- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Programming Challenges
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程挑战
- en: ”Beware of bugs in the above code; I have only proved it correct, not tried
    it.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “注意上述代码中的错误；我只证明了它是正确的，而没有尝试运行它。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Donald Knuth
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——唐纳德·克努特（Donald Knuth）
- en: In this chapter, we are going to deviate from professional programming and discuss
    the world of competitive programming and **programming challenges** .
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将偏离专业编程，讨论竞赛编程和**编程挑战**的世界。
- en: 'Programming challenges are problems that can be solved with a relatively short
    program. There are several websites that offer great collections of challenges.
    Most of them categorize challenges based on difficulty and other factors, such
    as:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编程挑战是可以用相对简短的程序解决的问题。有几个网站提供了大量的挑战集合。大多数网站根据难度和其他因素，如：
- en: The type of algorithm needed to solve the challenges.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决挑战所需的算法类型。
- en: The type of abstract data structures the challenges are about, like trees, linked
    lists, n-dimensional vectors, and so on.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战涉及的数据结构类型，如树、链表、n维向量等。
- en: The type of concrete data structures the challenges are about. For example,
    for Python, they could be lists, tuples, dictionaries, and so on.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战涉及的具体数据结构类型。例如，对于Python，它们可以是列表、元组、字典等。
- en: The type of approach needed to solve the challenges, such as dynamic programming,
    recursion, and so on.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决挑战所需的方法类型，如动态规划、递归等。
- en: This list is not fully comprehensive, but it gives an idea of what we can expect.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不全面，但它给出了我们可以期待的内容。
- en: Websites that offer programming challenges do it for various reasons. Some help
    programmers prepare for interviews, others do it for mere leisure, and others
    again do it as a way to teach programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 提供编程挑战的网站出于各种原因。有些帮助程序员准备面试，有些只是出于娱乐，还有些作为教授编程的方式。
- en: Some websites also host competitions, where the solutions provided by the participants
    are measured on execution speed, correctness, and memory footprint, just to name
    a few.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网站还举办比赛，其中参赛者提供的解决方案在执行速度、正确性和内存占用等方面进行衡量，仅举几例。
- en: The world of competitive programming is quite fun, and programming challenges
    are an excellent way to learn new languages and improve your programming skills.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 竞赛编程的世界非常有趣，编程挑战是学习新语言和提高编程技能的绝佳方式。
- en: In this chapter, we are going to solve two problems from **Advent of Code**
    ( https://adventofcode.com/ ), which is our favorite challenge website. Solving
    challenges is fun, and it is an efficient way for us to showcase several features
    of Python in a relatively short amount of code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决来自**Advent of Code**（https://adventofcode.com/）的两个问题，这是我们最喜欢的挑战网站。解决挑战很有趣，而且这是我们在相对较短的时间内展示Python几个特性的有效方式。
- en: Advent of Code
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Advent of Code
- en: 'Advent of Code was created by Eric Wastl in 2015. Quoting from the website:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 《Advent of Code》是由埃里克·瓦斯特尔（Eric Wastl）在2015年创建的。引用网站上的话：
- en: ”Advent of Code is an Advent calendar of small programming puzzles for a variety
    of skill sets and skill levels that can be solved in any programming language
    you like. People use them as interview prep, company training, university coursework,
    practice problems, a speed contest, or to challenge each other.
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “《Advent of Code》是一个包含各种技能水平和技能集的小型编程谜题日历，可以用你喜欢的任何编程语言解决。人们使用它们作为面试准备、公司培训、大学课程、练习问题、速度竞赛或相互挑战。”
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You don’t need a computer science background to participate - just a little
    programming knowledge and some problem-solving skills will get you pretty far.
    Nor do you need a fancy computer; every problem has a solution that completes
    in at most 15 seconds on ten-year-old hardware.”
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你不需要计算机科学背景来参与——只需要一点编程知识和一些解决问题的技能，你就能走得很远。你也不需要一台高级的电脑；每个问题都有一个解决方案，在十年前的硬件上最多只需要15秒就能完成。”
- en: Every problem has two parts. According to Eric, the first one is a way to make
    sure that you understand the assignment, and the second one is the actual problem.
    The second part is normally more challenging than the first one. Each problem
    is accompanied by input data that you can download from the website.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个问题有两个部分。根据埃里的说法，第一个部分是确保你理解任务的方式，第二个部分是实际问题。通常，第二部分比第一部分更具挑战性。每个问题都附有可以从网站上下载的输入数据。
- en: This website has some peculiar characteristics. Firstly, every problem is part
    of a story where the programmer – by solving the challenges – helps either Santa
    Claus or his helpers, the Elves, save Christmas. Each problem is therefore part
    of an adventure that lasts 25 days, from December 1 ^(st) to December 25 ^(th)
    . The presentation is infused with humor and each problem is unique and requires
    some degree of both logical and creative thinking. This is not that common a thing
    on many other similar websites, where challenges are normally much dryer, and
    their solutions often revolve around applying certain algorithms or using the
    appropriate data structures or patterns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网站有一些独特的特点。首先，每个问题都是故事的一部分，程序员通过解决挑战来帮助圣诞老人或他的助手，小精灵，拯救圣诞节。因此，每个问题都是一次持续25天的冒险的一部分，从12月1日到12月25日。展示中充满了幽默，每个问题都是独特的，需要一定程度的逻辑和创造性思维。这在许多其他类似网站上并不常见，那里的挑战通常非常枯燥，它们的解决方案通常围绕应用某些算法或使用适当的数据结构或模式。
- en: Before deciding to add this chapter, we spoke to Eric, and his only request
    was that we would not reproduce the full challenges verbatim. In accordance with
    that, we have abridged the problem statements so that we present only the problem
    instructions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定添加这一章节之前，我们与埃里克进行了交谈，他唯一的要求是我们不要逐字逐句地复制全部挑战。根据这一点，我们已缩减了问题陈述，只呈现问题指令。
- en: 'The solutions we are about to present are just one of the several ways in which
    these challenges can be solved. They are designed to allow us to discuss a few
    final concepts with you. Our advice is: after you have read this chapter, try
    and come up with your own solutions to the problems presented.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将呈现的解决方案只是解决这些挑战的几种方法之一。它们旨在让我们与您讨论一些最终概念。我们的建议是：在阅读完这一章后，尝试提出自己对所提问题的解决方案。
- en: Let us start.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Camel Cards
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 骆驼牌
- en: The first problem, *Camel Cards* , is from day 7, 2023. In this challenge, which
    you can find at [https://adventofcode.com/2023/day/7](https://adventofcode.com/2023/day/7)
    , we have to write a program that solves a variant of the poker game.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题，*骆驼牌*，来自2023年7月7日。在这个挑战中，你可以在[https://adventofcode.com/2023/day/7](https://adventofcode.com/2023/day/7)找到，我们必须编写一个程序来解决扑克游戏的变体。
- en: Part one – problem statement
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一部分 – 问题陈述
- en: 'This is an abridged version of the original text:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对原文的缩减版本：
- en: “In Camel Cards, you get a list of hands, and your goal is to order them based
    on the strength of each hand. A hand consists of five cards labeled one of `A`
    , `K` , `Q` , `J` , `T` , `9` , `8` , `7` , `6` , `5` , `4` , `3` , or `2` . The
    relative strength of each card follows this order, where `A` is the highest and
    `2` is the lowest.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “在骆驼牌中，你将得到一串手牌，你的目标是根据每手牌的强度来排序。一双手牌由五张标记为`A`、`K`、`Q`、`J`、`T`、`9`、`8`、`7`、`6`、`5`、`4`、`3`或`2`的牌组成。每张牌的相对强度遵循以下顺序，其中`A`为最高，`2`为最低。
- en: 'Every hand is exactly one type. From strongest to weakest, they are:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每一手牌都是一种类型。从最强到最弱，它们是：
- en: '**Five of a kind** , where all five cards have the same label: `AAAAA` .'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**五张同花**，其中所有五张牌都有相同的标记：`AAAAA`。'
- en: '**Four of a kind** , where four cards have the same label, and one card has
    a different label: `AA8AA` .'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四张同花**，其中四张牌有相同的标记，另一张牌有不同的标记：`AA8AA`。'
- en: '**Full house** , where three cards have the same label, and the remaining two
    cards share a different label: `23332` .'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**满贯**，其中三张牌有相同的标记，剩下的两张牌共享不同的标记：`23332`。'
- en: '**Three of a kind** , where three cards have the same label, and the remaining
    two cards are each different from any other card in the hand: `TTT98` .'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三张同花**，其中三张牌有相同的标记，剩下的两张牌与手中的任何其他牌都不同：`TTT98`。'
- en: '**Two pair** , where two cards share one label, two other cards share a second
    label, and the remaining card has a third label: `23432` .'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两对**，其中两张牌共享一个标记，另外两张牌共享第二个标记，剩下的牌有第三个标记：`23432`。'
- en: '**One pair** , where two cards share one label, and the other three cards have
    a different label from the pair and each other: `A23A4` .'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对**，其中两张牌共享一个标记，其他三张牌与这对牌和彼此都有不同的标记：`A23A4`。'
- en: '**High card** , where all cards’ labels are distinct: `23456` .'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高牌**，其中所有牌的标记都是不同的：`23456`。'
- en: Hands are primarily ordered based on type; for example, every full house is
    stronger than any three of a kind.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 手牌主要按类型排序；例如，每个满贯都比任何三张同花更强。
- en: If two hands have the same type, a second ordering rule takes effect. Start
    by comparing the first card in each hand. If these cards are different, the hand
    with the stronger first card is considered stronger. If the first card in each
    hand has the same label, however, then move on to considering the second card
    in each hand. If they differ, the hand with the higher second card wins; otherwise,
    continue with the third card in each hand, then the fourth, then the fifth.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两手牌类型相同，则生效第二个排序规则。首先比较每手牌中的第一张牌。如果这些牌不同，则拥有更强第一张牌的手牌被认为是更强的。如果每手牌中的第一张牌标签相同，则继续考虑每手牌中的第二张牌。如果它们不同，则拥有更高第二张牌的手牌获胜；否则，继续考虑每手牌中的第三张牌，然后是第四张，然后是第五张。
- en: So, `33332` and `2AAAA` are both *four of a kind* hands, but `33332` is stronger
    because its first card is stronger. Similarly, `77888` and `77788` are both a
    full house, but `77888` is stronger because its third card is stronger (and both
    hands have the same first and second card).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`33332`和`2AAAA`都是四条牌的手牌，但`33332`更强，因为它的第一张牌更强。同样，`77888`和`77788`都是满贯牌，但`77888`更强，因为它的第三张牌更强（而且这两手牌都有相同的第一张和第二张牌）。
- en: 'To play Camel Cards, you are given a list of hands and their corresponding
    bid (your puzzle input). For example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要玩骆驼牌，你会得到一串手牌及其相应的叫牌（你的谜题输入）。例如：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example shows five hands; each hand is followed by its bid amount. Each
    hand wins an amount equal to its bid multiplied by its rank, where the weakest
    hand gets rank 1, the second-weakest hand gets rank 2, and so on up to the strongest
    hand. Because there are five hands in this example, the strongest hand will have
    rank 5 and its bid will be multiplied by 5.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了五手牌；每手牌后面跟着它的叫牌金额。每手牌赢得的金额等于其叫牌金额乘以其排名，其中最弱的手牌排名为1，第二弱的手牌排名为2，依此类推，直到最强的手牌。因为在这个例子中有五手牌，所以最强的手牌将拥有排名5，其叫牌金额将乘以5。
- en: 'So, the first step is to put the hands in order of strength:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是将手牌按照力量顺序排列：
- en: '`32T3K` is the only one-pair hand, and the other hands are all a stronger type,
    so it gets rank 1.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`32T3K`是唯一的一对牌，而其他手牌都是更强类型，所以它获得排名1。'
- en: '`KK677` and `KTJJT` are both two pair. Their first cards both have the same
    label, but the second card of `KK677` is stronger ( `K` vs `T` ), so `KTJJT` gets
    rank 2 and `KK677` gets rank 3.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KK677`和`KTJJT`都是两对牌。它们的第一张牌标签都相同，但`KK677`的第二张牌更强（`K`对`T`），所以`KTJJT`获得排名2，`KK677`获得排名3。'
- en: '`T55J5` and `QQQJA` are both three of a kind. `QQQJA` has a stronger first
    card, so it gets rank 5 and `T55J5` gets rank 4.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T55J5`和`QQQJA`都是三张牌。`QQQJA`的第一张牌更强，所以它获得排名5，而`T55J5`获得排名4。'
- en: Now, you can determine the total winnings of this set of hands by adding up
    the result of multiplying each hand’s bid with its rank ( `765 * 1 + 220 * 2 +
    28 * 3 + 684 * 4 + 483 * 5` ). So, the total winnings in this example are `6440`
    .
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，你可以通过将每手牌的叫牌金额乘以其排名的结果相加来确定这组手牌的总共赢利（`765 * 1 + 220 * 2 + 28 * 3 + 684 *
    4 + 483 * 5`）。因此，在这个例子中的总共赢利是`6440`。
- en: Find the rank of every hand in your set. What are the total winnings?”
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 找出你手中每手牌的排名。总共赢利是多少？”
- en: Our job is to find the total winnings following the given instructions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是按照给定的说明找到总共赢利。
- en: Part one – solution
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一部分 – 解决方案
- en: 'The implementation of the solution is straightforward. Because part two of
    the problem is fairly similar to part one, we have encapsulated the common logic
    into one base class, `Solver` . This class provides all the methods we need to
    solve the problem, apart from one, `type()` , which is implemented in each of
    the child classes, `PartOne` and `PartTwo` . This is just one of many possible
    approaches to preventing code duplication. Let us see the first part of the code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的实施很简单。因为问题的第二部分与第一部分相当相似，所以我们已经将公共逻辑封装到一个基类`Solver`中。这个类提供了我们解决问题所需的所有方法，除了一个，即`type()`方法，它在每个子类`PartOne`和`PartTwo`中实现。这是防止代码重复的许多可能方法之一。让我们看看代码的第一部分：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We import `Counter` and `cmp_to_key()` from the standard library and `get_input()`
    from the `util.py` module. The latter is a helper that reads the input file and
    returns a list of strings, like `["9A35J 469", "75T32 237", ...]` .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从标准库中导入`Counter`和`cmp_to_key()`，从`util.py`模块中导入`get_input()`。后者是一个辅助函数，它读取输入文件并返回一个字符串列表，例如`["9A35J
    469", "75T32 237", ...]`。
- en: 'We define the `Solver` class, which is only partially reproduced here, which
    reads in the inputs during the initialization and contains the `solve()` method,
    which runs the algorithm. The steps are simple: we use the `parse_line()` method
    to convert from a list of strings to a dictionary ( `hands` ) whose keys are the
    hands, and whose values are their respective bids, already converted to integers.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`Solver`类，这里只部分展示了该类，它会在初始化时读取输入，并包含一个`solve()`方法，该方法运行算法。步骤很简单：我们使用`parse_line()`方法将字符串列表转换为字典（`hands`），其中键是手牌，值是它们各自的出价，这些出价已经被转换为整数。
- en: After converting the input data, we create a list of hands, sorted by their
    rank, which is calculated according to the rules given by the problem statement.
    We will analyze the custom `cmp()` method in a moment. For now, just notice how
    it is used, to perform the sorting. Since a comparator takes two objects to compare,
    it is not suitable as an argument to the `key` parameter of the `sorted()` function.
    For this reason, Python provides the `cmp_to_key()` function, which takes a comparator
    function as input and produces an object that can be used as a key for sorting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换输入数据后，我们创建了一个手牌列表，按照其等级排序，等级是根据问题陈述中给出的规则计算的。我们将在稍后分析自定义的`cmp()`方法。现在，只需注意它是如何被使用的，用于执行排序。由于比较器需要两个对象进行比较，所以它不适合作为`sorted()`函数的`key`参数的参数。因此，Python提供了一个`cmp_to_key()`函数，它接受一个比较器函数作为输入，并产生一个可以作为排序键的对象。
- en: After creating a sorted list of hands, we return the sum of all the products
    between each hand’s rank, and its bid.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建好排序好的手牌列表后，我们返回每对手牌的等级和其出价之间的所有乘积的总和。
- en: 'Let us examine the more interesting part of this class now:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来检查这个类的更有趣的部分：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the rest of the class code, we defined the custom comparator `cmp()` . It
    takes two hands and performs the comparison according to the problem’s rules.
    First, we calculate the type of each hand. If the types are different, we return
    `-1` if `hand2` is stronger than `hand1` , or `1` in the opposite case. Should
    the type of both hands be the same, we need to check the strength of each card.
    Depending on the result of this check, we return `-1` or `1` using the same criteria
    as before. For completeness, if both the type and strength of the two hands are
    the same, we return `0` . We know, from the problem statement, that this latter
    scenario is never going to happen, otherwise the final ranking might depend on
    the input order.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的其余代码中，我们定义了一个自定义比较器`cmp()`。它接受两个手牌并按照问题的规则进行比较。首先，我们计算每个手牌的类型。如果类型不同，如果`hand2`比`hand1`强，则返回`-1`，反之则返回`1`。如果两个手牌的类型相同，我们需要检查每张牌的强度。根据检查结果，我们使用之前相同的标准返回`-1`或`1`。为了完整性，如果两个手牌的类型和强度都相同，则返回`0`。我们知道，根据问题陈述，这种情况永远不会发生，否则最终的排名可能会依赖于输入顺序。
- en: The comparator is using the `type()` method, whose logic is not implemented
    in this class. Since the strengths of the card and the calculation of the hands’
    types is what changes between part one and part two, we implement them in two
    dedicated classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 比较器正在使用`type()`方法，其逻辑没有在这个类中实现。由于牌的强度和手牌类型的计算在第一部分和第二部分之间是不同的，所以我们把它们实现在了两个专门的类中。
- en: 'Let us see the implementation for `PartOne` :'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`PartOne`的实现：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `PartOne` , we set the `strengths` class attribute and implement the `type()`
    method. When we call it with a few example hands, these are the results:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PartOne`中，我们设置了`strengths`类属性并实现了`type()`方法。当我们用几个示例手牌调用它时，这些是结果：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is how `type()` works: the hand is first fed to a `Counter` . This object
    will count how many occurrences there are of each character in the hand. In the
    first example, the result of `Counter("KK444")` is `{''K'': 2, ''4'': 3}` , which
    is a *dict-like* object. As expected, we have two `K` s and three `4` s. Using
    the `most_common()` method, we can get a list of the values of that object, sorted
    from highest to lowest. This will produce the result in the example above: `[3,
    2]` . Those lists, `[1, 1, 1, 1, 1]` , `[3, 2]` , `[4, 1]` , and so on, can be
    compared to one another to calculate the ranks. We do this when we calculate `sorted_hands`
    in the `solve()` method.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '这是`type()`的工作方式：首先将手牌输入到`Counter`中。这个对象将计算手牌中每个字符出现的次数。在第一个例子中，`Counter("KK444")`的结果是`{''K'':
    2, ''4'': 3}`，这是一个类似字典的对象。正如预期的那样，我们有两个`K`和三个`4`。使用`most_common()`方法，我们可以获取该对象的值的列表，按从高到低的顺序排序。这将产生上面的结果：`[3,
    2]`。这些列表，如`[1, 1, 1, 1, 1]`、`[3, 2]`、`[4, 1]`等，可以相互比较以计算等级。我们在`solve()`方法中计算`sorted_hands`时这样做。'
- en: 'Now, it is time to create an instance of `PartOne` and run its `solve()` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建一个`PartOne`的实例并运行它的`solve()`方法了：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that we set `PartOne.strengths` to the string `"` `23456789TJQKA"` .
    That is the order in which strengths are to be evaluated, according to the problem
    statement, with `2` being the weakest and `A` being the strongest. Expressing
    their relative weight using their position is what enabled us to compare them,
    within `cmp()` , by using their index in the string. The higher the index, the
    stronger the card.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`PartOne.strengths`设置为字符串`"` `23456789TJQKA"`。这是根据问题陈述评估强度的顺序，其中`2`是最弱的，`A`是最强的。使用它们的位置来表示它们的相对权重，使我们能够在`cmp()`中使用它们的索引进行比较。索引越高，牌越强。
- en: Part one is now concluded, so let us move on to part two.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分现在已经结束，让我们继续到第二部分。
- en: Part two – problem statement
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二部分 – 问题陈述
- en: When we input the correct solution for part one on the website, we can access
    part two. Now the rules are changing a little bit because the joker card is introduced
    in the game.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在网站上输入第一部分的正确解决方案时，我们可以访问第二部分。现在规则有所改变，因为游戏中引入了王牌牌。
- en: '“Now, `J` cards are jokers – wildcards that can act like whatever card would
    make the hand the strongest type possible. To balance this, `J` cards are now
    the weakest individual cards, weaker even than `2` . The other cards stay in the
    same order: `A` , `K` , `Q` , `T` , `9` , `8` , `7` , `6` , `5` , `4` , `3` ,
    `2` , `J` .'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “现在，`J`牌是王牌——可以像任何牌一样行动的百搭牌。为了平衡这一点，`J`牌现在是单个牌中最弱的，甚至比`2`还弱。其他牌保持相同的顺序：`A`、`K`、`Q`、`T`、`9`、`8`、`7`、`6`、`5`、`4`、`3`、`2`、`J`。
- en: '`J` cards can pretend to be whatever card is best for the purpose of determining
    hand type; for example, `QJJQ2` is now considered four of a kind. However, for
    the purpose of breaking ties between two hands of the same type, `J` is always
    treated as `J` , not the card it is pretending to be: `JKKK2` is weaker than `QQQQ2`
    because `J` is weaker than `Q` .'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`J`牌可以假装成任何最适合确定手牌类型的牌；例如，`QJJQ2`现在被认为是四条。然而，为了在相同类型的两张手牌之间打破平局，`J`始终被当作`J`来处理，而不是它假装成的牌：`JKKK2`比`QQQQ2`弱，因为`J`比`Q`弱。'
- en: 'Now, the above example goes very differently:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，上面的例子会有很大的不同：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`32T3K` is still the only one-pair hand; it does not contain any jokers, so
    its strength does not increase.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`32T3K`仍然是唯一的单对牌；它不包含任何王牌，所以它的强度没有增加。'
- en: '`KK677` is now the only two pair, making it the second-weakest hand.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KK677`现在是唯一的两对牌，使其成为第二最弱的牌。'
- en: '`T55J5` , `KTJJT` , and `QQQJA` are now all four of a kind! `T55J5` gets rank
    3, `QQQJA` gets rank 4, and `KTJJT` gets rank 5.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T55J5`、`KTJJT`和`QQQJA`现在都是四条！`T55J5`得到第3名，`QQQJA`得到第4名，`KTJJT`得到第5名。'
- en: With the new joker rule, the total winnings in this example are `5905` . Using
    the new joker rule, find the rank of every hand in your set. What are the new
    total winnings?”
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的王牌规则，本例中的总奖金为`5905`。使用新的王牌规则，找出你手中每张牌的等级。新的总奖金是多少？”
- en: Let us dive into the solution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到解决方案中。
- en: Part two – solution
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二部分 – 解决方案
- en: For this part, we only need to provide the correct new set of strengths and
    a different implementation of the `type()` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这部分，我们只需要提供正确的新的一组强度和一个不同的`type()`方法实现。
- en: 'Let us see the code, which is a continuation from the same module:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码，这是从同一个模块继续的：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The above is all we need to solve the second part of the problem. The new version
    of the `type()` method works in this way: we still feed the `hand` string to a
    `Counter` but, this time, we remove any jokers from the hand. We sort the values
    in reverse order again, using the `most_common()` method. At this point, we end
    up in one of these scenarios:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容是我们解决问题第二部分所需的所有内容。`type()` 方法的新的版本是这样工作的：我们仍然将 `hand` 字符串喂给一个 `Counter`，但这次我们从手牌中移除了任何王牌。我们再次使用
    `most_common()` 方法按逆序排序值。在这个时候，我们最终会遇到以下这些情况之一：
- en: For a hand solely made of jokers, `"JJJJJ"` , `h` will be empty, so `type()`
    returns `[5]` . This is correct because the highest rank given this hand is a
    *five of a kind* .
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于完全由王牌组成的手牌 `"JJJJJ"`，`h` 将为空，因此 `type()` 返回 `[5]`。这是正确的，因为这个手牌的最高等级是 *五带一*。
- en: For a hand with no jokers, the logic behaves like that of `PartOne.type()` .
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于没有王牌的手牌，逻辑行为类似于 `PartOne.type()` 。
- en: For a hand with at least one joker, but less than five, we first calculate its
    type ignoring the jokers. After that, we return an amended version of that result,
    where the first element is incremented by the number of jokers in the hand. For
    example, the hand `"KKJJ4"` will produce (ignoring the jokers) the list `[2, 1]`
    (two `K` s and one `4` ). The smartest thing to do, to maximize its rank, is to
    use the two jokers as if they were `K` s. That would mean having the equivalent
    hand `"KKKK4"` . To do this, we add 2 (the number of jokers) to the first element
    in the list `[2, 1]` , so we return `[4, 1]` , which is the correct type for the
    `"KKKK4"` hand.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于至少有一张王牌但不到五张的手牌，我们首先忽略王牌计算其类型。之后，我们返回一个修改过的结果版本，其中第一个元素增加手牌中王牌的数量。例如，手牌 `"KKJJ4"`
    将产生（忽略王牌）列表 `[2, 1]`（两个 `K` 和一个 `4`）。为了最大化其等级，最聪明的事情是将两张王牌当作 `K` 使用。这意味着拥有等效的手牌
    `"KKKK4"`。为此，我们将2（王牌的数量）加到列表 `[2, 1]` 的第一个元素上，因此我们返回 `[4, 1]`，这是 `"KKKK4"` 手牌的正确类型。
- en: The only other important detail in `PartTwo` is the new strengths, which are
    now `"J23456789TQKA"` . For this part, the strengths also consider the joker card,
    which is the weakest, and therefore goes at the lowest index in the string.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`PartTwo` 中唯一另一个重要的细节是新的大牌顺序，现在是 `"J23456789TQKA"`。对于这部分，大牌顺序也考虑了王牌牌，它是最弱的，因此放在字符串中的最低索引位置。'
- en: This concludes the second part of the problem. We chose this problem because
    it allowed us to show you how you can use OOP to prevent the duplication of code,
    as well as for the use of `Counter` and `cmp_to_key()` .
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了问题的第二部分。我们选择这个问题是因为它允许我们向你展示如何使用面向对象编程（OOP）来防止代码重复，以及使用 `Counter` 和 `cmp_to_key()`。
- en: You can find the inputs for this problem in the `ch17` folder of the book’s
    source code, as well as the implementation of the `get_input()` function, in the
    `util.py` module.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书籍源代码的 `ch17` 文件夹中找到这个问题的输入，以及 `util.py` 模块中 `get_input()` 函数的实现。
- en: Now, let’s move on to the second challenge.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行第二个挑战。
- en: Cosmic Expansion
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宇宙膨胀
- en: The second problem, *Cosmic Expansion* , is from day 11, 2023. In this challenge,
    which you can find at [https://adventofcode.com/2023/day/11](https://adventofcode.com/2023/day/11)
    , we need to expand a universe and calculate the length of the shortest path between
    all pairs of galaxies.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题，*宇宙膨胀*，来自2023年11月11日。在这个挑战中，你可以在 [https://adventofcode.com/2023/day/11](https://adventofcode.com/2023/day/11)
    找到，我们需要扩展一个宇宙并计算所有星系对之间最短路径的长度。
- en: Part one – problem statement
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一部分 – 问题陈述
- en: 'Here is an abridged version of the original text:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是原始文本的简略版：
- en: '“The researcher has collected a bunch of data and compiled the data into a
    single giant image (your puzzle input). The image includes empty space ( `.` )
    and galaxies ( `#` ). For example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: “研究员收集了一堆数据，并将数据编译成一张巨大的图像（你的谜题输入）。图像包括空白空间（`.`）和星系（`#`）。例如：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The researcher is trying to figure out the sum of the lengths of the shortest
    path between every pair of galaxies. However, there is a catch: the universe expanded
    in the time it took the light from those galaxies to reach the observatory.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 研究员正在试图找出每对星系之间最短路径长度的总和。然而，有一个陷阱：在那些星系的光到达观测站之前，宇宙已经膨胀了。
- en: 'Only some space expands. In fact, any rows or columns that contain no galaxies
    should all be twice as big. In the above example, three columns and two rows contain
    no galaxies. These rows and columns need to be twice as big; the result of cosmic
    expansion therefore looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 只有部分空间会膨胀。实际上，任何包含没有星系的行或列都应该扩大一倍。在上面的例子中，有三列和两行没有星系。这些行和列需要扩大一倍；因此，宇宙膨胀的结果看起来像这样：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Equipped with this expanded universe, the shortest path between every pair
    of galaxies can be found. It can help to assign every galaxy a unique number.
    In these 9 galaxies, there are 36 pairs. Only count each pair once; order within
    the pair does not matter. For each pair, find any shortest path between the two
    galaxies using only steps that move up, down, left, or right exactly one • or
    # at a time. (The shortest path between two galaxies is allowed to pass through
    another galaxy.)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '配备了这个扩展宇宙，可以找到每对星系之间的最短路径。这有助于为每个星系分配一个唯一的数字。在这 9 个星系中，有 36 对。只计算每对一次；对内的顺序不重要。对于每一对，使用只向上、向下、向左或向右移动一步的步骤（每次移动正好一步或
    #）来找到两个星系之间的任何最短路径。（两个星系之间的最短路径允许穿过另一个星系。）'
- en: 'Assigning unique numbers, and highlighting with *x’s* one of the shortest paths
    from galaxy 5 to galaxy 9, we get this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 分配唯一的数字，并用 *x* 突出显示从星系 5 到星系 9 的其中一条最短路径，我们得到这个：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It takes a minimum of 9 steps to get from galaxy 5 to galaxy 9 (the 8 *x’s*
    plus the step onto galaxy 9 itself). Here are some other examples of shortest
    path lengths:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从星系 5 到星系 9（8 个 *x* 加上进入星系 9 的步骤）至少需要 9 步。这里有一些其他最短路径长度的例子：
- en: '*Between galaxy 1 and galaxy 7: 15*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*在星系 1 和星系 7 之间：15*'
- en: '*Between galaxy 8 and galaxy 9: 5*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*在星系 8 和星系 9 之间：5*'
- en: In this example, after expanding the universe, the sum of the shortest path
    between all 36 pairs of galaxies is 374. Expand the universe, then find the length
    of the shortest path between every pair of galaxies. What is the sum of these
    lengths?”
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在扩展宇宙之后，所有 36 对星系之间最短路径的总和是 374。扩展宇宙，然后找到每对星系之间最短路径的长度。这些长度的总和是多少？”
- en: Let us now see the solution for this part.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看这一部分的解答。
- en: Part one – solution
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一部分 – 解答
- en: 'Let us start by defining the basic blocks:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义基本块：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code begins with some imports. We will need to calculate all pairs of galaxies,
    which can be accomplished with `itertools.combinations()` . We also need `NamedTuple`
    and `Self` , from the `typing` module, and, of course, our custom `get_input()`
    function to read the input file, which we assign the name `universe` .
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从一些导入开始。我们需要计算所有星系对，这可以通过使用 `itertools.combinations()` 来实现。我们还需要从 `typing`
    模块中的 `NamedTuple` 和 `Self` ，以及当然，我们的自定义 `get_input()` 函数来读取输入文件，我们将它命名为 `universe`
    。
- en: In this problem, we have chosen to create a `Galaxy` class, which represents
    a point in space. It inherits from `NamedTuple` , which provides some helpful
    features out of the box. Other suitable choices for this data are `dataclasses.dataclass`
    , `complex` , or even just a bare custom class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们选择创建一个 `Galaxy` 类，它代表空间中的一个点。它从 `NamedTuple` 继承，这提供了一些开箱即用的有用功能。其他适合这种数据的选择是
    `dataclasses.dataclass` ， `complex` ，或者甚至只是一个裸露的自定义类。
- en: '`Galaxy` has two coordinates, `x` and `y` ; it defines an `expand()` method,
    which returns a new `Galaxy` with shifted coordinates, and a `manhattan()` method,
    which calculates the distance between two galaxies using **Taxicab Geometry**
    . To learn more about it, please visit [https://en.wikipedia.org/wiki/Taxicab_geometry](https://en.wikipedia.org/wiki/Taxicab_geometry)
    . Suffice it to say, it is the way in which distances are calculated when movement
    is constrained to the vertical and horizontal directions on an integer plane.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Galaxy` 有两个坐标， `x` 和 `y` ；它定义了一个 `expand()` 方法，该方法返回具有偏移坐标的新 `Galaxy` ，以及一个
    `manhattan()` 方法，该方法使用 **出租车几何** 来计算两个星系之间的距离。要了解更多信息，请访问 [https://en.wikipedia.org/wiki/Taxicab_geometry](https://en.wikipedia.org/wiki/Taxicab_geometry)
    。简单来说，这是在整数平面上垂直和水平方向上受到运动限制时计算距离的方式。'
- en: We also define an `ExpansionCoeff` class to represent an expansion coefficient.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个 `ExpansionCoeff` 类来表示膨胀系数。
- en: 'Here is the main part of the solver logic:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是求解器逻辑的主要部分：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `solve()` function calculates the expanded universe and returns the sum
    of the shortest paths between each pair. The main task is performed in the `expand_universe()`
    method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve()` 函数计算扩展宇宙并返回每对之间最短路径的总和。主要任务在 `expand_universe()` 方法中执行。'
- en: 'Here, we first parse the universe, to extract a set of `Galaxy` instances.
    Expansion is performed in two steps: first, we expand along the vertical direction,
    then the horizontal. Because the universe is a list of strings, it can be seen
    as a two-dimensional matrix. To expand it along two orthogonal directions we have
    two choices: one would be to write a separate function for each direction and
    call them passing the universe as an argument. The second option, which is what
    we implemented, is to write the expansion code only for the vertical direction
    and call it once with the universe as it is, and once more passing the transposed
    version of the universe. This does the equivalent job of expanding along the horizontal
    direction.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先解析宇宙，提取一组`Galaxy`实例。扩展分为两个步骤：首先，我们沿着垂直方向扩展，然后是水平方向。因为宇宙是一个字符串列表，它可以被视为一个二维矩阵。为了沿两个正交方向扩展，我们有两种选择：一种是为每个方向编写一个单独的函数并传递宇宙作为参数。第二种选择，即我们实现的，是只为垂直方向编写扩展代码，一次使用原始宇宙调用它，然后再次传递宇宙的转置版本。这相当于沿水平方向扩展。
- en: If you are not familiar with the concept of a transposed matrix, you can learn
    about it at [https://en.wikipedia.org/wiki/Transpose](https://en.wikipedia.org/wiki/Transpose)
    . Simply put, the transposed version of a matrix is the result of flipping that
    matrix over its diagonal. The result has the original rows as columns, and vice
    versa.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉转置矩阵的概念，你可以在[https://en.wikipedia.org/wiki/Transpose](https://en.wikipedia.org/wiki/Transpose)上了解它。简单来说，矩阵的转置版本就是将矩阵沿对角线翻转的结果。结果是原始的行变成了列，反之亦然。
- en: In the highlighted row, you can see how the transposed version of the universe
    is calculated. We could have used just `zip(*universe)` , but that would have
    required some tweaking to the type annotations, as that does not return a list
    of strings. We opted to comply with simpler type annotations and created the transposed
    version of the universe as a list of strings instead for consistency with the
    original version of the universe.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在高亮行中，你可以看到如何计算宇宙的转置版本。我们本可以使用`zip(*universe)`，但这将需要对类型注解进行一些调整，因为这样不会返回一个字符串列表。我们选择遵守更简单的类型注解，并将宇宙的转置版本作为一个字符串列表来保持与原始宇宙版本的一致性。
- en: It is worth mentioning that, in professional code, the better choice would be
    to adapt annotations to the code, rather than the other way around, but in this
    case, we wanted to keep things as simple as possible, in terms of readability.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在专业代码中，更好的选择是将注解适应到代码，而不是相反，但在这个案例中，我们希望尽可能保持代码的简洁性，以便于阅读。
- en: One word about the `coords_to_expand()` method. The algorithm we implemented
    to expand the universe in a direction relies on the fact that the coordinates
    to expand are sorted. You can see that, by looping on the universe from top to
    bottom and returning a list of coordinates of the rows that contain no galaxies,
    we are still producing a sorted list without explicitly having to call `sorted()`
    on it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`coords_to_expand()`方法，我们实现宇宙扩展方向的算法依赖于坐标是排序的事实。你可以看到，通过从上到下遍历宇宙并返回不包含星系的行的坐标列表，我们仍然在不需要显式调用`sorted()`的情况下产生了一个排序列表。
- en: 'The last bit of code we need is the part that does the one-dimensional expansion:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一段代码是执行一维扩展的部分：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `expand_dimension()` function may not be so straightforward, so let us walk
    through it line by line. We start by getting the dimension that we are supposed
    to expand on by inspecting the `expansion_coeff` object. If its `y` attribute
    is `0` , we are expanding on the `x` dimension and, conversely, if the `x` attribute
    is `0` , we are expanding on the `y` dimension.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`expand_dimension()`函数可能不是那么直接，让我们逐行分析它。我们首先通过检查`expansion_coeff`对象来获取我们应该扩展的维度。如果它的`y`属性是`0`，我们就在`x`维度上扩展，反之，如果`x`属性是`0`，我们就在`y`维度上扩展。'
- en: We then enter a nested loop. The outer part of it runs through all the coordinates
    that we need to expand. We loop through them in reverse order so we don’t move
    galaxies past coordinates that we have not yet considered, which could result
    in moving a galaxy more than it should have been.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进入一个嵌套循环。它的外层遍历所有需要扩展的坐标。我们以相反的顺序遍历它们，这样我们就不会将星系移动到我们尚未考虑的坐标上，这可能会导致星系移动超过应有的距离。
- en: Before entering the inner loop, we create a set, `new_galaxies` , which will
    contain all the galaxies after the current coordinate has been used. Some of the
    new galaxies might be shifted, while others might not.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入内部循环之前，我们创建一个集合，`new_galaxies`，它将包含当前坐标被使用后的所有星系。其中一些新星系可能会移动，而另一些则可能不会。
- en: After the inner loop has terminated, we assign `galaxies` to be `new_galaxies`
    , and move on to the next coordinate to expand. At the end of this process, all
    galaxies will have been shifted appropriately.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 内部循环结束后，我们将`galaxies`赋值为`new_galaxies`，然后移动到下一个坐标进行扩展。在这个过程中，所有星系都将被适当地移动。
- en: 'And that is it. All we need to do now is to call the solver with the correct
    coefficient:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们现在只需要调用带有正确系数的求解器：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will give us the solution for part one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出第一部分的解决方案。
- en: Part two – problem statement
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二部分 – 问题陈述
- en: 'As with the first problem, part two is just a slight variation of part one.
    Let us see the problem statement:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个问题一样，第二部分只是第一部分的微小变化。让我们看看问题陈述：
- en: “Now, instead of the expansion you did before, make each empty row or column
    one million times larger. That is, each empty row should be replaced with 1,000,000
    empty rows, and each empty column should be replaced with 1,000,000 empty columns.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: “现在，不再使用你之前所做的扩展，将每个空行或列扩大一百万倍。也就是说，每个空行应替换为100万个空行，每个空列应替换为100万个空列。
- en: (In the example above, if each empty row or column were merely 100 times larger,
    the sum of the shortest paths between every pair of galaxies would be 8,410. However,
    your universe will need to expand far beyond these values.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: （在上面的例子中，如果每个空行或列只是100倍更大，每对星系之间最短路径的总和将是8,410。然而，你的宇宙需要扩展到远超过这些值。）
- en: Starting with the same initial image, expand the universe according to these
    new rules, then find the length of the shortest path between every pair of galaxies.
    What is the sum of these lengths?”
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从相同的初始图像开始，根据这些新规则扩展宇宙，然后找到每对星系之间最短路径的长度。这些长度的总和是多少？”
- en: Quite often, in Advent of Code, part two is where we realize whether the implementation
    of part one is good enough. In this case, because we have chosen to represent
    galaxies using a set of `Galaxy` objects, rather than sticking with a list of
    strings (or a list of lists), we will not have to change anything in our code,
    other than the expansion coefficient we pass the `solve()` function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Advent of Code中，通常在第二部分我们会意识到第一部分的实现是否足够好。在这种情况下，因为我们选择使用一组`Galaxy`对象来表示星系，而不是坚持使用字符串列表（或列表的列表），我们不需要在我们的代码中做任何改变，除了传递给`solve()`函数的扩展系数。
- en: Part two – solution
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二部分 – 解答
- en: 'Let us see how we call `solve()` for the second part:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何调用`solve()`来解决第二部分的：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And that is it. Now, we pass 1,000,000, instead of 2, and we get the correct
    result for part two.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，我们传递1,000,000，而不是2，我们就能得到第二部分的正确结果。
- en: The key takeaway is that, by choosing the right data structure in part one,
    we can expand the universe by any coefficient without incurring any penalty.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的收获是，通过在第一部分选择合适的数据结构，我们可以通过任何系数扩展宇宙，而不会产生任何惩罚。
- en: The technique we used is a version of a concept called **Sparse Matrix** , or
    **Sparse Array** . You can learn about it at [https://en.wikipedia.org/wiki/Sparse_matrix](https://en.wikipedia.org/wiki/Sparse_matrix)
    .
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的技术是称为**稀疏矩阵**或**稀疏数组**的概念的一个版本。你可以在[https://en.wikipedia.org/wiki/Sparse_matrix](https://en.wikipedia.org/wiki/Sparse_matrix)上了解更多信息。
- en: When dealing with data in the form of a matrix, normally the data structure
    we would use is a list of lists (or, as in the case of this problem, a list of
    strings). However, sometimes the matrix is mostly empty, and the important data
    is just a small fraction of the whole.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理矩阵形式的数据时，我们通常使用的数据结构是列表的列表（或者，在这个问题的情况下，是字符串的列表）。然而，有时矩阵大部分是空的，而重要的数据只是整个数据的一小部分。
- en: In the problem’s universe, for example, galaxies are just a small portion of
    the whole universe, which is otherwise empty. It is, therefore, appropriate to
    represent them not by using a list of lists (or a list of strings) but by choosing
    a different data structure. Here, we have chosen a set of coordinates because
    it suffices to retain all the information we need.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题的宇宙中，例如，星系只是整个宇宙的一小部分，其余部分是空的。因此，用列表的列表（或字符串的列表）来表示它们是不合适的，我们选择不同的数据结构。在这里，我们选择了一组坐标，因为它足以保留我们所需的所有信息。
- en: 'In other scenarios, a dictionary might have been necessary. Say, for example,
    that each galaxy had a luminosity factor associated with it. Using a dictionary,
    we could have represented each galaxy by setting coordinates as keys, and luminosity
    factors as values. The main point would still be the same: we would only be storing
    the galaxy data, but none of the empty space that we would have had to store if
    we were using a list of lists.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，可能需要一个字典。比如说，每个星系都有一个与之相关的亮度因子。使用字典，我们可以通过设置坐标作为键，亮度因子作为值来表示每个星系。主要观点仍然是相同的：我们只会存储星系数据，而不会存储如果我们使用列表的列表必须存储的空空间。
- en: As we mentioned in earlier chapters, choosing the right data structures is of
    paramount importance. In this problem, had we chosen to create an expanded version
    of the universe by storing it in another list of strings (or a list of lists),
    it would have been fine for part one, but not so for part two.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中提到的，选择合适的数据结构至关重要。在这个问题中，如果我们选择通过将宇宙存储在另一个字符串列表（或列表的列表）中创建一个扩展版本的宇宙，那么对于第一部分来说是可以的，但对于第二部分来说就不行了。
- en: Final considerations
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终考虑
- en: Before we end this chapter, here are some final considerations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，这里有一些最后的考虑。
- en: First of all, as mentioned at the beginning of this chapter, the solutions to
    the two problems we presented do not claim to be the most elegant, nor the most
    efficient. There are faster algorithms we could have written that would perform
    much better on inputs of larger size.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如本章开头所提到的，我们提出的两个问题的解决方案并不声称是最优雅的，也不是最有效的。我们本可以编写更快的算法，在处理更大规模的数据输入时表现会更好。
- en: Moreover, the way in which we structured the code, using OOP for *Camel Cards*
    and a functional approach for *Cosmic Expansion* , was just to make sure we could
    show you different ways of structuring code to solve a given problem.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们结构代码的方式，使用面向对象编程来处理*骆驼卡*和使用函数式方法来处理*宇宙扩张*，只是为了确保我们可以向您展示解决给定问题的不同代码结构方式。
- en: Furthermore, we could have chosen other ways to split the solutions into classes
    and functions, and we could have also used different data structures to represent
    the data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以选择其他方法将解决方案拆分为类和函数，我们还可以使用不同的数据结构来表示数据。
- en: We have tried to prioritize readability and simplicity, overall, while still
    offering you a peek into concepts we have not been able to explore in the rest
    of the book, such as the use of custom comparator functions, or sparse matrixes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尽量优先考虑可读性和简洁性，同时仍然向您展示我们在本书其他部分未能探索的概念，例如使用自定义比较函数或稀疏矩阵。
- en: We hope you have enjoyed this brief detour from *professional Python* , and
    we also hope to have sparked some curiosity in you.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您喜欢这次从*专业Python*的短暂偏离，我们也希望激发您的一些好奇心。
- en: Our advice is to sign up to Advent of Code, and at least try to come up with
    your own solutions for the problems in this chapter. Try to use OOP where we did
    not, and vice versa. Try to use different algorithms and other ways to structure
    the data. Most of all, have fun. Solving programming challenges can be lots of
    fun and, if you are like us, quite addictive!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建议是注册 Advent of Code，并至少尝试为本章中的问题提出自己的解决方案。尝试在我们没有使用面向对象编程的地方使用它，反之亦然。尝试使用不同的算法和其他方式来组织数据。最重要的是，享受乐趣。解决编程挑战可以非常有趣，如果你像我们一样，可能会上瘾！
- en: We end this chapter with a list of programming challenge websites that we hope
    you will find interesting.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个编程挑战网站的列表结束本章，我们希望您会发现这些网站很有趣。
- en: Other programming challenge websites
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他编程挑战网站
- en: Here is a list of some of our favorite challenge websites. Some of them are
    free, some are not. Some are math oriented, while others are more focused on pure
    programming. Some help with interview preparation, while others are just for fun.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们最喜欢的挑战网站列表。其中一些是免费的，一些不是。有些是数学导向的，而有些则更专注于纯编程。有些有助于面试准备，而有些只是为了娱乐。
- en: 'Interview preparation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 面试准备：
- en: 'LeetCode: [https://leetcode.com/](https://leetcode.com/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LeetCode: [https://leetcode.com/](https://leetcode.com/)'
- en: 'HackerRank: [https://www.hackerrank.com/](https://www.hackerrank.com/)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'HackerRank: [https://www.hackerrank.com/](https://www.hackerrank.com/)'
- en: 'CodeSignal: [https://codesignal.com/](https://codesignal.com/)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CodeSignal: [https://codesignal.com/](https://codesignal.com/)'
- en: 'Coderbyte: [https://coderbyte.com/](https://coderbyte.com/)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Coderbyte: [https://coderbyte.com/](https://coderbyte.com/)'
- en: 'HackerEarth: [https://www.hackerearth.com/](https://www.hackerearth.com/)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'HackerEarth: [https://www.hackerearth.com/](https://www.hackerearth.com/)'
- en: 'Competitive programming:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 竞赛编程：
- en: 'Codeforces: [https://codeforces.com/](https://codeforces.com/)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Topcoder: [https://www.topcoder.com/](https://www.topcoder.com/)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AtCoder: [https://atcoder.jp/](https://atcoder.jp/)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sphere Online Judge (SPOJ): [https://www.spoj.com/](https://www.spoj.com/)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Skill building and learning:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Project Euler: [https://projecteuler.net/](https://projecteuler.net/) ( *Fabrizio
    used to be a member of Project Euler’s dev team. He created some problems and
    collaborated on others* )'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercism: [https://exercism.org/](https://exercism.org/)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Codewars: [https://www.codewars.com/](https://www.codewars.com/)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fun and community:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Advent of Code: [https://adventofcode.com/](https://adventofcode.com/)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CodinGame: [https://www.codingame.com/](https://www.codingame.com/)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Machine learning:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Kaggle: [https://www.kaggle.com/](https://www.kaggle.com/)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We hope you will take some time to explore a few of them; they will help you
    keep your mind sharp and brush up, or learn, algorithms, data structures, and
    new languages.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the world of programming challenges. We have
    solved two problems from the Advent of Code website and learned a little bit about
    a different universe in which programming is used for learning, fun, preparing
    for interviews, and competitions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about custom comparator functions and sparse matrixes, and saw
    how some of the concepts we learned in previous chapters can be applied to solve
    a problem.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Now, our journey together has come to an end. It is up to you to keep the momentum
    up and make the most of what you learned in these pages. We tried to equip you
    with a solid foundation that should be enough to support you while you take the
    next steps, both in terms of knowledge and in terms of methodologies.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: We hope to have been successful in conveying our passion and experience to you,
    and trust that it will accompany you wherever you go from here.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: We hope you enjoyed reading this book, and best of luck!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_17.xhtml)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code1190011064170264681.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: '![img](img/New_Packt_Logo1.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: '[packt.com](http://packt.com)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Why subscribe?
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your learning with Skill Plans built especially for you
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a free eBook or video every month
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully searchable for easy access to vital information
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At [www.packt.com](http://www.packt.com) , you can also read a collection of
    free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Other Books You May Enjoy
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[![img](img/9781835466384.jpg)](https://www.packtpub.com/en-in/product/modern-python-cookbook-9781835460757)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**Modern Python Cookbook**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Steven F. Lott
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 9781835466384'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Master core Python data structures, algorithms, and design patterns
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement object-oriented designs and functional programming features
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use type matching and annotations to make more expressive programs
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create useful data visualizations with Matplotlib and Pyplot
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage project dependencies and virtual environments effectively
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow best practices for code style and testing
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create clear and trustworthy documentation for your projects
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![img](img/9781800207721.jpg)](https://www.packtpub.com/en-in/product/mastering-python-2e-9781800202108)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**Mastering Python 2E**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Rick Hattem
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 9781800207721'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Write beautiful Pythonic code and avoid common Python coding mistakes
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the power of decorators, generators, coroutines, and metaclasses
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use different testing systems like pytest, unittest, and doctest
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track and optimize application performance for both memory and CPU usage
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug your applications with PDB, Werkzeug, and faulthandler
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your performance through asyncio, multiprocessing, and distributed computing
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore popular libraries like Dask, NumPy, SciPy, pandas, TensorFlow, and scikit-learn
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend Python’s capabilities with C/C++ libraries and system calls
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt is searching for authors like you
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](http://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Share your thoughts
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you’ve finished *Learn Python Programming* , *Fourth Edition* , we’d love
    to hear your thoughts! If you purchased the book from Amazon, please [click here
    to go straight to the Amazon review page](https://packt.link/r/1835882951) for
    this book and share your feedback or leave a review on the site that you purchased
    it from.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
