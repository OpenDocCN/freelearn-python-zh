["```py\ndef less_than(self, other):\n    return self.data <= other.data\n\nclass MyDs(object):\n\n    def __init__(self, data):\n        self.data = data\n\n    def __str__(self,):\n        return str(self.data)\n    __repr__ = __str__\n\nif __name__ == '__main__':\n\n    ml = [MyDs(i) for i in range(10, 1, -1)]\n    try:\n        ml.sort()\n    except TypeError:\n        print(\"unable to sort by default\")\n\n    for att in '__lt__', '__le__', '__gt__', '__ge__':\n        setattr(MyDs, att, less_than)\n        ml = [MyDs(i) for i in list(range(5, 1, -1)) + list(range(1, 5,))]\n        try:\n            ml.sort()\n            print(ml)\n        except TypeError:\n            print(\"cannot sort\")\n        delattr(MyDs, att)\n\n    ml = [MyDs(i) for i in range(10, 1, -1)]\n    print(\"sorted\", sorted(ml, key=lambda x: x.data))\n    ml.sort(key=lambda x: x.data)\n    print(\"sort\", ml)\n```", "```py\n[1, 2, 2, 3, 3, 4, 4, 5]\ncannot sort\n[5, 4, 4, 3, 3, 2, 2, 1]\ncannot sort\nsorted [2, 3, 4, 5, 6, 7, 8, 9, 10]\nsort [2, 3, 4, 5, 6, 7, 8, 9, 10]\n```", "```py\ndef equals(self, other):\n    return self.data == other.data\n\nclass MyDs(object):\n\n    def __init__(self, data):\n        self.data = data\n\n    def __str__(self,):\n        return str(self.data)\n    __repr__ = __str__\n\nif __name__ == '__main__':\n    m1 = MyDs(1)\n    m2 = MyDs(2)\n    m3 = MyDs(1)\n    print(m1 == m2)\n    print(m1 == m3)\n\n    setattr(MyDs, '__eq__', equals)\n    print(m1 == m2)\n    print(m1 == m3)\n    delattr(MyDs, '__eq__')\n\n    print(\"collection\")\n    l1 = [1, \"arun\", MyDs(3)]\n    l2 = [1, \"arun\", MyDs(3)]\n    print(l1 == l2)\n    setattr(MyDs, '__eq__', equals)\n    print(l1 == l2)\n    l2.append(45)\n    print(l1 == l2)\n    delattr(MyDs, '__eq__')\n\n    print(\"immutable collection\")\n    t1 = (1, \"arun\", MyDs(3), [1, 2])\n    t2 = (1, \"arun\", MyDs(3), [1, 2])\n    print(t1 == t2)\n    setattr(MyDs, '__eq__', equals)\n    print(t1 == t2)\n    t1[3].append(7)\n    print(t1 == t2)\n```", "```py\nFalse\nFalse\nFalse\nTrue\ncollection\nFalse\nTrue\nFalse\nimmutable collection\nFalse\nTrue\nFalse\n```", "```py\nclass MyDs(object):\n\n    def __init__(self, data):\n        self.data = data\n\n    def __str__(self,):\n        return \"%s:%s\" % (id(self) % 100000, self.data)\n\n    def __eq__(self, other):\n        print(\"collision\")\n        return self.data == other.data\n\n    def __hash__(self):\n        return hash(self.data)\n\n    __repr__ = __str__\n\nif __name__ == '__main__':\n\n    dd = {MyDs(i): i for i in (1, 2, 1)}\n    print(dd)\n\n    print(\"all collisions\")\n    setattr(MyDs, '__hash__', lambda x: 1)\n    dd = {MyDs(i): i for i in (1, 2, 1)}\n    print(dd)\n\n    print(\"all collisions,all values same\")\n    setattr(MyDs, '__eq__', lambda x, y: True)\n    dd = {MyDs(i): i for i in (1, 2, 1)}\n    print(dd)\n```", "```py\ncollision\n{92304:1: 1, 92360:2: 2}\nall collisions\ncollision\ncollision\n{51448:1: 1, 51560:2: 2}\nall collisions,all values same\n{92304:1: 1}\n```", "```py\n    >>> sys.getsizeof(())\n    48\n    >>> sys.getsizeof(tuple(range(100)))\n    848\n    ```", "```py\n    >>> from collections import namedtuple\n    >>> student = namedtuple('student','name,marks')\n    >>> s1 = student('arun',133)\n    >>> s1.name\n    'arun'\n    >>> s1.marks\n    133\n    >>> type(s1)\n    <class '__main__.student'>\n    ```", "```py\n    >>> sys.getsizeof([])\n    64\n    >>> sys.getsizeof(list(range(100)))\n    1008\n    ```", "```py\n    >>> d = dict()\n    >>> getsizeof(d)\n    288\n    >>> getsizeof({i:None for i in range(100)})\n    6240\n    ```", "```py\n    >>> air = (\"sparrow\", \"crow\")\n    >>> land = (\"sparrow\",\"lizard\",\"frog\")\n    >>> water = (\"frog\",\"fish\")\n    >>> # find animal able to live on land and water\n    ... \n    >>> [animal for animal in water if animal in land]\n    ['frog']\n    >>> \n    >>> air = set(air)\n    >>> land = set(land)\n    >>> water = set(water)\n    >>> land | water #animal living either land or water\n    {'frog', 'fish', 'sparrow', 'lizard'}\n    >>> land & water #animal living both land and water\n    {'frog'}\n    >>> land ^ water #animal living on only one land or water\n    {'fish', 'sparrow', 'lizard'}\n    ```", "```py\n    >>> s = set()\n    >>> sys.getsizeof(s)\n    224\n    >>> s = set(range(100))\n    >>> sys.getsizeof(s)\n    8416\n    ```", "```py\n    >>> d = deque()\n    >>> getsizeof(d)\n    632\n    >>> d = deque(range(100))\n    >>> getsizeof(d)\n    1160\n    ```", "```py\n    from heapq import heappush, heappop\n    from itertools import count\n\n    class PriorityQueue(object):\n        def __init__(self,):\n            self.queue = []\n            self.counter = count()\n\n        def __len__(self):\n            return len(self.queue)\n\n        def pop(self,):\n            item = heappop(self.queue)\n            print(item)\n            return item[2],item[0]\n\n        def push(self,item,priority):\n            cnt = next(self.counter)\n            heappush(self.queue, (priority, cnt, item))\n    ```", "```py\ntr = bintrees.FastRBTree()\ntr.insert(\"a\",40)\ntr.insert(\"b\",5)\ntr.insert(\"a\",9)\nprint(list(tr.keys()),list(tr.items()))\nprint(tr.min_item())\nprint(tr.pop_max())\nprint(tr.pop_max())\ntr = bintrees.FastRBTree([(i,i+1) for i in range(10)])\nprint(tr[5:9])\n```", "```py\n['a', 'b'] [('a', 9), ('b', 5)]\n('a', 9)\n('b', 5)\n('a', 9)\nFastRBTree({5: 6, 6: 7, 7: 8, 8: 9})\n```", "```py\nimport sortedcontainers as sc\nimport sys\nl = sc.SortedList()\nl.update([0,4,2,1,4,2])\nprint(l)\nprint(l.index(2),l.index(4))\nl.add(6)\nprint(l[-1])\nl = sc.SortedList(range(10))\nprint(l)\nprint(list(l.irange(2,6)))\n\nseta = sc.SortedSet(range(1,4))\nsetb = sc.SortedSet(range(3,7))\nprint(seta - setb)\nprint(seta | setb )\nprint(seta & setb)\nprint([i for i in seta])\n```", "```py\nSortedList([0, 1, 2, 2, 4, 4], load=1000)\n2 4\n6\nSortedList([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], load=1000)\n[2, 3, 4, 5, 6]\nSortedSet([1, 2], key=None, load=1000)\nSortedSet([1, 2, 3, 4, 5, 6], key=None, load=1000)\nSortedSet([3], key=None, load=1000)\n[1, 2, 3]\n```", "```py\n>>> import string\n>>> import marisa_trie as mtr\n>>> import datrie as dtr\n>>> \n>>> \n>>> # simple read-only keys\n... tr = mtr.Trie([u'192.168.124.1',u'192.168.124.2',u'10.10.1.1',u'10.10.1.2'])\n>>> #get all keys\n... print(tr.keys())\n['10.10.1.1', '10.10.1.2', '192.168.124.1', '192.168.124.2']\n>>> #check if key exists\n... print(tr.has_keys_with_prefix('192'))\nTrue\n>>> # get id of key\n... print(tr.get('192.168.124.1'))\n2\n>>> # get all items\n... print(tr.items())\n[('10.10.1.1', 0), ('10.10.1.2', 1), ('192.168.124.1', 2), ('192.168.124.2', 3)]\n>>> \n>>> # storing data along with keys\n... btr = mtr.BytesTrie([('192.168.124.1',b'redmine.meeku.com'),\n...                     ('192.168.124.2',b'jenkins.meeku.com'),\n...                     ('10.5.5.1',b'gerrit.chiku.com'),\n...                     ('10.5.5.2',b'gitlab.chiku.com'),\n...                     ])\n>>> print(list(btr.items()))\n[('10.5.5.1', b'gerrit.chiku.com'), ('10.5.5.2', b'gitlab.chiku.com'), ('192.168.124.1', b'redmine.meeku.com'), ('192.168.124.2', b'jenkins.meeku.com')]\n>>> print(btr.get('10.5.5.1'))\n[b'gerrit.chiku.com']\n>>> \n>>> with open(\"/tmp/marisa\",\"w\") as f:\n...     btr.write(f)\n... \n>>>     \n... # using memory mapped io to decrease memory usage\n... dbtr = mtr.BytesTrie().mmap(\"/tmp/marisa\")\n>>> print(dbtr.get(\"192.168.124.1\"))\n[b'redmine.meeku.com']\n>>> \n>>> \n>>> trie = dtr.Trie('0123456789.') #define allowed character range\n>>> trie['192.168.124.1']= 'redmine.meeku.com'\n>>> trie['192.168.124.2'] = 'jenkins.meeku.com'\n>>> trie['10.5.5.1'] = 'gerrit.chiku.com'\n>>> trie['10.5.5.2'] = 'gitlab.chiku.com'\n>>> print(trie.prefixes('192.168.245'))\n[]\n>>> print(trie.values())\n['gerrit.chiku.com', 'gitlab.chiku.com', 'redmine.meeku.com', 'jenkins.meeku.com']\n>>> print(trie.suffixes())\n['10.5.5.1', '10.5.5.2', '192.168.124.1', '192.168.124.2']\n>>> \n>>> trie.save(\"/tmp/1.datrie\")\n>>> ntr = dtr.Trie.load('/tmp/1.datrie')\n>>> print(ntr.values())\n['gerrit.chiku.com', 'gitlab.chiku.com', 'redmine.meeku.com', 'jenkins.meeku.com']\n>>> print(ntr.suffixes())\n['10.5.5.1', '10.5.5.2', '192.168.124.1', '192.168.124.2']\n```", "```py\n10000000022,shy-flower-ac5,-473,16/03/25\n10000000096,red-water-e85,-424,16/02/12\n10000000097,dry-star-c85,-417,16/07/19\n10000000070,damp-night-c76,-364,16/03/12\n10000000032,muddy-shadow-aad,-362,16/08/05\n\ndef dosort(filename,result):\n    with open(filename) as ifile:\n        with open(result,\"w\") as ofile:\n            for line in sorted(\n                map(lambda x:x.strip(), ifile.readlines()\n                    ),key=lambda x:int(x.split(',')[2])\n                ):\n                ofile.write(line)\n                ofile.write('\\n')\n```", "```py\nimport tempfile\nimport heapq\n\ndef slowread(f, nbytes):\n    while True:\n        ilines = f.readlines(nbytes)\n        if not ilines:\n            break\n        for line in ilines:\n            yield int(line.split(',')[2]),line\n\ndef dosort(filename, result):\n    partition = 5000\n    with open(filename,\"r\") as ifile:\n        with open(result,\"w\") as ofile:\n            tempfiles = []\n            while True:\n                ilines  = ifile.readlines(partition)\n                if len(ilines) == 0 :\n                    break\n                tfile = tempfile.TemporaryFile(mode=\"w+\")\n                tfile.writelines(\n                    sorted(\n                        ilines,\n                        key=lambda x:int(x.split(',')[2])\n                        ))\n                tfile.seek(0)\n                tempfiles.append(tfile)\n            lentempfiles = len(tempfiles)\n            read_generators = [slowread(tfile, partition//(lentempfiles+1))  for tfile in tempfiles]\n            res = []\n            for line in heapq.merge(*read_generators):\n                res.append(line[1])\n                if len(res) > 100:\n                    ofile.writelines(res)\n                    res.clear()\n            if res:\n                ofile.writelines(res)\n            ofile.close()\n```", "```py\nimport socket\nimport sys\nfrom sort2 import dosort2\n\nHOST = '127.0.0.1'\nPORT =  9002\nNCLIENTS = 2\n\nclass Client(object):\n\n    def __init__(self,HOST,PORT,filename):\n        self.skt = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n        self.skt.connect((HOST,PORT))\n        self.filename = filename\n        self.skt.setblocking(True)\n\n    def run(self):\n        for line in dosort2(self.filename):\n            print(\"for\",line)\n            data = self.skt.recv(1024)\n            print(\"data cmd\",data)\n            if data == b'next\\r\\n':\n                data = None\n                self.skt.send(line[1].encode())\n            else:\n                print(\"got from server\",data)\n        print(\"closing socket\")\n        self.skt.close()\n\nc = Client(HOST,PORT,sys.argv[1])\nc.run()\n```", "```py\nimport socket\nimport heapq\nfrom collections import deque\n\nHOST = '127.0.0.1'\nPORT = 9002\nNCLIENTS = 2\n\nclass Empty(Exception):\n    pass\n\nclass ClientConn(object):\n    def __init__(self, conn, addr):\n        self.conn = conn\n        self.addr = addr\n        self.buffer = deque()\n        self.finished = False\n        self.get_next()\n\n    def __str__(self, ):\n        return '%s' % (str(self.addr))\n\n    def get_next(self):\n        print(\"getting next\", self.addr)\n        self.conn.send(b\"next\\r\\n\")\n        try:\n            ndata = self.conn.recv(1024)\n        except Exception as e:\n            print(e)\n            self.finished = True\n            ndata = None\n        if ndata:\n            ndata = ndata.decode()\n            print(\"got from client\", ndata)\n            self.push((int(ndata.split(',')[2]), ndata))\n        else:\n            self.finished = True\n\n    def pop(self):\n        if self.finished:\n            raise Empty()\n        else:\n            elem = self.buffer.popleft()\n            self.get_next()\n            return elem\n\n    def push(self, value):\n        self.buffer.append(value)\n\n    def __iter__(self, ):\n        return self\n\n    def __next__(self, ):\n        try:\n            return self.pop()\n        except Empty:\n            print(\"iter empty\")\n            raise StopIteration\n\nclass Server(object):\n    def __init__(self, HOST, PORT, NCLIENTS):\n        self.nclients = NCLIENTS\n        self.skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.skt.setblocking(True)\n        self.skt.bind((HOST, PORT))\n        self.skt.listen(1)\n\n    def run(self):\n        self.conns = []  # list of all clients connected\n\n        while len(self.conns) < self.nclients:  # accept client till we have all\n            conn, addr = self.skt.accept()\n            cli = ClientConn(conn, addr)\n            self.conns.append(cli)\n            print('Connected by', cli)\n\n        with open(\"result\", \"w\") as ofile:\n            for line in heapq.merge(*self.conns):\n                print(\"output\", line)\n                ofile.write(line[1])\n\ns = Server(HOST, PORT, NCLIENTS)\ns.run()\n```"]