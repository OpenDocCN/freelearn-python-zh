<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer307">
    <h1 class="chapterNumber">15</h1>
    <h1 class="chapterTitle" id="_idParaDest-307">Continuous Integration with GitLab</h1>
    <p class="normal">The network touches every part of the technology stack; in all the environments I have worked in, the network is always a Tier-Zero service. It is a foundation service that other services rely on for their services to work. In the minds of other engineers, business managers, operators, and support staff, the network should just work. It should always be accessible and function correctly—a good network is a network that nobody hears about.</p>
    <p class="normal">Of course, as network engineers, we know the network is as complex as any other technology stack. Due to its complexity, the constructs that make up a running network can be fragile. Sometimes, I look at a network and wonder how it can work at all, let alone how it’s been running for months and years without any business impact.</p>
    <p class="normal">Part of the reason we are interested in network automation is to find ways to repeat our network-change process reliably and consistently. By using Python scripts or the Ansible framework, we can make sure the changes that we make will stay consistent and be reliably applied. As we saw in the last chapter, we can use Git and GitHub to store components of the process, such as templates, scripts, requirements, and files, reliably. The code that makes up the infrastructure is version-controlled, collaborated, and accountable for changes. But how do we tie all the pieces together? In this chapter, we will look at a popular repository that can optimize the network-management pipeline called GitLab.</p>
    <div class="note">
      <p class="normal">GitLab’s open core is published under an MIT open-source license. The rest is source-available, <a href="https://about.gitlab.com/solutions/open-source/."><span class="url">https://about.gitlab.com/solutions/open-source/.</span></a> </p>
    </div>
    <p class="normal">In this chapter, we’ll cover the following topics:</p>
    <ul>
      <li class="bulletList">Challenges with the traditional change management process</li>
      <li class="bulletList">An introduction to continuous integration and GitLab</li>
      <li class="bulletList">GitLab installation and examples</li>
      <li class="bulletList">GitLab with Python</li>
      <li class="bulletList">Continuous integration for network engineering</li>
    </ul>
    <p class="normal">We’ll begin by looking at the traditional change management process. As any battle-tested network engineer could tell you, the traditional change management process typically involves much manual labor and human judgment. As we will see, it is not consistent and is difficult to streamline.</p>
    <h1 class="heading-1" id="_idParaDest-308">The traditional change management process</h1>
    <p class="normal">Engineers who have worked in a large network environment know that the impact of a network <a id="_idIndexMarker1134"/>change gone wrong can be big. We can make hundreds of changes without any issues, but all it takes is one bad change that can cause the network to harm the whole business.</p>
    <div class="note">
      <p class="normal">There is no shortage of war stories about network outages causing business pain. One of the most visible and large-scale AWS EC2 outages in 2011 was caused by a network change that was part of the normal AWS scaling activities in the AWS US-East region. The change occurred at 00:47 PDT and caused a brown-out for various services for over 12 hours, losing millions of dollars for Amazon. More importantly, the reputation of the relatively young service took a serious hit. IT decision-makers pointed to the outage as a reason NOT to migrate to the young AWS cloud. It took many years to rebuild its reputation. You can read more about the incident report at <a href="https://aws.amazon.com/message/65648/"><span class="url">https://aws.amazon.com/message/65648/</span></a>.</p>
    </div>
    <p class="normal">Due to <a id="_idIndexMarker1135"/>the potential impact and complexity, in many environments, the <strong class="keyWord">change-advisory board</strong> (<strong class="keyWord">CAB</strong>) process is implemented for networks. The typical CAB process is as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The network engineer will design the change and write out the detailed steps required for the change. These can include the reason for the change, the devices involved, the commands that will be applied or deleted, how to verify <a id="_idIndexMarker1136"/>the output, and the expected outcome for each step.</li>
      <li class="numberedList">The network engineer is typically required to ask for a technical review from a peer first. Depending on the nature of the change, there can be different levels of peer review. Simple changes can require a single-peer technical review; more complex changes might require a senior designated engineer for approval.</li>
      <li class="numberedList">The CAB meeting is generally scheduled for set times with emergency ad hoc meetings available.</li>
      <li class="numberedList">The engineer will present the change to the board. The board will ask the necessary questions, assess the impact, and either approve or deny the change request.</li>
      <li class="numberedList">The change will be carried out, either by the original engineer or another engineer, during the scheduled change window.</li>
    </ol>
    <p class="normal">This process <a id="_idIndexMarker1137"/>sounds reasonable and inclusive but proves to have a few challenges in practice:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Write-ups are time-consuming</strong>: It typically takes a long time for the design engineer to write up the document, and sometimes the writing process takes longer than the time to apply the change. This is generally due to the fact that all network changes are potentially impactful and we need to document the process for both technical and non-technical CAB members.</li>
      <li class="bulletList"><strong class="keyWord">Engineer expertise</strong>: High-level engineer expertise is a limited resource. There are different levels of engineering expertise; some are more experienced, and they are typically the most sought-after resources. We should reserve their time for tackling the most complex network issues, not reviewing basic network changes.</li>
      <li class="bulletList"><strong class="keyWord">Meetings are time-consuming</strong>: It takes a lot of effort to put together meetings and have each member show up. What happens if a required approval person is on vacation or sick? What if you need the network change to be made prior to the scheduled CAB time?</li>
    </ul>
    <p class="normal">These are just some of the bigger challenges of the human-based CAB process. Personally, I hate the CAB process with a passion. I do not dispute the need for peer review and prioritization; however, I think we need to minimize the potential overhead involved. For the remainder of this chapter, let’s look at a potentially suitable replacement pipeline for CAB, and change management in general, that has been adopted in the software engineering world.</p>
    <h1 class="heading-1" id="_idParaDest-309">Introduction to continuous integration</h1>
    <p class="normal"><strong class="keyWord">Continuous Integration</strong> (<strong class="keyWord">CI</strong>) in software development is a way to publish small changes to the <a id="_idIndexMarker1138"/>code base quickly, with built-in code tests and validation. The key is to classify the changes to be CI-compatible, that is, not overly complex and small enough to be applied so that they can be backed out of easily. The tests and validation process are built in an automated way to gain a baseline of confidence that changes will be applied without breaking the whole system.</p>
    <p class="normal">Before CI, changes to software were often made in large batches and often required a long validation process (does that sound familiar?). It could be months before developers saw their changes in production, received feedback loops, and corrected bugs. In short, the CI process aims to shorten the process from idea to change.</p>
    <p class="normal">The general <a id="_idIndexMarker1139"/>workflow typically involves the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The first engineer takes a current copy of the code base and works on the change.</li>
      <li class="numberedList">The first engineer submits the change to the repository.</li>
      <li class="numberedList">The repository can notify the necessary parties of a change in the repository to a group of engineers who can review the change. They can either approve or reject the change.</li>
      <li class="numberedList">The CI system can continuously pull the repository for changes, or the repository can send a notification to the CI system when changes happen. Either way, the CI system will pull the latest version of the code.</li>
      <li class="numberedList">The CI system will run automated tests to try to catch any breakage.</li>
      <li class="numberedList">If there are no faults found, the CI system can choose to merge the change into the main code and optionally deploy it to the production system.</li>
    </ol>
    <p class="normal">This is a generalized list of steps. The process can be different for each organization. For example, automated tests can be run as soon as the delta code is checked instead of after code review. Sometimes, the organization might choose to have a human engineer involved for sanity checks in between the steps.</p>
    <p class="normal">In the next section, we will illustrate the instructions to install GitLab on an Ubuntu 22.04 LTS system.</p>
    <h1 class="heading-1" id="_idParaDest-310">Installing GitLab</h1>
    <p class="normal">GitLab is a powerful, all-in-one tool to handle the end-to-end DevOps collaboration tool. As we <a id="_idIndexMarker1140"/>will see in a minute, it hosts the code repository and handles the code testing, deployment, and verification. It is one of the most popular DevOps tools used in the field today. </p>
    <div class="note">
      <p class="normal">The company behind the technology, GitLab Inc., had its successful initial public offering on NASDAQ (ticket GTLB) in late 2021, <a href="https://techcrunch.com/2021/09/17/inside-gitlabs-ipo-filing/"><span class="url">https://techcrunch.com/2021/09/17/inside-gitlabs-ipo-filing/</span></a>. The company’s success shows the strength of and sustainability of the technology. </p>
    </div>
    <p class="normal">We will only need a small set of its features to get up and running with a test lab. The objective is to familiarize ourselves with the overall flow of the steps. I encourage you to look at the GitLab documentation at <a href="https://docs.gitlab.com/"><span class="url">https://docs.gitlab.com/</span></a> to get a sense of its features. </p>
    <figure class="mediaobject"><img alt="Graphical user interface, application, Teams  Description automatically generated" src="../Images/B18403_15_01.png"/></figure>
    <p class="packt_figref">Figure 15.1: GitLab Documentation</p>
    <p class="normal">For our network lab, we will use the same lab topology that we have been using for the last few chapters. </p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B18403_15_02.png"/></figure>
    <p class="packt_figref">Figure 15.2: Lab Topology</p>
    <p class="normal">While it <a id="_idIndexMarker1141"/>is tempting to run GitLab as a Docker image, the GitLab runners (components executing the steps) are Docker images themselves, and running Docker-in-Docker introduces more complexity in our lab. Therefore, in this chapter, we will install GitLab on a VM with the runners running in containers. The installation system requirements can be found here, <a href="https://docs.gitlab.com/ee/install/requirements.html"><span class="url">https://docs.gitlab.com/ee/install/requirements.html</span></a>. </p>
    <p class="normal">We will install Docker Engine, docker-compose, then the GitLab packages. Let’s get Docker ready first: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"># </span>Installing Docker Engine
<span class="hljs-con-meta">$ </span>sudo apt-get install ca-certificates curl gnupg lsb-release
<span class="hljs-con-meta">$ </span>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">echo</span> <span class="hljs-con-string">"deb [arch=</span><span class="hljs-con-subst">$(dpkg --print-architecture)</span><span class="hljs-con-string"> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu </span><span class="hljs-con-subst">$(lsb_release -cs)</span><span class="hljs-con-string"> stable"</span> | sudo <span class="hljs-con-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null
<span class="hljs-con-meta">$ </span>sudo apt-get update
<span class="hljs-con-meta">$ </span>sudo apt-get install docker-ce docker-ce-cli containerd.io
<span class="hljs-con-meta"># </span>Run Docker as user
<span class="hljs-con-meta">$ </span>sudo groupadd docker
<span class="hljs-con-meta">$ </span>sudo usermod -aG docker <span class="hljs-con-variable">$USER</span>
<span class="hljs-con-meta">$ </span>newgrp docker 
<span class="hljs-con-meta"># </span>Install Docker-Compose
<span class="hljs-con-meta">$ </span>sudo curl -L <span class="hljs-con-string">"</span><span class="hljs-con-string">https://github.com/docker/compose/releases/download/1.29.2/docker-compose-</span><span class="hljs-con-subst">$(uname -s)</span><span class="hljs-con-string">-</span><span class="hljs-con-subst">$(uname -m)</span><span class="hljs-con-string">"</span> -o /usr/local/bin/docker-compose
<span class="hljs-con-meta">$ </span>sudo <span class="hljs-con-built_in">chmod</span> +x /usr/local/bin/docker-compose
<span class="hljs-con-meta">$ </span>docker-compose --version
docker-compose version 1.29.2, build 5becea4c
</code></pre>
    <p class="normal">For GitLab, we will <a id="_idIndexMarker1142"/>install the self-managed GitLab with the official steps: <a href="https://docs.gitlab.com/omnibus/index.html#installation-and-configuration-using-omnibus-package"><span class="url">https://docs.gitlab.com/omnibus/index.html#installation-and-configuration-using-omnibus-package</span></a>. Note that the steps require port forwarding to the host on an externally accessible URL: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>sudo apt update
<span class="hljs-con-meta">$ </span>sudo apt-get install -y curl openssh-server ca-certificates tzdata perl 
<span class="hljs-con-meta">$ </span>sudo apt-get install -y postfix
<span class="hljs-con-meta">$ </span>curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash
<span class="hljs-con-meta">$ </span>sudo EXTERNAL_URL=<span class="hljs-con-string">"http://gitlab.networkautomationnerds.com:9090"</span> apt-get install gitlab-ee
</code></pre>
    <p class="normal">We should see the success message once installed: </p>
    <figure class="mediaobject"><img alt="Text  Description automatically generated" src="../Images/B18403_15_03.png"/></figure>
    <p class="packt_figref">Figure 15.3: GitLab Installation</p>
    <p class="normal">We will <a id="_idIndexMarker1143"/>use the initial password to log in and then reset it (<a href="https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password"><span class="url">https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password</span></a>): </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>sudo <span class="hljs-con-built_in">cat</span> /etc/gitlab/initial_root_password
…
Password: &lt;random password&gt;
<span class="hljs-con-meta">$ </span>sudo gitlab-rake <span class="hljs-con-string">"gitlab:password:reset"</span>
</code></pre>
    <p class="normal">We should be able to see the dashboard under ‘<strong class="screenText">Menu -&gt; Admin</strong>’ once everything is configured: </p>
    <figure class="mediaobject"><img alt="Graphical user interface, application, Teams  Description automatically generated" src="../Images/B18403_15_04.png"/></figure>
    <p class="packt_figref">Figure 15.4: GitLab Dashboard</p>
    <p class="normal">As an <a id="_idIndexMarker1144"/>optional step, we can enable SMTP settings under <code class="inlineCode">/etc/gitlab/gitlab.rb</code>. This would allow us to receive emails for the important messages on GitLab (<a href="https://docs.gitlab.com/omnibus/settings/smtp.html"><span class="url">https://docs.gitlab.com/omnibus/settings/smtp.html</span></a>): </p>
    <figure class="mediaobject"><img alt="Graphical user interface, text, application  Description automatically generated" src="../Images/B18403_15_05.png"/></figure>
    <p class="packt_figref">Figure 15.5: GitLab SMTP Settings</p>
    <p class="normal">Let’s talk <a id="_idIndexMarker1145"/>about GitLab runners. </p>
    <h1 class="heading-1" id="_idParaDest-311">GitLab runners</h1>
    <p class="normal">GitLab uses <a id="_idIndexMarker1146"/>the concept of a runner. A runner is a process that picks up and executes <strong class="keyWord">Continuous Integration/Continuous Deployment </strong>(<strong class="keyWord">CI/CD</strong>) jobs for GitLab. The runner can be run in a Docker container on the host itself, <a href="https://docs.gitlab.com/runner/install/docker.html"><span class="url">https://docs.gitlab.com/runner/install/docker.html</span></a>: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>docker run --<span class="hljs-con-built_in">rm</span> -t -i gitlab/gitlab-runner —<span class="hljs-con-built_in">help</span>
Unable to find image 'gitlab/gitlab-runner:latest' locally
latest: Pulling from gitlab/gitlab-runner
7b1a6ab2e44d: Pull complete 
5580ef77ebbe: Pull complete 
d7b21acbe607: Pull complete 
Digest: sha256:d2db6b687e9cf5baf96009e43cc3eaebf180f634306cdc74e2400315d35f0dab
Status: Downloaded newer image for gitlab/gitlab-runner:latest
…
<span class="hljs-con-meta">$ </span>   docker run -d --name gitlab-runner --restart always \
&gt;      -v /srv/gitlab-runner/config:/etc/gitlab-runner \
&gt;      -v /var/run/docker.sock:/var/run/docker.sock \
&gt;      gitlab/gitlab-runner:latest
617b94e5e4c5c72d33610b2eef5eb7027f579f4e069558cbf61f884375812306
 
</code></pre>
    <p class="normal">We can go <a id="_idIndexMarker1147"/>ahead and register the runner with the host, <a href="https://docs.gitlab.com/runner/register/index.html#docker"><span class="url">https://docs.gitlab.com/runner/register/index.html#docker</span></a>, under <strong class="screenText">Admin Area -&gt; Runners -&gt; Register</strong> an instance runner. We will take note of the token: </p>
    <figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" src="../Images/B18403_15_06.png"/></figure>
    <p class="packt_figref">Figure 15.6: GitLab Runner Registration</p>
    <p class="normal">We can then use the token to pull and register a runner with a base image: </p>
    <pre class="programlisting con"><code class="hljs-con">(venv) echou@gitlab:~$ docker run --rm -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register
Runtime platform                                    arch=amd64 os=linux pid=8 revision=5316d4ac version=14.6.0
Running in system-mode.                            
                                                   
Enter the GitLab instance URL (for example, https://gitlab.com/):
http://&lt;ip&gt;:&lt;port&gt; 
Enter the registration token:
&lt;token&gt;
Enter a description for the runner:
[fef6fb5a91dd]: local-runner
Enter tags for the runner (comma-separated): &lt;&lt; Leave empty unless we want matching tag to run the runners jobs
Registering runner... succeeded                     runner=64eCJ5yp
Enter an executor: virtualbox, docker-ssh+machine, kubernetes, custom, docker-ssh, parallels, docker+machine, docker, shell, ssh:
docker
Enter the default Docker image (for example, ruby:2.6):
docker pull ubuntu:latest
Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded!
</code></pre>
    <p class="normal">We are <a id="_idIndexMarker1148"/>now ready to handle our first job!</p>
    <h1 class="heading-1" id="_idParaDest-312">First GitLab example</h1>
    <p class="normal">We can <a id="_idIndexMarker1149"/>begin by creating a separate user under <strong class="screenText">Menu -&gt; Admin Area -&gt; Users</strong> (under Overview) and login via that user: </p>
    <figure class="mediaobject"><img alt="Graphical user interface  Description automatically generated" src="../Images/B18403_15_07.png"/></figure>
    <p class="packt_figref">Figure 15.7: GitLab Users</p>
    <p class="normal">To push or pull from repositories, we will also add our SSH key. This can be done via the settings section within the user profile: </p>
    <figure class="mediaobject"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="../Images/B18403_15_08.png"/></figure>
    <p class="packt_figref">Figure 15.8: User SSH Key</p>
    <p class="normal">We can <a id="_idIndexMarker1150"/>now create a new project under <strong class="screenText">Menu -&gt; Projects -&gt; Create New Project</strong>: </p>
    <figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" src="../Images/B18403_15_09.png"/></figure>
    <p class="packt_figref">Figure 15.9: Create New Project</p>
    <p class="normal">We will <a id="_idIndexMarker1151"/>name this project <code class="inlineCode">chapter15_example1</code>: </p>
    <figure class="mediaobject"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="../Images/B18403_15_10.png"/></figure>
    <p class="packt_figref">Figure 15.10: New Project Settings</p>
    <p class="normal">We can <a id="_idIndexMarker1152"/>leave the rest of the settings as we see fit. As a precaution, I typically leave the project visibility on private, but we can always change that later. </p>
    <figure class="mediaobject"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="../Images/B18403_15_11.png"/></figure>
    <p class="packt_figref">Figure 15.11: Project Clone URL</p>
    <p class="normal">We can <a id="_idIndexMarker1153"/>grab the URL for the project and clone that project on our management station: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>git <span class="hljs-con-built_in">clone</span> http://gitlab.&lt;url&gt;/echou/chapter15_example1.git
Cloning into 'chapter15_example1'...
Username for 'http://gitlab.&lt;url&gt;': &lt;user&gt;
Password for 'http://&lt;user&gt;@&lt;url&gt;': 
remote: Enumerating objects: 3, done.
remote: Counting objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Receiving objects: 100% (3/3), done.
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span> chapter15_example1/
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">ls</span>
README.md
</code></pre>
    <p class="normal">We will create a special file <code class="inlineCode">.gitlab-ci.yml</code> that is recognized by GitLab as a CI/CD instruction: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># define stages</span>
stages: 
    - build
    - test
    - deploy
<span class="hljs-comment"># define the job</span>
deploy our network: 
    image: <span class="hljs-string">"ubuntu:20.04"</span>
    stage: build
    script: 
        - mkdir new_network
        - cd new_network
        - touch bom.txt
        - echo <span class="hljs-string">"this is our build"</span> &gt;&gt; bom.txt
    artifacts: 
        paths: 
          - new_network/
test our network: 
    stage: test
    image: <span class="hljs-string">"ubuntu:20.04"</span>
    script: 
        - pwd
        - ls 
        - test -f new_network/bom.txt
deploy to prod:
    stage: deploy
    image: <span class="hljs-string">"ubuntu:20.04"</span>
    script: 
        - echo <span class="hljs-string">"deploy to production"</span>
    when: manual
</code></pre>
    <p class="normal">We will <a id="_idIndexMarker1154"/>check in, commit, and push the file to our GitLab repository: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>git add .gitlab-ci.yml
<span class="hljs-con-meta">$ </span>git commit -m <span class="hljs-con-string">"initial commit"</span>
<span class="hljs-con-meta">$ </span>git push origin main
Username for 'http://&lt;url&gt;': &lt;username&gt;
Password for 'http://&lt;url&gt;': &lt;password&gt;
Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 2 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 512 bytes | 512.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To http://&lt;url&gt; /echou/chapter15_example1.git
   c0b232d..5552a10  main -&gt; main
</code></pre>
    <p class="normal">The <code class="inlineCode">.gitlab-ci.yml</code> file contains instructions for a GitLab CI/CD pipeline in a YAML format. It contains <a id="_idIndexMarker1155"/>two main sections, stage and job definition: </p>
    <figure class="mediaobject"><img alt="A picture containing diagram  Description automatically generated" src="../Images/B18403_15_12.png"/></figure>
    <p class="packt_figref">Figure 15.12: GitLab CI File</p>
    <p class="normal">In our file, we defined three stages with the keyword <code class="inlineCode">stages</code>. In the execution section, we define the Docker base image to be pulled, the name of the job to be done, the stage it corresponds to, as well as the steps to be executed under <code class="inlineCode">script</code>. There can be optional instructions such as <code class="inlineCode">artifacts</code> under <code class="inlineCode">build</code> and <code class="inlineCode">when</code> under <code class="inlineCode">deploy</code>. </p>
    <p class="normal">If we move back to the project, we can click on <strong class="screenText">CI/CD -&gt; Pipelines</strong> to show us the status of the job: </p>
    <figure class="mediaobject"><img alt="Table  Description automatically generated with medium confidence" src="../Images/B18403_15_13.png"/></figure>
    <p class="packt_figref">Figure 15.13: CI/CD Pipeline</p>
    <p class="normal">There <a id="_idIndexMarker1156"/>are three circles, each representing a stage. </p>
    <figure class="mediaobject"><img alt="Graphical user interface, text, application  Description automatically generated" src="../Images/B18403_15_14.png"/></figure>
    <p class="packt_figref">Figure 15.14: Pipeline Output</p>
    <p class="normal">We can <a id="_idIndexMarker1157"/>click on the circles and see the container output: </p>
    <figure class="mediaobject"><img alt="Text  Description automatically generated" src="../Images/B18403_15_15.png"/></figure>
    <p class="packt_figref">Figure 15.15: Execution Output</p>
    <p class="normal">Remember we have optional steps under <code class="inlineCode">build</code> and <code class="inlineCode">deploy</code>? The artifacts give us something to download: </p>
    <figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" src="../Images/B18403_15_16.png"/></figure>
    <p class="packt_figref">Figure 15.16: Artifacts</p>
    <p class="normal">The <code class="inlineCode">when</code> keyword <a id="_idIndexMarker1158"/>allows us to manually push out the step instead of having GitLab automatically execute for us: </p>
    <figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" src="../Images/B18403_15_17.png"/></figure>
    <p class="packt_figref">Figure 15.17: Manual Push</p>
    <p class="normal">Is this awesome, or what? We now have some workers automatically executing jobs for us. We can also leverage many of the features of Git for collaboration, such as inviting colleagues for code review. Let’s see another example. </p>
    <h1 class="heading-1" id="_idParaDest-313">GitLab network example</h1>
    <p class="normal">We will <a id="_idIndexMarker1159"/>go ahead and create another project named <code class="inlineCode">chapter15_example2</code> on the GitLab server. On the local machine, we will clone the remote repository: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>git <span class="hljs-con-built_in">clone</span> http://&lt;url&gt;/echou/chapter15_example2.git
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span> chapter15_example2/
</code></pre>
    <p class="normal">In this example, we will integrate the Nornir library to see how we can execute <code class="inlineCode">show version</code> on two of the IOSv devices. We will begin by defining the <code class="inlineCode">hosts.yaml</code> file: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">---</span>
<span class="hljs-attr">r1:</span>
    <span class="hljs-attr">hostname:</span> <span class="hljs-string">'</span><span class="hljs-string">192.168.2.218'</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">22</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">'cisco'</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">'cisco'</span>
    <span class="hljs-attr">platform:</span> <span class="hljs-string">'cisco_ios'</span>
<span class="hljs-attr">r2:</span>
    <span class="hljs-attr">hostname:</span> <span class="hljs-string">'192.168.2.219'</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">22</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">'cisco'</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">'cisco'</span>
    <span class="hljs-attr">platform:</span> <span class="hljs-string">'cisco_ios'</span>
</code></pre>
    <p class="normal">We can <a id="_idIndexMarker1160"/>then construct the Python script for execution: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-keyword">from</span> nornir <span class="hljs-keyword">import</span> InitNornir
<span class="hljs-keyword">from</span> nornir_utils.plugins.functions <span class="hljs-keyword">import</span> print_result
<span class="hljs-keyword">from</span> nornir_netmiko <span class="hljs-keyword">import</span> netmiko_send_command
nr = InitNornir()
result = nr.run(
    task=netmiko_send_command,
    command_string=<span class="hljs-string">"show version"</span>
)
print_result(result)
</code></pre>
    <p class="normal">We will define a <code class="inlineCode">requirements.txt</code> file to specify the packages to be installed: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> requirements.txt 
…
flake8==4.0.1
…
netmiko==3.4.0
nornir==3.2.0
nornir-netmiko==0.1.2
nornir-utils==0.1.2
paramiko==2.9.2
…
</code></pre>
    <p class="normal">We will also define the <code class="inlineCode">.gitlab-ci.yml</code> file to define the stages and the scripts. Notice in the file <a id="_idIndexMarker1161"/>that we specify another <code class="inlineCode">before_script</code> step to be executed before any of the stages: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">stages:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">Test</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">QA</span>
<span class="hljs-attr">before_script:</span> 
  <span class="hljs-bullet">-</span> <span class="hljs-string">python</span> <span class="hljs-string">--version</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">pip3</span> <span class="hljs-string">install</span> <span class="hljs-string">-r</span> <span class="hljs-string">requirements.txt</span>
<span class="hljs-attr">Test-Job:</span>
  <span class="hljs-attr">stage:</span> <span class="hljs-string">Test</span>
  <span class="hljs-attr">script:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">python3</span> <span class="hljs-string">show_version.py</span> 
<span class="hljs-attr">flake8:</span> 
  <span class="hljs-attr">stage:</span> <span class="hljs-string">QA</span>
  <span class="hljs-attr">script:</span> 
    <span class="hljs-bullet">-</span> <span class="hljs-string">flake8</span> <span class="hljs-string">show_version.py</span>
</code></pre>
    <p class="normal">Once the files are checked in and pushed to the repository, we can go to the CI/CD section to look at the outputs. The steps will take longer this time because of the package download time. We can click on the step and examine the execution in real time. </p>
    <figure class="mediaobject"><img alt="Text  Description automatically generated" src="../Images/B18403_15_18.png"/></figure>
    <p class="packt_figref">Figure 15.18: Nornir CI/CD Step Execution</p>
    <p class="normal">We should <a id="_idIndexMarker1162"/>be able to see the pipeline successfully executed. </p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_15_19.png"/></figure>
    <p class="packt_figref">Figure 15.19: CI/CD Result</p>
    <p class="normal">Using GitLab CI/CD is a terrific way of automating our network operation steps. The pipeline might take longer to set up, but once it is completed, it will save us much time and allow us to preserve our energy to focus on more interesting work. For more information, check out <a href="https://docs.gitlab.com/ee/ci/"><span class="url">https://docs.gitlab.com/ee/ci/</span></a>. </p>
    <h1 class="heading-1" id="_idParaDest-314">Summary</h1>
    <p class="normal">In this chapter, we examined the traditional change management process and why it is not a good fit for today’s rapidly changing environment. The network needs to evolve with the business to become more agile and adapt to change quickly and reliably.</p>
    <p class="normal">We looked at the concept of continuous integration, in particular, the open-source GitLab system. GitLab is a full-featured, expandable, continuous integration system widely used in software development. We can adapt the same system for our network operations. We saw two examples using the GitLab Git repository and runners to execute our operations automatically. </p>
    <p class="normal">In <em class="chapterRef">Chapter 16</em>, <em class="italic">Test-Driven Development for Networks</em>, we will look at test-driven development with Python.</p>
    <h1 class="heading-1">Join our book community</h1>
    <p class="normal">To join our community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/networkautomationcommunity"><span class="url">https://packt.link/networkautomationcommunity</span></a></p>
    <p class="normal"><img alt="" src="../Images/QR_Code2903617220506617062.png"/></p>
  </div>
</body></html>