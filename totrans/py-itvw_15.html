<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch15"/>Chapter 15. Oliver Schoenborn</h1></div></div></div><div><img src="img/B08180_10_01.jpg" alt="Oliver Schoenborn"/></div><p>Oliver Schoenborn<a id="id388" class="indexterm"/> is a Canadian software developer and independent software developer. Past roles have included working as a simulation consultant at CAE Inc and as a visualization software developer at the National Research Council Canada. Oliver is passionate about connecting with the business and government communities. He is the author of Pypubsub (hosted at <a class="ulink" href="https://github.com/schollii/pypubsub">https://github.com/schollii/pypubsub</a>), a Python package that gives users a simple way to decouple parts of their event-based application. Oliver regularly updates Pypubsub and contributes to the wxPython mailing list.</p><div><blockquote class="blockquote"><p>
<strong>Discussion themes: Pypubsub, Python in AI, Python's future.</strong>
</p><p>
<strong>Catch up with Oliver Schoenborn here: @schollii2</strong>
</p></blockquote></div><p>
<strong>Mike Driscoll</strong>: So let's start with your <a id="id389" class="indexterm"/>background. Why did you decide to become a programmer?</p><p>
<strong>Oliver Schoenborn</strong>: Well, a buddy at school was selling his Apple IIe. I had never done programming before that, but I decided to buy his used computer. I was 14 at the time.</p><p>I remember being quite intrigued by the BASIC and assembly language. There was a command prompt and you could somehow drop into the assembly level to write assembly. I read the many manuals for the computer, which described how to program it. I tried to write some little programs and eventually got into Pascal. I really enjoyed it.</p><p>In my fifth year of high school, a school teacher asked us to do something with a language called Logo. It was basically graphics commands to move a pen right, left, draw lines etc. I created a simulation loop in there so that I could simulate a little aircraft flying and dropping a bomb. It was very simple but it was fun, and the teacher was impressed!</p><p>So that's how I got into programming. It was more or less a chance in some ways. At that point, programming was still just a hobby, because my goal was to get into physics.</p><p>
<strong>Driscoll</strong>: So how did you end up getting into Python itself?</p><p>
<strong>Schoenborn</strong>: At work we had a project that needed some graphical user interface development on Windows.</p><p>For<a id="id390" class="indexterm"/> the previous 10 years, I had mostly programmed in C++ on UNIX, developing command line and 3D graphics applications, but not menu-based applications (except for a GUI written in Java AWT). I really dreaded MFC, so I started looking into options on Windows for doing that. I came across Python (because it was platform independent), and Tk.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'Python was the perfect fit. As soon as I saw the language, I really related to its simple and clean syntax.'</strong>
</p></blockquote></div><p>Python was the perfect fit. As soon as I saw the language, I really related to its simple and clean syntax. I don't know if it just matched my way of thinking. I also found wxPython and saw that its API seemed to be rather solid. I fell in love with Python and the ability it provided to quickly create interfaces using wxPython.</p><p>So how I got into Python was through a work project that had requirements that were more easily achievable in Python than in C++.</p><p>
<strong>Driscoll</strong>: Was this how you got involved with the<a id="id391" class="indexterm"/> wxPython community<a id="id392" class="indexterm"/> as well?</p><p>
<strong>Schoenborn</strong>: That's right. I developed my first application in wxPython as a result of that project. It was an application for analyzing seat heating and air-conditioning. Back then, automobile seat comfort was being prototyped using this kind of software.</p><p>So I used wxPython and I thought that the publish-subscribe pattern that it supported was a really awesome idea. I got involved more heavily with the wxPython development by taking over the Pubsub component of that library.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'I got involved more heavily with wxPython development by taking over the Pubsub component of the wxPython library.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: So was Pubsub<a id="id393" class="indexterm"/> started by someone else?</p><p>
<strong>Schoenborn</strong>: Yes, Robb Shecter<a id="id394" class="indexterm"/> created the first version of Pubsub. There were limitations that I <a id="id395" class="indexterm"/>needed to get around (mostly,  a memory leak: subscribers were not released after they were no longer needed by the application), and I proposed some significant patches and unit tests. Robb was looking for someone to take over <code class="literal">wx.lib.pubsub</code>. So I did that.</p><p>
<strong>Driscoll</strong>: Is that also when Pubsub got split into its own module away from wxPython?</p><p>
<strong>Schoenborn</strong>: I think it was a couple of years later. Pubsub <a id="id396" class="indexterm"/>was pretty much a standalone sub-package, whereas most other wx.lib sub-packages required other wxPython components. I wanted to make wx.lib.pubsub available to a broader set of developers, and others on the wxPython developers group agreed.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'Pubsub was pretty much a standalone component.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: Were you guys aware of the <a id="id397" class="indexterm"/>PyDispatcher projects<a id="id398" class="indexterm"/> at that time?</p><p>
<strong>Schoenborn</strong>: Well, I did become aware of PyDispatcher at some point in those years. It was quite a different approach.</p><p>I remember that at the time it was not topic- based. Pubsub was sufficiently different from it to be justified as a separate package. It has been a while since I have looked at it, but it would be interesting actually to see where PyDispatcher is at now.</p><p>There are several projects now that use the basic idea of topics, messaging, and publish/subscribe (such as MQTT and Google pub/sub), but at the network, that is the inter-application level, whereas Pypubsub is at the application inter-component level. They have evolved much more than Pubsub has had to evolve; Pypubsub is mature and production quality.</p><p>
<strong>Driscoll</strong>: So I noticed that when you did that interview with me in the PyDev of the Week series, you had switched <a id="id399" class="indexterm"/>to PyQt. How did that happen?</p><p>
<strong>Schoenborn</strong>: That was some<a id="id400" class="indexterm"/> time in 2013. We basically had this project that involved modernizing an old prototype that our client had. The application involved user-defined scripts that could be run by the prototype and those were all written in Python. So we had to either embed a Python interpreter, or translate huge Python scripts into another language, while guaranteeing the same outputs, (a task that could not fit within the scope of the project budget).</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'We had to either embed a Python interpreter, or translate huge Python scripts.'</strong>
</p></blockquote></div><p>The graphics interface had to be very sophisticated. At the time, the prototype had a 3D component, where the user could rotate model components in a 3D environment. We needed to integrate the graphical user interface with menus and list views as a sophisticated 2D and 3D canvas, where the user could interact with things.</p><p>We wanted something that was stable, powerful, and well-documented, with an active community behind it. At the time, WPF, wxPython, and PyQt (or Qt, for a C++ infrastructure) were the main candidates for us. On the C# side there<a id="id401" class="indexterm"/> was WPF. We looked at a number of different approaches and in the end it was between wxPython and PyQt.</p><p>PyQt seemed to have more powerful integration of a 3D environment than wxPython did. PyQt also seemed to be quickly growing towards supporting a 3D scene graph, whereas in wxPython I would have had to use OpenGL, and this would have been more complicated.</p><p>Python 3 was required, but I <a id="id402" class="indexterm"/>think that's when Robin Dunn decided to create wxPython 3, and so the work on supporting Python 3 was still very early. Basically, there was only Python 2.7 for wxPython and the availability of Qt Designer was also a factor. PyQt had a very sophisticated interface for creating designs.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'PyQt definitely seemed to have momentum.'</strong>
</p></blockquote></div><p>An XML-driven user interface description was supported by both PyQt and WPF.</p><p>PyQt definitely seemed to have momentum, and it supported commercial use of the package, which was important for that project. I had had some negative experiences with WPF, fighting with the black-magic that it used in order to bind properties to widgets. Also, there were signs that IronPython was unmaintained. All things considered, we picked PyQt. We did not regret the choice.</p><p>
<strong>Driscoll</strong>: Going back to the Pypubsub part, <a id="id403" class="indexterm"/>I forgot to ask you, did you have any challenges while running that open source project that you'd like to talk about?</p><p>
<strong>Schoenborn</strong>: Well, it wasn't really a technical challenge, but I did have an interesting experience from an open source development point of view. It reminded me that you don't really control the space that you can occupy in the open source world.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'You don't really control the space that you can occupy in the open source world.'</strong>
</p></blockquote></div><p>What happened was that Pypubsub was on SourceForge, where it was named simply "pubsub", because that's how it was named in wxPython. On PyPI I had named it pypubsub. A couple of years later, I found out that there was another project on SourceForge called Pypubsub, but it hadn't gone anywhere. Basically, it was a dead project and sometimes it led to some confusion on Stack Overflow and the two pypubsub forums.</p><p>That took some effort to straighten out. I had to contact the author and explain what was going on. Eventually, he agreed and I was able to take ownership of the "pypubsub" name on SourceForge.</p><p>In the meantime, GitHub had become really popular. Some people had copied my Pypubsub source code into GitHub, just to have it handy. Nothing wrong with that, but since these forks were not to add features, when I actually decided to move Pypubsub to GitHub, I had to let some devs know that Pypubsub was finally available there. I explained that there probably was no longer a good reason to have separate copies. This was an interesting aspect of open source.</p><p>
<strong>Driscoll</strong>: How much of a<a id="id404" class="indexterm"/> commitment was the project?</p><p>
<strong>Schoenborn</strong>: Well, there have been various periods during the past 15 years when I made major changes to the implementation and extended the API: fixing bugs, updating documentation, and make sure that all tests work when there was a new release of Python. Finding the time to do those things was often a challenge. It is, I guess, another interesting aspect of working on a volunteer basis.</p><p>Evolving the API, while maintaining backwards compatibility, was mostly requested by Robin, the wxPython author, and this was important to me even if Pypubsub was technically separate from wxPython. It was a major technical challenge to make that possible. This led to the concept of Pubsub supporting three APIs or messaging protocols.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'It was a major technical challenge.'</strong>
</p></blockquote></div><p>First, there was backwards compatibility with the very first version of Pubsub. That was what I called the version 1 messaging protocol. Then there was the sort of "modern" Pubsub, which had significant improvements in the API, and there were two APIs for that.</p><p>One was called <code class="literal">arg1</code> because all message data was in one big blob given as one argument to the <code class="literal">sendMessage()</code> function. The other was called <code class="literal">kwargs</code> because message data was sent via keyword arguments in the <code class="literal">sendMessage()</code> function. That was the default when you installed Pypubsub standalone.</p><p>A vanilla installation of wxPython would install the <code class="literal">arg1</code> API, since that one was almost 100% compatible with the version 1 API. A setup flag could be set in the application code, before importing Pypubsub, to choose the <code class="literal">kwargs</code> protocol..</p><p>So getting all that to work was a major headache. I had to sort of hijack the import system a little bit, basically to allow for the user to say, "Well in this application I want the <code class="literal">arg1</code> protocol and in this wxPython application, I want the <code class="literal">kwargs</code> protocol.."</p><p>I also added some code to help transition a wxPython application from version 1 to <code class="literal">arg1</code>, to <code class="literal">kwargs</code> protocol. That was tough too.</p><p>I really wish that I hadn't had to do all that, but I felt at the time that it was a necessary evil.. Other than code complexity, it made the import system used by Pypubsub rather complicated, which could interfere with freezing.</p><p>
<strong>Driscoll</strong>: Why did you focus on making this transition possible?</p><p>
<strong>Schoenborn</strong>: Because I had to go through that challenge in one of my own applications on a project. It was using the <code class="literal">arg1</code> protocol and migrating it to the new <code class="literal">kwargs</code> protocol. Although not complex, this was somewhat tedious and error prone. It was worth adding these error checkers and going through the transition, due to the advantages of the <code class="literal">kwargs</code> API.</p><p>I had the concept of a parameter that you could set when you imported Pypubsub. This would configure Pypubsub to do some "in-between" tasks, that were useful during a transition between the two messaging protocols. The bridge would allow you to gradually move towards being fully kwargs, with some helpful facilities along the way.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'The code was certainly more complex than I wanted it to be.'</strong>
</p></blockquote></div><p>Getting to a stable API took quite a bit of effort. The frustration was that the code was certainly more complex than I wanted it to be, so it was a harder to maintain and harder to trace calls through Pypubsub. Also, it caused some challenges for people who wanted to freeze their application.</p><p>As soon as I was able to, I suggested we deprecate all of that old stuff, since it was only useful for the wxPython app with the old API. Robin agreed. In 2016, I dropped all support for version 1 and arg1 protocols, allowing for a major clean up and the simplification of the code base. So now there's just one API. This is v4 of Pypubsub.</p><p>
<strong>Driscoll</strong>: So can you tell me about some other <a id="id405" class="indexterm"/>Python projects that you've been involved with lately?</p><p>
<strong>Schoenborn</strong>: Sure, one is a really cool closed-source project, which is very challenging technically, with a very sophisticated GUI. I actually mentioned it indirectly in discussing the reason for working with PyQt in recent years.</p><p>The application shows a canvas on which you can drop boxes and connect them together in different ways. The difference from a tool like Visio is that the user can program these boxes to change in time, like an animation, to represent a process.</p><p>The user does this by defining Python scripts. The application adds a live Python namespace to each user script, so that the user can dynamically query the underlying model (such as code completion on properties dynamically changed in the model).</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'The application adds a live Python namespace to each user script, so that the user can dynamically query the underlying model.'</strong>
</p></blockquote></div><p>So there's a very sophisticated interface for creating model components, adding them, and linking them. There is also a very sophisticated undo function that covers all the different aspects of model editing.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: ' As usual, there was 10% of the feature that occupied 90% of its dev time.'</strong>
</p></blockquote></div><p>We coupled the view to the undo/redo so that the user could always see what was going to be undone, or redone, as they navigated their document. This was an interesting challenge, and as usual, there was 10% of the feature that occupied 90% of its dev time.</p><p>The application is a simulation system, so it's not just creating lines or boxes. There are interface components to manage the simulation, that is, the changing of the model in time, restoring it to its initial state, seeing the queue of changes, etc.</p><p>So there is a very large set of functionality in the application. But PyQt has been awesome to work with in that respect.</p><p>
<strong>Driscoll</strong>: Could you explain a little more about using Qt<a id="id406" class="indexterm"/> for this project? </p><p>
<strong>Schoenborn</strong>: Yes, Qt's Graphics View has <a id="id407" class="indexterm"/>been really impressive in terms of what it has allowed us to do.</p><p>I remember in the beginning, it was not always obvious how to do certain things in Qt. For example, in a canvas-based application, where you can do so many different things, it's super useful to have a state machine to manage what can be done at any given moment. There is no documentation that explains this because it is something that you learn over the years as a useful technique. Note that Qt has built-in support for state machines, but it wasn't sufficiently powerful for our needs.</p><p>A state machine allows you to define states in which only certain actions are possible. So in the "creating line" state, the only thing you can do is cancel creation, drag the mouse, or select the line target. That's where the state machine shines. Without it, your code ends up an unmaintainable spaghetti. Troubleshooting and extending with new actions is so much simpler.</p><p>Although the Qt docs are excellent, there are things you figure out as you go. Sometimes you say, "Oh yeah, I finally understand how to do this. I'm going to backtrack a bit and fix things." You end up with a more robust implementation that can really support the next level of features.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'You end up with a more robust implementation that can really have the next level of features.'</strong>
</p></blockquote></div><p>I'm starting to get kind of familiar with all of the widgets that Qt has. There was a nasty bug that we found, when we upgraded PyQt, that caused a whole interface to show all sorts of lines as you dragged pieces around. Needless to say, that was a problem, but we really needed to update PyQt for other features.</p><p>We traced the problem back to the C++ layer and by some incredible stroke of luck, there was a workaround: there was one line of code that we just had to put in our application at Python level. We didn't even need to change the PyQt source code. As long as we had that one line of code, then the bug would go away. I submitted: <a class="ulink" href="https://bugreports.qt.io/browse/QTBUG-55918">https://bugreports.qt.io/browse/QTBUG-55918</a>.</p><p>Another very interesting aspect of using Qt was unit testing. We needed unit tests for the GUI side of the application. We used the excellent pytest, and had one test suite for the core business logic, and one for the GUI components. Unit testing a GUI can be really challenging: you have to script user actions.</p><p>Luckily, Qt makes this relatively easy, in that you can easily trigger any widget event just by calling a method. But being event based, we needed a way to define a bunch of user actions, with the expected outcome. So I created a library to support doing this. Unfortunately, source is closed, so I could not share the code, but I mentioned the idea on the PyQt forum and some people implemented their own concept of it.</p><p>
<strong>Driscoll</strong>: Python is one of the<a id="id408" class="indexterm"/> major languages being used in the AI and machine learning<a id="id409" class="indexterm"/> boom. What do you think is behind this?</p><p>
<strong>Schoenborn</strong>: I would say that it's the "Olympian" nature of Python that makes it good for AI and machine learning. Python happens to be very strong in many of the necessary elements, instead of just one or two.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'It's the "Olympian" nature of Python that makes it good for AI and machine learning.'</strong>
</p></blockquote></div><p>For example, Python can be used for functional, procedural, or object-oriented coding, in any combination, and the code is still understandable and clean. Moreover, no compilation needed makes the exploration of algorithms and data so easy: you just modify the code and re-run the script.</p><p>Finally, Python provides powerful abstractions using a simple syntax. Maybe I'm biased, but I think that Python is at the top in this respect. I'm big on explicit and clean code, and on refactoring and testing. Being strong at all of these things makes Python the perfect language for AI.</p><p>
<strong>Mike Driscoll: What could be done to make Python a better language for AI and machine learning?</strong>
</p><p>
<strong>Schoenborn</strong>: A language is most useful, in a given problem domain, when the abstractions provided match those of the problem domain.</p><p>So if deep learning uses neural networks, then having a generic concept of a neural net could be really useful.. This is currently provided by libraries like TensorFlow. But perhaps as machine learning algorithms improve, a generic abstraction for a neural net will emerge that can become a basic data structure like lists and maps.</p><p>Also, I think we need the ability to ask the AI/machine learning functions, "How did you get to this result?" That's how humans validate conclusions. They are aware of the logic they used, they can verbalise it, another person can follow it, and they can verify its correctness.</p><p>
<strong>Driscoll</strong>: Many people I have talked to, and even people at PyCon, have put a lot of emphasis on Python growing in the data science field. Are you seeing that in what you're doing, or can you give me any kind of opinion one way or the other?</p><p>
<strong>Schoenborn</strong>: Yeah, Python is really growing in that field. Tools like Jupyter, Anaconda, and scikit-learn are major reasons for this, in my opinion.</p><p>Probably in combination with the fact that with large compute power, the speed of the language no longer matters so much. Python can be used in embedded systems, so in principle some predictive analytics based on trained machine models can happen in the devices themselves.</p><div><blockquote class="blockquote"><p>
<strong>
<strong>Oliver Schoenborn: 'With large compute power, the speed of the</strong>
<strong> language no longers matters so much.'</strong>
</strong>
</p></blockquote></div><p>There was a really interesting presentation at PyCon in 2017. A presenter was surveying the <a id="id410" class="indexterm"/>plotting libraries landscape. The survey started with matplotlib and everything around that. Then the survey moved on to some of the JavaScript libraries, in some cases related to Python libraries. So this was really fascinating, because there is a lot of interest, even for my own clients, in using pandas, NumPy, and matplotlib. This showed that there are many different extensions or layers that you can add.  </p><p>Speaking from a client perspective, you want a certain amount of capability and you don't want to be limited to only matplotlib, because there's so much more that's available. You also know that you don't want to be reinventing the wheel, so you must make sure that what you build is sufficiently generic. If you want to do statistical analysis, then you might want to do it with Jupyter or R. You always try to get a sense of the applications that are providing these capabilities.</p><p>You don't want to force the user to use matplotlib, because it is so diverse and the API is so advanced. There's no way that you can provide a GUI component that supports everything that matplotlib can do.</p><p>Python is such an expressive language and so easy to learn. I think that's why Python is so big now in research and applied research. It's easy to apply, sophisticated and solves technical problems.</p><div><blockquote class="blockquote"><p>
<strong>
<strong>Oliver Schoenborn: 'Python is such an expressive language and so </strong>
<strong>easy to learn. I think that's why Python is so big now in research and applied research.'</strong>
</strong>
</p></blockquote></div><p>Python gives you all of the tools to make and provide something that's robust and deterministic. We can measure performance, find bottlenecks or find memory leaks. There are so many things that really make Python a great tool.</p><p>
<strong>Driscoll</strong>: Have there been any other particularly <a id="id411" class="indexterm"/>memorable PyCon presentations?</p><p>
<strong>Schoenborn</strong>: There was another interesting PyCon 2017 presentation about the Global Interpreter Lock (GIL). In theory, getting rid of the GIL would be so great: we could run Python threads on separate cores.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'In theory, getting rid of the GIL would be so great.'</strong>
</p></blockquote></div><p>But the GIL solves a very practical problem: synchronizing access to Python data structures. You start digging into the GIL by analyzing what would be necessary, and what would be the gain versus the cost. You realize that the GIL really simplifies a lot of things and may well be a reason that it's so easy to do complicated things with Python.</p><p>You can basically get concurrent programming, without all the catches of multi-threaded programming. Most often in a large class of problems, that's what you want. In the other class of problems, you want to tackle trivially parallelizable problems. It's basically where you are subdividing the solution into tasks. There's very little coupling between the tasks and you can do it very easily.</p><p>Monte Carlo is one example because it's very important in simulation and business processes. You basically want to run a large number of things many times, with very little variation between them. Python makes that easy too.</p><p>For trivially parallelizable problems, you need to run those. You can run them on separate cores, just using a multiprocessing module. Yes, there's even that capability! So many different things that are complex in principle, are simple in Python, which makes it so usable for number crunching tasks.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'So many different things that are complex in principle, are simple in Python.'</strong>
</p></blockquote></div><p>But I do think that there should be an easier way to run Python code on multiple cores without having to use the module. There should be language constructs that work hand in hand with the GIL. There is no technical infeasibility there; it's just that there has to be enough concerted effort to make it happen.</p><p>
<strong>Driscoll</strong>: What are you most <a id="id412" class="indexterm"/>excited about in Python today?</p><p>
<strong>Schoenborn</strong>: The optional type annotation system, asynchronous calls, and the multiprocessing module.</p><p>
<strong>Driscoll</strong>: Which language is Python's biggest competitor would you say?</p><p>
<strong>Schoenborn</strong>: JavaScript. It's just so unfortunate that JavaScript dominates the web side of things. There are these two major contenders: JavaScript on the web and Python in technical computing. If you really need the raw compute speed, then you can do C++.</p><p>You can get major speedups in Python, by writing some C++ code and ingesting it in Python via SWIG and SIP. There is also Cython. It's so easy to work at a high level of abstraction with Python, with that compute power when you need it from C++.</p><p>I don't know where that's going to go. I think that a lot of things would have to happen on the JavaScript side to make it as powerful and as simple to use as Python, but on the other hand, I can't see Python becoming a supported language in the web browser, because JavaScript is just too established. Maybe if Google decides to make Python code runnable from Chrome.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'A lot of things would have to happen on the JavaScript side to make it as powerful and simple to use as Python.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: So is Python here to stay?</p><p>
<strong>Schoenborn</strong>: I think that Python is here to stay. Python is too good a language and its community has developed good quality and solid libraries, and language evolution processes via PEPs. There is a very rigorous process for Python and a lot of smart people working on it. So it's here to stay for sure.</p><p>
<strong>Driscoll</strong>: What do you think about the long life of Python 2.7? Should people move over to the latest version?</p><p>
<strong>Schoenborn</strong>: The long life<a id="id413" class="indexterm"/> of Python 2.7 is most irritating! Big influencers, like Ubuntu and Google Cloud Platform, must start making Python 3.6 their default.</p><div><blockquote class="blockquote"><p>
<strong>Oliver Schoenborn: 'The long life of Python 2.7 is most irritating!'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: What changes <a id="id414" class="indexterm"/>would you like to see in future Python releases?</p><p>
<strong>Schoenborn</strong>: I would like to see an optional static typing system with type inference (so types do not need declaration), true parallelism, and an optional compilation mode.</p><p>The combination of optional static typing, compilation, and type inference would allow the language to stay simple when starting, and get more rigorous when needed.</p><p>It could also provide massive gains in speed and productivity: it's always a time saver to be able to point to any object and know exactly what operations are either available on it, or required of it (within a function signature). Realistically, I don't know if a compilation mode (even JIT) that freezes types is feasible, but there are some incredibly smart people out there, so I would not discount it.</p><p>With regards to parallelism, I'm referring to the ability to run Python code on multiple cores simultaneously, while keeping the GIL. Sure, there is the multiprocessing module, but I'm talking about constructs built into the language itself as first-class citizens.</p><p>
<strong>Driscoll</strong>: Thank you, Oliver Schoenborn.</p></div></body></html>