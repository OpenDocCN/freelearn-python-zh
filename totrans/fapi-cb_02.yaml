- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data handling** is the backbone of any web application, and this chapter
    is dedicated to mastering this critical aspect. You will embark on a journey of
    working with data in FastAPI, where you’ll learn the intricacies of integrating,
    managing, and optimizing data storage using both **Structured Query Language**
    (**SQL**) and **NoSQL** databases. We’ll cover how FastAPI, combined with powerful
    database tools, can create efficient and scalable data management solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with SQL databases, you’ll get hands-on experience in setting up a
    database, implementing **create, read, update and delete** (**CRUD**) operations,
    and understanding the nuances of working with SQLAlchemy – a popular **object-relational
    mapping** (**ORM**) option for Python. We’ll then shift gears to NoSQL databases,
    delving into the world of **MongoDB.** You’ll learn how to integrate it with FastAPI,
    handle dynamic data structures, and leverage the flexibility and scalability of
    NoSQL solutions.
  prefs: []
  type: TYPE_NORMAL
- en: But it’s not just about storing and retrieving data. This chapter also focuses
    on best practices for securing sensitive data and managing transactions and concurrency
    in your databases. You’ll explore how to protect your data from vulnerabilities
    and ensure the integrity and consistency of your application’s data operations.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll not only have a solid understanding of how
    to work with various database systems in FastAPI but also the skills to build
    robust and secure data models for your web applications. Whether it’s implementing
    complex queries, optimizing database performance, or ensuring data security, this
    chapter provides the tools and knowledge you need to manage your application’s
    data effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding CRUD operations with SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating MongoDB for NoSQL data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with data validation and serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with file uploads and downloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling asynchronous data operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing sensitive data and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each topic is designed to equip you with the necessary skills and knowledge
    to handle data in FastAPI efficiently, ensuring your applications are not only
    functional but also secure and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To effectively run and understand the code in this chapter, ensure you have
    the following set up. If you’ve followed [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020),
    *First Steps with FastAPI*, you should already have some of these installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**: Make sure you’ve installed Python version 3.9 or higher on your
    computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip install fastapi[all]` command. As we saw in [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020),
    *First Steps with FastAPI*, this command also installs **Uvicorn**, an ASGI server
    that’s necessary to run your FastAPI application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated development environment** (**IDE**): A suitable IDE such as **VS
    Code** or **PyCharm** should be installed. These IDEs offer excellent support
    for Python and FastAPI development, providing features such as syntax highlighting,
    code completion, and easy debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MongoDB**: For the NoSQL database portions of this chapter, MongoDB needs
    to be installed on your local machine. Download and install the free community
    version server suitable for your operating system from [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure that MongoDB is correctly installed by running from the command line
    the Mongo Deamon:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ C:\Program>Files\MongoDB\Server\7.0\bin\mongod -- version
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**MongoDB tools**: While optional, tools such as the **MongoDB Shell** ([https://www.mongodb.com/try/download/shell](https://www.mongodb.com/try/download/shell))
    and **MongoDB Compass GUI** ([https://www.mongodb.com/try/download/compass](https://www.mongodb.com/try/download/compass))
    can greatly enhance your interaction with the MongoDB server. They provide a more
    user-friendly interface for managing databases, running queries, and visualizing
    data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code and examples used throughout this chapter are available on GitHub
    for reference and download. Visit [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter02](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter02)
    on GitHub to access the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of data handling, the power of Python meets the efficiency of SQL
    databases. This recipe aims to introduce you to how to integrate SQL databases
    within your application, a crucial skill for any developer looking to build robust
    and scalable web applications.
  prefs: []
  type: TYPE_NORMAL
- en: SQL is the standard language for managing and manipulating relational databases.
    When combined with FastAPI, it unlocks a world of possibilities in data storage
    and retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI’s compatibility with SQL databases is facilitated through ORMs. The
    most popular one is **SQLAlchemy**. We will focus on it in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, you’ll need to have FastAPI and SQLAlchemy installed in your virtual
    environment. If you followed the steps in [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020),
    *First Steps with FastAPI*, you should have FastAPI already set up. For SQLAlchemy,
    a simple `pip` command is all that’s needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, the next step is to configure SQLAlchemy so that it can work
    with FastAPI. This involves setting up the database connection – a process we
    will walk through step by step.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s dive deeper into configuring SQLAlchemy for your FastAPI application.
    SQLAlchemy acts as the bridge between your Python code and the database, allowing
    you to interact with the database using Python classes and objects rather than
    writing raw SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: After installing SQLAlchemy, the next step is to configure it within your FastAPI
    application. This involves defining your database models – a representation of
    your database tables in Python code. In SQLAlchemy, models are typically defined
    using classes, with each class corresponding to a table in the database, and each
    attribute of the class corresponding to a column in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Follow these steps to go through the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `sql_example`, move inside it, and then create a
    file called `database.py` there. Write a `base` class to be used as a reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To define a model in SQLAlchemy, you need to create a base class that derives
    from the `DeclarativeBase` class. This `Base` class maintains a catalog of classes
    and tables you’ve defined and is central to SQLAlchemy’s ORM functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can learn more by reading the official documentation: [https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.xhtml](https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.xhtml).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have your `Base` class, you can start defining your models. For instance,
    if you have a table for users, your model might look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this model, `User` class corresponds to a table named `user` in the database,
    with columns for `id`, `name`, and `email`. Each `class attribute` specifies the
    data type of the column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once your models have been defined, the next step is to connect to the database
    and create these tables. SQLAlchemy uses a connection string to define the details
    of the database it needs to connect to. The format of this connection string varies
    depending on the database system you are using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, a connection string for a SQLite database might look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`test.db` database file the first time you connect to it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will use the `DATABASE_URL` connection string to create an `Engine` object
    in SQLAlchemy that represents the core interface to the database:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the engine created, you can proceed to create your tables in the database.
    You can do this by passing your `base` class and the engine to SQLAlchemy’s `create_all`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you’ve defined all the abstractions of the database in your code, you
    can proceed with setting the database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a database connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final part of setting up a SQL database setup is establishing a database
    connection. This connection allows your application to communicate with the database,
    executing queries and retrieving data.
  prefs: []
  type: TYPE_NORMAL
- en: Database connections are managed with sessions. A session in SQLAlchemy represents
    a *workspace* for your objects, a place where you can add new records or fetch
    existing ones. Each session is bound to a single database connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage sessions, we need to create a `SessionLocal` class. This class will
    be used to create and manage session objects for the interactions with the database.
    Here’s how you can create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `sessionmaker` function creates a factory for sessions. The `autocommit`
    and `autoflush` parameters are set to `False`, meaning you have to manually commit
    transactions and manage them when your changes are flushed to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `SessionLocal` class in place, you can create a function that will
    be used in your FastAPI route functions to get a new database session. We can
    create it in the `main.py` module like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In your route functions, you can use this function as a dependency to communicate
    with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In FastAPI, this can be done with the `Depends` class. In the `main.py` file,
    you can then add an endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This approach ensures that a new session is created for each request and closed
    when the request is finished, which is crucial for maintaining the integrity of
    your database transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then run the server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the endpoint `GET` at `localhost:8000/users` you will get
    an empty list since no users have been added already.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can discover more on how to set up a session in **SQLAlchemy** on the documentation
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SQLAlchemy* *session*: [https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml](https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding CRUD operations with SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After setting up your SQL database with FastAPI, the next crucial step is creating
    database models. This process is central to how your application interacts with
    the database. **Database models** in SQLAlchemy are essentially Python classes
    that represent tables in your SQL database. They provide a high-level, object-oriented
    interface to manipulate database records as if they were regular Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will set up the **create, read, update and delete** (**CRUD**)
    endpoints to interact with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the models set up, you can now implement CRUD operations. These operations
    form the backbone of most web applications, allowing you to interact with the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For each operation, we will create a dedicated endpoint implementing the interacting
    operation with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a new user, we’ll use a `POST` request. In the `main.py` file, we must
    define an endpoint that receives user data, creates a new `User` instance in the
    body request, and adds it to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In a few lines, you’ve created the endpoint to add a new user to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a specific user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get a single user, we are going to use a `GET` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint will return a `404` response status if the user does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Updating a record via an API offers various approaches, including `PUT`, `PATCH`,
    or `POST` methods. Despite theoretical nuances, the choice of method often boils
    down to personal preference. I favor using a `POST` request and augmenting the
    `/user` endpoint with a `user_id` parameter. This simplifies the process, minimizing
    the need for extensive memorization. You can integrate this endpoint within the
    `main.py` module like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is all you need to do to create the endpoint to update a user record in
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To conclude, deleting a user within the same `main.py` module involves utilizing
    a `DELETE` request, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These endpoints cover the basic CRUD operations and demonstrate how FastAPI
    can be integrated with SQLAlchemy for database operations. By defining these endpoints,
    your application can create, retrieve, update, and delete user data, providing
    a fully functional API for client interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have implemented all the operations, you can spin the server by
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then open the inreactive documentation at `http://localhost:8000/docs` and start
    playing with the endpoints by creating, reading, updating and deleting users.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering these CRUD operations in FastAPI is a significant step in building
    dynamic and data-driven web applications. With the knowledge of how to integrate
    FastAPI endpoints with SQLAlchemy models, you are well-equipped to develop complex
    and efficient applications.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find a clear quick start on how to set up the ORM for CRUD operations
    with SQLAlchemy on the official documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SQLAlchemy ORM Quick* *Start*: [https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml](https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating MongoDB for NoSQL data storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transitioning from SQL to NoSQL databases opens up a different paradigm in data
    storage and management. **NoSQL databases**, like MongoDB, are known for their
    flexibility, scalability, and ability to handle large volumes of unstructured
    data. In this recipe, we’ll explore how to integrate MongoDB, a popular NoSQL
    database, with FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases differ from traditional SQL databases in that they often allow
    for more dynamic and flexible data models. MongoDB, for example, stores data in
    **binary JSON** (**BSON**) format, which can easily accommodate changes in data
    structure. This is particularly useful in applications that require rapid development
    and frequent updates to the database schema.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you’ve installed MongoDB on your machine. If you haven’t done it yet,
    you can download the installer from [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI doesn’t provide a built-in ORM for NoSQL databases. However, integrating
    MongoDB into FastAPI is straightforward thanks to Python’s powerful libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use `pymongo`, a Python package driver to interact with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: First, ensure you have MongoDB installed and running on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can install `pymongo` with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With `pymongo` installed, we can now establish a connection to a MongoDB instance
    and start performing database operations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can quickly connect our application to a Mongo DB instance running on our
    local machine by by applying the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project folder called `nosql_example`. Start by defining connection
    configuration in a `database.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, `mydatabase` is the name of your database. You can replace
    it with the name you prefer. Here, `MongoClient` establishes a connection to a
    MongoDB instance running locally on the *default port* *of 27017*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the connection has been set up, you can define your collections (equivalent
    to tables in SQL databases) and start interacting with them. MongoDB stores data
    in collections of documents, where each document is a JSON-like structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `user_collection` is a reference to the `users` collection in your MongoDB
    database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test the connection, you can create an endpoint that will retrieve all users
    that should return an empty list in a `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run your `mongod` instance. You can do it from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run on Windows the command will be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that''s it. To test it, in a separate terminal window, spin up the FastAPI
    server by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Then, simply open your browser at http://localhost:8000/users; you will get
    an empty list. This means that your database connection is correctly working.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the connection has been set up, we are going to create an endpoint
    to add a user and one to retrieve a specific user with an ID. We’ll create both
    endpoints in the `main.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a new document to a collection, use the `insert_one` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint we’ve just created returns the affected `id` number in the response
    to be used as input for other endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To retrieve a document, you can use the `find_one` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If the user with the specified ID doesn’t exist, it will return a response status
    of 404.
  prefs: []
  type: TYPE_NORMAL
- en: In Mongo, the ID of the document is not stored in plain text, but in a 12-byte
    object. That’s why we need to initialize a dedicated `bson.ObjectId` when querying
    the database and explicitly decode to `str` when returning the value through the
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then spin up the server with `uvicorn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the endpoints on the interactive documentation page: [http://localhost:8000/docs](http://localhost:8000/docs).
    Ensure you test every endpoint and the interaction among them thoroughly.'
  prefs: []
  type: TYPE_NORMAL
- en: By integrating MongoDB with FastAPI, you gain the ability to handle dynamic,
    schemaless data structures, which is a significant advantage in many modern web
    applications. This recipe has equipped you with the knowledge to set up MongoDB,
    define models and collections, and perform CRUD operations, providing a solid
    foundation for building versatile and scalable applications with FastAPI and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can dig into how to use the **PyMongo** Python client by reading the official
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*PyMongo* *documentation*: [https://pymongo.readthedocs.io/en/stable/](https://pymongo.readthedocs.io/en/stable/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with data validation and serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effective data validation stands as a cornerstone of robust web applications,
    ensuring that incoming data meets predefined criteria and remains safe for processing.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI harnesses the power of Pydantic, a Python library dedicated to data
    validation and serialization. By integrating Pydantic models, FastAPI streamlines
    the process of validating and serializing data, offering an elegant and efficient
    solution. This recipe shows how to utilize Pydantic models within FastAPI applications,
    exploring how they enable precise validation and seamless data serialization.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pydantic models** are essentially Python classes that define the structure
    and validation rules of your data. They use Python’s type annotations to validate
    that incoming data matches the expected format. When you use a Pydantic model
    in your FastAPI endpoints, FastAPI automatically validates incoming request data
    against the model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we’re going to use Pydantic’s email validator, which comes
    with the default `pydantic` package distribution. However, it needs to be installed
    in your environment. You can do this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once the package has been installed, you are ready to start this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s use it in the previous project. In the `main.py` module, we’ll modify
    the `UserCreate` class, which is used to accept only valid `email` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"name": "John Doe",'
  prefs: []
  type: TYPE_NORMAL
- en: '"email": "invalidemail.com",'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'class UserResponse(User):'
  prefs: []
  type: TYPE_NORMAL
- en: 'id: str'
  prefs: []
  type: TYPE_NORMAL
- en: '@app.get("/user")'
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_user(user_id: str) -> UserResponse:'
  prefs: []
  type: TYPE_NORMAL
- en: db_user = user_collection.find_one(
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"_id": ObjectId(user_id)'
  prefs: []
  type: TYPE_NORMAL
- en: if ObjectId.is_valid(user_id)
  prefs: []
  type: TYPE_NORMAL
- en: else None
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'if db_user is None:'
  prefs: []
  type: TYPE_NORMAL
- en: raise HTTPException(
  prefs: []
  type: TYPE_NORMAL
- en: status_code=404,
  prefs: []
  type: TYPE_NORMAL
- en: detail="User not found"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: db_user["id"] = str(db_user["_id"])
  prefs: []
  type: TYPE_NORMAL
- en: User object and then serializes the returned UserResponse object back into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: This automatic serialization and deserialization make working with JSON data
    in FastAPI straightforward and type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced validation techniques
  prefs: []
  type: TYPE_NORMAL
- en: '**Pydantic** offers a range of advanced validation techniques that you can
    leverage in FastAPI. These include custom validators and complex data types.'
  prefs: []
  type: TYPE_NORMAL
- en: '`@field_validator`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could add a validator to ensure that a user’s age is within
    a certain range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'class Tweet(BaseModel):'
  prefs: []
  type: TYPE_NORMAL
- en: 'content: str'
  prefs: []
  type: TYPE_NORMAL
- en: 'hashtags: list[str]'
  prefs: []
  type: TYPE_NORMAL
- en: 'class User(BaseModel):'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: str'
  prefs: []
  type: TYPE_NORMAL
- en: 'email: EmailStr'
  prefs: []
  type: TYPE_NORMAL
- en: 'age: Optional[int]'
  prefs: []
  type: TYPE_NORMAL
- en: User model has an optional tweets field, which is a list of Tweet objects.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging Pydantic’s advanced validation features, you can ensure that the
    data your FastAPI application processes is not only in the correct format but
    also adheres to your specific business logic and constraints. This provides a
    robust and flexible way to handle data validation and serialization in your FastAPI
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the potential of Pydantic validators on the documentation
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pydantic* *validators*: [https://docs.pydantic.dev/latest/concepts/validators/](https://docs.pydantic.dev/latest/concepts/validators/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with file uploads and downloads
  prefs: []
  type: TYPE_NORMAL
- en: Handling files is a common requirement in web applications, whether it’s uploading
    user avatars, downloading reports, or processing data files. FastAPI provides
    efficient and easy-to-implement methods for both uploading and downloading files.
    This recipe will guide you through how to set up and implement file handling in
    FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new project directory called `uploads_and_downloads` that contains
    a `main.py` module with a folder called `uploads`. This will contain the files
    from the application side. The directory structure will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can now proceed to create the appropriate endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: To handle file uploads in FastAPI, you must use the `File` and `UploadFile`
    classes from FastAPI. The `UploadFile` class is particularly useful as it provides
    an asynchronous interface and spools large files to disk to avoid memory exhaustion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.py` module, you can define the endpoint to upload files like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `upload_file` is an endpoint that accepts an uploaded file
    and returns its filename. The file is received in the form of an `UploadFile`
    object, which you can then save to disk or process further.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing file uploads
  prefs: []
  type: TYPE_NORMAL
- en: When implementing file uploads, it’s essential to handle the file data correctly
    to ensure it is saved without corruption. Here’s an example of how you can save
    the uploaded file to a directory on your server.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder project called `uploads_downloads`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.py` module, create the `upload_file` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet opens a new file in write-binary mode in the `uploads` directory
    and uses `shutil.copyfileobj` to copy the file content from the `UploadFile` object
    to the new file.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, remember to handle exceptions and errors appropriately,
    especially for larger files
  prefs: []
  type: TYPE_NORMAL
- en: Create a text file called `content.txt` with some text in it.
  prefs: []
  type: TYPE_NORMAL
- en: Start the server by running the `uvicorn main:app` command. Then, access the
    interactive documentation; you’ll observe that the endpoint we just created for
    file uploads includes a mandatory field prompting users to upload a file. Upon
    testing the endpoint by uploading a file, you’ll discover the uploaded file residing
    within the designated `uploads` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Managing file downloads and storage
  prefs: []
  type: TYPE_NORMAL
- en: Downloading files is the reverse process of uploading. In FastAPI, you can easily
    set up an endpoint to serve files for download. The `FileResponse` class is particularly
    useful for this purpose. It streams files from the server to the client, making
    it efficient for serving large files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple file download endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `download_file` is an endpoint that serves files from the `uploads`
    directory for download. Here, `FileResponse` automatically sets the appropriate
    content-type header based on the file type and handles streaming the file to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: The content of the file will be the response body of the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Handling file storage is another crucial aspect, especially when dealing with
    a large number of files or large file sizes. It’s often advisable to store files
    in a dedicated file storage system rather than directly on your web server. Cloud
    storage solutions such as **Amazon S3**, **Google Cloud Storage**, or **Azure
    Blob Storage** can be integrated into your FastAPI application for scalable and
    secure file storage. Additionally, consider implementing cleanup routines or archival
    strategies to manage the life cycle of the files you store.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about how to manage uploaded files on the official documentation
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*FastAPI request* *files*: [https://fastapi.tiangolo.com/tutorial/request-files/](https://fastapi.tiangolo.com/tutorial/request-files/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling asynchronous data operations
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous programming** is a core feature of FastAPI that allows you to
    develop highly efficient web applications. It allows your application to handle
    multiple tasks concurrently, making it particularly well-suited for I/O-bound
    operations, such as database interactions, file handling, and network communication.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s delve into leveraging asynchronous programming in FastAPI for data operations,
    enhancing the performance and responsiveness of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI is built on Starlette and Pydantic, which provide a robust foundation
    for writing asynchronous code in Python using the `asyncio` library with `async`/`await`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncio` library allows you to write non-blocking code that can pause its
    execution while waiting for I/O operations to complete, and then resume where
    it left off, all without blocking the main execution thread.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates the benefits of using `asyncio` with FastAPI in a simple,
    practical example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an application with two endpoints, one that runs a sleeping operation,
    the other that run the sleeping operation as well but in asynchrounous mode. Create
    a new project folder called `async_example` containing the `main.py` module. Fill
    the module as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the FastAPI server object class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Now, let’s create an endpoint that sleeps for 1 second:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The sleeping operation represents the waiting time to get a response from the
    database in a real-life scenario.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.  Now, let’s create the same endpoint for the `async def` version. The sleeping
    operation will be the sleep function from the `asyncio` module:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have two endpoints, `GET /sync` and `GET/async`, that are similar except
    for the fact the second contains a non-blocking sleeping operation.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our application with the endpoints, let's create a separate Python
    script to measure the time to serve a traffic demand. Let’s call it `timing_api_calls.py`
    and start building it through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the function to run the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Now, let’s define the start of the server as a context manager:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  Now, we can define a function that makes *n* concurrent requests to a specified
    path endpoint:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '4.  At this point, we can gather the operations into a main function, make
    *n* calls for each of the endpoints, and print the time to serve all the calls
    to the terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '5.  Finally, we can run the main function in the `asyncio` event loop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have built our timing script, let''s run it from the command terminal
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Time taken to make 10 requests to sync endpoint: 2.3172452449798584 seconds'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time taken to make 10 requests to async endpoint: 2.3033862113952637 seconds'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: asyncio.run(main(n=100))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Time taken to make 100 requests to sync endpoint: 6.424988269805908 seconds'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time taken to make 100 requests to async endpoint: 2.423431873321533 seconds'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
