- en: Chapter 6. Making the 2048 Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next few chapters, we will build a series of increasingly complex game
    projects to demonstrate some of the concepts commonly associated with game development:
    state management, controls, sound effects, and fast shader-based graphics, to
    name a few.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important thing to consider upfront is that no approach is actually unique
    to game development: there are whole other classes of software that use the same
    algorithms and performance hacks as video games.'
  prefs: []
  type: TYPE_NORMAL
- en: However, let's start small and gradually work our way to complex things. Our
    first project is re-implementing the relatively well-known **2048** board game.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will shed light on a number of Kivy techniques that are practically
    required when developing games:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Kivy widgets with custom visual appearance and behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing on canvas and utilizing built-in graphics instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using absolute positioning to arrange widgets arbitrarily on screen (as opposed
    to relying on a structured layout)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving widgets smoothly using Kivy's built-in support for animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning widgets in absolute coordinates may sound like a regression after
    getting used to layout classes, but it's necessary in highly interactive applications
    such as games. For example, a rectangular playing field of many board games can
    be represented by a `GridLayout`, but even a basic animation such as movement
    from cell to cell will be tricky to implement. Such a task is doomed to include
    widget reparenting in some form; this alone pretty much marginalizes any gains
    from using a fixed layout.
  prefs: []
  type: TYPE_NORMAL
- en: About the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the uninitiated, the game of 2048 is a math puzzle where you combine numbers
    to get to 2048 and possibly beyond that, to 4096 and 8192 (albeit this may prove
    challenging, so 2048 is a sufficiently hard-to-achieve winning condition). The
    board is a 4×4 square grid. It is mostly empty at first, with a few **2** tiles.
    Each turn the player moves all tiles in the same direction of choice: up, right,
    down, or left. If a tile cannot advance in that direction (there is no free space
    available), then it stays put in place.'
  prefs: []
  type: TYPE_NORMAL
- en: '![About the game](img/B01620_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The 2048 board (a screenshot from the original game)
  prefs: []
  type: TYPE_NORMAL
- en: 'When two tiles having the same value touch (or rather, attempt to move on top
    of one another), they merge into one and sum up, increasing the tile nominal to
    a next power of two. So the progression looks like this: 2, 4, 8, 16, ... , 2048
    and so on; programmers usually find this sequence familiar. After each turn, another
    **2** tile is spawned in a random empty space.'
  prefs: []
  type: TYPE_NORMAL
- en: The original version of 2048 also sometimes creates **4** instead of **2**;
    this is a minor feature that won't be addressed in this chapter, but should be
    rather simple to implement.
  prefs: []
  type: TYPE_NORMAL
- en: The game ends if there are no valid moves available to the player (the board
    is filled up in an unfortunate combination where no tiles of the same value are
    next to each other). You can play the original game of 2048 at [http://gabrielecirulli.github.io/2048/](http://gabrielecirulli.github.io/2048/).
  prefs: []
  type: TYPE_NORMAL
- en: Gameplay concepts and overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Games are generally very much stateful: the application goes through a number
    of distinctive states, such as the start screen, world map, town screen, and so
    on, depending on the specifics of the game. Certainly, each game is very different
    and there aren''t many aspects that are common across a significant number of
    games.'
  prefs: []
  type: TYPE_NORMAL
- en: One such aspect, and very basic at that, is that most games have either a win
    or a loss condition, often both. This may sound trivial, but these conditions
    and associated game states may have a tremendous impact on player's engagement
    and perception of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are games that are completely endless by design and have no connotation
    of the "game over" state (neither win nor loss) within the rules, and they are
    incredibly hard to get right in terms of player motivation. Such games also commonly
    provide a state of strong local advantage and disadvantage to compensate.
  prefs: []
  type: TYPE_NORMAL
- en: For example, while you cannot win the game or die completely and get into a
    "game over" state in World of Warcraft, or numerous other MMORPG titles that followed
    the same design concepts, you are certainly punished for neglecting your character's
    health and stats by having to perform in-game revival and associated tasks like
    repairing broken equipment.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you're exceptionally good, oftentimes you can team up with other highly
    skilled players and obtain items that aren't otherwise obtainable (and hence are
    unavailable to bad or casual players). This includes numerous boss encounters,
    raids, and those hard-to-get achievements.
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned losing condition found in 2048—the game ends when there are
    no available moves on the board—works great in practice because it makes the game
    gradually harder towards the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the very beginning, the game isn''t difficult at all: the player can basically
    perform completely random moves without any strategy. New tiles are added to the
    board having the same value, so it''s impossible to fill all cells and run out
    of valid moves during first few turns, even on purpose—all the tiles are compatible
    and can be combined, no matter which direction the player chooses to move.'
  prefs: []
  type: TYPE_NORMAL
- en: However, as you progress further in the game and variation is introduced to
    the board, free cells become increasingly scarcer. Since different values cannot
    be merged together, board management quickly becomes a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gameplay mechanics is what makes 2048 so engaging: it''s really easy to start,
    the rules are simple and don''t change over the course of the game, and 2048 doesn''t
    punish experimentation in the beginning, even in the form of clearly suboptimal
    behavior, until much later in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: Randomness, or lack thereof
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since all tiles (up to 16) move at once, some of the resulting situations may
    have not been foreseen by players if they don't pay close attention. Albeit completely
    deterministic, this algorithm is perceived as having a touch of randomness to
    it. This also helps engagement by making 2048 feel more like an arcade game, slightly
    unpredictable and surprising.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is generally a good thing: random encounters (or more accurately, encounters
    that are perceived as random, like in this case) may add life to an otherwise
    linear process, making the gameplay more interesting.'
  prefs: []
  type: TYPE_NORMAL
- en: The 2048 project outline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To summarize, the following are the defining characteristics of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: The playing field (the board) is 4×4 cells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following actions occur during each turn:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player moves all tiles in a direction of choice
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Colliding two tiles having the same value produces one tile of greater value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: New **2** tile is spawned in empty space
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The player wins by creating a **2048** tile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game ends when there are no valid moves left (that is, none of the possible
    moves can change the situation on the board anymore)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This checklist will come in handy later on, as it forms the essential technical
    outline of what we're going to implement in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What makes 2048 a good choice of project?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One might ask whether re-implementing an existing game is a sound idea. The
    answer is, by all means, yes; a more detailed explanation follows.
  prefs: []
  type: TYPE_NORMAL
- en: This is slightly off-topic when talking about practical software development,
    but the rationale to recreate a well-known project may not be obvious. If this
    chapter's approach makes perfect sense to you without lengthy explanations, then
    feel free to skip to the next section where the actual development begins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support the choice of 2048 (and the approach of "re-implementing the wheel"
    as a whole), let''s first assume the following: game development is extremely
    challenging on many different levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Interesting game designs are hard to come by. There has to be a central idea
    to game mechanics, which may require a healthy amount of creativity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good game requires that gameplay isn't way too complex, which may quickly
    lead to frustration, but not too easy and therefore boring either. Balancing this
    may sound simple at first, but is usually hard to get right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some algorithms are harder than others. Path-finding on a flat, tiled map is
    easily approachable, but path-finding in a dynamic arbitrary three-dimensional
    space is a whole other story; **artificial intelligence** (**AI**) for a shooter
    may be simplistic and still deliver excellent results, while AI for a strategy
    game has to be clever and unpredictable to provide sufficient challenge and variety.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attention to detail and the amount of polish that makes a good game can
    be downright overwhelming, even to professionals working in the field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is by no means exhaustive and serves not to scare everyone away from
    game development, but to get the point across—there are many things that can go
    wrong, so don't hesitate to offload some of the tasks to a third party. This increases
    your chances of delivering a working project and reduces the associated amount
    of frustration.
  prefs: []
  type: TYPE_NORMAL
- en: A go-to approach in gamedev (especially a sporadic, zero-budget effort like
    this book's projects) is to avoid costly creative search, especially in terms
    of gameplay. If you cannot get the project out of the door, its uniqueness is
    of very little value. That's why one should reuse as many existing elements as
    possible when building a new game.
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to copy someone else's ideas verbatim, of course—tweaking every
    aspect of the game can be fun and a very rewarding endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, most games borrow ideas, gameplay, and sometimes even visual attributes
    from their predecessors, and there is very little variety overall (this isn't
    necessarily a good thing, just the state of today's industry, for better or worse).
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity as a feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting back to the 2048 game, it's worth noting that its rules are very simple,
    borderline trivial. The fun factor, however, is inexplicably high; 2048 was very
    popular for a relatively long time, with numerous spin-offs flooding the Internet
    and app stores.
  prefs: []
  type: TYPE_NORMAL
- en: This alone makes the game of 2048 well worth rebuilding from scratch, even more
    so for the purpose of learning. Let's assume that at this point you're entirely
    convinced that 2048 is a fantastic choice of a project, and are eager to move
    on to actual development.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the 2048 board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until now, we were relying on existing Kivy widgets, customizing them as
    needed to fit our specific use case. For this application, we''re going to build
    our own unique widgets: `Board` (the playing field) and `Tile`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the simple stuff and create the background for the playing
    field. The most unimaginative way to do so would be just using a static image;
    this approach has many problems, for example, it does not support the multitude
    of possible screen sizes properly (remember that we're talking about both desktop
    and mobile at the same time, so the screen size can vary wildly).
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we will create the `Board` widget that renders the playing field graphics
    onto its canvas. This way, the board's positioning and size will be given declaratively
    in a Kivy language file, same as with other widgets we've used before (such as
    text labels and buttons).
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the easiest thing to start with is indeed setting the position and
    size of a board. To do this efficiently, we can use `FloatLayout`; this is one
    of the simplest layout classes provided by Kivy, which uses just the size and
    position hints. The following listing pretty much summarizes the usage of `FloatLayout`
    (this code resides in the `game.kv` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Board` widget is centered on the screen, both vertically and horizontally.
    In order to account for any possible screen orientation or aspect ratio, we compute
    board size by picking the smaller side of the screen (either width or height)
    and subtracting the padding twice (we want the same gap from both sides). The
    board is square, so its dimensions are equal.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `[...] * 2` trick on the `size:` line is a fairly standard Python feature
    to avoid repeating the same value in a list or tuple many times over when initializing
    the data structure, for example, `[1] * 3` equals `[1, 1, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid confusion with the arithmetic multiplication, we employ this feature
    sparingly. However, in production you should consider using this syntax where
    appropriate, as it's more concise than writing the same repetitive list or tuple
    by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see the result of our work so far, we need to define the `Board`
    widget itself and make it render something (by default, empty widgets are completely
    invisible). This will take place in the `main.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the definition of `padding` in `game.kv`, we define `spacing` at
    the top of the Python source code. This is the distance between two adjacent cells
    and from an edge of the board to an edge of the nearby cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `resize()` method plays a central role in this part of the code: it''s
    called when the `Board` widget is created (directly from `__init__()`) or repositioned
    (with the help of `on_pos` and `on_size` event callbacks). If the widget was indeed
    resized, we compute the new `cell_size` up front; it''s a very simple computation
    actually, so it won''t hurt even if the size of the widget did not change between
    invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the 2048 board](img/7849OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *size* means either width or height, since all objects in question are
    square.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we render the background. We clear the `canvas.before` graphics instruction
    group and fill it with primitives (which are represented by just `BorderImage`
    at the moment). The `canvas.before` group, as opposed to `canvas.after` or just
    `canvas`, is executed first when a widget is being rendered. This makes it perfect
    for background imagery that needs to be below any child other graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Canvas instruction groups are Kivy's way of organizing lower-level graphical
    operations, such as copying image data to canvas, drawing lines, and performing
    raw OpenGL calls. For a brief introduction to using the canvas, refer to [Chapter
    2](ch02.html "Chapter 2. Building a Paint App"), *Building a Paint App*.
  prefs: []
  type: TYPE_NORMAL
- en: Individual canvas instructions, living in the `kivy.graphics` namespace, are
    conceptually children of a `canvas` object (or `canvas.before` and `canvas.after`),
    just like leaf widgets are children of a container or root widget. Hierarchical
    definitions in code also look very similar.
  prefs: []
  type: TYPE_NORMAL
- en: An important difference, however, is that widgets have a complex lifecycle,
    can align themselves on the screen, respond to events, and do more. Rendering
    instructions, on the contrary, are just that—mostly self-contained primitives
    for drawing. For example, the `Color` instruction changes the color (tint) for
    next instructions in queue, if any; `Image` draws an image on canvas; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For now, the background is just a rectangle. It has rounded corners, thanks
    to the background image, `board.png`, rendered using the `BorderImage` instruction—a
    9-patch technique described in [Chapter 1](ch01.html "Chapter 1. Building a Clock
    App"), *Building a Clock App*, similar to how bordered buttons were implemented
    in all previous examples over the course of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Going through cells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our playing field is two-dimensional, and traversing a two-dimensional array
    can be achieved in a very obvious fashion by nesting `for` loops like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only is this unwieldy and adds two levels of indentation, but also leads
    to repetitive code when used in many places throughout the program, which is undesirable.
    In Python, we can refactor this code using a generator function as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The generator function itself looks similar to the straightforward approach
    shown in the previous code snippet. Its usage, however, is clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is basically the same code running two nested loops, but the details of
    those are abstracted, and as such we have a tidy one-liner, which is also more
    customizable than the code interspersed with literal `for` loops over each coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we will refer to board coordinates (those that designate
    a board cell, as opposed to pixel coordinates of rendered objects on screen) as
    `board_x` and `board_y`.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering empty cells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The position and size of the game board as a whole are defined by placement
    of the `Board` widget, but the location of individual cells is yet undefined.
    Next, we're going to compute each cell's coordinates on screen and draw all cells
    on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of a cell on screen, taking `spacing` into account, can be calculated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Canvas operations typically expect absolute coordinates, and this is why we're
    adding the `Board` location (`self.x`, `self.y`) to the computed value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can iterate over the playing field and compute an onscreen position
    of each cell based on its board location, the only thing that''s left is actually
    rendering cells on the canvas. Tweaking the `canvas.before` code as follows should
    suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When rendering images, the `Color` instruction serves the same purpose as we''ve
    discussed previously in this book (for example, in [Chapter 2](ch02.html "Chapter 2. Building
    a Paint App"), *Building a Paint App*): it allows every tile to be colored differently
    while using the same (white) image for a texture.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, note the use of `cell_pos` and `cell_size`—these are the *real* screen
    coordinates in pixels. They vary according to the application's window size, and
    are generally computed just to draw something on the screen. For game logic, we
    are going to use much simpler board coordinates `board_x` and `board_y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This screenshot summarizes all work we''ve done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering empty cells](img/B01620_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The playing field, devoid of anything remotely interesting yet
  prefs: []
  type: TYPE_NORMAL
- en: Board data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to work on game logic, we need to keep an internal representation
    of the board. For this, we will use a simple two-dimensional array (to be technically
    correct, a list of lists). The blank state of the board looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `None` means the cell is empty. The described data structure can
    be initialized using the nested list comprehension, as shown in the following
    code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We call the preceding function `reset()` because, in addition to initializing
    the data structure beforehand, it will also be used to return the game to a blank
    state after a game-over situation.
  prefs: []
  type: TYPE_NORMAL
- en: The use of list comprehensions isn't strictly necessary; this notation is just
    more concise than the literal list of lists which is also shown earlier. If you
    think that the literal form (as shown earlier) is more readable, by all means
    use it instead when initializing the grid.
  prefs: []
  type: TYPE_NORMAL
- en: Variable naming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A short name, `b`, is deemed appropriate because this property should be considered
    internal to the class, so it doesn't take part in the external API (or lack thereof).
    We will also use this variable heavily in the following code, so this also serves
    to reduce typing, akin to the commonly used loop iterator variables `i` and `j`.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, private fields are usually designated with the leading underscore,
    for example, `_name`. We do not follow this convention strictly here, partly because
    this looks bad when used with very short names. This whole class is largely internal
    to the application anyway and barely, if at all, reusable as a separate module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider `Board.b` a local variable for all intents and purposes, especially
    since `Board` acts as a singleton in our app: there should be only one instance
    of it at a given time.'
  prefs: []
  type: TYPE_NORMAL
- en: Calling reset()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We should call `Board.reset()` at the beginning of the game to initialize the
    internal representation of the board. The right place to do so is the application''s
    `on_start` callback, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Testing passability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don't have anything clever to put in the grid yet, but this doesn't prevent
    us from writing a passability check, `can_move()`. This helper function tests
    whether we can place a tile at the specified location on the board.
  prefs: []
  type: TYPE_NORMAL
- en: The check is two-fold. First we need to make sure that the coordinates that
    are provided generally make sense (that is, don't fall outside the board), and
    this check will live in a separate function called `valid_cell()`. Then, we look
    up the board cell to see if it's empty (equals to `None`). The return value will
    be `True` if the move is legal and the cell is free, and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding sentence can be literally translated to Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These methods will be used later when writing the code responsible for tile
    movement. But first, we need to create the tiles.
  prefs: []
  type: TYPE_NORMAL
- en: Making tiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of the chapter is devoted to building the `Tile` widget. Tiles are
    more dynamic in nature than, for example, the `Board` widget that we've seen earlier.
    To account for this, we are going to create a number of Kivy properties on the
    `Tile` class so that any visible change to tile automatically leads to redrawing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kivy properties differ from regular Python ones: a property in Python is basically
    just a variable bound to an instance of class, possibly coupled with getter and
    setter functions. In Kivy, properties have an additional feature: they emit events
    when changed and as such you can observe interesting properties and adjust other
    related variables accordingly, or perhaps repaint the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of this work happens under the hood without your intervention: when you
    issue a change to, for example, the `pos` or `size` of a widget, an event (`on_pos`
    or `on_size` respectively) is fired.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, all properties that are defined in a `.kv` file are propagated
    automatically. For example, you can write things such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When the `root.pos` property changes, so does this label's `pos` value; they
    are kept in sync effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use this quality to our advantage when creating the `Tile`
    widget. First, let''s declare interesting properties that should be accounted
    for when rendering the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is all that's needed to draw a tile; property names should be rather self-explanatory,
    with the possible exception of `color`, a tile's background color. The `number`
    property denotes the *face value* of the tile.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to run this code right now, please replace `tile_colors[2]` with
    a literal color value, for example, `'#EEE4DA'`. We will define the `tile_colors`
    list properly later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in `game.kv`, we define graphical elements that constitute our widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Custom properties coming from the `Tile` class are highlighted. Note that inside
    the `canvas` declaration, `self` refers to `<Tile>`, and not to the canvas itself.
    This is because `canvas` is merely a property of the corresponding widget. `Label`,
    on the other hand, is a nested widget in its own right, so it uses `root.XXX`
    to refer to `<Tile>` properties. It's the top-level definition in this case, so
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Tile initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the original 2048 game, tiles have varying background colors according to
    their numeric value. We are going to implement the same effect, and for this we
    need a color mapping, *number → color*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list of colors is close to what the original 2048 game uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to map them to numbers, which in 2048 are powers of two, we can use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the mapping we need, with tile numbers as keys and corresponding
    colors as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With the colors in place, we can write an initializer of the `Tile` class,
    the `Tile.__init__` method. It will mostly just assign properties of the tile
    in question, as shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s briefly talk about every property that we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`font_size`: This is set to half of `cell_size`. This is basically an arbitrary
    value which looks fine. We cannot just put an absolute font size here, because
    the board is scaled to fit the window; the best approach is to keep font size
    to scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`: This is passed from the calling function and defaults to **2**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color` (the background color of a tile): This originates from the mapping
    discussed earlier, based on the value of `number`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number_color`: This is chosen based on the `number` property, too, but with
    much less variety. There are just two colors: a dark one (the default) which is
    used on a light background, and a lighter one for better contrast on a bright
    background, as numbers go up; hence the check (`if self.number > 4`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything else is passed to the superclass in the form of `kwargs` (keyword
    arguments). This includes position and size attributes, which coincidentally are
    the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Colors live in a helper function of their own, `update_colors()`, because later
    we will need to update them when merging tiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth mentioning that at this point, you can create a tile using something
    along the lines of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As a result, a new tile will be visible on the screen. (The preceding code should
    reside in the `Board` class. Alternatively, change all `self` references to an
    instance of `Board`.)
  prefs: []
  type: TYPE_NORMAL
- en: Resizing tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another problem with tiles is that they aren't aware that they should keep up
    with the board being resized. If you enlarge or shrink the application window,
    the board adjusts its size and position, but tiles don't. We're going to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a helper method for updating all relevant `Tile` properties
    at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although this method isn't strictly required, it makes the following code a
    bit more concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual resizing code will be located at the end of the `Board.resize()`
    method, which is invoked by Kivy property bindings. Here, we can iterate over
    all tiles and fix their metrics according to new values of `cell_size` and `cell_pos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is the exact opposite of automatic property binding we''ve seen
    earlier: we do all resizing in a centralized, explicit fashion. Some programmers
    may find this way of doing things more readable and less *magical* (for example,
    Python code allows you to set breakpoints inside event handlers and such; on the
    contrary, Kivy language files are much harder to meaningfully debug, should the
    need arise).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the game logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve built all the components required to make an implementation
    of the 2048 game, let''s move on to more interesting things: spawning, moving,
    and combining tiles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s only logical that we begin with spawning new tiles in random empty cells.
    The algorithm for doing so is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find all cells that are currently empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick a random one from those found in step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new tile at the position determined in step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add it to the internal grid (`Board.b`), and to the board widget itself (using
    `add_widget()`) for Kivy to render it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The sequence of actions should be self-evident; the following Python implementation
    of this algorithm is also very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'New tiles spawn at the beginning of the game and after every move. We will
    get to moving tiles shortly, and we can already implement spawning tiles at the
    beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you run the program after this change, you should see two tiles added to
    the board in random places.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the game logic](img/B01620_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spawning tiles in action
  prefs: []
  type: TYPE_NORMAL
- en: Moving tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement movement efficiently, we'll need to map every input event to a
    directional vector. Then, the `Board.move()` method will accept such a vector
    and rearrange the board accordingly. A directional vector is typically normalized
    (its length equals to one), and in our case, we can just add it to the current
    tile's coordinates to get its possible new location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 2048 game only allows four options for movement, so the keyboard mapping
    definition is very short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, we're referring to arrow keys, aptly named `'up'`, `'right'`,
    `'down'`, and `'left'` in Kivy's predefined `keycodes` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listening to keyboard events in Kivy can be implemented using the `Window.bind()`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `Board.move()` method gets called as a result. It accepts the directional
    vector components, `dir_x` and `dir_y`, unpacked from `key_vectors[key]`.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the iteration sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get to actually build the `Board.move()` method, we need to make the
    `all_cells()` generator function customizable; correct iteration order depends
    on the movement direction.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when going up, we have to start with the topmost cell in each column.
    This way we can ensure that all tiles will be arranged densely at the top of the
    board. In the event of incorrect iteration, you will inevitably see holes remaining
    from cells at the bottom bumping into cells at the top before those have reached
    their topmost available position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking this new requirement into account, we can easily write a new version
    of the generator function as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You may also want to write just `(3, 2, 1, 0)` instead of `reversed(range(4))`.
    In this specific case, literal enumeration is more concise than the iterator that
    produces it. Whether you choose to do so is a matter of personal preference and
    doesn't affect the functionality in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the move() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we can build the simplest version of the `Board.move()` function. At the
    moment, it will only facilitate moving tiles around, but we will soon upgrade
    it to also merge tiles together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an overview of this function''s algorithm so far:'
  prefs: []
  type: TYPE_NORMAL
- en: Go through all (existing) tiles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each tile, move it in the specified direction until it bumps into another
    tile or the playing field boundary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the tile's coordinates stay the same, continue to the next tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Animate the tile's transition to new coordinates and continue to the next tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Python implementation closely follows the previous description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, you can see the usage of `can_move()` function that we've built
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Animation` API works akin to CSS transitions in a browser. We need to
    provide:'
  prefs: []
  type: TYPE_NORMAL
- en: Values of properties we want to animate (in this example, `pos`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duration, in seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transition type (`'linear'` means equal speed throughout the route)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given all that, Kivy renders a smooth animation with the widget morphing from
    the current state to a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All transition types are detailed in the Kivy manual ([http://kivy.org/docs/api-kivy.animation.html](http://kivy.org/docs/api-kivy.animation.html)).
    There are just too many of them to provide a meaningful summary here.
  prefs: []
  type: TYPE_NORMAL
- en: Binding touch controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's also implement touch controls (swipes) in addition to keyboard bindings
    that we've done previously. Thanks to mouse input events being processed just
    like touches in Kivy, our code will also support mouse gestures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we need to merely add an event handler to the `Board` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we''re converting an arbitrary gesture to a unit vector that
    we need for `Board.move()` to work. The complete walkthrough is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `if v.length() < 20:` condition checks for eliminating very short gestures.
    If the travel distance is very short, then probably it was a click or tap, not
    a swipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `if abs(v.x) > abs(v.y):` condition sets the shorter component of the vector
    to zero. The remaining component thus designates the direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And then we simply normalize the vector and feed it into `Board.move()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This last point is exactly the reason why you shouldn't invent your own ways
    to represent *mathematically expressible* things such as directions.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone out there understands vectors, you get compatibility with any other
    library essentially for free when you use them; but should you reinvent the wheel
    and define some other representation, for example, `UP = 0`, `RIGHT = 1` and so
    on—and boom, you're now all alone in the cold, dark nowhere, inconsistent with
    the rest of the world. Seriously, don't do that unless you have at least two very
    good reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Combining tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will discuss the last fun part of the gameplay now: merging tiles as they
    bump into one another. The following code is surprisingly not very convoluted;
    one would probably expect it to be harder than that.'
  prefs: []
  type: TYPE_NORMAL
- en: We will build yet another helper function, `can_combine()`. Conceptually very
    similar to `can_move()`, this function returns `True` if we can combine the current
    tile with the one at the provided location, that is, if the coordinates are same
    and the location contains a tile having the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the unabridged listing of the described method. Compare this function
    to its counterpart, `can_move()`, and you will notice that it looks almost identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this function in place, we can now expand the `Board.move()` function to
    support merging cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just add the following snippet after the movement `while self.can_move()` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please see the full source code for this project if you're unsure about the
    code layout. The latest version of all the source code accompanying this book
    can be found at [https://github.com/mvasilkov/kb](https://github.com/mvasilkov/kb).
  prefs: []
  type: TYPE_NORMAL
- en: Again, this code resembles the movement logic, with two notable differences.
    The tile we're combining with gets removed using `remove_widget()`, and the remaining
    tile's number is updated, which means that we need to also update its colors.
  prefs: []
  type: TYPE_NORMAL
- en: So, our tiles merge happily and their values add up. The game would absolutely
    be playable at this point, if not for the last few things discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our game really should spawn new tiles after each turn. To complicate things
    further, this has to be done at the end of the animation sequence, when tiles
    that were affected by the last turn are done moving.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, there is a fitting event, `Animation.on_complete`, which is exactly
    what we're going to use here. Since we run a number of animations equal to the
    number of active tiles simultaneously, we need to bind the event only to the first
    `Animation` instance—they all start at the same time and have the same duration
    anyway, so there shouldn't be a noticeable difference between the timings of the
    first and the last animation in a synchronized batch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation resides in the same `Board.move()` method that we''ve seen
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the animation ends and the `on_complete` event fires, `new_tile()`
    is called and the game continues.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we introduce a Boolean flag named `moving` is to ensure that `new_tile()`
    won't be called more than once per turn. Skipping this check leads to the board
    getting flooded with new titles in no time.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing turns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might have noticed that there is a bug in the current implementation of
    animated tiles: the player can start a new turn before the previous one has ended.
    The easiest way to reproduce and obviate this issue is to increase the duration
    of the movement considerably, for example, to 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way we can fix this bug is by ignoring subsequent calls to `move()`
    while the tiles are in motion already. In order to do that, we have to broaden
    the scope of the previously seen `moving` flag. From now on, it will be a property
    of the `Board` class. We are also adjusting the `move()` method accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to reset `moving` back to `False` in `new_tile()`, or else tiles
    will cease to move at all after the first turn.
  prefs: []
  type: TYPE_NORMAL
- en: Game over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more thing that is missing from the game is the "game over" state. We discussed
    winning and losing conditions at the beginning of the chapter, so it's stylistically
    appropriate to end the implementation with the same topic.
  prefs: []
  type: TYPE_NORMAL
- en: The winning condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Testing whether the player has managed to assemble a 2048 tile can be easily
    done in the only place where the tile value is doubled when combining tiles in
    the `Board.move()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the specific UI for reporting end game conditions is purposefully
    omitted. Creating yet another simple screen with a button and some text would
    unnecessarily clutter the chapter without adding anything to the content already
    present in the book.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, implementing visually appealing end game states is again left
    as an exercise—we will only suggest an algorithm for detecting them.
  prefs: []
  type: TYPE_NORMAL
- en: To test end game conditions, it may be useful to lower the winning requirement
    severely by replacing `2048` by, for example, `64`, but don't forget to change
    it back before a public release!
  prefs: []
  type: TYPE_NORMAL
- en: The loss condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This algorithm is a bit more complex, and as such it can be written in a number
    of ways. Probably the most literal approach would be to traverse the board completely
    before each move to test whether the board is deadlocked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation: for every tile on the board we''re testing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Found an empty cell? This instantly means that we're not deadlocked—another
    tile can move to that cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, if the selected tile can combine with the one to the right or to
    the bottom, we're good, since we have a possible move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all else fails and we cannot find a cell that satisfies either of the previous
    conditions, this means we're out of moves—the game is over at this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![The loss condition](img/B01620_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Game over: there are no valid moves'
  prefs: []
  type: TYPE_NORMAL
- en: 'A fitting place to run this test would be in the `new_tile()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The precondition (`len(empty_cells) == 1`) allows us to run the check less
    often: there is no point in testing for the loss when the board isn''t full yet.
    It''s worth noting that our `is_deadlocked()` method would have correctly returned
    `False` in this case anyway, so this is purely an optimization, not affecting
    the "business logic" in any way.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This approach is still a little suboptimal, performance-wise, and could be
    improved at the cost of lengthening the code: one obvious optimization would be
    skipping the last row and column, and then not checking for bounds on each iteration,
    which `can_combine()` function implicitly does.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the gain in this case would be negligible, since this check runs at
    most once every turn, and we're mostly waiting for user input anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Where to go from here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game is finally playable, but there certainly are many areas in which it
    can be improved. If you''re willing to toy with the concept of 2048 some more,
    consider some of the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Add more animations—they do wonders in terms of perceived interactivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an additional motivational factor, add a score counter and the related infrastructure
    (for instance, the ability to save high scores and transmit them to the global
    server-side leaderboard).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tweak the game rules so that they are exactly like the original 2048 game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more mind-bending experimentation, build an algorithm that predicts fruitless
    game sessions in advance. As a player, I would positively love to receive a notification
    that reads, "No matter what you do, in 7 turns it's over for you, thanks for playing."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the rules completely. Add a multiplayer arena death match mode—be creative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're interested in seeing another, more complete Kivy implementation of
    the same 2048 game, take a look at [https://github.com/tito/2048](https://github.com/tito/2048).
    This project, written by a core Kivy developer Mathieu Virbel, features Google
    Play integration, achievements, and a high-score leaderboard, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: It should be postulated that reading other people's code is a great way to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we built a playable replica of the 2048 game. We also showcased
    a number of implementation details that can be reused in other similar projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scalable board that fits the screen in any resolution and orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting together custom tiles, and implementing smooth movement for those with
    the help of Kivy's `Animation` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping player's controls to both touch screen gestures and keyboard arrow keys
    at the same time, to account for any control scheme the user might expect from
    the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kivy framework supports game development nicely; in particular, canvas rendering
    and support for animations can be very useful when building video games. Prototyping
    in Kivy is also feasible, albeit somewhat harder to do than in JavaScript (a modern
    browser is a very powerful platform, and it's especially hard to beat when it
    comes to cheap prototyping).
  prefs: []
  type: TYPE_NORMAL
- en: The resulting Python program is also inherently cross-platform unless you're
    using an OS-specific API in a way that prevents other systems from functioning.
    This means that technically your game can be played by everyone, reaching the
    widest possible audience.
  prefs: []
  type: TYPE_NORMAL
- en: The use of Kivy also doesn't conflict with publishing your work on major app
    distribution platforms, be it Apple AppStore, Google Play, or even Steam.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, Kivy lacks a great many features and most of the toolchain if compared
    to a full-fledged game engine like the Unreal Engine or Unity. This is due to
    the fact that Kivy is a general purpose UI framework and not a game engine per
    se; one can argue that such a comparison of vastly different software categories
    over respective feature sets is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, Kivy is a solid choice for sporadic indie game development. Angry
    Birds could have been implemented in Python and Kivy by *you*! Imagine the scale
    of the opportunity you've missed back then. (But please don't feel bad about this,
    it was meant as an encouragement. Rovio's path to a successful game title wasn't
    exactly easy either.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the topic of the next chapter: writing an arcade game using
    Kivy. It will utilize the familiar concept of Kivy widgets in a variety of unorthodox
    ways to create an interactive side-scrolling environment, reminiscent of another
    critically acclaimed indie game, Flappy Bird.'
  prefs: []
  type: TYPE_NORMAL
