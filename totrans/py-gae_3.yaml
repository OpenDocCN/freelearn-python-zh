- en: Chapter 3. Storing and Processing Users' Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：存储和处理用户数据
- en: There are several pieces of data that need to be persisted and that don't fit
    very well into the Datastore or similar storage systems, such as images and media
    files in general; these are usually big and their size impacts application costs
    and how they should be uploaded, stored, and served back when requested. In addition,
    sometimes we need to modify these contents on the server side and the operation
    can take a long time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些数据需要持久化，并且不太适合 Datastore 或类似存储系统，例如图像和媒体文件；这些通常很大，其大小会影响应用程序成本以及它们应该如何上传、存储和当请求时提供。此外，有时我们需要在服务器端修改这些内容，并且操作可能需要很长时间。
- en: We will add some features to the Notes application that will raise these kinds
    of problems, and we will see how App Engine provides everything we need to face
    them effectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Notes 应用程序中添加一些将引发这些问题的功能，我们将看到 App Engine 如何提供我们面对这些问题的所有所需。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding a form to our application to let users upload images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中添加表单以允许用户上传图像
- en: Serving the files uploaded back to the clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将上传的文件返回给客户端
- en: Transforming images with the Images service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Images 服务转换图像
- en: Performing long jobs with the task queue
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务队列执行长时间作业
- en: Scheduling tasks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度任务
- en: Handling e-mail messages from our application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理来自我们应用程序的电子邮件消息
- en: Uploading files to Google Cloud Storage
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件上传到 Google Cloud Storage
- en: It's extremely common for a web application to deal with image files or PDF
    documents, and Notes is not an exception. It could be very useful for users to
    attach an image or a document to one or more notes in addition to the title and
    the description text.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个网络应用程序来说，处理图像文件或 PDF 文档是非常常见的，Notes 也不例外。对于用户来说，除了标题和描述文本外，将图像或文档附加到一个或多个笔记中可能非常有用。
- en: 'Storing big chunks of binary data in the Datastore would be inefficient and
    rather expensive, so we need to use a different, dedicated system: Google Cloud
    Storage. Cloud Storage lets us store large files in locations called **buckets**.
    An application can read and write from multiple buckets and we can set up an **Access
    Control List** (**ACL**) to determine who can access a certain bucket and with
    what permissions. Every App Engine application has its default bucket associated
    but we can create, manage, and browse any number of them through the Developer
    Console.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Datastore 中存储大量二进制数据将是不高效的，并且相当昂贵，因此我们需要使用不同的、专门的系统：Google Cloud Storage。Cloud
    Storage 允许我们在称为**桶**的位置存储大文件。一个应用程序可以从多个桶中读取和写入，并且我们可以设置**访问控制列表**（**ACL**）来决定谁可以访问特定的桶以及具有什么权限。每个
    App Engine 应用程序都有一个默认的桶与之关联，但我们可以通过开发者控制台创建、管理和浏览任意数量的桶。
- en: Installing Cloud Storage Client Library
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Cloud Storage 客户端库
- en: 'To better interact with Cloud Storage, we need an external piece of software
    that is not included in the App Engine runtime environment, which is the **GCS
    Client Library**. This Python library implements functions to easily read and
    write files inside buckets, handling errors and retries. The following is the
    detailed list of these functions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地与 Cloud Storage 交互，我们需要一个外部软件，它不包括在 App Engine 运行时环境中，这就是**GCS 客户端库**。这个
    Python 库实现了读取和写入桶内文件的功能，并处理错误和重试。以下这些函数的详细列表：
- en: '**The** `open()` **method**: This allows us to operate with a file-like buffer
    on bucket contents'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**open()**方法：这允许我们在桶内容上操作类似文件缓冲区'
- en: '**The** `listbucket()` **method**: This retrieves the contents of a bucket'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**listbucket()**方法：这检索桶的内容'
- en: '**The** `stat()` **method**: This gets metadata for a file in a bucket'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stat()**方法：这为桶中的文件获取元数据'
- en: '**The** `delete()` **method**: This removes files from buckets'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**delete()**方法：这将从桶中删除文件'
- en: 'To install GCS Client Library, we can use pip:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 GCS 客户端库，我们可以使用 pip：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's important to specify the destination directory for the package with the
    `-t` option, as it is the only way to install third-party packages that are not
    provided by App Engine on the production server. When we deploy the application,
    all content in the application root will be copied on the remote server, including
    the `cloudstorage` package.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-t`选项指定包的目标目录非常重要，因为这是在生产服务器上安装由 App Engine 不提供的第三方包的唯一方式。当我们部署应用程序时，应用程序根目录中的所有内容都将复制到远程服务器上，包括`cloudstorage`包。
- en: 'It''s also possible to clone the **Subversion** (**SVN**) executable and check
    out the latest version of the source code, provided that we have the `svn` repository
    installed on our system:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们系统上安装了`svn`仓库，我们还可以克隆**Subversion**（**SVN**）可执行文件并检出源代码的最新版本：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To check whether the library is working, we can issue the following from the
    command line and verify that no errors are printed out:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查库是否正常工作，我们可以在命令行中发出以下命令，并验证没有错误打印出来：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative way to interact with Google Cloud Storage is the **Blobstore
    API**, bundled with the App Engine Environment. Blobstore was the first App Engine
    service to provide cheap and effective storage for big files, and it's still available
    even though Cloud Storage is more recent and more actively developed. Even if
    we do not store any data in Blobstore, we will use the Blobstore API with Cloud
    Storage later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与Google Cloud Storage交互的另一种方式是**Blobstore API**，它是App Engine环境捆绑的一部分。Blobstore是第一个提供大文件便宜且有效存储的App
    Engine服务，尽管云存储更新且更活跃地开发，但它仍然可用。即使我们不在Blobstore中存储任何数据，我们也会在本章的后面使用Blobstore API与云存储一起使用。
- en: Adding a form to upload images
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加表单上传图片
- en: 'We start adding a field in the HTML form that we use to create notes so that
    the user can specify a file to upload. Before the submit button, we insert an
    input tag:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始在用于创建笔记的HTML表单中添加一个字段，以便用户可以指定要上传的文件。在提交按钮之前，我们插入一个输入标签：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will store all the files for every user in the default bucket under a folder
    named after the user ID; our application is the only way to access that file if
    we do not alter the default access control list, so we can enforce security and
    privacy at the application level. In order to access the uploaded file from the
    `webapp2` request object, we need to rewrite the `post` method for the `MainHandler`
    class, but first, we need these import statements at the top of the `main.py`
    module:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把每个用户的所有文件存储在默认存储桶下的一个以用户ID命名的文件夹中；如果未更改默认访问控制列表，我们的应用程序是访问该文件的唯一方式，因此我们可以在应用程序级别强制执行安全和隐私。为了从`webapp2`请求对象中访问上传的文件，我们需要重写`MainHandler`类的`post`方法，但首先，我们需要在`main.py`模块的顶部添加以下导入语句：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will see in a moment where to use these modules; this is the code that will
    be added to the `MainHandler` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到这些模块的用途；这是将被添加到`MainHandler`类中的代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We first retrieve the name of the default bucket for our application through
    the `app_identity` service by calling its `get_default_gcs_bucket_name()`method.
    Then, we access the `request` object to get the value of the `uploaded_file` field.
    When users specify a file to upload, `self.request.POST.get('uploaded_file')`
    returns an instance of the `FileStorage` class defined in the `cgi` module of
    the Python standard library. The `FieldStorage` object has two fields, `filename`
    and `file`, that contain the name and the content of the uploaded file, respectively.
    If users don't specify a file to be uploaded, the value of the `uploaded_file`
    field becomes an empty string.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过调用`app_identity`服务的`get_default_gcs_bucket_name()`方法来检索我们应用程序的默认存储桶名称。然后，我们访问`request`对象以获取`uploaded_file`字段的值。当用户指定要上传的文件时，`self.request.POST.get('uploaded_file')`返回Python标准库中`cgi`模块定义的`FileStorage`类的实例。`FieldStorage`对象有两个字段，`filename`和`file`，分别包含上传文件的名称和内容。如果用户没有指定要上传的文件，则`uploaded_file`字段的值变为空字符串。
- en: When dealing with an uploaded file, we try to guess its type with the help of
    the `mimetypes` module from the Python standard library, and then we build the
    full path of the file according to the `/<bucket_name>/<user_id>/<filename>` scheme.
    The last part involves the GCS Client Library; in fact, it lets us open a file
    for writing on Cloud Storage as we would do on a regular filesystem. We write
    the content of the uploaded file by calling the `read` method on the `file_name`
    object. We finally call the `_create_note` method, passing the name of the file
    as well, so it will be stored inside a `Note` instance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理上传的文件时，我们尝试使用Python标准库中的`mimetypes`模块来猜测其类型，然后根据`/<bucket_name>/<user_id>/<filename>`方案构建文件的完整路径。最后一部分涉及到GCS客户端库；实际上，它允许我们像在常规文件系统上一样在云存储上打开一个文件进行写入。我们通过在`file_name`对象上调用`read`方法来写入上传文件的正文。最后，我们调用`_create_note`方法，同时传递文件名，这样它就会被存储在`Note`实例内部。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If users upload a file with the same name as another file that's already present
    in Cloud Storage, the latter will be overwritten with the new data. If we want
    to handle this issue, some logic should be added, such as either renaming the
    new file or asking users how to proceed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户上传的文件与云存储中已存在的文件同名，后者将被新数据覆盖。如果我们想处理这个问题，需要添加一些逻辑，例如重命名新文件或询问用户如何操作。
- en: 'Before refactoring the `_create_note()` method to accept and handle the name
    of the file attached to a note, we need to add a property to our `Note` model
    class to store the name of the files attached. The model becomes as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构`_create_note()`方法以接受和处理附加到笔记的文件名之前，我们需要向我们的`Note`模型类添加一个属性来存储附加文件的名称。模型变为以下内容：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Even if we only support the addition of a single file during the note creation,
    we store a list of filenames so that we already provide support for multiple attachments
    in a single note.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在创建笔记时只支持添加单个文件，我们也存储一个文件名列表，以便我们已经在单个笔记中提供了对多个附件的支持。
- en: 'Back in the `main.py` module, we refactor the `_create_note()` method as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.py`模块中，我们将`_create_note()`方法重构如下：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the `file_name` parameter is not set to the `None` value, we add the name
    of the file and update the `Note` entity. We can now run the code and try to upload
    a file when creating a note. The code we wrote so far only stores the uploaded
    file without any feedback, so to check whether everything is working, we need
    to use the Blobstore viewer on the local Development Console. If we're running
    the application on production servers, we can use the Cloud Storage interface
    on Google Developer Console to list the contents of the default bucket.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当`file_name`参数未设置为`None`值时，我们添加文件名并更新`Note`实体。现在我们可以运行代码，在创建笔记时尝试上传文件。我们编写的代码到目前为止只存储上传的文件而没有任何反馈，所以为了检查一切是否正常工作，我们需要在本地开发控制台中使用Blobstore查看器。如果我们正在生产服务器上运行应用程序，我们可以使用Google开发者控制台上的云存储界面来列出默认存储桶的内容。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this, the local development server emulates Cloud Storage
    in the very same way as it emulates Blobstore, and this is why we will only find
    a Blobstore viewer in the Development Console.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写此内容时，本地开发服务器以与模拟Blobstore相同的方式模拟云存储，这就是为什么我们只会在开发控制台中找到Blobstore查看器。
- en: Serving files from Cloud Storage
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从云存储中提供文件
- en: 'As we didn''t specify an Access Control List for the default bucket, it is
    only accessible from the Developer Console upon authentication or through the
    Notes application. This is fine as long as we want to keep files private to the
    user who performed the upload but we need to provide a URL for our application
    where these files can be retrieved. For example, if a user wants to retrieve the
    file named `example.png`, the URL could be `/media/example.png`. We need to provide
    a request handler for such URLs, checking whether the currently logged-in user
    has uploaded the requested file or not and provide a response accordingly. In
    the `main.py` module, we add the following class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有为默认存储桶指定访问控制列表，因此未经身份验证或通过笔记应用程序，它只能从开发者控制台访问。只要我们希望将文件保留给执行上传的用户，这就可以了，但我们需要提供一个应用程序的URL，以便可以检索这些文件。例如，如果用户想要检索名为`example.png`的文件，URL可以是`/media/example.png`。我们需要为这样的URL提供请求处理器，检查当前登录用户是否上传了请求的文件，并相应地提供响应。在`main.py`模块中，我们添加以下类：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After determining the currently logged-in user, we build the full path to the
    requested file using the same scheme we used to store the `/<bucket_name>/<user_id>/<filename>`
    file. If the file does not exist, GCS Client Library raises a `NotFoundError`
    error and we serve a **404: Not Found** courtesy page using the `abort()` method
    of the request handler. If the file is actually in Cloud Storage, we open it to
    read with the usual file-like interface provided by GCS Client Library, and we
    write its content in the response body after setting the right `Content-Type`
    HTTP header. This way, we cannot access any file uploaded by other users even
    if we know the name of the file, because our user ID will be used to determine
    the full path of the file.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 确定当前登录用户后，我们使用与存储 `<bucket_name>/<user_id>/<filename>` 文件相同的方案构建请求文件的完整路径。如果文件不存在，GCS
    客户端库会引发 `NotFoundError` 错误，我们使用请求处理器的 `abort()` 方法提供 **404：未找到** 的礼貌页面。如果文件实际上在云存储中，我们使用
    GCS 客户端库提供的常规文件接口打开它进行读取，并在设置正确的 `Content-Type` HTTP 头部后将其内容写入响应体。这样，即使我们知道文件名，我们也无法访问其他用户上传的任何文件，因为我们的用户
    ID 将用于确定文件的完整路径。
- en: 'To use the `MediaHandler` class, we add a tuple to the `WSGIApplication` constructor:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `MediaHandler` 类，我们在 `WSGIApplication` 构造函数中添加一个元组：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The regular expression tries to match any URL that starts with the `/media/`
    path followed by a filename. When matching, the regular expression group named
    `file_name` is passed to the `get()` method of the `MediaHandler` class as a parameter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式试图匹配以 `/media/` 路径开始的任何 URL，后面跟一个文件名。在匹配时，名为 `file_name` 的正则表达式组被传递到 `MediaHandler`
    类的 `get()` 方法作为参数。
- en: 'The last step is to add a link for each file attached to a note in the main
    page so that users can download them. We simply add a `for` iteration on the `main.html`
    template right before the iteration of the checklist items:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在主页中为每个附加到笔记的文件添加一个链接，以便用户可以下载它们。我们只需在 `main.html` 模板的清单项迭代之前添加一个 `for`
    迭代即可：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We finally add the CSS `file` class to `li` elements to distinguish files from
    checklist items; we add the corresponding styles to the `note.css` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终将 CSS 的 `file` 类添加到 `li` 元素上，以区分文件和清单项；我们将相应的样式添加到 `note.css` 文件中：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this updated style sheet, the background for file items has a different
    color from checklist items and the link text color is white.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个更新的样式表，文件项的背景颜色与清单项不同，链接文本颜色为白色。
- en: Serving files through Google's Content Delivery Network
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 Google 的内容分发网络提供文件服务
- en: 'We are currently serving files attached to the notes with our WSGI application
    through the `MediaHandler` request handler class, and this is very convenient
    because we can perform security checks and ensure that users only get files they
    have previously updated. This approach has several drawbacks, though: the application
    is less efficient compared to a regular web server and we consume resources such
    as memory and bandwidth, which could potentially cost us a lot of money.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前通过 `MediaHandler` 请求处理类使用我们的 WSGI 应用程序提供附加到笔记的文件服务，这非常方便，因为我们可以在执行安全检查的同时确保用户只能获取他们之前更新过的文件。尽管如此，这种方法有几个缺点：与常规
    Web 服务器相比，应用程序效率较低，我们消耗了诸如内存和带宽之类的资源，这可能会给我们带来大量的费用。
- en: 'There is an alternative, however; if we relax the requirements for our Notes
    application and allow the contents to be publicly available, we can deliver such
    files with low latency from a highly optimized and cookie-less infrastructure:
    the **Google Content Delivery Network (CDN)**. How to do this depends on which
    kind of files we have to deliver: images or any other **MIME** type.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个替代方案；如果我们放宽 Notes 应用程序的要求，允许内容公开访问，我们可以从高度优化且无 cookie 的基础设施中低延迟地提供此类文件：**Google
    内容分发网络 (CDN)**。如何实现这取决于我们必须提供哪种类型的文件：图片或其他任何 **MIME** 类型。
- en: Serving images
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端图片
- en: 'If we are dealing with an image file, we can use the Images service to generate
    a URL, which is public but not guessable, to reach content stored in Cloud Storage.
    First, we need to compute an encoded key representing the file in Cloud Storage
    that we want to serve; to do this, we use the `create_gs_key()` method provided
    by the Blobstore API. We then use the `get_serving_url()` method provided by the
    Images service to generate a serving URL for the encoded key. If we need to serve
    the same image with different sizes—for example, to provide a thumbnail—there
    is no need to store the same file multiple times; in fact, we can specify a size
    for the image we want to deliver and the CDN will take care of it. We need to
    import the packages needed at the top of the `main.py` module:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是图像文件，我们可以使用图像服务生成一个URL，该URL是公开的但不可猜测的，可以访问存储在云存储中的内容。首先，我们需要计算一个编码密钥，代表我们想要在云存储中提供的服务文件；为此，我们使用Blobstore
    API提供的`create_gs_key()`方法。然后，我们使用图像服务提供的`get_serving_url()`方法为编码密钥生成一个托管URL。如果我们需要以不同的尺寸提供相同的图像——例如，提供缩略图——就没有必要多次存储相同的文件；实际上，我们可以指定我们想要提供的图像的大小，CDN将负责处理。我们需要在`main.py`模块的顶部导入所需的包：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For convenience, we add a `_get_urls_for()` method to the `MainHandler` class
    we can call whenever we want to get serving URLs for a file in Cloud Storage:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们在`MainHandler`类中添加了一个`_get_urls_for()`方法，我们可以在需要获取云存储中文件的托管URL时调用此方法：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The method takes the filename as a parameter and builds the full path to Cloud
    Storage with the slightly different `/gs/<bucket_name>/<user_id>/<filename>` scheme
    (notice the `/gs` string that we need to prefix only when generating the encoded
    key). The real path to the file is then passed to the `create_gs_key()` function,
    which generates an encoded key, and then we call the `get_serving_url()` method
    twice: once to generate the URL for the full-sized image and then to generate
    the URL for a cropped thumbnail with a size of 150 pixels. Finally, both the URLs
    are returned. These URLs will be permanently available unless we call the `delete_serving_url()`
    method from the Images service passing the same key. If we don''t specify the
    `size` parameter, the CDN will serve an optimized version of the image that is
    smaller in size by default; explicitly passing the `size=0` parameter to the first
    call to the `get_serving_url()` function will make the CDN serve the original
    image.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受文件名作为参数，并使用略有不同的`/gs/<bucket_name>/<user_id>/<filename>`方案（注意只有在生成编码密钥时需要添加前缀的`/gs`字符串）构建云存储的完整路径。然后，将文件的真正路径传递给`create_gs_key()`函数，该函数生成一个编码密钥，然后我们调用两次`get_serving_url()`方法：一次生成全尺寸图像的URL，然后生成一个150像素大小的裁剪缩略图的URL。最后，返回这两个URL。除非我们从图像服务中调用`delete_serving_url()`方法并传递相同的密钥，否则这些URL将永久可用。如果我们没有指定`size`参数，CDN将默认提供优化后的图像版本，其大小更小；通过将`size=0`参数显式传递给`get_serving_url()`函数的第一次调用，将使CDN提供原始图像。
- en: 'We can improve the data model by providing a new kind that describes a file
    attached to a note. In the `models.py` module, we add the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供一个描述附加到笔记的文件的新类型来改进数据模型。在`models.py`模块中，我们添加以下内容：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We store the name, the two URLs, and the full path in Cloud Storage for each
    file. We then reference a `NoteFile` instance instead of the plain filename from
    the `Note` model:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个文件存储名称、两个URL和云存储中的完整路径。然后，我们从`Note`模型中引用`NoteFile`实例而不是纯文件名：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To store data according to the new model, we refactor the `_create_note()`
    method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据新的模型存储数据，我们重构了`_create_note()`方法：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We generate the URLs and create the `NoteFile` instance, adding it to the `Note`
    entity group. In the `post()` method of the `MainHandler` class, we now call the
    `_create_note()` method as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成URL并创建`NoteFile`实例，将其添加到`Note`实体组中。在`MainHandler`类的`post()`方法中，我们现在按照以下方式调用`_create_note()`方法：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the HTML template, we add this code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML模板中，我们添加以下代码：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Instead of the name of the file, we show the thumbnail inside a link pointing
    to the full-sized version of the image.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是显示文件的名称，而是在指向图像全尺寸版本的链接中显示缩略图。
- en: Serving other types of files
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供其他类型的文件服务
- en: We cannot use the Images service on file types that are not images, so we need
    to follow a different strategy in this case. Files stored in Cloud Storage that
    are publicly accessible can be reached by composing the URL of Google CDN with
    their full path.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在非图像文件上使用图像服务，因此在这种情况下我们需要遵循不同的策略。公开可访问的存储在云存储中的文件可以通过组合Google CDN的URL和它们的完整路径来访问。
- en: 'The first thing to do, then, is to change the default ACL when we save the
    files in the `post()` method of the `MainHandler` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，首先要做的事情是，在 `MainHandler` 类的 `post()` 方法中保存文件时更改默认的 ACL：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `options` parameter for the `open()` method of GCS Client Library lets
    us specify a dictionary of strings containing additional headers to pass to the
    Cloud Storage service: in this case, we set the `x-goog-acl` header to the `public-read`
    value so that the file will be publicly available. From now on, we could reach
    that file with a URL of the `http://storage.googleapis.com/<bucket_name>/<file_path>`
    type, so let''s add the code to compose and store such URLs for files that are
    not images.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: GCS 客户端库的 `open()` 方法的 `options` 参数让我们可以指定一个包含要传递给 Cloud Storage 服务的额外头部的字符串字典：在这种情况下，我们将
    `x-goog-acl` 头设置为 `public-read` 值，以便文件将公开可用。从现在起，我们可以通过 `http://storage.googleapis.com/<bucket_name>/<file_path>`
    类型的 URL 来访问该文件，因此让我们添加代码来组合和存储此类 URL，用于不是图像的文件。
- en: 'In the `_get_urls_for()` method, we catch errors of the `TransformationError`
    or `NotImageError` type assuming that if the Images service failed to handle a
    certain file, that file is not an image:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_get_urls_for()` 方法中，我们捕获 `TransformationError` 或 `NotImageError` 类型的错误，假设如果
    Images 服务未能处理某个文件，那么该文件不是图像：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the file type is not supported by the Images service, we compose the `url`
    parameter as stated before and set the `thumbnail_url` variable to the `None`
    value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件类型不受 Images 服务的支持，我们将按照之前所述的方式组合 `url` 参数，并将 `thumbnail_url` 变量设置为 `None`
    值。
- en: 'In the HTML template, we will show the filename instead of the thumbnail for
    files that are not images:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 模板中，对于不是图像的文件，我们将显示文件名而不是缩略图：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Transforming images with the Images service
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Images 服务转换图像
- en: We already used the App Engine Images service to serve images through Google's
    CDN, but there's a lot more it can do. It can resize, rotate, flip, crop images,
    and composite multiple images into a single file. It can enhance pictures using
    a predefined algorithm. It can convert an image from and to several formats. The
    service can also provide information about an image, such as its format, width,
    height, and a histogram of color values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了 App Engine Images 服务通过 Google 的 CDN 来提供图像服务，但它可以做更多的事情。它可以调整图像大小、旋转、翻转、裁剪图像，并将多个图像组合成一个文件。它可以使用预定义的算法增强图片。它可以转换图像的格式。该服务还可以提供有关图像的信息，例如其格式、宽度、高度以及颜色值的直方图。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To use the Images service on the local development server, we need to download
    and install the **Python Imaging Library** (**PIL**) package or, alternatively,
    the `pillow` package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地开发服务器上使用 Images 服务，我们需要下载并安装 **Python Imaging Library** (**PIL**) 包，或者，作为替代方案，安装
    `pillow` 包。
- en: 'We can pass the image data to the service directly from our application or
    specifying a resource stored in Cloud Storage. To see how this works, we add a
    function to our Notes application that users can trigger to shrink all the images
    attached to any note in order to save space in Cloud Storage. To do this, we add
    a dedicated request handler to the `main.py` module, which will be invoked when
    users hit the `/shrink` URL:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从我们的应用程序传递图像数据到服务，或者指定存储在 Cloud Storage 中的资源。为了了解这是如何工作的，我们在 Notes 应用程序中添加了一个函数，用户可以触发该函数以缩小任何笔记中附加的所有图像，以便在
    Cloud Storage 中节省空间。为此，我们在 `main.py` 模块中添加了一个专用的请求处理器，当用户点击 `/shrink` URL 时将被调用：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `get()` method, we load all the notes belonging to the current logged
    in user from the Datastore, and then we invoke the `_shrink_note()` method on
    each of them. For each file attached to a note, we check whether it is an image;
    if not, we catch the error and pass to the next one. If the file is actually an
    image, we open the file with GCS Client Library and pass the image data to the
    `Image` class constructor. Image objects wrap image data and provide an interface
    to manipulate and get information for the wrapped image. Transformations are not
    applied immediately; they are added to a queue that is processed when we invoke
    the `execute_transforms()` method on the `Image` instance. In our case, we apply
    just one transformation, resizing the image to 640 pixel width. The `execute_transforms()`
    method returns the transformed image data we use to overwrite the original file.
    When writing the new image data on Cloud Storage, we need to specify the content
    type for the file again: we derive the right content type from the `format` property
    of the `image` object. This value is an integer that has to be mapped to a content
    type string; we do this by adding this dictionary at the top of the `main.py`
    module:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get()`方法中，我们从 Datastore 加载属于当前登录用户的全部笔记，然后对每个笔记调用`_shrink_note()`方法。对于每个附加到笔记的文件，我们检查它是否是图片；如果不是，我们捕获错误并传递给下一个。如果文件实际上是图片，我们使用
    GCS 客户端库打开文件并将图像数据传递给`Image`类构造函数。图像对象封装图像数据并提供了一个用于操作和获取封装图像信息的接口。变换不会立即应用；它们被添加到一个队列中，当我们对`Image`实例调用`execute_transforms()`方法时进行处理。在我们的情况下，我们只应用一个变换，即将图像宽度调整为
    640 像素。`execute_transforms()`方法返回我们用来覆盖原始文件的变换后的图像数据。在将新的图像数据写入云存储时，我们需要再次指定文件的内容类型：我们从`image`对象的`format`属性中推导出正确的内容类型。这个值是一个整数，必须映射到一个内容类型字符串；我们通过在`main.py`模块顶部添加此字典来完成此操作：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We cast the `image.format` value to the string and access the right string to
    pass to the `open()` method from GCS Client Library.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`image.format`值转换为字符串并访问正确的字符串，将其传递给 GCS 客户端库的`open()`方法。
- en: 'We add the mapping for the `/shrink` URL in the `main.py` module:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main.py`模块中添加了`/shrink` URL的映射：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To let users access this functionality, we add a hyperlink on the main page.
    We take the opportunity to provide a main menu for our application, changing the
    `main.html` template as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户访问此功能，我们在主页上添加了一个超链接。我们借此机会为我们的应用程序提供一个主菜单，如下修改`main.html`模板：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make the menu lay out horizontally, we add these lines to the `notes.css`
    file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使菜单水平布局，我们在`notes.css`文件中添加了以下行：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Users can now shrink the space taken by images attached to their notes clicking
    the corresponding action in the menu on the main page.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以通过点击主页菜单中的相应操作来缩小其笔记中附加的图片所占的空间。
- en: Processing long jobs with the task queue
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务队列处理长时间作业
- en: 'App Engine provides a mechanism called **request timer** to ensure that requests
    from a client have a finite lifespan, avoiding infinite loops and preventing an
    overly aggressive use of the resources from an application. In particular, the
    request timer raises a `DeadlineExceededError` error whenever a request takes
    more than 60 seconds to complete. We have to take this into consideration if our
    application provides functionalities that involve complex queries, I/O operations,
    or image processing. This is the case of the `ShrinkHandler` class from the previous
    paragraph: the number of notes to be loaded and the attached images to be processed
    could be big enough to make the request last more than 60 seconds. In such cases,
    we can use the **task queue**, which is a service provided by App Engine that
    lets us execute operations outside the request / response cycle with a wider time
    limit of 10 minutes.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine 提供了一种称为**请求计时器**的机制，以确保客户端请求有一个有限的生命周期，避免无限循环并防止应用程序过度使用资源。特别是，当请求完成超过
    60 秒时，请求计时器会引发一个`DeadlineExceededError`错误。如果我们的应用程序提供涉及复杂查询、I/O 操作或图像处理的功能，我们必须考虑这一点。上一段中的`ShrinkHandler`类就是这样一种情况：要加载的笔记数量和要处理的附加图片可能足够多，使得请求持续超过
    60 秒。在这种情况下，我们可以使用**任务队列**，这是 App Engine 提供的一项服务，允许我们在请求/响应周期之外执行操作，具有更宽的时间限制，即
    10 分钟。
- en: 'There are two types of task queue: **push queues**, which are used for tasks
    that are automatically processed by the App Engine infrastructure, and **pull
    queues**, which let developers build their own task-consuming strategy either
    with another App Engine application or externally from another infrastructure.
    We will use push queues so that we have a turnkey solution from App Engine without
    worrying about the setup and scalability of external components.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的任务队列：**推送队列**，用于由 App Engine 基础设施自动处理的任务，以及**拉取队列**，允许开发者使用另一个 App Engine
    应用程序或从另一个基础设施外部构建自己的任务消费策略。我们将使用推送队列，以便我们有来自 App Engine 的现成解决方案，无需担心外部组件的设置和可伸缩性。
- en: 'We will run the shrink images functionality inside a task queue, and to do
    so, we need to refactor the `ShrinkHandler` class: in the `get()` method, we will
    start the task, moving the execution of the query and the image processing to
    the `post()` method. The `post()` method will be invoked by the task queue consumer
    infrastructure to process the task.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在任务队列内部运行缩放图像功能，为此，我们需要重构 `ShrinkHandler` 类：在 `get()` 方法中，我们将启动任务，将查询执行和图像处理移动到
    `post()` 方法。`post()` 方法将由任务队列消费者基础设施调用以处理任务。
- en: 'We first need to import the `taskqueue` package to use the task queue Python
    API:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要导入 `taskqueue` 包以使用任务队列 Python API：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we add the `post()` method to the `ShrinkHandler` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `post()` 方法添加到 `ShrinkHandler` 类：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To ensure that we have received a task queue request, we check whether the
    `X-AppEngine-TaskName` HTTP header was set; App Engine strips these kinds of headers
    if requests come from outside the platform, so we can trust the client. If this
    header is missing, we set the `HTTP 403: Forbidden` response code.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '为了确保我们已经收到任务队列请求，我们检查 `X-AppEngine-TaskName` HTTP 头是否已设置；如果请求来自平台外部，App Engine
    会删除这些类型的头，因此我们可以信任客户端。如果此头缺失，我们设置 `HTTP 403: Forbidden` 响应代码。'
- en: The request contains a `user_email` parameter containing the e-mail of the user
    who added this task to the queue (we'll see where this parameter has to be set
    in a moment); we instance a `User` object by passing the e-mail address to match
    a valid user and proceed with image processing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请求包含一个 `user_email` 参数，该参数包含添加此任务到队列的用户电子邮件地址（我们将在稍后看到这个参数需要在何处设置）；我们通过传递电子邮件地址来实例化一个
    `User` 对象，以匹配有效用户，并继续进行图像处理。
- en: 'The `get()` method of the `ShrinkHandler` class has to be refactored as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShrinkHandler` 类的 `get()` 方法需要按照以下方式进行重构：'
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After checking whether the user is logged in, we add a task to the queue using
    the task queue API. We pass the URL mapped to the handler that will perform the
    job as a parameter and a dictionary containing the parameters we want to pass
    to the handler. In this case, we set the `user_email` parameter we use in the
    `post()` method to load a valid `User` instance. After the task is added to the
    queue, a response is immediately returned, and when executed, the actual shrinking
    operation could last up to 10 minutes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查用户是否登录后，我们使用任务队列 API 向队列中添加一个任务。我们将映射到执行作业的处理器的 URL 作为参数传递，以及包含我们想要传递给处理器的参数的字典。在这种情况下，我们将
    `post()` 方法中使用的 `user_email` 参数设置为加载有效的 `User` 实例。任务添加到队列后，将立即返回响应，实际缩放操作可能持续长达
    10 分钟。
- en: Scheduling tasks with Cron
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cron 调度任务
- en: We have designed the shrink operation as an optional functionality triggered
    by users, but we could run it at a determined time interval for every user in
    order to lower the costs of Cloud Storage. App Engine supports the scheduled execution
    of jobs with the Cron service; every application has a limited number of Cron
    jobs available, depending on our billing plan. Cron jobs have the same restrictions
    as tasks in a task queue, so the request can last up to 10 minutes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将缩放操作设计为用户触发的可选功能，但我们可以为每个用户在确定的时间间隔内运行它，以降低云存储的成本。App Engine 支持使用 Cron 服务调度作业的执行；每个应用程序都有一定数量的
    Cron 作业可用，这取决于我们的计费计划。Cron 作业具有与任务队列中的任务相同的限制，因此请求可以持续长达 10 分钟。
- en: 'We first prepare a request handler that will implement the job:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先准备一个实现作业的请求处理器：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We derive the `ShrinkCronJob` class from the `ShrinkHandler` class to inherit
    the `_shrink_note()` method. The cron service performs an HTTP request of type
    `GET`, so we should override the `post()` method, simply returning a **HTTP 405:
    Method not allowed** error, thus avoiding someone hitting our handler with an
    HTTP `POST` request. All the logic is implemented in the `get()` method of the
    handler class. To ensure the handler was triggered by the Cron service and not
    by an external client, we first check whether the request contains the `X-AppEngine-Cron`
    header that is normally stripped by App Engine; if this is not the case, we return
    a **HTTP 403: Unauthorized** error. Then, we load all the Note entities from the
    Datastore and invoke the `_shrink_note()` method on each of them.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '我们从`ShrinkHandler`类派生出`ShrinkCronJob`类以继承`_shrink_note()`方法。Cron服务执行一个类型为`GET`的HTTP请求，因此我们应该重写`post()`方法，简单地返回一个**HTTP
    405: 方法不允许**错误，从而避免有人用HTTP `POST`请求击中我们的处理程序。所有逻辑都在处理程序类的`get()`方法中实现。为了确保处理程序是由Cron服务触发的，而不是由外部客户端触发的，我们首先检查请求是否包含通常由App
    Engine移除的`X-AppEngine-Cron`头；如果不是这种情况，我们返回一个**HTTP 403: 未授权**错误。然后，我们加载所有笔记实体并调用每个实体上的`_shrink_note()`方法。'
- en: 'We then map the `ShrinkCronJob` handler to the `/shrink_all` URL:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`ShrinkCronJob`处理程序映射到`/shrink_all` URL：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Cron jobs are listed in a `YAML` file in the application root, so we create
    the `cron.yaml` file with the following content:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Cron作业以`YAML`文件的形式列在应用程序根目录中，因此我们创建了一个包含以下内容的`cron.yaml`文件：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The file contains a list of job definitions with some properties: for each
    job, we must specify the URL and `schedule` properties, containing the URL mapped
    to the handler implementing the job and the time interval at which the job is
    executed, respectively, every day at midnight. We also add the optional `description`
    property containing a string to detail the job.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含一系列带有一些属性的作业定义：对于每个作业，我们必须指定URL和`schedule`属性，分别包含映射到实现作业的处理程序的URL和作业执行的时时间间隔，即每天午夜。我们还添加了一个可选的`description`属性，其中包含一个字符串来详细说明作业。
- en: The list of scheduled Cron jobs is updated every time we deploy the application;
    we can check for jobs' details and status by accessing the Developer Console or
    the local Development Console.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们部署应用程序时，都会更新计划中的Cron作业列表；我们可以通过访问开发者控制台或本地开发控制台来检查作业的详细信息和工作状态。
- en: Sending notification e-mails
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送通知电子邮件
- en: 'It''s very common for web applications to send notifications to the users,
    and e-mails are a cheap and effective channel for delivering. The Notes application
    could benefit from a notification system as well: early in this chapter, we modified
    the `shrink` image function so that it runs in a task queue. Users receive a response
    immediately, but the actual job is put in a queue and they don''t know if and
    when shrink operations complete successfully.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用程序来说，向用户发送通知是非常常见的，电子邮件是一种既便宜又有效的传递渠道。笔记应用程序也可以从通知系统中受益：在本章早期，我们修改了`shrink`图像函数，使其在任务队列中运行。用户会立即收到响应，但实际上作业被放入队列，他们不知道缩放操作何时成功完成。
- en: As we can send e-mail messages from an App Engine application on behalf of the
    administrators or users with Google Accounts, we send a message to the user as
    soon as the shrink operation is completed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以代表管理员或具有Google账户的用户从App Engine应用程序发送电子邮件消息，因此当缩放操作完成后，我们立即向用户发送消息。
- en: 'We first import the mail package in the `main.py` module:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`main.py`模块中导入邮件包：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we append the following code to the end of the `post()` method in the
    `ShrinkHandler` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将以下代码追加到`ShrinkHandler`类中的`post()`方法末尾：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: All we have to do is invoke the `send_mail()` method, passing in the sender
    address, the destination address, the subject of the e-mail, and the body of the
    message.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需调用`send_mail()`方法，传入发件人地址、目的地地址、电子邮件主题和消息正文。
- en: If we are running the application on the production server, the `sender_address`
    parameter must contain the registered address on App Engine of one of the administrators,
    or the message won't be delivered.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在生产服务器上运行应用程序，则`sender_address`参数必须包含App Engine上一位管理员的注册地址，否则消息将无法送达。
- en: If the application is running on the local development server, App Engine will
    not send out real e-mails and will show a detailed message on the console instead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序在本地开发服务器上运行，App Engine将不会发送真实的电子邮件，而是在控制台上显示一条详细的消息。
- en: Receiving users' data as e-mail messages
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收用户数据作为电子邮件消息
- en: 'A less common but useful feature for a web application is the ability to receive
    e-mail messages from its users: for example, a **Customer Relationship Management**
    (**CRM)** application could open a support ticket after receiving an e-mail sent
    out from a user to a certain address, say, `support@example.com`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个Web应用程序来说，一个不太常见但很有用的功能是能够接收来自其用户的电子邮件消息：例如，一个**客户关系管理**（**CRM**）应用程序在收到用户发送到特定地址（例如，`support@example.com`）的电子邮件后，可以打开一个支持工单。
- en: 'To show how this works on App Engine, we add the ability for our users to create
    notes by sending e-mail messages to the Notes application: the e-mail subject
    will be used for the title, the message body for the note content, and every file
    attached to the e-mail message will be stored on Cloud Storage and be attached
    to the note as well.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这在App Engine上的工作原理，我们添加了用户通过向笔记应用程序发送电子邮件消息来创建笔记的能力：电子邮件的主题将被用作标题，消息正文用作笔记内容，并且每封电子邮件消息中附加的每个文件都将存储在云存储上，并将其附加到笔记中。
- en: App Engine applications can receive e-mail messages at any address of the `<string>@<appid>.appspotmail.com`
    form; messages are then transformed to HTTP requests to the `/_ah/mail/<address>`
    URL, where a request handler will process the data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine应用程序可以在任何`<string>@<appid>.appspotmail.com`格式的地址接收电子邮件消息；然后，消息被转换成对`/_ah/mail/<address>`
    URL的HTTP请求，在那里一个请求处理器将处理数据。
- en: 'Before we start, we need to enable the incoming e-mail service, which is disabled
    by default, so we add the following in our `app.yaml` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要启用默认禁用的入站电子邮件服务，因此我们将在我们的`app.yaml`文件中添加以下内容：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we need to implement a handler for the e-mail messages, deriving from
    a specialized `InboundMailHandler` request handler class provided by App Engine.
    Our subclass must override the `receive()` method that takes a parameter containing
    an instance of the `InboundEmailMessage` class that we can use to access all the
    details from the e-mail message we received. We add this new handler to the `main.py`
    module but before proceeding, we need to import the modules and packages required:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现一个用于电子邮件消息的处理程序，它从App Engine提供的专门`InboundMailHandler`请求处理程序类中派生。我们的子类必须重写接受一个包含`InboundEmailMessage`类实例的参数的`receive()`方法，我们可以使用这个实例来访问我们从收到的电子邮件中获取的所有详细信息。我们将这个新的处理程序添加到`main.py`模块中，但在继续之前，我们需要导入所需的模块和包：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we start implementing our `CreateNoteHandler` class; this is the first
    part of the code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始实现我们的`CreateNoteHandler`类；这是代码的第一部分：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The first part of the code implements a simple security check: we actually
    create a note for a certain user only if the e-mail message comes from the same
    address users registered for their account. We first extract the e-mail address
    from the `sender` field of the `InboundEmailMessage` instance contained in the
    `mail_message` parameter with a regular expression. We then instance a `User`
    object representing the owner of the e-mail address that sent the message. If
    the sender does not correspond to a registered user, App Engine raises a `UserNotFoundError`
    error and we return a `403: Forbidden` HTTP response code, otherwise we call the
    `_reload_user()` method.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '代码的第一部分实现了一个简单的安全检查：我们实际上只为来自用户注册相同地址的电子邮件消息创建特定用户的笔记。我们首先使用正则表达式从包含在`mail_message`参数中的`InboundEmailMessage`实例的`sender`字段中提取电子邮件地址。然后，我们实例化一个代表发送该消息的电子邮件地址所有者的`User`对象。如果发送者不对应于已注册用户，App
    Engine将引发`UserNotFoundError`错误，我们返回一个`403: Forbidden` HTTP响应代码，否则我们调用`_reload_user()`方法。'
- en: 'If users want to attach a file to their notes, the Notes application needs
    to know the user ID of the note owner to build the path when storing files on
    Cloud Storage; the problem is that when we programmatically instance a `User`
    class without calling the `get_current_user()` method from the `users` API, the
    `user_id()` method of the instance always returns the `None` value. At the time
    of writing this, App Engine does not provide a clean method to determine the user
    ID from an instance of the `User` class, so we implement a workaround by following
    these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户想要将文件附加到他们的笔记中，笔记应用程序需要知道笔记所有者的用户ID来构建在云存储上存储文件时的路径；问题是当我们没有从`users` API调用`get_current_user()`方法来实例化`User`类时，该实例的`user_id()`方法总是返回`None`值。在撰写本文时，App
    Engine没有提供一种干净的方法来确定`User`类实例的用户ID，因此我们通过以下步骤实现了一个解决方案：
- en: Assign the `User` instance to a field of a Datastore entity, which is called
    the `UserLoader entity.`
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`User`实例分配给Datastore实体的一个字段，该字段称为`UserLoader`实体。
- en: Store the `UserLoader` entity in the Datastore.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`UserLoader`实体存储在Datastore中。
- en: Immediately after, load the entity again.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立即再次加载实体。
- en: 'This way, we force the `Users` service to fill in all the user data; by accessing
    the field containing the `User` instance in the `UserLoader` entity, we will get
    all the user properties, including the `id` property. We perform this operation
    in a utility method of the handler class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们强制`Users`服务填写所有用户数据；通过访问`UserLoader`实体中包含`User`实例的字段，我们将获得所有用户属性，包括`id`属性。我们在处理器类的实用方法中执行此操作：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To force a clean reload of the entity from the Datastore, we first need to
    purge the NDB cache, and we do this by calling the `delete()` method on the key
    passing the `use_datastore=False` parameter. We then reload the entity from the
    Datastore and return the `user` property, now containing all the data we need.
    We add the `UserLoader` model class to our `models.py` module:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制从Datastore重新加载实体，我们首先需要清除NDB缓存，这是通过在传递`use_datastore=False`参数的键上调用`delete()`方法来实现的。然后我们从Datastore重新加载实体并返回`user`属性，现在它包含我们所需的所有数据。我们将`UserLoader`模型类添加到我们的`models.py`模块中：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Back in the `receive()` method, we proceed to extract all the data we need
    from the e-mail message after reloading the `User` instance; in order to extract
    all the data, we need to create a note: the message subject is a simple string
    that we will use as the note title. Accessing the body is a little bit more complex
    because e-mail messages might have multiple bodies with different content types,
    typically plain text or HTML; in this case, we extract only the plain text body
    and use it as the note content.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`receive()`方法中，我们在重新加载`User`实例后继续从电子邮件消息中提取所需的所有数据；为了提取所有数据，我们需要创建一个笔记：消息主题是一个简单的字符串，我们将用它作为笔记标题。访问正文稍微复杂一些，因为电子邮件消息可能有多个正文，内容类型不同，通常是纯文本或HTML；在这种情况下，我们只提取纯文本正文并将其用作笔记内容。
- en: 'In the case, the e-mail messages have attachments, and the `mail_message` instance
    provides the `attachments` attribute: we pass it as a parameter to the method
    dedicated to note creation, that is the `_create_note()` method. The `_create_note()`
    method runs in a transaction and encapsulates all the logic needed to create a
    `Note` entity:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，电子邮件消息有附件，并且`mail_message`实例提供了`attachments`属性：我们将其作为参数传递给专门用于创建笔记的方法，即`_create_note()`方法。`_create_note()`方法在事务中运行并封装了创建`Note`实体所需的所有逻辑：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The method is quite similar to the method that has the same name in the `MainHandler`
    class; the main difference is the way in which we access data from the files attached
    to the e-mail message. The `attachments` parameter is a list of tuples of two
    elements: one is a string containing the file name and the other is an instance
    of a **wrapper** class containing the message payload. We use the filename to
    build the full path to the file in Cloud Storage, and we use the `decode()` method
    to access the payload data and store it in a file.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法与`MainHandler`类中同名的方法非常相似；主要区别在于我们从电子邮件消息中附加的文件中访问数据的方式。`attachments`参数是一个包含两个元素的元组列表：一个是包含文件名的字符串，另一个是包含消息有效载荷的**包装器**类的实例。我们使用文件名来构建云存储中文件的完整路径，并使用`decode()`方法来访问有效载荷数据并将其存储在文件中。
- en: 'Finally, we map the URL to the handler:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将URL映射到处理器：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When testing the application on the local development server, we can use the
    development console to simulate e-mail sending from a web interface; this function
    is available from the bar on the left-hand side by clicking on the **Inbound Mail**
    menu item.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发服务器上测试应用程序时，我们可以使用开发控制台从Web界面模拟发送电子邮件；此功能可通过点击左侧栏上的**入站邮件**菜单项获得。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we pushed a lot of features in our Notes application, and we
    should now be able to leverage the Cloud Storage and use it to store and serve
    static contents from our applications. We saw the Images API in action, and we
    should now know how to deal with requests that take a long time, and we also learned
    how to schedule recurrent tasks. In the last part, we delved into the Mail API
    capabilities and we learned how App Engine provides a turnkey solution to send
    and receive e-mail messages.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在Notes应用程序中添加了许多功能，现在我们应该能够利用云存储并将其用于存储和从我们的应用程序中提供静态内容。我们看到了Images API的实际应用，现在我们应该知道如何处理耗时较长的请求，我们还学习了如何安排重复任务。在最后一部分，我们深入探讨了Mail
    API的功能，并了解了App Engine如何提供发送和接收电子邮件消息的现成解决方案。
- en: In the next chapter, we will take a look at the performance of our application
    and see where and how we can improve, using advanced features of components we
    are already using together with more services provided by App Engine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将审视我们应用程序的性能，并探讨我们可以在哪些方面以及如何进行改进，这包括利用我们已使用的组件的高级功能，以及App Engine提供的更多服务。
