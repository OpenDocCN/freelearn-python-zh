<html><head></head><body>
		<div><h1 id="_idParaDest-91"><em class="italic"><a id="_idTextAnchor091"/>Chapter 6:</em> Working with Data – Variables</h1>
			<p>In previous chapters, we stated that a program is something that takes data as input and performs operations on it to produce new data. So, handling data is crucial in any application, regardless of whether it is used for accounting or whether it is a game.</p>
			<p>When we work with data, it must be stored in the computer's memory, and this is done with <strong class="bold">variables</strong>. It is variables that let us store and retrieve data. In this chapter, we will get to know variables, see how they work, and, in the end, look at some operations that we can perform on them.</p>
			<p>In this chapter, you will learn about the following:</p>
			<ul>
				<li>Declaring and initializing variables</li>
				<li>Understanding data types and applying them to variables</li>
				<li>Using composite types to handle multiple values</li>
				<li>Performing operations on variables using operators</li>
				<li>Operating on numbers and manipulating strings</li>
				<li>When programming, we need to work with data, and that data will be stored in the computer's memory. To be able to use this data, we need to have a way to reference where in the memory the data is. This is done by using a nice abstraction called variables. Variables hide the difficult stuff, such as working with memory addresses, and give us easy access to data by letting us assign a name to it. Let's see how this works.</li>
			</ul>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>Declaring and initializing variables</h1>
			<p>When writing <a id="_idIndexMarker233"/>programs, we continuously work with data. As we are using this data, we need <a id="_idIndexMarker234"/>a way to keep track of it. To do this, we use variables. Let's look at how this works in the following sections.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Understanding variables</h2>
			<p>To understand <a id="_idIndexMarker235"/>what a variable is, we can start with some code where we assign a value to a variable:</p>
			<pre>x = 13</pre>
			<p>Here, we have the value <code>13</code>, which is a whole number. Usually, in programming, we refer to these as integers as they can be both positive and negative. Different programming languages treat integer values differently. Most languages will specify how much memory an integer will use. Let's assume that this size is 4 bytes, which is a common size used to store an integer value. Remember that one byte is 8 bits and that each bit can be either <code>0</code> or <code>1</code>. With 4 bytes, we have 4 times 8 bits, which is 32 zeros or ones, at our disposal. </p>
			<p>To store <code>13</code> in the computer's memory, the programming language will need to reserve enough space—4 bytes, in our case.</p>
			<p>Each byte of computer memory has an address. A memory address works like a street address; it is used to help us navigate to the correct location:</p>
			<div><div><img src="img/B15554_06_01.jpg" alt="Figure 6.1 – Part of the computer's memory. Each square is a byte and has a unique address"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Part of the computer's memory. Each square is a byte and has a unique address</p>
			<p>In our example, 4 bytes that are not occupied by something else need to be located. These bytes need to be in continuous order.</p>
			<p>The address of the first byte in this sequence is of interest to us. The programming language knows that we are storing an integer value at this location, and it knows how many bytes an integer occupies, so the first address is enough to locate this integer. The following diagram shows this:</p>
			<div><div><img src="img/B15554_06_02.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – The programming language reserves enough space in memory for an integer value to be stored</p>
			<p>When writing a program, we don't want to remember numeric memory addresses, so we give this memory address a name. It is up to us, as programmers, to come up with this name, and we should pick a name that describes the data that we are storing. We will talk more about what considerations we need to make when naming variables soon:</p>
			<div><div><img src="img/B15554_06_03.jpg" alt="Figure 6.3 – The first address in the reserved sequence is given a name—in this case, x"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – The first address in the reserved sequence is given a name—in this case, x</p>
			<p>Now that we have enough room for the reserved integer value and a name that can be used to refer <a id="_idIndexMarker236"/>to this memory address, the actual value can be stored at this memory location. This value will be stored in binary format. We talked about binary numbers in <a href="B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Computer Programs</em>. In the preceding code snippet, we wanted to save the value <code>13</code>, and <code>13</code> in binary is <code>1101</code>. All of the bits preceding this value are filled with zeros. As you can see in the following diagram, one byte would have been enough, but as many languages have a fixed size for its integer type, all the bytes will be reserved, regardless of whether we need them:</p>
			<div><div><img src="img/B15554_06_04.jpg" alt="Figure 6.4 – The binary representation of the value we want to be stored is inserted at this memory location"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The binary representation of the value we want to be stored is inserted at this memory location</p>
			<p>Now, the value is stored in memory and we have a name that refers to this location. We can use this name to access this value. </p>
			<p>We call <code>x</code> in our example a variable. A variable consists of several things. It has a name, which is <code>x</code> in our sample. It also has a type. The type defines how much memory the data needs. We wanted to store an integer <a id="_idIndexMarker237"/>and we assumed that the language we are using has decided to use 4 bytes for integers. This is the size of this variable. We also know that if an integer has a fixed size, there is a maximum value that it can store. Later in this chapter, we will talk about this limitation. </p>
			<p>We also need to explore how we can name our variables and what types they can have. Let's start with the names.</p>
			<h3>Naming variables</h3>
			<p>The name <a id="_idIndexMarker238"/>we give a variable should reflect what data it represents, so if we use a variable to store an email address, a good name would be <code>email</code>, whereas <code>b45</code> would be rather lousy.</p>
			<p>The syntax of <a id="_idIndexMarker239"/>each language has rules for how we can name our variables. Some <a id="_idIndexMarker240"/>standard rules for naming variables are as follows:</p>
			<ul>
				<li>It must begin with a letter of the alphabet or an underscore (<code>_</code>).</li>
				<li>After the first character, the name can contain letters, underscores, and numbers.</li>
				<li>You cannot use names that are used as keywords in the language—that is, words that are reserved by the language, such as <code>for</code>, <code>if</code>, and <code>else</code>.</li>
				<li>Spaces or other special characters, such as <code>+</code>, <code>-</code>, and <code>*</code>, are not allowed to be part of the name.</li>
			</ul>
			<p>Some examples of legal and illegal names are as follows:</p>
			<div><div><img src="img/B15554_Table_6.1.jpg" alt="Table 6.1"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.1</p>
			<p>Many languages are also case sensitive when it comes to variable names. What that means is that the <code>name</code>, <code>Name</code>, and <code>nAmE</code> variables will be treated as three different variables.</p>
			<p>Many languages will also <a id="_idIndexMarker241"/>have what is known as naming conventions when it comes to how we construct <a id="_idIndexMarker242"/>and format variable names. There are also conventions for how to create <a id="_idIndexMarker243"/>names that are made up of more than one word. We will study these conventions next.</p>
			<h4>Camel case</h4>
			<p>Camel case is where <a id="_idIndexMarker244"/>the words that make up a name are separated <a id="_idIndexMarker245"/>by an uppercase <a id="_idIndexMarker246"/>letter that starts each word. There are <a id="_idIndexMarker247"/>two sub-types—<strong class="bold">upper camel case</strong> (also known as <strong class="bold">Pascal case</strong>) and <strong class="bold">lower camel case</strong> (also known as <strong class="bold">Dromedary case</strong>). Some <a id="_idIndexMarker248"/>examples of <a id="_idIndexMarker249"/>variable names using <a id="_idIndexMarker250"/>upper camel case are as follows:</p>
			<ul>
				<li><code>FirstName</code></li>
				<li><code>EmailAddress</code></li>
				<li><code>ZipCode</code></li>
			</ul>
			<p>The same <a id="_idIndexMarker251"/>names would look like this in lower camel case:</p>
			<ul>
				<li><code>firstName</code></li>
				<li><code>emailAddress</code></li>
				<li><code>zipCode</code></li>
			</ul>
			<p>As we can see, the first variant capitalizes all of the first letters of the words that make up a name, whereas the second variant leaves the first word in lowercase and only uses uppercase with the second word's first letter.</p>
			<p>Languages that recommend this naming convention are Java, C#, and Pascal.</p>
			<h4>Snake case</h4>
			<p>Separating words <a id="_idIndexMarker252"/>with an underscore is called snake case. When using this convention, we only <a id="_idIndexMarker253"/>use lowercase letters and separate words with an <a id="_idIndexMarker254"/>underscore character. Using this casing for the same variable names as the preceding examples would look like this:</p>
			<ul>
				<li><code>first_name</code></li>
				<li><code>email_address</code></li>
				<li><code>zip_code</code></li>
			</ul>
			<p>Languages that use this convention for naming variables include Python, Ruby, C, and C++, in some circumstances.</p>
			<p>What does it mean when we say a language has a convention for naming variables?</p>
			<h3>Naming conventions</h3>
			<p>Usually, a naming convention is a recommended way for naming things, such as variables. This means that we <a id="_idIndexMarker255"/>can break these rules and the program will still work. However, there are several good reasons for us to obey these recommendations. One could be that if <a id="_idIndexMarker256"/>many programmers are involved in writing some code, the style will be consistent and, therefore, more straightforward to interpret for human readers.</p>
			<p>Some software companies have their own naming conventions. This is typically the case when the language itself has a weak or non-existing convention.</p>
			<p>When coming across a new language, we should always learn its conventions. If you work on several projects that use different programming languages, it can be tricky to remember what convention to use.</p>
			<p>Read more about naming conventions in <a href="B15554_12_Final_NM_ePub.xhtml#_idTextAnchor186"><em class="italic">Chapter 12</em></a>, <em class="italic">Code Quality</em> in the <em class="italic">Using code conventions</em> section.</p>
			<p>Now that we know how to name a variable, let's explore the different types that a variable can have.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Primitive data types</h1>
			<p>Every variable <a id="_idIndexMarker257"/>has both a name and a type. The type defines what kind of data can be stored in the variable. Typically, a language will have some built-in types, called primitive or basic types, to handle a single value.</p>
			<p>Primitive types can be divided into two categories—Boolean and numeric—which we will look at next.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Boolean type</h2>
			<p>In <a href="B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a><em class="italic">, Introduction to Computer Programs</em>, we talked about George Bool and his Boolean algebra. This defined how we can combine values of <code>true</code> and <code>false</code> with <code>and</code>, <code>or</code>, and <code>not</code>. To be able to <a id="_idIndexMarker258"/>use these values in our programs, we have a type that <a id="_idIndexMarker259"/>is named after Bool, called Boolean. A variable that uses this type can only have one of two values—<code>true</code> or <code>false</code>. For languages that have these types, we use the actual <code>true</code> and <code>false</code> words. </p>
			<p>Languages that have this type either call it <code>Boolean</code> or just <code>bool</code>.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Numeric type</h2>
			<p>Numeric types <a id="_idIndexMarker260"/>fall into one of two categories—integer types and <a id="_idIndexMarker261"/>floating-point types. We will look at them in detail, next.</p>
			<h3>Integer data types</h3>
			<p>The first question you could ask yourself here is why are we talking about types in plural when it comes to integers? You could argue that data is either an integer or not. As it turns out, many languages will <a id="_idIndexMarker262"/>have several types for representing integer values and <a id="_idIndexMarker263"/>the reason for this has to do with how much memory is used for the data and how that data should be interpreted.</p>
			<p>As we saw earlier in this chapter, a language will define how much memory to use when storing data in a variable. When working with integers, we might only work with small values in a predefined range, such as the age of a human, or the values might be huge, such as the distance between stars.</p>
			<p>If we think about the characteristics of the data we are working with, we will discover that it has natural limitations. The age of a human, for example, will never have a negative value, and if we take the highest human age recorded (122 years, at the time of writing) and add some years to be on the safe side, we could state that a valid human age will fall into the range of 0 to 150. One byte—remember that one byte is 8 bits (8 zeros or ones)—can work with numbers in the range 0 to 255, so that is more than enough to store human age.</p>
			<p>If we instead talk about the distance between us and other stars, we have a different range of values. The closest star, except for our own sun, are the two stars in the Alpha Centauri system. They are just over 4 lightyears away. The furthest star that we have observed, known by the name MACS J1149+2223 Lensed Star 1, is 9 billion lightyears away. So, if we are working with these values, we still would not <a id="_idIndexMarker264"/>need any negative numbers and the range would be between 4 and 9,000,000,000.</p>
			<p>Sometimes, we <a id="_idIndexMarker265"/>need to work with both negative and positive numbers—for example, if we are writing some accounting software.</p>
			<p>This means that integer values can have different properties, and for that reason, we have more than one integer type so that we can find one that fits our needs. As we don't need any negative numbers and the maximum won't ever exceed 150 as a value for human age, a type that can work with huge or negative numbers would be a waste of the computer's memory.</p>
			<p>With this knowledge, programming languages are often implemented with several different integer types that differ in how much memory (measured in bytes) they will use to represent a value. The programmer's task is to pick one that matches the properties for the data that will be handled by the variable that has this type.</p>
			<p>Different languages will have a different set of integer types, but here are some typical integer types, their sizes, and the range of values that they can handle:</p>
			<div><div><img src="img/B15554_Table_6.2.jpg" alt="Table 6.2"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.2</p>
			<p>As you can see, all the preceding types include negative as well as positive values. Representing <a id="_idIndexMarker266"/>both will limit how a type can serve <a id="_idIndexMarker267"/>large numbers. Taking human age as an example again, we will see that the byte type wouldn't really work as although it has a maximum value of 127, it has 128 negative values that we would never use.</p>
			<p>The reason why we have this restriction has to do with how negative numbers are represented.</p>
			<h4>Signed and unsigned integers</h4>
			<p>If we look at <a id="_idIndexMarker268"/>the smallest type in the preceding table—the byte—and think about how negative numbers can be represented, we will see that we have a problem. When <a id="_idIndexMarker269"/>working with binary numbers, we have several bits <a id="_idIndexMarker270"/>that can store either <code>0</code> or <code>1</code>, but we don't have any other values, so we can't just <a id="_idIndexMarker271"/>insert a minus sign to indicate that this is a negative number. Instead, one of the following three methods can be used.</p>
			<p>Let's see how they work.</p>
			<h4>Signed Magnitude Representation (SMR)</h4>
			<p>Even if the <a id="_idIndexMarker272"/>name is a bit complicated, this is the easiest way to represent negative values in binary form. Imagine that we are working with <a id="_idIndexMarker273"/>one byte that gives us eight bits to represent a value. However, if we assign one of the bits to represent whether this is a positive or negative value, we are left with just seven bits for the actual value:</p>
			<div><div><img src="img/B15554_06_05.jpg" alt="Figure 6.5 – A byte using only 7 bits to represent a value—127, in this case"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – A byte using only 7 bits to represent a value—127, in this case</p>
			<p>If we use the bit to the left in the preceding diagram—often referred to as the most significant bit as it is the bit representing the highest value—to represent whether the rest should be considered either positive or negative, the rest of the bits can form a maximum value of <code>127</code>:</p>
			<div><div><img src="img/B15554_06_06.jpg" alt="Figure 6.6 – Using the most significant bit to represent a positive value—29, in this case"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Using the most significant bit to represent a positive value—29, in this case</p>
			<p>If we designate <a id="_idIndexMarker274"/>the first position to indicate whether this is a positive or a negative value, we can use <code>0</code> to show that this is a positive value and <code>1</code> to show that this is a negative one:</p>
			<div><div><img src="img/B15554_06_07.jpg" alt="Figure 6.7 – Using the most significant bit to represent a negative value, -29, in this case"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Using the most significant bit to represent a negative value, -29, in this case</p>
			<p>Using this <a id="_idIndexMarker275"/>technique, we have a range of values from <code>-127</code> to <code>127</code> using a single byte. We will also have two representations for 0—positive and negative. This is one disadvantage of this method and a reason why it is not used so often.</p>
			<p>Another problem with this technique is found when performing mathematical operations, such as addition, on two values that use SMR.</p>
			<p><em class="italic">Figures 6.8 to 6.12</em> illustrate what happens if we add <code>3</code> and <code>c</code> together if we have used SMR to represent a negative value. To understand the diagrams, imagine that you add two decimal numbers. If you want to add <code>495</code> and <code>572</code>, we will put one above the other and start to add them column by column:</p>
			<div><div><img src="img/B15554_06_31.jpg" alt=""/>
				</div>
			</div>
			<p>We then do the same for the next column, but as we get a value larger than <code>9</code>, we have to carry:</p>
			<div><div><img src="img/B15554_06_32.jpg" alt=""/>
				</div>
			</div>
			<p>When adding <a id="_idIndexMarker276"/>the last column, we use the carried number as part of the numbers we add:</p>
			<div><div><img src="img/B15554_06_33.jpg" alt=""/>
				</div>
			</div>
			<p>We can apply <a id="_idIndexMarker277"/>the same principle for adding binary numbers. The only difference is that we now work with just two digits. So, instead of <code>10</code>, we will need to carry a value as soon as the result is greater than 1. Now, when adding two bits that can be either <code>0</code> or <code>1</code>, we only end up with three different results—0, 1, or 2 (in decimal). If we consider that we need to add two values and one potential carried value, the maximum will be 1 + 1 + 1 = <code>3</code>. Now that we know the maximum value we can possibly get (3), we can translate it into binary. <code>3</code> in binary is <code>11</code>. This means that our possible results will be 0, 1, 10, and 11. 0 and 1 fit within a single bit, but <code>10</code> and <code>11</code> do not, so here, we will need to carry 1.</p>
			<p>As guidance, let's use a table to convert between decimal and binary values:</p>
			<div><div><img src="img/B15554_Table_6.3.jpg" alt="Table 6.3"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.3</p>
			<p>Let's also <a id="_idIndexMarker278"/>see another <a id="_idIndexMarker279"/>table that helps us understand how binary addition works:</p>
			<div><div><img src="img/B15554_Table_6.4.jpg" alt="Table 6.4"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.4</p>
			<p>As you <a id="_idIndexMarker280"/>can see, the last three operations resulted in two digits, so all of them will result in a carry.</p>
			<p>Let's see <a id="_idIndexMarker281"/>how we can apply this principle when adding binary numbers:</p>
			<div><div><img src="img/B15554_06_08.jpg" alt="Figure 6.8 – Adding two values, 3 and -3, where the negative number is represented using SMR"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – Adding two values, 3 and -3, where the negative number is represented using SMR</p>
			<p>When we want to add two binary numbers, we do the same thing that we did with decimal numbers. The only difference is that we can only handle results that are 0 or 1. If the result is 2, we need to carry 1 to the next position:</p>
			<div><div><img src="img/B15554_06_09.jpg" alt="Figure 6.9 – Step one is to add the two rightmost bits—1 + 1 = 2"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – Step one is to add the two rightmost bits—1 + 1 = 2</p>
			<p>From the <a id="_idIndexMarker282"/>preceding diagram, we can see that as 2 in binary is 10, we insert 0 at this location and carry 1.</p>
			<p>This means <a id="_idIndexMarker283"/>that in the next step, we have three values—1 + 1 + 1. As the result will be 3, which is 11 in binary, we insert a 1 in this position and carry 1 to the next round:</p>
			<div><div><img src="img/B15554_06_10.jpg" alt="Figure 6.10 – Repeating the operation for the next two bits"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Repeating the operation for the next two bits</p>
			<p>In this example, we now have several positions where we add zeros together, but we must remember that we have carried 1 the first time:</p>
			<div><div><img src="img/B15554_06_11.jpg" alt="Figure 6.11 – For the third pair of bits, we are adding two zeros with the carry"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – For the third pair of bits, we are adding two zeros with the carry</p>
			<p>We can <a id="_idIndexMarker284"/>now repeat this all the way to the last position. This is our sign bit:</p>
			<div><div><img src="img/B15554_06_12.jpg" alt="Figure 6.12 – The next four bits are just zeros with no carry, so they will all result in zeros"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – The next four bits are just zeros with no carry, so they will all result in zeros</p>
			<p>As we <a id="_idIndexMarker285"/>are adding a positive value (3) with a negative value (-3), we have <code>0</code> at this position for the first value and <code>1</code> in the second to indicate that the value is negative. As 0 + 1 is 1, this indicates that the result is negative:</p>
			<div><div><img src="img/B15554_06_13.jpg" alt="Figure 6.12 – When we add the bit used as a sign bit, the result will be 1, indicating that the result is negative"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – When we add the bit used as a sign bit, the result will be 1, indicating that the result is negative</p>
			<p>To our surprise, we discover that the result of adding 3 and -3 is not 0 as we expected but -6, as we have 4 plus 2, which is 6, and 1 at the first position, indicating that this is a negative number.</p>
			<p>This is another reason why this method is not used that often.</p>
			<h4>Ones' complement</h4>
			<p>Another approach to representing negative numbers that will address the problem we saw when we tried to add <a id="_idIndexMarker286"/>a positive and a negative value is the use of something called ones' complement. It also uses the most significant bit (the leftmost bit in our illustrations) as the sign <a id="_idIndexMarker287"/>bit but stores negative numbers differently compared to SMR.</p>
			<p>If we have a positive value, we can use 3 again as an example, and if we store it in a byte, we get 0000 0011, as we can see here:</p>
			<div><div><img src="img/B15554_06_14.jpg" alt="Figure 6.13 – Storing positive 3 in a byte"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – Storing positive 3 in a byte</p>
			<p>To store -3, we flip all the bits, so 0 becomes 1 and vice versa, as follows:</p>
			<div><div><img src="img/B15554_06_15.jpg" alt="Figure 6.14 – Storing -3 using ones' complement. All values are the opposite of when we store positive 3"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14 – Storing -3 using ones' complement. All values are the opposite of when we store positive 3</p>
			<p>As we can see, all the bits are the opposite compared to when we stored a positive 3. When this number is interpreted, the sign bit is checked first. If it is 1, all the other bits are then flipped to form the actual value. This might seem like a strange thing to do, but let's see what happens when we add the two together:</p>
			<div><div><img src="img/B15554_06_16.jpg" alt="Figure 6.15 – Adding 3 and -3 where the negative number is represented using ones' complement"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – Adding 3 and -3 where the negative number is represented using ones' complement</p>
			<p>As we can see in the preceding diagram, we add 1 and 0 for each location. The result will, therefore, be 1 in every position, as we can see here: </p>
			<div><div><img src="img/B15554_06_17.jpg" alt="Figure 6.16 – The result of adding the two bytes will be 1 in all locations"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16 – The result of adding the two bytes will be 1 in all locations</p>
			<p>As we have 1 for the signed bit, this means that we have a negative result, so all the other bits need to be flipped and the result will be -0. Now, this is better as 3 + (-3) is 0, but negative 0 does not mean anything. This means <a id="_idIndexMarker288"/>that this method also has the same <a id="_idIndexMarker289"/>problem as SMR, where we have two representations of the value 0—one positive and one negative:</p>
			<div><div><img src="img/B15554_06_18.jpg" alt="Figure 6.17 – As the sign bit is 1, all the other bits need to be flipped, forming negative 0"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17 – As the sign bit is 1, all the other bits need to be flipped, forming negative 0</p>
			<p>Let's see whether we can tackle this problem and find a representation that works.</p>
			<h4>Two's complement</h4>
			<p>To solve the <a id="_idIndexMarker290"/>problem of two zeros in ones' complement, a third method for representing integer values exists, which is called two's complement. It works in the same way as ones' complement but with a twist.</p>
			<p>The first <a id="_idIndexMarker291"/>step is to use ones' complement to represent a negative number, which takes the positive value and flips all the bits. But when that is done, we add 1 to the result. Now, this might seem like we are messing the result up totally, but as we will see, it solves the problem with the double zero representation.</p>
			<p>See <em class="italic">figures 6.18 to 6.21</em> to see how this works:</p>
			<div><div><img src="img/B15554_06_19.jpg" alt="Figure 6.18 – Representing the value 3 in a byte"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18 – Representing the value 3 in a byte</p>
			<p>Representing a positive value is done just the same as before. However, when dealing with negative numbers, we do things differently:</p>
			<div><div><img src="img/B15554_06_20.jpg" alt="Figure 6.19 – Representing -3 in the two's complement form"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19 – Representing -3 in the two's complement form</p>
			<p>Here, we take all the bits from the positive representation and flip them, so 0 becomes 1 and vice versa:</p>
			<div><div><img src="img/B15554_06_21.jpg" alt="Figure 6.20 – When adding 3 and -3, we do what we did before. 1 + 1 = 10, so 0 goes to this position and 1 is carried"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20 – When adding 3 and -3, we do what we did before. 1 + 1 = 10, so 0 goes to this position and 1 is carried</p>
			<p>Adding <a id="_idIndexMarker292"/>the bits together is done in the same way as before:</p>
			<div><div><img src="img/B15554_06_22.jpg" alt="Figure 6.21 – For all positions, we have 1 carry, so we will add 1 + 1 + 0 = 10"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.21 – For all positions, we have 1 carry, so we will add 1 + 1 + 0 = 10</p>
			<p>When <a id="_idIndexMarker293"/>adding the sign bit to the left, we get a carry. The two's complement method states that this carry should be discarded.</p>
			<p>We can see that the result of this operation is a byte with only zeros, giving us a single representation of 0 as a result. </p>
			<p>As two's complement solves both the problem with the binary representation of zero and the problem of adding two values together, this is the one that is most frequently used.</p>
			<h4>Unsigned integers</h4>
			<p>Some languages <a id="_idIndexMarker294"/>will let us work with integer types that use all bits as values. This allows us to work with only positive integers, but they can, on the other hand, be twice <a id="_idIndexMarker295"/>as big because we use all the bits to store values.</p>
			<p>Not all numerical values are integers, so let's now look at another group of numerical data types—floating-point types.</p>
			<h3>Floating-point types</h3>
			<p>Representing floating-point numbers using the binary form is tricky, and as a programmer, we soon discover some oddities that relate to this. Let's look at the following code:</p>
			<pre>result = 0.1 + 0.2</pre>
			<p>We would <a id="_idIndexMarker296"/>expect the result stored in the variable result to be <code>0.3</code>, but in many languages, this will instead be something like <code>0.30000000000000004</code>.</p>
			<p>The reason <a id="_idIndexMarker297"/>we get odd results like this is that we try to represent a decimal floating-point number as a binary floating-point number. We will not go into too much detail about how floating-point numbers are represented in a computer as it will get a bit complicated. If you want to learn how this is done, you can search for it online and see lots of detailed explanations for how it works.</p>
			<p>But what we will do is to think about the problem the computer faces when dealing with a binary representation of a decimal number.</p>
			<p>In our decimal positional system, each position in a number has a value, as we saw earlier. This is just as true for floating-point numbers as for integers. For a floating-point number, the positions have values, as illustrated:</p>
			<div><div><img src="img/B15554_06_23.jpg" alt="Figure 6.22 – The values that the different positions have in the decimal system, to the left and right of the decimal point"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.22 – The values that the different positions have in the decimal system, to the left and right of the decimal point</p>
			<p>Using this system makes it easy for us to store a value—for example, one-tenth can be written as 0.1. In binary, the positions are as follows:</p>
			<div><div><img src="img/B15554_06_24.jpg" alt="Figure 6.23 – The values that the different locations have in the binary system, &#13;&#10;to the left and right of the decimal point"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.23 – The values that the different locations have in the binary system, to the left and right of the decimal point</p>
			<p>As we <a id="_idIndexMarker298"/>can see, no value represents one-tenth, so something else needs to be done. What computers do is store floating-point values in scientific notation. Representing the <code>300</code> decimal value in scientific form come to <img src="img/Formula_06_001.png" alt=""/>. The computer does this but in binary form <a id="_idIndexMarker299"/>and divides the value into three parts. The first is the sign, just as we saw for integer values. The second part is the exponent used and the last part is called the mantissa. The mantissa is <a id="_idIndexMarker300"/>the decimal part of a logarithm to base 10 (that is, a decimal number). If that means nothing to you, don't worry. You don't need to understand the math to be able to use floating-point numbers. However, we must understand why numbers don't always come out the way we expect them to.</p>
			<p>To illustrate this, we can think about what happens if we calculate 1/3. We will get <code>0.333333333…</code>, where we will have an infinite number of threes. The same thing happened when we tried to represent <code>0.1</code> using binary numbers. The result will be a value that goes on forever in the binary form. The problem is that the computer does not have an infinite amount of memory, so when the amount that is assigned to this type runs out, it will just stop, which means that we will not have an accurate representation of the number. That is why we got <code>0.30000000000000004</code> instead of <code>0.3</code> when we added <code>0.1</code> and <code>0.2</code> together in the preceding example.</p>
			<p>Without going into the math of how floating-point numbers are represented, we need to understand the two most <a id="_idIndexMarker301"/>frequent types for representing them that we find in programming. They are usually called <strong class="bold">float</strong> and <strong class="bold">double</strong>.</p>
			<p>The difference <a id="_idIndexMarker302"/>between them is that a float will usually use 32 bits and a double will use 64 bits. This means that the double has more memory to use before it chops off a number. It is named double because it has double precision compared to the float type.</p>
			<p>What we can <a id="_idIndexMarker303"/>learn from this is that if precision matters in our application, we should use a double, but if not, we can use a float. If, for example, we want to store outside temperatures, a float will be fine to use as we never deal with that many decimals.</p>
			<p>We can now <a id="_idIndexMarker304"/>work with integer and floating-point numbers, but sometimes we want to represent other kinds of values, such as complex numbers.</p>
			<p>Some programming languages have a special type for working with complex numbers. Some examples of languages that use this type are Go, C++, Python, and Ruby.</p>
			<p>There is also another numeric type, even if we often think of it as something else—the character type.</p>
			<p>A character that is a letter, a punctation mark, or any other character that we can come up with can be represented as a number. Many programming languages will provide a special type that is meant to handle a single character, but under the hood, it is an integer type. It is treated in a different way than the other numeric types that we have seen, as we can assign not only numbers to it but also characters, surrounded by some quotation marks—often single quotes. It can look something like this:</p>
			<pre>character_a = 'a'</pre>
			<p>Here, we assign the <code>a</code> character to a variable called <code>character_a</code>. The character is surrounded by single quotes to indicate that this is a character and not a variable named <code>a</code>. What happens is that the numerical value for this character is assigned to the variable. The character value for lowercase <code>a</code> is <code>97</code>, so in this case, that is what will be stored in the variable.</p>
			<p>To print the content of the variable to the screen, type the following code:</p>
			<pre>print character_a</pre>
			<p>We will see <code>a</code> printed, not <code>97</code>, as the programming language will know that this is a character type and not a normal numeric type and will translate the numerical value back to the character representation again.</p>
			<p>Sometimes, we <a id="_idIndexMarker305"/>need to store more than one value at a time. Then, we can use what are called <strong class="bold">composite types</strong>.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>Composite type</h1>
			<p>A composite type <a id="_idIndexMarker306"/>is a data type that is made up of more than one value. There are situations when keeping several related values together makes sense. In our everyday life, we do this often. A shopping list is an example. Instead of having several papers, each one having one item we need to buy, we store all the items on one piece of paper and call this a list. </p>
			<p>This is how a composite type works in programming as well. We have several types that all have some specific characteristics. The first one can be used when we want to represent a sequence or list of things. This is often called an array.</p>
			<p>An array—also called a vector, list, or sequence—is a data type that stores several elements. This number can be fixed or flexible.</p>
			<h4>Fixed array</h4>
			<p>When we have a fixed size array, we say how many slots we want it to have when we create it. This size will not change. If we create an array that can store 10 integers, it will reserve space for 10 integers, even if we only use 3 or 5.</p>
			<p>Typically, we would <a id="_idIndexMarker307"/>create a fixed-size array as follows:</p>
			<pre>numbers[10]</pre>
			<p>Here, we say that <a id="_idIndexMarker308"/>we want an array that can store 10 integers and we call it <code>numbers</code>. We are not storing any values in the array, so we say that these 10 locations are unassigned, but we have space in memory reserved for us, and we have a name that we can use to access this space.</p>
			<p>We can see this as if we have 10 different variables. The only difference is that we store all 10 variables under the same name.</p>
			<p>We will now need a way to address these variables individually. This is done by indexing.</p>
			<p>We can index into the array by using its name and an index value:</p>
			<pre>numbers[2] = 44</pre>
			<p>Here, we store <code>44</code> at position <code>2</code> in the array. You might think that position <code>2</code> is the second value in the array, but it is actually the third. The reason for this is that the index starts at 0, as shown: </p>
			<div><div><img src="img/B15554_06_25.jpg" alt="Figure 6.24 – Inserting 44 at index 2 will place the value in the third position of the array"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.24 – Inserting 44 at index 2 will place the value in the third position of the array</p>
			<p>The reason that the indexing starts at 0 and not 1 is that we can think of the name that we used for this array as a reference to the first location in the array. When using an index, we say <a id="_idIndexMarker309"/>how many places we should move forward. So, <code>numbers[2]</code> means we start at the first location and move forward 2 integers in memory. That is the location you should store the value at.</p>
			<p>We can also retrieve a value from a given index, as follows:</p>
			<pre>print numbers[2]</pre>
			<p>The preceding <a id="_idIndexMarker310"/>code prints the value that is located at index <code>2</code>, which is the third value in the array. </p>
			<p>Having an array of a fixed size can be problematic as it is not always the case that we know how many values we need to store. If this is the case, then we can use another type of array that can grow and shrink as we use it. This is sometimes called a dynamic array.</p>
			<h4>Dynamic array</h4>
			<p>A dynamic array (or list, vector, or sequence) is an array that can grow and shrink as we use it. Initially, this kind <a id="_idIndexMarker311"/>of array will be empty when we first create it, but we can then add <a id="_idIndexMarker312"/>and remove things from it as we go along. How we create these arrays will differ from language to language, but it can look something like this:</p>
			<pre>numbers = []</pre>
			<p>Here, we are creating an empty dynamic array.</p>
			<p>We can now add and remove things from this array:</p>
			<pre>numbers.add(10)
numbers.add(11)
numbers.add(12)
numbers.remove(11)</pre>
			<p>Here, we first add three values—<code>10</code>, <code>11</code>, and <code>12</code>. Values are usually added at the end, so they will be stored in the <code>10</code>, <code>11</code>, <code>12</code> order. </p>
			<p>On the last line, we remove the <code>11</code> value. The array now has the <code>10</code> and <code>12</code> values.</p>
			<p>Often, we will have different ways to dictate where in this array new values should be added and removed. We might, for example, be able to do something like this:</p>
			<pre>numbers.addBack(10)
numbers.addFront(11)
numbers.addBack(12)
numbers.addFront(13)</pre>
			<p>From the preceding code, we can see the following:</p>
			<ol>
				<li value="1">We add the <code>10</code> value to the back of the empty array.</li>
				<li>Then, we add the <code>11</code> value to the beginning of the array. We now have <code>11</code>, <code>10</code>.</li>
				<li>Then, we add <code>12</code> to the back, giving us <code>11</code>, <code>10</code>, <code>12</code>.</li>
				<li>In the last line, we add <code>13</code> to the front of the array. We now have the <code>13</code>, <code>11</code>, <code>10</code>, and <code>12</code> values.</li>
			</ol>
			<p>We can often use an index, just as with a fixed size array, to retrieve individual values from a dynamic array. The problem is that we need to keep track of how many items we currently have in the array. This is important because if you have an array of let's say five things and you say that you want to get item number 10, you are looking outside the array and <a id="_idIndexMarker313"/>your programming language will most likely halt the execution of the program as you are doing something that is considered illegal (according to your language, that is.)</p>
			<p>Dynamic arrays <a id="_idIndexMarker314"/>come at another cost as well. When we create a fixed-size array, a big enough chunk of memory will be found, and we can then go ahead and use this. All the items in the array must come sequentially in memory because that is what makes indexing work. As we saw, the name of the array will tell us the starting location for this array, and we then use an index to say how many steps into the memory we need to move to come to the correct place.</p>
			<p>When using a dynamic array, this might be a problem. If we add item after item, we will eventually hit a memory location where something else is located. Our array will now need to move to another location that is big enough for all the values we already had in it, plus the new value that we want to add. As a programmer, this is not a usual task. The language does this for us, but copying all the old values from the original location to this location will take time. This is the cost we pay for the freedom of having a structure that can grow and shrink depending on our needs.</p>
			<p>Most programming <a id="_idIndexMarker315"/>languages will only let you store data of the same type <a id="_idIndexMarker316"/>in an array. There are a few, however, that will allow you to mix the types as you wish.</p>
			<p>Sometimes, we want to store values that are related in another way—let's say information about a person. Then, we can use what is called a record.</p>
			<h3>The record type</h3>
			<p>If you are writing an application and you want to represent information about, say, customers, you will first <a id="_idIndexMarker317"/>need to decide what information you want to handle. This might be the customer's first and last name, a street address, a city, a ZIP code, and so on. This might include <a id="_idIndexMarker318"/>data of different types. It would also be handy if you could retrieve the different items with the help of a name.</p>
			<p>Records are sometimes called structures or structs. To use them, we first need to define what they look like. This can look something like this:</p>
			<pre>struct Person 
   firstName,
   lastName,
   streetAddress,
   city,
   zip
end_struct</pre>
			<p>What we are doing here is defining a new type called <code>Person</code>. One variable of this type can store a first name, last name, street address, city, and ZIP code.</p>
			<p>Creating a variable of this type might look something like this:</p>
			<pre>Person person1</pre>
			<p>We now have a variable called <code>person1</code>, but we do not store any data in it yet. Doing so might look like this:</p>
			<pre>person1.firstName = "Anna"
person1.lastNamme = "Smith"
person1.streetAddress = "34 Main Street"
person1.city = "Home Town"
person1.zip = "123 456"</pre>
			<p>All the information we have about this person is now stored in the <code>person1</code> variable. We can now create other <code>person</code> variables to store information about other people:</p>
			<pre>Person person2
Person person3
person2.firstName = "Bob"
person3.firstName = "Colette"</pre>
			<p>We can <a id="_idIndexMarker319"/>also retrieve the data stored within these variables, as follows: </p>
			<pre>print person1.firstName
print person2.firstName
print person3.firstName</pre>
			<p>The output <a id="_idIndexMarker320"/>of this will be as follows:</p>
			<pre>Anna
Bob
Colette</pre>
			<p>Here, we have a relationship between a variable name, <code>firstName</code>, for example, and some data—<code>Anna</code>, <code>Bob</code>, and <code>Colette</code>. We know about this relationship beforehand, so the record structure is perfect for us. Sometimes, we might not know what we will get, but the data might still come in pairs. Then, we can use another data type known as a dictionary.</p>
			<h3>The dictionary type</h3>
			<p>A <a id="_idIndexMarker321"/>dictionary (also known as a map, hash map, or associative array) is a <a id="_idIndexMarker322"/>collection type that uses key-value pairs. The key needs to be a unique value that we can use to retrieve the value that is associated with it. </p>
			<p>A colon often separates the key and the value.</p>
			<p>They might look something like this:</p>
			<pre>dictionary books 
    "Pride and Prejudice": "Jane Austen",
    "David Copperfield": "Charles Dickens",
    "Madame Bovary": "Gustave Flaubert"
end_dictionary</pre>
			<p>Here, we are using the name of some famous books as the keys, and the value associated with each key is the author of that book. As we stated before, the key needs to be unique. If we reuse the key and assign another value to it, the old value will be overwritten by the new one.</p>
			<p>We can access the values—the names of the authors, in our case—by using the key as an index:</p>
			<pre>print books["David Copperfield"]</pre>
			<p>This will give the following output:</p>
			<pre>Charles Dickens</pre>
			<p>As it is only the key that needs to be unique, we can have multiple items that have the same value. We can, for example, add a book to the dictionary as follows:</p>
			<pre>books["Oliver Twist"] = "Charles Dickens"</pre>
			<p>We now <a id="_idIndexMarker323"/>have two values containing <code>Charles Dickens</code>, but they are associated with two different and unique keys.</p>
			<p>Sometimes, we have <a id="_idIndexMarker324"/>other reasons for storing unique values. We might want to represent what in mathematics is known as finite sets. For that, we also have the set type.</p>
			<h3>The set type</h3>
			<p>A set <a id="_idIndexMarker325"/>is a composite type that will store unique values without any order. As this type is unordered, we cannot <a id="_idIndexMarker326"/>retrieve items from it with an index. This is usually not a problem as this type is often used to test for membership. You might, for example, have two sets with some values in them and <a id="_idIndexMarker327"/>would like to know which values occur in both sets. </p>
			<p>Let's see how we might create these two sets and then print the values that occur in both:</p>
			<pre>firstSet = {2, 5, 7, 9}
secondSet {2, 3, 4, 8, 9}
print firstSet.intersection(secondSet)</pre>
			<p>In set theory, an intersection <a id="_idIndexMarker328"/>between two sets are the values that exists in both sets. </p>
			<p>The output of this will be as follows:</p>
			<pre>2, 9</pre>
			<p>This output is represented as follows:</p>
			<div><div><img src="img/B15554_06_26.jpg" alt="Figure 6.25 – Representation of two sets that has an intersection of 2 and 9 as &#13;&#10;these two values exist in both sets"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.25 – Representation of two sets that has an intersection of 2 and 9 as these two values exist in both sets</p>
			<p>Sometimes, we want to create a new type so that we can dictate what values can be assigned to variables that are of this type. For this, we have enumeration.</p>
			<h3>Enumeration</h3>
			<p>Enumeration, often <a id="_idIndexMarker329"/>called just <strong class="bold">enum</strong>, is an enumerated type with distinct values. We can <a id="_idIndexMarker330"/>use this to create our types and dictate what values can be assigned to a variable that has this type.</p>
			<p>It can look something like this:</p>
			<pre>enum TrafficLight
    red,
    yellow,
    green
end_enum</pre>
			<p><code>TrafficLight</code> is now a type and we can use it to create variables:</p>
			<pre>TrafficLight light1
TrafficLight light2</pre>
			<p>As both <code>light1</code> and <code>light2</code> are of the <code>TrafficLight</code> type, we can only assign the things we described inside this type:</p>
			<pre>light1 = yellow
light2 = green</pre>
			<p>Behind the scenes, there are numerical values associated with each of the items in the enum. In our case, <code>red</code> will be <code>0</code>, <code>yellow</code> is <code>1</code>, and <code>green</code> is <code>2</code>. </p>
			<p>Now, we have <a id="_idIndexMarker331"/>seen that we can work with Boolean values, numbers, characters, and different composite types, but you might notice that we're missing one type. We have <a id="_idIndexMarker332"/>still not seen a type that can handle text. It is time to look at strings.</p>
			<h3>Strings</h3>
			<p>A string is a composite type as it is stored as an array of characters. Most languages will use double quotes to designate that something is a string and will use single quotes for single characters. Some languages will let you use either single or double quotes for both types. Here, we will use double quotes for strings and single quotes when we only have a single character.</p>
			<p>Usually, we will not consider a string an array. We can create a string as follows:</p>
			<pre>greeting = "Hello there"</pre>
			<p>Here, we created a variable of the string type, called <code>greeting</code>, and assigned a <code>Hello there</code> value to it. Behind the scenes, an array of characters will be created and each character in the string will be assigned to one location in this array, as shown:</p>
			<div><div><img src="img/B15554_06_27.jpg" alt="Figure 6.26 – The Hello there string stored as an array, where each item is a character"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26 – The Hello there string stored as an array, where each item is a character</p>
			<p>As a string is <a id="_idIndexMarker333"/>an array of characters, we can use an <a id="_idIndexMarker334"/>index to access individual characters. As an example, let's print the character at position <code>7</code>, which is the eighth character:</p>
			<pre>print greeting[7]</pre>
			<p>The output will be as follows:</p>
			<pre>h</pre>
			<p>Now that we can handle data in different formats, we can move on to do something with this data. It is time to look at operators.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/>Operators – things we can do with variables</h2>
			<p>In <a href="B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a><em class="italic">, Sequence – The Basic Building Block of a Computer Program</em>, we talked about how a statement is made up of expressions and that expressions can be made up of operations or operands. </p>
			<p>Let's see <a id="_idIndexMarker335"/>an example of this. Here, we will create two variables and assign a value <a id="_idIndexMarker336"/>to each of them. Then, we will add the two values together and store the result in a new variable:</p>
			<pre>number1 = 10
number2 = 15
result = number1 + number2</pre>
			<p>In line one, we created a variable called <code>number1</code> and assigned a value of <code>10</code> to it. We now know that this means several things:</p>
			<ul>
				<li>The variable name is <code>number1</code>.</li>
				<li>As it is assigned an integer, it must be of an <code>integer</code> type. </li>
				<li>The <code>=</code> sign is an operator, taking whatever is on the right and assigning it to what we have on the left.</li>
				<li>Somewhere in the computer's memory, enough space for an integer has been reserved.</li>
				<li>The name, <code>number1</code>, will act as an alias for this address.</li>
			</ul>
			<p>We then do the same thing in line two, the only difference being that we have another name for the variable, <code>number2</code>, and we assign it another value, <code>15</code>.</p>
			<p>On the third line, we use <a id="_idIndexMarker337"/>the addition operator. This operator has two operands—<code>number1</code> and <code>number2</code>. It will now extract the values in these two variables, add them together, and return the result. </p>
			<p>This operation <a id="_idIndexMarker338"/>will result in a value of <code>25</code>, which is what will be assigned to the variable result. As a result of the addition operation giving us another integer, we now also know that the variable result will also have the <code>integer</code> type.</p>
			<p>Let's look at some operators for basic arithmetic.</p>
			<h3>Arithmetic operators</h3>
			<p>Most <a id="_idIndexMarker339"/>programming languages share the symbols used for basic <a id="_idIndexMarker340"/>arithmetic operations. Refer to the following table to see the most common ones:</p>
			<div><div><img src="img/B15554_Table_6.5.jpg" alt="Table 6.5"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.5</p>
			<p>The last one, the modulus operator, might not be familiar to you. It is often used in programming as it has some <a id="_idIndexMarker341"/>features that can be handy when working with numbers. We can illustrate what it does with a simple example. If we calculated <code>16/13</code>, we would get a result of <code>1.230769…</code>. The integer part, <code>1</code>, tells us that <code>13</code> goes once into <code>16</code>. What the modulus operator does is tells <a id="_idIndexMarker342"/>us how much there is left to get to <code>16</code>. So, if <code>13</code> goes once into <code>16</code>, we must add <code>3</code> to <code>13</code> to get to <code>16</code>.</p>
			<p>We would express that with <code>16 % 13</code> and get a result of <code>3</code>. If you have not worked with modulus before, I suggest you search it up online to get an understanding of how it works as it is something that you will find very useful as a programmer.</p>
			<p>Next up, we have some operators that we can use to compare things.</p>
			<h3>Relational operators</h3>
			<p>Relational operators <a id="_idIndexMarker343"/>are used when we want to compare two values. They can <a id="_idIndexMarker344"/>be equal or not equal. We might want to know whether one value is greater than the other. The following table lists the relational operators that are typically found in programming languages:</p>
			<div><div><img src="img/B15554_Table_6.6.jpg" alt="Table 6.6"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.6</p>
			<p>With these <a id="_idIndexMarker345"/>operators, we can compare two values, but sometimes we <a id="_idIndexMarker346"/>have more values to compare. In this case, we will need logical operators.</p>
			<h3>Logical operators</h3>
			<p>These operators <a id="_idIndexMarker347"/>are used to represent <code>and</code>, <code>or</code>, and <code>not</code>. Some languages <a id="_idIndexMarker348"/>will use these exact words to represent them, but others will have special signs for them. They are used in statements such as <code>if the age is greater than 12</code> and <code>age is less than 20</code>. In code, that would look something like this:</p>
			<pre>if age &gt; 12 &amp;&amp; age &lt; 20 then</pre>
			<p>The three operators we can use are as follows:</p>
			<div><div><img src="img/B15554_Table_6.7.jpg" alt="Table 6.7"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.7</p>
			<p>Most languages will have more operators than the ones we have seen here. We will not cover them here as some are combination operators, which is a combination of two of the operators we have seen here, and <a id="_idIndexMarker349"/>others are specialized for one or a few languages.</p>
			<p>Next up, we <a id="_idIndexMarker350"/>will look at two different ways that variables can be stored in memory and why that concerns us. </p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>The concept of values and reference variables</h2>
			<p>There are two <a id="_idIndexMarker351"/>ways that a variable can store its value in memory. We could <a id="_idIndexMarker352"/>think of these ways as direct and indirect. This might sound strange, but let's use an analogy to explain.</p>
			<p>The variables <a id="_idIndexMarker353"/>that directly store their data are like boxes. When we create them, we can think of them as a box that has the name of the variable stuck to it with a label. We can store the value inside the box and look in the box later to see what value is in there. Variables that store their values like this are called <strong class="bold">value variables</strong>:</p>
			<div><div><img src="img/B15554_06_28.jpg" alt="Figure 6.27 – A variable that stores its data by value is like a box"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27 – A variable that stores its data by value is like a box</p>
			<p>Variables that use indirect storage will act as an index card in a library. It will not store the book but will have the <a id="_idIndexMarker354"/>location where it is stored, so it only contains the address to where in memory the actual value is. Variables that store values like this are called <strong class="bold">reference variables</strong>:</p>
			<div><div><img src="img/B15554_06_29.jpg" alt="Figure 6.28 – Variables that store data by reference are like a library index card"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.28 – Variables that store data by reference are like a library index card</p>
			<p>Let's see how they both work.</p>
			<h3>Value variables</h3>
			<p>When we <a id="_idIndexMarker355"/>create a variable—or declare it, as we would usually say—of a type, several things will happen, as we saw at the beginning of this chapter. Let's see what will happen when the following code line is executed:</p>
			<pre>x = 10</pre>
			<p>As we now know, a chunk of memory that is large enough to host an integer is located, and this location has an address. The name we give the variable—<code>x</code>, in the preceding example—is just an alias for this address. It is much easier for us to remember that a variable called <code>firstName</code> stores a name instead of having to remember that the first name was at the <code>38892819283</code> address.</p>
			<p>When our code is interpreted or compiled, the variable name is changed to the actual address, but that is luckily not anything that we will ever see. As this is a variable that stores its data by value, there is a direct relationship between where the data is and the variable name.</p>
			<h3>Reference variables</h3>
			<p>When it comes to reference variables, there is an extra step between the variable name and where the data is. Let's see what happens when we create a reference variable with another code example:</p>
			<p><code>weather = "Sunny"</code></p>
			<p>In this example, the data will still need to be stored somewhere, so a memory location for it is found <a id="_idIndexMarker356"/>and as before, the address of where this is is noted. However, the difference is that the variable name is not an alias for this address. Instead, the address for where the data is is stored at another location in memory and the variable is an alias for that location. The following diagram illustrates this:</p>
			<div><div><img src="img/B15554_06_30.jpg" alt="Figure 6.29 – A variable named weather as a reference variable"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.29 – A variable named weather as a reference variable</p>
			<p>This might seem pointless. Why can't we store the text string at the location pointed out by the <code>weather</code> variable? What is the point of this extra step? The answer is efficiency. In a program, we need to pass data around. The data that we have in a variable in one part of the program needs to be passed along to another part. Imagine that the data stored is much larger than the short text string in the preceding example; the actual passing of the data would mean that we need to make a copy of all the data. This takes some time, and we will now have two copies of the data, which will use twice as much memory. If a variable is of this reference type, we will not need to copy all the data. In the preceding example, this will mean that we will not need to copy <code>Sunny</code>. Instead, the <code>weather</code> variable contains the address to where this data is, so it can just pass the address. </p>
			<p>How a language uses these two types will differ from language to language. When learning a new language, it is vital to learn how it works with value and reference variables. </p>
			<p>Now that we have covered lots of things related to variables, we are now ready to use them. We will now see how we can work with numbers, and after that, we will look at text strings.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Working with numbers</h2>
			<p>Numbers are essential in computer programs. We use them to represent real-world concepts, such as the number <a id="_idIndexMarker357"/>of items in a shopping cart, the weight of a package, and the distance to a location. We also use them to <a id="_idIndexMarker358"/>represent internal things within our program, such as the number of characters in a name so that we can calculate whether it will fit on an address label if we print it. The point is, we use numbers all the time, so let's see what we can do with them.</p>
			<p>First, we can do basic arithmetic, such as addition, subtraction, multiplication, and division, as in the following code snippet:</p>
			<pre>age1 = 34
age2 = 67
mediumAge = (age1 + age2) / 2</pre>
			<p>In this example, we have two ages and we are calculating the medium age. </p>
			<p>We often use numbers as counters of things. What this means is that we will use them to keep track of how many times we have done something. This means that we need to increase (and sometimes decrease) them by 1. We could do this as follows:</p>
			<pre>count = count + 1</pre>
			<p>To understand what happens here, we need to look to the right of the <code>=</code> sign first. Here, we have a variable called <code>count</code>. As this is just a line that is ripped out of its context, we can assume that it already has a value stored. This value is now used, and we add <code>1</code> to it. The result of this addition is then stored back in the variable count, and we have increased its value by 1.</p>
			<p>As this is such a common thing to do in programming, some shorthands for this have been developed. As we are using the same variable on both sides of the <code>=</code> operator, we can skip one of them and instead use a different operator that looks something like this:</p>
			<pre>count += 1</pre>
			<p>This is the same as in the last example, but just shorter. We can read it as taking the value that is stored by the <code>count</code> variable, adding <code>1</code> to it, and storing the result back in <code>count</code>.</p>
			<p>Some languages have taken this further and shortened this even more:</p>
			<pre>count++</pre>
			<p>Again, the result will be the same as the other two. We can read this as increasing the value stored in <code>count</code> by <code>1</code>.</p>
			<p>All of the three examples we just saw can, of course, be done with subtraction too, as shown:</p>
			<pre>count = count - 1
count -= 1
count--</pre>
			<p>When working <a id="_idIndexMarker359"/>with numbers, they can either be stored in a variable, as with <code>count</code>, or digits directly in the code, as is the case with <code>1</code> in the <a id="_idIndexMarker360"/>preceding examples.</p>
			<p>Sometimes, we will work with more complex mathematical formulas and do several things in one single line.</p>
			<p>We could have something like the following:</p>
			<p><img src="img/Formula_06_002.png" alt=""/></p>
			<p>How would we write that in a program?</p>
			<p>First, <code>x</code>, <code>a</code>, and <code>b</code> are variables in mathematics and will be variables in our program, too. <code>a + 3</code> and <code>7 – b</code> must be done before we can divide. We use an equation such as this as a recipe to calculate something. To use it, we insert some values for <code>a</code> and <code>b</code>. Then, we do the math, and <code>x</code> will be the result.</p>
			<p>In our program, we can, therefore, assume that <code>a</code> and <code>b</code> have some values given to them earlier in the program. So, let's see how we can let the computer do the math for us:</p>
			<pre>x = (a + 3) / (7 – b)</pre>
			<p>Adding parentheses means that what is inside of them will be calculated first. So, if we imagine some values for <code>a</code> and <code>b</code>—let's say <code>a = 3</code> and <code>b = 4</code>—then <code>a + 3</code> will be calculated first, so we have <code>3 + 3 = 6</code>. Then, <code>7 – b</code> will be calculated, so <code>7 – 4 = 3</code>. At this point, we can imagine that <code>a + 3</code> is replaced by <code>6</code> and <code>7 – b</code> by <code>3</code>; we are left with <code>6 / 3</code>. The result, <code>2</code>, will be stored in <code>x</code>.</p>
			<p>If basic <a id="_idIndexMarker361"/>algebra is not enough for us, most programming <a id="_idIndexMarker362"/>languages come with a vast library of mathematical functions that we can use, such as cosine, tangent, square root, and absolute value.</p>
			<p>Another data type that programmers use a lot is strings. Let's look at some of the things we can do with them.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor101"/>Manipulating strings</h2>
			<p>A string is a sequence of characters, and a character does not have to be a letter, it can be punctuation marks, a space, a hyphen, or any other character we can produce using a computer. A string can also contain digits. </p>
			<p>The first thing <a id="_idIndexMarker363"/>we must understand is that a string only containing digits will not be the same as if it were an integer. Look at the following code:</p>
			<pre>numberA = 1234
numberB = "1234"</pre>
			<p>Notice the <a id="_idIndexMarker364"/>quotation marks around the digits in the last number. This turns it into a string. The first one, <code>numberA</code>, will be of the <code>integer</code> type, so it can be used for counting and other mathematical operations. For the computer, the second one is just as much a number as the word <code>dog</code> is—that is, not at all. </p>
			<p>When working with strings, there are several typical things we can do with them. Let's look at some frequent string operations.</p>
			<h3>String concatenation</h3>
			<p>When we <a id="_idIndexMarker365"/>take two strings and add them together to form a new string, we call it concatenation. How this is done will differ a bit from language to language, but often, we can use the <code>+</code> operator, as in the following example:</p>
			<pre>word = "day" + "break"</pre>
			<p>Here, we have two strings—<code>day</code> and <code>break</code>. The quote marks tell us that they are strings. They will <a id="_idIndexMarker366"/>now be concatenated into a new string that is stored in the <code>word</code> variable. This variable will contain the <code>daybreak</code> word.</p>
			<h3>Splitting strings</h3>
			<p>Sometimes, we want <a id="_idIndexMarker367"/>to split a string into multiple strings. To do this, we will often use a delimiter inside the string, which we can use to indicate where the string should be divided. Let's assume that we have a string that contains a first name and last name and that the names are separated by a comma, such as <code>Sue,Smith</code>.</p>
			<p>If that is stored in a variable called <code>name</code>, in some languages, we could do something like this:</p>
			<pre>firstName, lastName = name.split(",")</pre>
			<p>As usual, we will begin by looking at the right side of the <code>=</code> operator. Here, we say that we have a string in a variable called <code>name</code>. We want to break up this string into two parts, so we use <code>split</code>. Inside the parentheses, we see a string. Again, we know that it is a string because it has quote marks and contains a comma. This is the character that will be used for the split. All characters that precede the comma inside the variable name will be sent to the first variable to the left, <code>firstName</code>. Everything after the comma will be sent to the second variable, <code>lastName</code>. The comma itself that is inside the variable name will be discarded. </p>
			<p>It is also important to note that the content of the variable name has not changed, so if we peek into the variables after this line has executed, we can see that they contain the following:</p>
			<pre>firstName = Sue
lastName = Smith
name = Sue,Smith</pre>
			<p>The result can also be an array that contains the two strings. This would look something like the following:</p>
			<pre>splitName = name.split(",")</pre>
			<p>The <code>splitName</code> variable will now be an array that contains two strings. Remember that the first position in an array is <code>0</code>, and in that location, we will find the <code>Sue</code> string, and at position <code>1</code>, we will find <code>Smith</code>.</p>
			<h3>Substrings</h3>
			<p>Substrings are <a id="_idIndexMarker368"/>used when we take part of a string to form a new string. How this is done will change from language to language. Here are some examples of what it might look like if we want to extract the <code>car</code> substring out of the <code>phonocardiogram</code> string.</p>
			<p>First, we store <code>phonocardiogram</code> in a variable, as follows:</p>
			<pre>word = "phonocardiogram"</pre>
			<p>In some languages, we can then do something like this:</p>
			<pre>newWord = word[5:8]</pre>
			<p>This will begin extracting the substring from location <code>5</code> in the string. Just as with arrays, the counting will start at <code>0</code>. As the letter <code>c</code> is the sixth letter, the index we use will be <code>5</code>. Then, as per the code given, we end at <code>8</code>. But that looks like we went one letter too far. Commonly, we use two values as the start and end index. The first will state where to start and the second will point out the first things that are outside the range. We can read the preceding example as starting at location <code>5</code> and stopping at location <code>8</code> without including it. </p>
			<p>After this line has executed, the <code>newWord</code> variable will contain the <code>car</code> string, and as before, the <code>word</code> variable will be unchanged.</p>
			<p>Other languages will do something like the following instead:</p>
			<pre>newWord = word.substr(5,8)</pre>
			<p>Here, we use <code>substr</code> instead of square brackets. Also, note that <code>5</code> and <code>8</code> are separated by a comma here and that we used a semicolon in the first example.</p>
			<p>A third variant would look something like this:</p>
			<pre>newWord = word.substr(5, 3)</pre>
			<p>In languages that use this form, the second value indicates how many characters we want instead of the end index. However, the result will be the same.</p>
			<h4>Case conversion</h4>
			<p>Converting string casing is something we often want to do. The reason for this can, for example, be so that we <a id="_idIndexMarker369"/>can ask the user of our program to enter a text command, and then we will need to check what command the user entered. As an example, we can imagine that they entered the following commands:</p>
			<ul>
				<li><code>Start</code></li>
				<li><code>Pause</code></li>
				<li><code>Stop</code></li>
			</ul>
			<p>We will need to compare what the user wrote against these strings, but we have a problem. When we compare strings, they need to be cased the same to be equal. This means that <code>start</code>, <code>Start</code>, and <code>START</code> will all be different. </p>
			<p>We can't compare all the combinations as they would be rather too many. For just the <code>start</code> word, we have the following variants:</p>
			<ul>
				<li><code>start</code></li>
				<li><code>Start</code></li>
				<li><code>STart</code></li>
				<li><code>StArt</code></li>
				<li><code>STArt</code></li>
				<li><code>SRArT</code></li>
				<li><code>sTART</code></li>
				<li><code>starT</code></li>
			</ul>
			<p>We could go on, but instead, let's just convert a string into either all uppercase or all lowercase. Then, we will know what form the string has.</p>
			<p>We can do this as follows:</p>
			<pre>answer = answer.lower()</pre>
			<p>Alternatively, the string can be converted as follows:</p>
			<pre>answer = answer.upper()</pre>
			<p><code>lower</code> and <code>upper</code> will not change the original string that is inside the variable answer, but instead will create a new <a id="_idIndexMarker370"/>lowercase or uppercase version of this string. We will store this new version back into the variable, and by doing so, we will overwrite the old string with the new version where we know how it is cased.</p>
			<p>We have seen a few examples of things we can do with strings. This not all we can do, but consider these as some examples of some frequent operations that we can perform on strings.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Summary</h1>
			<p>In this chapter, we covered one of the two main pillars that programming rests on—how we can store, retrieve, and change data in the computer's memory using variables.</p>
			<p>We learned that a variable has a name and a data type and that the type of the variable dictates what can be stored in it and how much memory it will use. We also learned how we could concisely name our variables and that there are naming conventions that we can use for guidance.</p>
			<p>With that covered, we then talked about primary or primitive data types and saw that numbers are handled either as integers or floating-point numbers, which are further divided into different sizes, so we can pick a type that suits our needs and make sure we don't waste memory space.</p>
			<p>Some data naturally comes in a sequence or in natural groups. For this data, we used a composite data type, and we saw that this type lets us work with groups of data.</p>
			<p>We then talked about what operators are and how we can perform operations on variables using them, as well as what common operators are and some examples of how to use them.</p>
			<p>A variable can be stored in memory either as a value or reference type. We learned that when it is stored as a value, the data it stores is located at the memory address of the variable. A reference variable does not save its value directly but stores an address to where the data can be found.</p>
			<p>We used variables with numbers and performed some basic operations on them using our operators. In the end, we turned our attention to strings and looked at how we can manipulate them.</p>
			<p>In the next chapter, we will introduce logic to our programs with proper selection so that we can do things only if a condition is met. We will also see how we can repeat the same thing several times with the help of loops.</p>
		</div>
	</body></html>