<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Detecting Edges and Contours in Images</h1>
                </header>
            
            <article>
                
<p>This chapter presents the following recipes:</p>
<ul>
<li>Loading, displaying, and saving images</li>
<li>Image flipping and scaling</li>
<li>Erosion and dilation</li>
<li>Image segmentation</li>
<li>Blurring and sharpening images</li>
<li>Detecting edges in images</li>
<li>Histogram equalization</li>
<li>Detecting corners in images</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Image processing plays a vital role in almost all engineering and medical applications to extract and evaluate the region of interest from gray/color images. Image processing methods include pre-processing, feature extraction, and classification. Pre-processing is used to enhance the quality of the image; this includes adaptive thresholding, contrast enhancement, histogram equalization, and edge detection. Feature extraction techniques are used to extract prominent features from images that can later be used for classification.</p>
<p>The procedures to build an image pre-processing scheme are presented in the recipes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Loading, displaying, and saving images</h1>
                </header>
            
            <article>
                
<p>This section presents how to work on images by means of OpenCV-Python. Furthermore, we discuss how to load, display, and save images.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Import the Computer Vision package - <kbd>cv2</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import cv2 </pre>
<ol start="2">
<li>Read the image using the built-in <kbd>imread</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">image = cv2.imread('image_1.jpg')</pre>
<ol start="3">
<li>Display the original image using the built-in <kbd>imshow</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow("Original", image) </pre>
<ol start="4">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0) </pre>
<ol start="5">
<li>Save the image using the built-in <kbd>imwrite</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">cv2.imwrite("Saved Image.jpg", image) </pre>
<ol start="6">
<li>The command used to execute the Python program <kbd>Load_Display_Save.py</kbd> is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/3d39218f-0be9-4432-b023-3d2a975fe4d0.png" style="width:47.92em;height:2.08em;" width="575" height="25"/></div>
<ol start="7">
<li>The result obtained after executing <kbd>Load_Display_Save.py</kbd> is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/df40378a-72f0-4b23-af7b-c03bd6a03384.png" width="600" height="407"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Image flipping</h1>
                </header>
            
            <article>
                
<p>In the image flipping operation, we can flip the input images horizontally, vertically, horizontal, and vertically.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Import the Computer Vision package - <kbd>cv2</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import cv2 </pre>
<ol start="2">
<li>Read the image using the built-in <kbd>imread</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">image = cv2.imread('image_2.jpg')</pre>
<ol start="3">
<li>Display the original image using the built-in <kbd>imshow</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow("Original", image) </pre>
<ol start="4">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0) </pre>
<ol start="5">
<li>Perform the required operation on the test image:</li>
</ol>
<pre style="padding-left: 60px"># cv2.flip is used to flip images 
# Horizontal flipping of images using value '1' 
flipping = cv2.flip(image, 1) </pre>
<ol start="6">
<li>Display the horizontally flipped image:</li>
</ol>
<pre style="padding-left: 60px"># Display horizontally flipped image 
cv2.imshow("Horizontal Flipping", flipping) </pre>
<ol start="7">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0) </pre>
<ol start="8">
<li>Perform vertical flipping of input image:</li>
</ol>
<pre style="padding-left: 60px"># Vertical flipping of images using value '0' 
flipping = cv2.flip(image, 0) </pre>
<ol start="9">
<li>Display the vertically flipped image:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow("Vertical Flipping", flipping) </pre>
<ol start="10">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0) </pre>
<ol start="11">
<li>Display the processed image:</li>
</ol>
<pre style="padding-left: 60px"># Horizontal &amp; Vertical flipping of images using value '-1' 
flipping = cv2.flip(image, -1) 
# Display horizontally &amp; vertically flipped image 
cv2.imshow("Horizontal &amp; Vertical Flipping", flipping) 
# Wait until any key is pressed 
cv2.waitKey(0)</pre>
<ol start="12">
<li>Stop the execution and display the result:</li>
</ol>
<pre style="padding-left: 60px"># Close all windows 
cv2.destroyAllWindows() </pre>
<ol start="13">
<li>The command used to execute the <kbd>Flipping.py</kbd>Â Python program is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/48322718-29c2-48f6-9cb5-669d2902257e.png" style="width:39.08em;height:1.92em;" width="571" height="28"/></div>
<ol start="14">
<li>The original and horizontally flipped images obtained after executing <kbd>Flipping.py</kbd> are shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/4862ac76-a1a0-4494-a16c-7fc30c0408c3.png" style="width:36.08em;height:36.58em;" width="555" height="562"/>
<p style="padding-left: 60px">Following is the horizontally flipped picture:</p>
</div>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/2ee92b0e-5304-42ff-9542-8ddb36d277eb.png" style="width:40.83em;height:41.33em;" width="555" height="562"/></div>
<ol start="15">
<li>Vertically, and horizontally and vertically, flipped images obtained after executing <kbd>Flipping.py</kbd> are shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/108023cf-2613-49af-96da-c6805dfcaef4.png" style="width:38.33em;height:38.83em;" width="555" height="562"/>
<p style="padding-left: 60px">Following horizontally and vertically flipped picture:</p>
</div>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/d9fe5bd4-a7de-40c1-a561-3fca02cc5da3.png" style="width:39.50em;height:40.08em;" width="555" height="562"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Image scaling</h1>
                </header>
            
            <article>
                
<p>Image scaling is used to modify the dimensions of the input image based on requirements. Three types of scaling operators are commonly used in OpenCV, and they are cubic, area, and linear interpolations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new Python file and import the following packages:</li>
</ol>
<pre style="padding-left: 60px"># Scaling (Resizing) Images - Cubic, Area, Linear Interpolations 
# Interpolation is a method of estimating values between known data points  
# Import Computer Vision package - cv2 
import cv2 
# Import Numerical Python package - numpy as np 
import numpy as np </pre>
<ol start="2">
<li>Read the image using the built-in <kbd>imread</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">image = cv2.imread('image_3.jpg') </pre>
<ol start="3">
<li>Display the original image using the built-in <kbd>imshow</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow("Original", image) </pre>
<ol start="4">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey() </pre>
<ol start="5">
<li>Adjust the image size based on the operator's command:</li>
</ol>
<pre style="padding-left: 60px"># cv2.resize(image, output image size, x scale, y scale, interpolation) </pre>
<ol start="6">
<li>Adjust the image size using cubic interpolation:</li>
</ol>
<pre style="padding-left: 60px"># Scaling using cubic interpolation 
scaling_cubic = cv2.resize(image, None, fx=.75, fy=.75, interpolation = cv2.INTER_CUBIC) </pre>
<ol start="7">
<li>Show the output image:</li>
</ol>
<pre style="padding-left: 60px"># Display cubic interpolated image 
cv2.imshow('Cubic Interpolated', scaling_cubic) </pre>
<ol start="8">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey()</pre>
<ol start="9">
<li>Adjust the image size using area interpolation:</li>
</ol>
<pre style="padding-left: 60px"># Scaling using area interpolation 
scaling_skewed = cv2.resize(image, (600, 300), interpolation = cv2.INTER_AREA) </pre>
<ol start="10">
<li>Show the output image:</li>
</ol>
<pre style="padding-left: 60px"># Display area interpolated image 
cv2.imshow('Area Interpolated', scaling_skewed)  </pre>
<ol start="11">
<li>Wait for the instruction from the operator:</li>
</ol>
<pre style="padding-left: 60px"># Wait until any key is pressed 
cv2.waitKey() </pre>
<ol start="12">
<li>Adjust the image size using linear interpolation:</li>
</ol>
<pre style="padding-left: 60px"># Scaling using linear interpolation 
scaling_linear  = cv2.resize(image, None, fx=0.5, fy=0.5, interpolation = cv2.INTER_LINEAR) </pre>
<ol start="13">
<li>Show the output image:</li>
</ol>
<pre style="padding-left: 60px"># Display linear interpolated image 
cv2.imshow('Linear Interpolated', scaling_linear)  </pre>
<ol start="14">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey() </pre>
<ol start="15">
<li>After completing the image scaling task, terminate the program execution:</li>
</ol>
<pre style="padding-left: 60px"># Close all windows 
cv2.destroyAllWindows() </pre>
<ol start="16">
<li>The command used to execute the <kbd>Scaling.py</kbd> <span>Python programÂ </span>is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-667 image-border" src="Images/dc0b3c29-c336-407d-a64e-a19574405b9e.png" style="width:32.92em;height:2.08em;" width="395" height="25"/><br/></div>
<ol start="17">
<li>The original image used for scaling is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/4f131cc0-07d0-4fb3-8da0-529dfe0142c0.png" style="width:30.42em;height:28.08em;" width="370" height="342"/></div>
<ol start="18">
<li>Linear interpolated output obtained after executing theÂ <kbd>Scaling.py</kbd>Â file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/47ad007d-24fe-4cd6-aa43-2aa2b8cdef42.png" width="370" height="205"/></div>
<ol start="19">
<li>The area-interpolated output obtained after executing theÂ <kbd>Scaling.py</kbd>Â file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/2e2e48f4-2cf3-4dae-8e73-a20ee6bd4cbf.png" width="600" height="369"/></div>
<ol start="20">
<li>The cubic-interpolated output obtained after executing theÂ <kbd>Scaling.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/8d280736-230d-4845-ab6d-b355b72458f6.png" width="370" height="274"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Erosion and dilation</h1>
                </header>
            
            <article>
                
<p>Erosion and dilation are morphological operations. Erosion removes pixels at the boundaries of objects in an image and dilation adds pixels to the boundaries of objects in an image.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Import the Computer Vision package â <kbd>cv2</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import cv2 </pre>
<ol start="2">
<li>Import the numerical Python package â <kbd>numpy as np</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import numpy as np </pre>
<ol start="3">
<li>Read the image using the built-in <kbd>imread</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">image = cv2.imread('image_4.jpg')</pre>
<ol start="4">
<li>Display the original image using the built-in <kbd>imshow</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow("Original", image) </pre>
<ol start="5">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0) </pre>
<ol start="6">
<li>Given shape and type, fill it with ones:</li>
</ol>
<pre style="padding-left: 60px"># np.ones(shape, dtype) 
# 5 x 5 is the dimension of the kernel, uint8: is an unsigned integer (0 to 255) 
kernel = np.ones((5,5), dtype = "uint8") </pre>
<ol start="7">
<li><kbd>cv2.erode</kbd> is the built-in function used for erosion:</li>
</ol>
<pre style="padding-left: 60px"># cv2.erode(image, kernel, iterations) 
erosion = cv2.erode(image, kernel, iterations = 1) </pre>
<ol start="8">
<li>Display the image after erosion using the built-in <kbd>imshow</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow("Erosion", erosion) </pre>
<ol start="9">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0) </pre>
<ol start="10">
<li><kbd>cv2.dilate</kbd> is the built-in function used for dilation:</li>
</ol>
<pre style="padding-left: 60px"># cv2.dilate(image, kernel, iterations) 
dilation = cv2.dilate(image, kernel, iterations = 1) </pre>
<ol start="11">
<li>Display the image after dilation using the built-in <kbd>imshow</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow("Dilation", dilation) </pre>
<ol start="12">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0) </pre>
<ol start="13">
<li>Close all windows:</li>
</ol>
<pre style="padding-left: 60px">cv2.destroyAllWindows()</pre>
<ol start="14">
<li>The command used to execute theÂ <kbd>Erosion_Dilation.py</kbd>Â file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-668 image-border" src="Images/d3cdbe8d-73a7-429c-8b79-0e4d5c346e60.png" style="width:42.25em;height:1.58em;" width="507" height="19"/></div>
<ol start="15">
<li>The input image used to execute theÂ <kbd>Erosion_Dilation.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/37197915-ef15-4ca8-9b11-7c349c02f6cf.png" style="width:51.67em;height:44.33em;" width="640" height="549"/></div>
<ol start="16">
<li>The eroded image obtained after executing theÂ <kbd>Erosion_Dilation.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/d05d9b14-1081-412a-9586-98ebcb87189f.png" style="width:50.50em;height:43.33em;" width="640" height="549"/></div>
<ol start="17">
<li>The dilated image obtained after executing theÂ <kbd>Erosion_Dilation.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/f2633fde-b795-4165-8041-41281564fa02.png" style="width:48.42em;height:41.50em;" width="640" height="549"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Image segmentation</h1>
                </header>
            
            <article>
                
<p>Segmentation is a process of partitioning images into different regions. Contours are lines or curves around the boundary of an object. Image segmentation using contours is discussed in this section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Import the Computer Vision package - <kbd>cv2</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import cv2 
# Import Numerical Python package - numpy as np 
import numpy as np </pre>
<ol start="2">
<li>Read the image using the built-in <kbd>imread</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">image = cv2.imread('image_5.jpg') </pre>
<ol start="3">
<li>Display the original image using the built-in <kbd>imshow</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow("Original", image) </pre>
<ol start="4">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0) </pre>
<ol start="5">
<li>Execute the <kbd>Canny</kbd> edge detection system:</li>
</ol>
<pre style="padding-left: 60px"># cv2.Canny is the built-in function used to detect edges 
# cv2.Canny(image, threshold_1, threshold_2) 
canny = cv2.Canny(image, 50, 200) </pre>
<ol start="6">
<li>Display the edge detected output image using the built-in <kbd>imshow</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow("Canny Edge Detection", canny) </pre>
<ol start="7">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0)</pre>
<ol start="8">
<li>Execute the contour detection system:</li>
</ol>
<pre style="padding-left: 60px"># cv2.findContours is the built-in function to find contours 
# cv2.findContours(canny, contour retrieval mode, contour approximation mode) 
# contour retrieval mode: cv2.RETR_LIST (retrieves all contours)  
# contour approximation mode: cv2.CHAIN_APPROX_NONE (stores all boundary points) 
contours, hierarchy = cv2.findContours(canny, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) </pre>
<ol start="9">
<li>Sketch the contour on the image:</li>
</ol>
<pre style="padding-left: 60px"># cv2.drawContours is the built-in function to draw contours 
# cv2.drawContours(image, contours, index of contours, color, thickness) 
cv2.drawContours(image, contours, -1, (255,0,0), 10) 
# index of contours = -1 will draw all the contours </pre>
<ol start="10">
<li>Show the sketched contour of the image:</li>
</ol>
<pre style="padding-left: 60px"># Display contours using imshow built-in function 
cv2.imshow("Contours", image) </pre>
<ol start="11">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey() </pre>
<ol start="12">
<li>Terminate the program and display the result:</li>
</ol>
<pre style="padding-left: 60px"># Close all windows 
cv2.destroyAllWindows() </pre>
<p>Â </p>
<ol start="13">
<li>The result obtained after executing theÂ <kbd>Image_Segmentation.py</kbd>Â file is shown here:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/5e6ca6b7-08fd-4788-93ae-6efc83f74f29.png" style="width:47.92em;height:41.08em;" width="640" height="549"/>
<p style="padding-left: 60px">Following is theÂ edge detection output:</p>
</div>
<div class="CDPAlignCenter CDPAlign"><img src="Images/ad5d8a16-5971-45fc-84a4-77cf67a04e67.png" style="width:48.17em;height:41.25em;" width="640" height="549"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Blurring and sharpening images</h1>
                </header>
            
            <article>
                
<p>Blurring and sharpening are image processing operations used to enhance the input images.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Import the Computer Vision package - <kbd>cv2</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import cv2 
# Import Numerical Python package - numpy as np 
import numpy as np </pre>
<ol start="2">
<li>Read the image using the built-in <kbd>imread</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">image = cv2.imread('image_6.jpg') </pre>
<ol start="3">
<li>Display the original image using the built-in <kbd>imshow</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow("Original", image) </pre>
<ol start="4">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0) </pre>
<ol start="5">
<li>Execute the pixel level action with the blurring operation:</li>
</ol>
<pre style="padding-left: 60px"># Blurring images: Averaging, cv2.blur built-in function 
# Averaging: Convolving image with normalized box filter 
# Convolution: Mathematical operation on 2 functions which produces third function. 
# Normalized box filter having size 3 x 3 would be: 
# (1/9)  [[1, 1, 1], 
#         [1, 1, 1], 
#         [1, 1, 1]] 
blur = cv2.blur(image,(9,9)) # (9 x 9) filter is used  </pre>
<ol start="6">
<li>Display the blurred image:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow('Blurred', blur) </pre>
<ol start="7">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0)</pre>
<ol start="8">
<li>Execute the pixel level action with the sharpening operation:</li>
</ol>
<pre style="padding-left: 60px"># Sharpening images: Emphasizes edges in an image 
kernel = np.array([[-1,-1,-1],  
                   [-1,9,-1],  
                   [-1,-1,-1]]) 
# If we don't normalize to 1, image would be brighter or darker respectively     
# cv2.filter2D is the built-in function used for sharpening images 
# cv2.filter2D(image, ddepth, kernel) 
# ddepth = -1, sharpened images will have same depth as original image 
sharpened = cv2.filter2D(image, -1, kernel) </pre>
<ol start="9">
<li>Display the sharpened image:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow('Sharpened', sharpened) </pre>
<ol start="10">
<li>Wait until any key is pressed:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey(0) </pre>
<ol start="11">
<li>Terminate the program execution:</li>
</ol>
<pre style="padding-left: 60px"># Close all windows 
cv2.destroyAllWindows() </pre>
<ol start="12">
<li>The command used to execute the <kbd>Blurring_Sharpening.py</kbd>Â Python program file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-669 image-border" src="Images/502c4776-5ed8-41e0-b2bb-5d56f181712d.png" style="width:45.67em;height:2.42em;" width="548" height="29"/></div>
<ol start="13">
<li>The input image used to execute theÂ <kbd>Blurring_Sharpening.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/0057cfaf-3a06-40f3-b58d-dabbe5e5ee1c.png" width="640" height="549"/></div>
<ol start="14">
<li>The blurred image obtained after executing theÂ <kbd>Blurring_Sharpening.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/4c91b06a-f9f4-4cae-99ab-924e43508ce4.png" width="640" height="549"/></div>
<ol start="15">
<li>The sharpened image obtained after executing theÂ <kbd>Blurring_Sharpening.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/e909cf91-2856-453f-857c-3a2843c15f84.png" width="527" height="453"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Detecting edges in images</h1>
                </header>
            
            <article>
                
<p>Edge detection is used to detect the borders in images. It provides the details regarding the shape and the region properties. This includes perimeter, major axis size, and minor axis size.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Import the necessary packages:</li>
</ol>
<pre style="padding-left: 60px">import sys 
import cv2 
import numpy as np </pre>
<ol start="2">
<li>Read the input image:</li>
</ol>
<pre style="padding-left: 60px">in_file = sys.argv[1] 
image = cv2.imread(in_file, cv2.IMREAD_GRAYSCALE) </pre>
<ol start="3">
<li>Implement the Sobel edge detection scheme:</li>
</ol>
<pre style="padding-left: 60px">horizontal_sobel = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=5) 
vertical_sobel = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=5) 
laplacian_img = cv2.Laplacian(image, cv2.CV_64F) 
canny_img = cv2.Canny(image, 30, 200) </pre>
<ol start="4">
<li>Display the input image and its corresponding output:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow('Original', image) 
cv2.imshow('horizontal Sobel', horizontal_sobel) 
cv2.imshow('vertical Sobel', vertical_sobel) 
cv2.imshow('Laplacian image', laplacian_img) 
cv2.imshow('Canny image', canny_img) </pre>
<ol start="5">
<li>Wait for the instruction from the operator:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey() </pre>
<ol start="6">
<li>Display the input image and the corresponding results:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow('Original', image) 
cv2.imshow('horizontal Sobel', horizontal_sobel) 
cv2.imshow('vertical Sobel', vertical_sobel) 
cv2.imshow('Laplacian image', laplacian_img) 
cv2.imshow('Canny image', canny_img) </pre>
<ol start="7">
<li>Wait for the instruction from the operator:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey()</pre>
<ol start="8">
<li>The command used to execute the <kbd>Detecting_edges.py</kbd> <span>Python programÂ </span>file, along with the input image (<kbd>baby.jpg</kbd>), is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/51f4bf73-3806-4ab2-941c-b66e386bc7e4.png" width="574" height="48"/></div>
<ol start="9">
<li>The input image and the horizontal Sobel filter output obtained after executing theÂ <kbd>Detecting_edges.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/0feb0bf8-e971-4bf6-8277-81630cbe5b63.png" style="width:28.08em;height:24.83em;" width="447" height="395"/></div>
<ol start="10">
<li>The vertical Sobel filter output and the Laplacian image output obtained after executing theÂ <kbd>Detecting_edges.py</kbd>Â file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/26872f8b-b8c8-4235-826a-1e18377b0eca.png" style="width:24.17em;height:19.08em;" width="447" height="354"/></div>
<p style="padding-left: 60px" class="packt_figure CDPAlignLeft CDPAlign">FollowingÂ  is the Laplacian image output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/e8a14347-762c-4c1b-a7db-9808cdc7a22e.png" style="width:24.92em;height:22.08em;" width="447" height="395"/><br/></div>
<ol start="11">
<li>The <kbd>Canny</kbd> edge detection output obtained after executing theÂ <kbd>Detecting_edges.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/69f29259-5618-423a-bfbb-c4f828847685.png" style="width:28.17em;height:24.92em;" width="447" height="395"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Readers can refer to the following document to learn what edge detection is and its impact on test pictures:</p>
<p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.301.927" target="_blank">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.301.927</a></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Please refer to the following document:</p>
<ul>
<li><a href="https://www.tutorialspoint.com/dip/concept_of_edge_detection.htm">https://www.tutorialspoint.com/dip/concept_of_edge_detection.htm</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Histogram equalization</h1>
                </header>
            
            <article>
                
<p>Histogram equalization is used to enhance the visibility and the contrast of images. It is performed by varying the image intensities. These procedures are clearly described here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do itâ¦</h1>
                </header>
            
            <article>
                
<ol>
<li>Import the necessary packages:</li>
</ol>
<pre style="padding-left: 60px">import sys 
import cv2 
import numpy as np </pre>
<ol start="2">
<li>Load the input image:</li>
</ol>
<pre style="padding-left: 60px">in_file = sys.argv[1] 
image = cv2.imread(in_file) </pre>
<ol start="3">
<li>Convert the RGB image into grayscale:</li>
</ol>
<pre style="padding-left: 60px">image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) 
cv2.imshow('Input grayscale image', image_gray) </pre>
<ol start="4">
<li>Regulate the histogram of the grayscale image:</li>
</ol>
<pre style="padding-left: 60px">image_gray_histoeq = cv2.equalizeHist(image_gray) 
cv2.imshow('Histogram equalized - grayscale image', image_gray_histoeq) </pre>
<ol start="5">
<li>Regulate the histogram of the RGB image:</li>
</ol>
<pre style="padding-left: 60px">image_yuv = cv2.cvtColor(image, cv2.COLOR_BGR2YUV) 
image_yuv[:,:,0] = cv2.equalizeHist(image_yuv[:,:,0]) 
image_histoeq = cv2.cvtColor(image_yuv, cv2.COLOR_YUV2BGR) </pre>
<ol start="6">
<li>Display the output image:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow('Input image', image) 
cv2.imshow('Histogram equalized - color image', image_histoeq) 
cv2.waitKey()</pre>
<ol start="7">
<li>The command used to execute the <kbd>histogram.py</kbd> <span>Python programÂ </span>file, along with the input image (<kbd>finger.jpg</kbd>), is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-670 image-border" src="Images/d4fe5eae-c6e9-440c-8d80-739612a8969f.png" style="width:37.42em;height:2.00em;" width="629" height="33"/></div>
<ol start="8">
<li>The input image used to execute theÂ <kbd>histogram.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/19597408-7b95-4c97-a461-e5929f4b0276.png" width="655" height="519"/></div>
<ol start="9">
<li>The histogram equalized grayscale image obtained after executing theÂ <kbd>histogram.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/4f307056-ee49-42aa-bb41-958b39fa4951.png" width="693" height="515"/></div>
<ol start="10">
<li>The histogram equalized color image obtained after executing theÂ <kbd>histogram.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/502b425e-d6e2-407a-87e2-597b2a5d80e5.png" width="960" height="744"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Detecting corners in images</h1>
                </header>
            
            <article>
                
<p>Corners are borders in images used to extract special features that infer the content of an image. Corner detection is frequently used in image registration, video tracking, image mosaics, motion detection, 3D modelling, panorama stitching, and object recognition.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Import the necessary packages:</li>
</ol>
<pre style="padding-left: 60px">import sys 
import cv2 
import numpy as np </pre>
<ol start="2">
<li>Load the input image:</li>
</ol>
<pre style="padding-left: 60px">in_file = sys.argv[1] 
image = cv2.imread(in_file) 
cv2.imshow('Input image', image) 
image_gray1 = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) 
image_gray2 = np.float32(image_gray1) </pre>
<ol start="3">
<li>Implement the Harris corner detection scheme:</li>
</ol>
<pre style="padding-left: 60px">image_harris1 = cv2.cornerHarris(image_gray2, 7, 5, 0.04) </pre>
<ol start="4">
<li>Dilate the input image and construct the corners:</li>
</ol>
<pre style="padding-left: 60px">image_harris2 = cv2.dilate(image_harris1, None) </pre>
<ol start="5">
<li>Implement image thresholding:</li>
</ol>
<pre style="padding-left: 60px">image[image_harris2 &gt; 0.01 * image_harris2.max()] = [0, 0, 0] </pre>
<ol start="6">
<li>Display the input image:</li>
</ol>
<pre style="padding-left: 60px">cv2.imshow('Harris Corners', image) </pre>
<ol start="7">
<li>Wait for the instruction from the operator:</li>
</ol>
<pre style="padding-left: 60px">cv2.waitKey() </pre>
<ol start="8">
<li>The command used to execute the <kbd>Detecting_corner.py</kbd> <span>Python programÂ </span>file, along with the input image (<kbd>box.jpg</kbd>), is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/a7d6e3a7-79e2-40a3-b3ef-6b9d6c05cd94.png" style="width:39.75em;height:2.17em;" width="514" height="28"/></div>
<ol start="9">
<li>The input image used to execute theÂ <kbd>Detecting_corner.py</kbd> file is shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-671 image-border" src="Images/a9fde55f-33a1-4773-ad98-0e6485cadb89.png" style="width:18.67em;height:20.42em;" width="224" height="245"/></div>
<ol start="10">
<li><span class="packt_screen">Harris Corners</span> obtained after executing theÂ <kbd>Detecting_corner.py</kbd> file are shown here:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-672 image-border" src="Images/0372faa3-4b7a-4c85-900e-5dfa30a55029.png" style="width:18.67em;height:20.42em;" width="224" height="245"/></div>
<p>In order to learn how it works for an input image, refer to the following:</p>
<ul>
<li>Image corner detection involves finding the edges/corners in the given picture. It can be used to extract the vital shape features from grayscale and RGB pictures. Refer to this survey paper on edge and corner detection:</li>
</ul>
<p style="padding-left: 60px"><a href="https://pdfs.semanticscholar.org/24dd/6c2c08f5601e140aad5b9170e0c7485f6648.pdf">https://pdfs.semanticscholar.org/24dd/6c2c08f5601e140aad5b9170e0c7485f6648.pdf</a>.</p>


            </article>

            
        </section>
    </div>



  </body></html>