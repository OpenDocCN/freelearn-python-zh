<html><head></head><body>
		<div id="_idContainer027">
			<h1 id="_idParaDest-81" class="chapter-number"><a id="_idTextAnchor080"/>4</h1>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Building the Microservice Application</h1>
			<p>Previously, we spent a lot of time building API services for various applications using the core features of FastAPI. We also started applying important design patterns such as <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) and <strong class="bold">Dependency Injection</strong> (<strong class="bold">DI</strong>), which are essential for managing FastAPI container objects. External Python packages were installed and used to provide options on what containers to use in managing objects. </p>
			<p>These design patterns can help not only with managed objects in container but also when building scalable, enterprise-grade, and unconventionally complex applications. Most of these design patterns help break down monolithic architecture into loosely coupled components that are known as <em class="italic">microservices</em>.</p>
			<p>In this chapter, we will explore some architectural design patterns and principles that can provide strategies and ways to initiate the building of our microservices from a monolithic application. Our focus will be on breaking the huge application into business units, creating a sole gateway to bundle these business units, applying domain modeling to each of the microservices, and managing other concerns such as logging and application configuration.</p>
			<p>Aside from expounding the benefits and disadvantages of each design pattern, another objective is to apply these architectural patterns to our software specimen to show its effectiveness and feasibility. And to support these goals, the following topics will be covered in this chapter:</p>
			<ul>
				<li>Applying the decomposition pattern</li>
				<li>Creating a common gateway</li>
				<li>Centralizing the logging mechanism</li>
				<li>Consuming the REST APIs</li>
				<li>Applying the domain modeling approach</li>
				<li>Managing a microservice’s configuration details</li>
			</ul>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Technical requirements</h1>
			<p>This chapter uses a <em class="italic">university ERP system</em> prototype that focuses on the students, faculty, and library submodules, but more on student-library and faculty-library operations (for example, book borrowing and issuing). Each submodule has its administration, management, and transaction services, and they are independent of each other even though they are part of an ERP specification. Currently, this sample prototype does not use any database management system, so all the data is temporarily stored in Python containers. The code is all uploaded at <a href="https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI">https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI</a> under the <strong class="source-inline">ch04</strong>, <strong class="source-inline">ch04-student</strong>, <strong class="source-inline">ch04-faculty</strong>, and <strong class="source-inline">ch04-library</strong> projects.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Applying the decomposition pattern</h1>
			<p>If we <a id="_idIndexMarker212"/>apply the monolithic strategy used in building the prototypes presented in the previous chapters, building this ERP will not be cost-effective in terms of resources and effort. There will be features that might become too dependent on other functions, which will put the teams of developers in a difficult situation whenever transaction problems occur due to these tightly coupled features. The best way to implement our University ERP prototype is to decompose the whole specification into smaller modules before the implementation starts. </p>
			<p>There are two appropriate ways in which to decompose our application prototype, namely decomposition by business units and decomposition by subdomains: </p>
			<ul>
				<li><em class="italic">Decomposition by business units</em> is used when the breakdown of the monolithic application is based on organizational structures, architectural components, and structural units. Usually, its resulting modules have fixed and structured processes and functionality that are seldom enhanced or upgraded. </li>
				<li><em class="italic">Decomposition by subdomain</em> uses domain models and their corresponding business processes as the basis of the breakdown. Unlike the former, this decomposition strategy deals with modules that continuously evolve and change to capture the exact structure of the modules. </li>
			</ul>
			<p>Of the <a id="_idIndexMarker213"/>two options, decomposition by business units is the more practical decomposition strategy to use for our monolithic University ERP prototype. Since the information and business flow used by universities has been part of its foundation for years, we need to organize and breakdown its voluminous and compounded operations by colleges or departments. <em class="italic">Figure 4.1</em> shows the derivation of these submodules:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_4.1_B17975.jpg" alt="Figure 4.1 – Decomposition by business units"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Decomposition by business units</p>
			<p>After determining the submodules, we can implement them as independent microservices using the FastAPI framework. We can call an implementation of a business unit or module a microservice if its services <em class="italic">can collectively stand as one component</em>. Also, it must be able to <em class="italic">collaborate with other microservices</em> through <em class="italic">interconnection</em> based on the URL address and port number. <em class="italic">Figure 4.2</em> shows the project directories of the faculty, library, and student management modules implemented as FastAPI microservice applications. <a href="B17975_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a><em class="italic">, Setting Up FastAPI for Starters,</em> to <a href="B17975_03.xhtml#_idTextAnchor052"><em class="italic">Chapter 3</em></a><em class="italic">,</em> <em class="italic">Investigating Dependency Injection</em>, gave us the foundation to<a id="_idIndexMarker214"/> build a FastAPI microservice:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_4.2_B17975.jpg" alt="Figure 4.2 – The faculty, library, and student microservice applications"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The faculty, library, and student microservice applications</p>
			<p>Each of these microservices is independent of the others in terms of its server instance and management. Starting and shutting down one of them will not affect the other two, as each can have a different context root and port. Each application can have a separate logging mechanism, dependency environment, container, configuration file, and any other aspect of a microservice, which will be discussed in the subsequent chapters.</p>
			<p>But FastAPI has another way of designing microservices using a <em class="italic">mount</em> sub-application.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Creating the sub-applications</h2>
			<p>FastAPI allows you <a id="_idIndexMarker215"/>to build independent sub-applications inside the <em class="italic">main application</em>. Here, <strong class="source-inline">main.py</strong> serves as a gateway that provides a pathname to these mounted applications. It also creates the mounts specifying the context path mapped to the FastAPI instance of each sub-application. <em class="italic">Figure 4.3</em> shows a new university ERP implementation that has been built using mounts:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_4.3_B17975.jpg" alt="Figure 4.3 – The main project with the mounts&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The main project with the mounts</p>
			<p>Here, <strong class="source-inline">faculty_mgt</strong>, <strong class="source-inline">library_mgt</strong>, and <strong class="source-inline">student_mgt</strong> are typical independent microservice applications mounted into the <strong class="source-inline">main.py</strong> component, the top-level application. Each <a id="_idIndexMarker216"/>sub-application has a <strong class="source-inline">main.py</strong> component, such as <strong class="source-inline">library_mgt</strong>, which has its FastAPI instance created in its <strong class="source-inline">library_main.py</strong> setup, as shown in the following code snippet:</p>
			<pre class="source-code">
from fastapi import FastAPI
<strong class="bold">library_app = FastAPI()</strong>
library_app.include_router(admin.router)
library_app.include_router(management.router)</pre>
			<p>The student sub-application has a <strong class="source-inline">student_main.py</strong> setup that creates its FastAPI instance, as shown in the following code:</p>
			<pre class="source-code">
from fastapi import FastAPI
<strong class="bold">student_app = FastAPI()</strong>
student_app.include_router(reservations.router)
student_app.include_router(admin.router)
student_app.include_router(assignments.router)
student_app.include_router(books.router)</pre>
			<p>Likewise, the<a id="_idIndexMarker217"/> faculty sub-application also has its <strong class="source-inline">faculty_main.py</strong> setup, as highlighted in the following code, for the same purpose, to build the microservice architecture:</p>
			<pre class="source-code">
from fastapi import FastAPI
<strong class="bold">faculty_app = FastAPI()</strong>
faculty_app.include_router(admin.router)
faculty_app.include_router(assignments.router)
faculty_app.include_router(books.router)</pre>
			<p>These sub-applications are typical FastAPI microservice applications containing all of the essential components such as routers, middleware exception handlers, and all the necessary packages to build REST API services. The only difference from the usual applications is that their context paths or URLs are defined and decided by the top-level application that handles them. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Optionally, we can run the <strong class="source-inline">library_mgt</strong> sub-application independently from <strong class="source-inline">main.py</strong> through the <strong class="source-inline">uvicorn main:library_app --port 8001</strong> command, <strong class="source-inline">faculty_mgt</strong> through <strong class="source-inline">uvicorn main:faculty_app --port 8082</strong>, and <strong class="source-inline">student_mgt</strong> through <strong class="source-inline">uvicorn main:student_app --port 8003</strong>. The option of running them independently despite the mount explains why these mounted sub-applications are all microservices.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Mounting the submodules</h1>
			<p>All the FastAPI <a id="_idIndexMarker218"/>decorators of each sub-application must be mounted in the <strong class="source-inline">main.py</strong> component of the top-level application for them to be accessed at runtime. The <strong class="source-inline">mount()</strong> function is invoked by the FastAPI decorator object of the top-level application, which adds all FastAPI instances of the sub-applications into the gateway application (<strong class="source-inline">main.py</strong>) and maps each with its corresponding URL context. The following script shows how the mounting of the <em class="italic">library</em>, <em class="italic">student</em>, and <em class="italic">faculty</em> subsystems is implemented in the <strong class="source-inline">main.py</strong> component of the University ERP top-level system:</p>
			<pre class="source-code">
from fastapi import FastAPI
<strong class="bold">from student_mgt import student_main</strong>
<strong class="bold">from faculty_mgt import faculty_main</strong>
<strong class="bold">from library_mgt import library_main</strong>
app = FastAPI()
app.<strong class="bold">mount</strong>("<strong class="bold">/ch04/student</strong>", student_main.<strong class="bold">student_app</strong>)
app.<strong class="bold">mount</strong>("<strong class="bold">/ch04/faculty</strong>", faculty_main.<strong class="bold">faculty_app</strong>)
app.<strong class="bold">mount</strong>("<strong class="bold">/ch04/library</strong>", library_main.<strong class="bold">library_app</strong>)</pre>
			<p>With this setup, the mounted <strong class="source-inline">/ch04/student</strong> URL will be used to access all the API services of the <em class="italic">student module</em> app, <strong class="source-inline">/ch04/faculty</strong> will be used for all the services of the <em class="italic">faculty module</em>, and <strong class="source-inline">/ch04/library</strong> will be used for the <em class="italic">library</em>-related REST services. These mounted paths become valid once they are declared in <strong class="source-inline">mount()</strong> because FastAPI automatically handles all of these paths through the <strong class="source-inline">root_path</strong> specification.</p>
			<p>Since all three sub-applications of our <em class="italic">university ERP system</em> are independent microservices, now let us apply another design strategy that can help manage the requests to these applications just by using the main URL of the ERP system. Let us utilize the <em class="italic">main application</em> as a gateway to our sub-applications.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Creating a common gateway</h1>
			<p>It will be <a id="_idIndexMarker219"/>easier if we use the URL of the main application to manage the requests and redirect users to any of the three sub-applications. The <em class="italic">main application</em> can stand as a pseudo-reverse proxy or an entry point for user requests, which will always redirect user requests to any of the desired sub-applications. This kind of approach is based on a design pattern called <em class="italic">API Gateway</em>. Now, let us explore how we can apply this design to manage independent microservices mounted onto the main application using a workaround.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Implementing the main endpoint</h1>
			<p>There are so <a id="_idIndexMarker220"/>many solutions when it comes to implementing this gateway endpoint, and among them is having a simple REST API service in the top-level application with an integer path parameter that will identify the <strong class="source-inline">ID</strong> parameter of the microservice. If the <strong class="source-inline">ID</strong> parameter is invalid, the endpoint will only return the <strong class="source-inline">{'message': 'University ERP Systems'}</strong> JSON string instead of an error. The following script is a straightforward implementation of this endpoint:</p>
			<pre class="source-code">
from fastapi import APIRouter
router = APIRouter()
<strong class="bold">@router.get("/university/{portal_id}")</strong>
def access_portal(portal_id:int): 
    return {'message': 'University ERP Systems'}</pre>
			<p>The <strong class="source-inline">access_portal</strong> API endpoint is created as a GET path operation with <strong class="source-inline">portal_id</strong> as its path parameter. The <strong class="source-inline">portal_id</strong> parameter is essential to this process because it will determine which among the <em class="italic">Student</em>, <em class="italic">Faculty</em>, and <em class="italic">Library</em> microservices the user wants to<a id="_idIndexMarker221"/> access. Therefore, accessing the <strong class="source-inline">/ch04/university/1</strong> URL should lead the user to the student application, <strong class="source-inline">/ch04/university/2</strong> to the faculty microservice, and <strong class="source-inline">/ch04/university/3</strong> to the library application.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Evaluating the microservice ID</h1>
			<p>The <strong class="source-inline">portal_id</strong> parameter<a id="_idIndexMarker222"/> will automatically be fetched and evaluated using a dependable function that is injected into the <strong class="source-inline">APIRouter</strong> instance where the API endpoint is implemented. As discussed in <a href="B17975_03.xhtml#_idTextAnchor052"><em class="italic">Chapter 3</em></a>, <em class="italic">Investigating Dependency Injection</em>, a <em class="italic">dependable function</em> or <em class="italic">object</em> can serve as a filter or validator of all incoming requests of any services once injected into an <strong class="source-inline">APIRouter</strong> or <strong class="source-inline">FastAPI</strong> instance. The dependable function used in this ERP prototype, as shown in the following script, evaluates whether the <strong class="source-inline">portal_id</strong> parameter is <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, or <strong class="source-inline">3</strong> only:</p>
			<pre class="source-code">
def call_api_gateway(<strong class="bold">request: Request</strong>): 
    <strong class="bold">portal_id = request.path_params['portal_id']</strong>
    print(request.path_params)
    if portal_id == str(<strong class="bold">1</strong>): 
        raise <strong class="bold">RedirectStudentPortalException()</strong> 
    elif portal_id == str(<strong class="bold">2</strong>): 
        raise <strong class="bold">RedirectFacultyPortalException()</strong> 
    elif portal_id == str(<strong class="bold">3</strong>): 
        raise <strong class="bold">RedirectLibraryPortalException()</strong>
class <strong class="bold">RedirectStudentPortalException</strong>(Exception):
    pass
class <strong class="bold">RedirectFacultyPortalException</strong>(Exception):
    pass
class <strong class="bold">RedirectLibraryPortalException</strong>(Exception):
    pass</pre>
			<p>The <a id="_idIndexMarker223"/>given solution is a feasible workaround to trigger a custom event since FastAPI has no built-in event handling except for the startup and shutdown event handlers, which are topics in <a href="B17975_08.xhtml#_idTextAnchor229"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Coroutines, Events, and Message-Driven Transactions</em>. So, once <strong class="source-inline">call_api_gateway()</strong> finds <strong class="source-inline">portal_id</strong> to be a valid microservice ID, it will raise some custom exceptions. It will throw <strong class="source-inline">RedirectStudentPortalException</strong> if the user wants to access the <em class="italic">Student</em> microservice. On the other hand, the <strong class="source-inline">RedirectFacultyPortalException</strong> error will be raised if the user desires the <em class="italic">Faculty</em> microservice. Otherwise, the <strong class="source-inline">RedirectLibraryPortalException</strong> error will be triggered when the <em class="italic">Library</em> microservice is the one wanted by the user. But first, we need to inject <strong class="source-inline">call_api_gateway()</strong> into the <strong class="source-inline">APIRouter</strong> instance handling the gateway endpoint through the <strong class="source-inline">main.py</strong> component of the top-level ERP application. The following script shows you how it is injected into <strong class="source-inline">university.router</strong> using the concepts discussed earlier:</p>
			<pre class="source-code">
from fastapi import FastAPI, Depends, Request, <a id="_idTextAnchor089"/>Response
<strong class="bold">from gateway.api_router import call_api_gateway</strong>
<strong class="bold">from controller import university</strong>
app = FastAPI()
app.include_router (<strong class="bold">university.router</strong>, 
           <strong class="bold">dependencies=[Depends(call_api_gateway)]</strong>, 
           prefix='/ch04')</pre>
			<p>All <a id="_idIndexMarker224"/>of these raised exceptions require an exception handler that will listen to the throws and execute some of the tasks required to pursue the microservices.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Applying the exception handlers</h1>
			<p>The<a id="_idIndexMarker225"/> exception handler does a redirection to the appropriate microservice. As you learned in <a href="B17975_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring the Core Features</em>, each thrown exception must have its corresponding exception handler to pursue the required response after the exception handling. Here are the exception handlers that will handle the custom exception thrown by <strong class="source-inline">call_api_gateway()</strong>:</p>
			<pre class="source-code">
<strong class="bold">from fastapi.responses import RedirectResponse</strong>
from gateway.api_router import call_api_gateway, 
     <strong class="bold">RedirectStudentPortalException</strong>, 
     <strong class="bold">RedirectFacultyPortalException</strong>, 
     <strong class="bold">RedirectLibraryPortalException</strong>
@app.exception_handler(<strong class="bold">RedirectStudentPortalException</strong>)
def exception_handler_student(request: Request, 
   <strong class="bold">exc: RedirectStudentPortalException</strong>) -&gt; Response:
    return <strong class="bold">RedirectResponse(</strong>
        <strong class="bold">url='http://localhost:8000/ch04/student/index')</strong>
@app.exception_handler(<strong class="bold">RedirectFacultyPortalException</strong>)
def exception_handler_faculty(request: Request, 
   <strong class="bold">exc: RedirectFacultyPortalException</strong>) -&gt; Response:
    return <strong class="bold">RedirectResponse(</strong>
       <strong class="bold">url='http://localhost:8000/ch04/faculty/index')</strong>
@app.exception_handler(<strong class="bold">RedirectLibraryPortalException</strong>)
def exception_handler_library(request: Request, 
   <strong class="bold">exc: RedirectLibraryPortalException</strong>) -&gt; Response:
    return <strong class="bold">RedirectResponse(</strong>
       <strong class="bold">url='http://localhost:8000/ch04/library/index')</strong></pre>
			<p>Here, <strong class="source-inline">exception_handler_student()</strong> will redirect the user to the mount path of the <em class="italic">Student</em> microservice, while <strong class="source-inline">exception_handler_faculty()</strong> will redirect the user to the <em class="italic">Faculty</em> sub-application. Additionally, <strong class="source-inline">exception_handler_library()</strong> will let the user access the <em class="italic">Library</em> microservice. Exception <a id="_idIndexMarker226"/>handlers are the last component needed to complete the API Gateway architecture. The exceptions trigger the redirection to the independent microservices mounted on the FastAPI framework.</p>
			<p>Although there are other, better solutions to achieve the gateway architecture, our approach is still procedural and pragmatic without having to resort to external modules and tools, just the core components of FastAPI. <a href="B17975_11.xhtml#_idTextAnchor321"><em class="italic">Chapter 11</em></a>, <em class="italic">Adding Other Microservices Features</em>, will discuss establishing an effective API Gateway architecture using Docker and NGINX. </p>
			<p>Now, let us explore how to set up a centralized logging mechanism for this kind of microservices setup.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>Centralizing the logging mechanism</h1>
			<p>We have<a id="_idIndexMarker227"/> created an audit trail mechanism with middleware and Python file transactions in <a href="B17975_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring the Core Features</em>. We have found out that middleware, which can only be set up through the FastAPI decorator of the top-level application, can manage incoming Request and outgoing Response of any API services. This time, we will be using custom middleware to set up a centralized logging feature that will log all service transactions of the top-level application alongside its independent mounted microservices. Of the many approaches for integrating these logging concerns into the application without changing the API services, we will concentrate on the following pragmatic custom approach with the custom middleware and <em class="italic">Loguru</em> module.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Utilizing the Loguru module</h2>
			<p>An <em class="italic">application log</em> is <a id="_idIndexMarker228"/>essential to any enterprise-grade application. For monolithic applications deployed in a single server, logging means letting service transactions write their log messages to a single file. On the other hand, logging can be too complex and complicated to implement in an independent microservices setup, especially when these services are for deployment to different servers or Docker containers. Its logging mechanism could even cause runtime problems if the module used is not adaptable to asynchronous services.</p>
			<p>For FastAPI instances that support both asynchronous and synchronous API services that run on an ASGI server, using Python’s logging module always generates the following error log:</p>
			<pre class="source-code">
2021-11-08 01:17:22,336 - uvicorn.error - ERROR - Exception in ASGI application
Traceback (most recent call last):
  File "c:\alibata\development\language\python\
  python38\lib\site-packages\uvicorn\protocols\http\
  httptools_impl.py", line 371, in run_asgi
    result = await app(self.scope, self.receive, self.send)
  File "c:\alibata\development\language\python\
  python38\lib\site-packages\uvicorn\middleware\
  proxy_headers.py", line 59, in __call__
    return await self.app(scope, receive, send)</pre>
			<p>Opting for<a id="_idIndexMarker229"/> another logging extension is the only solution to avoid the error generated by the <strong class="source-inline">logging</strong> module. The best option is one that can fully support the FastAPI framework, which is the <strong class="source-inline">loguru</strong> extension. But first, we need to install it using the <strong class="source-inline">pip</strong> command:</p>
			<p class="source-code">pip install loguru</p>
			<p>Loguru is a straightforward and easy-to-use logging extension. We can immediately log using its default handler, the <strong class="source-inline">sys.stderr</strong> handler, even without adding much configurations. Since our application needs to place all messages in a log file, we need to add the following lines to the <strong class="source-inline">main.py</strong> component of the top-level application right after the instantiation of <strong class="source-inline">FastAPI</strong>:</p>
			<pre class="source-code">
<strong class="bold">from loguru import logger</strong>
from uuid import uuid4
app = FastAPI()
app.include_router (university.router, 
         dependencies=[Depends(call_api_gateway)], 
         prefix='/ch04')
<strong class="bold">logger.add("info.log",format="Log: [{extra[log_id]}: </strong>
<strong class="bold">   {time} - {level} - {message} ", level="INFO", </strong>
<strong class="bold">   enqueue = True)</strong></pre>
			<p>Note<a id="_idIndexMarker230"/> that its <strong class="source-inline">logger</strong> instance has an <strong class="source-inline">add()</strong> method where we can register <em class="italic">sinks</em>. The first part of the <em class="italic">sinks</em> is the <em class="italic">handler</em> that decides whether to emit the logs in <strong class="source-inline">sys.stdout</strong> or the file. In our university ERP prototype, we need to have a global <strong class="source-inline">info.log</strong> file that contains all the log messages of the sub-applications. </p>
			<p>A crucial part of the log sink is the <strong class="source-inline">level</strong> type, which indicates the granularity of log messages that need to be managed and logged. If we set the <strong class="source-inline">level</strong> parameter of <strong class="source-inline">add()</strong> to <strong class="source-inline">INFO</strong>, it tells the logger to consider only those messages under the <strong class="source-inline">INFO</strong>, <strong class="source-inline">SUCCESS</strong>, <strong class="source-inline">WARNING</strong>, <strong class="source-inline">ERROR</strong>, and <strong class="source-inline">CRITICAL</strong> weights. The logger will bypass log messages outside these levels.</p>
			<p>Another part of the <em class="italic">sinks</em> is the <strong class="source-inline">format</strong> log, where we can create a custom log message layout to replace its default format. This format is just like a Python interpolated string without the <em class="italic">"f"</em> that contains placeholders such as <strong class="source-inline">{time}</strong>, <strong class="source-inline">{level}</strong>, <strong class="source-inline">{message}</strong>, and any custom placeholders that need to be replaced by <strong class="source-inline">logger</strong> at runtime. </p>
			<p>In <strong class="source-inline">log.file</strong>, we want our logs to start with the <strong class="source-inline">Log</strong> keyword followed immediately by the custom-generated <strong class="source-inline">log_id</strong> parameter and then the time the logging happened, the level, and the message. </p>
			<p>And to add support for asynchronous logging, the <strong class="source-inline">add()</strong> function has an <strong class="source-inline">enqueue</strong> parameter that we can enable anytime. In our case, this parameter is default to <strong class="source-inline">True</strong> just to prepare for any <strong class="source-inline">async/await</strong> execution. </p>
			<p>There is a lot to explore with Loguru’s features and functionality. For instance, we can create additional handlers for loggers to emit where each of these handlers has different retention, rotation, and rendition types. Additionally, Loguru can allow us to add colors to our logs through some color markups such as <strong class="source-inline">&lt;red&gt;</strong>, <strong class="source-inline">&lt;blue&gt;</strong>, or <strong class="source-inline">&lt;cyan&gt;</strong>. It also has an <strong class="source-inline">@catch()</strong> decorator that can be applied to manage exceptions at runtime. All the logging features we need to set up our unified application log are in Loguru. Now <a id="_idIndexMarker231"/>that we have configured our Loguru in the top-level application, we need to let its logging mechanism work across the three sub-applications or microservices without modifying their code.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>Building the logging middleware</h1>
			<p>The core<a id="_idIndexMarker232"/> component of this centralized application log is the custom middleware that we must implement in the <strong class="source-inline">main.py</strong> component where we set up Loguru. FastAPI’s <em class="italic">mount</em> allows us to centralize some cross-cutting concerns such as logging without adding anything to the sub-applications. One middleware implementation in the <strong class="source-inline">main.py</strong> component of the top-level application is good enough to pursue logging across the independent microservices. The following is the middleware implementation for our specimen application:</p>
			<pre class="source-code">
<strong class="bold">@app.middleware("http")</strong>
async def log_middleware(request:Request, call_next):
    <strong class="bold">log_id = str(uuid4())</strong>
    <strong class="bold">with logger.contextualize(log_id=log_id)</strong>:
        <strong class="bold">logger.info('Request to access ' + </strong>
             <strong class="bold">request.url.path)</strong>
        try:
            response = await call_next(request)
        except Exception as ex: 
            <strong class="bold">logger.error(f"Request to " + </strong>
              <strong class="bold">request.url.path + " failed: {ex}")</strong>
            response = JSONResponse(content=
               {"success": False}, status_code=500)
        finally: 
            <strong class="bold">logger.info('Successfully accessed ' + </strong>
               <strong class="bold">request.url.path)</strong>
            return response</pre>
			<p>First, <strong class="source-inline">log_middleware()</strong> will generate a <strong class="source-inline">log_id</strong> parameter every time it intercepts <a id="_idIndexMarker233"/>any API services from the main app or the sub-applications. Then, the <strong class="source-inline">log_id</strong> parameter is injected into the <strong class="source-inline">dict</strong> of context information through Loguru’s <strong class="source-inline">contextualize()</strong> method since <strong class="source-inline">log_id</strong> is part of the log information, as indicated in our log format setup. Afterward, logging starts before the API service is executed and after its successful execution. When exceptions are encountered during the process, the logger will still generate a log message with the <strong class="source-inline">Exception</strong> message. So, whenever we access any API services anywhere from the ERP prototype, the following log messages will be written in <strong class="source-inline">info.log</strong>:</p>
			<pre class="source-code">
Log: [1e320914-d166-4f5e-a39b-09723e04400d: 2021-11-28T12:02:25.582056+0800 - INFO - Request to access <strong class="bold">/ch04/university/1</strong> 
Log: [1e320914-d166-4f5e-a39b-09723e04400d: 2021-11-28T12:02:25.597036+0800 - INFO - Successfully accessed <strong class="bold">/ch04/university/1</strong> 
Log: [fd3badeb-8d38-4aec-b2cb-017da853e3db: 2021-11-28T12:02:25.609162+0800 - INFO - Request to access <strong class="bold">/ch04/student/index</strong> 
Log: [fd3badeb-8d38-4aec-b2cb-017da853e3db: 2021-11-28T12:02:25.617177+0800 - INFO - Successfully accessed <strong class="bold">/ch04/student/index</strong> 
Log: [4cdb1a46-59c8-4762-8b4b-291041a95788: 2021-11-28T12:03:25.187495+0800 - INFO - Request to access <strong class="bold">/ch04/student/profile/add</strong> 
Log: [4cdb1a46-59c8-4762-8b4b-291041a95788: 2021-11-28T12:03:25.203421+0800 - 
INFO - Request to access <strong class="bold">/ch04/faculty/index </strong>
Log: [5cde7503-cb5e-4bda-aebe-4103b2894ffe: 2021-11-28T12:03:33.432919+0800 - INFO - Successfully accessed <strong class="bold">/ch04/faculty/index</strong> 
Log: [7d237742-fdac-4f4f-9604-ce49d3c4c3a7: 2021-11-28T12:04:46.126516+0800 - INFO - Request to access <strong class="bold">/ch04/faculty/books/request/list</strong> 
Log: [3a496d87-566c-477b-898c-8191ed6adc05: 2021-11-28T12:04:48.212197+0800 - INFO - Request to access <strong class="bold">/ch04/library/book/request/list</strong> 
Log: [3a496d87-566c-477b-898c-8191ed6adc05: 2021-11-28T12:04:48.221832+0800 - INFO - Successfully accessed <strong class="bold">/ch04/library/book/request/list</strong> 
Log: [7d237742-fdac-4f4f-9604-ce49d3c4c3a7: 2021-11-28T12:04:48.239817+0800 - 
Log: [c72f4287-f269-4b21-a96e-f8891e0a4a51: 2021-11-28T12:05:28.987578+0800 - INFO - Request to access <strong class="bold">/ch04/library/book/add</strong> 
Log: [c72f4287-f269-4b21-a96e-f8891e0a4a51: 2021-11-28T12:05:28.996538+0800 - INFO - Successfully accessed <strong class="bold">/ch04/library/book/add</strong></pre>
			<p>The <a id="_idIndexMarker234"/>given snapshot of log messages proves that we have a centralized setup because the middleware filters all API service execution and performs the logging transaction. It shows that the logging started from accessing the gateway down to executing the API services from the <em class="italic">faculty</em>, <em class="italic">student</em>, and <em class="italic">l</em><em class="italic">ibrary</em> sub-applications. Centralizing and managing cross-cutting concerns is one advantage that can be provided by using FastAPI’s <em class="italic">mounting</em> when building independent microservices.</p>
			<p>But when it comes to the interactions among these independent sub-applications, can mounting <a id="_idIndexMarker235"/>also be an advantage? Now, let us explore how independent microservices in our architecture can communicate by utilizing each other’s API resources.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Consuming the REST API services</h2>
			<p>Just like in<a id="_idIndexMarker236"/> an unmounted microservices setup, mounted ones can also communicate by accessing each other’s API services. For instance, if a faculty member or student wants to borrow a book from the library, how can that setup be implemented seamlessly? </p>
			<p>In <em class="italic">Figure 4.4</em>, we can see that interactions can be possible by establishing a client-server communication wherein one API service can serve as a resource provider, and the others are the clients:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_4.4_B17975.jpg" alt="Figure 4.4 – Interaction with the faculty, student, and library microservices &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Interaction with the faculty, student, and library microservices </p>
			<p>Consuming API resources in FastAPI can be straightforward using the <strong class="source-inline">httpx</strong> and <strong class="source-inline">requests</strong> external modules. The<a id="_idIndexMarker237"/> following discussions will focus on how these two modules can help our mounted services interact with each other.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>Using the httpx module</h1>
			<p>The <strong class="source-inline">httpx</strong> external<a id="_idIndexMarker238"/> module is a Python extension that can consume both asynchronous and synchronous REST APIs and has <em class="italic">HTTP/1.1</em> and <em class="italic">HTTP/2</em> support. It is<a id="_idIndexMarker239"/> a fast and multi-purpose toolkit that is used to access API services running on WSGI-based platforms, as well as, on ASGI, like the FastAPI services. But first, we need to install it using <strong class="source-inline">pip</strong>:</p>
			<p class="source-code">pip install httpx</p>
			<p>Then, we can use it directly without further configuration to make two microservices interact, for instance, our <em class="italic">student</em> module submitting assignments to the <em class="italic">faculty</em> module:</p>
			<pre class="source-code">
import <strong class="bold">httpx</strong>
<strong class="bold">@router.get('/assignments/list')</strong>
async def list_assignments(): 
   <strong class="bold">async with httpx.AsyncClient() as client:</strong>
    <strong class="bold">response = await client.get(</strong>
     <strong class="bold">"http://localhost:8000/ch04/faculty/assignments/list")</strong>
    return response.<strong class="bold">json()</strong>
<strong class="bold">@router.post('/assignment/submit')</strong>
def submit_assignment(assignment:AssignmentRequest ):
   <strong class="bold">with httpx.Client() as client:</strong>
      <strong class="bold">response = client.post("http://localhost:8000/</strong>
          <strong class="bold">ch04/faculty/assignments/student/submit",  </strong>
           <strong class="bold">data=json.dumps(jsonable_encoder(assignment)))</strong>
      return response.<strong class="bold">content</strong></pre>
			<p>The <strong class="source-inline">httpx</strong> module <a id="_idIndexMarker240"/>can process the <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PATCH</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> path operations. It can allow the passing of different request parameters to the requested API without so much complexity. The <strong class="source-inline">post()</strong> client operation, for instance, can accept headers, cookies, params, json, files, and model data as parameter values. We use the <strong class="source-inline">with</strong> context manager to directly manage the streams created by its <strong class="source-inline">Client()</strong> or <strong class="source-inline">AsyncClient()</strong> instances, which are closeable components. </p>
			<p>The preceding <strong class="source-inline">list_assignments</strong> service is a client that uses the <strong class="source-inline">AsyncClient()</strong> instance to pursue its GET request from an asynchronous <strong class="source-inline">/ch04/faculty/assignments/list</strong> API endpoint from the f<em class="italic">aculty</em> module. <strong class="source-inline">AsyncClient</strong> accesses the WSGI-based platform to execute any asynchronous services, not the synchronous ones, or else it will throw <em class="italic">Status Code 500</em>. It might require additional configuration details in its constructor for some complex cases, where it needs to further manage resource access through ASGI.</p>
			<p>On the other hand, the <strong class="source-inline">submit_assignment</strong> service is a synchronous client that accesses another synchronous endpoint, <strong class="source-inline">ch04/faculty/assignments/student/submit</strong>, which is a <strong class="source-inline">POST</strong> HTTP operation. In this case, the <strong class="source-inline">Client()</strong> instance is used to access the resource to submit an assignment to the <em class="italic">Faculty</em> module through a <strong class="source-inline">POST</strong> request. <strong class="source-inline">AssignmentRequest</strong> is a <strong class="source-inline">BaseModel</strong> object that needs to be filled up by the client for submission to the request endpoint. Unlike <strong class="source-inline">params</strong> and <strong class="source-inline">json</strong>, which are passed straightforwardly as <strong class="source-inline">dict</strong>, <strong class="source-inline">data</strong> is a model object that must be first converted into <strong class="source-inline">dict</strong> by <strong class="source-inline">jsonable_encoder()</strong> and <strong class="source-inline">json.dumps()</strong> to make the transport feasible across the HTTP. The new converted model becomes the argument value of the <strong class="source-inline">data</strong> parameter of the POST client operation.</p>
			<p>When it comes to the response of the client services, we can allow the response to be treated as a piece of text using the module’s <strong class="source-inline">content</strong> or as a JSON result using <strong class="source-inline">json()</strong>. It now <a id="_idIndexMarker241"/>depends on the requirement of the client service as to what response type to use for the application. </p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Using the requests module</h1>
			<p>Another option to <a id="_idIndexMarker242"/>establish client-server communication among microservices is the <strong class="source-inline">requests</strong> module. Although <strong class="source-inline">httpx</strong> and <strong class="source-inline">requests</strong> are almost compatible, the latter offers other features such <a id="_idIndexMarker243"/>as auto-redirection and explicit session handling. The only problem with <strong class="source-inline">requests</strong> is its non-direct support to asynchronous APIs and its slow performance when accessing resources. Despite its drawbacks, the <strong class="source-inline">requests</strong> module is still the standard way of consuming REST APIs in Python microservice development. First, we need to install it before we can use it:</p>
			<p class="source-code">pip install requests</p>
			<p>In our ERP prototype, the <strong class="source-inline">requests</strong> extension was used by the <em class="italic">faculty</em> microservice to borrow books from the <em class="italic">library</em> module. Let’s look at the <em class="italic">Faculty</em> client services that show us how the <strong class="source-inline">requests</strong> module is used to access the synchronous API of <em class="italic">library</em>:</p>
			<pre class="source-code">
<strong class="bold">@router.get('/books/request/list')</strong>
def list_all_request(): 
    <strong class="bold">with requests.Session() as sess:</strong>
        <strong class="bold">response = sess.get('http://localhost:8000/</strong>
           <strong class="bold">ch04/library/book/request/list')</strong>
        return response.<strong class="bold">json()</strong>
<strong class="bold">@router.post('/books/request/borrow')</strong>
def request_borrow_book(request:BookRequestReq): 
    <strong class="bold">with requests.Session() as sess:</strong>
        <strong class="bold">response = sess.post('http://localhost:8000/</strong>
           <strong class="bold">ch04/library/book/request', </strong>
             <strong class="bold">data=dumps(jsonable_encoder(request)))</strong>
        return response.<strong class="bold">content</strong>
<strong class="bold">@router.get('/books/issuance/list')</strong>
def list_all_issuance(): 
    <strong class="bold">with requests.Session() as sess:</strong>
        <strong class="bold">response = sess.get('http://localhost:8000/</strong>
            <strong class="bold">ch04/library/book/issuance/list')</strong>
        return response.<strong class="bold">json()</strong>
<strong class="bold">@router.post('/books/returning')</strong>
def return_book(returning: BookReturnReq): 
    <strong class="bold">with requests.Session() as sess:</strong>
        <strong class="bold">response = sess.post('http://localhost:8000/</strong>
            <strong class="bold">ch04/library/book/issuance/return', </strong>
              <strong class="bold">data=dumps(jsonable_encoder(returning)))</strong>
        return response.<strong class="bold">json()</strong></pre>
			<p>The <strong class="source-inline">requests</strong> module <a id="_idIndexMarker244"/>has a <strong class="source-inline">Session()</strong> instance, which is equivalent to <strong class="source-inline">Client()</strong> in the <strong class="source-inline">httpx</strong> module. It provides all the necessary client operations that will consume the API endpoints from the FastAPI platform. Since <strong class="source-inline">Session</strong> is a closeable object, the context manager is, again, used here to handle the streams that will be utilized during the access of the resources and transport of some parameter values. Like in <strong class="source-inline">httpx</strong>, parameter details such as <strong class="source-inline">params</strong>, <strong class="source-inline">json</strong>, <strong class="source-inline">header</strong>, <strong class="source-inline">cookies</strong>, <strong class="source-inline">files</strong>, and <strong class="source-inline">data</strong> are also part of the <strong class="source-inline">requests</strong> module and are ready for transport through the client operation if needed by the API endpoints.</p>
			<p>From the<a id="_idIndexMarker245"/> preceding code, we can see that sessions are created to implement the <strong class="source-inline">list_all_request</strong> and <strong class="source-inline">list_all_issuance</strong> <strong class="source-inline">GET</strong> client services. Here, <strong class="source-inline">request_borrow_book</strong> is a <strong class="source-inline">POST</strong> client service that requests a book in the form of <strong class="source-inline">BookRequestReq</strong> from the <strong class="source-inline">/ch04/library/book/request</strong> API endpoint. Similar to <strong class="source-inline">httpx</strong>, <strong class="source-inline">jsonable_encoder()</strong> and <strong class="source-inline">json.dumps()</strong> must be used to convert the <strong class="source-inline">BaseModel</strong> object into <strong class="source-inline">dict</strong> in order to be transported as a <strong class="source-inline">data</strong> parameter value. The same approach is also applied to the <strong class="source-inline">return_book</strong> <strong class="source-inline">POST</strong> client service, which returns the book borrowed by the faculty. The responses of these client services can also be <strong class="source-inline">content</strong> or <strong class="source-inline">json()</strong> just like what we have in the <strong class="source-inline">httpx</strong> extension.</p>
			<p>Using the <strong class="source-inline">requests</strong> and <strong class="source-inline">httpx</strong> modules allows these mounted microservices to interact with each other based on some specification. Consuming exposed endpoints from other microservices minimizes tight coupling and strengthens the importance of the decomposition design pattern of building independent microservices. </p>
			<p>The next technique gives you the option of managing components within a microservice using <em class="italic">domain modeling</em>.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>Applying the domain modeling approach</h1>
			<p>Applications<a id="_idIndexMarker246"/> that are database-focused or built from core functionalities without collaborating with models are either not easy to manage when they scale up or not friendly when enhanced or bug-fixed. The reason behind this is the absence of the structure and flow of business logic to follow, study, and analyze. Understanding the behavior of an application and deriving the domain models with the business logic behind them encompasses the best approach when it comes to establishing and organizing a structure in an application. This principle is called the <em class="italic">domain modeling approach</em>, which we will now apply to our ERP specimen.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Creating the layers</h1>
			<p>Layering is <a id="_idIndexMarker247"/>one implementation that is inevitable when applying domain-driven development. There is a dependency between <em class="italic">layers</em> that, sometimes, might pose problems when fixing bugs during development. But what are important in layered architectures are the concepts, structures, categories, functionalities, and roles that <em class="italic">layering</em> can create, which helps in understanding the specification of the application. <em class="italic">Figure 4.5</em> shows the <em class="italic">models</em>, <em class="italic">repositories</em>, <em class="italic">services</em>, and <em class="italic">controllers</em> of the sub-applications: </p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_4.5_B17975.jpg" alt="Figure 4.5 – Layered architecture&#13;&#10;"/>
				</div>
			</div>
			<p> </p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Layered architecture</p>
			<p>The most crucial layer is the <strong class="source-inline">models</strong> layer, which consists of the domain model classes that describe the domain and business processes involved in the application.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>Identifying the domain models</h1>
			<p>The <em class="italic">domain model layer</em> is the<a id="_idIndexMarker248"/> initial artifact of the application because it provides the contextual framework of the application. Business processes and transactions can be easily classified and <a id="_idIndexMarker249"/>managed if domains are first determined during the initial phase of the development. The code organization created by domain layering can provide code traceability, which can ease source code updates and debugging.</p>
			<p>In our ERP specimen, these models are categorized into two: the <em class="italic">data</em> and <em class="italic">request</em> models. The data models are those used to capture and store data in its temporary data stores, while the request models are the <strong class="source-inline">BaseModel</strong> objects used in the API services.</p>
			<p>For<a id="_idIndexMarker250"/> instance, the <em class="italic">faculty</em> module has the following data models:</p>
			<pre class="source-code">
class <strong class="bold">Assignment</strong>: 
    def __init__(self, assgn_id:int, title:str, 
        date_due:datetime, course:str):
        self.assgn_id:int = assgn_id 
        self.title:str = title 
        self.date_completed:datetime = None
        self.date_due:datetime = date_due
        self.rating:float = 0.0 
        self.course:str = course
        
    def __repr__(self): 
      return ' '.join([str(self.assgn_id), self.title,
        self.date_completed.strftime("%m/%d/%Y, %H:%M:%S"),
        self.date_due.strftime("%m/%d/%Y, %H:%M:%S"), 
        str(self.rating) ])
    def __expr__(self): 
      return ' '.join([str(self.assgn_id), self.title, 
       self.date_completed.strftime("%m/%d/%Y, %H:%M:%S"), 
       self.date_due.strftime("%m/%d/%Y, %H:%M:%S"), 
        str(self.rating) ])
class <strong class="bold">StudentBin</strong>: 
    def __init__(self, bin_id:int, stud_id:int, 
      faculty_id:int): 
        self.bin_id:int = bin_id 
        self.stud_id:int = stud_id 
        self.faculty_id:int = faculty_id 
        self.assignment:List[Assignment] = list()
        
    
    def __repr__(self): 
        return ' '.join([str(self.bin_id), 
         str(self.stud_id), str(self.faculty_id)])
    def __expr__(self): 
        return ' '.join([str(self.bin_id), 
         str(self.stud_id), str(self.faculty_id)])</pre>
			<p>These data model <a id="_idIndexMarker251"/>classes always have their constructors implemented if constructor injection is needed during instantiation. Moreover, the <strong class="source-inline">__repr__()</strong> and <strong class="source-inline">__str__()</strong> dunder methods are optionally there to provide efficiency for developers when accessing, reading, and logging these objects.</p>
			<p>On the other hand, the request models are familiar because they were already discussed in the <a id="_idIndexMarker252"/>previous chapter. Additionally, the <em class="italic">faculty</em> module has the following request models:</p>
			<pre class="source-code">
class <strong class="bold">SignupReq(BaseModel)</strong>:     
    faculty_id:int
    username:str
    password:str
class <strong class="bold">FacultyReq(BaseModel)</strong>: 
    faculty_id:int
    fname:str
    lname:str
    mname:str
    age:int
    major:Major
    department:str
class FacultyDetails(BaseModel): 
    fname:Optional[str] = None
    lname:Optional[str] = None
    mname:Optional[str] = None
    age:Optional[int] = None
    major:Optional[Major] = None
    department:Optional[str] = None</pre>
			<p>The request models listed in the preceding snippet are just simple <strong class="source-inline">BaseModel</strong> types. For <a id="_idIndexMarker253"/>further details on how to create <strong class="source-inline">BaseModel</strong> classes, <a href="B17975_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up FastAPI for Starters</em>, provides guidelines for creating different kinds of <strong class="source-inline">BaseModel</strong> classes to capture different requests from clients.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/>Building the repository and service layers</h1>
			<p>The two most popular domain modeling patterns that are crucial in building the layers of this approach are the <em class="italic">repository</em> and <em class="italic">service layer patterns</em>. The repository aims to create strategies<a id="_idIndexMarker254"/> for managing data access. Some repository<a id="_idIndexMarker255"/> layers only provide data connectivity to the data store like in our specimen here, but oftentimes, repository's goal is to interact with<a id="_idIndexMarker256"/> the <strong class="bold">Object Relational Model</strong> (<strong class="bold">ORM</strong>) framework to optimize and manage data transactions. But aside from the access, this layer provides a high-level abstraction for the application so that the specific database technology or <em class="italic">dialect</em> used will not matter to the applications. It serves as an adapter to any database platform to pursue data transactions for the application, nothing else. The following is a repository class of the <em class="italic">faculty</em> module, which manages the domain for creating assignments for their students:</p>
			<pre class="source-code">
from fastapi.encoders import jsonable_encoder
from typing import List, Dict, Any
<strong class="bold">from faculty_mgt.models.data.facultydb import </strong>
     <strong class="bold">faculty_assignments_tbl</strong>
<strong class="bold">from faculty_mgt.models.data.faculty import Assignment</strong>
from collections import namedtuple
class <strong class="bold">AssignmentRepository</strong>: 
      
    def <strong class="bold">insert_assignment</strong>(self, 
           assignment:Assignment) -&gt; bool: 
        try:
            faculty_assignments_tbl[assignment.assgn_id] = 
                assignment
        except: 
            return False 
        return True
    
    def <strong class="bold">update_assignment</strong>(self, assgn_id:int, 
           details:Dict[str, Any]) -&gt; bool: 
       try:
           assignment = faculty_assignments_tbl[assgn_id]
           assignment_enc = jsonable_encoder(assignment)
           assignment_dict = dict(assignment_enc)
           assignment_dict.update(details)         
           faculty_assignments_tbl[assgn_id] =   	 	 	           Assignment(**assignment_dict)
       except: 
           return False 
       return True
   
    def <strong class="bold">delete_assignment</strong>(self, assgn_id:int) -&gt; bool: 
        try:
            del faculty_assignments_tbl[assgn_id] 
        except: 
            return False 
        return True
    
    def <strong class="bold">get_all_assignment</strong>(self):
        return faculty_assignments_tbl </pre>
			<p>Here, <strong class="source-inline">AssignmentRepository</strong> manages the <strong class="source-inline">Assignment</strong> domain object using its four<a id="_idIndexMarker257"/> repository transactions. Additionally, <strong class="source-inline">insert_assignment()</strong> creates a new <strong class="source-inline">Assignment</strong> entry in the <strong class="source-inline">faculty_assignment_tbl</strong> dictionary, and <strong class="source-inline">update_assignment()</strong> accepts new details or the <a id="_idIndexMarker258"/>corrected information of an existing assignment and updates it. On the other hand, <strong class="source-inline">delete_assignment()</strong> deletes an existing <strong class="source-inline">Assignment</strong> entry from the data store using its <strong class="source-inline">assign_id</strong> parameter. To retrieve all the created assignments, the repository class has <strong class="source-inline">get_all_assignment()</strong>, which returns all the entries of <strong class="source-inline">faculty_assignments_tbl</strong>.</p>
			<p>The service layer pattern defines the algorithms, operations, and process flows of the applications. Oftentimes, it interacts with the repository to build the necessary business logic, management, and controls for the other components of the application, such as the API services or controllers. Usually, one service caters to one repository class or more depending on the specification of the project. The following code snippet is a service that interfaces a repository to provide additional tasks such as UUID generation for a student workbin:</p>
			<pre class="source-code">
from typing import List, Dict , Any
from faculty_mgt.repository.assignments import  
            AssignmentSubmissionRepository
from faculty_mgt.models.data.faculty import Assignment
from uuid import uuid4
class <strong class="bold">AssignmentSubmissionService</strong>: 
    
    def __init__(self): 
        <strong class="bold">self.repo:AssignmentSubmissionRepository = </strong>
            <strong class="bold">AssignmentSubmissionRepository()</strong>
        
    def <strong class="bold">create_workbin</strong>(self, stud_id:int, faculty_id:int): 
        <strong class="bold">bin_id = uuid4().int</strong>
        result = <strong class="bold">self.repo.create_bin</strong>(stud_id, bin_id, 
                     faculty_id )
        return (result, bin_id)
    
    def <strong class="bold">add_assigment</strong>(self, bin_id:int, 
                   assignment: Assignment): 
        result = <strong class="bold">self.repo.insert_submission</strong>(bin_id, 
                     assignment ) 
        return result
    
    def <strong class="bold">remove_assignment</strong>(self, bin_id:int, 
                   assignment: Assignment): 
        result = <strong class="bold">self.repo.insert_submission</strong>(bin_id, 
                      assignment )
        return result
    def <strong class="bold">list_assignments</strong>(self, bin_id:int): 
        return <strong class="bold">self.repo.get_submissions</strong>(bin_id)</pre>
			<p>The <strong class="source-inline">AssignmentSubmissionService</strong> cited in the preceding code has methods that utilize the <strong class="source-inline">AssignmentSubmissionRepository</strong> transactions. It provides them with<a id="_idIndexMarker259"/> parameters and returns the <strong class="source-inline">bool</strong> results for <a id="_idIndexMarker260"/>evaluation by other components. Other services might look more complicated than this sample because algorithms and tasks are usually added to pursue the requirements of the layers. </p>
			<p>The successful wiring of a repository class to the service happens in the latter’s constructor. Usually, the repository class is instantiated just like in the preceding sample. Another fantastic option is to use DI, as discussed in <a href="B17975_03.xhtml#_idTextAnchor052"><em class="italic">Chapter 3</em></a>.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor101"/>Using the factory method pattern</h2>
			<p>The <em class="italic">factory method design pattern</em> is always a <a id="_idIndexMarker261"/>good approach for managing injectable classes and functions using the <strong class="source-inline">Depends()</strong> component. <a href="B17975_03.xhtml#_idTextAnchor052"><em class="italic">Chapter 3</em></a> showcased factory methods as mediums to inject the repository components into the service instead of instantiating them directly within the service. The design pattern provides loose coupling between components or layers. This approach is highly applicable to large applications wherein some modules and sub-components are reused and inherited. </p>
			<p>Now, let us look at how the top-level application can manage the different configuration details of these mounted and independent microservice applications.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Managing a microservice’s configuration details</h1>
			<p>So far, this chapter <a id="_idIndexMarker262"/>has provided us with some popular design patterns and strategies that can give us a kickstart on how to provide our FastAPI microservices with the best structures and architecture. This time, let us explore how the FastAPI framework supports storing, assigning, and reading configuration details to mounted microservice applications such as database credentials, networking configuration data, application server information, and deployment details. First, we need to install <strong class="source-inline">python-dotenv</strong> using <strong class="source-inline">pip</strong>:</p>
			<p class="source-code">pip install python-dotenv</p>
			<p>All of these <a id="_idIndexMarker263"/>settings are values that are external to the implementation of the microservice applications. Instead of hardcoding them into the code as variable data, usually, we store them in the <em class="italic">env</em>, <em class="italic">property</em>, or <em class="italic">INI</em> files. However, challenges arise when assigning these settings to different microservices. </p>
			<p>Frameworks that support the <em class="italic">externalized configuration design pattern</em> have an internal processing feature that fetches environment variables or settings without requiring additional parsing or decoding techniques. For instance, the FastAPI framework has built-in support for externalized settings through pydantic’s <strong class="source-inline">BaseSettings</strong> class.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor103"/>Storing settings as class attributes</h2>
			<p>In our <a id="_idIndexMarker264"/>architecture setup, it should be the top-level application that will manage the externalized values. One way is to store them in a <strong class="source-inline">BaseSettings</strong> class as attributes. The following are classes of the <strong class="source-inline">BaseSettings</strong> type with their respective application details:</p>
			<pre class="source-code">
from pydantic import BaseSettings
from datetime import date
class <strong class="bold">FacultySettings(BaseSettings)</strong>: 
    <strong class="bold">application</strong>:str = 'Faculty Management System' 
    <strong class="bold">webmaster</strong>:str = 'sjctrags@university.com'
    <strong class="bold">created</strong>:date = '2021-11-10'
class <strong class="bold">LibrarySettings(BaseSettings)</strong>: 
    <strong class="bold">application</strong>:str = 'Library Management System' 
    <strong class="bold">webmaster</strong>:str = 'sjctrags@university.com'
    <strong class="bold">created</strong>:date = '2021-11-10' 
class <strong class="bold">StudentSettings(BaseSettings)</strong>: 
    <strong class="bold">application</strong>:str = 'Student Management System' 
    <strong class="bold">webmaster</strong>:str = 'sjctrags@university.com'
    <strong class="bold">created</strong>:date = '2021-11-10'</pre>
			<p>Here, <strong class="source-inline">FacultySettings</strong> will be assigned to the <em class="italic">f</em><em class="italic">aculty</em> module since it carries some information <a id="_idIndexMarker265"/>regarding the module. <strong class="source-inline">LibrarySettings</strong> is for the <em class="italic">library</em> module to utilize, while <strong class="source-inline">StudentSettings</strong> is for the <em class="italic">student</em> module. </p>
			<p>To fetch the values, first, a component in a module must import the <strong class="source-inline">BaseSettings</strong> class from the main project’s <strong class="source-inline">/configuration/config.py</strong> module. Then, it needs an injectable function to instantiate it before injecting it into a component that needs to utilize the values. The following script is part of  <strong class="source-inline">/student_mgt/student_main.py</strong>, where the settings need to be retrieved: </p>
			<pre class="source-code">
<strong class="bold">from configuration.config import StudentSettings</strong>
student_app = FastAPI()
student_app.include_router(reservations.router)
student_app.include_router(admin.router)
student_app.include_router(assignments.router)
student_app.include_router(books.router)
<strong class="bold">def build_config(): </strong>
    <strong class="bold">return StudentSettings()</strong>
@student_app.get('/index')
def index_student(
   <strong class="bold">config:StudentSettings = Depends(build_config)</strong>): 
    return {
        'project_name': <strong class="bold">config.application</strong>,
        'webmaster': <strong class="bold">config.webmaster</strong>,
        'created': <strong class="bold">config.created</strong>
      }</pre>
			<p>Here, <strong class="source-inline">build_config()</strong> is an <a id="_idIndexMarker266"/>injectable function that injects the <strong class="source-inline">StudentSettings</strong> instance into the <strong class="source-inline">/index</strong> endpoint of the <em class="italic">s</em><em class="italic">tudent</em> microservice. After the DI, the application, webmaster, and created values will become accessible from the <strong class="source-inline">config</strong> wired object. These settings will appear on the browser right after calling the <strong class="source-inline">/ch04/university/1</strong> gateway URL.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>Storing settings in the properties file</h2>
			<p>Another option is to <a id="_idIndexMarker267"/>store all these settings inside a physical file with an extension of <strong class="source-inline">.env</strong>, <strong class="source-inline">.properties</strong>, or <strong class="source-inline">.ini</strong>. For instance, this project has the <strong class="source-inline">erp_settings.properties</strong> file found in the <strong class="source-inline">/configuration</strong> folder, and it contains the following application server details in <em class="italic">key-value</em> pair format:</p>
			<pre class="source-code">
<strong class="bold">production_server</strong> = prodserver100
<strong class="bold">prod_port</strong> = 9000
<strong class="bold">development_server</strong> = devserver200
<strong class="bold">dev_port</strong> = 10000</pre>
			<p>To fetch these details, the application needs another <strong class="source-inline">BaseSettings</strong> class implementation that declares the <em class="italic">key</em> of the <em class="italic">key-value</em> pair as attributes. The following class shows how <strong class="source-inline">production_server</strong>, <strong class="source-inline">prod_port</strong>, <strong class="source-inline">development_server</strong>, and <strong class="source-inline">dev_port</strong> are declared without any assigned values:</p>
			<pre class="source-code">
import os
class ServerSettings(BaseSettings): 
    <strong class="bold">production_server:str</strong>
    <strong class="bold">prod_port:int</strong>
    <strong class="bold">development_server:str </strong>
    <strong class="bold">dev_port:int</strong>
    
    class Config: 
        env_file = os.getcwd() + 
           '/configuration/erp_settings.properties'</pre>
			<p>Aside from the class variable declaration, <strong class="source-inline">BaseSetting</strong> requires an implementation of an <em class="italic">inner class</em>, called <strong class="source-inline">Config</strong>, with a predefined <strong class="source-inline">env_file</strong> assigned to the current location of the properties file. </p>
			<p>The <a id="_idIndexMarker268"/>same processes are involved when it comes to accessing the property details from the file. After importing <strong class="source-inline">ServerSettings</strong>, it needs an injectable function to inject its instance to the components that need the details. The following script is an updated version of <strong class="source-inline">/student_mgt/student_main.py</strong>, which includes access to the <strong class="source-inline">development_server</strong> and <strong class="source-inline">development_port</strong> settings:</p>
			<pre class="source-code">
from fastapi import FastAPI, Depends
from configuration.config import StudentSettings, 
      <strong class="bold">ServerSettings</strong>
student_app = FastAPI()
student_app.include_router(reservations.router)
student_app.include_router(admin.router)
student_app.include_router(assignments.router)
student_app.include_router(books.router)
def build_config(): 
    return StudentSettings()
<strong class="bold">def fetch_config():</strong>
    <strong class="bold">return ServerSettings()</strong>
@student_app.get('/index')
def index_student(
     config:StudentSettings = Depends(build_config), 
     fconfig:ServerSettings = Depends(fetch_config)): 
    return {
        'project_name': config.application,
        'webmaster': config.webmaster,
        'created': config.created,
        <strong class="bold">'development_server' : fconfig.development_server</strong>,
        <strong class="bold">'dev_port': fconfig.dev_port</strong>
      }</pre>
			<p>Based on<a id="_idIndexMarker269"/> this enhanced script, running the <strong class="source-inline">/ch04/university/1</strong> URL will redirect the browser to a screen showing additional server details from the properties file. Managing configuration details in FastAPI is easy, as we either save them inside a class or inside a file. No external module is necessary, and no special coding effort is required to fetch all these settings, just the creation of the <strong class="source-inline">BaseSettings</strong> classes. This easy setup contributes to building flexible and adaptable microservice applications that can run on varying configuration details.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor105"/>Summary</h1>
			<p>The chapter started with the decomposition pattern, which is useful for breaking down a monolithic application into granularized, independent, and scalable modules. The FastAPI application that implemented these modules exhibited some principles included in the <em class="italic">12-Factor Application principles</em> of a microservice, such as having independence, configuration files, logging systems, code bases, port binding, concurrency, and easy deployment.</p>
			<p>Alongside decomposition, this chapter also showcased the <em class="italic">mounting of different independent sub-applications</em> onto the FastAPI platform. Only FastAPI can group independent microservices using mounts and bind them into one port with their corresponding context roots. From this feature, we created a pseudo-API Gateway pattern that serves as a façade to the independent sub-applications.</p>
			<p>Despite the possible drawbacks, the chapter also highlighted domain modeling as an option for organizing components in a FastAPI microservice. The <em class="italic">domain</em>, <em class="italic">repository</em>, and <em class="italic">service</em> layers help manage the information flow and task distribution based on the project specification. Tracing, testing, and debugging are easy when domain layers are in place.</p>
			<p>In the next chapter, we will focus on integrating our microservice applications with a relational database platform. The focus is to establish database connectivity and utilize our data models to implement CRUD transactions within the repository layer. </p>
		</div>
		<div>
			<div id="_idContainer028">
			</div>
		</div>
	

		<div id="_idContainer029" class="Content">
			<h1 id="_idParaDest-106"><a id="_idTextAnchor106"/>Part 2: Data-Centric and Communication-Focused Microservices Concerns and Issues</h1>
			<p>In this part of the book, we will be exploring other FastAPI components and features to solve other design patterns that the API framework can build, looking at data, communication, messaging, reliability, and security. External modules will also be highlighted in order to pursue other behavior and frameworks, such as ORM and reactive programming. </p>
			<p>This part comprises the following chapters:</p>
			<ul>
				<li><a href="B17975_05.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a>, Connecting to a Relational Database </li>
				<li><a href="B17975_06.xhtml#_idTextAnchor155"><em class="italic">Chapter 6</em></a>, Using a Non-Relational Database </li>
				<li><a href="B17975_07.xhtml#_idTextAnchor190"><em class="italic">Chapter 7</em></a>, Securing the REST APIs </li>
				<li><a href="B17975_08.xhtml#_idTextAnchor229"><em class="italic">Chapter 8</em></a>, Creating Coroutines, Events, and Message-Driven Transactions</li>
			</ul>
		</div>
		<div>
			<div id="_idContainer030">
			</div>
		</div>
	</body></html>