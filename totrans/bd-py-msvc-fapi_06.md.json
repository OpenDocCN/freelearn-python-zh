["```py\npip install pymongo \n```", "```py\nfrom pymongo import MongoClient\ndef create_db_collections():\n    client = MongoClient('mongodb://localhost:27017/')\n    try:\n        db = client.obrs\n        buyers = db.buyer\n        users = db.login\n        print(\"connect\")\n        yield {\"users\": users, \"buyers\": buyers}\n    finally:\n        client.close()\n```", "```py\n{\n   _id:ObjectId(\"61e7a49c687c6fd4abfc81fa\"),\n   id:1,\n   user_id:10,\n   date_purchased:\"2022-01-19T00:00:00.000000\",\n   purchase_history: \n   [\n       {\n        purchase_id:100,\n        shipping_address:\"Makati City\",\n        email:\"mailer@yahoo.com\",\n        date_purchased:\"2022-01-19T00:00:00.000000\",\n        date_shipped:\"2022-01-19T00:00:00.000000\",\n        date_payment:\"2022-01-19T00:00:00.000000\"\n      },\n      {\n        purchase_id:110,\n        shipping_address:\"Pasig City\",\n        email:\"edna@yahoo.com\",\n        date_purchased:\"2022-01-19T00:00:00.000000\",\n        date_shipped:\"2022-01-19T00:00:00.000000\",\n        date_payment:\"2022-01-19T00:00:00.000000\"\n      }\n    ],\n   customer_status: \n   {\n        status_id:90,\n        name:\"Sherwin John C. Tragura\",\n        discount:50,\n        date_membership:\"2022-01-19T00:00:00.000000\"\n   }\n}\n```", "```py\npip install bson\n```", "```py\n from pydantic import BaseModel, validator\nfrom typing import List, Optional, Dict\nfrom bson import ObjectId\nfrom datetime import date\nclass PurchaseHistoryReq(BaseModel):\n    purchase_id: int\n    shipping_address: str \n    email: str   \n    date_purchased: date\n    date_shipped: date\n    date_payment: date\n    @validator('date_purchased')\n    def date_purchased_datetime(cls, value):\n        return datetime.strptime(value, \n           \"%Y-%m-%dT%H:%M:%S\").date()\n\n    @validator('date_shipped')\n    def date_shipped_datetime(cls, value):\n        return datetime.strptime(value, \n           \"%Y-%m-%dT%H:%M:%S\").date()\n\n    @validator('date_payment')\n    def date_payment_datetime(cls, value):\n        return datetime.strptime(value, \n           \"%Y-%m-%dT%H:%M:%S\").date()\n\n    class Config:\n        arbitrary_types_allowed = True\n        json_encoders = {\n            ObjectId: str\n        }\n\nclass PurchaseStatusReq(BaseModel):\n    status_id: int \n    name: str\n    discount: float \n    date_membership: date\n    @validator('date_membership')\n    def date_membership_datetime(cls, value):\n        return datetime.strptime(value, \n            \"%Y-%m-%dT%H:%M:%S\").date()\n\n    class Config:\n        arbitrary_types_allowed = True\n        json_encoders = {\n            ObjectId: str\n        }\n\nclass BuyerReq(BaseModel):\n    _id: ObjectId\n    Buyer_id: int\n    user_id: int\n    date_purchased: date\n    purchase_history: List[Dict] = list()\n    customer_status: Optional[Dict]\n    @validator('date_purchased')\n    def date_purchased_datetime(cls, value):\n        return datetime.strptime(value, \n            \"%Y-%m-%dT%H:%M:%S\").date()\n\n    class Config:\n        arbitrary_types_allowed = True\n        json_encoders = {\n            ObjectId: str\n        }\n```", "```py\nfrom pydantic.dataclasses import dataclass\nfrom dataclasses import field\nfrom pydantic import validator\nfrom datetime import date, datetime\nfrom bson import ObjectId\nfrom typing import List, Optional\nclass Config:\n        arbitrary_types_allowed = True\n@dataclass(config=Config)\nclass PurchaseHistory:\n    purchase_id: Optional[int] = None\n    shipping_address: Optional[str] = None\n    email: Optional[str] = None   \n    date_purchased: Optional[date] = \"1900-01-01T00:00:00\"\n    date_shipped: Optional[date] = \"1900-01-01T00:00:00\"\n    date_payment: Optional[date] = \"1900-01-01T00:00:00\"\n\n    @validator('date_purchased', pre=True)\n    def date_purchased_datetime(cls, value):\n        return datetime.strptime(value, \n           \"%Y-%m-%dT%H:%M:%S\").date()\n\n    @validator('date_shipped', pre=True)\n    def date_shipped_datetime(cls, value):\n        return datetime.strptime(value, \n           \"%Y-%m-%dT%H:%M:%S\").date()\n\n    @validator('date_payment', pre=True)\n    def date_payment_datetime(cls, value):\n        return datetime.strptime(value, \n           \"%Y-%m-%dT%H:%M:%S\").date()\n@dataclass(config=Config)\nclass PurchaseStatus:\n    status_id: Optional[int] = None\n    name: Optional[str] = None\n    discount: Optional[float] = None\n    date_membership: Optional[date] = \"1900-01-01T00:00:00\"\n\n    @validator('date_membership', pre=True)\n    def date_membership_datetime(cls, value):\n        return datetime.strptime(value, \n           \"%Y-%m-%dT%H:%M:%S\").date()\n\n@dataclass(config=Config)\nclass Buyer:\n    buyer_id: int \n    user_id: int \n    date_purchased: date \n    purchase_history: List[PurchaseHistory] = \n          field(default_factory=list )\n    customer_status: Optional[PurchaseStatus] = \n          field(default_factory=dict)\n    _id: ObjectId = field(default=ObjectId())\n\n    @validator('date_purchased', pre=True)\n    def date_purchased_datetime(cls, value):\n        print(type(value))\n        return datetime.strptime(value, \n             \"%Y-%m-%dT%H:%M:%S\").date()\n```", "```py\nfrom typing import Dict, Any\nclass BuyerRepository: \n\n    def __init__(self, buyers): \n        self.buyers = buyers\n\n    def insert_buyer(self, users, \n          details:Dict[str, Any]) -> bool: \n        try:\n           user = users.find_one(\n                {\"_id\": details[\"user_id\"]})\n           print(user)\n           if user == None:\n               return False\n           else: \n               self.buyers.insert_one(details)\n\n        except Exception as e:\n            return False \n        return True\n```", "```py\n    def update_buyer(self, id:int, \n              details:Dict[str, Any]) -> bool: \n       try:\n          self.buyers.update_one({\"buyer_id\": id},\n                  {\"$set\":details})\n       except: \n           return False \n       return True\n\n    def delete_buyer(self, id:int) -> bool: \n        try:\n            self.buyers.delete_one({\"buyer_id\": id})\n        except: \n            return False \n        return True\n```", "```py\nfrom dataclasses import asdict\nfrom models.data.pymongo import Buyer\nfrom datetime import datetime\nfrom bson.json_util import dumps\nimport json\n    … … …\n    … … …  \n    … … …\n    def get_all_buyer(self):\n        buyers = [asdict(Buyer(**json.loads(dumps(b)))) \n              for b in self.buyers.find()]\n        return buyers\n\n    def get_buyer(self, id:int): \n        buyer = self.buyers.find_one({\"buyer_id\": id})\n        return asdict(Buyer(**json.loads(dumps(buyer))))\n```", "```py\nbuyer[\"purchase_history\"].append(new  DBRef(\"purchase_history\", \"49a3e4e5f462204490f70911\"))\n```", "```py\nbuyer.find({ \"purchase_history \": DBRef(\"purchase_history\",ObjectId(\"49a3e4e5f462204490f70911\")) })\n```", "```py\ndef add_purchase_history(self, id:int, \n                details:Dict[str, Any]): \n        try:\n            buyer = self.buyers.find_one({\"buyer_id\": id})\n            buyer[\"purchase_history\"].append(details)\n            self.buyers.update_one({\"buyer_id\": id},\n           {\"$set\": {\"purchase_history\": \n                     buyer[\"purchase_history\"]}})\n        except Exception as e: \n           return False \n        return True\n\n    def add_customer_status(self, id:int, \n                  details:Dict[str, Any]): \n        try:\n            buyer = self.buyers.find_one({\"buyer_id\": id})\n            self.buyers.update_one({\"buyer_id\": id},\n                {\"$set\":{\"customer_status\": details}})\n        except Exception as e: \n           return False \n        return True\n```", "```py\nfrom fastapi import APIRouter, Depends\nfrom fastapi.responses import JSONResponse\nfrom models.request.buyer import BuyerReq, \n      PurchaseHistoryReq, PurchaseStatusReq\nfrom repository.pymongo.buyer import BuyerRepository\nfrom db_config.pymongo_config import create_db_collections\nfrom datetime import date, datetime\nfrom json import dumps, loads\nfrom bson import ObjectId\nrouter = APIRouter()\ndef json_serialize_date(obj):\n    if isinstance(obj, (date, datetime)):\n        return obj.strftime('%Y-%m-%dT%H:%M:%S')\n    raise TypeError (\"The type %s not serializable.\" % \n            type(obj))\ndef json_serialize_oid(obj):\n    if isinstance(obj, ObjectId):\n        return str(obj)\n    elif isinstance(obj, date):\n        return obj.isoformat()\n    raise TypeError (\"The type %s not serializable.\" % \n            type(obj))\n@router.post(\"/buyer/add\")\ndef add_buyer(req: BuyerReq, \n            db=Depends(create_db_collections)): \n    buyer_dict = req.dict(exclude_unset=True)\n    buyer_json = dumps(buyer_dict, \n              default=json_serialize_date)\n    repo:BuyerRepository = BuyerRepository(db[\"buyers\"])\n    result = repo.insert_buyer(db[\"users\"], \n            loads(buyer_json))  \n\n    if result == True: \n        return JSONResponse(content={\"message\": \n          \"add buyer successful\"}, status_code=201) \n    else: \n        return JSONResponse(content={\"message\": \n          \"add buyer unsuccessful\"}, status_code=500) \n@router.patch(\"/buyer/update\")\ndef update_buyer(id:int, req:BuyerReq, \n           db=Depends(create_db_collections)): \n    buyer_dict = req.dict(exclude_unset=True)\n    buyer_json = dumps(buyer_dict, \n             default=json_serialize_date)\n    repo:BuyerRepository = BuyerRepository(db[\"buyers\"])\n    result = repo.update_buyer(id, loads(buyer_json))  \n\n    if result == True: \n        return JSONResponse(content={\"message\": \n         \"update buyer successful\"}, status_code=201) \n    else: \n        return JSONResponse(content={\"message\": \n         \"update buyer unsuccessful\"}, status_code=500)\n@router.post(\"/buyer/history/add\")\ndef add_purchase_history(id:int, req:PurchaseHistoryReq, \n           db=Depends(create_db_collections)): \n    history_dict = req.dict(exclude_unset=True)\n    history_json = dumps(history_dict, \n           default=json_serialize_date)\n    repo:BuyerRepository = BuyerRepository(db[\"buyers\"])\n    result = repo.add_purchase_history(id, \n           loads(history_json))  \n```", "```py\n@router.get(\"/buyer/list/all\")\ndef list_all_buyer(db=Depends(create_db_collections)): \n  repo:BuyerRepository = BuyerRepository(db[\"buyers\"])\n  buyers = repo.get_all_buyer() \n  return loads(dumps(buyers, default=json_serialize_oid))\n@router.get(\"/buyer/get/{id}\")\ndef get_buyer(id:int, db=Depends(create_db_collections)): \n  repo:BuyerRepository = BuyerRepository(db[\"buyers\"])\n  buyer = repo.get_buyer(id)\n  return loads(dumps(buyer, default=json_serialize_oid))\n```", "```py\npip install motor\n```", "```py\nfrom motor.motor_asyncio import AsyncIOMotorClient\ndef create_async_db():\n    global client\n    client = AsyncIOMotorClient(str(\"localhost:27017\"))\ndef create_db_collections():\n    db = client.obrs\n    buyers = db[\"buyer\"]\n    users = db[\"login\"]\n    return {\"users\": users, \"buyers\": buyers}\ndef close_async_db(): \n    client.close()\n```", "```py\nclass BuyerRepository: \n\n    def __init__(self, buyers): \n        self.buyers = buyers\n\n    async def insert_buyer(self, users, \n           details:Dict[str, Any]) -> bool: \n        try:\n           user = await users.find_one({\"_id\": \n                details[\"user_id\"]})\n           … … … … …\n           else: \n               await self.buyers.insert_one(details)\n           … … … … …\n        return True\n\n    async def add_purchase_history(self, id:int, \n            details:Dict[str, Any]): \n        try:\n            … … … … …\n            await self.buyers.update_one({\"buyer_id\": id},\n                   {\"$set\":{\"purchase_history\": \n                     buyer[\"purchase_history\"]}})\n            … … … … …\n        return True\n```", "```py\n    async def get_all_buyer(self):\n        cursor = self.buyers.find()\n        buyers = [asdict(Buyer(**json.loads(dumps(b)))) \n           for b in await cursor.to_list(length=None)]\n        return buyers\n\n    async def get_buyer(self, id:int): \n        buyer = await self.buyers.find_one(\n                    {\"buyer_id\": id})\n        return asdict(Buyer(**json.loads(dumps(buyer))))\n```", "```py\n… … … … … …\nfrom db_config.motor_config import create_async_db,\n  create_db_collections, close_async_db\n… … … … … …\nrouter = APIRouter()\nrouter.add_event_handler(\"startup\", \n            create_async_db)\nrouter.add_event_handler(\"shutdown\", \n            close_async_db)\n```", "```py\n@router.post(\"/buyer/async/add\")\nasync def add_buyer(req: BuyerReq, \n          db=Depends(create_db_collections)): \n    buyer_dict = req.dict(exclude_unset=True)\n    buyer_json = dumps(buyer_dict, \n              default=json_serialize_date)\n    repo:BuyerRepository = BuyerRepository(db[\"buyers\"])\n\n    result = await repo.insert_buyer(db[\"users\"], \n                  loads(buyer_json))  \n    if result == True: \n        return JSONResponse(content={\"message\":\n            \"add buyer successful\"}, status_code=201) \n    else: \n        return JSONResponse(content={\"message\": \n            \"add buyer unsuccessful\"}, status_code=500)\n```", "```py\npip install mongoengine\n```", "```py\nfrom mongoengine import connect\ndef create_db():\n    try:\n        db = connect(db=\"obrs\", host=\"localhost\", \n                 port=27017)\n        yield db\n    finally: \n        db.close()\n```", "```py\nfrom mongoengine import Document, StringField, \n         SequenceField, EmbeddedDocumentField\nimport json\nclass Login(Document): \n    id = SequenceField(required=True, primary_key=True)\n    username = StringField(db_field=\"username\", \n         max_length=50, required=True, unique=True)\n    password = StringField(db_field=\"password\", \n         max_length=50, required=True)\n    profile = EmbeddedDocumentField(UserProfile, \n         required=False)\n\n    def to_json(self):\n            return {\n            \"id\": self.id,\n            \"username\": self.username,\n            \"password\": self.password,\n            \"profile\": self.profile\n        }\n\n    @classmethod\n    def from_json(cls, json_str):\n        json_dict = json.loads(json_str)\n        return cls(**json_dict)\n```", "```py\nTried to save duplicate unique keys (E11000 duplicate key error collection: obrs.login index: username_...)\n```", "```py\nclass UserProfile(EmbeddedDocument):\n   firstname = StringField(db_field=\"firstname\", \n          max_length=50, required=True)\n   lastname = StringField(db_field=\"lastname\", \n          max_length=50, required=True)\n   middlename = StringField(db_field=\"middlename\", \n          max_length=50, required=True)\n   position = StringField(db_field=\"position\", \n          max_length=50, required=True)\n   date_approved = DateField(db_field=\"date_approved\", \n          required=True)\n   status = BooleanField(db_field=\"status\", required=True)\n   level = IntField(db_field=\"level\", required=True)\n   login_id = IntField(db_field=\"login_id\", required=True)\n   booksale = EmbeddedDocumentListField(BookForSale, \n           required=False)\n\n   def to_json(self):\n            return {\n            \"firstname\": self.firstname,\n            \"lastname\": self.lastname,\n            \"middlename\": self.middlename,\n            \"position\": self.position,\n            \"date_approved\": \n               self.date_approved.strftime(\"%m/%d/%Y\"),\n            \"status\": self.status,\n            \"level\": self.level,\n            \"login_id\": self.login_id,\n            \"books\": self.books\n        }\n\n   @classmethod\n   def from_json(cls, json_str):\n        json_dict = json.loads(json_str)\n        return cls(**json_dict)\n```", "```py\nfrom typing import Dict, Any\nfrom models.data.mongoengine import Login\nclass LoginRepository: \n\n    def insert_login(self, details:Dict[str, Any]) -> bool: \n        try:\n            login = Login(**details)\n            login.save()\n        except Exception as e:\n            print(e)\n            return False \n        return True\n\n    def update_password(self, id:int, newpass:str) -> bool: \n       try:\n          login = Login.objects(id=id).get()\n          login.update(password=newpass)\n       except: \n           return False \n       return True\n\n    def delete_login(self, id:int) -> bool: \n        try:\n            login = Login.objects(id=id).get()\n            login.delete()\n        except: \n            return False \n        return True\n```", "```py\n    def get_all_login(self):\n        login = Login.objects()\n        login_list = [l.to_json() for l in login]\n        return login_list\n\n    def get_login(self, id:int): \n        login = Login.objects(id=id).get()\n        return login.to_json()\n```", "```py\nfrom typing import Dict, Any\nfrom models.data.mongoengine import Login, UserProfile, \n      BookForSale\nclass UserProfileRepository(): \n\n    def insert_profile(self, login_id:int, \n             details:Dict[str, Any]) -> bool: \n        try:\n            profile = UserProfile(**details)\n            login = Login.objects(id=login_id).get()\n            login.update(profile=profile)\n        except Exception as e:\n            print(e)\n            return False \n        return True\n\n    def add_book_sale(self, login_id:int, \n             details:Dict[str, Any]): \n        try:\n            sale = BookForSale(**details)\n            login = Login.objects(id=login_id).get()\n            login.profile.booksale.append(sale) \n            login.update(profile=login.profile)\n        except Exception as e:\n            print(e)\n            return False \n        return True\n```", "```py\n     def get_all_profile(self):\n        profiles = Login.objects.filter(\n               profile__login_id__exists=True)\n        profiles_dict = list(\n              map(lambda h: h.profile.to_json(), \n                Login.objects().filter(\n                    profile__login_id__exists=True)))\n        return profiles_dict\n\n    def get_profile(self, login_id:int): \n        login = Login.objects(id=login_id).get()\n        profile = login.profile.to_json()\n        return profile\n```", "```py\nfrom fastapi import APIRouter, Depends\nfrom fastapi.responses import JSONResponse\nfrom models.request.profile import UserProfileReq, \n         BookForSaleReq\nfrom repository.mongoengine.profile import \n         UserProfileRepository\nfrom db_config.mongoengine_config import create_db\nrouter = APIRouter()\n@router.post(\"/profile/login/add\", \n      dependencies=[Depends(create_db)])\ndef create_profile(login_id:int, req:UserProfileReq): \n    profile_dict = req.dict(exclude_unset=True)\n    repo:UserProfileRepository = UserProfileRepository()\n    result = repo.insert_profile(login_id, profile_dict)\n    if result == True: \n        return req \n    else: \n        return JSONResponse(content={\"message\": \n          \"insert profile unsuccessful\"}, status_code=500) \n```", "```py\npip install beanie\n```", "```py\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom beanie import init_beanie\nfrom models.data.beanie import Cart, Order, Receipt\nasync def db_connect():\n    global client\n    client = \n     AsyncIOMotorClient(f\"mongodb://localhost:27017/obrs\")\n    await init_beanie(client.obrs, \n         document_models=[Cart, Order, Receipt])\n\nasync def db_disconnect():\n     client.close()\n```", "```py\nfrom typing import Optional, List\nfrom beanie import Document\nfrom bson import datetime \nclass Cart(Document):\n    id: int \n    book_id: int \n    user_id: int\n    qty: int\n    date_carted: datetime.datetime\n    discount: float\n\n    class Collection:\n        name = \"cart\"\n    … … … … … …\n\nclass Order(Document):\n    id: int \n    user_id: int\n    date_ordered: datetime.datetime\n    orders: List[Cart] = list()\n\n    class Collection:\n        name = \"order\"\n    … … … … … …\n\nclass Receipt(Document): \n    id: int \n    date_receipt: datetime.datetime \n    total: float \n    payment_mode: int\n    order: Optional[Order] = None\n\n    class Collection:\n        name = \"receipt\"\n    class Settings:\n        use_cache = True\n        cache_expiration_time =    \n             datetime.timedelta(seconds=10)\n        cache_capacity = 10\n```", "```py\nfrom typing import Dict, Any\nfrom models.data.beanie import Cart\nclass CartRepository: \n\n    async def add_item(self, \n             details:Dict[str, Any]) -> bool: \n        try:\n            receipt = Cart(**details)\n            await receipt.insert()\n        except Exception as e:\n            print(e)\n            return False \n        return True\n\n    async def update_qty(self, id:int, qty:int) -> bool: \n       try:\n          cart = await Cart.get(id)\n          await cart.set({Cart.qty:qty})\n       except: \n           return False \n       return True\n\n    async def delete_item(self, id:int) -> bool: \n        try:\n            cart = await Cart.get(id)\n            await cart.delete()\n        except: \n            return False \n        return True\n```", "```py\nasync def get_cart_items(self):\n        return await Cart.find_all().to_list()\n\n    async def get_items_user(self, user_id:int): \n        return await Cart.find(\n              Cart.user_id == user_id).to_list()\n\n    async def get_item(self, id:int): \n        return await Cart.get(id)\n```", "```py\nfrom repository.beanie.cart import CartRepository\nfrom db_config.beanie_config import db_connect\nrouter = APIRouter(dependencies=[Depends(db_connect)])\n@router.post(\"/cart/add/item\")\nasync def add_cart_item(req:CartReq): \n    repo:CartRepository = CartRepository()\n    result = await repo.add_item(loads(cart_json))\n          \"insert cart unsuccessful\"}, status_code=500)\n```", "```py\npip install odmantic\n```", "```py\nfrom odmantic import AIOEngine\nfrom motor.motor_asyncio import AsyncIOMotorClient\ndef create_db_connection():\n   global client_od\n   client_od = \n     AsyncIOMotorClient(f\"mongodb://localhost:27017/\")\ndef create_db_engine():\n   engine = AIOEngine(motor_client=client_od, \n         database=\"obrs\")\n   return engine\ndef close_db_connection():\n    client_od.close() \n```", "```py\nfrom odmantic import Model\nfrom bson import datetime\nclass Purchase(Model): \n    purchase_id: int\n    buyer_id: int \n    book_id: int \n    items: int \n    price: float \n    date_purchased: datetime.datetime\n\n    class Config:\n        collection = \"purchase\"\n```", "```py\nfrom typing import List, Dict, Any\nfrom models.data.odmantic import Purchase\nclass PurchaseRepository: \n\n    def __init__(self, engine): \n        self.engine = engine\n\n    async def insert_purchase(self, \n              details:Dict[str, Any]) -> bool: \n        try:\n           purchase = Purchase(**details)\n           await self.engine.save(purchase)\n\n        except Exception as e:\n            print(e)\n            return False \n        return True\n```", "```py\n    async def update_purchase(self, id:int, \n              details:Dict[str, Any]) -> bool: \n       try:\n          purchase = await self.engine.find_one(\n                Purchase, Purchase.purchase_id == id)\n\n          for key,value in details.items():\n            setattr(purchase,key,value)\n\n          await self.engine.save(purchase)\n       except Exception as e:\n           print(e) \n           return False \n       return True\n```", "```py\n     async def delete_purchase(self, id:int) -> bool: \n        try:\n            purchase = await self.engine.find_one(\n                Purchase, Purchase.purchase_id == id) \n            await self.engine.delete(purchase)\n        except: \n            return False \n        return True\n```", "```py\n    async def get_all_purchase(self):\n        purchases = await self.engine.find(Purchase)\n        return purchases\n\n    async def get_purchase(self, id:int): \n        purchase = await self.engine.find_one(\n            Purchase, Purchase.purchase_id == id) \n        return purchase\n```", "```py\nfrom fastapi import APIRouter, Depends\nfrom fastapi.responses import JSONResponse\nfrom models.request.purchase import PurchaseReq\nfrom repository.odmantic.purchase import PurchaseRepository\nfrom db_config.odmantic_config import create_db_engine, \n    create_db_connection, close_db_connection\nfrom datetime import date, datetime\nfrom json import dumps, loads\nrouter = APIRouter()\nrouter.add_event_handler(\"startup\", create_db_connection)\nrouter.add_event_handler(\"shutdown\", close_db_connection)\n@router.post(\"/purchase/add\")\nasync def add_purchase(req: PurchaseReq, \n          engine=Depends(create_db_engine)): \n     purchase_dict = req.dict(exclude_unset=True) \n     purchase_json = dumps(purchase_dict, \n                default=json_serial)\n     repo:PurchaseRepository = PurchaseRepository(engine)\n     result = await \n            repo.insert_purchase(loads(purchase_json))\n     if result == True: \n        return req \n     else: \n        return JSONResponse(content={\"message\": \n          \"insert purchase unsuccessful\"}, status_code=500)\n     return req\n```", "```py\npip install MongoFrames\n```", "```py\nfrom pymongo import MongoClient\nfrom mongoframes import Frame\ndef create_db_client():\n    Frame._client = \n        MongoClient('mongodb://localhost:27017/obrs')\n\ndef disconnect_db_client():\n    Frame._client.close()\n```", "```py\nfrom mongoframes import Frame, SubFrame\nclass Book(Frame):\n    _fields = {\n        'id ',\n        'isbn',\n        'author', \n        'date_published', \n        'title', \n        'edition',\n        'price',\n        'category'\n    }\n    _collection = \"book\"\n\nclass Category(SubFrame):\n\n    _fields = {\n        'id',\n        'name',\n        'description',\n        'date_added'\n        }\n\n    _collection = \"category\"\nclass Reference(Frame):\n    _fields = {\n        'id',\n        'name',\n        'description',\n        'categories'\n        }\n\n    _collection = \"reference\"\n```", "```py\nfrom mongoframes.factory.makers import Q\nfrom models.data.mongoframe import Book, Category\nfrom typing import List, Dict, Any\nclass BookRepository: \n    def insert_book(self, \n             details:Dict[str, Any]) -> bool: \n        try:\n           book = Book(**details)\n           book.insert()\n\n        except Exception as e:\n            return False \n        return True\n```", "```py\n    def update_book(self, id:int, \n            details:Dict[str, Any]) -> bool: \n       try:\n        book = Book.one(Q.id == id)\n        for key,value in details.items():\n            setattr(book,key,value)\n        book.update()\n       except: \n           return False \n       return True\n```", "```py\n    def delete_book(self, id:int) -> bool: \n        try:\n           book = Book.one(Q.id == id)\n           book.delete()\n        except: \n            return False \n        return True\n```", "```py\n    def get_all_book(self):\n        books = [b.to_json_type() for b in Book.many()]\n        return books\n\n    def get_book(self, id:int): \n        book = Book.one(Q.id == id).to_json_type()\n        return book\n```", "```py\n    def add_category(self, id:int, \n               category:Category) -> bool: \n       try:\n        book = Book.one(Q.id == id)\n        book.category = category\n        book.update()\n       except: \n           return False \n       return True\n```", "```py\nfrom fastapi import APIRouter, Depends\nfrom fastapi.responses import JSONResponse\nfrom models.request.category import BookReq\nfrom repository.mongoframe.book import BookRepository\nfrom db_config.mongoframe_config import create_db_client\nfrom datetime import date, datetime\nfrom json import dumps, loads\nrouter = APIRouter(\n         dependencies=[Depends(create_db_client)])\n@router.post(\"/book/create\")\ndef create_book(req:BookReq): \n    book_dict = req.dict(exclude_unset=True) \n    book_json = dumps(book_dict, default=json_serial)\n    repo:BookRepository = BookRepository()\n    result = repo.insert_book(loads(book_json))\n    if result == True: \n        return req \n    else: \n        return JSONResponse(content={\"message\": \n          \"insert book unsuccessful\"}, status_code=500)\n```"]