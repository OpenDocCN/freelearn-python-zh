["```py\nPOST http://localhost:5000/api/messages/ \n\n```", "```py\nGET http://localhost:5000/api/messages/{id} \n\n```", "```py\nPATCH http://localhost:5000/api/messages/{id} \n\n```", "```py\nDELETE http://localhost:5000/api/messages/{id} \n\n```", "```py\n~/PythonREST/Flask01 \n\n```", "```py\n%USERPROFILE%\\PythonREST\\Flask01 \n\n```", "```py\npython3 -m venv ~/PythonREST/Flask01\n\n```", "```py\npython -m venv %USERPROFILE%\\PythonREST\\Flask01\n\n```", "```py\nsource ~/PythonREST/Flask01/bin/activate\n\n```", "```py\nsource ~/PythonREST/Flask01/bin/activate.csh\n\n```", "```py\nsource ~/PythonREST/Flask01/bin/activate.fish\n\n```", "```py\n%USERPROFILE%\\PythonREST\\Flask01\\Scripts\\activate.bat\n\n```", "```py\ncd $env:USERPROFILE\nPythonREST\\Flask01\\Scripts\\Activate.ps1\n\n```", "```py\npip install flask-restful\n\n```", "```py\nInstalling collected packages: six, pytz, click, itsdangerous, MarkupSafe, Jinja2, Werkzeug, Flask, python-dateutil, aniso8601, flask-restful\n Running setup.py install for click\n Running setup.py install for itsdangerous\n Running setup.py install for MarkupSafe\n Running setup.py install for aniso8601\nSuccessfully installed Flask-0.11.1 Jinja2-2.8 MarkupSafe-0.23 Werkzeug-0.11.10 aniso8601-1.1.0 click-6.6 flask-restful-0.3.5 itsdangerous-0.24 python-dateutil-2.5.3 pytz-2016.4 six-1.10.0\n\n```", "```py\ndef is_informational(code): \n    return code >= 100 and code <= 199 \n\ndef is_success(code): \n    return code >= 200 and code <= 299 \n\ndef is_redirect(code): \n    return code >= 300 and code <= 399 \n\ndef is_client_error(code): \n    return code >= 400 and code <= 499 \n\ndef is_server_error(code): \n    return code >= 500 and code <= 599 \n\nHTTP_100_CONTINUE = 100 \nHTTP_101_SWITCHING_PROTOCOLS = 101 \nHTTP_200_OK = 200 \nHTTP_201_CREATED = 201 \nHTTP_202_ACCEPTED = 202 \nHTTP_203_NON_AUTHORITATIVE_INFORMATION = 203 \nHTTP_204_NO_CONTENT = 204 \nHTTP_205_RESET_CONTENT = 205 \nHTTP_206_PARTIAL_CONTENT = 206 \nHTTP_300_MULTIPLE_CHOICES = 300 \nHTTP_301_MOVED_PERMANENTLY = 301 \nHTTP_302_FOUND = 302 \nHTTP_303_SEE_OTHER = 303 \nHTTP_304_NOT_MODIFIED = 304 \nHTTP_305_USE_PROXY = 305 \nHTTP_306_RESERVED = 306 \nHTTP_307_TEMPORARY_REDIRECT = 307 \nHTTP_400_BAD_REQUEST = 400 \nHTTP_401_UNAUTHORIZED = 401 \nHTTP_402_PAYMENT_REQUIRED = 402 \nHTTP_403_FORBIDDEN = 403 \nHTTP_404_NOT_FOUND = 404 \nHTTP_405_METHOD_NOT_ALLOWED = 405 \nHTTP_406_NOT_ACCEPTABLE = 406 \nHTTP_407_PROXY_AUTHENTICATION_REQUIRED = 407 \nHTTP_408_REQUEST_TIMEOUT = 408 \nHTTP_409_CONFLICT = 409 \nHTTP_410_GONE = 410 \nHTTP_411_LENGTH_REQUIRED = 411 \nHTTP_412_PRECONDITION_FAILED = 412 \nHTTP_413_REQUEST_ENTITY_TOO_LARGE = 413 \nHTTP_414_REQUEST_URI_TOO_LONG = 414 \nHTTP_415_UNSUPPORTED_MEDIA_TYPE = 415 \nHTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE = 416 \nHTTP_417_EXPECTATION_FAILED = 417 \nHTTP_428_PRECONDITION_REQUIRED = 428 \nHTTP_429_TOO_MANY_REQUESTS = 429 \nHTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE = 431 \nHTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS = 451 \nHTTP_500_INTERNAL_SERVER_ERROR = 500 \nHTTP_501_NOT_IMPLEMENTED = 501 \nHTTP_502_BAD_GATEWAY = 502 \nHTTP_503_SERVICE_UNAVAILABLE = 503 \nHTTP_504_GATEWAY_TIMEOUT = 504 \nHTTP_505_HTTP_VERSION_NOT_SUPPORTED = 505 \nHTTP_511_NETWORK_AUTHENTICATION_REQUIRED = 511 \n\n```", "```py\nclass MessageModel: \n    def __init__(self, message, duration, creation_date, message_category): \n        # We will automatically generate the new id \n        self.id = 0 \n        self.message = message \n        self.duration = duration \n        self.creation_date = creation_date \n        self.message_category = message_category \n        self.printed_times = 0 \n        self.printed_once = False \n\n```", "```py\nfrom flask import Flask \nfrom flask_restful import abort, Api, fields, marshal_with, reqparse, Resource \nfrom datetime import datetime \nfrom models import MessageModel \nimport status \nfrom pytz import utc \n\nclass MessageManager(): \n    last_id = 0 \n    def __init__(self): \n        self.messages = {} \n\n    def insert_message(self, message): \n        self.__class__.last_id += 1 \n        message.id = self.__class__.last_id \n        self.messages[self.__class__.last_id] = message \n\n    def get_message(self, id): \n        return self.messages[id] \n\n    def delete_message(self, id): \n         del self.messages[id] \n\n```", "```py\nmessage_fields = { \n    'id': fields.Integer, \n    'uri': fields.Url('message_endpoint'), \n    'message': fields.String, \n    'duration': fields.Integer, \n    'creation_date': fields.DateTime, \n    'message_category': fields.String, \n    'printed_times': fields.Integer, \n    'printed_once': fields.Boolean \n} \n\nmessage_manager = MessageManager() \n\n```", "```py\nclass Message(Resource): \n    def abort_if_message_doesnt_exist(self, id): \n        if id not in message_manager.messages: \n            abort( \n                status.HTTP_404_NOT_FOUND,  \n                message=\"Message {0} doesn't exist\".format(id)) \n\n    @marshal_with(message_fields) \n    def get(self, id): \n        self.abort_if_message_doesnt_exist(id) \n        return message_manager.get_message(id) \n\n    def delete(self, id): \n        self.abort_if_message_doesnt_exist(id) \n        message_manager.delete_message(id) \n        return '', status.HTTP_204_NO_CONTENT \n\n    @marshal_with(message_fields) \n    def patch(self, id): \n        self.abort_if_message_doesnt_exist(id) \n        message = message_manager.get_message(id) \n        parser = reqparse.RequestParser() \n        parser.add_argument('message', type=str) \n        parser.add_argument('duration', type=int) \n        parser.add_argument('printed_times', type=int) \n        parser.add_argument('printed_once', type=bool) \n        args = parser.parse_args() \n        if 'message' in args: \n            message.message = args['message'] \n        if 'duration' in args: \n            message.duration = args['duration'] \n        if 'printed_times' in args: \n            message.printed_times = args['printed_times'] \n        if 'printed_once' in args: \n            message.printed_once = args['printed_once'] \n        return message \n\n```", "```py` ```", "```py`message exists, the code calls the `message_manager.delete_message` method with the received id as an argument to remove the `MessageModel` instance from our data repository. Then, the code returns an empty response body and a `204 No Content` status code.\n*   `patch`: This method receives the id of the message that has to be updated or patched in the `id` argument. The code calls the `self.abort_if_message_doesnt_exist` method to abort in case there is no message with the requested id. In case the message exists, the code saves the `MessageModel` instance whose `id` that matches the specified `id` returned by the `message_manager.get_message` method in the `message` variable. The next line creates a `flask_restful.reqparse.RequestParser` instance named `parser`. The `RequestParser` instance allows us to add arguments with their names and types and then easily parse the arguments received with the request. The code makes four calls to the `parser.add_argument` with the argument name and the type of the four arguments we want to parse. Then, the code calls the `parser.parse_args` method to parse all the arguments from the request and saves the returned dictionary (`dict`) in the `args` variable. The code updates all the attributes that have new values in the `args` dictionary in the `MessageModel` instance: `message`. In case the request didn't include values for certain fields, the code won't make changes to the realted attributes. The request doesn't require to include the four fields that can be updated with values. The code returns the updated `message`. The `patch` method uses the `@marshal_with` decorator with `message_fields` as an argument. The decorator will take the `MessageModel` instance, `message`, and apply the field filtering and output formatting specified in `message_fields`.\n\n### Tip\n\nWe used multiple return values to set the response code.\n\nAs previously explained, the three methods call the internal `abort_if_message_doesnt_exist` method that receives the id for an existing `MessageModel` instance in the `id` argument. If the received `id` is not present in the keys of the `message_manager.messages` dictionary, the method calls the `flask_restful.abort` function with `status.HTTP_404_NOT_FOUND` as the `http_status_code` argument and a message indicating that the message with the specified id doesn't exists. The `abort` function raises an `HTTPException` for the received `http_status_code` and attaches the additional keyword arguments to the exception for later processing. In this case, we generate an HTTP `404 Not Found` status code.\n\nBoth the `get` and `patch` methods use the `@marshal_with` decorator that takes a single data object or a list of data objects and applies the field filtering and output formatting specifies as an argument. The marshalling can also work with dictionaries (dicts). In both methods, we specified `message_fields` as an argument, and therefore, the code renders the following fields: `id`, `uri`, `message`, `duration`, `creation_date`, `message_category`, `printed_times` and `printed_once`. When we use the `@marshal_with` decorator, we are automatically returning an HTTP 200 `OK` status code.\n\nThe following `return` statement with the `@marshal_with(message_fields)` decorator returns an `HTTP 200 OK` status code because we didn't specify any status code after the returned object (`message`):\n\n```", "```py\n\nThe next line is the line of code that is really executed with the `@marshal_with(message_fields)` decorator, and we can use it instead of working with the decorator:\n\n```", "```py\n\nFor example, we can call the `marshal` function as shown in the previous line instead of using the `@marshal_with` decorator and the code will produce the same result.\n\nNow, we will create a `MessageList` class that we will use to represent the collection of messages. Open the previously created `api/api.py` file and add the following lines. The code file for the sample is included in the `restful_python_chapter_05_01` folder:\n\n```", "```py\n\nThe `MessageList` class is a subclass of `flask_restful.Resource` and declares the following two methods that will be called when the HTTP method with the same name arrives as a request on the represented resource:\n\n*   `get`: This method returns a list with all the `MessageModel` instances saved in the `message_manager.messages` dictionary. The `get` method uses the `@marshal_with` decorator with `message_fields` as an argument. The decorator will take each `MessageModel` instance in the returned list and apply the field filtering and output formatting specified in `message_fields`.\n*   `post`: This method creates a `flask_restful.reqparse.RequestParser` instance named `parser`. The `RequestParser` instance allows us to add arguments with their names and types and then easily parse the arguments received with the `POST` request to create a new `MessageModel` instance. The code makes three calls to the `parser.add_argument` with the argument name and the type of the three arguments we want to parse. Then, the code calls the `parser.parse_args` method to parse all the arguments from the request and saves the returned dictionary (`dict`) in the `args` variable. The code uses the parsed arguments in the dictionary to specify the values for the `message`, `duration` and `message_category` attributes to create a new `MessageModel` instance and save it in the `message` variable. The value for the `creation_date` argument is set to the current `datetime` with time zone info, and therefore, it isn't parsed from the request. Then, the code calls the `message_manager.insert_message` method with the new `MessageModel` instance (`message`) to add this new instance to the dictionary. The `post` method uses the `@marshal_with` decorator with `message_fields` as an argument. The decorator will take the recently created and stored `MessageModel` instance, `message`, and apply the field filtering and output formatting specified in `message_fields`. The code returns an HTTP `201 Created` status code.\n\nThe following table shows the method of our previously created classes that we want to be executed for each combination of HTTP verb and scope:\n\n| **HTTP verb** | **Scope** | **Class and method** |\n| `GET` | Collection of messages | MessageList.get |\n| `GET` | Message | Message.get |\n| `POST` | Collection of messages | MessageList.post |\n| `PATCH` | Message | Message.patch |\n| `DELETE` | Message | Message.delete |\n\nIf the request results in the invocation of a resource with an unsupported HTTP method, Flask-RESTful will return a response with the HTTP `405 Method Not Allowed` status code.\n\n# Configuring resource routing and endpoints\n\nWe must make the necessary resource routing configurations to call the appropriate methods and pass them all the necessary arguments by defining URL rules. The following lines create the main entry point for the application, initialize it with a Flask application and configure the resource routing for the `api`. Open the previously created `api/api.py` file and add the following lines. The code file for the sample is included in the `restful_python_chapter_05_01` folder:\n\n```", "```py\n\nThe code creates an instance of the `flask_restful.Api` class and saves it in the `api` variable. Each call to the `api.add_resource` method routes a URL to a resource, specifically to one of the previously declared subclasses of the `flask_restful.Resource` class. When there is a request to the API and the URL matches one of the URLs specified in the `api.add_resource` method, Flask will call the method that matches the HTTP verb in the request for the specified class. The method follows standard Flask routing rules.\n\nFor example, the following line will make an HTTP GET request to `/api/messages/` without any additional parameters to call the `MessageList.get` method:\n\n```", "```py\n\nFlask will pass the URL variables to the called method as arguments. For example, the following line will make an HTTP `GET` request to `/api/messages/12` to call the `Message.get` method with `12` passed as the value for the `id` argument:\n\n```", "```py\n\nIn addition, we can specify a string value for the endpoint argument to make it easy to reference the specified route in `fields.Url` fields. We pass the same endpoint name, `'message_endpoint'` as an argument in the `uri` field declared as `fields.Url` in the `message_fields` dictionary that we use to render each `MessageModel` instance. This way, `fields.Url` will generate a URI considering this route.\n\nWe just required a few lines of code to configure resource routing and endpoints. The last line just calls the `app.run` method to start the Flask application with the `debug` argument set to `True` to enable debugging. In this case, we start the application by calling the `run` method to immediately launch a local server. We could also achieve the same goal by using the `flask` command-line script. However, this option would require us to configure environment variables and the instructions are different for the platforms that we are covering in this book-macOS, Windows and Linux.\n\n### Tip\n\nAs with any other Web framework, you should never enable debugging in a production environment.\n\n# Making HTTP requests to the Flask API\n\nNow, we can run the `api/api.py` script that launches Flask's development server to compose and send HTTP requests to our unsecure and simple Web API (we will definitely add security later). Execute the following command.\n\n```", "```py\n\nThe following lines show the output after we execute the previous command. The development server is listening at port `5000`.\n\n```", "```py\n\nWith the previous command, we will start Flask development server and we will only be able to access it in our development computer. The previous command starts the development server in the default IP address, that is, `127.0.0.1` (`localhost`). It is not possible to access this IP address from other computers or devices connected on our LAN. Thus, if we want to make HTTP requests to our API from other computers or devices connected to our LAN, we should use the development computer IP address, `0.0.0.0` (for IPv4 configurations) or `::` (for IPv6 configurations), as the desired IP address for our development server.\n\nIf we specify `0.0.0.0` as the desired IP address for IPv4 configurations, the development server will listen on every interface on port 5000\\. In addition, it is necessary to open the default port `5000` in our firewalls (software and/or hardware) and configure port-forwarding to the computer that is running the development server.\n\nWe just need to specify `'0.0.0.0'` as the value for the host argument in the call to the `app.run` method, specifically, the last line in the `api/api.py` file. The following line shows the new call to `app.run` that launches Flask's development server in an IPv4 configuration and allows requests to be made from other computers and devices connected to our LAN. The line generates an externally visible server. The code file for the sample is included in the `restful_python_chapter_05_02` folder:\n\n```", "```py\n\n### Tip\n\nIf you decide to compose and send HTTP requests from other computers or devices connected to the LAN, remember that you have to use the development computer's assigned IP address instead of `localhost`. For example, if the computer's assigned IPv4 IP address is `192.168.1.103`, instead of `localhost:5000`, you should use `192.168.1.103:5000`. Of course, you can also use the host name instead of the IP address. The previously explained configurations are very important because mobile devices might be the consumers of our RESTful APIs and we will always want to test the apps that make use of our APIs in our development environments. In addition, we can work with useful tools such as ngrok that allow us to generate secure tunnels to localhost. You can read more information about ngrok at [http://www.ngrok.com](http://www.ngrok.com).\n\nThe Flask development server is running on localhost (`127.0.0.1`), listening on port `5000`, and waiting for our HTTP requests. Now, we will compose and send HTTP requests locally in our development computer or from other computer or devices connected to our LAN.\n\n## Working with command-line tools â curl and httpie\n\nWe will start composing and sending HTTP requests with the command-line tools we have introduced in *[Chapter 1](ch01.html \"Chapter 1. Developing RESTful APIs with Django\")* , *Developing RESTful APIs with Django*, curl and HTTPie. In case you haven't installed HTTPie, make sure you activate the virtual environment and then run the following command in the terminal or command prompt to install the HTTPie package.\n\n```", "```py\n\n### Tip\n\nIn case you don't remember how to activate the virtual environment that we created for this example, read the following section in this chapter-*Setting up the virtual environment with Django REST framework*.\n\nOpen a Cygwin Terminal in Windows or a Terminal in macOS or Linux, and run the following command. It is very important that you enter the ending slash (`/`) when specified /api/messages won't match any of the configured URL routes. Thus, we must enter `/api/messages/`, including the ending slash (/). We will compose and send an HTTP request to create a new message:\n\n```", "```py\n\nThe following is the equivalent curl command. It is very important to use the `-H \"Content-Type: application/json\"` option to indicate curl to send the data specified after the `-d` option as `application/json` instead of the default `application/x-www-form-urlencoded`:\n\n```", "```py\n\nThe previous commands will compose and send the following HTTP request: `POST http://localhost:5000/api/messages/` with the following JSON key-value pairs:\n\n```", "```py\n\nThe request specifies `/api/messages/`, and therefore, it will match `'/api/messages/'` and run the `MessageList.post` method. The method doesn't receive arguments because the URL route doesn't include any parameters. As the HTTP verb for the request is `POST`, Flask calls the `post` method. If the new `MessageModel` was successfully persisted in the dictionary, the function returns an `HTTP 201 Created` status code and the recently persisted `MessageModel` serialized serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new `MessageModel` object in the JSON response:\n\n```", "```py\n\nWe will compose and send an HTTP request to create another message. Go back to the Cygwin terminal in Windows or the Terminal in macOS or Linux, and run the following command:\n\n```", "```py\n\nThe following is the equivalent `curl` command:\n\n```", "```py\n\nThe previous commands will compose and send the following HTTP request, `POST http://localhost:5000/api/messages/`, with the following JSON key-value pairs:\n\n```", "```py\n\nThe following lines show an example response for the HTTP request, with the new `MessageModel` object in the JSON response:\n\n```", "```py\n\nWe will compose and send an HTTP request to retrieve all the messages. Go back to the Cygwin terminal in Windows or the Terminal in macOS or Linux, and run the following command:\n\n```", "```py\n\nThe following is the equivalent curl command:\n\n```", "```py\n\nThe previous commands will compose and send the following HTTP request: `GET http://localhost:5000/api/messages/`. The request specifies `/api/messages/`, and therefore, it will match `'/api/messages/'` and run the `MessageList.get` method. The method doesn't receive arguments because the URL route doesn't include any parameters. As the HTTP verb for the request is `GET`, Flask calls the `get` method. The method retrieves all the `MessageModel` objects and generates a JSON response with all of these `MessageModel` objects serialized.\n\nThe following lines show an example response for the HTTP request. The first lines show the HTTP response headers, including the status (200 OK) and the Content-type (application/json). After the HTTP response headers, we can see the details for the two `MessageModel` objects in the JSON response:\n\n```", "```py\n\nAfter we run the three requests, we will see the following lines in the window that is running the Flask development server. The output indicates that the server received three HTTP requests, specifically two `POST` requests and one `GET` request with `/api/messages/` as the URI. The server processed the three HTTP requests, returned status code 201 for the first two requests and 200 for the last request:\n\n```", "```py\n\nThe following image shows two Terminal windows side-by-side on macOS. The Terminal window at the left-hand side is running the Flask development server and displays the received and processed HTTP requests. The Terminal window at the right-hand side is running `http` commands to generate the HTTP requests. It is a good idea to use a similar configuration to check the output while we compose and send the HTTP requests:\n\n![Working with command-line tools â curl and httpie](img/image_05_001.jpg)\n\nNow, we will compose and send an HTTP request to retrieve a message that doesn't exist. For example, in the previous list, there is no message with an `id` value equal to `800`. Run the following command to try to retrieve this message. Make sure you use an `id` value that doesn't exist. We must make sure that the utilities display the headers as part of the response to see the returned status code:\n\n```", "```py\n\nThe following is the equivalent `curl` command:\n\n```", "```py\n\nThe previous commands will compose and send the following HTTP request: `GET http://localhost:5000/api/messages/800`. The request is the same than the previous one we have analyzed, with a different number for the `id` parameter. The server will run the `Message.get` method with `800` as the value for the `id` argument. The method will execute the code that retrieves the `MessageModel` object whose id matches the `id` value received as an argument. However, the first line in the `MessageList.get` method calls the `abort_if_message_doesnt_exist` method that won't find the id in the dictionary keys and it will call the `flask_restful.abort` function because there is no message with the specified `id` value. Thus, the code will return an HTTP `404 Not Found` status code. The following lines show an example header response for the HTTP request and the message included in the body. In this case, we just leave the default message. Of course, we can customize it based on our specific needs:\n\n```", "```py\n\nOur API is able to update a single field for an existing resource, and therefore, we provide an implementation for the `PATCH` method. For example, we can use the `PATCH` method to update two fields for an existing message and set the value for its `printed_once` field to `true` and `printed_times` to `1`. We don't want to use the `PUT` method because this method is meant to replace an entire message. The `PATCH` method is meant to apply a delta to an existing message, and therefore, it is the appropriate method to just change the value of the `printed_once` and `printed_times` fields.\n\nNow, we will compose and send an HTTP request to update an existing message, specifically, to update the value of two fields. Make sure you replace `2` with the id of an existing message in your configuration:\n\n```", "```py\n\nThe following is the equivalent `curl` command:\n\n```", "```py\n\nThe previous command will compose and send a `PATCH` HTTP request with the specified JSON key-value pairs. The request has a number after `/api/messages/`, and therefore, it will match `'/api/messages/<int:id>'` and run the `Message.patch` method, that is, the `patch` method for the `Message` class. If a `MessageModel` instance with the specified id exists and it was successfully updated, the call to the method will return an HTTP `200 OK` status code and the recently updated `MessageModel` instance serialized to JSON in the response body. The following lines show a sample response:\n\n```", "```py\n\n### Tip\n\nThe IoT device will make the previously explained HTTP request when it displays the message for the first time. Then, it will make additional PATCH requests to update the value for the `printed_times` field.\n\nNow, we will compose and send an HTTP request to delete an existing message, specifically, the last message we added. As happened in our last HTTP requests, we have to check the value assigned to `id` in the previous response and replace `2` in the command with the returned value:\n\n```", "```py\n\nThe following is the equivalent `curl` command:\n\n```", "```py\n\nThe previous commands will compose and send the following HTTP request: `DELETE http://localhost:5000/api/messages/2`. The request has a number after `/api/messages/`, and therefore, it will match `'/api/messages/<int:id>'` and run the `Message.delete` method, that is, the `delete` method for the `Message` class. If a `MessageModel` instance with the specified id exists and it was successfully deleted, the call to the method will return an HTTP `204 No Content` status code. The following lines show a sample response:\n\n```", "```py\n\n## Working with GUI tools - Postman and others\n\nSo far, we have been working with two terminal-based or command-line tools to compose and send HTTP requests to our Flask development server-cURL and HTTPie. Now, we will work with one of the GUI tools we used when composing and sending HTTP requests to the Django development server-Postman.\n\nNow, we will use the **Builder** tab in Postman to easily compose and send HTTP requests to `localhost:5000` and test the RESTful API with this GUI tool. Remember that Postman doesn't support curl-like shorthands for localhost, and therefore, we cannot use the same shorthands we have been using when composing requests with curl and HTTPie.\n\nSelect **GET** in the dropdown menu at the left-hand side of the **Enter request URL** textbox, and enter `localhost:5000/api/messages/` in this textbox at the right-hand side of the dropdown. Then, click **Send** and Postman will display the Status (**200 OK**), the time it took for the request to be processed and the response body with all the games formatted as JSON with syntax highlighting (**Pretty** view). The following screenshot shows the JSON response body in Postman for the HTTP GET request.\n\n![Working with GUI tools - Postman and others](img/image_05_002.jpg)\n\nClick on **Headers** at the right-hand side of **Body** and **Cookies** to read the response headers. The following screenshot shows the layout for the response headers that Postman displays for the previous response. Notice that Postman displays the **Status** at the right-hand side of the response and doesn't include it as the first line of the Headers, as happened when we worked with both the cURL and HTTPie utilities:\n\n![Working with GUI tools - Postman and others](img/image_05_003.jpg)\n\nNow, we will use the **Builder** tab in Postman to compose and send an HTTP request to create a new message, specifically, a POST request. Follow the next steps:\n\n1.  Select **POST** in the drop-down menu at the left-hand side of the **Enter request URL** textbox, and enter `localhost:5000/api/messages/` in this textbox at the right-hand side of the dropdown.\n2.  Click **Body** at the right-hand side of **Authorization** and **Headers**, within the panel that composes the request.\n3.  Activate the **raw** radio button and select **JSON (application/json)** in the dropdown at the right-hand side of the **binary** radio button. Postman will automatically add a **Content-type** = **application/json** header, and therefore, you will notice the **Headers** tab will be renamed to **Headers (1)**, indicating us that there is one key-value pair specified for the request headers.\n4.  Enter the following lines in the textbox below the radio buttons, within the **Body** tab:\n\n```"]