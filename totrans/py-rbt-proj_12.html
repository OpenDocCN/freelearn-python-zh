<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Recognizing Humans with Jarvis</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span><span>By now  </span></span>we have understood in the last chapter how multiple layers of conditions can be clubbed together to get the functionality that is desired. We have just completed the first step in making Jarvis work for you. Now, it's time to make it even more capable.</p>
<p class="mce-root">In this chapter, we will make it control more electronics at your home, which can be controlled autonomously without you telling anything to the system. So without delay, let's get straight into it and see what we have in our bucket.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Turn on the light Jarvis</h1>
                </header>
            
            <article>
                
<p>One of the basic functionalities of a smart home is to turn on the lights for you whenever you are around. It is one of the most basic things that any system can do for you. We will start off by turning on the light as soon as you come inside the room, thereafter, we will make the system more and more intelligent.</p>
<p>So, the first thing we need to do is recognize whether you are in a room or not. There are multiple ways to do that. One important characteristic of life is the presence of movement. You may say plants don't move, well they do; they grow, don't they? So detecting movement can be a key step in detecting whether someone is there or not!</p>
<p>This step will not be so difficult for you, as we have already interfaced this sensor previously. We are talking about the good old PIR sensor. So the sensor will sense any movement in the area. If there is any movement, then Jarvis will switch on the lights. I am sure this is something you can do by yourself by now. You can still refer to the code and the circuit diagram here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/831a5983-5954-4b4b-82ec-fe5b34c2edc8.png"/></div>
<div>Now upload the following code:</div>
<pre>import RPi.GPIO as GPIO<br/>import time<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/>PIR = 24<br/>LIGHT = 23<br/>GPIO.setup(DOPPLER,GPIO.IN)<br/>GPIO.setup(BUZZER,GPIO.OUT)<br/>While True:<br/>   if GPIO.input(PIR) == 1:<br/>       GPIO.output(LIGHT,GPIO.HIGH)<br/>   if GPIO.input(PIR) == 0:<br/>       GPIO.output(LIGHT,GPIO.LOW)</pre>
<p>In the preceding code, we are simply turning on the light as soon as the motion is detected, but the problem is that it will only switch on the light for the time the motion is there. What does that mean? Simple, while there is some movement, will keep the lights on and as soon as the movement stops, it will switch off the light.</p>
<p>This can be a very good code for a person who wants to lose weight, but for most of us, it will be annoying. So, let's include a small loop, which we have used in the previous chapter and make this a little better:</p>
<pre>import RPi.GPIO as GPIO<br/>import time<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/><br/>PIR = 24<br/>LIGHT = 23<br/>TIME = 5<br/><br/>GPIO.setup(PIR,GPIO.IN)<br/>GPIO.setup(BUZZER,GPIO.OUT)<br/><br/>While True:<br/><br/>   If GPIO.input(PIR) == 1:<br/>       <br/>       <span>M = datetime.datetime.now().strftime('%M')<br/>       M_final= M + TIME<br/></span><br/>       for M &lt; M_final:<br/><br/>         GPIO.output(LIGHT,GPIO.HIGH)<br/>         <span>M = datetime.datetime.now().strftime('%M')<br/><br/>         if GPIO.input(PIR) == 1:<br/>            M_final = M_final + 1 </span><span><br/><br/><br/>    if GPIO.input(PIR) = 0:<br/><br/>        GPIO.output(LIGHT, GPIO.LOW)}<br/></span></pre>
<p>So, in this program, all we have done is we have added a <kbd>for</kbd> loop, which switches on the light for a set amount of time. How long that time will be can be toggled by changing the value of the variable <kbd>TIME</kbd>.</p>
<p>There is one more interesting part in that loop which is as follows:</p>
<pre><span>         if GPIO.input(PIR) == 1<br/>            M_final = M_final + 1 </span></pre>
<p>Why did we do this you might wonder? Whenever the light will be switched on, it will remain on for 5 minutes. Then, it will switch off and wait for movement to occur. So, essentially, the problem with this code will be that if you are in the room and the light switches on, then for 5 minutes it will see if there is any motion detected or not. There is a chance that you will be in motion when it searches for the motion after 5 minutes. But for most of the time, it won't be the case. So we are detecting the movement using the PIR sensor. Whenever movement is detected, the value of <kbd>M_final</kbd> is incremented using the line <kbd>M_final = M_final + 1</kbd>, thereby increasing the time until which the light will be switched on.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding motion</h1>
                </header>
            
            <article>
                
<p>By now you must have figured that the PIR sensor is not the most idealistic sensor for us to switch the lights on or off. Mostly because, although the motion is one of the best indicators of presence, there can be times when you might not move at all, for example, while resting, reading a book, watching a movie, and so on.</p>
<p>What do we do now? Well, we can do a little trick. Remember in the last chapter we used our proximity sensor to sense whether a person has crossed a specific area or not? We will implant a similar logic here; but rather than just copy pasting the code, we will improve it and make it even better.</p>
<p>So rather than using one single IR proximity sensor, we will be using two of these things. The mounting will be as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/09728605-7f11-4f9c-bf51-35889757bffa.png"/></div>
<p>Now it is very evident that whenever a person walks in from the door side to the room side the <strong>Sensor 1</strong> will show a lower reading when detecting a body. Then, while he is walking towards the room side, <strong>Sensor 2</strong> will show a similar reading.</p>
<p>If first <strong>Sensor 1</strong> is triggered and thereafter <strong>Sensor 2</strong> is triggered, then we can safely assume that the person is travelling from the door side to the room side. Similarly, if the opposite is happening, then it is understood that the person is walking out of the room.</p>
<p>Now, this is fairly simple. But how do we implement it in a real-life situation? Firstly, we need to connect the circuit as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0dfd0653-10b4-4311-8c2c-f4ebe1a71e48.png"/></div>
<p>Once that is done, upload the following code:</p>
<pre>import GPIO library<br/>import RPi.GPIO as GPIO<br/>import time<br/><br/><span>import Adafruit_ADS1x15<br/></span><span>adc0 = Adafruit_ADS1x15.ADS1115()</span><span><br/></span><span><br/>GAIN = 1<br/>LIGHT = 23<br/><br/></span><span>adc0.start_adc(0, gain=GAIN)<br/></span>adc1.start_adc(1, gain=GAIN)<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/><br/><br/>while True:<br/><br/><br/><span>   F_value = adc0.get_last_result()</span><span><br/></span><span>   F1 =    </span><span>(</span><span>1.0</span><span> </span><span>/</span><span> (F_value </span><span>/</span><span> </span><span>13.15</span><span>)) </span><span>-</span><span> </span><span>0.35<br/><br/>   time.sleep(0.1)<br/><br/></span><span>   F_value = adc0.get_last_result()</span><span><br/></span><span>   F2 =    </span><span>(</span><span>1.0</span><span> </span><span>/</span><span> (F_value </span><span>/</span><span> </span><span>13.15</span><span>)) </span><span>-</span><span> </span><span>0.35<br/><br/> </span><span>  F0_final = F1-F2<br/><br/>   if F0 &gt; 10 :<br/>     <br/>        Time0 =</span>  time.time()<br/><span><br/>        <br/>        </span><br/><span>   F_value = adc1.get_last_result()</span><span><br/></span><span>   F1 =    </span><span>(</span><span>1.0</span><span> </span><span>/</span><span> (F_value </span><span>/</span><span> </span><span>13.15</span><span>)) </span><span>-</span><span> </span><span>0.35<br/><br/>   time.sleep(0.1)<br/><br/></span><span>   F_value = adc1.get_last_result()</span><span><br/></span><span>   F2 =    </span><span>(</span><span>1.0</span><span> </span><span>/</span><span> (F_value </span><span>/</span><span> </span><span>13.15</span><span>)) </span><span>-</span><span> </span><span>0.35<br/><br/>   F1_final = F1-F2<br/><br/></span>   if F1 &gt; 10: <br/><br/><span>        Time1 =</span>  time.time()<br/><br/>    <br/>    if Time1 &gt; Time0:<br/><br/>        GPIO.output(LIGHT, GPIO.HIGH)<br/><br/><br/>    if Time1 &lt; Time0:<br/><br/>        GPIO.output(LIGHT, GPIO.LOW)      }</pre>
<p>Now, let's see what are we doing here. As always, most of the syntax is very simple and straightforward. The most important part is the logic. So, let's understand in proper steps as to what we are doing.</p>
<pre><span>   F_value = adc0.get_last_result()</span><span><br/></span><span>   F1 =    </span><span>(</span><span>1.0</span><span> </span><span>/</span><span> (F_value </span><span>/</span><span> </span><span>13.15</span><span>)) </span><span>-</span><span> </span><span>0.35<br/><br/>   time.sleep(0.1)<br/><br/></span><span>   F_value = adc0.get_last_result()</span><span><br/></span><span>   F2 =    </span><span>(</span><span>1.0</span><span> </span><span>/</span><span> (F_value </span><span>/</span><span> </span><span>13.15</span><span>)) </span><span>-</span><span> </span><span>0.35</span></pre>
<p>In the preceding lines of code, we are taking the value of the IR proximity sensor and calculating the distance corresponding to it and storing that value in a variable called <kbd>F1</kbd>. Once that is done, we are stopping for a brief period of <kbd>0.1</kbd> seconds using the <kbd>time.sleep(0.1)</kbd> function. Thereafter, we are taking the reading from the same sensor again and storing the value in a variable called <kbd>F2</kbd>. Why are we doing this? We have already understood that in the previous chapters.</p>
<pre><span>  F0_final = F1-F2</span></pre>
<p>Once the value of <kbd>F1</kbd> and <kbd>F0</kbd> is acquired, we will calculate the difference to find out whether someone has passed through it or not. If no one has passed, then the reading will almost be the same and the difference will not be considerable. However, if a person does pass, then the reading will be considerable and that value will be stored in a variable called <kbd>F0_final</kbd>.</p>
<pre><span>   if F0 &gt; 10 :<br/>     <br/>        Time0 =</span>  time.time()</pre>
<p>If the value of the <kbd>F0</kbd> or the difference in distance between the first and the second reading is more than 10 centimeters, then the <kbd>if</kbd> condition will be true. Once true, it will set the value of the <kbd>Time0</kbd> variable as the current value of time. The <kbd>time.time()</kbd> <span>function </span>will make a note of the exact time. </p>
<pre><span>   F_value = adc1.get_last_result()</span><span><br/></span><span>   F1 =    </span><span>(</span><span>1.0</span><span> </span><span>/</span><span> (F_value </span><span>/</span><span> </span><span>13.15</span><span>)) </span><span>-</span><span> </span><span>0.35<br/><br/>   time.sleep(0.1)<br/><br/></span><span>   F_value = adc1.get_last_result()</span><span><br/></span><span>   F2 =    </span><span>(</span><span>1.0</span><span> </span><span>/</span><span> (F_value </span><span>/</span><span> </span><span>13.15</span><span>)) </span><span>-</span><span> </span><span>0.35<br/><br/>   F1_final = F1-F2<br/><br/></span>   if F1 &gt; 10: <br/><br/><span>        Time1 =</span>  time.time()</pre>
<p>Now, we'll perform the exact same step for <strong>Sensor 2</strong> as well. There is nothing new to tell here; it's all self explanatory.</p>
<pre>    if Time1 &gt; Time0:<br/><br/>        GPIO.output(LIGHT, GPIO.HIGH)</pre>
<p>Once all of this is done, we compare <kbd>if Time1 &gt; Time0</kbd>. Why are we comparing it? Because <kbd>Time0</kbd> is the time noted for <strong>Sensor 1</strong>. If the person is moving inside, then <strong>Sensor 1</strong> would be the first one to be triggered and then the <strong>Sensor 2</strong> would be triggered. Hence, the time noted would be greater for <strong>Sensor 2</strong> and relatively earlier for <strong>Sensor 1</strong>. If that happens, then we can assume that the person is coming inside. Well, if a person is coming inside, then we simply need to switch the light on, which is exactly what we are doing here. </p>
<pre>    if Time1 &lt; Time0:<br/><br/>        GPIO.output(LIGHT, GPIO.LOW)</pre>
<p>Similarly, when a person is going out, the first sensor to be triggered would be <strong>Sensor 2</strong>, thereafter <strong>Sensor 1</strong> will be triggered. Making the time noted for <kbd>Time1</kbd> earlier than <kbd>Time2</kbd>; hence, whenever this condition is true, we will know that the person is moving out of the room and the lights can be switched off.</p>
<p>Go ahead and mount it near the door and see how it reacts. I'm sure this will be way better than what we had done through PIR. Have fun with it and try to find any flaws that it might have. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Perfecting motion</h1>
                </header>
            
            <article>
                
<p>Were you able to find any flaws in the previous code? They are not hard to find; the code works brilliantly when it's only a single person in the room. If this is installed somewhere where multiple people are coming and going, then it might be challenging. This is because whenever a person moves outside, the light will be turned off.</p>
<p>So now that the problem is evident, it's time to make the code even more better. To do this, the hardware will remain exactly the same; we simply need to make the code smarter. Let's see how we can do that:</p>
<pre>import GPIO library<br/>   import RPi.GPIO as GPIO<br/>   import time<br/>   import time<br/>   import Adafruit_ADS1x15<br/>   adc0 = Adafruit_ADS1x15.ADS1115()<br/>GAIN = 1<br/> adc0.start_adc(0, gain=GAIN)<br/>adc1.start_adc(1, gain=GAIN)<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/>PCount = 0<br/>while True:<br/>   F_value = adc0.get_last_result()<br/>   F1 = (1.0 / (F_value / 13.15)) - 0.35<br/>   time.sleep(0.1)<br/>   F_value = adc0.get_last_result()<br/>   F2 = (1.0 / (F_value / 13.15)) - 0.35<br/>   F0_final = F1-F2<br/>   if F0 &gt; 10 :<br/>        Time0 = time.time()<br/>   F_value = adc1.get_last_result()<br/>   F1 = (1.0 / (F_value / 13.15)) - 0.35<br/>   time.sleep(0.1)<br/>   F_value = adc1.get_last_result()<br/>   F2 = (1.0 / (F_value / 13.15)) - 0.35<br/>   F1_final = F1-F2<br/>   if F1 &gt; 10:<br/>        Time1 = time.time()<br/>    if Time1 &gt; Time0:<br/>        PCount = PCount + 1<br/>    if Time1 &lt; Time0:<br/>        PCount = PCount - 1<br/><br/>if PCount &gt; 0:<br/><br/>           GPIO.output(LIGHT, GPIO.HIGH)<br/>       else if PCount = 0:<br/>          GPIO.output(LIGHT, GPIO.LOW)        </pre>
<p>What we have done is something really basic. We have declared a variable called <kbd>PCount</kbd>. This variable is declared to count the number of people who are there inside a room or a home. As you can see in the first few lines of the code, we have declared the value of <kbd>PCount</kbd> as <kbd>0</kbd>. We are assuming that once we start this, the number of people inside would be <kbd>0</kbd>. </p>
<pre>    if Time1 &gt; Time0:<br/><br/>        PCount = PCount + 1</pre>
<p>Whenever the condition <kbd>if Time1 &gt; Time0:</kbd> is satisfied, the <kbd>PCount</kbd> value is incremented by <kbd>1</kbd>. As we all know, the condition will only be true when a person is walking inside the home.</p>
<pre>    if Time1 &lt; Time0:<br/>        <br/>        PCount = PCount - 1</pre>
<p>Similarly, when a person is walking outside, the condition <kbd>if Time1 &lt; Time0:</kbd> is true; whenever that happens, the value of <kbd>PCount</kbd> is decremented by <kbd>1</kbd>. </p>
<pre>    if PCount &gt; 0:<br/><br/>       GPIO.output(LIGHT, GPIO.HIGH)</pre>
<p>Now that we have started counting the number of people in the room, we are now applying the condition, which will turn on if the number of <kbd>PCount</kbd> is more than <kbd>0</kbd>. Hence, the light will be on for the time when the number of people inside the home is more than <kbd>0</kbd>. </p>
<pre>    else if PCount = 0:<br/><br/>       GPIO.output(LIGHT, GPIO.LOW)</pre>
<p>In a very similar fashion, the lights will be turned off if the value of <kbd>PCount</kbd> or the number of people inside the home gets to <kbd>0</kbd>. </p>
<p>Hence, nailed! </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling the intensity</h1>
                </header>
            
            <article>
                
<p>We have controlled a lot of light now. It's time that we control our fans and other air circulation systems. Whenever we talk about fans or any other air circulation devices, then essentially we are talking about motors. As we have learned earlier, motors are simple devices, which can be controlled every easily using a motor driver. But as you know, back then we were controlling DC motors. DC motors are extremely simple devices. But when we talk about our household appliances, then most of these devices will be working on AC or alternating current. I am assuming that you must be aware of what that is and how it is different from DC.</p>
<p>Now that you know that the motors used in our households are working on AC, you must also think about the fact that their control mechanism will be much different to DC motors. You are right, if you thought so. However, the good thing about electronics is, nothing is really difficult or complicated. The basics are pretty much the same. So, let's see how we can control the speed of the motors in AC supply.</p>
<p>As we have seen earlier, we can simply have a PWM signal given to the DC motor and the motor will run at the speed of the average voltage as a result of the PWM signal. Now, you must be thinking that this can be applied to AC as well. The thing is, yes it can be done if you want to control a light or similar devices, which do not have any major change in the characteristics in case the wave form is distorted. However, when we are talking about any other component, then we come across a big problem. The AC wave form looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/88cbcaf7-ac59-4dd4-bd1a-4b0689d10a23.png" style="width:41.25em;height:18.17em;"/></div>
<p>This basically means that the potential is changing periodically. In most of the households, this is 50 times per second. Now, imagine if we have a PWM-controlled device that is switching the circuit that only lets the power supply to pass at certain intervals. Then, the different parts of the sinusoidal waves would be passed on to the final output.</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/00216168-787b-4c9a-adad-d1a3432e2d5d.png" style="width:41.33em;height:17.08em;"/></div>
<p>As you can see in the preceding PWM, fortunately the PWM signal has matched with the phase of the AC power; however, due to this, only the positive end of the phase is being transferred to the final output and not the negative end. This will cause a severe problem to our load and there is a very good chance that the appliance that is connected will not work.</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/03c40308-32cd-4111-a608-85e99d49da28.png" style="width:41.33em;height:18.42em;"/></div>
<p>We have another example in which the PWM is random and it lets random parts of the wave pass by. In this, we can clearly see that randomly any part of the wave is being transferred and the positive and negative end voltage is not in sync, which again will be a huge problem. Hence, instead of using PWM, we use something really interesting.</p>
<p>The method that is most commonly used is called <strong>phase fired control</strong>. Sometimes it is also called phase angle control or phase cutting. What it essentially does is, it cuts the wave at certain parts of the phase letting the rest of the wave cross by. Confused? Let me show you here: </p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1887c541-2bc4-452c-ad7c-b09527637d84.png" style="width:41.17em;height:16.33em;"/></div>
<p>Now, as you can see the phase behind the second half of the AC wave is getting chopped and is not getting passed in the final output. This makes the final output to be only 50% of the overall input. What this technique does is, it maintains the AC nature of the power supply while still being able to reduce the overall resulting voltage. Likewise, as you can see in the next diagram, the wave is getting chopped after 75% of the wave has already passed. This results in the output being relatively lower:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4a68f836-fb99-4f70-99ce-f1e98e907137.png" style="width:41.17em;height:17.08em;"/></div>
<p>Now you must be asking, how did we actually go ahead and do this? It is done by a relatively complex circuit that detects the phase angle of the wave and then opens or controls a triac, which is a high power bi-directional semiconductor. This leads the power supply to pass or to be stopped at certain phases. We will leave the exact working of this circuit for the next time as it is fairly complex and will not be relevant to this book.</p>
<p>Now coming to the basic point, we know what phase cutting is, we also know that triac is the basic device that lets us do that. But how do we go ahead and do it using Raspberry Pi is the question.</p>
<p>So firstly, we will need an AC-dimmer module. This module already has all the components of phase detection and chopping. So all we need to do is simply control it using simple PWM.</p>
<p>Though I might not have to demonstrate how to connect the circuit or what the code should be, for the sake of understanding, let's connect a light bulb to our Arduino using this module and then control the bulb. Now, the first thing to remember is that the load should be a bulb and not anything else such as an LED light. So go ahead and connect the circuit as shown in the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/87ff5a87-1bdd-4990-92b5-08e1fc8e5f47.png" style="width:41.75em;height:48.75em;"/></div>
<p>Once this is done, go ahead and upload the following code:</p>
<pre>import RPi.GPIO as GPIO<br/>import time                             <br/>GPIO.setmode(GPIO.BCM)       <br/>GPIO.setup(18,GPIO.OUT)         <br/>I = 0<br/>pwm= GPIO.PWM(18,50)<br/><br/>for I &lt; 100:<br/><br/>    I = I+1<br/>    pwm.start(I)<br/>    time.sleep(0.1)<br/><br/><br/>GPIO.cleanup()}</pre>
<p>As expected, the attached light will start to glow very faintly first and will increase the intensity gradually until it reaches 100%. That is how simple it is to control such a complex process.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Intelligent temperature control</h1>
                </header>
            
            <article>
                
<p><span>Now that the basics are done, let's go ahead and build something meaningful using this system. Isn't it difficult to set your air-conditioner to the perfect temperature? No matter what you do, you end up feeling not in the most comfortable spot. This happens due to physiological changes in the body temperature over the course of the day.<br/></span></p>
<p><span>When you wake up, your body temperature is relatively low. It is as much as 1° </span>F, which is lower than the normal body temperature. As the day progresses, the body temperature rises until the time you hit the bed. Once you sleep, again your body temperature starts to dip reaching its lowest point around 4:00-6:00 am in the morning. That's the reason why what might feel warm while you go to bed, can be pretty cold when you wake up. Modern <span>air-conditioners</span><span> </span>have something called a sleep mode. What this does is, it simply increases the temperature through the night. So that you do not feel cold at any point. But then again, how well it works is also a question.</p>
<p>So, now that we know the robotics very well, we will go ahead and make a system of our own that will take care of everything. </p>
<p>In this part, we will connect both the air-conditioner and your fan together so that they can both work in tandem and make you sleep well. Now, before jumping straight into it, I would like you to see the ratings that are mentioned on the relay. As you can see, the relay can handle only 250V and 5 ampere. Now, if you go through the brochure of your air-conditioner, you will easily understand why I am showing all of this to you. The power consumption of the air-conditioner will be much higher than what your relays can handle. So, if you try to run your air conditioner using the normal relays, then you will surely end up blowing the relay. There might be a chance that your appliance will be of a lower current rating than your relay. But with any device that has motors in it just keep in mind that the initial power consumption of that device is much higher than the nominal power consumption. Hence, if your air-conditioner needs 10 ampere nominal, then the starting load may be as much as 15 ampere. You must be thinking, it's not a problem, why don't we just purchase a relay that has a higher rating. Well, correct! That's exactly what we will be doing. But the naming of electronics can be tricky at times. The devices that deal with a higher-power higher-voltage electro-mechanical switching is generally called contractor instead of relay. Technically, they have the same working principal; However, there are construction differences, which at this point would not be our concern. So we will be using a contractor for the air conditioner switching and a dimmer for the fan speed control. Now that this has been cleared up, let's go ahead and attach the hardware as shown in the following diagram: </p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/816fa8b1-760c-4d1c-89c3-2e4609965bc4.png"/></div>
<pre><span><span>import RPi.GPIO as GPIO<br/></span></span><span><span>import time <br/></span></span><span><span>import Adafruit_DHT<br/><br/></span></span><span><span>GPIO.setmode(GPIO.BCM)<br/><br/></span></span><span><span>FAN = 18<br/>AC = 17<br/><br/></span></span>pwm= GPIO.PWM(18,50)<span><span><br/></span></span><span><span>GPIO.setup(FAN,GPIO.OUT)<br/></span></span>GPIO.setup(AC, GPIO.OUT)<span><span><br/></span></span><span><span><br/>while True:<br/><br/></span></span><span>    humidity, temperature = Adafruit_DHT.read_retry(sensor, pin)<br/><br/>    if temperature =&gt;20 &amp;&amp; temperature &lt;=30:<br/><br/>        </span>Duty = 50 + ((temperature-25)*10)<br/><span><span>        </span></span>pwm.start(Duty)<br/><br/>    if temperature &lt;22 :<br/><br/>         GPIO.output(AC, GPIO.LOW)<br/><br/>    if temperature &gt;= 24<br/><br/>         GPIO.output(AC, GPIO.HIGH)}<br/>        </pre>
<p>The logic used here is pretty basic. Let's see what it is doing:</p>
<pre><span>    humidity, temperature = Adafruit_DHT.read_retry(sensor, pin)<br/><br/>    if temperature =&gt;20 &amp;&amp; temperature &lt;=30:<br/><br/>        </span>Duty = 50 + ((temperature-25)*10)<br/><span>        </span>pwm.start(Duty)</pre>
<p>Here we are taking the value of <kbd>humidity</kbd> and <kbd>temperature</kbd>. So far so good, but can we take it a step further and make it even more intelligent? The previous logic must have helped you sleep better, but can we make it just perfect for you?</p>
<p>There are multiple indicators in our body that give us an idea of what the state of the body is. For example, if you are tired, you will probably not be walking very fast or talking very loud. Instead, you would be doing the opposite! Similarly, there are multiple factors that indicate how our sleep cycle is going.</p>
<p>Some of these factors are: body temperature, respiration rate, REM sleep, and body movements. Measuring the exact body temperature or respiration rate and REM sleep is something of a challenge. But when we talk about body movements, I think we have already perfected it. So based on the body movements, we will be sensing how well we are sleeping and what kind of temperature adjustment is needed.</p>
<p>If you notice, whenever someone is sleeping and starts feeling cold, the body will go to a fetal position and will move much less. This happens automatically. However, when a person is comfortable, there are some inevitable movements such as changing sides and movement of arms or legs. This does not happen when a person is feeling cold. So with these movements we can figure out whether a person is feeling cold or not. Now that we have understood the physiological changes of the body, let's try to build a program around it and see what we can achieve.</p>
<p>To do this, firstly, we need to connect the circuit as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/dadeba11-0e9a-4d06-bb94-5f8d2184e8b5.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">Once this is done, go ahead and write the following code:</p>
<pre><span>import RPi.GPIO as GPIO<br/></span><span>import time <br/></span><span>import Adafruit_DHT<br/><br/></span><span>GPIO.setmode(GPIO.BCM)<br/><br/></span><span>FAN = 18<br/>AC = 17<br/>PIR = 22<br/></span><span>PIN = 11<br/>Sensor = 4<br/><br/></span>pwm= GPIO.PWM(18,50)<span><br/></span><span>GPIO.setup(FAN,GPIO.OUT)<br/></span>GPIO.setup(AC, GPIO.OUT)<span><br/></span><span><br/>while True:<br/><br/></span><span>    humidity, temperature = Adafruit_DHT.read_retry(sensor, pin)<br/>    </span><span>H = datetime.datetime.now().strftime('%H') <br/></span><span>    M = datetime.datetime.now().strftime('%M')<br/><br/>    if H &lt;= 6 &amp;&amp; H &lt;= 22:<br/><br/>        if M &lt;=58 :<br/><br/>           </span><span>M = datetime.datetime.now().strftime('%M')<br/>           </span><span>humidity, temperature = Adafruit_DHT.read_retry(sensor, pin)<br/></span><span>           <br/>           if </span><span>GPIO.input(PIR) == 0 :<br/>                <br/>                Movement = Movement + 1<br/>                time.sleep(10)<br/><br/>           if temperature &lt; 28:</span><span><br/>        <br/>                if Movement &gt; 5 :<br/><br/>                    Duty = Duty + 10<br/>                    </span>pwm.start(Duty)<br/>                    Movement = 0     <br/><br/>        if M = 59 : <br/><br/>            if Movement = 0 :<br/><br/>                Duty = Duty -10<br/>                pwm.start(Duty)<br/><br/>            Movement = 0<br/><br/>        if temperature &lt;22 :<br/><br/>           GPIO.output(AC, GPIO.LOW)<br/><br/>       if temperature &gt;= 24 &amp;&amp; H &lt;= 6 &amp;&amp; H &gt;= 22:<br/><br/>           GPIO.output(AC, GPIO.HIGH)<br/><br/>        if temperature &gt; 27<br/><br/>            pwm.start(100)<br/><br/>    for H &gt; 7 &amp;&amp; H &lt; 20 <br/><br/>        GPIO.output(AC, GPIO.LOW)<br/><br/>    if H = 20 <br/><br/>        GPIO.output(AC,GPIO.HIGH)<br/><span><br/></span><span>}</span></pre>
<p>Let's have a look at what is going on under the hood:</p>
<pre><span>    if H &lt;= 6 &amp;&amp; H &lt;= 22:<br/><br/>        if M &lt;=58 :<br/><br/>           </span><span>M = datetime.datetime.now().strftime('%M')<br/>           </span><span>humidity, temperature = Adafruit_DHT.read_retry(sensor, pin)</span></pre>
<p>The first thing you will see is that we have a condition: <kbd>if H,= 6 &amp;&amp; H&lt;= 22:</kbd>. This condition will only be true if the time frame is between 10 o'clock in the morning and <span> 6 o'clock in the night</span>. That is because this is the time when we generally sleep. Hence, the logic under this head will only work if it's time to sleep.</p>
<p>The second condition is <kbd>if M &lt;= 58</kbd>, which will be true only when the time is between <kbd>0</kbd> and <kbd>58</kbd> minutes. So when the time is <kbd>M = 59</kbd>, then this condition will not work. We will see the reason for having this logic.</p>
<p>Thereafter, we are calculating the time and storing the value in a variable called <kbd>M</kbd>. We are also calculating the humidity and temperature values and storing it in variables called <kbd>temperature</kbd> and <kbd>humidity</kbd>:</p>
<pre><span>           if </span><span>GPIO.input(PIR) == 0 :<br/>                <br/>                Movement = Movement + 1<br/>                time.sleep(10)<br/></span></pre>
<p>Now, in this line, we are implementing a condition which will be true if the reading from the PIR is high. That is, there is some motion that will be detected. Whenever this happens, the <kbd>Movement</kbd> <span>variable </span>will be incremented by <kbd>1</kbd>. Finally, we are using the <kbd>time.sleep(10)</kbd> function to wait for <kbd>10</kbd> seconds. This is done as the PIR might be high for a momentary period. In that case, the condition will be true over and over again which in turn will increment the value of <kbd>Movement</kbd> multiple times.</p>
<p>Our purpose of incrementing the value of <kbd>Movement</kbd> is to count the number of times the person has moved. Hence, incrementing it multiples times in one single time will defy the objective.</p>
<pre><span>           if temperature &lt; 28:</span><span><br/>        <br/>                if Movement &gt; 5 :<br/><br/>                    Duty = Duty + 10<br/>                    </span>pwm.start(Duty)<br/>                    Movement = 0</pre>
<p>Now we have another condition, which says <kbd>if temperature &lt; 28</kbd>. Not much explanation is needed for when the condition will be true. So whenever the condition is true and if the counted number of <kbd>Movement</kbd> is more than <kbd>5</kbd>, the value of <kbd>Duty</kbd> will be incremented by <kbd>10</kbd>. Therefore, we are sending the PWM to the AC dimmer, which in turn will increase the speed of the fan. Finally, we are resetting the value of <kbd>Movement</kbd> to <kbd>0</kbd>.</p>
<p>So essentially, we are just counting the number of movements. This movement is counted only if the temperature is less than 28° C. If the movement is more than <kbd>5</kbd>, then we will increase the speed of the fan by 10%.</p>
<pre>        if M = 59 : <br/><br/>            if Movement = 0 :<br/><br/>                Duty = Duty -10<br/>                pwm.start(Duty)<br/><br/>            Movement = 0</pre>
<p>In the previous section, the logic will only work when the time is between <kbd>0</kbd> and <kbd>58</kbd>, that is, the time in which the counting will happen. When the value of <kbd>M</kbd> is <kbd>59</kbd>, then the condition <kbd>if Movement = 0</kbd> will be checked, and if true, then the value of <kbd>Duty</kbd> will be decremented by <kbd>10</kbd>. This in turn will reduce the speed of the fan by 10%. Also, once this condition is executed, the value of <kbd>Movement</kbd> will be reset to <kbd>0</kbd>. So then a new cycle can start for the next hour. </p>
<p>Now what it basically means is that counting will happen on an hourly basis. If the <kbd>Movement</kbd> is more than <kbd>5</kbd> then immediately the value of the <kbd>Duty</kbd> would be increased. However, if that is not the case, then the program will wait until the minute approaches the value of <kbd>59</kbd> and whenever that happens, it will check whether there is any movement, in which case, the fan speed will be decreased.</p>
<pre>        if temperature &lt;22 :<br/><br/>           GPIO.output(AC, GPIO.LOW)<br/><br/>        if temperature &gt;= 24 &amp;&amp; H &lt;= 6 &amp;&amp; H &gt;= 22: <br/><br/>           GPIO.output(AC, GPIO.HIGH)<br/><br/>        if temperature &gt; 27<br/><br/>            pwm.start(100)</pre>
<p>All of this code is very straightforward. If the temperature is less than <kbd>22</kbd>, then the AC will be switched off. Furthermore, if the temperature is equal to or more than <kbd>24</kbd>, and time is between 10:00 p.m. and 6:00 a.m., then the AC will be turned on. Finally, if the temperature is more than <kbd>27</kbd>, then the fan will be switch on to 100% speed.</p>
<pre>    for H &gt; 7 &amp;&amp; H &lt; 20 <br/><br/>        GPIO.output(AC, GPIO.LOW)<br/><br/>    if H = 20 <br/><br/>        GPIO.output(AC,GPIO.HIGH)</pre>
<p>Finally, we are making sure by using the condition <kbd>for H &gt; 7 &amp;&amp; H &lt;20</kbd> that during this time the AC is always switched off. Also, if <kbd>H = 20</kbd>, then the AC should be turned on so that the room is cooled before you are ready to sleep.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding more </h1>
                </header>
            
            <article>
                
<p>As you would have understood by now, we can control any AC electrical appliances as per our needs. We have understood switching and have also perfected the way we can vary the intensity of light and the speed of fans. But did you notice one thing? Sooner or later as our system gets more and more complex, the number of GPIOs needed will increase. There will come a moment when you will want to have more and more devices connected to your Raspberry Pi; however, you will not be able to do so due to lack of physical ports.</p>
<p>This is a very common situation in electronics. As always, there is a solution for this problem as well. This solution is known as a multiplexer. The basic job of a multiplexer is to multiply the number of ports in any computer system. Now you must be thinking, how is it able to do so?</p>
<p>The concept is extremely simple. Let's first look at the diagram of a multiplexer here: </p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/791608bb-5514-40a0-a239-ccbd83872423.png" style="width:42.17em;height:17.75em;"/></div>
<p>In the preceding diagram, you can see that there are two ends to the multiplexer—one being the signal output lines and the other opposite to it. The first thing we need to understand is that the multiplexer is a bidirectional device, that is, it sends the data from the multiplexer to the connected devices and also vice versa.</p>
<p>Now, firstly, we have the power line, which is pretty basic. It is there to power up the multiplexer itself. Then, we have <strong>Signal Lines</strong>, which have two ports, the <strong>Sig</strong> and <strong>EN</strong>. <strong>EN</strong> stands for enable, which means that until the time <strong>EN</strong> is not high, the data communication will not happen either way. Then we have something called <strong>Sig</strong>. This is the port that is connected to the GPIO of Raspberry Pi for data communication. Next we have the selection line. As you can see, we have four ports for it, namely, <strong>S0</strong>, <strong>S1</strong>, <strong>S2</strong>, and <strong>S3</strong>. The selection lines have a purpose of selecting a particular port that needs to be selected. The following is a table that will clarify what exactly is happening:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td><strong>S0</strong></td>
<td><strong>S1</strong></td>
<td><strong>S3</strong></td>
<td><strong>S4</strong></td>
<td><strong>Selected output</strong></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>C0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>C1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>C2</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>C3</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>C4</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>C5</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>C6</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>C7</td>
</tr>
<tr>
<td>
<p class="mce-root">0</p>
</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>
<p class="mce-root">C8</p>
</td>
</tr>
<tr>
<td>
<p class="mce-root">1</p>
</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>
<p class="mce-root">C9</p>
</td>
</tr>
<tr>
<td>
<p class="mce-root">0</p>
</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>
<p class="mce-root">C10</p>
</td>
</tr>
<tr>
<td>
<p class="mce-root">1</p>
</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>
<p class="mce-root">C11</p>
</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>
<p class="mce-root">C12</p>
</td>
</tr>
<tr>
<td>
<p class="mce-root">1</p>
</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>
<p class="mce-root">C13</p>
</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>
<p class="mce-root">C14</p>
</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>
<p class="mce-root">C15</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">In the preceding table, you can see that by using various logic combinations on the selection lines, various lines can be addressed. Let's say, for example, we have the following sequence on the selection pins—S0 = 1, S1 = 0, S2 = 1, S3 = 1. If this is the input on the selection pins from Raspberry Pi, then the pin number C13 will be selected. This basically means that now C13 can communicate the data to and from the pin <strong>Sig</strong> for the multiplexer. Also, we must remember that the enable pin must be high for the data transfer to happen.</p>
<p class="mce-root">In a similar fashion, we can go ahead and address all the 16 pins of the multiplexer. Hence, if we see it logically, then by using six pins of Raspberry Pi, we can go ahead and utilize 16 GPIOs. Now that we have understood the basics of multiplexing, let's go ahead and try using one of them.</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f5ee592f-1b26-414f-9a0e-1dedf0b903c1.png"/></div>
<p>Once the hardware is connected, let's go ahead and upload the following code:</p>
<pre><span><span>import RPi.GPIO as GPIO<br/></span></span><span><span>import time<br/></span></span> <br/><span><span>GPIO.setmode(GPIO.BCM)<br/></span></span><span><span>GPIO.setwarnings(False)<br/><br/></span></span><span><span>S0 = 21<br/></span></span><span><span>S1 = 22<br/></span></span><span><span>S2 = 23<br/></span></span><span><span>S3 = 24<br/><br/></span></span><span><span>GPIO.setup(S0,GPIO.OUT)<br/></span></span><span><span>GPIO.setup(S1,GPIO.OUT) <br/></span></span><span><span>GPIO.setup(S2,GPIO.OUT)<br/><br/></span></span><span><span>While True:<br/><br/></span></span><span><span>    GPIO.output(S0,1)<br/></span></span><span><span>    GPIO.output(S1,0)<br/></span></span><span><span>    GPIO.output(S2,1)<br/></span></span><span><span>    GPIO.output(S4,1)<br/><br/></span></span><span><span>    time.sleep(1)<br/><br/></span></span><span><span>    GPIO.output(S0,1)<br/></span></span><span><span>    GPIO.output(S1,1)<br/></span></span><span><span>    GPIO.output(S2,1)<br/></span></span><span><span>    GPIO.output(S4,1)<br/><br/></span></span><span><span>    time.sleep(1)<br/><br/></span></span><span><span>    GPIO.output(S0,1)<br/></span></span><span><span>    GPIO.output(S1,0)<br/></span></span><span><span>    GPIO.output(S2,0)<br/></span></span><span><span>    GPIO.output(S4,1)<br/><br/></span></span><span><span>    time.sleep(1)<br/><br/></span></span><span><span>    'GPIO.output(S0,0)<br/></span></span><span><span>    GPIO.output(S1,0)<br/></span></span><span><span>    GPIO.output(S2,0)<br/></span></span><span><span>    GPIO.output(S4,1)<br/><br/></span></span><span><span>    time.sleep(1)<br/><br/></span></span><span>    GPIO.output(S0,0)<br/></span><span>    GPIO.output(S1,1)<br/></span><span>    GPIO.output(S2,0)<br/></span><span>    GPIO.output(S4,1)<br/><br/></span><span>    time.sleep(1)</span><span><span> }</span></span></pre>
<p>Here, what we are essentially doing is, triggering the selection lines one by one to address every single port where the LED is connected. Whenever that happens, the LED corresponding to it glows. Also, the reason it glows is because the signal port <kbd>Sig</kbd> is connected to 3.3V of Raspberry Pi. Hence, send a logic high to whichever port it is connected to.</p>
<p>This is one of the basic ways in which the multiplexer works. This can be incredibly useful when we will be using multiple devices and sensors.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we enabled Jarvis to automate your home appliances under different conditions, also applying various properties to the system. So go on and try many other scenarios under which you can enhance your home automation system.</p>
<p>In the next chapter, we will enable Jarvis IoT, thus controlling the appliances from your mobile phone using Wi-Fi and the internet.</p>


            </article>

            
        </section>
    </div></body></html>