<html><head></head><body>
		<div id="_idContainer148">
			<h1 id="_idParaDest-747" class="chapter-number"><a id="_idTextAnchor929"/>16</h1>
			<h1 id="_idParaDest-748"><a id="_idTextAnchor930"/>The Odoo Web Library (OWL)</h1>
			<p>The Odoo V17 Javascript framework uses a custom component framework called <strong class="bold">OWL </strong>(short for <strong class="bold">Odoo Web Library</strong>). It is a <a id="_idIndexMarker1139"/>declarative component <a id="_idIndexMarker1140"/>system loosely inspired by <strong class="bold">Vue</strong> and <strong class="bold">React</strong>. <strong class="bold">OWL</strong> is a component-based <a id="_idIndexMarker1141"/>UI framework and uses QWeb templates for structure. OWL is very <a id="_idIndexMarker1142"/>fast compared to Odoo’s legacy widget system and introduces tons of <a id="_idIndexMarker1143"/>new features, including <strong class="bold">hooks</strong>, <strong class="bold">reactivity</strong>, the <strong class="bold">auto instantiation</strong> of <strong class="bold">subcomponents</strong>, and <span class="No-Break">more besides.</span></p>
			<p>In this chapter, we will <a id="_idIndexMarker1144"/>learn how to use an OWL component to generate interactive UI elements. We will start with a minimal OWL component and then we will learn about the component’s life cycle. Finally, we will create a new field widget for the form view. In this chapter, we will cover the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Creating an <span class="No-Break">OWL component</span></li>
				<li>Managing user actions in an <span class="No-Break">OWL component</span></li>
				<li>Making OWL components <span class="No-Break">with hooks</span></li>
				<li>Understanding the OWL component <span class="No-Break">life cycle</span></li>
				<li>Adding an OWL field to the <span class="No-Break">form view</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">The following question may occur to you: why is Odoo not using some well-known JavaScript frameworks, such as React.js or Vue.js? Please check out the following link for more <span class="No-Break">information: </span><a href="https://github.com/odoo/owl/blob/master/doc/miscellaneous/comparison.md"><span class="No-Break">https://github.com/odoo/owl/blob/master/doc/miscellaneous/comparison.md</span></a><span class="No-Break">.</span></p>
			<p class="callout">You can <a id="_idIndexMarker1145"/>refer to <a href="https://github.com/odoo/owl">https://github.com/odoo/owl</a> to learn more about the <span class="No-Break">OWL framework.</span></p>
			<h1 id="_idParaDest-749"><a id="_idTextAnchor931"/>Technical requirements</h1>
			<p>OWL components are defined with ES6 classes. In this chapter, we will be using some ES6 syntax. Also, some ES6 syntaxes are not supported by old browsers, so make sure you are using the latest version of Chrome or Firefox. You will find the code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16"><span class="No-Break">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-750"><a id="_idTextAnchor932"/>Creating an OWL component</h1>
			<p>The main building blocks of OWL are components <span class="No-Break">and templates.</span></p>
			<p>In OWL, every part <a id="_idIndexMarker1146"/>of the UI is managed by a component: they hold the logic and define the templates that are used to render the <span class="No-Break">user interface</span></p>
			<p>The goal of this recipe is to learn the basics of an OWL component. We will create a minimal OWL component and append it to the Odoo web client. In this recipe, we will create a component for a small horizontal bar with <span class="No-Break">som<a id="_idTextAnchor933"/>e text.</span></p>
			<h2 id="_idParaDest-751"><a id="_idTextAnchor934"/>Getting ready</h2>
			<p>For this recipe, we will be using the <strong class="source-inline">my_hostel</strong> module with basic fields and views. You will find the basic <strong class="source-inline">my_hostel</strong> module in the <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/00_initial_module/my_hostel">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/00_initial_module/my_hostel</a> directory in the <span class="No-Break">GitHub repository.</span></p>
			<h2 id="_idParaDest-752"><a id="_idTextAnchor935"/>How to do it...</h2>
			<p>We will add a small horizontal bar component to the Odoo web client. Follow these steps to add your first component to the Odoo <span class="No-Break">web client:</span></p>
			<ol>
				<li>Add a  <strong class="source-inline">my_hostel/static/src/js/component.js</strong> JavaScript file and define the new <span class="No-Break">module’s namespace:</span><pre class="source-code">
    odoo.define('my_hostel.component', [], function (require) {
    "use strict";
    console.log("Load component......");
});</pre></li>				<li>Add the component JavaScript <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">assets</strong></span><span class="No-Break">:</span><pre class="source-code">
'assets': {
    'web.assets_backend': [
        'my_hostel/static/src/js/component.js',
    ],
},</pre></li>				<li>Define the <a id="_idIndexMarker1147"/>OWL utilities to the <strong class="source-inline">component.js</strong> file created in <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">:</span><pre class="source-code">
const { Component, mount, xml , whenReady } = owl;</pre></li>				<li>Add the OWL component and its basic template to the <strong class="source-inline">component.js</strong> file created in <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">:</span><pre class="source-code">
class MyComponent extends Component {
    static template = xml`
        &lt;div class="bg-info text-white text-center p-3"&gt;
            &lt;b&gt; Welcome To Odoo &lt;/b&gt;
        &lt;/div&gt;`
}</pre></li>				<li>Initialize and append the component to the web client. Add this to the <strong class="source-inline">component.js</strong> file added in <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">:</span><pre class="source-code">
whenReady().then(() =&gt; {
    mount(MyComponent, document.body);
});</pre></li>			</ol>
			<p>Install/upgrade the <strong class="source-inline">my_hostel</strong> module to apply our changes. Once our module is loaded in Odoo, you will see the horizontal bar, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B20997_16_01.jpg" alt="Figure 16.1 – OWL component"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1 – OWL component</p>
			<p>This is just a simple component. Right now, it will not handle any user events and you cannot <span class="No-Break">rem<a id="_idTextAnchor936"/>ove it.</span></p>
			<h2 id="_idParaDest-753"><a id="_idTextAnchor937"/>How it works...</h2>
			<p>In <em class="italic">step 1</em> and <em class="italic">step 2</em>, we added a JavaScript file and listed it in the backend assets. If you want to learn more about assets, refer to the <em class="italic">Static assets management</em> recipe in <a href="B20997_14.xhtml#_idTextAnchor734"><span class="No-Break"><em class="italic">Chapter 14</em></span></a><em class="italic">, CMS </em><span class="No-Break"><em class="italic">Website Development</em></span><span class="No-Break">.</span></p>
			<p>In <em class="italic">step</em> <em class="italic">3</em>, we initialized <a id="_idIndexMarker1148"/>a variable from OWL. All the utilities from OWL are available under a single global variable, <strong class="source-inline">owl</strong>. In our example, we pulled an OWL utility. we declared <strong class="source-inline">Component</strong>, <strong class="source-inline">mount</strong>, <strong class="source-inline">xml</strong> , <strong class="source-inline">whenReady</strong>. <strong class="source-inline">Component</strong> is the main class for the <strong class="source-inline">OWL</strong> component and, by extending it, we will create our <span class="No-Break">own components.</span></p>
			<p>In <em class="italic">step 4,</em> we created our component, <strong class="source-inline">MyComponent</strong>, by extending OWL’s <strong class="source-inline">Component</strong> class. For the sake of simplicity, we have just added the QWeb template to the definition of the <strong class="source-inline">MyComponent</strong> class. Here, as you may have noticed, we have used <strong class="source-inline">xml`…`</strong> to declare our template. This syntax is known as an <span class="No-Break">inline template.</span></p>
			<p>However, you can load QWeb templates via separate files, which is usually the case. We will see examples of external QWeb templates in the <span class="No-Break">upcoming recipes.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Inline QWeb templates do not support translations or modifications via inheritance. So, always endeavor to load QWeb templates from a <span class="No-Break">separate file.</span></p>
			<p>In <em class="italic">step 5</em>, we instantiated the <strong class="source-inline">MyComponent</strong> component and appended it to the body. The OWL component is an ES6 class, so you can create an object via the <strong class="source-inline">new</strong> keyword. Then you can use the <strong class="source-inline">mount()</strong> method to add the component to the page. If you notice, we have <a id="_idIndexMarker1149"/>placed our code inside the <strong class="source-inline">whenReady()</strong> callback. This will ensure that all OWL functionality is properly loaded before we start using <span class="No-Break">OWL co<a id="_idTextAnchor938"/>mponents.</span></p>
			<h2 id="_idParaDest-754"><a id="_idTextAnchor939"/>There’s more...</h2>
			<p>OWL is a separate library and is loaded in Odoo as an external JavaScript library. You can use OWL in <a id="_idIndexMarker1150"/>your other projects, too. The OWL library is listed at <a href="https://github.com/odoo/owl">https://github.com/odoo/owl</a>. There is also an online playground available in case you just want to test OWL without setting it in your local machine. You can play with OWL <span class="No-Break">at </span><a href="https://odoo.github.io/owl/playground/"><span class="No-Break">https://odoo.github.io/owl/pl<span id="_idTextAnchor940"/>ayground/</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-755"><a id="_idTextAnchor941"/>Managing user actions in an OWL component</h1>
			<p>To make <a id="_idIndexMarker1151"/>the UI interactive, components <a id="_idIndexMarker1152"/>need to handle <strong class="source-inline">user actions</strong> such as <strong class="source-inline">click</strong>, <strong class="source-inline">hover</strong>, and <strong class="source-inline">form submission</strong>. In this recipe, we will add a button to our component, and we will handle a <a id="_idTextAnchor942"/><span class="No-Break">click event.</span></p>
			<h2 id="_idParaDest-756"><a id="_idTextAnchor943"/>Getting ready</h2>
			<p>For this recipe, we will continue using the <strong class="source-inline">my_hostel</strong> module from the <span class="No-Break">prev<a id="_idTextAnchor944"/>ious recipe.</span></p>
			<h2 id="_idParaDest-757"><a id="_idTextAnchor945"/>How to do it...</h2>
			<p>In this recipe, we will add a delete button to the component. Upon clicking the delete button, the component gets removed. Perform the following steps to add a delete button and its event in <span class="No-Break">the component:</span></p>
			<ol>
				<li>Update the QWeb template and add an icon to remove <span class="No-Break">the bar:</span><pre class="source-code">
class MyComponent extends Component {
    static template = xml`
        &lt;div class="bg-info text-white text-center p-3"&gt;
            &lt;b&gt; Welcome To Odoo &lt;/b&gt;
            &lt;i class="fa fa-close p-1 float-end"
               style="cursor: pointer;"
               t-on-click="onRemove"&gt; &lt;/i&gt;
        &lt;/div&gt;`
}</pre></li>				<li>To remove <a id="_idIndexMarker1153"/>the component, add <a id="_idIndexMarker1154"/>the <strong class="source-inline">onRemove</strong> method to the <strong class="source-inline">MyComponent</strong> class, <span class="No-Break">as follows:</span><pre class="source-code">
class MyComponent extends Component {
    static template = xml`
        &lt;div class="bg-info text-white text-center p-3"&gt;
            &lt;b&gt; Welcome To Odoo &lt;/b&gt;
            &lt;i class="fa fa-close p-1 float-end"
               style="cursor: pointer;"
               t-on-click="onRemove"&gt; &lt;/i&gt;
        &lt;/div&gt;`
    onRemove(ev) {
        $(ev.target).parent().remove();
    }
}</pre></li>			</ol>
			<p>Update the module to apply the changes. Following the update, you will see a little cross icon on the right side of the bar, as in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B20997_16_02.jpg" alt="Figure 16.2 – The remove button on the top bar component"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 – The remove button on the top bar component</p>
			<p>Upon clicking the remove icon, our OWL component will be removed. The bar will reappear when you rel<a id="_idTextAnchor946"/>oad <span class="No-Break">the page.</span></p>
			<h2 id="_idParaDest-758"><a id="_idTextAnchor947"/>How it works…</h2>
			<p>In <em class="italic">step 1</em>, we added a remove icon to the component. We have added a <strong class="source-inline">t-on-click</strong> attribute. This <a id="_idIndexMarker1155"/>will be used to bind a click event. The <a id="_idIndexMarker1156"/>value of the attribute will be the method in the component. In our example, we have used <strong class="source-inline">t-on-click="onRemove"</strong>. This implies that when the user clicks on the remove icon, the <strong class="source-inline">onRemove</strong> method in the component will be called. The syntax to define the event <span class="No-Break">is simple:</span></p>
			<pre class="source-code">
t-on-&lt;name of event&gt;="&lt;method name in component&gt;"</pre>			<p>For example, if you want to call the method when the user moves the mouse over the component, you can do so by adding the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
t-on-mouseover="onMouseover"</pre>			<p>After adding the preceding code, whenever the user moves the mouse cursor over the component, OWL will call the <strong class="source-inline">onMouseover</strong> method specified in <span class="No-Break">the component.</span></p>
			<p>In <em class="italic">step 2</em>, we have added the <strong class="source-inline">onRemove</strong> method. This method will be called when the user clicks on the remove icon. In the method, we have called the <strong class="source-inline">remove()</strong> method, which will remove the component from the DOM. We will be seeing several default methods in the <span class="No-Break">up<a id="_idTextAnchor948"/>coming recipes.</span></p>
			<h2 id="_idParaDest-759"><a id="_idTextAnchor949"/>There’s more...</h2>
			<p>Event handling is not limited to the DOM events. You can use your custom events as well. For instance, if you are manually triggering the event called <strong class="source-inline">my-custom-event</strong>, you can use <strong class="source-inline">t-on-my-custom-event</strong> to catch <span class="No-Break">custom-tr<a id="_idTextAnchor950"/>iggered events.</span></p>
			<h1 id="_idParaDest-760"><a id="_idTextAnchor951"/>Making OWL components with hooks</h1>
			<p>OWL is a <a id="_idIndexMarker1157"/>powerful framework and supports automatic <a id="_idIndexMarker1158"/>updates for the UI based on <strong class="bold">hooks</strong>. With update <a id="_idIndexMarker1159"/>hooks, a component’s UI will be automatically updated when the internal state of the component is changed. In this recipe, we will update the message in the component base<a id="_idTextAnchor952"/>d on <span class="No-Break">user actions.</span></p>
			<h2 id="_idParaDest-761"><a id="_idTextAnchor953"/>Getting ready</h2>
			<p>For this recipe, we will continue using the <strong class="source-inline">my_hostel</strong> module from th<a id="_idTextAnchor954"/>e <span class="No-Break">previous recipe.</span></p>
			<h2 id="_idParaDest-762"><a id="_idTextAnchor955"/>How to do it…</h2>
			<p>In this recipe, we will add arrows around the text in the component. When we click on the arrow, we will change the message. Follow these steps to make the OWL <span class="No-Break">component reactive:</span></p>
			<ol>
				<li>Update the XML template of the component. Add two buttons with an event directive around the text. Also, retrieve the message dynamically from <span class="No-Break">the list:</span><pre class="source-code">
static template = xml`
    &lt;div class="bg-info text-white text-center p-3"&gt;
        &lt;i class="fa fa-arrow-left p-1"
           style="cursor: pointer;"
           t-on-click="onPrevious"&gt; &lt;/i&gt;
        &lt;b t-esc="messageList[Math.abs(state.currentIndex%4)]"/&gt;
        &lt;i class="fa fa-arrow-right p-1"
           style="cursor: pointer;"
           t-on-click="onNext"&gt; &lt;/i&gt;
        &lt;i class="fa fa-close p-1 float-end"
           style="cursor: pointer;"
           t-on-click="onRemove"&gt; &lt;/i&gt;
    &lt;/div&gt;`</pre></li>				<li>In the <a id="_idIndexMarker1160"/>JavaScript file of the component, import the <strong class="source-inline">useState</strong> hook <span class="No-Break">as follows:</span><pre class="source-code">
const { Component, mount, xml , whenReady, useState } = owl;</pre></li>				<li>Add the <strong class="source-inline">setup</strong> method <a id="_idIndexMarker1161"/>to the component and initialize some variables <span class="No-Break">as follows:</span><pre class="source-code">
setup() {
    this.messageList = [
        'Hello World',
        'Welcome to Odoo',
        'Odoo is awesome',
        'You are awesome too'
    ];
    this.state = useState({ currentIndex: 0 });
}</pre></li>				<li>In the <strong class="source-inline">Component</strong> class, add methods to handle the user’s <span class="No-Break">click event:</span><pre class="source-code">
onNext(ev) {
    this.state.currentIndex++;
}
onPrevious(ev) {
    this.state.currentIndex--;
}</pre></li>			</ol>
			<p>Restart and update the module to apply the changes to the module. Following the update, you will see the two arrow icons around the text <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B20997_16_03.jpg" alt="Figure 16.3 – Arrows around the text"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3 – Arrows around the text</p>
			<p>If you click on the arrow, the message text will be changed based on the list of messages <a id="_idTextAnchor956"/>in <span class="No-Break">the constructor.</span></p>
			<h2 id="_idParaDest-763"><a id="_idTextAnchor957"/>How it works...</h2>
			<p>In <em class="italic">step 1</em>, we updated the XML template of our component. Basically, we made two changes to the template. We rendered the text message from the list of messages, and we selected <a id="_idIndexMarker1162"/>the message based on the value of <strong class="source-inline">currentIndex</strong> in the state variable. We added two arrow icons around the text block. In the <a id="_idIndexMarker1163"/>arrow icons, we added <strong class="source-inline">the t-on-click</strong> attribute to bind the click event to <span class="No-Break">the arrow.</span></p>
			<p>In <em class="italic">step 2</em>, we imported the <strong class="source-inline">useState</strong> hook from OWL. This hook is used to handle the state of <span class="No-Break">the component.</span></p>
			<p>In <em class="italic">step 3</em>, we added a <strong class="source-inline">setup</strong>. This will be called when you create an instance of the object. In the <strong class="source-inline">setup</strong>, we added a list of messages that we want to show, and then we added the <strong class="source-inline">state</strong> variable using the <strong class="source-inline">useState</strong> hook. This will make the component reactive. When the <strong class="source-inline">state</strong> is <strong class="source-inline">changed</strong>, the <strong class="source-inline">UI</strong> will be updated based on the new state. In our example, we used <strong class="source-inline">currentIndex</strong> in the <strong class="source-inline">useState</strong> hook. This implies that whenever the value of <strong class="source-inline">currentIndex</strong> changes, the UI will be updated <span class="No-Break">as well.</span></p>
			<p class="callout-heading">Important information</p>
			<p class="callout">There is only one rule for defining hooks, which is that the hooks will only work if you have declared them in <strong class="source-inline">setup</strong>. Several other types of hooks are available, which you can find <span class="No-Break">here: </span><a href="https://github.com/odoo/owl/blob/master/doc/reference/hooks.md"><span class="No-Break">https://github.com/odoo/owl/blob/master/doc/reference/hooks.md</span></a><span class="No-Break">.</span></p>
			<p>In <em class="italic">step 4</em>, we added <a id="_idIndexMarker1164"/>methods to handle the click events <a id="_idIndexMarker1165"/>of the arrow. Upon clicking the arrow, we are changing the state of the component. As we are using a hook on the state, the UI of the component will be<a id="_idTextAnchor958"/> <span class="No-Break">automatically updated.</span></p>
			<h1 id="_idParaDest-764"><a id="_idTextAnchor959"/>Understanding the OWL component life cycle</h1>
			<p>OWL components have several methods that help developers to create powerful and interactive <a id="_idIndexMarker1166"/>components. Some of the important methods of the OWL components are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">setup()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onWillStart()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onWillRender()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onRendered()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onMounted()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onWillUpdateProps()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onWillPatch()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onPatched()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onMounted()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onWillUnmount()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onWillDestroy()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">onError()</strong></span></li>
			</ul>
			<p>In this recipe, we will log the message in the console to help us understand the life cyc<a id="_idTextAnchor960"/>le of the <span class="No-Break">OWL component.</span></p>
			<h2 id="_idParaDest-765"><a id="_idTextAnchor961"/>Getting ready</h2>
			<p>For this recipe, we will continue using the <strong class="source-inline">my_hostel</strong> module f<a id="_idTextAnchor962"/>rom the <span class="No-Break">previous recipe.</span></p>
			<h2 id="_idParaDest-766"><a id="_idTextAnchor963"/>How to do it…</h2>
			<p>To add methods <a id="_idIndexMarker1167"/>of the component to show the life cycle of an OWL component, you need to carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>First, you need to import the <strong class="source-inline">all</strong> hook, <span class="No-Break">as follows:</span><pre class="source-code">
const {
        Component,
        mount,
        whenReady,
        onWillStart,
        onMounted,
        onWillUnmount,
        onWillUpdateProps,
        onPatched,
        onWillPatch,
        onWillRender,
        onRendered,
        onError,
        onWillDestroy,
    } = owl;</pre></li>				<li>As we already have <strong class="source-inline">setup</strong> in the component, let’s add a message to the console <span class="No-Break">like this:</span><pre class="source-code">
setup() {
     console.log('CALLED:&gt; setup');
}</pre></li>				<li>Add the <strong class="source-inline">willStart</strong> method to <span class="No-Break">the component:</span><pre class="source-code">
setup() {
    onWillStart(async () =&gt; {
        console.log('CALLED:&gt; willStart');
    });
}</pre></li>				<li>Add the <strong class="source-inline">willrender</strong> method <a id="_idIndexMarker1168"/>to <span class="No-Break">the component:</span><pre class="source-code">
setup() {
    onWillRender(() =&gt; {
        console.log('CALLED:&gt; willRender');
    });
}</pre></li>				<li>Add the <strong class="source-inline">render</strong> method to <span class="No-Break">the component:</span><pre class="source-code">
setup() {
    onRendered(() =&gt; {
        console.log('CALLED:&gt; Rendered');
    });
}</pre></li>				<li>Add the <strong class="source-inline">mounted</strong> method to <span class="No-Break">the component:</span><pre class="source-code">
setup() {
    onMounted(() =&gt; {
        console.log('CALLED:&gt; Mounted');
    });
}</pre></li>				<li>Add the <strong class="source-inline">willUpdateProps</strong> method to <span class="No-Break">the component:</span><pre class="source-code">
setup() {
    onWillUpdateProps(() =&gt; {
        console.log('CALLED:&gt; WillUpdateProps');
    });
}</pre></li>				<li>Add the <strong class="source-inline">willPatch</strong> method <a id="_idIndexMarker1169"/>to <span class="No-Break">the component:</span><pre class="source-code">
setup() {
    onWillPatch(() =&gt; {
        console.log('CALLED:&gt; WillPatch');
    });
}</pre></li>				<li>Add the <strong class="source-inline">patched</strong> method to <span class="No-Break">the component:</span><pre class="source-code">
setup() {
    onPatched(() =&gt; {
        console.log('CALLED:&gt; Patch');
    });
}</pre></li>				<li>Add the <strong class="source-inline">willUnmount</strong> method to <span class="No-Break">the component:</span><pre class="source-code">
setup() {
    onWillUnmount(() =&gt; {
        console.log('CALLED:&gt; WillUnmount');
    });
}</pre></li>				<li>Add the <strong class="source-inline">willDestroy</strong> method to <span class="No-Break">the component:</span><pre class="source-code">
setup() {
    onWillDestroy(() =&gt; {
        console.log('CALLED:&gt; WillDestroy');
    });
}</pre></li>				<li>Add the <strong class="source-inline">Error</strong> method <a id="_idIndexMarker1170"/>to <span class="No-Break">the component:</span><pre class="source-code">
setup() {
    onError(() =&gt; {
        console.log('CALLED:&gt; Error');
    });
}</pre></li>			</ol>
			<p>Restart and update the module to apply the module changes. Following the update, perform some operations, such as changing the message via arrows and removing the component. In the browser console, you will see the logs <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B20997_16_04.jpg" alt="Figure 16.4 – Logs in the browser console"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4 – Logs in the browser console</p>
			<p>You may have different logs based on the operation you have <a id="_idTextAnchor964"/>performed on <span class="No-Break">the component.</span></p>
			<h2 id="_idParaDest-767"><a id="_idTextAnchor965"/>How it works…</h2>
			<p>In this recipe, we have <a id="_idIndexMarker1171"/>added several methods and added logged messages to the method. You can use these methods based on your requirements. Let’s see the life cycle of the component and when these methods <span class="No-Break">are called.</span></p>
			<h3>setup</h3>
			<p><strong class="source-inline">setup</strong> is run just <a id="_idIndexMarker1172"/>after the component is constructed. It is a life cycle method that’s very similar to the <strong class="source-inline">constructor</strong>, except that it does not receive <span class="No-Break">any arguments.</span></p>
			<p>It is the proper place to call hook functions. Note that one of the main reasons to have the setup hook in the <a id="_idIndexMarker1173"/>component lifecycle is to make it possible to <strong class="bold">monkey patch</strong> it. It is a common need in the <span class="No-Break">Odoo ecosystem.</span></p>
			<h3>willStart</h3>
			<p><strong class="source-inline">willStart</strong> is an <a id="_idIndexMarker1174"/>asynchronous hook that can be implemented to perform some (most of the time asynchronous) action before the initial rendering of <span class="No-Break">a component.</span></p>
			<p>It will be called exactly once before the initial rendering. It is useful in some cases, for example, to load external assets (such as a JavaScript library) before the component is rendered. Another use case is to load data from <span class="No-Break">a server.</span></p>
			<p>The <strong class="source-inline">onWillStart</strong> hook is used to register a function that will <span class="No-Break">be executed:</span></p>
			<pre class="source-code">
setup() {
    onWillStart(async () =&gt; {
        this.data = await this.loadData()
    });
}</pre>			<h3>willRender</h3>
			<p>It is <a id="_idIndexMarker1175"/>uncommon, but you may need to execute code just before a component is rendered (more precisely, when its compiled template function is executed). To do that, we can use the <span class="No-Break"><strong class="source-inline">onWillRender</strong></span><span class="No-Break"> hook.</span></p>
			<p><strong class="source-inline">willRender</strong> hooks are called just before rendering templates, parent first, <span class="No-Break">then children.</span></p>
			<h3>rendered</h3>
			<p>Similarly, it is <a id="_idIndexMarker1176"/>uncommon, but you may need to execute code just after a component is rendered (more precisely, when its compiled template function is executed). To do that, we can use the <span class="No-Break"><strong class="source-inline">onRendered</strong></span><span class="No-Break"> hook.</span></p>
			<p><strong class="source-inline">rendered</strong> hooks are called just after rendering templates, parent first, then children. Note that at this moment, the actual DOM may not exist yet (if it is the first rendering), or is not updated yet. This will be done in the next animation frame, as soon as all the components <span class="No-Break">are ready.</span></p>
			<h3>mounted</h3>
			<p>The <strong class="source-inline">mounted</strong> hook is <a id="_idIndexMarker1177"/>called each time a component is attached to the DOM, after the initial rendering. At this point, the component is considered active. This is a good place to add some listeners, or to interact with the DOM, if the component needs to perform some measure <span class="No-Break">for example.</span></p>
			<p>It is the opposite of <strong class="source-inline">willUnmount</strong>. If a component has been mounted, it will always be unmounted at some point in <span class="No-Break">the future.</span></p>
			<p>The <strong class="source-inline">mounted</strong> method will be called recursively on each of its children. First children, <span class="No-Break">then parents.</span></p>
			<p>It is allowed (but not encouraged) to modify the state in the mounted hook. Doing so will cause a rerender, which will not be perceptible by the user, but will slightly slow down <span class="No-Break">the component.</span></p>
			<p>The <strong class="source-inline">onMounted</strong> hook is used to register a function that will be executed at <span class="No-Break">this moment.</span></p>
			<h3>willUpdateProps</h3>
			<p><strong class="source-inline">willUpdateProps</strong> is an asynchronous hook that is called just before new props are set. This is <a id="_idIndexMarker1178"/>useful if the component needs to perform an asynchronous task, depending on the props (for example, assuming that the props are some record ID, fetching the <span class="No-Break">record data).</span></p>
			<p>The <strong class="source-inline">onWillUpdateProps</strong> hook is used to register a function that will be executed at <span class="No-Break">this moment.</span></p>
			<p>Notice that it receives the next props for <span class="No-Break">the component.</span></p>
			<p>This hook is not called during the first render (but <strong class="source-inline">willStart</strong> is called and performs a similar job). Also, like most hooks, it is called in the usual order: parents first, <span class="No-Break">then children.</span></p>
			<h3>willPatch</h3>
			<p>The <strong class="source-inline">willPatch</strong> hook is called just before the DOM patching process starts. It is not called on <a id="_idIndexMarker1179"/>the initial render. This is useful to read information from the DOM, such as the current position of <span class="No-Break">the scrollbar.</span></p>
			<p>Note that modifying the state is not allowed here. This method is called just before an actual DOM patch, and is only intended to be used to save some local DOM state. Also, it will not be called if the component is not in <span class="No-Break">the DOM.</span></p>
			<p>The <strong class="source-inline">onWillPatch</strong> hook is used to register a function that will be executed at this moment. <strong class="source-inline">willPatch</strong> is called in the usual <span class="No-Break">parent/children order.</span></p>
			<h3>patched</h3>
			<p>This hook is <a id="_idIndexMarker1180"/>called whenever a component actually updates its DOM (most likely via a change in its state/props <span class="No-Break">or environment).</span></p>
			<p>This method is not called on the initial render. It is useful to interact with the DOM (for example, through an external library) whenever the component is patched. Note that this hook will not be called if the component is not in <span class="No-Break">the DOM.</span></p>
			<p>The <strong class="source-inline">onPatched</strong> hook is used to register a function that will be executed at <span class="No-Break">this moment.</span></p>
			<p>Updating the component state in this hook is possible, but not recommended. We need to be careful because updates here will create additional rendering, which in turn will cause other <a id="_idIndexMarker1181"/>calls to the <strong class="source-inline">patched</strong> method. So, we need to be particularly careful to prevent <span class="No-Break">endless cycles.</span></p>
			<p>Like <strong class="source-inline">mounted</strong>, the <strong class="source-inline">patched</strong> hook is called in the order: children first, <span class="No-Break">then parent.</span></p>
			<h3>willUnmount</h3>
			<p><strong class="source-inline">willUnmount</strong> is a hook that is called just before a component is unmounted from the DOM. This <a id="_idIndexMarker1182"/>is a good place to remove listeners, <span class="No-Break">for example.</span></p>
			<p>The <strong class="source-inline">onWillUnmount</strong> hook is used to register a function that will be executed at <span class="No-Break">this moment.</span></p>
			<p>This is the opposite method of <strong class="source-inline">mounted</strong>. Note that if a component is destroyed before being mounted, the <strong class="source-inline">willUnmount</strong> method may not <span class="No-Break">be called.</span></p>
			<p>Parent <strong class="source-inline">willUnmount</strong> hooks will be called <span class="No-Break">before children.</span></p>
			<h3>willDestroy</h3>
			<p>Sometimes, components <a id="_idIndexMarker1183"/>need to do some action in the setup and clean it up when they are inactive. However, the <strong class="source-inline">willUnmount</strong> hook is not appropriate for the cleaning operation, since the component may be destroyed before it has even been mounted. The <strong class="source-inline">willDestroy</strong> hook is useful in this situation since it is <span class="No-Break">always called.</span></p>
			<p>The <strong class="source-inline">onWillUnmount</strong> hook is used to register a function that will be executed at <span class="No-Break">this moment.</span></p>
			<p><strong class="source-inline">willDestroy</strong> hooks are first called on children, then <span class="No-Break">on parents.</span></p>
			<h3>onError</h3>
			<p>Sadly, components <a id="_idIndexMarker1184"/>may crash at runtime. This is an unfortunate reality, and this is why OWL needs to provide a way to handle <span class="No-Break">these errors.</span></p>
			<p>The <strong class="source-inline">onError</strong> hook is useful when we need to intercept and properly react to e<a id="_idTextAnchor966"/>rrors that occur in <span class="No-Break">some sub-components.</span></p>
			<h2 id="_idParaDest-768"><a id="_idTextAnchor967"/>There’s more…</h2>
			<p>There is one more method in the component life cycle, but it is used when you are using subcomponents. OWL passes the parent component state via the <strong class="source-inline">props</strong> parameter, and when <strong class="source-inline">props</strong> is changed, the <strong class="source-inline">willUpdateProps</strong> method is called. This is an asynchronous method, which means you can perform an<a id="_idTextAnchor968"/> asynchronous operation such as <span class="No-Break">RPC here.</span></p>
			<h1 id="_idParaDest-769"><a id="_idTextAnchor969"/>Adding an OWL field to the form view</h1>
			<p>Up to this point, we have learned about all the basics of OWL. Now we will move on to more advanced <a id="_idIndexMarker1185"/>aspects and create a field widget that can be used in the form view, just like the field widget recipe from the <span class="No-Break">previous chapter.</span></p>
			<p>Odoo has many <a id="_idIndexMarker1186"/>widgets in the UI for different functionalities, such as a status bar, checkboxes, and radio buttons. which makes the operations in Odoo simpler and run with ease. For example, we used <strong class="source-inline">widget='image'</strong> to display a binary field as an image. To demonstrate how to create your own widget, we’ll write one widget that lets the user choose an integer field, but we will display it differently. Instead of an input box, we will display a color picker so that we can select a color number. Here, each number will be mapped to <span class="No-Break">a color.</span></p>
			<p>In this recipe, we will create a color picker widget that will save integer values based on the <span class="No-Break">color selected.</span></p>
			<p>To make the example more informative,<a id="_idTextAnchor970"/> we will use some advanced concepts <span class="No-Break">of OWL.</span></p>
			<h2 id="_idParaDest-770"><a id="_idTextAnchor971"/>Getting ready</h2>
			<p>For this rec<a id="_idTextAnchor972"/>ipe, we will be using the <span class="No-Break"><strong class="source-inline">my_hostel</strong></span><span class="No-Break"> module.</span></p>
			<h2 id="_idParaDest-771"><a id="_idTextAnchor973"/>How to do it…</h2>
			<p>We’ll add a JavaScript file that contains our widget’s logic, an XML file that contains design logic, and an SCSS file to do some styling. Then, we will add one integer field to the books form to use our <span class="No-Break">new widget.</span></p>
			<p>Perform the following steps to add a new <span class="No-Break">field widget:</span></p>
			<ol>
				<li>Add the category integer field to the <strong class="source-inline">hostel.room</strong> model <span class="No-Break">as follows:</span><pre class="source-code">
category = fields.Integer('Category')</pre></li>				<li> Add the <a id="_idIndexMarker1187"/>same field to the form view, with a <strong class="source-inline">widget</strong> attribute <span class="No-Break">as well:</span><pre class="source-code">
       &lt;field name="category" widget="category_color"/&gt;</pre></li>				<li>Add <a id="_idIndexMarker1188"/>the QWeb templates for the field <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">static/src/xml/field_widget.xml</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;t t-name="OWLColorPill"&gt;
    &lt;span t-attf-class="o_color_pill o_color_#{props.color} #{props.value == props.color ? 'active': ''}"
          t-att-data-val="props.color"
          t-on-click="() =&gt; this.pillClicked()"
          t-attf-title="#{props.category_count or 0 } Room booked in this category" /&gt;
&lt;/t&gt;
&lt;span t-name="OWLFieldColorPills"&gt;
    &lt;t t-foreach="totalColors" t-as='color' t-key="color"&gt;
        &lt;ColorPill onClickColorUpdated="data =&gt; this.colorUpdated(data)"
                   color='color'
                   value="props.value"
                   category_count="categoryInfo[color]"/&gt;
    &lt;/t&gt;
&lt;/span&gt;</pre></li>				<li>List the QWeb file in the module’s <span class="No-Break"><strong class="source-inline">manifest</strong></span><span class="No-Break"> file:</span><pre class="source-code">
'assets': {
    'web.assets_backend': [
        'my_hostel/static/src/js/field_widget.js',
    ],
},</pre></li>				<li>Now we <a id="_idIndexMarker1189"/>want to add some SCSS for the field at <strong class="source-inline">static/src/scss/field_widget.scss</strong>. As the content of SCSS is too long, please <a id="_idIndexMarker1190"/>find the content of the SCSS file in this book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/05_owl_field/my_hostel/static/src/scss"><span class="No-Break">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/05_owl_field/my_hostel/static/src/scss</span></a><span class="No-Break">.</span></li>
				<li>Add the static <strong class="source-inline">/src/js/field_widget.js</strong> JavaScript file with the following <span class="No-Break">basic content:</span><pre class="source-code">
/** @odoo-module */
import { Component, onWillStart , onWillUpdateProps} from "@odoo/owl";
import { registry } from "@web/core/registry";
class ColorPill extends Component {
    static template = 'OWLColorPill';
    pillClicked() {
        this.props.onClickColorUpdated(this.props.color);
    }
}
export class OWLCategColorField extends Component {
    static supportedFieldTypes = ['integer'];
    static template = 'OWLFieldColorPills';
    static components = { ColorPill };
    setup() {
        this.totalColors = [1,2,3,4,5,6];
        onWillStart(async() =&gt; {
            await this.loadCategInformation();
        });
        onWillUpdateProps(async() =&gt; {
            await this.loadCategInformation();
        });
        super.setup();
    }
    colorUpdated(value) {
        this.props.record.update({ [this.props.name]: value });
    }
    async loadCategInformation() {
        var self = this;
        self.categoryInfo = {};
        var resModel = self.env.model.root.resModel;
        var domain = [];
        var fields = ['category'];
        var groupby = ['category'];
        const categInfoPromise = await self.env.services.orm.readGroup(
            resModel,
            domain,
            fields,
            groupby
        );
        categInfoPromise.map((info) =&gt; {
            self.categoryInfo[info.category] = info.category_count;
        });
    }
}
registry.category("fields").add("category_color",{
    component: OWLCategColorField
});</pre></li>				<li>Add JavaScript <a id="_idIndexMarker1191"/>and an SCSS file to the backend <a id="_idIndexMarker1192"/>assets <span class="No-Break">as follows:</span><pre class="source-code">
'assets': {
    'web.assets_backend': [
        'my_hostel/static/src/scss/field_widget.scss',
        'my_hostel/static/src/js/field_widget.js',
        'my_hostel/static/src/xml/field_widget.xml',
    ],
},</pre></li>				<li>Restart and update the module to apply the module changes. Open the room form view. You will be able to see the color picker widget, as shown in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/B20997_16_05.jpg" alt="Figure 16.5 – Color picker OWL widget"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5 – Color picker OWL widget</p>
			<ol>
				<li value="9">This field looks just like the color widget from the last chapter, but the actual difference <a id="_idIndexMarker1193"/>lies under the hood. This new field is built <a id="_idIndexMarker1194"/>with OWL components and subcomponents, while the previous one was built <span class="No-Break">with widgets.</span></li>
				<li>The benefit of this subcomponent is to provide a comprehensive framework for building modern, responsive, and interactive UIs in OWL. By modularizing functionality into small, reusable units, developers can create more maintainable and extensible applications while reducing code<a id="_idTextAnchor974"/> duplication and improving <span class="No-Break">development efficiency.</span></li>
			</ol>
			<h2 id="_idParaDest-772"><a id="_idTextAnchor975"/>How it works…</h2>
			<p>In <em class="italic">step 1</em>, we added an integer field to the <span class="No-Break"><strong class="source-inline">hostel.room</strong></span><span class="No-Break"> model.</span></p>
			<p>In <em class="italic">step 2</em>, we added the field to the form view of <span class="No-Break">the room.</span></p>
			<p>In <em class="italic">step 3</em>, we added the QWeb template file. If you notice, we added two templates to the file, one for the color pill and the other for the field itself. We used two templates because we want to see the concept of the <strong class="source-inline">subcomponent</strong>. If you observe the template closely, you will find that we have used the <strong class="source-inline">&lt;ColorPill&gt;</strong> tag. This will be used to instantiate the subcomponent. On the <strong class="source-inline">&lt;ColorPill&gt;</strong> tag, we have passed the active and color attributes. These attributes will be received as <strong class="source-inline">props</strong> in the template of the subcomponent. Also note that the <strong class="source-inline">onClickColorUpdated</strong> attribute is used to listen to the custom event triggered from <span class="No-Break">the subcomponent.</span></p>
			<p class="callout-heading">Important information</p>
			<p class="callout">Odoo v17 uses both the widget system and the <span class="No-Break">OWL framework.</span></p>
			<p>In <em class="italic">step 4</em>, we listed our QWeb template in the manifest. This will automatically load our template in <span class="No-Break">the browser.</span></p>
			<p>In <em class="italic">step 5</em>, we added SCSS for the color. This will help us to have a beautiful UI for the <span class="No-Break">color picker.</span></p>
			<p>In <em class="italic">step 6</em>, we added JavaScript for the <span class="No-Break">field component.</span></p>
			<p>We imported <a id="_idIndexMarker1195"/>the OWL utility and we also imported <a id="_idIndexMarker1196"/>the component <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">fieldRegistry</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">fieldRegistry</strong> is used to list the OWL component as a <span class="No-Break">field component.</span></p>
			<p>In <em class="italic">step 7</em>, we created the <strong class="source-inline">ColorPill</strong> component. The <strong class="source-inline">template</strong> variable on the component is the name of the template that is loaded from the external XML file. The <strong class="source-inline">ColorPill</strong> component has the <strong class="source-inline">pillClicked</strong> method, which is called when the user clicks on the color pill. Inside the method body, we have triggered the <strong class="source-inline">onClickColorUpdated</strong> event, which will be captured by the parent <strong class="source-inline">OWLCategColorField</strong> component as we used <strong class="source-inline">colorUpdated</strong> on the <span class="No-Break"><strong class="source-inline">OWLCategColorField</strong></span><span class="No-Break"> component.</span></p>
			<p>In <em class="italic">step 8</em> and <em class="italic">step 9</em>, we created the <strong class="source-inline">OWLCategColorField</strong> component by extending <strong class="source-inline">Component</strong>. We used the <strong class="source-inline">Component</strong> because it will have all the utilities that are required to create the <span class="No-Break">field widget.</span></p>
			<p>If you notice, we used the <strong class="source-inline">components</strong> static variable at the start. You need to list the components via the <strong class="source-inline">components</strong> static variable when you are using subcomponents in the template. We also added the <strong class="source-inline">onWillStart</strong> method in our example. The <strong class="source-inline">willStart</strong> method is an asynchronous method, so we have called RPC (network call) to fetch data regarding the number of the room booked for a particular color. Toward the end, we added the <strong class="source-inline">colorUpdated</strong> method, which will be called when the user clicks on the pill. So, we are changing the values of the field. The <strong class="source-inline">this.props.record.update</strong> method is used to set the field values (which will be saved in the database). Note here that the data triggered from the child component is available under the <strong class="source-inline">detail</strong> attribute in the <strong class="source-inline">event</strong> parameter. Finally, we registered our widget in <strong class="source-inline">fieldRegistry</strong>, implying that henceforth, we will be able to use our field via the <strong class="source-inline">widget</strong> attribute in the <span class="No-Break">form view.</span></p>
			<p>In <em class="italic">step 10</em>, we loade<a id="_idTextAnchor976"/>d JavaScript and SCSS files into the <span class="No-Break">backend assets.</span></p>
			<h2 id="_idParaDest-773"><a id="_idTextAnchor977"/>There’s more…</h2>
			<h3>Understanding QWeb</h3>
			<p><strong class="bold">QWeb</strong> is the primary <a id="_idIndexMarker1197"/>templating engine used by Odoo. It is an XML templating engine and is used mostly to generate HTML fragments and pages. Template directives are specified as XML attributes prefixed with <strong class="source-inline">t-</strong>, for instance, <strong class="source-inline">t-if</strong> for conditionals, with elements and other attributes being rendered directly. The following are the different operations of the <span class="No-Break">QWeb template:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Data output</strong></span><span class="No-Break">:</span><p class="list-inset">QWeb’s output directive, <strong class="source-inline">out</strong>, will automatically HTML-escape its input, limiting XSS risks <a id="_idIndexMarker1198"/>when displaying user-provided content. <strong class="source-inline">out</strong> takes an expression, evaluates it, and injects the result into <span class="No-Break">the document:</span></p><pre class="source-code">
&lt;p&gt;&lt;t t-out="value"/&gt;&lt;/p&gt;</pre><p class="list-inset">Setting <strong class="source-inline">value</strong> set to <strong class="source-inline">42</strong> yields <span class="No-Break">the following:</span></p><pre class="source-code">&lt;p&gt;42&lt;/p&gt;</pre></li>				<li><span class="No-Break"><strong class="bold">Setting variables</strong></span><span class="No-Break">:</span><p class="list-inset">QWeb allows <a id="_idIndexMarker1199"/>us to create variables from within the template, memorize a computation (to use it multiple times), and give a piece of data a <span class="No-Break">clearer name.</span></p><p class="list-inset">This is done via the <strong class="source-inline">set</strong> directive, which takes the name of the variable to create. The value of <strong class="source-inline">set</strong> can be provided in <span class="No-Break">two ways:</span></p><ul><li>A <strong class="source-inline">t-value</strong> attribute containing an expression, and the result of its evaluation will <span class="No-Break">be set:</span><pre class="source-code">
&lt;t t-set="foo" t-value="2 + 1"/&gt;
&lt;t t-out="foo"/&gt;</pre></li></ul><p class="list-inset">This <a id="_idIndexMarker1200"/>will <span class="No-Break">print </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">.</span></p><ul><li>If there is no <strong class="source-inline">t-value</strong> attribute, the node’s body is rendered and set as the <span class="No-Break">variable’s value:</span><pre class="source-code">&lt;t t-set="foo"&gt;
    &lt;li&gt;ok&lt;/li&gt;
&lt;/t&gt;
&lt;t t-out="foo"/&gt;</pre></li></ul></li>				<li><span class="No-Break"><strong class="bold">Conditionals</strong></span><span class="No-Break">:</span><p class="list-inset">QWeb has <a id="_idIndexMarker1201"/>a conditional directive, <strong class="source-inline">if</strong>, which evaluates an expression given as an <span class="No-Break">attribute value:</span></p><pre class="source-code">
&lt;div&gt;
    &lt;t t-if="condition"&gt;
        &lt;p&gt;ok&lt;/p&gt;
    &lt;/t&gt;
&lt;/div&gt;</pre><p class="list-inset">The element is rendered if the condition <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p><pre class="source-code">&lt;div&gt;
    &lt;p&gt;ok&lt;/p&gt;
&lt;/div&gt;</pre><p class="list-inset">But if the condition is <strong class="source-inline">false</strong>, it is removed from <span class="No-Break">the result:</span></p><pre class="source-code">&lt;div&gt;
&lt;/div&gt;</pre><p class="list-inset">Extra <a id="_idIndexMarker1202"/>conditional branching directives, <strong class="source-inline">t-elif</strong> and <strong class="source-inline">t-else</strong>, are <span class="No-Break">also available:</span></p><pre class="source-code">&lt;div&gt;
    &lt;p t-if="user.birthday == today()"&gt;Happy birthday!&lt;/p&gt;
    &lt;p t-elif="user.login == 'root'"&gt;Welcome master!&lt;/p&gt;
    &lt;p t-else=""&gt;Welcome!&lt;/p&gt;
&lt;/div&gt;</pre></li>				<li><span class="No-Break"><strong class="bold">Loops</strong></span><span class="No-Break">:</span><p class="list-inset">QWeb has <a id="_idIndexMarker1203"/>an iteration directive, <strong class="source-inline">foreach</strong>, which takes an expression that returns the collection to iterate on, and a second parameter, <strong class="source-inline">t-as</strong>, providing the name to use for the current item of <span class="No-Break">the iteration:</span></p><pre class="source-code">
&lt;t t-foreach="[1, 2, 3]" t-as="i"&gt;
    &lt;p&gt;&lt;t t-out="i"/&gt;&lt;/p&gt;
&lt;/t&gt;</pre><p class="list-inset">This will be rendered <span class="No-Break">as follows:</span></p><pre class="source-code">&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;</pre></li>				<li><span class="No-Break"><strong class="bold">Attributes</strong></span><span class="No-Break">:</span><p class="list-inset">QWeb can compute attributes on the fly and set the result of the computation on the <a id="_idIndexMarker1204"/>output node. This is done via the <strong class="source-inline">t-att</strong> (attribute) directive, which exists in three <span class="No-Break">different forms:</span></p><pre class="source-code">
t-att-$name</pre><p class="list-inset">Attribute <strong class="source-inline">t-att </strong>is <strong class="source-inline">$name</strong>, then the set will be rendered the attribute value as  shown in the <span class="No-Break">example below.</span></p><pre class="source-code">&lt; div t-att-a="42"/&gt;</pre><p class="list-inset">This will be rendered <span class="No-Break">as follows:</span></p><pre class="source-code">&lt;div a="42"&gt;&lt;/div&gt;
    t-attf-$name</pre><p class="list-inset">This is the same as previous, but the parameter is a format string instead of just an expression. This is often useful for mixing literal and non-literal strings (<span class="No-Break">e.g., classes):</span></p><pre class="source-code">&lt;t t-foreach="[1, 2, 3]" t-as="item"&gt;
    &lt;li t-attf-class="row {{ (item_index % 2 === 0) ? 'even' : 'odd' }}"&gt;
        &lt;t t-out="item"/&gt;
    &lt;/li&gt;
&lt;/t&gt;</pre><p class="list-inset">This will be rendered <span class="No-Break">as follows:</span></p><pre class="source-code">&lt; li class="row even"&gt;1&lt;/li&gt;
&lt;li class="row odd"&gt;2&lt;/li&gt;
&lt;li class="row even"&gt;3&lt;/li&gt;
      t-att=mapping</pre><p class="list-inset">If the parameter is a mapping, each key/value pair generates a new attribute and <span class="No-Break">its value:</span></p><pre class="source-code">&lt;div t-att="{'a': 1, 'b': 2}"/&gt;</pre><p class="list-inset">This will be rendered <span class="No-Break">as follows:</span></p><pre class="source-code">&lt;div a="1" b="2"&gt;&lt;/div&gt;
t-att=pair</pre><p class="list-inset">If the parameter is a pair (a tuple or array of two elements), the first item of the pair is the <a id="_idIndexMarker1205"/>name of the attribute and the second item is <span class="No-Break">the value:</span></p><pre class="source-code">&lt;div t-att="['a', 'b']"/&gt;</pre><p class="list-inset">This will be rendered <span class="No-Break">as follows:</span></p><pre class="source-code">&lt;div a="b"&gt;
&lt;/div&gt;</pre></li>				<li><span class="No-Break"><strong class="bold">Calling sub-templates</strong></span><p class="list-inset">QWeb templates can be used for top-level rendering, but they can also be used from within <a id="_idIndexMarker1206"/>another template (to avoid duplication or to give names to parts of templates) using the <span class="No-Break"><strong class="source-inline">t-call</strong></span><span class="No-Break"> directive:</span></p><pre class="source-code">
&lt;t t-call="other-template"/&gt;</pre><p class="list-inset">This calls the named template with the execution context of the parent, if <strong class="source-inline">other_template</strong> is defined <span class="No-Break">as follows:</span></p><pre class="source-code">&lt;p&gt;&lt;t t-value="var"/&gt;&lt;/p&gt;</pre><p class="list-inset">The preceding call will be rendered as <strong class="source-inline">&lt;p/&gt; (</strong><span class="No-Break"><strong class="source-inline">no content)</strong></span><span class="No-Break">.</span></p><pre class="source-code">&lt;t t-set="var" t-value="1"/&gt;
&lt;t t-call="other-template"/&gt;</pre><p class="list-inset">The preceding code will be rendered <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">&lt;p&gt;1&lt;/p&gt;</strong></span><span class="No-Break">.</span></p><p class="list-inset">However, this has the problem of being visible from outside the <strong class="source-inline">t-call</strong>.   Alternatively, content set in the body of the <strong class="source-inline">call</strong> directive will be evaluated before calling the sub-template, and can alter a <span class="No-Break">local context:</span></p><pre class="source-code">&lt;t t-call="other-template"&gt;
           &lt;t t-set="var" t-value="1"/&gt;
    &lt;/t&gt;
    &lt;!-- "var" does not exist here --&gt;</pre><p class="list-inset">The body <a id="_idIndexMarker1207"/>of the <strong class="source-inline">call</strong> directive can be arbitrarily complex (not just set directives), and its rendered form will be available within the called template as a magical <span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break"> variable:</span></p><pre class="source-code">&lt;div&gt;
    This template was called with content:
    &lt;t t-out="0"/&gt;
&lt;/div&gt;</pre><p class="list-inset">being <span class="No-Break">called thus:</span></p><pre class="source-code">&lt;t t-call="other-template"&gt;
    &lt;em&gt;content&lt;/em&gt;
&lt;/t&gt;</pre><p class="list-inset">This will result in <span class="No-Break">the following:</span></p><pre class="source-code">&lt;div&gt;
    This template was called with content:
    &lt;em&gt;content&lt;/em&gt;
&lt;/div&gt;</pre></li>			</ul>
			<h3>Understanding subcomponents</h3>
			<p>In the context of OWL, subcomponents refer to small, modular units of functionality that can be <a id="_idIndexMarker1208"/>integrated into larger components to enhance their capabilities or provide <span class="No-Break">additional features.</span></p>
			<p>Subcomponents in OWL can include various elements, such as widgets, utilities, services, and views, which are designed to work together within the OWL framework to create rich, interactive UIs and manage client-side <span class="No-Break">logic efficiently.</span></p>
			<p>These subcomponents work together to provide a comprehensive framework for building modern, responsive, and interactive UIs in OWL. By modularizing functionality into small, reusable units, developers can create more maintainable and extensible applications while reducing code duplication and improving <span class="No-Break">development efficiency.</span></p>
			<p>It is convenient to define a component using other (sub) components. This is called composition and is very powerful in practice. To do that in OWL, we can just use a tag starting with a capital letter in its template, and register the subcomponent class in its static <span class="No-Break"><strong class="source-inline">component</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
class Child extends Component {
  static template = xml`&lt;div&gt;child component &lt;t t-esc="props.value"/&gt;&lt;/div&gt;`;
}
class Parent extends Component {
  static template = xml`
    &lt;div&gt;
      &lt;Child value="1"/&gt;
      &lt;Child value="2"/&gt;
    &lt;/div&gt;`;
  static components = { Child };
}</pre>			<p>Here, <strong class="source-inline">&lt;Child&gt;</strong> has <strong class="source-inline">subcomponent</strong>. This example also shows how we can pass information from the parent component to the child component as props. In OWL, <strong class="source-inline">props</strong> (short for properties) is an object that contains every piece of data given to a component by its parent. Note that <strong class="source-inline">props</strong> is an object that only makes sense from the perspective of the <span class="No-Break">child component.</span></p>
			<p>The <strong class="source-inline">props</strong> object is <a id="_idIndexMarker1209"/>made of every attribute defined on the template, with the following exceptions: every attribute starting with <strong class="source-inline">t-</strong> is not a prop (they are <span class="No-Break">QWeb directives).</span></p>
			<p>In the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
&lt;div&gt;
    &lt;Child value="string"/&gt;
    &lt;Child t-if="condition" model="model"/&gt;
&lt;/div&gt;</pre>			<p>The <strong class="source-inline">props</strong> object contains the <span class="No-Break">following keys:</span></p>
			<pre class="source-code">
for Child: value,
for Child: model,</pre>		</div>
	</body></html>