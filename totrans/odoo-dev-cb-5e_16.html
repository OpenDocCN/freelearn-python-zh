<html><head></head><body>
		<div><h1 id="_idParaDest-747" class="chapter-number"><a id="_idTextAnchor929"/>16</h1>
			<h1 id="_idParaDest-748"><a id="_idTextAnchor930"/>The Odoo Web Library (OWL)</h1>
			<p>The Odoo V17 Javascript framework uses a custom component framework called <strong class="bold">OWL </strong>(short for <strong class="bold">Odoo Web Library</strong>). It is a <a id="_idIndexMarker1139"/>declarative component <a id="_idIndexMarker1140"/>system loosely inspired by <strong class="bold">Vue</strong> and <strong class="bold">React</strong>. <strong class="bold">OWL</strong> is a component-based <a id="_idIndexMarker1141"/>UI framework and uses QWeb templates for structure. OWL is very <a id="_idIndexMarker1142"/>fast compared to Odoo’s legacy widget system and introduces tons of <a id="_idIndexMarker1143"/>new features, including <strong class="bold">hooks</strong>, <strong class="bold">reactivity</strong>, the <strong class="bold">auto instantiation</strong> of <strong class="bold">subcomponents</strong>, and more besides.</p>
			<p>In this chapter, we will <a id="_idIndexMarker1144"/>learn how to use an OWL component to generate interactive UI elements. We will start with a minimal OWL component and then we will learn about the component’s life cycle. Finally, we will create a new field widget for the form view. In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Creating an OWL component</li>
				<li>Managing user actions in an OWL component</li>
				<li>Making OWL components with hooks</li>
				<li>Understanding the OWL component life cycle</li>
				<li>Adding an OWL field to the form view</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">The following question may occur to you: why is Odoo not using some well-known JavaScript frameworks, such as React.js or Vue.js? Please check out the following link for more information: <a href="https://github.com/odoo/owl/blob/master/doc/miscellaneous/comparison.md">https://github.com/odoo/owl/blob/master/doc/miscellaneous/comparison.md</a>.</p>
			<p class="callout">You can <a id="_idIndexMarker1145"/>refer to <a href="https://github.com/odoo/owl">https://github.com/odoo/owl</a> to learn more about the OWL framework.</p>
			<h1 id="_idParaDest-749"><a id="_idTextAnchor931"/>Technical requirements</h1>
			<p>OWL components are defined with ES6 classes. In this chapter, we will be using some ES6 syntax. Also, some ES6 syntaxes are not supported by old browsers, so make sure you are using the latest version of Chrome or Firefox. You will find the code for this chapter at <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16</a>.</p>
			<h1 id="_idParaDest-750"><a id="_idTextAnchor932"/>Creating an OWL component</h1>
			<p>The main building blocks of OWL are components and templates.</p>
			<p>In OWL, every part <a id="_idIndexMarker1146"/>of the UI is managed by a component: they hold the logic and define the templates that are used to render the user interface</p>
			<p>The goal of this recipe is to learn the basics of an OWL component. We will create a minimal OWL component and append it to the Odoo web client. In this recipe, we will create a component for a small horizontal bar with som<a id="_idTextAnchor933"/>e text.</p>
			<h2 id="_idParaDest-751"><a id="_idTextAnchor934"/>Getting ready</h2>
			<p>For this recipe, we will be using the <code>my_hostel</code> module with basic fields and views. You will find the basic <code>my_hostel</code> module in the <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/00_initial_module/my_hostel">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/00_initial_module/my_hostel</a> directory in the GitHub repository.</p>
			<h2 id="_idParaDest-752"><a id="_idTextAnchor935"/>How to do it...</h2>
			<p>We will add a small horizontal bar component to the Odoo web client. Follow these steps to add your first component to the Odoo web client:</p>
			<ol>
				<li>Add a  <code>my_hostel/static/src/js/component.js</code> JavaScript file and define the new module’s namespace:<pre class="source-code">
    odoo.define('my_hostel.component', [], function (require) {
    "use strict";
    console.log("Load component......");
});</pre></li>				<li>Add the component JavaScript to <code>assets</code>:<pre class="source-code">
'assets': {
    'web.assets_backend': [
        'my_hostel/static/src/js/component.js',
    ],
},</pre></li>				<li>Define the <a id="_idIndexMarker1147"/>OWL utilities to the <code>component.js</code> file created in <em class="italic">step 1</em>:<pre class="source-code">
const { Component, mount, xml , whenReady } = owl;</pre></li>				<li>Add the OWL component and its basic template to the <code>component.js</code> file created in <em class="italic">step 1</em>:<pre class="source-code">
class MyComponent extends Component {
    static template = xml`
        &lt;div class="bg-info text-white text-center p-3"&gt;
            &lt;b&gt; Welcome To Odoo &lt;/b&gt;
        &lt;/div&gt;`
}</pre></li>				<li>Initialize and append the component to the web client. Add this to the <code>component.js</code> file added in <em class="italic">step 1</em>:<pre class="source-code">
whenReady().then(() =&gt; {
    mount(MyComponent, document.body);
});</pre></li>			</ol>
			<p>Install/upgrade the <code>my_hostel</code> module to apply our changes. Once our module is loaded in Odoo, you will see the horizontal bar, as shown in the following screenshot:</p>
			<div><div><img src="img/B20997_16_01.jpg" alt="Figure 16.1 – OWL component"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1 – OWL component</p>
			<p>This is just a simple component. Right now, it will not handle any user events and you cannot rem<a id="_idTextAnchor936"/>ove it.</p>
			<h2 id="_idParaDest-753"><a id="_idTextAnchor937"/>How it works...</h2>
			<p>In <em class="italic">step 1</em> and <em class="italic">step 2</em>, we added a JavaScript file and listed it in the backend assets. If you want to learn more about assets, refer to the <em class="italic">Static assets management</em> recipe in <a href="B20997_14.xhtml#_idTextAnchor734"><em class="italic">Chapter 14</em></a><em class="italic">, CMS </em><em class="italic">Website Development</em>.</p>
			<p>In <em class="italic">step</em> <em class="italic">3</em>, we initialized <a id="_idIndexMarker1148"/>a variable from OWL. All the utilities from OWL are available under a single global variable, <code>owl</code>. In our example, we pulled an OWL utility. we declared <code>Component</code>, <code>mount</code>, <code>xml</code> , <code>whenReady</code>. <code>Component</code> is the main class for the <code>OWL</code> component and, by extending it, we will create our own components.</p>
			<p>In <em class="italic">step 4,</em> we created our component, <code>MyComponent</code>, by extending OWL’s <code>Component</code> class. For the sake of simplicity, we have just added the QWeb template to the definition of the <code>MyComponent</code> class. Here, as you may have noticed, we have used <code>xml`…`</code> to declare our template. This syntax is known as an inline template.</p>
			<p>However, you can load QWeb templates via separate files, which is usually the case. We will see examples of external QWeb templates in the upcoming recipes.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Inline QWeb templates do not support translations or modifications via inheritance. So, always endeavor to load QWeb templates from a separate file.</p>
			<p>In <em class="italic">step 5</em>, we instantiated the <code>MyComponent</code> component and appended it to the body. The OWL component is an ES6 class, so you can create an object via the <code>new</code> keyword. Then you can use the <code>mount()</code> method to add the component to the page. If you notice, we have <a id="_idIndexMarker1149"/>placed our code inside the <code>whenReady()</code> callback. This will ensure that all OWL functionality is properly loaded before we start using OWL co<a id="_idTextAnchor938"/>mponents.</p>
			<h2 id="_idParaDest-754"><a id="_idTextAnchor939"/>There’s more...</h2>
			<p>OWL is a separate library and is loaded in Odoo as an external JavaScript library. You can use OWL in <a id="_idIndexMarker1150"/>your other projects, too. The OWL library is listed at <a href="https://github.com/odoo/owl">https://github.com/odoo/owl</a>. There is also an online playground available in case you just want to test OWL without setting it in your local machine. You can play with OWL at <a href="https://odoo.github.io/owl/playground/">https://odoo.github.io/owl/playground/</a>.</p>
			<h1 id="_idParaDest-755"><a id="_idTextAnchor941"/>Managing user actions in an OWL component</h1>
			<p>To make <a id="_idIndexMarker1151"/>the UI interactive, components <a id="_idIndexMarker1152"/>need to handle <code>user actions</code> such as <code>click</code>, <code>hover</code>, and <code>form submission</code>. In this recipe, we will add a button to our component, and we will handle a <a id="_idTextAnchor942"/>click event.</p>
			<h2 id="_idParaDest-756"><a id="_idTextAnchor943"/>Getting ready</h2>
			<p>For this recipe, we will continue using the <code>my_hostel</code> module from the prev<a id="_idTextAnchor944"/>ious recipe.</p>
			<h2 id="_idParaDest-757"><a id="_idTextAnchor945"/>How to do it...</h2>
			<p>In this recipe, we will add a delete button to the component. Upon clicking the delete button, the component gets removed. Perform the following steps to add a delete button and its event in the component:</p>
			<ol>
				<li>Update the QWeb template and add an icon to remove the bar:<pre class="source-code">
class MyComponent extends Component {
    static template = xml`
        &lt;div class="bg-info text-white text-center p-3"&gt;
            &lt;b&gt; Welcome To Odoo &lt;/b&gt;
            &lt;i class="fa fa-close p-1 float-end"
               style="cursor: pointer;"
               t-on-click="onRemove"&gt; &lt;/i&gt;
        &lt;/div&gt;`
}</pre></li>				<li>To remove <a id="_idIndexMarker1153"/>the component, add <a id="_idIndexMarker1154"/>the <code>onRemove</code> method to the <code>MyComponent</code> class, as follows:<pre class="source-code">
class MyComponent extends Component {
    static template = xml`
        &lt;div class="bg-info text-white text-center p-3"&gt;
            &lt;b&gt; Welcome To Odoo &lt;/b&gt;
            &lt;i class="fa fa-close p-1 float-end"
               style="cursor: pointer;"
               t-on-click="onRemove"&gt; &lt;/i&gt;
        &lt;/div&gt;`
    onRemove(ev) {
        $(ev.target).parent().remove();
    }
}</pre></li>			</ol>
			<p>Update the module to apply the changes. Following the update, you will see a little cross icon on the right side of the bar, as in the following screenshot:</p>
			<div><div><img src="img/B20997_16_02.jpg" alt="Figure 16.2 – The remove button on the top bar component"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 – The remove button on the top bar component</p>
			<p>Upon clicking the remove icon, our OWL component will be removed. The bar will reappear when you rel<a id="_idTextAnchor946"/>oad the page.</p>
			<h2 id="_idParaDest-758"><a id="_idTextAnchor947"/>How it works…</h2>
			<p>In <em class="italic">step 1</em>, we added a remove icon to the component. We have added a <code>t-on-click</code> attribute. This <a id="_idIndexMarker1155"/>will be used to bind a click event. The <a id="_idIndexMarker1156"/>value of the attribute will be the method in the component. In our example, we have used <code>t-on-click="onRemove"</code>. This implies that when the user clicks on the remove icon, the <code>onRemove</code> method in the component will be called. The syntax to define the event is simple:</p>
			<pre class="source-code">
t-on-&lt;name of event&gt;="&lt;method name in component&gt;"</pre>			<p>For example, if you want to call the method when the user moves the mouse over the component, you can do so by adding the following code:</p>
			<pre class="source-code">
t-on-mouseover="onMouseover"</pre>			<p>After adding the preceding code, whenever the user moves the mouse cursor over the component, OWL will call the <code>onMouseover</code> method specified in the component.</p>
			<p>In <em class="italic">step 2</em>, we have added the <code>onRemove</code> method. This method will be called when the user clicks on the remove icon. In the method, we have called the <code>remove()</code> method, which will remove the component from the DOM. We will be seeing several default methods in the up<a id="_idTextAnchor948"/>coming recipes.</p>
			<h2 id="_idParaDest-759"><a id="_idTextAnchor949"/>There’s more...</h2>
			<p>Event handling is not limited to the DOM events. You can use your custom events as well. For instance, if you are manually triggering the event called <code>my-custom-event</code>, you can use <code>t-on-my-custom-event</code> to catch custom-tr<a id="_idTextAnchor950"/>iggered events.</p>
			<h1 id="_idParaDest-760"><a id="_idTextAnchor951"/>Making OWL components with hooks</h1>
			<p>OWL is a <a id="_idIndexMarker1157"/>powerful framework and supports automatic <a id="_idIndexMarker1158"/>updates for the UI based on <strong class="bold">hooks</strong>. With update <a id="_idIndexMarker1159"/>hooks, a component’s UI will be automatically updated when the internal state of the component is changed. In this recipe, we will update the message in the component base<a id="_idTextAnchor952"/>d on user actions.</p>
			<h2 id="_idParaDest-761"><a id="_idTextAnchor953"/>Getting ready</h2>
			<p>For this recipe, we will continue using the <code>my_hostel</code> module from th<a id="_idTextAnchor954"/>e previous recipe.</p>
			<h2 id="_idParaDest-762"><a id="_idTextAnchor955"/>How to do it…</h2>
			<p>In this recipe, we will add arrows around the text in the component. When we click on the arrow, we will change the message. Follow these steps to make the OWL component reactive:</p>
			<ol>
				<li>Update the XML template of the component. Add two buttons with an event directive around the text. Also, retrieve the message dynamically from the list:<pre class="source-code">
static template = xml`
    &lt;div class="bg-info text-white text-center p-3"&gt;
        &lt;i class="fa fa-arrow-left p-1"
           style="cursor: pointer;"
           t-on-click="onPrevious"&gt; &lt;/i&gt;
        &lt;b t-esc="messageList[Math.abs(state.currentIndex%4)]"/&gt;
        &lt;i class="fa fa-arrow-right p-1"
           style="cursor: pointer;"
           t-on-click="onNext"&gt; &lt;/i&gt;
        &lt;i class="fa fa-close p-1 float-end"
           style="cursor: pointer;"
           t-on-click="onRemove"&gt; &lt;/i&gt;
    &lt;/div&gt;`</pre></li>				<li>In the <a id="_idIndexMarker1160"/>JavaScript file of the component, import the <code>useState</code> hook as follows:<pre class="source-code">
const { Component, mount, xml , whenReady, useState } = owl;</pre></li>				<li>Add the <code>setup</code> method <a id="_idIndexMarker1161"/>to the component and initialize some variables as follows:<pre class="source-code">
setup() {
    this.messageList = [
        'Hello World',
        'Welcome to Odoo',
        'Odoo is awesome',
        'You are awesome too'
    ];
    this.state = useState({ currentIndex: 0 });
}</pre></li>				<li>In the <code>Component</code> class, add methods to handle the user’s click event:<pre class="source-code">
onNext(ev) {
    this.state.currentIndex++;
}
onPrevious(ev) {
    this.state.currentIndex--;
}</pre></li>			</ol>
			<p>Restart and update the module to apply the changes to the module. Following the update, you will see the two arrow icons around the text like this:</p>
			<div><div><img src="img/B20997_16_03.jpg" alt="Figure 16.3 – Arrows around the text"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3 – Arrows around the text</p>
			<p>If you click on the arrow, the message text will be changed based on the list of messages <a id="_idTextAnchor956"/>in the constructor.</p>
			<h2 id="_idParaDest-763"><a id="_idTextAnchor957"/>How it works...</h2>
			<p>In <em class="italic">step 1</em>, we updated the XML template of our component. Basically, we made two changes to the template. We rendered the text message from the list of messages, and we selected <a id="_idIndexMarker1162"/>the message based on the value of <code>currentIndex</code> in the state variable. We added two arrow icons around the text block. In the <a id="_idIndexMarker1163"/>arrow icons, we added <code>the t-on-click</code> attribute to bind the click event to the arrow.</p>
			<p>In <em class="italic">step 2</em>, we imported the <code>useState</code> hook from OWL. This hook is used to handle the state of the component.</p>
			<p>In <em class="italic">step 3</em>, we added a <code>setup</code>. This will be called when you create an instance of the object. In the <code>setup</code>, we added a list of messages that we want to show, and then we added the <code>state</code> variable using the <code>useState</code> hook. This will make the component reactive. When the <code>state</code> is <code>changed</code>, the <code>UI</code> will be updated based on the new state. In our example, we used <code>currentIndex</code> in the <code>useState</code> hook. This implies that whenever the value of <code>currentIndex</code> changes, the UI will be updated as well.</p>
			<p class="callout-heading">Important information</p>
			<p class="callout">There is only one rule for defining hooks, which is that the hooks will only work if you have declared them in <code>setup</code>. Several other types of hooks are available, which you can find here: <a href="https://github.com/odoo/owl/blob/master/doc/reference/hooks.md">https://github.com/odoo/owl/blob/master/doc/reference/hooks.md</a>.</p>
			<p>In <em class="italic">step 4</em>, we added <a id="_idIndexMarker1164"/>methods to handle the click events <a id="_idIndexMarker1165"/>of the arrow. Upon clicking the arrow, we are changing the state of the component. As we are using a hook on the state, the UI of the component will be<a id="_idTextAnchor958"/> automatically updated.</p>
			<h1 id="_idParaDest-764"><a id="_idTextAnchor959"/>Understanding the OWL component life cycle</h1>
			<p>OWL components have several methods that help developers to create powerful and interactive <a id="_idIndexMarker1166"/>components. Some of the important methods of the OWL components are as follows:</p>
			<ul>
				<li><code>setup()</code></li>
				<li><code>onWillStart()</code></li>
				<li><code>onWillRender()</code></li>
				<li><code>onRendered()</code></li>
				<li><code>onMounted()</code></li>
				<li><code>onWillUpdateProps()</code></li>
				<li><code>onWillPatch()</code></li>
				<li><code>onPatched()</code></li>
				<li><code>onMounted()</code></li>
				<li><code>onWillUnmount()</code></li>
				<li><code>onWillDestroy()</code></li>
				<li><code>onError()</code></li>
			</ul>
			<p>In this recipe, we will log the message in the console to help us understand the life cyc<a id="_idTextAnchor960"/>le of the OWL component.</p>
			<h2 id="_idParaDest-765"><a id="_idTextAnchor961"/>Getting ready</h2>
			<p>For this recipe, we will continue using the <code>my_hostel</code> module f<a id="_idTextAnchor962"/>rom the previous recipe.</p>
			<h2 id="_idParaDest-766"><a id="_idTextAnchor963"/>How to do it…</h2>
			<p>To add methods <a id="_idIndexMarker1167"/>of the component to show the life cycle of an OWL component, you need to carry out the following steps:</p>
			<ol>
				<li>First, you need to import the <code>all</code> hook, as follows:<pre class="source-code">
const {
        Component,
        mount,
        whenReady,
        onWillStart,
        onMounted,
        onWillUnmount,
        onWillUpdateProps,
        onPatched,
        onWillPatch,
        onWillRender,
        onRendered,
        onError,
        onWillDestroy,
    } = owl;</pre></li>				<li>As we already have <code>setup</code> in the component, let’s add a message to the console like this:<pre class="source-code">
setup() {
     console.log('CALLED:&gt; setup');
}</pre></li>				<li>Add the <code>willStart</code> method to the component:<pre class="source-code">
setup() {
    onWillStart(async () =&gt; {
        console.log('CALLED:&gt; willStart');
    });
}</pre></li>				<li>Add the <code>willrender</code> method <a id="_idIndexMarker1168"/>to the component:<pre class="source-code">
setup() {
    onWillRender(() =&gt; {
        console.log('CALLED:&gt; willRender');
    });
}</pre></li>				<li>Add the <code>render</code> method to the component:<pre class="source-code">
setup() {
    onRendered(() =&gt; {
        console.log('CALLED:&gt; Rendered');
    });
}</pre></li>				<li>Add the <code>mounted</code> method to the component:<pre class="source-code">
setup() {
    onMounted(() =&gt; {
        console.log('CALLED:&gt; Mounted');
    });
}</pre></li>				<li>Add the <code>willUpdateProps</code> method to the component:<pre class="source-code">
setup() {
    onWillUpdateProps(() =&gt; {
        console.log('CALLED:&gt; WillUpdateProps');
    });
}</pre></li>				<li>Add the <code>willPatch</code> method <a id="_idIndexMarker1169"/>to the component:<pre class="source-code">
setup() {
    onWillPatch(() =&gt; {
        console.log('CALLED:&gt; WillPatch');
    });
}</pre></li>				<li>Add the <code>patched</code> method to the component:<pre class="source-code">
setup() {
    onPatched(() =&gt; {
        console.log('CALLED:&gt; Patch');
    });
}</pre></li>				<li>Add the <code>willUnmount</code> method to the component:<pre class="source-code">
setup() {
    onWillUnmount(() =&gt; {
        console.log('CALLED:&gt; WillUnmount');
    });
}</pre></li>				<li>Add the <code>willDestroy</code> method to the component:<pre class="source-code">
setup() {
    onWillDestroy(() =&gt; {
        console.log('CALLED:&gt; WillDestroy');
    });
}</pre></li>				<li>Add the <code>Error</code> method <a id="_idIndexMarker1170"/>to the component:<pre class="source-code">
setup() {
    onError(() =&gt; {
        console.log('CALLED:&gt; Error');
    });
}</pre></li>			</ol>
			<p>Restart and update the module to apply the module changes. Following the update, perform some operations, such as changing the message via arrows and removing the component. In the browser console, you will see the logs like this:</p>
			<div><div><img src="img/B20997_16_04.jpg" alt="Figure 16.4 – Logs in the browser console"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4 – Logs in the browser console</p>
			<p>You may have different logs based on the operation you have <a id="_idTextAnchor964"/>performed on the component.</p>
			<h2 id="_idParaDest-767"><a id="_idTextAnchor965"/>How it works…</h2>
			<p>In this recipe, we have <a id="_idIndexMarker1171"/>added several methods and added logged messages to the method. You can use these methods based on your requirements. Let’s see the life cycle of the component and when these methods are called.</p>
			<h3>setup</h3>
			<p><code>setup</code> is run just <a id="_idIndexMarker1172"/>after the component is constructed. It is a life cycle method that’s very similar to the <code>constructor</code>, except that it does not receive any arguments.</p>
			<p>It is the proper place to call hook functions. Note that one of the main reasons to have the setup hook in the <a id="_idIndexMarker1173"/>component lifecycle is to make it possible to <strong class="bold">monkey patch</strong> it. It is a common need in the Odoo ecosystem.</p>
			<h3>willStart</h3>
			<p><code>willStart</code> is an <a id="_idIndexMarker1174"/>asynchronous hook that can be implemented to perform some (most of the time asynchronous) action before the initial rendering of a component.</p>
			<p>It will be called exactly once before the initial rendering. It is useful in some cases, for example, to load external assets (such as a JavaScript library) before the component is rendered. Another use case is to load data from a server.</p>
			<p>The <code>onWillStart</code> hook is used to register a function that will be executed:</p>
			<pre class="source-code">
setup() {
    onWillStart(async () =&gt; {
        this.data = await this.loadData()
    });
}</pre>			<h3>willRender</h3>
			<p>It is <a id="_idIndexMarker1175"/>uncommon, but you may need to execute code just before a component is rendered (more precisely, when its compiled template function is executed). To do that, we can use the <code>onWillRender</code> hook.</p>
			<p><code>willRender</code> hooks are called just before rendering templates, parent first, then children.</p>
			<h3>rendered</h3>
			<p>Similarly, it is <a id="_idIndexMarker1176"/>uncommon, but you may need to execute code just after a component is rendered (more precisely, when its compiled template function is executed). To do that, we can use the <code>onRendered</code> hook.</p>
			<p><code>rendered</code> hooks are called just after rendering templates, parent first, then children. Note that at this moment, the actual DOM may not exist yet (if it is the first rendering), or is not updated yet. This will be done in the next animation frame, as soon as all the components are ready.</p>
			<h3>mounted</h3>
			<p>The <code>mounted</code> hook is <a id="_idIndexMarker1177"/>called each time a component is attached to the DOM, after the initial rendering. At this point, the component is considered active. This is a good place to add some listeners, or to interact with the DOM, if the component needs to perform some measure for example.</p>
			<p>It is the opposite of <code>willUnmount</code>. If a component has been mounted, it will always be unmounted at some point in the future.</p>
			<p>The <code>mounted</code> method will be called recursively on each of its children. First children, then parents.</p>
			<p>It is allowed (but not encouraged) to modify the state in the mounted hook. Doing so will cause a rerender, which will not be perceptible by the user, but will slightly slow down the component.</p>
			<p>The <code>onMounted</code> hook is used to register a function that will be executed at this moment.</p>
			<h3>willUpdateProps</h3>
			<p><code>willUpdateProps</code> is an asynchronous hook that is called just before new props are set. This is <a id="_idIndexMarker1178"/>useful if the component needs to perform an asynchronous task, depending on the props (for example, assuming that the props are some record ID, fetching the record data).</p>
			<p>The <code>onWillUpdateProps</code> hook is used to register a function that will be executed at this moment.</p>
			<p>Notice that it receives the next props for the component.</p>
			<p>This hook is not called during the first render (but <code>willStart</code> is called and performs a similar job). Also, like most hooks, it is called in the usual order: parents first, then children.</p>
			<h3>willPatch</h3>
			<p>The <code>willPatch</code> hook is called just before the DOM patching process starts. It is not called on <a id="_idIndexMarker1179"/>the initial render. This is useful to read information from the DOM, such as the current position of the scrollbar.</p>
			<p>Note that modifying the state is not allowed here. This method is called just before an actual DOM patch, and is only intended to be used to save some local DOM state. Also, it will not be called if the component is not in the DOM.</p>
			<p>The <code>onWillPatch</code> hook is used to register a function that will be executed at this moment. <code>willPatch</code> is called in the usual parent/children order.</p>
			<h3>patched</h3>
			<p>This hook is <a id="_idIndexMarker1180"/>called whenever a component actually updates its DOM (most likely via a change in its state/props or environment).</p>
			<p>This method is not called on the initial render. It is useful to interact with the DOM (for example, through an external library) whenever the component is patched. Note that this hook will not be called if the component is not in the DOM.</p>
			<p>The <code>onPatched</code> hook is used to register a function that will be executed at this moment.</p>
			<p>Updating the component state in this hook is possible, but not recommended. We need to be careful because updates here will create additional rendering, which in turn will cause other <a id="_idIndexMarker1181"/>calls to the <code>patched</code> method. So, we need to be particularly careful to prevent endless cycles.</p>
			<p>Like <code>mounted</code>, the <code>patched</code> hook is called in the order: children first, then parent.</p>
			<h3>willUnmount</h3>
			<p><code>willUnmount</code> is a hook that is called just before a component is unmounted from the DOM. This <a id="_idIndexMarker1182"/>is a good place to remove listeners, for example.</p>
			<p>The <code>onWillUnmount</code> hook is used to register a function that will be executed at this moment.</p>
			<p>This is the opposite method of <code>mounted</code>. Note that if a component is destroyed before being mounted, the <code>willUnmount</code> method may not be called.</p>
			<p>Parent <code>willUnmount</code> hooks will be called before children.</p>
			<h3>willDestroy</h3>
			<p>Sometimes, components <a id="_idIndexMarker1183"/>need to do some action in the setup and clean it up when they are inactive. However, the <code>willUnmount</code> hook is not appropriate for the cleaning operation, since the component may be destroyed before it has even been mounted. The <code>willDestroy</code> hook is useful in this situation since it is always called.</p>
			<p>The <code>onWillUnmount</code> hook is used to register a function that will be executed at this moment.</p>
			<p><code>willDestroy</code> hooks are first called on children, then on parents.</p>
			<h3>onError</h3>
			<p>Sadly, components <a id="_idIndexMarker1184"/>may crash at runtime. This is an unfortunate reality, and this is why OWL needs to provide a way to handle these errors.</p>
			<p>The <code>onError</code> hook is useful when we need to intercept and properly react to e<a id="_idTextAnchor966"/>rrors that occur in some sub-components.</p>
			<h2 id="_idParaDest-768"><a id="_idTextAnchor967"/>There’s more…</h2>
			<p>There is one more method in the component life cycle, but it is used when you are using subcomponents. OWL passes the parent component state via the <code>props</code> parameter, and when <code>props</code> is changed, the <code>willUpdateProps</code> method is called. This is an asynchronous method, which means you can perform an<a id="_idTextAnchor968"/> asynchronous operation such as RPC here.</p>
			<h1 id="_idParaDest-769"><a id="_idTextAnchor969"/>Adding an OWL field to the form view</h1>
			<p>Up to this point, we have learned about all the basics of OWL. Now we will move on to more advanced <a id="_idIndexMarker1185"/>aspects and create a field widget that can be used in the form view, just like the field widget recipe from the previous chapter.</p>
			<p>Odoo has many <a id="_idIndexMarker1186"/>widgets in the UI for different functionalities, such as a status bar, checkboxes, and radio buttons. which makes the operations in Odoo simpler and run with ease. For example, we used <code>widget='image'</code> to display a binary field as an image. To demonstrate how to create your own widget, we’ll write one widget that lets the user choose an integer field, but we will display it differently. Instead of an input box, we will display a color picker so that we can select a color number. Here, each number will be mapped to a color.</p>
			<p>In this recipe, we will create a color picker widget that will save integer values based on the color selected.</p>
			<p>To make the example more informative,<a id="_idTextAnchor970"/> we will use some advanced concepts of OWL.</p>
			<h2 id="_idParaDest-770"><a id="_idTextAnchor971"/>Getting ready</h2>
			<p>For this rec<a id="_idTextAnchor972"/>ipe, we will be using the <code>my_hostel</code> module.</p>
			<h2 id="_idParaDest-771"><a id="_idTextAnchor973"/>How to do it…</h2>
			<p>We’ll add a JavaScript file that contains our widget’s logic, an XML file that contains design logic, and an SCSS file to do some styling. Then, we will add one integer field to the books form to use our new widget.</p>
			<p>Perform the following steps to add a new field widget:</p>
			<ol>
				<li>Add the category integer field to the <code>hostel.room</code> model as follows:<pre class="source-code">
category = fields.Integer('Category')</pre></li>				<li> Add the <a id="_idIndexMarker1187"/>same field to the form view, with a <code>widget</code> attribute as well:<pre class="source-code">
       &lt;field name="category" widget="category_color"/&gt;</pre></li>				<li>Add <a id="_idIndexMarker1188"/>the QWeb templates for the field at <code>static/src/xml/field_widget.xml</code>:<pre class="source-code">
&lt;t t-name="OWLColorPill"&gt;
    &lt;span t-attf-class="o_color_pill o_color_#{props.color} #{props.value == props.color ? 'active': ''}"
          t-att-data-val="props.color"
          t-on-click="() =&gt; this.pillClicked()"
          t-attf-title="#{props.category_count or 0 } Room booked in this category" /&gt;
&lt;/t&gt;
&lt;span t-name="OWLFieldColorPills"&gt;
    &lt;t t-foreach="totalColors" t-as='color' t-key="color"&gt;
        &lt;ColorPill onClickColorUpdated="data =&gt; this.colorUpdated(data)"
                   color='color'
                   value="props.value"
                   category_count="categoryInfo[color]"/&gt;
    &lt;/t&gt;
&lt;/span&gt;</pre></li>				<li>List the QWeb file in the module’s <code>manifest</code> file:<pre class="source-code">
'assets': {
    'web.assets_backend': [
        'my_hostel/static/src/js/field_widget.js',
    ],
},</pre></li>				<li>Now we <a id="_idIndexMarker1189"/>want to add some SCSS for the field at <code>static/src/scss/field_widget.scss</code>. As the content of SCSS is too long, please <a id="_idIndexMarker1190"/>find the content of the SCSS file in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/05_owl_field/my_hostel/static/src/scss">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/05_owl_field/my_hostel/static/src/scss</a>.</li>
				<li>Add the static <code>/src/js/field_widget.js</code> JavaScript file with the following basic content:<pre class="source-code">
/** @odoo-module */
import { Component, onWillStart , onWillUpdateProps} from "@odoo/owl";
import { registry } from "@web/core/registry";
class ColorPill extends Component {
    static template = 'OWLColorPill';
    pillClicked() {
        this.props.onClickColorUpdated(this.props.color);
    }
}
export class OWLCategColorField extends Component {
    static supportedFieldTypes = ['integer'];
    static template = 'OWLFieldColorPills';
    static components = { ColorPill };
    setup() {
        this.totalColors = [1,2,3,4,5,6];
        onWillStart(async() =&gt; {
            await this.loadCategInformation();
        });
        onWillUpdateProps(async() =&gt; {
            await this.loadCategInformation();
        });
        super.setup();
    }
    colorUpdated(value) {
        this.props.record.update({ [this.props.name]: value });
    }
    async loadCategInformation() {
        var self = this;
        self.categoryInfo = {};
        var resModel = self.env.model.root.resModel;
        var domain = [];
        var fields = ['category'];
        var groupby = ['category'];
        const categInfoPromise = await self.env.services.orm.readGroup(
            resModel,
            domain,
            fields,
            groupby
        );
        categInfoPromise.map((info) =&gt; {
            self.categoryInfo[info.category] = info.category_count;
        });
    }
}
registry.category("fields").add("category_color",{
    component: OWLCategColorField
});</pre></li>				<li>Add JavaScript <a id="_idIndexMarker1191"/>and an SCSS file to the backend <a id="_idIndexMarker1192"/>assets as follows:<pre class="source-code">
'assets': {
    'web.assets_backend': [
        'my_hostel/static/src/scss/field_widget.scss',
        'my_hostel/static/src/js/field_widget.js',
        'my_hostel/static/src/xml/field_widget.xml',
    ],
},</pre></li>				<li>Restart and update the module to apply the module changes. Open the room form view. You will be able to see the color picker widget, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B20997_16_05.jpg" alt="Figure 16.5 – Color picker OWL widget"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5 – Color picker OWL widget</p>
			<ol>
				<li value="9">This field looks just like the color widget from the last chapter, but the actual difference <a id="_idIndexMarker1193"/>lies under the hood. This new field is built <a id="_idIndexMarker1194"/>with OWL components and subcomponents, while the previous one was built with widgets.</li>
				<li>The benefit of this subcomponent is to provide a comprehensive framework for building modern, responsive, and interactive UIs in OWL. By modularizing functionality into small, reusable units, developers can create more maintainable and extensible applications while reducing code<a id="_idTextAnchor974"/> duplication and improving development efficiency.</li>
			</ol>
			<h2 id="_idParaDest-772"><a id="_idTextAnchor975"/>How it works…</h2>
			<p>In <em class="italic">step 1</em>, we added an integer field to the <code>hostel.room</code> model.</p>
			<p>In <em class="italic">step 2</em>, we added the field to the form view of the room.</p>
			<p>In <em class="italic">step 3</em>, we added the QWeb template file. If you notice, we added two templates to the file, one for the color pill and the other for the field itself. We used two templates because we want to see the concept of the <code>subcomponent</code>. If you observe the template closely, you will find that we have used the <code>&lt;ColorPill&gt;</code> tag. This will be used to instantiate the subcomponent. On the <code>&lt;ColorPill&gt;</code> tag, we have passed the active and color attributes. These attributes will be received as <code>props</code> in the template of the subcomponent. Also note that the <code>onClickColorUpdated</code> attribute is used to listen to the custom event triggered from the subcomponent.</p>
			<p class="callout-heading">Important information</p>
			<p class="callout">Odoo v17 uses both the widget system and the OWL framework.</p>
			<p>In <em class="italic">step 4</em>, we listed our QWeb template in the manifest. This will automatically load our template in the browser.</p>
			<p>In <em class="italic">step 5</em>, we added SCSS for the color. This will help us to have a beautiful UI for the color picker.</p>
			<p>In <em class="italic">step 6</em>, we added JavaScript for the field component.</p>
			<p>We imported <a id="_idIndexMarker1195"/>the OWL utility and we also imported <a id="_idIndexMarker1196"/>the component and <code>fieldRegistry</code>.</p>
			<p><code>fieldRegistry</code> is used to list the OWL component as a field component.</p>
			<p>In <em class="italic">step 7</em>, we created the <code>ColorPill</code> component. The <code>template</code> variable on the component is the name of the template that is loaded from the external XML file. The <code>ColorPill</code> component has the <code>pillClicked</code> method, which is called when the user clicks on the color pill. Inside the method body, we have triggered the <code>onClickColorUpdated</code> event, which will be captured by the parent <code>OWLCategColorField</code> component as we used <code>colorUpdated</code> on the <code>OWLCategColorField</code> component.</p>
			<p>In <em class="italic">step 8</em> and <em class="italic">step 9</em>, we created the <code>OWLCategColorField</code> component by extending <code>Component</code>. We used the <code>Component</code> because it will have all the utilities that are required to create the field widget.</p>
			<p>If you notice, we used the <code>components</code> static variable at the start. You need to list the components via the <code>components</code> static variable when you are using subcomponents in the template. We also added the <code>onWillStart</code> method in our example. The <code>willStart</code> method is an asynchronous method, so we have called RPC (network call) to fetch data regarding the number of the room booked for a particular color. Toward the end, we added the <code>colorUpdated</code> method, which will be called when the user clicks on the pill. So, we are changing the values of the field. The <code>this.props.record.update</code> method is used to set the field values (which will be saved in the database). Note here that the data triggered from the child component is available under the <code>detail</code> attribute in the <code>event</code> parameter. Finally, we registered our widget in <code>fieldRegistry</code>, implying that henceforth, we will be able to use our field via the <code>widget</code> attribute in the form view.</p>
			<p>In <em class="italic">step 10</em>, we loade<a id="_idTextAnchor976"/>d JavaScript and SCSS files into the backend assets.</p>
			<h2 id="_idParaDest-773"><a id="_idTextAnchor977"/>There’s more…</h2>
			<h3>Understanding QWeb</h3>
			<p><code>t-</code>, for instance, <code>t-if</code> for conditionals, with elements and other attributes being rendered directly. The following are the different operations of the QWeb template:</p>
			<ul>
				<li><code>out</code>, will automatically HTML-escape its input, limiting XSS risks <a id="_idIndexMarker1198"/>when displaying user-provided content. <code>out</code> takes an expression, evaluates it, and injects the result into the document:</p><pre class="source-code">
&lt;p&gt;&lt;t t-out="value"/&gt;&lt;/p&gt;
&lt;p&gt;42&lt;/p&gt;</pre></li>				<li><code>set</code> directive, which takes the name of the variable to create. The value of <code>set</code> can be provided in two ways:</p><ul><li>A <code>t-value</code> attribute containing an expression, and the result of its evaluation will be set:<pre class="source-code">
&lt;t t-set="foo" t-value="2 + 1"/&gt;
&lt;t t-out="foo"/&gt;</pre></li></ul><pre></li></ul></li>				<li><code>if</code>, which evaluates an expression given as an attribute value:</pre><pre class="source-code">
&lt;div&gt;
    &lt;t t-if="condition"&gt;
        &lt;p&gt;ok&lt;/p&gt;
    &lt;/t&gt;
&lt;/div&gt;</pre><p class="list-inset">The element is rendered if the condition is <code>true</code>:</p><pre class="source-code">&lt;div&gt;
    &lt;p&gt;ok&lt;/p&gt;
&lt;/div&gt;</pre><p class="list-inset">But if the condition is <code>false</code>, it is removed from the result:</p><pre class="source-code">&lt;div&gt;
&lt;/div&gt;</pre><p class="list-inset">Extra <a id="_idIndexMarker1202"/>conditional branching directives, <code>t-elif</code> and <code>t-else</code>, are also available:</p><pre class="source-code">&lt;div&gt;
    &lt;p t-if="user.birthday == today()"&gt;Happy birthday!&lt;/p&gt;
    &lt;p t-elif="user.login == 'root'"&gt;Welcome master!&lt;/p&gt;
    &lt;p t-else=""&gt;Welcome!&lt;/p&gt;
&lt;/div&gt;</pre></li>				<li><code>foreach</code>, which takes an expression that returns the collection to iterate on, and a second parameter, <code>t-as</code>, providing the name to use for the current item of the iteration:</p><pre class="source-code">
&lt;t t-foreach="[1, 2, 3]" t-as="i"&gt;
    &lt;p&gt;&lt;t t-out="i"/&gt;&lt;/p&gt;
&lt;/t&gt;</pre><p class="list-inset">This will be rendered as follows:</p><pre class="source-code">&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;</pre></li>				<li><code>t-att</code> (attribute) directive, which exists in three different forms:</p><pre class="source-code">
t-att-$name
&lt; div t-att-a="42"/&gt;</pre><p class="list-inset">This will be rendered as follows:</pre><pre class="source-code">&lt;div a="42"&gt;&lt;/div&gt;
    t-attf-$name
<p class="list-inset">This will be rendered as follows:</pre><pre class="source-code">&lt; li class="row even"&gt;1&lt;/li&gt;
&lt;li class="row odd"&gt;2&lt;/li&gt;
&lt;li class="row even"&gt;3&lt;/li&gt;
      t-att=mapping
&lt;div t-att="{'a': 1, 'b': 2}"/&gt;</pre><p class="list-inset">This will be rendered as follows:</pre><pre class="source-code">&lt;div a="1" b="2"&gt;&lt;/div&gt;
t-att=pair
&lt;div t-att="['a', 'b']"/&gt;</pre><p class="list-inset">This will be rendered as follows:</pre><pre class="source-code">&lt;div a="b"&gt;
&lt;/div&gt;</pre></li>				<li><code>t-call</code> directive:</p><pre class="source-code">
&lt;t t-call="other-template"/&gt;
&lt;p&gt;&lt;t t-value="var"/&gt;&lt;/p&gt;</pre><p class="list-inset">The preceding call will be rendered as <code>&lt;p/&gt; (</code><code>no content)</code>.</pre><pre class="source-code">&lt;t t-set="var" t-value="1"/&gt;
&lt;t t-call="other-template"/&gt;
<p class="list-inset">The body <a id="_idIndexMarker1207"/>of the <code>call</code> directive can be arbitrarily complex (not just set directives), and its rendered form will be available within the called template as a magical <code>0</code> variable:</pre><pre class="source-code">&lt;div&gt;
    This template was called with content:
    &lt;t t-out="0"/&gt;
&lt;/div&gt;
<p class="list-inset">This will result in the following:</pre><pre class="source-code">&lt;div&gt;
    This template was called with content:
    &lt;em&gt;content&lt;/em&gt;
&lt;/div&gt;</pre></li>			</ul>
			<h3>Understanding subcomponents</h3>
			<p>In the context of OWL, subcomponents refer to small, modular units of functionality that can be <a id="_idIndexMarker1208"/>integrated into larger components to enhance their capabilities or provide additional features.</p>
			<p>Subcomponents in OWL can include various elements, such as widgets, utilities, services, and views, which are designed to work together within the OWL framework to create rich, interactive UIs and manage client-side logic efficiently.</p>
			<p>These subcomponents work together to provide a comprehensive framework for building modern, responsive, and interactive UIs in OWL. By modularizing functionality into small, reusable units, developers can create more maintainable and extensible applications while reducing code duplication and improving development efficiency.</p>
			<p>It is convenient to define a component using other (sub) components. This is called composition and is very powerful in practice. To do that in OWL, we can just use a tag starting with a capital letter in its template, and register the subcomponent class in its static <code>component</code> object:</p>
			<pre class="source-code">
class Child extends Component {
  static template = xml`&lt;div&gt;child component &lt;t t-esc="props.value"/&gt;&lt;/div&gt;`;
}
class Parent extends Component {
  static template = xml`
    &lt;div&gt;
      &lt;Child value="1"/&gt;
      &lt;Child value="2"/&gt;
    &lt;/div&gt;`;
  static components = { Child };
}</pre>			<p>Here, <code>&lt;Child&gt;</code> has <code>subcomponent</code>. This example also shows how we can pass information from the parent component to the child component as props. In OWL, <code>props</code> (short for properties) is an object that contains every piece of data given to a component by its parent. Note that <code>props</code> is an object that only makes sense from the perspective of the child component.</p>
			<p>The <code>props</code> object is <a id="_idIndexMarker1209"/>made of every attribute defined on the template, with the following exceptions: every attribute starting with <code>t-</code> is not a prop (they are QWeb directives).</p>
			<p>In the following example:</p>
			<pre class="source-code">
&lt;div&gt;
    &lt;Child value="string"/&gt;
    &lt;Child t-if="condition" model="model"/&gt;
&lt;/div&gt;</pre>			<p>The <code>props</code> object contains the following keys:</p>
			<pre class="source-code">
for Child: value,
for Child: model,</pre>		</div>
	</body></html>