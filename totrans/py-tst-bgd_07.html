<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Developing a Test-Driven Project"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Developing a Test-Driven Project</h1></div></div></div><a class="indexterm" id="id344"/><a class="indexterm" id="id345"/><p>
<span class="emphasis"><em>In this chapter, we won't talk about new techniques for testing in Python, neither will we spend much time talking about the philosophy of testing. Instead, what we'll do is walk step-by-step through a record of an actual development process. Your humble and sadly fallible author has memorialized his mistakes—and the ways that testing helped him fix them—while developing part of a personal scheduling program.</em></span>
</p><p>In this chapter, we shall:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Write a testable specification</li><li class="listitem" style="list-style-type: disc">Write unit tests</li><li class="listitem" style="list-style-type: disc">Write code that complies with the specification and unit tests</li><li class="listitem" style="list-style-type: disc">Use the testable specification and unit tests to help debug</li></ul></div><p>You'll be prompted to design and build your own module as you read through this chapter, so that you can walk through your own process as well.</p><div class="section" title="Writing the specification"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec59"/>Writing the specification</h1></div></div></div><a class="indexterm" id="id346"/><p>As usual, the process starts with a written specification. The specification is a doctest, (which we learned about in Chapters 2 and 3), so the computer can use it to check the implementation. The specification isn't strictly a set of unit tests though; the discipline of unit testing has been sacrificed (for the moment) in exchange for making the document more accessible to a human reader. That's a common trade-off, and it's fine as long as you make up for it by also writing unit tests covering the code.</p><p>The goal of the project is to make a Python package capable of representing personal time management information.</p><p>The following code goes in a file called <code class="literal">docs/outline.txt</code>:</p><div class="informalexample"><pre class="programlisting">This project is a personal scheduling system intended to keep track of a single person's schedule and activities. The system will store and display two kinds of schedule information: activities and statuses. Activities and statuses both support a protocol which allows them to be checked for overlap with another object supporting the protocol.

&gt;&gt;&gt; from planner.data import activities, statuses
&gt;&gt;&gt; from datetime import datetime

Activities and statuses are stored in schedules, to which they can be added and removed.
<a class="indexterm" id="id347"/>
&gt;&gt;&gt; from planner.data import schedules
&gt;&gt;&gt; activity = activities('test activity',
...                       datetime(year=2009, month=6, day=1,
...                                hour=10, minute=15),
...                       datetime(year=2009, month=6, day=1,
...                                hour=12, minute=30))
&gt;&gt;&gt; duplicate_activity = activities('test activity',
...                       datetime(year=2009, month=6, day=1,
...                                hour=10, minute=15),
...                       datetime(year=2009, month=6, day=1,
...                                hour=12, minute=30))
&gt;&gt;&gt; status = statuses('test status',
...                   datetime(year=2009, month=7, day=1,
...                            hour=10, minute=15),
...                   datetime(year=2009, month=7, day=1,
...                            hour=12, minute=30))
&gt;&gt;&gt; schedule = schedules()
&gt;&gt;&gt; schedule.add(activity)
&gt;&gt;&gt; schedule.add(status)
&gt;&gt;&gt; status in schedule
True
&gt;&gt;&gt; activity in schedule
True
&gt;&gt;&gt; duplicate_activity in schedule
True
&gt;&gt;&gt; schedule.remove(activity)
&gt;&gt;&gt; schedule.remove(status)
&gt;&gt;&gt; status in schedule
False
&gt;&gt;&gt; activity in schedule
False

Activities represent tasks that the person must actively engage in, and they are therefore mutually exclusive: no person can have two activities that overlap the same period of time.

&gt;&gt;&gt; activity1 = activities('test activity 1',
...                        datetime(year=2009, month=6, day=1,
...                                 hour=9, minute=5),
...                        datetime(year=2009, month=6, day=1,
...                                 hour=12, minute=30))
&gt;&gt;&gt; activity2 = activities('test activity 2',
...                        datetime(year=2009, month=6, day=1,
...                                 hour=10, minute=15),
...                        datetime(year=2009, month=6, day=1,
...                                 hour=13, minute=30))
&gt;&gt;&gt; schedule = schedules()
&gt;&gt;&gt; schedule.add(activity1)
&gt;&gt;&gt; schedule.add(activity2) # doctest:+ELLIPSIS
Traceback (most recent call last):
schedule_error: "test activity 2" overlaps with "test activity 1"
<a class="indexterm" id="id348"/>
Statuses represent tasks that a person engages in passively, and so
can overlap with each other and with activities.

&gt;&gt;&gt; activity1 = activities('test activity 1',
...                        datetime(year=2009, month=6, day=1,
...                                 hour=9, minute=5),
...                        datetime(year=2009, month=6, day=1,
...                                 hour=12, minute=30))
&gt;&gt;&gt; status1 = statuses('test status 1',
...                    datetime(year=2009, month=6, day=1,
...                             hour=10, minute=15),
...                    datetime(year=2009, month=6, day=1,
...                             hour=13, minute=30))
&gt;&gt;&gt; status2 = statuses('test status 2',
...                    datetime(year=2009, month=6, day=1,
...                             hour=8, minute=45),
...                    datetime(year=2009, month=6, day=1,
...                             hour=15, minute=30))
&gt;&gt;&gt; schedule = schedules()
&gt;&gt;&gt; schedule.add(activity1)
&gt;&gt;&gt; schedule.add(status1)
&gt;&gt;&gt; schedule.add(status2)
&gt;&gt;&gt; activity1 in schedule
True
&gt;&gt;&gt; status1 in schedule
True
&gt;&gt;&gt; status2 in schedule
True

Schedules can be saved to a sqlite database, and they can be reloaded
from that stored state.

&gt;&gt;&gt; from planner.persistence import file
&gt;&gt;&gt; storage = file(':memory:')
&gt;&gt;&gt; schedule.store(storage)
&gt;&gt;&gt; newsched = schedules.load(storage)
&gt;&gt;&gt; schedule == newsched
True</pre></div><a class="indexterm" id="id349"/><p>This doctest will serve as a testable specification for my project, which means that it will be the foundation stone on which all of my other tests (and my program code) will be built on. Let's look at each section in more detail:</p><div class="informalexample"><pre class="programlisting">This project is a personal scheduling system intended to keep track of a single person's schedule and activities. The system will store and display two kinds of schedule information: activities and statuses. Activities and statuses both support a protocol which allows them to be checked for overlap with another object supporting the protocol.

&gt;&gt;&gt; from planner.data import activities, statuses
&gt;&gt;&gt; from datetime import datetime</pre></div><p>The above code consists of some introductory English text and a couple of import statements that bring in code that we need for these tests. By doing so, they also tell us about some of the structure of the <code class="literal">planner</code> package. Specifically, they tell us that it contains a module called <code class="literal">data</code>, which defines activities and statuses.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; from planner.data import schedules
&gt;&gt;&gt; activity = activities('test activity',
...                       datetime(year=2009, month=6, day=1,
...                                hour=10, minute=15),
...                       datetime(year=2009, month=6, day=1,
...                                hour=12, minute=30))
&gt;&gt;&gt; duplicate_activity = activities('test activity',
...                       datetime(year=2009, month=6, day=1,
...                                hour=10, minute=15),
...                       datetime(year=2009, month=6, day=1,
...                                hour=12, minute=30))
&gt;&gt;&gt; status = statuses('test status',
...                   datetime(year=2009, month=7, day=1,
...                            hour=10, minute=15),
...                   datetime(year=2009, month=7, day=1,
...                            hour=12, minute=30))
&gt;&gt;&gt; schedule = schedules()
&gt;&gt;&gt; schedule.add(activity)
&gt;&gt;&gt; schedule.add(status)
&gt;&gt;&gt; status in schedule
True
&gt;&gt;&gt; activity in schedule
True
&gt;&gt;&gt; duplicate_activity in schedule
True
&gt;&gt;&gt; schedule.remove(activity)
&gt;&gt;&gt; schedule.remove(status)
&gt;&gt;&gt; status in schedule
False
&gt;&gt;&gt; activity in schedule
False</pre></div><a class="indexterm" id="id350"/><p>The above tests describe some of the desired behavior of <code class="literal">schedules</code> for <code class="literal">activities</code> and <code class="literal">statuses</code>. According to these tests, <code class="literal">schedules</code> must accept <code class="literal">activities</code> and <code class="literal">statuses</code> as parameters of its <code class="literal">add</code> and <code class="literal">remove</code> methods. Once they're added, the <code class="literal">in</code> operator must return <code class="literal">True</code> for an object until it is removed. Furthermore, two <code class="literal">activities</code> that have the same parameters must be treated as the same object by <code class="literal">schedules</code>.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; activity1 = activities('test activity 1',
...                        datetime(year=2009, month=6, day=1,
...                                 hour=9, minute=5),
...                        datetime(year=2009, month=6, day=1,
...                                 hour=12, minute=30))
&gt;&gt;&gt; activity2 = activities('test activity 2',
...                        datetime(year=2009, month=6, day=1,
...                                 hour=10, minute=15),
...                        datetime(year=2009, month=6, day=1,
...                                 hour=13, minute=30))
&gt;&gt;&gt; schedule = schedules()
&gt;&gt;&gt; schedule.add(activity1)
&gt;&gt;&gt; schedule.add(activity2) # doctest:+ELLIPSIS
Traceback (most recent call last):
schedule_error: "test activity 2" overlaps with "test activity 1"</pre></div><p>The above test code describes what should happen when overlapping activities are added to a schedule. Specifically, a <code class="literal">schedule_error</code> should be raised.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; activity1 = activities('test activity 1',
...                        datetime(year=2009, month=6, day=1,
...                                 hour=9, minute=5),
...                        datetime(year=2009, month=6, day=1,
...                                 hour=12, minute=30))
&gt;&gt;&gt; status1 = statuses('test status 1',
...                    datetime(year=2009, month=6, day=1,
...                             hour=10, minute=15),
...                    datetime(year=2009, month=6, day=1,
...                             hour=13, minute=30))
&gt;&gt;&gt; status2 = statuses('test status 2',
...                    datetime(year=2009, month=6, day=1,
...                             hour=8, minute=45),
...                    datetime(year=2009, month=6, day=1,
...                             hour=15, minute=30))
&gt;&gt;&gt; schedule = schedules()
&gt;&gt;&gt; schedule.add(activity1)
&gt;&gt;&gt; schedule.add(status1)
&gt;&gt;&gt; schedule.add(status2)
&gt;&gt;&gt; activity1 in schedule
True
&gt;&gt;&gt; status1 in schedule
True
&gt;&gt;&gt; status2 in schedule
True</pre></div><a class="indexterm" id="id351"/><p>The above test code describes what should happen when overlapping statuses are added to a schedule: the schedule should accept them. Furthermore, if a status and an activity overlap, they can still both be added.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; from planner.persistence import file
&gt;&gt;&gt; storage = file(':memory:')
&gt;&gt;&gt; schedule.store(storage)
&gt;&gt;&gt; newsched = schedules.load(storage)
&gt;&gt;&gt; schedule == newsched
True</pre></div><p>The above code describes how schedule storage should work. It also tells us that the <code class="literal">planner</code> package needs to contain a <code class="literal">persistence</code> module, which in turn should contain <code class="literal">file</code>.</p></div></div>
<div class="section" title="Time for action &#x2013; what are you going to do?"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Time for action – what are you going to do?</h1></div></div></div><p>It's time for you to come up with a project of your own, something that you can work on by yourself; we step through the development process:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Think of a project of approximately the same complexity as the one described in this chapter. It should be a single module or a few modules in a single package.</li><li class="listitem">Imagine that the project is already done, and you need to write a description of what you've done, along with a little bit of demonstration code. Then go ahead and write your description and demo code in the form of a doctest file.</li><li class="listitem">As you're writing the doctest file, look out for places where your original idea has to change a little bit to make the demo easier to write, or work better. When you find such cases, pay attention to them! At this stage, it's better to change the idea a little bit and save yourself effort all through the process.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec81"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We've got testable specifications for moderately-sized projects, now. These will help us to write unit tests and code, and they'll give us a sense of how complete the project is, as a whole.</p><p>In addition, the process of writing code into the doctest gave us a chance to test-drive our ideas. We've probably improved our projects a little bit by using them in a concrete manner, even though the project implementation is still merely imaginary.</p><p>Once again, it's important that we have written these tests <span class="emphasis"><em>before</em></span> writing the code that they will test. By writing the tests first, we give ourselves a touchstone that we can use to judge how well our code conforms to what we intended. If we write the code first, and then the tests, all we end up doing is enshrining what the code actually does—as opposed to what we meant for it to do—into the tests.</p></div></div>
<div class="section" title="Writing initial unit tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Writing initial unit tests</h1></div></div></div><a class="indexterm" id="id352"/><p>Since the specification doesn't contain unit tests, there's still a need for unit tests before the coding of the module can begin. <a class="indexterm" id="id353"/>The <code class="literal">planner.data</code> classes are the first target for implementation, so they're the first ones to get tests.</p><p>Activities and statuses are defined to be very similar, so their test modules are also similar. They're not identical though, and they're not required to have any particular inheritance relationship, so the tests remain distinct.</p><p>The following tests are in <code class="literal">tests/test_activities.py</code>:</p><div class="informalexample"><pre class="programlisting">from unittest import TestCase
from mocker import MockerTestCase
from planner.data import activities, task_error
from datetime import datetime

class constructor_tests(TestCase):
    def test_valid(self):
        activity = activities('activity name',
                              datetime(year=2007, month=9, day=11),
                              datetime(year=2008, month=4, day=27))

        self.assertEqual(activity.name, 'activity name')
        self.assertEqual(activity.begins,
                         datetime(year = 2007, month = 9, day = 11))
        self.assertEqual(activity.ends,
                         datetime(year = 2008, month = 4, day = 27))

    def test_backwards_times(self):
        self.assertRaises(task_error,
                          activities,
                          'activity name',
                          datetime(year=2008, month=4, day=27),
                          datetime(year=2007, month=9, day=11))

    def test_too_short(self):
        self.assertRaises(task_error,
                          activities,
                          'activity name',
                          datetime(year = 2008, month = 4, day = 27,
                                   hour = 7, minute = 15),
                          datetime(year = 2008, month = 4, day = 27,
                                   hour = 7, minute = 15))

class utility_tests(TestCase):
    def test_repr(self):
        activity = activities('activity name',
                              datetime(year=2007, month=9, day=11),
                              datetime(year=2008, month=4, day=27))

        expected = "&lt;activity name 2007-09-11T00:00:00 2008-04-27T00:00:00&gt;"

        self.assertEqual(repr(activity), expected)
<a class="indexterm" id="id354"/>
class exclusivity_tests(TestCase):
    def test_excludes(self):
        activity = activities('activity name',
                              datetime(year=2007, month=9, day=11),
                              datetime(year=2007, month=10, day=6))

        # Any activity should exclude any other activity
        self.assertTrue(activity.excludes(activity))

        # Anything not known to be excluded should be included
        self.assertFalse(activity.excludes(None))

class overlap_tests(MockerTestCase):
    def setUp(self):
        pseudo = self.mocker.mock()

        pseudo.begins
        self.mocker.result(datetime(year=2007, month=10, day=7))
        self.mocker.count(0, None)

        pseudo.ends
        self.mocker.result(datetime(year=2008, month=2, day=5))
        self.mocker.count(0, None)
<a class="indexterm" id="id355"/>
        self.other = pseudo

        self.mocker.replay()

    def test_overlap_before(self):
        activity = activities('activity name',
                              datetime(year=2007, month=9, day=11),
                              datetime(year=2007, month=10, day=6))

        self.assertFalse(activity.overlaps(self.other))

    def test_overlap_begin(self):
        activity = activities('activity name',
                              datetime(year=2007, month=8, day=11),
                              datetime(year=2007, month=11, day=27))

        self.assertTrue(activity.overlaps(self.other))

    def test_overlap_end(self):
        activity = activities('activity name',
                              datetime(year=2008, month=1, day=11),
                              datetime(year=2008, month=4, day=16))

        self.assertTrue(activity.overlaps(self.other))

    def test_overlap_inner(self):
        activity = activities('activity name',
                              datetime(year=2007, month=10, day=11),
                              datetime(year=2008, month=1, day=27))

        self.assertTrue(activity.overlaps(self.other))

    def test_overlap_outer(self):
        activity = activities('activity name',
                              datetime(year=2007, month=8, day=12),
                              datetime(year=2008, month=3, day=15))

        self.assertTrue(activity.overlaps(self.other))

    def test_overlap_after(self):
        activity = activities('activity name',
                              datetime(year=2008, month=2, day=6),
                              datetime(year=2008, month=4, day=27))

        self.assertFalse(activity.overlaps(self.other))</pre></div><p>Let's take a look at each section of the above unit test code:</p><div class="informalexample"><pre class="programlisting">    def test_valid(self):
        activity = activities('activity name',
                              datetime(year=2007, month=9, day=11),
                              datetime(year=2008, month=4, day=27))
<a class="indexterm" id="id356"/>
        self.assertEqual(activity.name, 'activity name')
        self.assertEqual(activity.begins,
                         datetime(year = 2007, month = 9, day = 11))
        self.assertEqual(activity.ends,
                         datetime(year = 2008, month = 4, day = 27))</pre></div><a class="indexterm" id="id357"/><p>The <code class="literal">test_valid</code> method checks that the constructor works correctly when all of the parameters are correct. This is an important test, because it defines what correct behavior in the normal case should be. We need more tests though, to define correct behavior in abnormal situations.</p><div class="informalexample"><pre class="programlisting">    def test_backwards_times(self):
        self.assertRaises(task_error,
                          activities,
                          'activity name',
                          datetime(year=2008, month=4, day=27),
                          datetime(year=2007, month=9, day=11))</pre></div><p>Here, we'll make sure that you can't create an activity that ends before it begins. That doesn't make any sense, and could easily throw off assumptions made during the implementation.</p><div class="informalexample"><pre class="programlisting">    def test_too_short(self):
        self.assertRaises(task_error,
                          activities,
                          'activity name',
                          datetime(year = 2008, month = 4, day = 27,
                                   hour = 7, minute = 15),
                          datetime(year = 2008, month = 4, day = 27,
                                   hour = 7, minute = 15))</pre></div><p>We don't want extremely short activities either. In the real world, an activity that takes no time is meaningless, so we have a test here to make sure that such things are not allowed.</p><div class="informalexample"><pre class="programlisting">class utility_tests(TestCase):
    def test_repr(self):
        activity = activities('activity name',
                              datetime(year=2007, month=9, day=11),
                              datetime(year=2008, month=4, day=27))

        expected = "&lt;activity name 2007-09-11T00:00:00 2008-04-27T00:00:00&gt;"

        self.assertEqual(repr(activity), expected)</pre></div><p>While <code class="literal">repr(activity)</code> isn't likely to be used in any production code paths, it's handy during development and debugging. This test defines how the text representation of an activity should look, to make sure that it contains the desired information.</p><div class="informalexample"><pre class="programlisting">class exclusivity_tests(TestCase):
    def test_excludes(self):
        activity = activities('activity name',
                              datetime(year=2007, month=9, day=11),
                              datetime(year=2007, month=10, day=6))

        # Any activity should exclude any other activity
        self.assertTrue(activity.excludes(activity))

        # Anything not known to be excluded should be included
        self.assertFalse(activity.excludes(None))</pre></div><a class="indexterm" id="id358"/><p>Since activities are supposed to be exclusive of each other when they overlap, we check that here. The activity obviously overlaps with itself, so the <code class="literal">excludes</code> method should return <code class="literal">True</code>. On the other hand, an activity shouldn't just assume it excludes everything, so calling <code class="literal">excludes</code> on unknown objects (such as <code class="literal">None</code>) should return <code class="literal">False</code>.</p><div class="informalexample"><pre class="programlisting">class overlap_tests(MockerTestCase):
    def setUp(self):
        pseudo = self.mocker.mock()

        pseudo.begins
        self.mocker.result(datetime(year=2007, month=10, day=7))
        self.mocker.count(0, None)

        pseudo.ends
        self.mocker.result(datetime(year=2008, month=2, day=5))
        self.mocker.count(0, None)

        self.other = pseudo

        self.mocker.replay()</pre></div><p>Here we created a test fixture that creates a mock object which pretends to be an activity <a class="indexterm" id="id359"/>or status. We'll use this mock object (called <code class="literal">self.other</code>) in several of the following tests.</p><div class="informalexample"><pre class="programlisting">    def test_overlap_before(self):
        activity = activities('activity name',
                              datetime(year=2007, month=9, day=11),
                              datetime(year=2007, month=10, day=6))

        self.assertFalse(activity.overlaps(self.other))

    def test_overlap_begin(self):
        activity = activities('activity name',
                              datetime(year=2007, month=8, day=11),
                              datetime(year=2007, month=11, day=27))

        self.assertTrue(activity.overlaps(self.other))

    def test_overlap_end(self):
        activity = activities('activity name',
                              datetime(year=2008, month=1, day=11),
                              datetime(year=2008, month=4, day=16))

        self.assertTrue(activity.overlaps(self.other))

    def test_overlap_inner(self):
        activity = activities('activity name',
                              datetime(year=2007, month=10, day=11),
                              datetime(year=2008, month=1, day=27))

        self.assertTrue(activity.overlaps(self.other))

    def test_overlap_outer(self):
        activity = activities('activity name',
                              datetime(year=2007, month=8, day=12),
                              datetime(year=2008, month=3, day=15))

        self.assertTrue(activity.overlaps(self.other))

    def test_overlap_after(self):
        activity = activities('activity name',
                              datetime(year=2008, month=2, day=6),
                              datetime(year=2008, month=4, day=27))

        self.assertFalse(activity.overlaps(self.other))</pre></div><p>These tests describe the behavior of activity overlap checking in the cases where the activity:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Comes after the mock object</li><li class="listitem" style="list-style-type: disc">Overlaps the end of the mock object</li><li class="listitem" style="list-style-type: disc">Overlaps the beginning of the mock object</li><li class="listitem" style="list-style-type: disc">Starts after the mock object and ends before it</li><li class="listitem" style="list-style-type: disc">Starts before the mock object and ends after it</li></ul></div><a class="indexterm" id="id360"/><p>The following tests are in <code class="literal">tests/test_statuses.py</code>. Many of these are similar to the tests for <code class="literal">activities</code>. We'll concentrate on the differences:</p><div class="informalexample"><pre class="programlisting">from unittest import TestCase
from mocker import MockerTestCase
from planner.data import statuses, task_error
from datetime import datetime

class constructor_tests(TestCase):
    def test_valid(self):
        status = statuses('status name',
                          datetime(year=2007, month=9, day=11),
                          datetime(year=2008, month=4, day=27))

        self.assertEqual(status.name, 'status name')
        self.assertEqual(status.begins,
                         datetime(year=2007, month=9, day=11))
        self.assertEqual(status.ends,
                         datetime(year=2008, month=4, day=27))

    def test_backwards_times(self):
        self.assertRaises(task_error,
                          statuses,
                          'status name',
                          datetime(year=2008, month=4, day=27),
                          datetime(year=2007, month=9, day=11))

    def test_too_short(self):
        self.assertRaises(task_error,
                          statuses,
                          'status name',
                          datetime(year=2008, month=4, day=27,
                                   hour=7, minute=15),
                          datetime(year=2008, month=4, day=27,
                                   hour=7, minute=15))

class utility_tests(TestCase):
    def test_repr(self):
        status = statuses('status name',
                              datetime(year=2007, month=9, day=11),
                              datetime(year=2008, month=4, day=27))

        expected = "&lt;status name 2007-09-11T00:00:00 2008-04-27T00:00:00&gt;"

        self.assertEqual(repr(status), expected)

class exclusivity_tests(TestCase):
    def test_excludes(self):
        status = statuses('status name',
                          datetime(year=2007, month=9, day=11),
                          datetime(year=2007, month=10, day=6))

        # A status shouldn't exclude anything
        self.assertFalse(status.excludes(status))
        self.assertFalse(status.excludes(None))

class overlap_tests(MockerTestCase):
    def setUp(self):
        pseudo = self.mocker.mock()

        pseudo.begins
        self.mocker.result(datetime(year=2007, month=10, day=7))
        self.mocker.count(1, None)

        pseudo.ends
        self.mocker.result(datetime(year=2008, month=2, day=5))
        self.mocker.count(1, None)

        self.other = pseudo

        self.mocker.replay()

    def test_overlap_before(self):
        status = statuses('status name',
                          datetime(year=2007, month=9, day=11),
                          datetime(year=2007, month=10, day=6))

        self.assertFalse(status.overlaps(self.other))

    def test_overlap_begin(self):
        status = statuses('status name',
                          datetime(year=2007, month=8, day=11),
                          datetime(year=2007, month=11, day=27))

        self.assertTrue(status.overlaps(self.other))

    def test_overlap_end(self):
        status = statuses('status name',
                          datetime(year=2008, month=1, day=11),
                          datetime(year=2008, month=4, day=16))

        self.assertTrue(status.overlaps(self.other))

    def test_overlap_inner(self):
        status = statuses('status name',
                          datetime(year=2007, month=10, day=11),
                          datetime(year=2008, month=1, day=27))

        self.assertTrue(status.overlaps(self.other))

    def test_overlap_outer(self):
        status = statuses('status name',
                          datetime(year=2007, month=8, day=12),
                          datetime(year=2008, month=3, day=15))

        self.assertTrue(status.overlaps(self.other))

    def test_overlap_after(self):
        status = statuses('status name',
                          datetime(year=2008, month=2, day=6),
                          datetime(year=2008, month=4, day=27))

        self.assertFalse(status.overlaps(self.other))</pre></div><p>There's one significant area of difference between this test file and the previous one, the <code class="literal">test_excludes</code> method.<a class="indexterm" id="id361"/>
</p><div class="informalexample"><pre class="programlisting">class exclusivity_tests(TestCase):
    def test_excludes(self):
        status = statuses('status name',
                          datetime(year=2007, month=9, day=11),
                          datetime(year=2007, month=10, day=6))

        # A status shouldn't exclude anything
        self.assertFalse(status.excludes(status))
        self.assertFalse(status.excludes(None))</pre></div><p>Unlike an activity, a status should never force itself to be exclusive with something else, so this test uses <code class="literal">assertFalse</code>, instead of <code class="literal">assertTrue</code> for the first assertion.</p><a class="indexterm" id="id362"/><p>The following tests are in <code class="literal">tests/test_schedules.py</code>. We define several mock objects in the <a class="indexterm" id="id363"/>
<code class="literal">setUp</code> method that behave as if they were <code class="literal">activities</code> or <code class="literal">statuses</code>. These mock objects simulate activities or statuses, and so by using them instead of real activities or statuses they allow us to check that the <code class="literal">schedules</code> class correctly handles events that either do or do not overlap, and that either do or do not exclude each other, all without actually using code from outside the unit being tested.</p><div class="informalexample"><pre class="programlisting">from unittest import TestCase
from mocker import MockerTestCase, ANY
from planner.data import schedules, schedule_error
from datetime import datetime

class add_tests(MockerTestCase):
    def setUp(self):

        overlap_exclude = self.mocker.mock()
        overlap_exclude.overlaps(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        overlap_exclude.excludes(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)

        overlap_include = self.mocker.mock()
        overlap_include.overlaps(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        overlap_include.excludes(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)

        distinct_exclude = self.mocker.mock()
        distinct_exclude.overlaps(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)
        distinct_exclude.excludes(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)

        distinct_include = self.mocker.mock()
        distinct_include.overlaps(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)
        distinct_include.excludes(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)

        self.overlap_exclude = overlap_exclude
        self.overlap_include = overlap_include
        self.distinct_exclude = distinct_exclude
        self.distinct_include = distinct_include

        self.mocker.replay()

    def test_add_overlap_exclude(self):
        schedule = schedules()
        schedule.add(self.distinct_include)
        self.assertRaises(schedule_error,
                          schedule.add,
                          self.overlap_exclude)

    def test_add_overlap_include(self):
        schedule = schedules()
        schedule.add(self.distinct_include)
        schedule.add(self.overlap_include)
<a class="indexterm" id="id364"/>
    def test_add_distinct_exclude(self):
        schedule = schedules()
        schedule.add(self.distinct_include)
        schedule.add(self.distinct_exclude)
    def test_add_distinct_include(self):
        schedule = schedules()
        schedule.add(self.distinct_include)
        schedule.add(self.distinct_include)

    def test_add_over_overlap_exclude(self):
        schedule = schedules()
        schedule.add(self.overlap_exclude)
        self.assertRaises(schedule_error,
                          schedule.add,
                          self.overlap_include)

    def test_add_over_distinct_exclude(self):
        schedule = schedules()
        schedule.add(self.distinct_exclude)
        self.assertRaises(schedule_error,
                          schedule.add,
                          self.overlap_include)

    def test_add_over_overlap_include(self):
        schedule = schedules()
        schedule.add(self.overlap_include)
        schedule.add(self.overlap_include)

    def test_add_over_distinct_include(self):
        schedule = schedules()
        schedule.add(self.distinct_include)
        schedule.add(self.overlap_include)
<a class="indexterm" id="id365"/>
class in_tests(MockerTestCase):
    def setUp(self):
        fake = self.mocker.mock()
        fake.overlaps(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        fake.excludes(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)

        self.fake = fake

        self.mocker.replay()

    def test_in_before_add(self):
        schedule = schedules()
        self.assertFalse(self.fake in schedule)

    def test_in_after_add(self):
        schedule = schedules()
        schedule.add(self.fake)
        self.assertTrue(self.fake in schedule)</pre></div><p>Let's go over those tests section by section.</p><div class="informalexample"><pre class="programlisting">    def setUp(self):

        overlap_exclude = self.mocker.mock()
        overlap_exclude.overlaps(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        overlap_exclude.excludes(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)

        overlap_include = self.mocker.mock()
        overlap_include.overlaps(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        overlap_include.excludes(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)
<a class="indexterm" id="id366"/>
        distinct_exclude = self.mocker.mock()
        distinct_exclude.overlaps(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)
        distinct_exclude.excludes(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)

        distinct_include = self.mocker.mock()
        distinct_include.overlaps(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)
        distinct_include.excludes(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)

        self.overlap_exclude = overlap_exclude
        self.overlap_include = overlap_include
        self.distinct_exclude = distinct_exclude
        self.distinct_include = distinct_include

        self.mocker.replay()</pre></div><p>We created four mock objects here: <code class="literal">overlap_exclude</code>, <code class="literal">overlap_include</code>, <code class="literal">distinct_exclude</code>, and d<code class="literal">istinct_include</code>. Each of them represents a different combination of behavior of its <code class="literal">overlaps</code> method and its <code class="literal">excludes</code> method. Between these four mock objects, we have every combination of overlapping or not overlapping, and excluding or not excluding. In the following tests, we'll add various combinations of these mock objects to a schedule, and make sure it does the right things.<a class="indexterm" id="id367"/>
</p><div class="informalexample"><pre class="programlisting">    def test_add_overlap_exclude(self):
        schedule = schedules()
        schedule.add(self.distinct_include)
        self.assertRaises(schedule_error,
                          schedule.add,
                          self.overlap_exclude)

    def test_add_overlap_include(self):
        schedule = schedules()
        schedule.add(self.distinct_include)
        schedule.add(self.overlap_include)

    def test_add_distinct_exclude(self):
        schedule = schedules()
        schedule.add(self.distinct_include)
        schedule.add(self.distinct_exclude)

    def test_add_distinct_include(self):
        schedule = schedules()
        schedule.add(self.distinct_include)
        schedule.add(self.distinct_include)</pre></div><p>These four tests cover cases, where we add a non-overlapping object to a schedule. All of them are expected to accept the non-overlapping object, except the first. In that test, we've previously added an object that claims that it does indeed overlap, and furthermore it excludes anything it overlaps. That test shows that if either the object being added or an object already in the schedule believes there's an overlap, the schedule must treat it as an overlap.</p><div class="informalexample"><pre class="programlisting">    def test_add_over_overlap_exclude(self):
        schedule = schedules()
        schedule.add(self.overlap_exclude)
        self.assertRaises(schedule_error,
                          schedule.add,
                          self.overlap_include)</pre></div><p>In this test, we'll make sure that if an object already in the schedule overlaps a new object and claims exclusivity, then adding the new object will fail.</p><div class="informalexample"><pre class="programlisting">    def test_add_over_distinct_exclude(self):
        schedule = schedules()
        schedule.add(self.distinct_exclude)
        self.assertRaises(schedule_error,
                          schedule.add,
                          self.overlap_include)</pre></div><p>In this test, we'll make sure that even though the object already in the schedule doesn't think it overlaps with the new object, it excludes the new object because the new object thinks that there's an overlap.</p><div class="informalexample"><pre class="programlisting">    def test_add_over_overlap_include(self):
        schedule = schedules()
        schedule.add(self.overlap_include)
        schedule.add(self.overlap_include)

    def test_add_over_distinct_include(self):
        schedule = schedules()
        schedule.add(self.distinct_include)
        schedule.add(self.overlap_include)</pre></div><p>These tests make sure that inclusive objects don't somehow interfere with adding each other to a schedule.</p><div class="informalexample"><pre class="programlisting">class in_tests(MockerTestCase):
    def setUp(self):
        fake = self.mocker.mock()
        fake.overlaps(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        fake.excludes(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)

        self.fake = fake

        self.mocker.replay()

    def test_in_before_add(self):
        schedule = schedules()
        self.assertFalse(self.fake in schedule)

    def test_in_after_add(self):
        schedule = schedules()
        schedule.add(self.fake)
        self.assertTrue(self.fake in schedule)</pre></div><p>These two tests describe schedule behavior with respect to the <code class="literal">in</code> operator. Specifically, <code class="literal">in</code> should return <code class="literal">True</code> when the object in question is actually in the schedule.</p></div>
<div class="section" title="Time for action &#x2013; nailing down the specification with unit tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Time for action – nailing down the specification with unit tests</h1></div></div></div><a class="indexterm" id="id368"/><p>A specification—even a testable specification written in doctest—is still home to a lot of ambiguities that can be ironed out with good unit tests. Add that to the fact that the specification doesn't maintain separation between different tests, and you can see that it's time for your project to gain some unit tests.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Find some element of your project which is described in (or implied by) your specification</li><li class="listitem" style="list-style-type: disc">Write a unit test that describes the behavior of that element when given correct input</li><li class="listitem" style="list-style-type: disc">Write a unit test that describes the behavior of that element when given incorrect input</li><li class="listitem" style="list-style-type: disc">Write unit tests that describe the behavior of the element at the boundaries between correct and incorrect input</li><li class="listitem" style="list-style-type: disc">Go back to step 1 if you can find another untested part of your program.</li></ul></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec82"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>It doesn't take many bullet points to describe the procedure, but this is an important process. This is where you really take what was an ill-defined idea and turn it into a precise description of what you're going to do. </p><p>The end result can be quite lengthy, which shouldn't come as much of a surprise. After all, your goal at this stage is to completely define the behavior of your project; and even without bothering yourself with the details of how that behavior is implemented, that's a lot of information.</p></div></div>
<div class="section" title="Coding planner.data"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Coding planner.data</h1></div></div></div><a class="indexterm" id="id369"/><p>It's time to write some code, using the specification document and the unit tests as guides. Specifically, it's time to write the <code class="literal">planner.data</code> module, which contains <code class="literal">statuses</code>, <code class="literal">activities</code>, and <code class="literal">schedules</code>.</p><p>I made a directory called <code class="literal">planner</code>, and within that directory created a file called <code class="literal">__init__.py</code>. There's no need to put anything inside <code class="literal">__init__.py</code>, but the file itself needs to exist to tell Python that the <code class="literal">planner</code> directory is a package.</p><p>The following code goes in <code class="literal">planner/data.py</code>:</p><div class="informalexample"><pre class="programlisting">from datetime import timedelta

class task_error(Exception):
    pass

class schedule_error(Exception):
    pass

class _tasks:
    def __init__(self, name, begins, ends):
        if ends &lt; begins:
            raise task_error('The begin time must precede the end time')
        if ends - begins &lt; timedelta(minutes = 5):
            raise task_error('The minimum duration is 5 minutes')
<a class="indexterm" id="id370"/>
        self.name = name
        self.begins = begins
        self.ends = ends

    def excludes(self, other):
        raise NotImplemented('Abstract method. Use a child class.')

    def overlaps(self, other):
        if other.begins &lt; self.begins:
            return other.ends &gt; self.begins
        elif other.ends &gt; self.ends:
            return other.begins &lt; self.ends
        else:
            return True

    def __repr__(self):
        return ''.join(['&lt;', self.name,
                        ' ', self.begins.isoformat(),
                        ' ', self.ends.isoformat(),
                        '&gt;'])

class activities(_tasks):
    def excludes(self, other):
        return isinstance(other, activities)


class statuses(_tasks):
    def excludes(self, other):
        return False

class schedules:
    def __init__(self, name='schedule'):
        self.tasks = []
        self.name = name
    def add(self, task):
        for contained in self.tasks:
            if task.overlaps(contained):
                if task.exclude(contained) or contained.exclude(task):
                    raise schedule_error(task, containeed)

        self.tasks.append(task)

    def remove(self, task):
        try:
            self.tasks.remove(task)
        except ValueError:
            pass

    def __contains__(self, task):
        return task in self.tasks</pre></div><a class="indexterm" id="id371"/><p>Let's go over this section by section:</p><div class="informalexample"><pre class="programlisting">class _tasks:
    def __init__(self, name, begins, ends):
        if ends &lt; begins:
            raise task_error('The begin time must precede the end time')
        if ends - begins &lt; timedelta(minutes = 5):
            raise task_error('The minimum duration is 5 minutes')

        self.name = name
        self.begins = begins
        self.ends = ends

    def excludes(self, other):
        raise NotImplemented('Abstract method. Use a child class.')

    def overlaps(self, other):
        if other.begins &lt; self.begins:
            return other.ends &gt; self.begins
        elif other.ends &gt; self.ends:
            return other.begins &lt; self.ends
        else:
            return True

    def __repr__(self):
        return ''.join(['&lt;', self.name,
                        ' ', self.begins.isoformat(),
                        ' ', self.ends.isoformat(),
                        '&gt;'])</pre></div><a class="indexterm" id="id372"/><a class="indexterm" id="id373"/><p>The <code class="literal">_tasks</code> class here contains most of the behavior that is needed for both the <code class="literal">activities</code> and the <code class="literal">statuses</code> classes. Since so much of what they do is common to both, it makes sense to write the code once and reuse it. Only the <a class="indexterm" id="id374"/>
<code class="literal">excludes</code> method needs to be different in each of the subclasses.</p><div class="informalexample"><pre class="programlisting">class activities(_tasks):
    def excludes(self, other):
        return isinstance(other, activities)

class statuses(_tasks):
    def excludes(self, other):
        return False

class schedules:
    def __init__(self, name='schedule'):
        self.tasks = []
        self.name = name

    def add(self, task):
        for contained in self.tasks:
            if task.overlaps(contained):
                if task.exclude(contained) or contained.exclude(task):
                    raise schedule_error(task, containeed)

        self.tasks.append(task)

    def remove(self, task):
        try:
            self.tasks.remove(task)
        except ValueError:
            pass

    def __contains__(self, task):
        return task in self.tasks</pre></div><p>Here we have the implementations of the classes that our tests actually require to exist. The <code class="literal">activities</code> and <code class="literal">statuses</code> classes are very simple, by virtue of inheriting from <a class="indexterm" id="id375"/>
<code class="literal">_tasks</code>. The <code class="literal">schedules</code> class turns out to be pretty easy, too. But is it right? Our tests will tell us.<a class="indexterm" id="id376"/>
</p></div>
<div class="section" title="Using the tests to get the code right"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Using the tests to get the code right</h1></div></div></div><p>All right, so that code looks fairly good. Unfortunately, Nose tells us there are a few problems. Actually, Nose reports quite a large number of problems, but the first ones needing to be fixed are shown below:</p><div class="mediaobject"><img alt="Using the tests to get the code right" src="graphics/8846_07_01.jpg"/></div><p>The reason for focusing on those errors, when we have so many to choose from, is simple. A lot of the other errors seem to be derived from these. The unit tests also report problems with exclude, so we know that one isn't derived from some other error—remember that unit tests aren't influenced by each other, unlike the tests in our specification.</p></div>
<div class="section" title="Fixing the code"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Fixing the code</h1></div></div></div><a class="indexterm" id="id377"/><p>To fix the first error, add the following code to the <code class="literal">_tasks</code> class in <code class="literal">planner/data.py</code>:</p><div class="informalexample"><pre class="programlisting">
<a class="indexterm" id="id378"/>    def __eq__(self, other):
        return self.name == other.name and self.begins == other.begins and self.ends == other.ends

    def __ne__(self, other):
        return not self.__eq__(other)</pre></div><p>(Beware of the wrapped line in <code class="literal">__eq__</code>)</p><a class="indexterm" id="id379"/><p>As you can probably tell, that code overrides the equality comparison between two <code class="literal">_tasks</code>, declaring them to be equal if they have the same name, begin time and end time. That's the equality metric that's implicitly assumed by the test code.</p><p>The second error can be fixed by fixing the typographical errors in <code class="literal">schedules.add</code>:</p><div class="informalexample"><pre class="programlisting">    def add(self, task):
        for contained in self.tasks:
            if task.overlaps(contained):
                if task.excludes(contained) or contained.excludes(task):
                    raise schedule_error(task, containeed)

        self.tasks.append(task)</pre></div><p>In this case, we changed the incorrect method name <code class="literal">exclude</code> to the correct method name <code class="literal">excludes</code>. (Again, watch out for wrapped lines)</p><p>So now, I run Nose again and it breaks:</p><div class="mediaobject"><img alt="Fixing the code" src="graphics/8846_07_02.jpg"/></div><p>Fortunately, this is an easy fix: take out the extra 'e' in 'contained':</p><div class="informalexample"><pre class="programlisting">                    raise schedule_error(task, contained)</pre></div><p>For the skeptical reader, I'm compelled to admit that, yes, that typo really did slip by until the test caught it. Sometimes tests catch boring mistakes instead of dramatic problems, typos instead of logic errors. It doesn't really matter, because either way the test is helping you make your code more solid, more reliable, and better.</p><p>So now, when I run Nose it breaks:</p><div class="mediaobject"><img alt="Fixing the code" src="graphics/8846_07_03.jpg"/></div><p>Okay, fine, this is easy to fix too. The error is just formatted wrongly. Fix that by replacing the 'raise' in <code class="literal">schedules.add</code>:</p><div class="informalexample"><pre class="programlisting">           raise schedule_error('"%s" overlaps with "%s"' %
                                (task.name, contained.name))</pre></div><a class="indexterm" id="id380"/><p>This time when I run Nose, it tells me that my unit test is broken:</p><div class="mediaobject"><img alt="Fixing the code" src="graphics/8846_07_04.jpg"/></div><p>Specifically, it's telling me that my mockups of <code class="literal">activities</code> and <code class="literal">statuses</code> are missing the <code class="literal">name</code> attribute. This too is simply fixed by changing the <code class="literal">setUp</code> method of <code class="literal">add_tests</code> in <code class="literal">tests/test_schedules.py</code>:</p><div class="informalexample"><pre class="programlisting">    def setUp(self):

        overlap_exclude = self.mocker.mock()
        overlap_exclude.overlaps(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        overlap_exclude.excludes(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        <span class="strong"><strong>overlap_exclude.name</strong></span>
<span class="strong"><strong>        self.mocker.result('overlap_exclude')</strong></span>
<span class="strong"><strong>        self.mocker.count(0, None)</strong></span>

        overlap_include = self.mocker.mock()
        overlap_include.overlaps(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        overlap_include.excludes(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)
        <span class="strong"><strong>overlap_include.name</strong></span>
<span class="strong"><strong>        self.mocker.result('overlap_include')</strong></span>
<span class="strong"><strong>        self.mocker.count(0, None)</strong></span>

        distinct_exclude = self.mocker.mock()
        distinct_exclude.overlaps(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)
        distinct_exclude.excludes(ANY)
        self.mocker.result(True)
        self.mocker.count(0, None)
        <span class="strong"><strong>distinct_exclude.name</strong></span>
        <span class="strong"><strong>        self.mocker.result('distinct_exclude')</strong></span>
<span class="strong"><strong>        self.mocker.count(0, None)</strong></span>

        distinct_include = self.mocker.mock()
        distinct_include.overlaps(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)
        distinct_include.excludes(ANY)
        self.mocker.result(False)
        self.mocker.count(0, None)
        <span class="strong"><strong>distinct_include.name</strong></span>
<span class="strong"><strong>        self.mocker.result('distinct_include')</strong></span>
<span class="strong"><strong>        self.mocker.count(0, None)</strong></span>

   <a class="indexterm" id="id381"/>     self.overlap_exclude = overlap_exclude
        self.overlap_include = overlap_include
        self.distinct_exclude = distinct_exclude
        self.distinct_include = distinct_include

        self.mocker.replay()</pre></div><p>Having fixed that, Nose still reports errors, but all of them have to do with persistence. Those errors aren't surprising, because there's no persistence implementation yet.</p></div>
<div class="section" title="Time for action &#x2013; writing and debugging code"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Time for action – writing and debugging code</h1></div></div></div><p>The <a class="indexterm" id="id382"/>basic procedure (as we've discussed before), is to write some code and run the tests to find problems with the code, and repeat. When you come across an error that isn't covered by an existing test, you write a new test and continue the process.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write code that ought to satisfy at least some of your tests</li><li class="listitem">Run <a class="indexterm" id="id383"/>your tests. If you used it when we talked about it in previous chapters, you should be able to run everything simply by executing:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>       $ nosetests</strong></span>
</pre></div></li><li class="listitem">If <a class="indexterm" id="id384"/>there are errors in the code you've already written, use the test output to help you locate and identity them. Once you understand the bugs, try to fix them and then go back to step 2.</li><li class="listitem">Once you've fixed all the errors in the code you've written, and if your project isn't complete, choose some new tests to concentrate on and go back to step 1.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec83"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>Enough iterations on this procedure leads you to having a complete and tested project. Of course, the real task is more difficult than simply saying "it will work," but in the end, it will work. You will produce a codebase that you can be confident in. It will also be an easier process than it would have been without the tests.</p><p>Your project may be done, but there's still more to do on the personal scheduler. At this stage of the chapter, I haven't finished going through the writing and debugging process. It's time to do that.</p></div></div>
<div class="section" title="Writing persistence tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Writing persistence tests</h1></div></div></div><a class="indexterm" id="id385"/><p>Since I don't have any actual unit tests for the persistence code yet, I'll start off by making some. In the process, I have to figure how persistence will actually work. The following code goes in <code class="literal">tests/test_persistence.py</code>:</p><div class="informalexample"><pre class="programlisting">from unittest import TestCase
from mocker import MockerTestCase
from planner.persistence import file

class test_file(TestCase):
    def test_basic(self):
        storage = file(':memory:')
        storage.store_object('tag1', ('some object',))
        self.assertEqual(tuple(storage.load_objects('tag1')),
                         (('some object',),))


    def test_multiple_tags(self):
        storage = file(':memory:')

        storage.store_object('tag1', 'A')
        storage.store_object('tag2', 'B')
        storage.store_object('tag1', 'C')
        storage.store_object('tag1', 'D')
        storage.store_object('tag3', 'E')
        storage.store_object('tag3', 'F')

        self.assertEqual(set(storage.load_objects('tag1')),
                         set(['A', 'C', 'D']))

        self.assertEqual(set(storage.load_objects('tag2')),
                         set(['B']))

        self.assertEqual(set(storage.load_objects('tag3')),
                         set(['E', 'F']))</pre></div><p>Looking at each of the important sections of the test code, we see the following:</p><div class="informalexample"><pre class="programlisting">    def test_basic(self):
        storage = file(':memory:')
        storage.store_object('tag1', ('some object',))
        self.assertEqual(tuple(storage.load_objects('tag1')),
                         (('some object',),))</pre></div><p>The <a class="indexterm" id="id386"/>
<a class="indexterm" id="id387"/>
<code class="literal">test_basic</code> test creates a <code class="literal">storage</code>, stores a single object under the name <code class="literal">tag1</code>, and then loads that object back from storage and checks that it is equal to the original object.</p><div class="informalexample"><pre class="programlisting">    def test_multiple_tags(self):
        storage = file(':memory:')

        storage.store_object('tag1', 'A')
        storage.store_object('tag2', 'B')
        storage.store_object('tag1', 'C')
        storage.store_object('tag1', 'D')
        storage.store_object('tag3', 'E')
        storage.store_object('tag3', 'F')

        self.assertEqual(set(storage.load_objects('tag1')),
                         set(['A', 'C', 'D']))

        self.assertEqual(set(storage.load_objects('tag2')),
                         set(['B']))

        self.assertEqual(set(storage.load_objects('tag3')),
                         set(['E', 'F']))</pre></div><p>The <a class="indexterm" id="id388"/>
<code class="literal">test_multiple_tags</code> test creates a storage, and then stores multiple objects in it, some with duplicate tags. It then checks that the storage keeps all of the objects with a given tag, and returns all of them on request.</p><p>In <a class="indexterm" id="id389"/>other words, a persistence file is a multimap from string keys to object values.</p></div>
<div class="section" title="Writing persistence code"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Writing persistence code</h1></div></div></div><p>Now <a class="indexterm" id="id390"/>that there are at least basic unit tests covering the persistence mechanism, it's time to write the persistence code itself. The following goes in  <code class="literal">planner/persistence.py</code>:</p><div class="informalexample"><pre class="programlisting">import sqlite3
from cPickle import loads, dumps

class file:
    def __init__(self, path):
        self.connection = sqlite3.connect(path)

        try:
            self.connection.execute("""
                create table objects (tag, pickle)
            """)
        except sqlite3.OperationalError:
            pass

    def store_object(self, tag, object):
        self.connection.execute('insert into objects values (?, ?)',
                                (tag, dumps(object)))

    def load_objects(self, tag):
        cursor = self.connection.execute("""
                     select pickle from objects where tag like ?
                 """, (tag,))
        return [loads(row[0]) for row in cursor]</pre></div><p>The <a class="indexterm" id="id391"/>
<code class="literal">store_object</code> method runs a short SQL statement to store the object into a database field. The object serialization is handled by the <code class="literal">dumps</code> function from the <code class="literal">cPickle</code> module.</p><p>The <a class="indexterm" id="id392"/>
<code class="literal">load_object</code> method uses SQL to query the database for the serialized version of every object stored under a given tag, and then uses <code class="literal">cPickle.loads</code> to transform those serializations into real objects for it to return.</p><p>Now I run Nose to find out what's broken:</p><div class="mediaobject"><img alt="Writing persistence code" src="graphics/8846_07_05.jpg"/></div><p>I forgot that <code class="literal">sqlite</code> returns text data as unicode. Pickle is understandably unwilling to work with a Unicode string: it expects a byte string, and the correct way to interpret Unicode as a byte string is ambiguous. This can be solved by telling <code class="literal">sqlite</code> to store the pickled object as a BLOB (Binary Large Object). Modify the <code class="literal">store_object</code> and <a class="indexterm" id="id393"/>
<code class="literal">load_objects</code> methods of <code class="literal">file</code> in <code class="literal">planner/persistence.py</code>:</p><div class="informalexample"><pre class="programlisting">    def store_object(self, tag, object):
        self.connection.execute('insert into objects values (?, ?)',
                               <span class="strong"><strong>(tag, sqlite3.Binary(dumps(object))))</strong></span>

    def load_objects(self, tag):
        cursor = self.connection.execute("""
                     select pickle from objects where tag like ?
                 """, (tag,))
        <span class="strong"><strong>return [loads(str(row[0])) for row in cursor]</strong></span>
</pre></div><p>Now Nose is saying that the schedules class doesn't have <code class="literal">store</code> and <code class="literal">load</code> methods, which is true. Furthermore, there aren't any unit tests that check those methods... the only error is coming from the specification doctest. Time to write some more unit tests in <code class="literal">tests/test_schedules.py</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from mocker import MockerTestCase, ANY, IN</strong></span>
…
class store_load_tests(MockerTestCase):
    def setUp(self):
        fake_tasks = []
        for i in range(50):
            fake_task = self.mocker.mock()
            fake_task.overlaps(ANY)
            self.mocker.result(False)
            self.mocker.count(0, None)
            fake_task.name
            self.mocker.result('fake %d' % i)
            self.mocker.count(0, None)
            fake_tasks.append(fake_task)

        self.tasks = fake_tasks

    def test_store(self):
        fake_file = self.mocker.mock()

        fake_file.store_object('test_schedule', IN(self.tasks))
        self.mocker.count(len(self.tasks))

        self.mocker.replay()

        schedule = schedules('test_schedule')
        for task in self.tasks:
            schedule.add(task)

        schedule.store(fake_file)

    def test_load(self):
        fake_file = self.mocker.mock()

        fake_file.load_objects('test_schedule')
        self.mocker.result(self.tasks)
        self.mocker.count(1)

        self.mocker.replay()

        schedule = schedules.load(fake_file, 'test_schedule')

        self.assertEqual(set(schedule.tasks),
                         set(self.tasks))</pre></div><p>Now <a class="indexterm" id="id394"/>that I have some tests to check against, it's time to write the <code class="literal">store</code> and <code class="literal">load</code> methods of the <code class="literal">schedules</code> class in <code class="literal">planner/data.py</code>:</p><div class="informalexample"><pre class="programlisting">    def store(self, storage):
        for task in self.tasks:
            storage.store_object(self.name, task)

    @staticmethod
    def load(storage, name = 'schedule'):
        value = schedules(name)

        for task in storage.load_objects(name):
            value.add(task)

        return value</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>The <code class="literal">@</code>
<a class="indexterm" id="id395"/>
<code class="literal">staticmethod</code> notation means that you can call <code class="literal">load</code> without first creating an instance of <code class="literal">schedules</code>. Notice that the <code class="literal">load</code> method does not receive a <code class="literal">self</code> parameter.</p><p>The <code class="literal">@</code>
<a class="indexterm" id="id396"/> syntax for function decorators was introduced in Python 2.4. In earlier versions back to Python 2.2, you could instead write <code class="literal">load = staticmethod(load)</code> after the method definition, which means the same thing. Before Python 2.2, there was no <a class="indexterm" id="id397"/>
<code class="literal">staticmethod</code> function: the easiest way to do static "methods" was to write one as a standalone function in the same module.</p></div></div><p>This <a class="indexterm" id="id398"/>new bunch of tests and code allows us to save and restore schedules from files, and clears up most of the remaining test failures. The <code class="literal">planner</code> package is nearly finished!</p></div>
<div class="section" title="Finishing up"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Finishing up</h1></div></div></div><p>Now, Nose only reports one failed test, the check to see whether the original <code class="literal">schedules</code> instance and the one loaded from the file are equal. The problem here is that, once again, there's a need to redefine what it means to be equal.</p><p>That can be fixed by adding the following to the definition of <code class="literal">schedules</code> in <code class="literal">planner/data.py</code>:</p><div class="informalexample"><pre class="programlisting">    def __eq__(self, other):
        if len(self.tasks) != len(other.tasks):
            return False

        left_tasks = list(self.tasks)
        left_tasks.sort(key = (lambda task: task.begins))
        right_tasks = list(other.tasks)
        right_tasks.sort(key = (lambda task: task.begins))
        return tuple(left_tasks) == tuple(right_tasks)

    def __ne__(self, other):
        return not self.__eq__(other)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>The <code class="literal">key</code> parameter of <code class="literal">sort</code> was added in Python 2.4. Prior to that version, doing such a <code class="literal">sort</code> would have looked like <code class="literal">left_tasks.sort(cmp = (lambda t1, t2: cmp(t1.begins, t2.begins)))</code>.</p></div></div><p>These methods define equality between schedules to be when they contain exactly the same tasks, and define inequality to be whenever they aren't equal (It may sound silly to have to define inequality that way, but it turns out that there actually are some situations where you'd want to define it differently).</p><p>Now, the tests all pass. There's something worth paying attention to though, in the way that they pass. Specifically, a couple of them are very slow. A little investigation reveals that the slow tests are the ones that deal with schedules that contain a larger number of tasks. That reveals something very important: the <code class="literal">schedules</code> implementation is now conformant with the tests and specifications, but it stores and organizes data in a naïve way, and so it doesn't scale up well.</p><p>Now that there is a working implementation, well covered by unit tests, the time is ripe for optimization.</p><div class="section" title="Pop quiz – test-driven development"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec84"/>Pop quiz – test-driven development</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">I didn't follow unit testing discipline when I wrote my testable specification. What did I have to do because of that, which I wouldn't have had to do otherwise? Was it wrong to choose that path?</li><li class="listitem">Is it desirable to minimize the number of times you run your tests?</li><li class="listitem">If you start writing code before you write any tests, what opportunities have you lost?</li></ol></div></div><div class="section" title="Have a go hero"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec85"/>Have a go hero</h2></div></div></div><p>You worked through your own project, and we worked through a project together. Now it's time to try something completely on your own. I'll give you a little help coming up with a goal, but from there on out, it's your time to shine.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><a class="indexterm" id="id399"/><p>A <code class="literal">Skip list</code> is another dictionary-like data structure. You can find quite a bit of information about them on Wikipedia at<a class="ulink" href="http:// http://en.wikipedia.org/wiki/Skip_list"> http://en.wikipedia.org/wiki/Skip_list</a>. Using that information (and any other references you can find, if you feel like it) and the test-driven process, write your own skip list module.<a class="indexterm" id="id400"/>
</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Summary</h1></div></div></div><p>In this chapter, we looked at how to apply the skills covered in earlier parts of this book. We did this by stepping through a recording of your humble author's actual process in writing a package. At the same time, you had the chance to work through your own project, making your own decisions, and designing your own tests. You've taken the lead in a test-driven project, and you should be able to do it again whenever you want.</p><p>Now that we've covered the heart of Python testing, we're ready to talk about testing web-based user interfaces with Python and Twill—which is the topic of the next chapter.</p></div></body></html>