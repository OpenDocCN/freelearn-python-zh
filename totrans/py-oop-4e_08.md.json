["```py\n>>> len([1, 2, 3, 4])\n4 \n```", "```py\n>>> class CustomSequence:\n...     def __init__(self, args):\n...         self._list = args\n...     def __len__(self):\n...         return 5\n...     def __getitem__(self, index):\n...         return f\"x{index}\"\n>>> class FunkyBackwards(list):\n...     def __reversed__(self):\n...         return \"BACKWARDS!\" \n```", "```py\n>>> generic = [1, 2, 3, 4, 5]\n>>> custom = CustomSequence([6, 7, 8, 9, 10])\n>>> funkadelic = FunkyBackwards([11, 12, 13, 14, 15])\n>>> for sequence in generic, custom, funkadelic:\n...     print(f\"{sequence.__class__.__name__}: \", end=\"\")\n...     for item in reversed(sequence):\n...         print(f\"{item}, \", end=\"\")\n...     print()\nlist: 5, 4, 3, 2, 1, \nCustomSequence: x4, x3, x2, x1, x0, \nFunkyBackwards: B, A, C, K, W, A, R, D, S, !, \n```", "```py\n>>> from pathlib import Path\n>>> with Path(\"docs/sample_data.md\").open() as source:\n...     for index, line in enumerate(source, start=1):\n...         print(f\"{index:3d}: {line.rstrip()}\") \n```", "```py\n1: # Python 3 Object-Oriented Programming\n2: \n3: Chapter 8\\. The Intersection of Object-Oriented and Functional Programming\n4: \n5: Some sample data to show how the `enumerate()` function works. \n```", "```py\n>>> def no_params():\n...     return \"Hello, world!\" \n```", "```py\n>>> no_params()\n'Hello, world!' \n```", "```py\n>>> def mandatory_params(x, y, z): \n...     return f\"{x=}, {y=}, {z=}\" \n```", "```py\n>>> a_variable = 42\n>>> mandatory_params(\"a string\", a_variable, True) \n```", "```py\n>>> from typing import Any\n>>> def mandatory_params(x: Any, y: Any, z: Any) -> str: \n...     return f\"{x=}, {y=}, {z=}\" \n```", "```py\ndef latitude_dms(\n    deg: float, min: float, sec: float = 0.0, dir: Optional[str] = None\n) -> str:\n    if dir is None:\n        dir = \"N\"\n    return f\"{deg:02.0f}° {min+sec/60:05.3f}{dir}\" \n```", "```py\n>>> latitude_dms(36, 51, 2.9, \"N\")\n'36° 51.048N' \n```", "```py\n>>> latitude_dms(38, 58, dir=\"N\")\n'38° 58.000N' \n```", "```py\n>>> latitude_dms(38, 19, dir=\"N\", sec=7)\n'38° 19.117N' \n```", "```py\ndef kw_only(\n    x: Any, y: str = \"defaultkw\", *, a: bool, b: str = \"only\"\n) -> str:\n    return f\"{x=}, {y=}, {a=}, {b=}\" \n```", "```py\n>>> kw_only('x')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: kw_only() missing 1 required keyword-only argument: 'a' \n```", "```py\n>>> kw_only('x', 'y', 'a')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: kw_only() takes from 1 to 2 positional arguments but 3 were given \n```", "```py\n>>> kw_only('x', a='a', b='b')\n\"x='x', y='defaultkw', a='a', b='b'\" \n```", "```py\ndef pos_only(x: Any, y: str, /, z: Optional[Any] = None) -> str:\n    return f\"{x=}, {y=}, {z=}\" \n```", "```py\n>>> pos_only(x=2, y=\"three\")\nTraceback (most recent call last):\n  ...\n  File \"<doctest hint_examples.__test__.test_pos_only[0]>\", line 1, in <module>\n    pos_only(x=2, y=\"three\")\nTypeError: pos_only() got some positional-only arguments passed as keyword arguments: 'x, y'\n>>> pos_only(2, \"three\")\n\"x=2, y='three', z=None\"\n>>> pos_only(2, \"three\", 3.14159) \n\"x=2, y='three', z=3.14159\" \n```", "```py\nnumber = 5\ndef funky_function(x: int = number) -> str:\n    return f\"{x=}, {number=}\" \n```", "```py\n>>> funky_function(42)\n'x=42, number=5'\n>>> number = 7\n>>> funky_function()\n'x=5, number=5' \n```", "```py\ndef better_function(x: Optional[int] = None) -> str:\n    if x is None:\n        x = number\n    return f\"better: {x=}, {number=}\" \n```", "```py\ndef better_function_2(x: Optional[int] = None) -> str:\n    x = number if x is None else x\n    return f\"better: {x=}, {number=}\" \n```", "```py\nfrom typing import List\ndef bad_default(tag: str, history: list[str] = []) -> list[str]:\n    \"\"\" A Very Bad Design (VBD™).\"\"\"\n    history.append(tag)\n    return history \n```", "```py\n>>> h = bad_default(\"tag1\")\n>>> h = bad_default(\"tag2\", h)\n>>> h\n['tag1', 'tag2']\n>>> h2 = bad_default(\"tag21\")\n>>> h2 = bad_default(\"tag22\", h2)\n>>> h2\n['tag1', 'tag2', 'tag21', 'tag22'] \n```", "```py\n>>> h\n['tag1', 'tag2', 'tag21', 'tag22']\n>>> h is h2\nTrue \n```", "```py\ndef good_default(\n        tag: str, history: Optional[list[str]] = None\n) -> list[str]:\n    history = [] if history is None else history\n    history.append(tag)\n    return history \n```", "```py\nfrom urllib.parse import urlparse\nfrom pathlib import Path\ndef get_pages(*links: str) -> None:\n    for link in links:\n        url = urlparse(link)\n        name = \"index.html\" if url.path in (\"\", \"/\") else url.path\n        target = Path(url.netloc.replace(\".\", \"_\")) / name\n        print(f\"Create {target} from {link!r}\")\n        # etc. \n```", "```py\n>>> get_pages()\n\n>>> get_pages('https://www.archlinux.org') \nCreate www_archlinux_org/index.html from 'https://www.archlinux.org'\n>>> get_pages('https://www.archlinux.org', \n...        'https://dusty.phillips.codes',\n...        'https://itmaybeahack.com'\n... ) \nCreate www_archlinux_org/index.html from 'https://www.archlinux.org'\nCreate dusty_phillips_codes/index.html from 'https://dusty.phillips.codes'\nCreate itmaybeahack_com/index.html from 'https://itmaybeahack.com' \n```", "```py\nfrom __future__ import annotations\nfrom typing import Dict, Any\nclass Options(Dict[str, Any]):\n    default_options: dict[str, Any] = {\n        \"port\": 21,\n        \"host\": \"localhost\",\n        \"username\": None,\n        \"password\": None,\n        \"debug\": False,\n    }\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(self.default_options)\n        self.update(kwargs) \n```", "```py\n>>> options = Options(username=\"dusty\", password=\"Hunter2\",\n...     debug=True)\n>>> options['debug']\nTrue\n>>> options['port']\n21\n>>> options['username']\n'dusty' \n```", "```py\nfrom __future__ import annotations\nimport contextlib\nimport os\nimport subprocess\nimport sys\nfrom typing import TextIO\nfrom pathlib import Path\ndef doctest_everything(\n        output: TextIO,\n        *directories: Path,\n        verbose: bool = False,\n        **stems: str\n) -> None:\n    def log(*args: Any, **kwargs: Any) -> None:\n        if verbose:\n            print(*args, **kwargs)\n    with contextlib.redirect_stdout(output):\n        for directory in directories:\n            log(f\"Searching {directory}\")\n            for path in directory.glob(\"**/*.md\"):\n                if any(\n                        parent.stem == \".tox\"\n                        for parent in path.parents\n                ):\n                    continue\n                log(\n                    f\"File {path.relative_to(directory)}, \"\n                    f\"{path.stem=}\"\n                )\n                if stems.get(path.stem, \"\").upper() == \"SKIP\":\n                    log(\"Skipped\")\n                    continue\n                options = []\n                if stems.get(path.stem, \"\").upper() == \"ELLIPSIS\":\n                    options += [\"ELLIPSIS\"]\n                search_path = directory / \"src\"\n                print(\n                    f\"cd '{Path.cwd()}'; \"\n                    f\"PYTHONPATH='{search_path}' doctest '{path}' -v\"\n                )\n                option_args = (\n                    [\"-o\", \",\".join(options)] if options else []\n                )\n                subprocess.run(\n                    [\"python3\", \"-m\", \"doctest\", \"-v\"] \n                        + option_args + [str(path)],\n                    cwd=directory,\n                    env={\"PYTHONPATH\": str(search_path)},\n                ) \n```", "```py\ndoctest_everything(\n    sys.stdout,\n    Path.cwd() / \"ch_02\",\n    Path.cwd() / \"ch_03\",\n) \n```", "```py\ndoctest_log = Path(\"doctest.log\")\nwith doctest_log.open('w') as log:\n    doctest_everything(\n        log,\n        Path.cwd() / \"ch_04\",\n        Path.cwd() / \"ch_05\",\n        verbose=True\n    ) \n```", "```py\ndoctest_everything(\n    sys.stdout,\n    Path.cwd() / \"ch_02\",\n    Path.cwd() / \"ch_03\",\n    examples=\"ELLIPSIS\",\n    examples_38=\"SKIP\",\n    case_study_2=\"SKIP\",\n    case_study_3=\"SKIP\",\n) \n```", "```py\n>>> def show_args(arg1, arg2, arg3=\"THREE\"): \n...     return f\"{arg1=}, {arg2=}, {arg3=}\" \n```", "```py\n>>> some_args = range(3) \n>>> show_args(*some_args)\n'arg1=0, arg2=1, arg3=2' \n```", "```py\n>>> more_args = { \n...        \"arg1\": \"ONE\", \n...        \"arg2\": \"TWO\"}\n>>> show_args(**more_args)\n\"arg1='ONE', arg2='TWO', arg3='THREE'\" \n```", "```py\ndef __init__(self, **kwargs: Any) -> None:\n    super().__init__(self.default_options)\n    self.update(kwargs) \n```", "```py\ndef __init__(self, **kwargs: Any) -> None:\n    super().__init__({**self.default_options, **kwargs}) \n```", "```py\n>>> x = {'a': 1, 'b': 2}\n>>> y = {'b': 11, 'c': 3}\n>>> z = {**x, **y}\n>>> z\n{'a': 1, 'b': 11, 'c': 3} \n```", "```py\n>>> def fizz(x: int) -> bool:\n...     return x % 3 == 0\n>>> def buzz(x: int) -> bool:\n...     return x % 5 == 0\n>>> def name_or_number(\n...         number: int, *tests: Callable[[int], bool]) -> None:\n...     for t in tests:\n...         if t(number):\n...             return t.__name__\n...     return str(number)\n>>> for i in range(1, 11):\n...     print(name_or_number(i, fizz, buzz)) \n```", "```py\n>>> name_or_number(1, fizz)\n'1'\n>>> name_or_number(3, fizz)\n'fizz'\n>>> name_or_number(5, fizz)\n'5' \n```", "```py\n>>> name_or_number(5, fizz, buzz)\n'buzz' \n```", "```py\n>>> for i in range(1, 11):\n...     print(name_or_number(i, fizz, buzz))\n1\n2\nfizz\n4\nbuzz\nfizz\n7\n8\nfizz\nbuzz \n```", "```py\nfrom __future__ import annotations\nimport heapq\nimport time\nfrom typing import Callable, Any, List, Optional\nfrom dataclasses import dataclass, field\nCallback = Callable[[int], None]\n@dataclass(frozen=True, order=True)\nclass Task:\n    scheduled: int\n    callback: Callback = field(compare=False)\n    delay: int = field(default=0, compare=False)\n    limit: int = field(default=1, compare=False)\n    def repeat(self, current_time: int) -> Optional[\"Task\"]:\n        if self.delay > 0 and self.limit > 2:\n            return Task(\n                current_time + self.delay,\n                cast(Callback, self.callback),  # type: ignore [misc]\n                self.delay,\n                self.limit - 1,\n            )\n        elif self.delay > 0 and self.limit == 2:\n            return Task(\n                current_time + self.delay,\n                cast(Callback, self.callback),  # type: ignore [misc]\n            )\n        else:\n            return None \n```", "```py\nclass Scheduler:\n    def __init__(self) -> None:\n        self.tasks: List[Task] = []\n    def enter(\n        self,\n        after: int,\n        task: Callback,\n        delay: int = 0,\n        limit: int = 1,\n    ) -> None:\n        new_task = Task(after, task, delay, limit)\n        heapq.heappush(self.tasks, new_task)\n    def run(self) -> None:\n        current_time = 0\n        while self.tasks:\n            next_task = heapq.heappop(self.tasks)\n            if (delay := next_task.scheduled - current_time) > 0:\n               time.sleep(next_task.scheduled - current_time)\n            current_time = next_task.scheduled\n            next_task.callback(current_time)  # type: ignore [misc]\n            if again := next_task.repeat(current_time):\n                heapq.heappush(self.tasks, again) \n```", "```py\nimport datetime\ndef format_time(message: str) -> None:\n    now = datetime.datetime.now()\n    print(f\"{now:%I:%M:%S}: {message}\")\ndef one(timer: float) -> None:\n    format_time(\"Called One\")\ndef two(timer: float) -> None:\n    format_time(\"Called Two\")\ndef three(timer: float) -> None:\n    format_time(\"Called Three\")\nclass Repeater:\n    def __init__(self) -> None:\n        self.count = 0\n    def four(self, timer: float) -> None:\n        self.count += 1\n        format_time(f\"Called Four: {self.count}\") \n```", "```py\ns = Scheduler()\ns.enter(1, one)\ns.enter(2, one)\ns.enter(2, two)\ns.enter(4, two)\ns.enter(3, three)\ns.enter(6, three)\nrepeater = Repeater()\ns.enter(5, repeater.four, delay=1, limit=5)\ns.run() \n```", "```py\n01:44:35: Called One\n01:44:36: Called Two\n01:44:36: Called One\n01:44:37: Called Three\n01:44:38: Called Two\n01:44:39: Called Four: 1\n01:44:40: Called Three\n01:44:40: Called Four: 2\n01:44:41: Called Four: 3\n01:44:42: Called Four: 4\n01:44:43: Called Four: 5 \n```", "```py\n>>> class A:\n...     def show_something(self):\n...         print(\"My class is A\")\n>>> a_object = A()\n>>> a_object.show_something()\nMy class is A \n```", "```py\n>>> def patched_show_something():\n...     print(\"My class is NOT A\")\n>>> a_object.show_something = patched_show_something\n>>> a_object.show_something()\nMy class is NOT A \n```", "```py\n>>> b_object = A()\n>>> b_object.show_something()\nMy class is A \n```", "```py\nclass Repeater_2:\n    def __init__(self) -> None:\n        self.count = 0\n    def __call__(self, timer: float) -> None:\n        self.count += 1\n        format_time(f\"Called Four: {self.count}\") \n```", "```py\nclass Repeater_2:\n    def __init__(self) -> None:\n        self.count = 0\n    def __call__(self, timer: float) -> None:\n        self.count += 1\n        format_time(f\"Called Four: {self.count}\")\nrpt = Repeater_2() \n```", "```py\n>>> rpt(1)\n04:50:32: Called Four: 1\n>>> rpt(2)\n04:50:35: Called Four: 2\n>>> rpt(3)\n04:50:39: Called Four: 3 \n```", "```py\ns2 = Scheduler()\ns2.enter(5, Repeater_2(), delay=1, limit=5)\ns2.run() \n```", "```py\n>>> contents = \"Some file contents\\n\"\n>>> file = open(\"filename.txt\", \"w\")\n>>> file.write(contents)\n>>> file.close() \n```", "```py\nwith open(\"big_number.txt\") as input:\n    for line in input:\n        print(line) \n```", "```py\nresults = str(2**2048)\nwith open(\"big_number.txt\", \"w\") as output:\n    output.write(\"# A big number\\n\")\n    output.writelines(\n        [\n            f\"{len(results)}\\n\",\n            f\"{results}\\n\"\n        ]\n    ) \n```", "```py\n>>> source_path = Path(\"requirements.txt\")\n>>> with source_path.open() as source_file:\n...     for line in source_file:\n...         print(line, end='') \n```", "```py\n>>> class StringJoiner(list): \n...     def __enter__(self): \n...         return self \n...     def __exit__(self, exc_type, exc_val, exc_tb): \n...         self.result = \"\".join(self) \n```", "```py\nfrom typing import List, Optional, Type, Literal\nfrom types import TracebackType\nclass StringJoiner(List[str]):\n    def __enter__(self) -> \"StringJoiner\":\n        return self\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> Literal[False]:\n        self.result = \"\".join(self)\n        return False \n```", "```py\nreturn exc_type == StopIteration \n```", "```py\n>>> with StringJoiner(\"Hello\") as sj:\n...     sj.append(\", \")\n...     sj.extend(\"world\")\n...     sj.append(\"!\")\n>>> sj.result\n'Hello, world!' \n```", "```py\n>>> with StringJoiner(\"Partial\") as sj:\n...     sj.append(\" \")\n...     sj.extend(\"Results\")\n...     sj.append(str(2 / 0))\n...     sj.extend(\"Even If There's an Exception\")\nTraceback (most recent call last):\n  ...\n  File \"<doctest examples.md[60]>\", line 3, in <module>\n    sj.append(str(2 / 0))\nZeroDivisionError: division by zero\n>>> sj.result\n'Partial Results' \n```", "```py\nclass StringJoiner2(List[str]):\n    def __init__(self, *args: str) -> None:\n        super().__init__(*args)\n        self.result = \"\".join(self) \n```", "```py\nfrom contextlib import contextmanager\nfrom typing import List, Any, Iterator\n@contextmanager\ndef joiner(*args: Any) -> Iterator[StringJoiner2]:\n    string_list = StringJoiner2(*args)\n    try:\n        yield string_list\n    finally:\n        string_list.result = \"\".join(string_list) \n```", "```py\ndef training(s: Sample, i: int) -> bool:\n    pass\ntraining_samples = [\n    TrainingKnownSample(s) \n    for i, s in enumerate(samples) \n    if training(s, i)]\ntest_samples = [\n    TestingKnownSample(s) \n    for i, s in enumerate(samples) \n    if not training(s, i)] \n```", "```py\ntest_samples = list(\n    TestingKnownSample(s) \n    for i, s in enumerate(samples) \n    if not training(s, i)) \n```", "```py\ndef training_80(s: KnownSample, i: int) -> bool:\n    return i % 5 != 0\ndef training_75(s: KnownSample, i: int) -> bool:\n    return i % 4 != 0\ndef training_67(s: KnownSample, i: int) -> bool:\n    return i % 3 != 0 \n```", "```py\nTrainingList = List[TrainingKnownSample]\nTestingList = List[TestingKnownSample]\ndef partition(\n    samples: Iterable[KnownSample], \n    rule: Callable[[KnownSample, int], bool]\n) -> Tuple[TrainingList, TestingList]:\n    training_samples = [\n        TrainingKnownSample(s) \n        for i, s in enumerate(samples) if rule(s, i)\n    ]\n    test_samples = [\n        TestingKnownSample(s) \n        for i, s in enumerate(samples) if not rule(s, i)\n    ]\n    return training_samples, test_samples \n```", "```py\ndef partition_1(\n        samples: Iterable[KnownSample], \n        rule: Callable[[KnownSample, int], bool]\n) -> Tuple[TrainingList, TestingList]:\n\n    training: TrainingList = []\n    testing: TestingList = []\n    for i, s in enumerate(samples):\n        training_use = rule(s, i)\n        if training_use:\n            training.append(TrainingKnownSample(s))\n        else:\n            testing.append(TestingKnownSample(s))\n    return training, testing \n```", "```py\nfrom collections import defaultdict, Counter\ndef partition_1p(\n    samples: Iterable[KnownSample], \n    rule: Callable[[KnownSample, int], bool]\n) -> tuple[TrainingList, TestingList]:\n    pools: defaultdict[bool, list[KnownSample]] = defaultdict(list)\n    partition = ((rule(s, i), s) for i, s in enumerate(samples))\n    for usage_pool, sample in partition:\n        pools[usage_pool].append(sample)\n    training = [TrainingKnownSample(s) for s in pools[True]]\n    testing = [TestingKnownSample(s) for s in pools[False]]\n    return training, testing \n```"]