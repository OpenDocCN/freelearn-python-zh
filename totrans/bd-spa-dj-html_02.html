<html><head></head><body>
		<div id="_idContainer024">
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Chapter 1: Setting up the Virtual Environment</h1>
			<p>A good programmer is not afraid of technology because their confidence doesn’t lie in the programming language, but in their own skills and experience. Tools only make them more productive. We can’t build even the simplest website in an acceptable amount of time without the right software. Building websites with Python is possible on any modern operating system, regardless of the hardware behind it. The core team that maintains this fantastic language already takes care of some of the more tedious tasks, such as compiling it and optimizing it for the processor you’re using. </p>
			<p>However, building a web application in Python, even if we only respond with plain text, requires a great deal of knowledge, including of servers and web applications as well as the WSGI or ASGI interface. We need to abstract that complexity to respond to requests, environments, asynchrony, WebSocket, database connections, and the other elements that define a current web application. That’s why we’re going to set up a desktop with everything you need to be a productive modern Django developer. We will build different real-time applications using the technology offered by Channels, a Django extension (developed by the same Django team), which includes a WebSocket server and WebSocket integrations. The architecture of the applications will differ from how server-side rendering works. The communication path between the server and the client will be bidirectional, allowing us to use it to receive or send events and/or HTML. My intention is that upon finishing the chapter, your focus will be on the code and not on complex configurations that may distract you. To achieve this, we will make use of Docker, the famous container manager, which will open up the possibility of adding all kinds of software already precooked to launch without investing practically any time: databases, web servers, mail servers, and caches, among others. Don’t worry if you have no experience with Docker. I’ll teach you the basics without going into low-level details. After a few tweaks, you’ll practically forget that it’s running in the background.</p>
			<p>It’s important not only that we know how to write Python and create real-time infrastructures with Django but also that we have the skills to be independent of the operating system when deploying or working in a team. By virtualizing (or isolating) the processes, we can remain unconcerned about the operating system where it runs, making the project easy to continue for any specialist, and we can anticipate future problems that may occur when deploying to a production server.</p>
			<p>In this chapter, we’ll be covering the following topics:</p>
			<ul>
				<li>Exploring the software required</li>
				<li>Adding dependencies</li>
				<li>Configuring the IDE</li>
				<li>Installing Django</li>
				<li>Creating our project</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Exploring the software required</h1>
			<p>In this section, we will take a look at the software that we’ll be using throughout the book and how to install it. The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-1">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-1</a>.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Operating system</h2>
			<p>You should work on <a id="_idIndexMarker000"/>an operating system that supports Docker, such as one of the following:</p>
			<ul>
				<li>Linux distribution, preferably <strong class="bold">Ubuntu</strong> or <strong class="bold">Debian</strong></li>
				<li>macOS in its latest version</li>
				<li>Windows 10 or higher, preferably with the Linux subsystem active and Ubuntu or Debian installed</li>
				<li>BSD descendants, preferably FreeBSD</li>
			</ul>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Code editor</h2>
			<p>I assume<a id="_idIndexMarker001"/> that if you are reading this book, you already have experience with Python and you have an IDE or rich editor that is ready. If you need to change the IDE, I have recommended, from most to least highly recommended, in the following list some that I consider perfect for working with Python:</p>
			<ul>
				<li><strong class="bold">PyCharm Professional</strong>: If you <a id="_idIndexMarker002"/>are a student at a recognized school, you can claim a free student license from JetBrains. Otherwise, I encourage you to pay for the license or use their demo. There is a free version of the IDE, <strong class="bold">PyCharm Community Edition</strong>, but <a id="_idIndexMarker003"/>you will not be able to use the Docker interpreter, as this is a feature of the Professional version. You <a id="_idIndexMarker004"/>can download this editor from <a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a>.</li>
				<li><strong class="bold">Visual Studio Code</strong> (<strong class="bold">VSCode</strong>): This is a <a id="_idIndexMarker005"/>very popular editor in web development, created and maintained by Microsoft. You can download<a id="_idIndexMarker006"/> this editor from <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>.</li>
				<li><strong class="bold">Emacs</strong>: This is very easy to use with a preconfigured framework such as Spacemacs or Doom. You can<a id="_idIndexMarker007"/> download this editor from <a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>.</li>
				<li><strong class="bold">Sublime Text</strong> with <a id="_idIndexMarker008"/>the <strong class="bold">Djaneiro</strong> package: This is the easiest option if you are not looking for complications. You can download this editor from <a href="https://www.sublimetext.com/">https://www.sublimetext.com/</a>.</li>
			</ul>
			<p>Don’t force yourself to change. A <a id="_idIndexMarker009"/>code editor is a very personal thing, like choosing a brand of underwear: once you find one that fits your way of being, you don’t want to change. I understand that you may not feel like learning new shortcuts or workflows either. Otherwise, if you have no preference, you are free to visit the website of any of the preceding editors to download and install it on your computer.</p>
			<p>All the examples, activities, and snippets in the book will work with whatever your editor or IDE of choice is. They will mainly help you with syntax errors, autocompletion, and hints, but your code will be self-contained since it is always stored in plain text. A Python programmer is a Python programmer in any editor but not all editors work well with Python.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Python</h2>
			<p>You don’t need to install it. You’re reading correctly; the editor didn’t make a mistake in the review. We’ll use Docker to install a<a id="_idIndexMarker010"/> Python container capable of launching basic commands in Django, such as creating a project or an app or launching the development server.</p>
			<p>I assume that if you are here, it is because you feel comfortable programming with Python. If not, I would recommend you read some of Packt’s books:</p>
			<ul>
				<li><em class="italic">Learn Python Programming – Third Edition</em>, <em class="italic">Fabrizio Romano and Heinrich Kruger</em>, <em class="italic">Packt Publishing</em> (<a href="https://bit.ly/3yikXfg">https://bit.ly/3yikXfg</a>)</li>
				<li><em class="italic">Expert Python Programming – Fourth Edition</em>, <em class="italic">Michał Jaworski and Tarek Ziadé</em>, <em class="italic">Packt Publishing</em> (<a href="https://bit.ly/3pUi9kZ">https://bit.ly/3pUi9kZ</a>)</li>
			</ul>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Docker</h2>
			<p>The fastest way to install Docker is through <strong class="bold">Docker Desktop.</strong>. It’s available on Windows, macOS, and Linux (in beta as I write this). Just<a id="_idIndexMarker011"/> go to the official website, download, and install: </p>
			<p><a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></p>
			<p>In the case that you want to <a id="_idIndexMarker012"/>install it directly through the terminal, you will need to search for <em class="italic">Docker Engine</em> (<a href="https://docs.docker.com/engine/">https://docs.docker.com/engine/</a>). This is highly recommended if you use Linux or BSD.</p>
			<p>Also install <strong class="bold">Docker Compose</strong>, which <a id="_idIndexMarker013"/>will simplify the declaration and management of images and services:</p>
			<p><a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Git</h2>
			<p>There is no development <a id="_idIndexMarker014"/>that does not involve a versioning system. Git is the most popular option and is almost mandatory to learn.</p>
			<p>If you have no knowledge or relatively basic experience with it, I recommend looking at another of Packt’s books, such as <em class="italic">Git Essentials – Second Edition</em>, <em class="italic">Ferdinando Santacroce</em>, <em class="italic">Packt Publishing</em> (<a href="https://bit.ly/3rYVvKL">https://bit.ly/3rYVvKL</a>).</p>
			<p>Alternatively, you can opt to<a id="_idIndexMarker015"/> review the more extensive documentation from the official Git website:</p>
			<p><a href="https://git-scm.com/">https://git-scm.com/</a></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Browser</h2>
			<p>We will avoid <a id="_idIndexMarker016"/>focusing on the visual aspect of the browser, which means frontend implementation features such as CSS compatibility or JavaScript features do not matter. The most important thing is to feel comfortable when debugging the backend. Most of the time, we will be in the console checking that the requests (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and the like) work as expected, watching the communication over <strong class="bold">WebSocket</strong> to make it smooth, and sporadically manipulating the rendered HTML.</p>
			<p class="callout-heading">WebSocket</p>
			<p class="callout">WebSocket<a id="_idIndexMarker017"/> is a bidirectional communication protocol, different from HTTP, which facilitates the sending of data in real time between a server and a client, in our case, between a Django server and a frontend client. </p>
			<p>In this book, I will use<a id="_idIndexMarker018"/> the <strong class="bold">Firefox Developer Edition</strong> (<a href="https://www.mozilla.org/en-US/firefox/developer/">https://www.mozilla.org/en-US/firefox/developer/</a>) browser because it is so convenient to manage the <a id="_idIndexMarker019"/>aspects mentioned using it. You are free to use any other browser, such as <strong class="bold">Chrome</strong>, <strong class="bold">Safari</strong>, or <strong class="bold">Edge</strong>, but I’m not sure whether all the features I will use are <a id="_idIndexMarker020"/>available<a id="_idIndexMarker021"/> with those browsers.</p>
			<p>With the software installed, we can start working with the preparations around Python and Docker to run Django or future Python code.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Adding dependencies</h1>
			<p>We’re going to run <a id="_idIndexMarker022"/>Python via Docker and a configuration file. That way, any developer can replicate our code regardless of whether they have Python installed on their machine and they will be able to run the associated services with just one command.</p>
			<p>First, we will create a Python file called <strong class="source-inline">hello.py</strong> with the following content:</p>
			<p class="source-code">print(“Wow, I have run in a Docker container!”)</p>
			<p>The code is ready. We can continue.</p>
			<p>The goal will be to configure Docker to run the file. Sounds easy, doesn’t it? Here we go!</p>
			<p>We’ll create a <a id="_idIndexMarker023"/>file called <strong class="source-inline">Dockerfile</strong> with the following code:</p>
			<pre class="source-code"># Image</pre>
			<pre class="source-code">FROM python:3.10</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"># Display the Python output through the terminal</pre>
			<pre class="source-code">ENV PYTHONUNBUFFERED: 1</pre>
			<pre class="source-code"># Set work directory</pre>
			<pre class="source-code">WORKDIR /usr/src/app</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"># Add Python dependencies</pre>
			<pre class="source-code">## Update pip</pre>
			<pre class="source-code">RUN pip install --upgrade pip</pre>
			<pre class="source-code">## Copy requirements</pre>
			<pre class="source-code">COPY requirements.txt ./requirements.txt</pre>
			<pre class="source-code">## Install requirements</pre>
			<pre class="source-code">RUN pip3 install -r requirements.txt</pre>
			<p>This file is used to create a Docker image, or template, with instructions that will be cached. Since they are precached, their launch will be almost instantaneous. Let’s check out what’s going on in the code:</p>
			<ul>
				<li>With <strong class="source-inline">FROM python:3.10</strong>, we are using another existing image as a base. We are extending the work already <a id="_idIndexMarker024"/>done. But... where is it? Docker has a repository full of images, or templates, called <strong class="bold">Docker Hub</strong> (<a href="https://hub.docker.com/">https://hub.docker.com/</a>), a place where developers selflessly upload their work. There is an official image called <strong class="source-inline">python</strong> and we mark it with a tag to use version 3.10. If you have worked with Docker before, you might be wondering why we are not using the <em class="italic">Alpine</em> version, the famous operating system that saves so much space in servers around the world. For two reasons: Python is slower (<a href="https://pythonspeed.com/articles/alpine-docker-python/">https://pythonspeed.com/articles/alpine-docker-python/</a>) and it doesn’t have the ability to compile dependencies. The <em class="italic">Slim</em> version also exacerbates the last problem and is recommended only for production versions that are short of space.</li>
				<li><strong class="source-inline">ENV PYTHONUNBUFFERED: 1</strong> shows us the Python messages, for example, when we use <strong class="source-inline">print()</strong>. If it was not added, they would go directly to the Docker log.</li>
				<li>By adding <strong class="source-inline">WORKDIR /usr/src/app</strong>, we define the path in which the commands will be executed inside the Docker container, not inside our operating system. This is equivalent to changing the directory with <strong class="source-inline">cd</strong>.</li>
				<li>We will also <a id="_idIndexMarker025"/>take the opportunity to install the Python dependencies that we will be adding in the future inside <strong class="source-inline">requirements.txt</strong>. We update <em class="italic">pip</em> with <strong class="source-inline">RUN pip install --upgrade pip</strong>, copy the list of dependencies from the folder to the image with <strong class="source-inline">COPY requirements.txt ./requirements. Txt</strong>, and finally, run <em class="italic">pip</em> to install everything with <strong class="source-inline">RUN pip3 install -r requirements.txt</strong>.</li>
				<li>At the root of the project, we create another file called <strong class="source-inline">docker-compose.yaml</strong> with the following content:<p class="source-code">version: '3.8'</p><p class="source-code"> </p><p class="source-code">services:</p><p class="source-code"> </p><p class="source-code">  python:</p><p class="source-code">    build:</p><p class="source-code">      context: ./</p><p class="source-code">      dockerfile: ./Dockerfile</p><p class="source-code">    entrypoint: python3 hello.py</p><p class="source-code">    volumes:</p><p class="source-code">      - .:/usr/src/app/</p></li>
			</ul>
			<p>This is the orchestrator, a file where we define each service and its configurations. In this case, we are only going to have a service called <strong class="source-inline">python</strong>. With <strong class="source-inline">build</strong>, we tell Docker to use the image that we just defined in the <strong class="source-inline">Dockerfile</strong>. With <strong class="source-inline">entrypoint</strong>, we indicate what it should do when the service is launched: <strong class="source-inline">python3 hello.py</strong>. Finally, in <strong class="source-inline">volumes</strong>, we tell it to mount the root directory, represented by a single dot, with <strong class="source-inline">/usr/src/app/</strong>, which is an internal directory of the image. This way, the service will have access to all the files in the folder.</p>
			<ul>
				<li>Next, we create<a id="_idIndexMarker026"/> an empty file called <strong class="source-inline">requirements.txt</strong>. We will not add a single line, though the file must be present.</li>
			</ul>
			<p>We’re ready to go! Open the terminal, go to the working folder, and tell <strong class="source-inline">docker-compose</strong> to pull up the services:</p>
			<p class="source-code">cd [your folder]</p>
			<p class="source-code">docker-compose up</p>
			<p>Docker will gradually perform several tasks: it will download the base <strong class="source-inline">python</strong> image, build its own image by executing the instructions we have defined, and raise the <strong class="source-inline">python</strong> service. It will print 2 lines per console, as in the following:</p>
			<p class="source-code">python_1 | Wow, I have run in a Docker container!</p>
			<p class="source-code">python_1 exited with code 0</p>
			<p>We’ve executed the Python file! Victory!</p>
			<p>With the recent ability to run Python using Docker, it’s time to integrate it into an IDE to make it easier to run without using the terminal.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Configuring the IDE</h1>
			<p><strong class="bold">PyCharm</strong> is<a id="_idIndexMarker027"/> highly popular because it’s a tool specially prepared to work with Python and it also includes interesting integrations with databases, Git, HTTP clients, environments, and the like. One of the <a id="_idIndexMarker028"/>most used is certainly the one related to Docker, so I will use this fantastic IDE in future examples. However, as I said before, it is not mandatory to use it; there are enough alternatives to please everyone. All code and activities shown in this chapter will work independently of the editor.</p>
			<p>To set up the IDE, follow these steps:</p>
			<ol>
				<li>Open the folder where you want to work using PyCharm (<strong class="bold">File</strong> | <strong class="bold">Open</strong>). A directory tree will be displayed on the left. </li>
				<li>Click on the Python file (<strong class="source-inline">hello.py</strong>). It’s not possible to run the Python code if you don’t use the terminal; PyCharm doesn’t know where the Python interpreter, or executable, is otherwise. It’s inside a Docker image that the operating system can’t access, for now.</li>
			</ol>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/Figure_1.1_B18321.jpg" alt="Figure 1.1 – Open the Python file&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Open the Python file</p>
			<ol>
				<li value="3">PyCharm may <a id="_idIndexMarker029"/>open a popup that suggests creating a virtual environment. You can skip this step or close the window; we will use Docker for the job. If you don’t see the window, you can continue without fear.</li>
				<li>We then check whether we have the Docker plugin installed. Go to <strong class="bold">File</strong> | <strong class="bold">Settings</strong> | <strong class="bold">Plugins</strong> and look for <strong class="bold">Docker</strong>. </li>
				<li>If it is installed, it will appear in the <strong class="bold">Installed</strong> tab. If not, you will have to look for it in <strong class="bold">Marketplace</strong> and then click on the <strong class="bold">Install</strong> button. Then, restart PyCharm. Ensure you do this. Otherwise, we won’t be able to continue.</li>
			</ol>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_1.2_B18321.jpg" alt="Figure 1.2 – Installing the Docker plugin&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Installing the Docker plugin</p>
			<ol>
				<li value="6">Now <a id="_idIndexMarker030"/>open <strong class="bold">File</strong> | <strong class="bold">Settings</strong> | <strong class="bold">Build, Execution, Deployment</strong> | <strong class="bold">Docker</strong> and press the <strong class="bold">+</strong> button. Then, search for <strong class="bold">Docker</strong>. </li>
			</ol>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_1.3_B18321.jpg" alt="Figure 1.3 – Connecting with Docker&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Connecting with Docker</p>
			<ol>
				<li value="7">Enter <strong class="source-inline">Docker</strong> in the <strong class="bold">Name</strong> field, for example, and activate <strong class="bold">Unix socket</strong>. At the <a id="_idIndexMarker031"/>bottom, you will see the <strong class="bold">Connection successful</strong> message. </li>
				<li>We only need to tell PyCharm not to look for the Python interpreter, or executable, on the machine (if there is one) and to use the Docker service we have created instead.</li>
				<li>Go to <strong class="bold">File</strong> | <strong class="bold">Settings</strong> | <strong class="bold">Project: Executable Python</strong>. Here, we deploy the <strong class="bold">Python Interpreter</strong>, select <strong class="bold">Remote Python xxx Docker Compose</strong>, and click on <strong class="bold">Apply</strong>. The interpreter name may change depending on the folder name.</li>
			</ol>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_1.4_B18321.jpg" alt="Figure 1.4 – Adding the Python interpreter&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Adding the Python interpreter</p>
			<ol>
				<li value="10">It will <a id="_idIndexMarker032"/>automatically detect the dependencies that are already installed on the machine but we will ignore them. By the way, this is a good place to manage all Python dependencies visually.</li>
				<li>Now, it’s time to run the Python code using the configuration you just made.</li>
				<li>Close <strong class="bold">Settings</strong> and focus on the directory tree (on the left side). Right-click on <strong class="source-inline">hello.py</strong> and then <strong class="bold">Run ‘hello’</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_1.5_B18321.jpg" alt="Figure 1.5 – Running Python with PyCharm&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Running Python with PyCharm</p>
			<ol>
				<li value="13">At the<a id="_idIndexMarker033"/> bottom of the editor, an area with the log of the execution will open. As proof that it has been done successfully, we can see the <strong class="source-inline">print</strong> statement.</li>
			</ol>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_1.6_B18321.jpg" alt="Figure 1.6 – Viewing the Python execution log through Docker integration&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Viewing the Python execution log through Docker integration</p>
			<ol>
				<li value="14">Also, if <a id="_idIndexMarker034"/>we open the <strong class="source-inline">docker-compose.yaml</strong> file, we can run the containers individually.</li>
			</ol>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_1.7_B18321.jpg" alt="Figure 1.7 – Launching containers through Docker integration&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Launching containers through Docker integration</p>
			<ol>
				<li value="15">On line 5 in <em class="italic">Figure 1.7</em>, you can <a id="_idIndexMarker035"/>see a green arrow; when you click on it, it will launch the service and, again, the Python code.</li>
			</ol>
			<p>PyCharm is already integrated with Docker and is able to launch Python with its dependencies in isolation from the operating system. We are ready to work directly with Django. We are going to create a simple project using the official Django client to have a minimal structure when developing.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Installing Django</h1>
			<p>We already have a base with <a id="_idIndexMarker036"/>which to work with Python; now, it’s time to install the minimum dependencies and tools that will be practical in Django.</p>
			<p>We will add the following content to <strong class="source-inline">requirements.txt</strong>, which is currently empty:</p>
			<pre class="source-code"># Django</pre>
			<pre class="source-code">django===4.0</pre>
			<pre class="source-code"># Django Server</pre>
			<pre class="source-code">daphne===3.0.2</pre>
			<pre class="source-code">asgiref===3.4.1</pre>
			<pre class="source-code"># Manipulate images</pre>
			<pre class="source-code">Pillow===8.2.0</pre>
			<pre class="source-code"># Kit utilities</pre>
			<pre class="source-code">django-extensions===3.1.3</pre>
			<pre class="source-code"># PostgreSQL driver</pre>
			<pre class="source-code">psycopg2===2.9.1</pre>
			<pre class="source-code"># Django Channels</pre>
			<pre class="source-code">channels===3.0.4</pre>
			<pre class="source-code"># Redis Layer</pre>
			<pre class="source-code">channels_redis===3.2.0</pre>
			<p>You may not know some of them <a id="_idIndexMarker037"/>since they are part of the project that adds WebSocket to Django. Let’s review each one:</p>
			<ul>
				<li><strong class="bold">Django</strong>: This<a id="_idIndexMarker038"/> automates many important tasks, such as database connections, migrations, HTML rendering, sessions, and forms. In addition, being one of the most used and active frameworks, it gives us a high degree of security.</li>
				<li><strong class="bold">Daphne</strong>: An <a id="_idIndexMarker039"/>asynchronous server maintained by the Django team itself. We’ll need it to work with WebSocket, to emit or receive data without blocking the app.</li>
				<li><strong class="bold">asgiref</strong>: An <a id="_idIndexMarker040"/>ASGI library that needs Channels to work.</li>
				<li><strong class="bold">Pillow</strong>: The<a id="_idIndexMarker041"/> mandatory Django library for manipulating images.</li>
				<li><strong class="bold">django-extensions</strong>: A set<a id="_idIndexMarker042"/> of extensions that adds elements, such as <em class="italic">jobs</em>, script execution, database synchronization, and static storage in <em class="italic">S3</em>.</li>
				<li><strong class="bold">Psycopg2</strong>: The<a id="_idIndexMarker043"/> driver to connect to PostgreSQL, the database that we will use and is most recommended to use with Django.</li>
				<li><strong class="bold">Channels</strong>: Adds protocols<a id="_idIndexMarker044"/> and functionality for working with WebSocket to the heart of Django.</li>
				<li><strong class="bold">channels_redis</strong>: We<a id="_idIndexMarker045"/> must have a record of the connections that we have active and the groups to which they belong. Using a database that writes to the hard disk is an inefficient way to manage it. To solve this, we’ll connect with a Redis service later, as it works on volatile memory and is incredibly fast.</li>
			</ul>
			<p>PyCharm may suggest <a id="_idIndexMarker046"/>you install a plugin, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_1.8_B18321.jpg" alt="Figure 1.8 – PyCharm asking whether you want to install the new dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – PyCharm asking whether you want to install the new dependencies</p>
			<p>If you click <a id="_idIndexMarker047"/>on <strong class="bold">Install plugins</strong>, it will show you a window, like so:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_1.9_B18321.jpg" alt="Figure 1.9 – PyCharm asking whether you want to install the requirements plugin&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – PyCharm asking whether you want to install the requirements plugin</p>
			<p>By clicking on<a id="_idIndexMarker048"/> the <strong class="bold">OK</strong> button, we can enjoy color codes for <strong class="source-inline">requirements.txt</strong>.</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_1.10_B18321.jpg" alt="Figure 1.10 – Color codes thanks to the plugin&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – Color codes thanks to the plugin</p>
			<p>Now, we will <a id="_idIndexMarker049"/>recompile the image so that all the dependencies we have added are installed. </p>
			<p>With PyCharm, this can be done in a visual way. Go to <strong class="bold">Dockerfile</strong>, right-click on the double arrow shown in the following screenshot, and select <strong class="bold">Build Image for ‘Dockerfile’</strong>:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_1.11_B18321.jpg" alt="Figure 1.11 – Compiling a Dockerfile image using PyCharm&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – Compiling a Dockerfile image using PyCharm</p>
			<p>If you are using the <a id="_idIndexMarker050"/>terminal or another editor, we will use <strong class="source-inline">docker-compose</strong> in the directory:</p>
			<p class="source-code">docker-compose build</p>
			<p>By recreating the image, we’ve integrated all the dependencies inside the image; now, Django has everything we need. To check that it’s installed and we have version 4, we’ll te<a id="_idTextAnchor026"/>mporarily modify <strong class="source-inline">entrypoint</strong>:</p>
			<pre class="source-code">Entrypoint: django-admin --version</pre>
			<p>And then, we’ll run the service.</p>
			<p>Remember that you can do this by clicking on the green arrow next to Python (line 5 in <em class="italic">Figure 1.12</em>) or through <strong class="source-inline">docker-compose</strong>.</p>
			<p class="source-code">docker-compose up</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_1.12_B18321.jpg" alt="Figure 1.12 – Checking which version of Django is installed&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – Checking which version of Django is installed</p>
			<p>In both cases, you can<a id="_idIndexMarker051"/> see that it returns <strong class="source-inline">4.0</strong> or the version specified in <strong class="source-inline">requirements.txt</strong>. We are ready!</p>
			<p>All this work can serve as a template for future Python developments. Don’t lose it!</p>
			<p>After creating a minimal template through the Django client, we’re going to configure it to launch the test server every time the service is up.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor027"/>Creating our project</h1>
			<p>Django needs its own directory and<a id="_idIndexMarker052"/> file structure to work. That’s why we need to generate a project via <strong class="source-inline">django-admin</strong>, a terminal client built to launch Django tasks. Don’t worry! You don’t have to install anything new; it was added when we added the Django dependency. </p>
			<p>Let’s build a file with shell instructions to perform all the<a id="_idTextAnchor028"/> tasks in one go. We create a file called <strong class="source-inline">start-project.sh</strong>, where we are working with the following content:</p>
			<pre class="source-code"># Create the 'hello-word' project</pre>
			<pre class="source-code">django-admin startproject hello_world </pre>
			<pre class="source-code"># Create a folder to host the future App with the name </pre>
			<pre class="source-code">    'simple-app'.</pre>
			<pre class="source-code">mkdir -p app/simple_app</pre>
			<pre class="source-code"># Create the 'simple-app' App</pre>
			<pre class="source-code">django-admin startapp simple_app app/simple_app</pre>
			<p>Here is what we are doing:</p>
			<ul>
				<li>With the first<a id="_idIndexMarker053"/> instruction, <strong class="source-inline">django-admin startproject hello_world .</strong>, we’re creating a project (<strong class="source-inline">startproject</strong>) called <strong class="source-inline">hello_world</strong> and, with the final dot, we’re telling it to make it in the directory where we’re running it.</li>
				<li>When we launch <strong class="source-inline">mkdir -p app/simple_app</strong>, we create a directory called <strong class="source-inline">simple_app </strong>which is inside app. The goal is to organize the apps, saving them all in the same directory; we also create the folder in which the first app will be saved: <strong class="source-inline">simple_app</strong>.</li>
				<li>Finally, we create the app with <strong class="source-inline">django-admin startapp simple_app app/simple_app</strong>. The <strong class="source-inline">simple_app</strong> and <strong class="source-inline">app/simple_app</strong> parameters define the app’s name and its location, respectively, which we created with the previous command.</li>
				<li>In short, we’ll call the project <strong class="source-inline">hello_world</strong>, and inside it, we’ll have a single app with the original name <strong class="source-inline">simple_app</strong>. </li>
			</ul>
			<p>PyCharm may suggest that you install a plugin to check for syntax problems; it’s a good idea to do so.</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_1.13_B18321.jpg" alt="Figure 1.13 – PyCharm suggests installing a syntax checker for shell files&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – PyCharm suggests installing a syntax checker for shell files</p>
			<p>To execute the<a id="_idIndexMarker054"/> script, we again must temporarily modify <strong class="source-inline">entrypoint</strong> with <strong class="source-inline">bash start-project.sh</strong>:</p>
			<pre class="source-code">version: '3.8'</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">services:</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">  python:</pre>
			<pre class="source-code">    build:</pre>
			<pre class="source-code">      context:<a id="_idTextAnchor029"/> ./</pre>
			<pre class="source-code">      dockerfile: ./Dockerfile</pre>
			<pre class="source-code">        entrypoint: bash start-project.sh</pre>
			<pre class="source-code">    volumes:</pre>
			<pre class="source-code">      - .:/usr/src/app/</pre>
			<p>We launch the container as we have already learned to: open the <strong class="source-inline">docker-compose.yaml</strong> file and click on the double green arrow in <strong class="source-inline">services</strong> or the single arrow in <strong class="source-inline">python</strong>.</p>
			<p>If you are using the terminal or another editor, we will use <strong class="source-inline">docker-compose</strong> in the directory:</p>
			<p class="source-code">docker-compose up</p>
			<p>When Docker<a id="_idIndexMarker055"/> finishes, the new files and directories will appear. Be patient if you don’t see them in PyCharm; sometimes it has a hard time refreshing when new files appear. You can wait or right-click on any file and click <strong class="bold">Reload from Disk</strong>.</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_1.14_B18321.jpg" alt="Figure 1.14 – The newly generated Django project&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – The newly generated Django project</p>
			<p>It’s time to<a id="_idIndexMarker056"/> modify <strong class="source-inline">entrypoint</strong> one last time. Let’s get the development server up. It’s time to reap the fruits of ou<a id="_idTextAnchor030"/>r labor.</p>
			<p>Modify it by adding the following:</p>
			<pre class="source-code">python3 manage.py runserver 0.0.0.0.0:8000</pre>
			<p>If you haven’t worked with Django before, <strong class="source-inline">manage.py</strong> is equivalent to using <strong class="source-inline">django-admin</strong>. The advantage of the former is that it uses the project’s configuration, while <strong class="source-inline">django-admin</strong> is more general and you have to tell it where the configuration is; so, it’s more practical to use <strong class="source-inline">manage.py</strong> as soon as the project exists.</p>
			<p>The action we want to launch is to raise a development server with <strong class="source-inline">runserver</strong>. The <strong class="source-inline">0.0.0.0.0:8000</strong> parameter indicates that we are open to any <em class="italic">IP</em> that makes the request and finally, we will use port <strong class="source-inline">8000</strong> to accept connections.</p>
			<p>On the other <a id="_idIndexMarker057"/>hand, for Docker to route port <strong class="source-inline">8000</strong> from the service to the outside, we will add ports <strong class="source-inline">8000:8000</strong> somewhere inside the service.</p>
			<p>Altogether, it will look like this:</p>
			<pre class="source-code">version: '3.8'</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">services:</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">  python:</pre>
			<pre class="source-code">    build:</pre>
			<pre class="source-code">      context: ./</pre>
			<pre class="source-code">      dockerfile: ./Dockerfile</pre>
			<pre class="source-code">    entrypoint:<a id="_idTextAnchor031"/> python3 manage.py runserver 0.0.0.0:8000</pre>
			<pre class="source-code">    ports:</pre>
			<pre class="source-code">      - “8000:8000”</pre>
			<pre class="source-code">    volumes:</pre>
			<pre class="source-code">      - .:/usr/src/app/</pre>
			<p>We launch the service again. Now, open your favorite browser and enter <strong class="source-inline">127.0.0.1:8000</strong>. You’ll find the Django welcome web page.</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_1.15_B18321.jpg" alt="Figure 1.15 – The Django default page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – The Django default page</p>
			<p>We’ve done it! Django is<a id="_idIndexMarker058"/> running on Docker.</p>
			<p>As a last detail, if you are using the terminal, you will find that the container never stops. That’s because the web server, as a good server, is constantly running and waiting for requests until we tell it otherwise. Press <em class="italic">Ctrl</em> + <em class="italic">C</em> if you want to close it. In PyCharm, you should click on the red <strong class="bold">Stop</strong> square.</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_1.16_B18321.jpg" alt="Figure 1.16 – Stopping Docker services via PyCharm and its integration&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – Stopping Docker services via PyCharm and its integration</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor032"/>Summary</h1>
			<p>We have just acquired the skills to configure and build a Python project using Docker containers. We started with the basics, creating an image that runs a Python script and also installs all the dependencies we declared in <strong class="source-inline">requirements.txt</strong>. Then, we automated the creation of a Django project with a simple script and set up the development server.      </p>
			<p>On the other hand, to make container management easier, we have integrated an IDE into the flow, in our case, PyCharm. It gives us the possibility to launch some of the functionalities that we will use the most: building a custom image, executing a container composition (now we only have a service for Python), visualizing the log, and restarting and stopping containers. But let’s not forget that all these tasks are accessible from the terminal, using <strong class="source-inline">docker-compose</strong>.</p>
			<p>In the next chapter, we will build a complete project in Django with various databases, a web server, and other tools that we will need to build a complete project. In addition, we will integrate Django’s configuration with Docker to facilitate its deployment with different configurations.</p>
		</div>
		<div>
			<div id="_idContainer025">
			</div>
		</div>
	</body></html>