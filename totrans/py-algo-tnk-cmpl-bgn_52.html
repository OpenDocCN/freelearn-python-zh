<html><head></head><body><div><div><h2>Chapter 36 <br/>Tips and Tricks with Subprograms</h2>
<h3 id="toc_1">36.1 Can Two Subprograms use Variables of the Same Name?</h3>
<p class="my_basic">Each subprogram uses its own memory space to hold the values of its variables. Even the main code has its own memory space! This means that you can have a variable named test in main code, another variable named test in a subprogram, and yet another variable named test in another subprogram. Pay attention! Those three variables are three completely different variables, in different memory locations, and they can hold completely different values.</p>
<p class="my_basic">As you can see in the program that follows, there are three variables named test in three different memory locations and each one of them holds a completely different value. The trace table below can help you understand what really goes on.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.1</div>
<div><p>def f1():</p>
<p>test = "Testing!"</p>
<p>print(test)</p>
<div></div>
<p>def f2(test):</p>
<p>print(test)</p>
<div></div>
<p>#Main code starts here</p>
<p>test = 5</p>
<p>print(test)</p>
<p>f1()</p>
<p>f2(10)</p>
<p>print(test)</p>
</div>
<p class="my_basic">The trace table is shown here.</p>
<div><table border="0" cellpadding="3" cellspacing="0" class="my_table">
<tr>
<th class="center" rowspan="2">Step</th>
<th rowspan="2">Statement</th>
<th rowspan="2">Notes</th>
<th class="center">Main Code</th>
<th class="center">void Function f1()</th>
<th class="center">void Function f2()</th>
</tr>
<tr>
<th class="center">test</th>
<th class="center">test</th>
<th class="center">test</th>
</tr>
<tr>
<th class="center"> 1</th>
<td>test = 5</td>
<td> </td>
<td class="center">5</td>
<td class="center"> </td>
<td class="center"> </td>
</tr>
<tr>
<th class="center"> 2</th>
<td>print(test)</td>
<td>It displays: 5</td>
<td class="center">5</td>
<td class="center"> </td>
<td class="center"> </td>
</tr>
<tr>
<th class="center"> 3</th>
<td>f1()</td>
<td>f1() is called</td>
<td class="center"> </td>
<td class="center">?</td>
<td class="center"> </td>
</tr>
<tr>
<th class="center"> 4</th>
<td>test = "Testing!"</td>
<td> </td>
<td class="center"> </td>
<td class="center">Testing!</td>
<td class="center"> </td>
</tr>
<tr>
<th class="center"> 5</th>
<td>print(test)</td>
<td>It displays: Testing!</td>
<td class="center"> </td>
<td class="center">Testing!</td>
<td class="center"> </td>
</tr>
<tr>
<th class="center"> 6</th>
<td>f2(10)</td>
<td>f2() is called</td>
<td class="center"> </td>
<td class="center"> </td>
<td class="center">10</td>
</tr>
<tr>
<th class="center"> 7</th>
<td>print(test)</td>
<td>It displays: 10</td>
<td class="center"> </td>
<td class="center"> </td>
<td class="center">10</td>
</tr>
<tr>
<th class="center"> 8</th>
<td>print(test)</td>
<td>It displays: 5</td>
<td class="center">5</td>
<td class="center"> </td>
<td class="center"> </td>
</tr>
</table>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Note that variables used in a subprogram “live” as long as the subprogram is being executed. This means that before calling the subprogram, none of its variables (including those in the formal argument list) exists in main memory (RAM). They are all defined in the main memory when the subprogram is called, and they are all removed from the main memory when the subprogram finishes and the flow of execution returns to the caller. The only variables that “live” forever, or at least for as long as the Python program is being executed, are the variables of the main code and the global variables! You will learn more about global variables in <a href="#toc_6">Section 36.6</a>.</p>
</div>
<h3 id="toc_2">36.2 Can a Subprogram Call Another Subprogram?</h3>
<p class="my_basic">Up to this point, you might have gotten the impression that only the main code can call a subprogram. However, this is not true! A subprogram can call any other subprogram which in turn can call another subprogram, and so on. You can make whichever combination you wish. For example, you can write a function that calls a void function, a void function that calls a function, a function that calls another function, or even a function that calls one of the built-in functions of Python.</p>
<p class="my_basic">The next example presents exactly this situation. The main code calls the void function displaySum(), which in turn calls the function add().</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.2</div>
<div><p>def add(number1, number2):</p>
<p>result = number1 + number2</p>
<p>return result</p>
<div></div>
<p>def displaySum(num1, num2):</p>
<p>print(add(num1, num2))</p>
<div></div>
<p>#Main code starts here</p>
<p>a = int(input())</p>
<p>b = int(input())</p>
<div></div>
<p>displaySum(a, b)</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>When the flow of execution reaches the return statement of the function add(), it returns to its caller, that is to the void function displaySum(). Then, when the flow of execution reaches the end of the void function displaySum(), it returns to its caller, that is, to the main code.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Note that there is no restriction on the order in which the two subprograms should be written. It would have been exactly the same if the void function displaySum() had been written before the function add().</p>
</div>
<h3 id="toc_3">36.3 Passing Arguments by Value and by Reference</h3>
<p class="my_basic">In Python, variables are passed to subprograms by value. This means that if the value of an argument is changed within the subprogram, it does not get changed outside of it. Take a look at the following example.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.3a</div>
<div><p>def f1(b):</p>
<p>b += 1      #This is a variable of void function f1()</p>
<p>print(b)    #It displays: 11</p>
<div></div>
<p>#Main code starts here</p>
<p>a = 10          #This is a variable of the main code</p>
<p>f1(a)</p>
<p>print(a)        #It displays: 10</p>
</div>
<p class="my_basic">The value 10 of variable a is passed to void function f1() through argument b. However, although the content of variable b is altered within the void function, when the flow of execution returns to the main code this change does not affect the value of variable a.</p>
<p class="my_basic">In the previous example, the main code and the void function are using two variables with different names. Yet, the same would have happened if, for instance, both the main code and the void function had used two variables of the same name. The next example operates exactly the same way and displays exactly the same results as the previous example did.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.3b</div>
<div><p>def f1(a):</p>
<p>a += 1      #This is a variable of void function f1()</p>
<p>print(a)    #It displays: 11</p>
<div></div>
<p>#Main code starts here</p>
<p>a = 10          #This is a variable of the main code</p>
<p>f1(a)</p>
<p>print(a)        #It displays: 10</p>
</div>
<p class="my_basic">Passing a list to a subprogram as an argument is as easy as passing a simple variable. The next example passes list a to the void function display(), and the latter displays the list.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.3c</div>
<div><p>ELEMENTS = 10</p>
<div></div>
<p>def display(b):</p>
<p>for i in range(ELEMENTS):</p>
<div><blockquote><p>print(b[i], end = "\t")</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>a = [None] * ELEMENTS</p>
<p>for i in range(ELEMENTS):</p>
<p>a[i] = int(input())</p>
<div></div>
<p>display(a)</p>
</div>
<p class="my_basic">Contrary to variables, data structures in Python are, by default, passed by reference. This means that if you pass, for example, a list to a subprogram, and that subprogram changes the value of one or more elements of the list, these changes are also reflected outside the subprogram. Take a look at the following example.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.3d</div>
<div><p>def f1(x):</p>
<p>x[0] += 1</p>
<p>print(x[0]) #It displays: 6</p>
<div></div>
<p>#Main code starts here</p>
<p>y = [5, 10, 15, 20]</p>
<p>print(y[0])     #It displays: 5</p>
<p>f1(y)</p>
<p>print(y[0])     #It displays: 6</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Passing a list to a subprogram passes a reference to the list, not a copy of the list, meaning that y and x are actually aliases of the same list. Only one copy of the list exists in the main memory (RAM). If a subprogram changes the value of an element, this change is also reflected in the main program.</p>
</div>
<p class="my_basic">So, as you have probably realized, passing lists by reference can provide an indirect way for a subprogram to “return” more than one value. Keep in mind, though, that using a list to return more than one value from a subprogram is quite unusual in Python since, as you have already learned, Python provides a more convenient way to accomplish this. However, let's see, albeit formally, one such example. In the next example, the function myDivmod() divides variable a by variable b and finds their integer quotient and their integer remainder. If all goes well, it returns True; otherwise, it returns False. Moreover, through the list results, the function also indirectly returns the calculated quotient and the calculated remainder.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.3e</div>
<div><p>def myDivmod(a, b, results):</p>
<p>returnValue = True</p>
<div></div>
<p>if b == 0:</p>
<div><blockquote><p>returnValue = False</p></blockquote></div>
<p>else:</p>
<div><blockquote><p>results[0] = a // b</p></blockquote></div>
<div><blockquote><p>results[1] = a % b</p></blockquote></div>
<div></div>
<p>return returnValue</p>
<div></div>
<p>#Main code starts here</p>
<p>res = [None] * 2</p>
<div></div>
<p>val1 = int(input())</p>
<p>val2 = int(input())</p>
<p>ret = myDivmod(val1, val2, res)</p>
<p>if ret:</p>
<p>print(res[0], res[1])</p>
<p>else:</p>
<p>print("Sorry, wrong values entered!");</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>A very good tactic regarding the arguments in the formal argument list is to have all of those being passed by value written before those being passed by reference.</p>
</div>
<h3 id="toc_4">36.4 Returning a List</h3>
<p class="my_basic">In the next example, the Python program must find the three lowest values of list t. To do so, the program calls and passes the list to the void function getList() through its formal argument x, which in turn sorts list x using the insertion sort algorithm. When the flow of execution returns to the main code, list t is also sorted. This happens because, as already stated, lists in Python are passed by reference. So what the main code finally does is just display the values of the first three elements of the list.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.4a</div>
<div><p>ELEMENTS = 10</p>
<div></div>
<p>def getList(  x  ):     <a href="more.html#more_36_4_1" id="Link_To_More_36_4_1">[More…]</a></p>
<p>for m in range(1, ELEMENTS):</p>
<div><blockquote><p>element = x[m]</p></blockquote></div>
<div><blockquote><p>n = m</p></blockquote></div>
<div><blockquote><p>while n &gt; 0 and x[n - 1] &gt; element:</p></blockquote></div>
<div><blockquote><blockquote><p>x[n] = x[n - 1]</p></blockquote></blockquote></div>
<div><blockquote><blockquote><p>n -= 1</p></blockquote></blockquote></div>
<div><blockquote><p>x[n] = element</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]</p>
<div></div>
<p>getList(t)</p>
<div></div>
<p>print("Three lowest values are: ", t[0], t[1], t[2])</p>
<div></div>
<p>#In this step, list t is sorted</p>
<p>for i in range(ELEMENTS):</p>
<p>print(t[i], end = "\t")</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Since the list t of the main code is passed to the void function by reference, only one copy of the list exists in the main memory (RAM), meaning that t and x are actually aliases of the same list. When the flow of execution returns to the main code, the list t is also sorted.</p>
</div>
<p class="my_basic">However, there are many times when passing a list by reference can be completely disastrous. Suppose you have the following two lists. List names contains the names of 10 cities, and list t contains their corresponding temperatures recorded at a specific hour on a specific day.</p>
<p class="centered_image"><img alt="Image" class="width22" src="img/chapter36-01.png"/></p>
<p class="my_basic">Now, suppose that for list t you wish to display the three lowest temperatures. If you call void function getList() of the previous Python program, you have a problem. Although the three lowest temperatures can be displayed as required, the list t becomes sorted; therefore, the one-to-one correspondence between its elements and the elements of list names is lost forever!</p>
<p class="my_basic">One possible solution would be to write a function in which the list is copied to an auxiliary list and the function would return a smaller list that contains only the three lowest values. The proposed solution is shown here.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.4b</div>
<div><p>ELEMENTS = 10</p>
<div></div>
<p>def getList(x):</p>
<p>#Copy list x to list auxX</p>
<p>auxX = [None] * ELEMENTS</p>
<p>for m in range(ELEMENTS):</p>
<div><blockquote><p>auxX[m] = x[m]</p></blockquote></div>
<div></div>
<p>#and sort list auxX</p>
<p>for m in range(1, ELEMENTS):</p>
<div><blockquote><p>element = auxX[m]</p></blockquote></div>
<div><blockquote><p>n = m</p></blockquote></div>
<div><blockquote><p>while n &gt; 0 and auxX[n - 1] &gt; element:</p></blockquote></div>
<div><blockquote><blockquote><p>auxX[n] = auxX[n - 1]</p></blockquote></blockquote></div>
<div><blockquote><blockquote><p>n -= 1</p></blockquote></blockquote></div>
<div><blockquote><p>auxX[n] = element</p></blockquote></div>
<div></div>
<p>return auxX[:3]  #Use slicing to return only the first 3 elements as a list</p>
<div></div>
<p>#Main code starts here</p>
<p>names = ["City1", "City2", "City3", "City4", "City5",   \</p>
<div><blockquote><p>"City6", "City7", "City8", "City9", "City10"]</p></blockquote></div>
<div></div>
<p>t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]</p>
<div></div>
<p>low = getList(t)</p>
<p>print("Three lowest values are: ", low[0], low[1], low[2])</p>
<div></div>
<p>#In this step, list t is NOT sorted</p>
<p>for i in range(ELEMENTS):</p>
<p>print(t[i], "\t", names[i])</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Note that you cannot use a statement such as auxX = x to copy the elements of list x to auxX. This statement just creates two aliases of the same list. This is why a for-loop is used in the previous example to copy the elements of list x to the list auxX.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>A more Pythonic way to copy all the elements of a list to another list is to use the slicing mechanism. In the previous example, you could do this using the statement auxX = x[:]</p>
</div>
<p class="my_basic">Another, more Pythonic, way is shown here.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.4c</div>
<div><p>def getList(x):</p>
<p>return sorted(x)[:3]  #Return only the first 3 elements of the sorted list</p>
<div></div>
<p>#Main code starts here</p>
<p>names = ["City1", "City2", "City3", "City4", "City5",   \</p>
<div><blockquote><p>"City6", "City7", "City8", "City9", "City10"]</p></blockquote></div>
<div></div>
<p>t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]</p>
<div></div>
<p>low = getList(t)</p>
<p>print("Three lowest values are: ", low[0], low[1], low[2])</p>
<div></div>
<p>#In this step, list t is NOT sorted</p>
<p>for i in range(len(t)):</p>
<p>print(t[i], "\t", names[i])</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/remember.jpg"/>The function sorted(x) returns a new sorted list, leaving the initial list x intact (see <a href="chapter32.html#toc_12">Section 32.7</a>).</p>
</div>
<h3 id="toc_5">36.5 Default Argument Values (Optional Arguments) and Keyword Arguments</h3>
<p class="my_basic">If you assign a default value to an argument within the formal argument list, it means that if no value is passed for that argument then the default value is used. In the next example, the function prependTitle() is designed to prepend (add a prefix to) a title before the name. However, if no value for argument title is passed, the function uses the default value “M”.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.5a</div>
<div><p>def prependTitle(name, title = "M"):</p>
<p>return title + " " + name</p>
<div></div>
<p>#Main code starts here</p>
<p>print(prependTitle("John King"))          #It displays: M John King</p>
<p>print(prependTitle("Maria Miller", "Ms")) #It displays: Ms Maria Miller</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>When a default value is assigned to an argument within the formal argument list, this argument is called an “optional argument”.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Within the formal argument list, any optional arguments must be on the right side of any non-optional arguments; to do the opposite of this would be incorrect.</p>
</div>
<p class="my_basic">Moreover, in Python, subprograms can be called using a keyword argument with the form</p>
<p class="my_basic center">argument_name = value</p>
<p class="my_basic">Python assumes that keyword arguments are optional. If no argument is provided in a subprogram call, the default value is used. Take a look at the following Python program. The function prependTitle() is called four times. In the last call however, a keyword argument is used.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.5b</div>
<div><p>def prependTitle(firstName, lastName, title = "M", reverse = False):</p>
<p>if not reverse:</p>
<div><blockquote><p>returnValue = title + " " + firstName + " " + lastName</p></blockquote></div>
<p>else:</p>
<div><blockquote><p>returnValue = title + " " + lastName + " " + firstName</p></blockquote></div>
<div></div>
<p>return returnValue</p>
<div></div>
<p>#Main code starts here</p>
<p>print(prependTitle("John", "King"))          #It displays: M John King</p>
<p>print(prependTitle("Maria", "Miller", "Ms")) #It displays: Ms Maria Miller</p>
<p>print(prependTitle("Maria", "Miller", "Ms", True)) #It displays: Ms Miller Maria</p>
<div></div>
<p>#Call the function using a keyword argument</p>
<p>print(prependTitle("John", "King", reverse = True)) #It displays: M King John</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Note that the argument reverse is the fourth in order in the formal argument list. Using a keyword argument though, you can bypass this order.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Instead of using the term “keyword arguments”, many computer languages such as PHP, C#, and Visual Basic (to name a few), prefer to use the term “named arguments”.</p>
</div>
<h3 id="toc_6">36.6 The Scope of a Variable</h3>
<p class="my_basic">The scope of a variable refers to the range of effect of that variable. In Python, a variable can have a local or global scope. A variable declared within a subprogram has a local scope and can be accessed only from within that subprogram. On the other hand, a variable declared outside of a subprogram has a global scope and can be accessed from within any subprogram, as well as from the main code.</p>
<p class="my_basic">Let's see some examples. The next example declares a global variable test. The value of this global variable, though, is accessed and displayed within the void function.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.6a</div>
<div><p>def displayValue():</p>
<p>print(test)     #It displays: 10</p>
<div></div>
<p>#Main code starts here</p>
<p>test = 10           #This is a global variable</p>
<p>displayValue()</p>
<p>print(test)         #It displays: 10</p>
</div>
<p class="my_basic">The question now is, “What happens, if you try to change the value of variable test within function displayValue()? Will it affect the global variable test as well?” In the next example the values 20 and 10 are displayed.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.6b</div>
<div><p>def displayValue():</p>
<p>test = 20       #This is a local variable</p>
<p>print(test)     #It displays: 20</p>
<div></div>
<p>#Main code starts here</p>
<p>test = 10           #This is a global variable</p>
<p>displayValue()</p>
<p>print(test)         #It displays: 10</p>
</div>
<p class="my_basic">This happens because Python declares two variables in main memory (RAM); that is, a global variable test and a local variable test.</p>
<p class="my_basic">Now let's combine the first example with the second one and see what happens. First the subprogram will access the variable test, and then it will assign a value to it, as shown in the code that follows.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.6c</div>
<div><p>def displayValue():</p>
<p>print(test)    #This statement throws an error</p>
<p>test = 20</p>
<p>print(test)</p>
<div></div>
<p>#Main code starts here</p>
<p>test = 10         #This is a global variable</p>
<p>displayValue()</p>
<p>print(test)</p>
</div>
<p class="my_basic">Unfortunately, this example throws the error message “local variable 'test' referenced before assignment”. This happens because Python “assumes” that you want a local variable due to the assignment statement test = 20 within function displayValue(). Therefore, the first print() statement inevitably throws this error message. Any variable that is defined or altered within a function is automatically declared as local, unless it has been forced to be a global variable. To force Python to use the global variable you have to use the keyword global, as you can see in the following example.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.6d</div>
<div><p>def displayValue():</p>
<p>global test    #Force Python to use the global variable test</p>
<p>print(test)    #It displays: 10</p>
<p>test = 20</p>
<p>print(test)    #It displays: 20</p>
<div></div>
<p>#Main code starts here</p>
<p>test = 10          #This is a global variable</p>
<p>displayValue()</p>
<p>print(test)        #It displays: 20</p>
</div>
<p class="my_basic">If you wish to access more than one global variable from within a subprogram, you can write the keyword global and, next to it, all the variables separated with commas, as shown here.</p>
<div><p>global a, b, c</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>If the value of a global variable is altered within a subprogram, this change is also reflected outside of the subprogram. Please note that the last print(test) statement of the main code displays the value of 20.</p>
<p class="notice"><img alt="" class="notice_image" src="img/remember.jpg"/>Any variable that is defined or altered within a function is local unless it is declared as a global variable using the keyword global.</p>
</div>
<p class="my_basic">The next program declares a global variable test, a local variable test within the void function displayValueA(), and another local variable test within the void function displayValueB(). Keep in mind that the global variable test and the two local variables test are three different variables! Furthermore, the third void function displayValueC() uses and alters the value of the global variable test.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.6e</div>
<div><p>def displayValueA():</p>
<p>test = 7      #Local variable test</p>
<p>print(test)   #It displays: 7</p>
<div></div>
<p>def displayValueB():</p>
<p>test = 9      #Local variable test</p>
<p>print(test)   #It displays: 9</p>
<div></div>
<p>def displayValueC():</p>
<p>global test   #Use the value of the global variable test</p>
<p>print(test)   #It displays: 10</p>
<p>test += 1     #Increase the value of the global variable test</p>
<div></div>
<p>#Main code starts here</p>
<p>test = 10         #This is the global variable test</p>
<div></div>
<p>print(test)       #It displays: 10</p>
<p>displayValueA()</p>
<p>print(test)       #It displays: 10</p>
<p>displayValueB()</p>
<p>print(test)       #It displays: 10</p>
<p>displayValueC()</p>
<p>print(test)       #It displays: 11</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>You can have variables of local scope of the same name within different subprograms, because they are recognized only by the subprogram in which they are declared.</p>
</div>
<h3 id="toc_7">36.7 Converting Parts of Code into Subprograms</h3>
<p class="my_basic">Writing large programs without subdividing them into smaller subprograms results in a code that cannot be easily understood or maintained. Suppose you have a large program and you wish to subdivide it into smaller subprograms. The next program is an example explaining the steps that must be followed. The parts of the program marked with a dashed rectangle must be converted into subprograms.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.7a</div>
<div><p>totalYes = 0</p>
<p>femaleNo = 0</p>
<p>for i in range(100):</p>
<p>while True:</p>
<div><div><blockquote><p>temp1 = input("Enter gender for citizen No" + str(i + 1) + ": ")</p></blockquote></div>
<div><blockquote><p>gender = temp1.lower()</p></blockquote></div>
<div><blockquote><p>if gender in ["male", "female", "other"]: break</p></blockquote></div>
</div>
<div></div>
<div><p>while True:</p>
<div><blockquote><p>temp2 = input("Do you go jogging in the afternoon? ")</p></blockquote></div>
<div><blockquote><p>answer = temp2.lower()</p></blockquote></div>
<div><blockquote><p>if answer in ["yes", "no", "sometimes"]: break</p></blockquote></div>
</div>
<div></div>
<div><p>if answer == "yes":</p>
<div><blockquote><p>totalYes += 1</p></blockquote></div>
<div></div>
<p>if gender == "female" and answer == "no":</p>
<div><blockquote><p>femaleNo += 1</p></blockquote></div>
</div>
<div></div>
<div><p>print("Total positive answers:", totalYes)</p>
<p>print("Women's negative answers:", femaleNo)</p>
</div>
</div>
<p class="my_basic">To convert parts of this program into subprograms you must:</p>
<p>►decide, for each dashed rectangle, whether to use a function or a void function. This depends on whether or not, the subprogram will return a result.</p>
<p>►determine which variables exist in each dashed rectangle and their roles in that dashed rectangle.</p>
<p class="my_basic">The flowchart that follows can help you decide what to do with each variable, whether it must be passed to the subprogram and/or returned from the subprogram, or if it must just be a local variable within the subprogram.</p>
<p class="my_basic centered_image"><img alt="Image" class="width38" src="img/chapter36-02.png"/></p>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Keep in mind that functions in Python can return more than one result!</p>
</div>
<p class="my_basic">So, with the help of this flowchart, let's deal with each dashed rectangle one by one! The parts that are not marked with a dashed rectangle will comprise the main code.</p>
<p class="strong">First part</p>
<p class="my_basic">In the first dashed rectangle, there are three variables: i, temp1, and gender. However, not all of them must be included in the formal argument list of the subprogram that will replace the dashed rectangle. Let's find out why!</p>
<p>►Variable i:</p>
<p>►is initialized/updated outside the dashed rectangle; thus, it must be passed to the subprogram</p>
<p>►is not updated within the dashed rectangle; thus, it should not be returned to the caller</p>
<p>►Variable temp1:</p>
<p>►is not initialized/updated outside of the dashed rectangle; thus, it should not be passed to the subprogram</p>
<p>►is initialized within the dashed rectangle but its value is not used outside of it; thus, it should not be returned to the caller</p>
<p>According to the flowchart, since variable temp1 should neither be passed nor returned, this variable can just be a local variable within the subprogram.</p>
<p>►Variable gender:</p>
<p>►is not initialized/updated outside of the dashed rectangle; thus, it should not be passed to the subprogram</p>
<p>►is initialized within the dashed rectangle and then its value is used outside of it; thus, it must be returned to the caller</p>
<p class="my_basic">Therefore, since one value must be returned to the main code, a function can be used as shown here.</p>
<div><p>#First part</p>
<p>def getGender(i):</p>
<p>while True:</p>
<div><blockquote><p>temp1 = input("Enter gender for citizen No" + str(i + 1) + ": ")</p></blockquote></div>
<div><blockquote><p>gender = temp1.lower()</p></blockquote></div>
<div><blockquote><p>if gender in ["male", "female", "other"]: break</p></blockquote></div>
<div></div>
<p>return gender</p>
</div>
<p class="strong">Second part</p>
<p class="my_basic">In the second dashed rectangle there are two variables, temp2 and answer, but they do not both need to be included in the formal argument list of the subprogram that will replace the dashed rectangle. Let's find out why!</p>
<p>►Variable temp2:</p>
<p>►is not initialized/updated outside of the dashed rectangle; thus, it should not be passed to the subprogram</p>
<p>►is initialized/updated within the dashed rectangle but its value is not used outside of it; thus, it should not be returned to the caller</p>
<p>According to the flowchart, since variable temp2 should neither be passed nor returned, this variable can just be a local variable within the subprogram.</p>
<p>►Variable answer:</p>
<p>►is not initialized/updated outside of the dashed rectangle; thus, it should not be passed to the subprogram</p>
<p>►is initialized within the dashed rectangle and then its value is used outside of it; thus, it must be returned to the caller</p>
<p class="my_basic">Therefore, since one value must be returned to the main code, a function can be used, as shown here.</p>
<div><p>#Second part</p>
<p>def getAnswer():</p>
<p>while True:</p>
<div><blockquote><p>temp2 = input("Do you go jogging in the afternoon? ")</p></blockquote></div>
<div><blockquote><p>answer = temp2.lower()</p></blockquote></div>
<div><blockquote><p>if answer in ["yes", "no", "sometimes"]: break</p></blockquote></div>
<div></div>
<p>return answer</p>
</div>
<p class="strong">Third part</p>
<p class="my_basic">In the third dashed rectangle of the example, there are four variables: answer, totalYes, gender and femaleNo and all of them must be included in the formal argument list of the subprogram that will replace the dashed rectangle. Let's find out why!</p>
<p>►Both variables answer and gender:</p>
<p>►are initialized/updated outside of the dashed rectangle; thus, they must be passed to the subprogram</p>
<p>►are not updated within the dashed rectangle; thus, they should not be returned to the caller</p>
<p>►Both variables totalYes and femaleNo:</p>
<p>►are initialized outside of the dashed rectangle; thus, they must be passed to the subprogram</p>
<p>►are updated within the dashed rectangle and then their value is used outside of it; thus, they must be returned to the caller</p>
<p class="my_basic">Therefore, since two values must be returned to the main code, a function can be used, as shown here.</p>
<div><p>#Third part</p>
<p>def countResults(answer, gender, totalYes, femaleNo):</p>
<p>if answer == "yes":</p>
<div><blockquote><p>totalYes += 1</p></blockquote></div>
<div></div>
<p>if gender == "female" and answer == "no":</p>
<div><blockquote><p>femaleNo += 1</p></blockquote></div>
<div></div>
<p>return totalYes, femaleNo</p>
</div>
<p class="strong">Fourth part</p>
<p class="my_basic">In the fourth dashed rectangle of the example, there are two variables: totalYes and femaleNo. Let's see what you should do with them.</p>
<p>►Both variables totalYes and femaleNo:</p>
<p>►are updated outside of the dashed rectangle; thus, they must be passed to the subprogram</p>
<p>►are not updated within the dashed rectangle; thus, they should not be returned to the caller</p>
<p class="my_basic">Therefore, since no value should be returned to the main code, a void function can be used, as follows.</p>
<div><p>#Fourth part</p>
<p>def displayResults(totalYes, femaleNo):</p>
<p>print("Total positive answers:", totalYes)</p>
<p>print("Women's negative answers:", femaleNo)</p>
</div>
<p class="strong">The final program</p>
<p class="my_basic">The final program, including the main code and all the subprograms cited above, is shown here.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.7b</div>
<div><p>#First part</p>
<p>def getGender(i):</p>
<p>while True:</p>
<div><blockquote><p>temp1 = input("Enter gender for citizen No " + str(i + 1) + ": ")</p></blockquote></div>
<div><blockquote><p>gender = temp1.lower()</p></blockquote></div>
<div><blockquote><p>if gender in ["male", "female", "other"]: break</p></blockquote></div>
<div></div>
<p>return gender</p>
<div></div>
<p>#Second part</p>
<p>def getAnswer():</p>
<p>while True:</p>
<div><blockquote><p>temp2 = input("Do you go jogging in the afternoon? ")</p></blockquote></div>
<div><blockquote><p>answer = temp2.lower()</p></blockquote></div>
<div><blockquote><p>if answer in ["yes", "no", "sometimes"]: break</p></blockquote></div>
<div></div>
<p>return answer</p>
<div></div>
<p>#Third part</p>
<p>def countResults(answer, gender, totalYes, femaleNo):</p>
<p>if answer == "yes":</p>
<div><blockquote><p>totalYes += 1</p></blockquote></div>
<div></div>
<p>if gender == "female" and answer == "no":</p>
<div><blockquote><p>femaleNo += 1</p></blockquote></div>
<div></div>
<p>return totalYes, femaleNo</p>
<div></div>
<p>#Fourth part</p>
<p>def displayResults(totalYes, femaleNo):</p>
<p>print("Total positive answers:", totalYes)</p>
<p>print("Women's negative answers:", femaleNo)</p>
<div></div>
<p>#Main code starts here</p>
<p>totalYes = 0</p>
<p>femaleNo = 0</p>
<p>for i in range(100):</p>
<p>gender = getGender(i)</p>
<p>answer = getAnswer()</p>
<p>totalYes, femaleNo = countResults(answer, gender, totalYes, femaleNo)</p>
<div></div>
<p>displayResults(totalYes, femaleNo)</p>
</div>
<h3 id="toc_8">36.8 Recursion</h3>
<p class="my_basic">Recursion is a programming technique in which a subprogram calls itself. This might initially seem like an endless loop, but of course this is not true; a subprogram that uses recursion must be written in a way that obviously satisfies the property of finiteness.</p>
<p class="my_basic">Imagine that the next Python program helps you find your way home. In this program, recursion occurs because the void function find_your_way_home() calls itself within the function.</p>
<div><p>def find_your_way_home():</p>
<p>if you_are_already_at_home:</p>
<div><blockquote><p>stop_walking()</p></blockquote></div>
<p>else:</p>
<div><blockquote><p>take_one_step_toward_home()</p></blockquote></div>
<div><blockquote><p>find_your_way_home()</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>find_your_way_home()</p>
</div>
<p class="my_basic">Now, let's try to analyze recursion through a real example. The next Python program calculates the factorial of 5 using recursion.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_36.8</div>
<div><p>def factorial(value):</p>
<p>if value == 1:</p>
<div><blockquote><p>return 1</p></blockquote></div>
<p>else:</p>
<div><blockquote><p>return factorial(value - 1) * value</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>print(factorial(5)) #It displays: 120</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/remember.jpg"/>In mathematics, the factorial of a non-negative integer N is the product of all positive integers less than or equal to N. It is denoted by N! and the factorial of 0 is, by definition, equal to 1. For example, the factorial of 5 is 1 × 2 × 3 × 4 × 5 = 120.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Recursion occurs because the function factorial() calls itself within the function.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Note that there isn't any loop control structure!</p>
</div>
<p class="my_basic">You are probably confused right now. How on Earth is the product 1 × 2 × 3 × 4 × 5 calculated without using a loop control structure? The next diagram may help you understand. It shows the multiplication operations that are performed as function factorial(5) works its way backwards through the series of calls.</p>
<p class="centered_image"><img alt="Image" class="width44" src="img/chapter36-03.png"/></p>
<p class="my_basic">Let's see how this diagram works. The main code calls the function factorial(5), which in turn calls the function factorial(4), and the latter calls the function factorial(3), and so on. The last call (factorial(1)) returns to its caller (factorial(2)) the value 1, which in turn returns to its caller (factorial(3)) the value 1 × 2 = 2, and so on. When the function factorial(5) returns from the topmost call, you have the final solution.</p>
<p class="my_basic">To avoid logic errors, all recursive subprograms must adhere to three important rules:</p>
<p>1)They must call themselves.</p>
<p>2)They must have a base case, which is the condition that “tells” the subprogram to stop recursions. The base case is usually a very small problem that can be solved directly. It is the solution to the "simplest" possible problem. In the function factorial() of the previous example, the base case is the factorial of 1.  When factorial(1) is called, the Boolean expression value == 1 evaluates to True and signals the end of the recursions.</p>
<p>3)They must change their state and move toward the base case. A change of state means that the subprogram alters some of its data. Usually, data are getting smaller and smaller in some way. In the function factorial() of the previous example, since the base case is the factorial of 1, the whole concept relies on the idea of moving toward that base case.</p>
<p class="my_basic">In conclusion, recursion helps you write more creative and more elegant programs, but keep in mind that it is not always the best option. The main disadvantage of recursion is that it is hard for a programmer to think through the logic, and therefore it is difficult to debug a code that contains a recursive subprogram. Furthermore, a recursive algorithm may prove worse than a non-recursive one because it may consume too much CPU time and/or too much main memory (RAM). So, there are times where it would be better to follow the KISS principle and, instead of using a recursion, solve the algorithm using loop control structures.</p>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>For you who don't know what the KISS principle is, it is an acronym for “Keep It Simple, Stupid”! It states that most systems work best if they are kept simple, avoiding any unnecessary complexity!</p>
</div>
<h3 id="toc_9">36.9 Review Questions: True/False</h3>
<p class="my_basic">Choose true or false for each of the following statements.</p>
<p>1)Each subprogram uses its own memory space to hold the values of its variables.</p>
<p>2)Variables used in a subprogram "live" as long as the subprogram is being executed.</p>
<p>3)The only variables that “live” for as long as the Python program is being executed are the variables of the main code and the global variables.</p>
<p>4)A subprogram can call the main code.</p>
<p>5)If an argument is passed by value and its value is changed within the subprogram, it does not get changed outside of it.</p>
<p>6)The name of an actual argument and the name of the corresponding formal argument must be the same.</p>
<p>7)The total number of actual arguments cannot be greater than the total number of formal arguments.</p>
<p>8)An expression cannot be passed to a subprogram.</p>
<p>9)By default, lists in Python are passed by reference.</p>
<p>10)You can pass a list to a void function but the void function cannot return (directly or indirectly) a list to the caller.</p>
<p>11)A function can accept a list through its formal argument list.</p>
<p>12)In general, a void function can call any function.</p>
<p>13)In general, a function can call any void function.</p>
<p>14)Within a statement, a function can be called only once.</p>
<p>15)A void function can return a value through its formal argument list.</p>
<p>16)A subprogram can be called by another subprogram or by the main code.</p>
<p>17)If you assign a default value to an argument within the formal argument list, it means that no matter what value is passed for that argument, the default value is used.</p>
<p>18)An argument is called an optional argument when a default value is assigned to that argument within the actual argument list.</p>
<p>19)Optional arguments must be on the left side of any non-optional arguments.</p>
<p>20)The default value of an argument cannot be a string.</p>
<p>21)The scope of a variable refers to the range of effect of that variable.</p>
<p>22)If the value of a global variable is altered within a subprogram, this change is reflected outside the subprogram as well.</p>
<p>23)You can have two variables of global scope of the same name.</p>
<p>24)Recursion is a programming technique in which a subprogram calls itself.</p>
<p>25)A recursive algorithm must have a base case.</p>
<p>26)Using recursion to solve a problem is not always the best option.</p>
<h3 id="toc_10">36.10 Review Exercises</h3>
<p class="my_basic">Complete the following exercises.</p>
<p>1)Without using a trace table, can you find out what the next Python program displays?</p>
<div><p>def f1():</p>
<p>a = 22</p>
<p>def f2():</p>
<p>a = 33</p>
<div></div>
<p>a = 5</p>
<p>f1()</p>
<p>f2()</p>
<p>print(a)</p>
</div>
<p>2)Without using a trace table, can you find out what the next Python program displays?</p>
<div><p>def f1(number1):</p>
<p>return 2 * number1</p>
<div></div>
<p>def f2(number1, number2):</p>
<p>return f1(number1) + f1(number2)</p>
<div></div>
<p>a = 3</p>
<p>b = 4</p>
<p>print(f2(a, b))</p>
</div>
<p>3)Without using a trace table, can you find out what the next Python program displays?</p>
<div><p>def f1(number1):</p>
<p>return number1 * 2</p>
<div></div>
<p>def f2(number1, number2):</p>
<p>number1 = f1(number1)</p>
<p>number2 = f1(number2)</p>
<p>return number1 + number2</p>
<div></div>
<p>a = 2</p>
<p>b = 5</p>
<p>print(f2(a, b))</p>
</div>
<p>4)Without using a trace table, can you find out what the next Python program displays?</p>
<div><p>def display(s = "hello"):</p>
<p>s = s.replace("a", "e")</p>
<p>print(s, end = "")</p>
<div></div>
<p>display("hello")</p>
<p>display()</p>
<p>display("hallo")</p>
</div>
<p>5)Without using a trace table, can you find out what the next Python program displays?</p>
<div><p>def f1():</p>
<p>global a</p>
<p>a = a + b</p>
<div></div>
<p>a = 10</p>
<p>b = 5</p>
<p>f1()</p>
<p>b -= 1</p>
<div></div>
<p>print(a)</p>
</div>
<p>6)Without using a trace table, can you find out what the next Python program displays?</p>
<div><p>def f2():</p>
<p>global a</p>
<p>a = a + b</p>
<div></div>
<p>def f1():</p>
<p>global a</p>
<p>a = a + b</p>
<p>f2()</p>
<div></div>
<p>a = 3</p>
<p>b = 4</p>
<p>f1()</p>
<div></div>
<p>print(a, b)</p>
</div>
<p>7)Without using a trace table, can you find out what the next Python program displays?</p>
<div><p>def foo(a, b):</p>
<p>c = 0</p>
<p>for x in a:</p>
<div><blockquote><p>if x == b:</p></blockquote></div>
<div><blockquote><blockquote><p>c += 1</p></blockquote></blockquote></div>
<p>return c</p>
<div></div>
<p>print(foo([5, 9, 2, 5, 5], 5))</p>
</div>
<p>8)The following Python program is supposed to prompt the user to enter five integers into a list and then display, for each element, its number of digits and the integer itself. For example, if the user enters the values 35, 13565, 113, 278955, 9999, the program is supposed to display:</p>
<div><p>2 digits in number 35</p>
<p>5 digits in number 13565</p>
<p>3 digits in number 113</p>
<p>6 digits in number 278955</p>
<p>4 digits in number 9999</p>
</div>
<p class="my_basic ptab1 KBHeading">Unfortunately, the program displays</p>
<div><p>2 digits in number 0</p>
<p>5 digits in number 0</p>
<p>3 digits in number 0</p>
<p>6 digits in number 0</p>
<p>4 digits in number 0</p>
</div>
<p class="my_basic ptab1 KBHeading">Can you find out why?</p>
<div><p>ELEMENTS = 5</p>
<div></div>
<p>def getNumOfDigits(x, index):</p>
<p>count = 0</p>
<p>while x[index] != 0:</p>
<div><blockquote><p>count += 1</p></blockquote></div>
<div><blockquote><p>x[index] = x[index] // 10</p></blockquote></div>
<p>return count</p>
<div></div>
<p>#Main code starts here</p>
<p>val = [None] * ELEMENTS</p>
<div></div>
<p>for i in range(ELEMENTS):</p>
<p>val[i] = int(input())</p>
<div></div>
<p>for i in range(ELEMENTS):</p>
<p>print(getNumOfDigits(val, i), "digits in number", val[i])</p>
</div>
<p>9)For the following Python program, convert the parts marked with a dashed rectangle into subprograms.</p>
<div><p>STUDENTS = 10</p>
<p>LESSONS = 5</p>
<p>names = [None] * STUDENTS</p>
<p>grades = [[None] * LESSONS for i in range(STUDENTS)]</p>
<div></div>
<div><p>for i in range(STUDENTS):</p>
<p>names[i] = input("Enter name No. " + str(i + 1) + ": ")</p>
<p>for j in range(LESSONS):</p>
<div><blockquote><p>grades[i][j] = int(input("Enter grade for lesson No. " + str(j + 1) + ": "))</p></blockquote></div>
</div>
<div></div>
<div><p>average = [None] * STUDENTS</p>
<p>for i in range(STUDENTS):</p>
<p>average[i] = 0</p>
<p>for j in range(LESSONS):</p>
<div><blockquote><p>average[i] += grades[i][j]</p></blockquote></div>
<p>average[i] /= LESSONS</p>
</div>
<div></div>
<div><p>for m in range(1, STUDENTS):</p>
<p>for n in range(STUDENTS - 1, m - 1, -1):</p>
<div><blockquote><p>if average[n] &gt; average[n - 1]:</p></blockquote></div>
<div><blockquote><blockquote><p>average[n], average[n - 1] = average[n - 1], average[n]</p></blockquote></blockquote></div>
<div><blockquote><blockquote><p>names[n], names[n - 1] = names[n - 1], names[n]</p></blockquote></blockquote></div>
<div><blockquote><p>elif average[n] == average[n - 1]:</p></blockquote></div>
<div><blockquote><blockquote><p>if names[n] &lt; names[n - 1]:</p></blockquote></blockquote></div>
<div><blockquote><blockquote><blockquote><p>names[n], names[n - 1] = names[n - 1], names[n]</p></blockquote></blockquote></blockquote></div>
</div>
<div></div>
<p>for i in range(STUDENTS):</p>
<p>print(names[i], "\t", average[i])</p>
</div>
<p>10)For the following Python program, convert the parts marked with a dashed rectangle into subprograms.</p>
<div><div><p>message = input("Enter a message: ").lower()</p>
</div>
<div></div>
<div><div><p>messageClean = ""</p>
<p>for i in range(len(message)):</p>
<p>if message[i] not in " ,.?":</p>
<div><blockquote><p>messageClean += message[i]</p></blockquote></div>
</div>
<div></div>
<div><p>middlePos = (len(messageClean) - 1) // 2</p>
<p>j = len(messageClean) - 1</p>
<p>palindrome = True</p>
<p>for i in range(middlePos + 1):</p>
<p>if messageClean[i] != messageClean[j]:</p>
<div><blockquote><p>palindrome = False</p></blockquote></div>
<div><blockquote><p>break</p></blockquote></div>
<p>j -= 1</p>
</div>
</div>
<div></div>
<p>if palindrome:</p>
<p>print("The message is palindrome")</p>
</div>
<p>11)The next Python program finds the greatest value among four user-provided values. Rewrite the program without using subprograms.</p>
<div><p>def myMax(n, m):</p>
<p>if n &gt; m:</p>
<div><blockquote><p>m = n</p></blockquote></div>
<p>return m</p>
<div></div>
<p>a = int(input())</p>
<p>b = int(input())</p>
<p>c = int(input())</p>
<p>d = int(input())</p>
<div></div>
<p>maximum = a</p>
<p>maximum = myMax(b, maximum)</p>
<p>maximum = myMax(c, maximum)</p>
<p>maximum = myMax(d, maximum)</p>
<div></div>
<p>print(maximum)</p>
</div>
<p>12)Write two subprograms, a function and a void function. They must both accept three numbers through their formal argument list and then return their sum and average.</p>
<p>13)Write a subprogram named myRound that accepts a real (a float) and an integer through its formal argument list and then returns the real rounded to as many decimal places as the integer indicates. Moreover, if no value is passed for the integer, the subprogram must return the real rounded to two decimal places by default. Try not to use the round() function of Python.</p>
<p>14)Do the following:</p>
<p>i)Write a subprogram named getInput that prompts the user to enter an answer “yes” or “no” and then returns the value True or False correspondingly to the caller. Make the subprogram accept the answer in all possible forms such as “yes”, “YES”, “Yes”, “No”, “NO”, “nO”, and so on.</p>
<p>ii)Write a subprogram named findArea that accepts the base and the height of a parallelogram through its formal argument list and then returns its area.</p>
<p>iii)Using the subprograms cited above, write a Python program that prompts the user to enter the base and the height of a parallelogram and then calculates and displays its area. The program must iterate as many times as the user wishes. At the end of each calculation, the program must ask the user whether they wish to calculate the area of another parallelogram. If the answer is “yes” the program must repeat.</p>
<p>15)Do the following:</p>
<p>i)Write a subprogram named getLists that prompts the user to enter the grades and the names of 100 students into the lists grades and names, correspondingly. The two lists must be returned to the caller.</p>
<p>ii)Write a subprogram named getAverage that accepts the list grades through its formal argument list and returns the average grade.</p>
<p>iii)Write a subprogram named sortLists that accepts the lists grades and names through its formal argument list and sorts the list grades in descending order using the insertion sort algorithm. The subprogram must preserve the one-to-one correspondence between the elements of the two lists.</p>
<p>iv)Using the subprograms cited above, write a Python program that prompts the user to enter the grades and the names of 100 students and then displays all student names whose grade is less than the average grade, sorted by grade in descending order.</p>
<p>16)In a song contest, there is an artist who is scored by 10 judges. However, according to the rules of this contest, the total score is calculated after excluding the highest and lowest scores. Do the following:</p>
<p>i)Write a subprogram named getList that prompts the user to enter the scores of the 10 judges into a list and then returns the list to the caller. Assume that each score is unique.</p>
<p>ii)Write a subprogram named findMinMax that accepts a list through its formal argument list and then returns the maximum and the minimum value.</p>
<p>iii)Using the subprograms cited above, write a Python program that prompts the user to enter the name of the artist and the score they get from each judge. The program must then display the message “Artist NN got XX points” where NN and XX must be replaced by actual values.</p>
<p>17)Do the following:</p>
<p>i)Write a recursive function named sumRecursive that accepts an integer through its formal argument list and then returns the sum of numbers from 1 to that integer.</p>
<p>ii)Using the subprogram cited above, write a Python program that lets the user enter a positive integer, and then displays the sum of numbers from 1 to that user-provided integer.</p>
<p>18)On a chessboard you must place grains of wheat on each square, such that one grain is placed on the first square, two on the second, four on the third, and so on (doubling the number of grains on each subsequent square). Do the following:</p>
<p>i)Write a recursive function named woc that accepts the index of a square and returns the number of grains of wheat that are on this square. Since a chessboard contains 8 × 8 = 64 squares, assume that the index is an integer between 1 and 64.</p>
<p>ii)Using the subprogram cited above, write a Python program that calculates and displays the total number of grains of wheat that are on the chessboard in the end.</p>
<p>19)The Fibonacci sequence is a series of numbers in the following sequence:</p>
<p class="my_basic ptab1 center KBHeading">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …</p>
<p class="my_basic ptab1 KBHeading">By definition, the first two terms are 0 and 1 and each subsequent term is the sum of the previous two.</p>
<p class="my_basic ptab1 KBHeading">Do the following:</p>
<p>i)Write a recursive function named fib that accepts an integer through its formal argument list and then returns the N<sup>th</sup> term of the Fibonacci series.</p>
<p>ii)Using the subprogram cited above, write a Python program that lets the user enter a positive integer N and then displays the N<sup>th</sup> term of the Fibonacci series.</p>
<p>20)The Tribonacci sequence is similar to the Fibonacci sequence but each term is the sum of the three preceding terms. Write a recursive function named trib that accepts an integer through its formal argument list and then returns the N<sup>th</sup> term of the Tribonacci series.</p>
<p>21)Write a recursive function named myPow that accepts a real and an integer and then returns the result of the first number raised to the power of the second number, without using either the exponentiation operator ( ** ) or even the built-in pow() function of Python. Ensure that the function works correctly for both positive and negative exponent values.</p>
<p>22)Do the following:</p>
<p>i)Write a recursive function named factorial that accepts an integer through its formal argument list and then returns its factorial.</p>
<p>ii)Using the function cited above, write a recursive function named myCos that calculates and returns the cosine of x using the Taylor series, shown next.</p>
<p class="centered_image">.<img alt="Image" class="height4" src="img/chapter29-28.png"/></p>
<p class="my_basic ptab3 KBHeading">Hint: Keep in mind that x is in radians and <img alt="Image" class="height3" src="img/chapter29-25.png"/>.</p>
<p>iii)Using the function myCos() cited above, write a Python program that calculates and displays the cosine of 45<sup>o</sup>.</p>
<p class="my_basic ptab3 KBHeading">Hint: To verify the result, note that the cosine of 45<sup>o</sup> is approximately 0.7071067811865475.</p>
</div></div></body></html>