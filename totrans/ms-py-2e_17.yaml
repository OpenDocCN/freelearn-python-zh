- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extensions in C/C++, System Calls, and C/C++ Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last few chapters have shown us many machine learning and scientific computing
    libraries. Many of these libraries are not written in pure Python because of code
    reuse from existing libraries, or for performance reasons. In this chapter, we
    will learn how we can do some of this ourselves by creating C/C++ extensions.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 12*, *Performance – Tracking and Reducing Your Memory and CPU Usage*,
    we saw that the `cProfile` module is about 10 times faster than the `profile` module,
    which indicates that at least some C extensions are faster than their pure Python
    equivalents. This chapter will not focus on performance that much, however. The
    goal here is interaction with non-Python libraries. To paraphrase Linus Torvalds,
    any performance improvement will just be a completely unintentional side effect.
  prefs: []
  type: TYPE_NORMAL
- en: If performance is your main goal, you really should not be looking at writing
    a C/C++ extension manually. For the Python core modules, that was done, of course,
    but in most practical applications you are far better off using `numba` or `cython`.
    Or, if the use case allows, use pre-existing libraries such as `numpy` or `jax`.
    The main reason for using the tools in this chapter should be to reuse existing
    libraries so you don’t have to reinvent the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ctypes` for handling foreign (C/C++) functions and data from Python'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C Foreign Function Interface** (**CFFI**), similar to `ctypes`, but with
    a slightly different approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing native C/C++ to extend Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, it is important to note that this chapter will require a working
    compiler that plays nicely with your Python interpreter. Unfortunately, these
    vary from platform to platform. For Linux distributions, this can usually be achieved
    with one or two commands without much hassle.
  prefs: []
  type: TYPE_NORMAL
- en: For OS X, the experience is often very similar, mostly because the heavy lifting
    can be offloaded to package management systems such as Homebrew. For Windows,
    it can be slightly trickier, but that process has been streamlined over the last
    few years as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good and up-to-date starting point to get the required tooling is the Python
    Developer’s Guide: [https://devguide.python.org/setup/](https://devguide.python.org/setup/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For building the actual extensions, the Python manual can be useful: [https://docs.python.org/3/extending/building.html](https://docs.python.org/3/extending/building.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Do you need C/C++ modules?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In almost all cases, I’m inclined to say that you don’t need C/C++ modules.
    If you are really strapped for best performance, then there are almost always highly
    optimized Python libraries available that use C/C++/Fortran/etc. internally and
    fit your purpose. There are some cases where native C/C++ (or just “not Python”)
    is a requirement. If you need to communicate directly with hardware that has specific
    timings, then Python might not do the trick. Generally, however, that kind of
    communication should be left to an operating system kernel-level driver that takes
    care of the specific timings. Regardless, even if you will never write one of
    these modules yourself, you might still need to know how they work when you are
    debugging a project.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Windows, the general recommendation is Visual Studio. The specific version
    depends on your Python version:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python 3.4**: Microsoft Visual Studio 2010'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 3.5 and 3.6**: Microsoft Visual Studio 2015 or Visual Studio 2017'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 3.7–3.10**: Microsoft Visual Studio 2017'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2019 is also supported, but the official builds of Python 3.7
    to Python 3.10 still use Visual Studio 2017, making that the recommended solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specifics of installing Visual Studio and compiling Python modules fall
    somewhat outside the scope of this book. Luckily, the Python documentation has
    some documentation available to get you started: [https://devguide.python.org/setup/#windows](https://devguide.python.org/setup/#windows).'
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for a more Linux/Unix-like solution, you can also choose
    to use the GCC compiler through MinGW.
  prefs: []
  type: TYPE_NORMAL
- en: OS X
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a Mac, the process is mostly straightforward, but there are a few tips specific
    to OS X. First, install Xcode through the Mac App Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have done that, you should be able to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the fun part. Because OS X comes with a bundled Python version (which
    is generally out of date), I would recommend installing a new Python version through
    Homebrew instead. The most up-to-date instructions for installing Homebrew can
    be found on the Homebrew home page ([http://brew.sh/](http://brew.sh/)), but the
    gist of installing Homebrew is this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, make sure you check whether everything is set up correctly using
    the `doctor` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When all of this is done, simply install Python through Homebrew and make sure
    you use that Python release when executing your scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also ensure that the Python process is in `/usr/local/bin`, that is, the Homebrewed
    version. The regular OS X version would be in `/usr/bin/` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Linux/Unix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The installation for Linux/Unix systems greatly depends on the distribution,
    but it is generally simple to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Fedora, Red Hat, CentOS, and other systems that use `yum` as the package
    manager, use these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For Debian, Ubuntu, and other systems that use `apt` as the package manager,
    use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that Python 3.10 is not available everywhere yet, so you might need Python
    3.9 or even Python 3.8 instead.
  prefs: []
  type: TYPE_NORMAL
- en: For most systems, to get help with the installation, a web search along the
    lines of `<operating system> python.h` should do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: Calling C/C++ with ctypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ctypes` library makes it easily possible to call functions from C libraries,
    but you do need to be careful with memory access and data types. Python is generally
    very lenient in memory allocation and type-casting; C is, most definitely, not
    that forgiving.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though all platforms will have a standard C library available somewhere,
    the location and the method of calling it differs per platform. For the purpose
    of having a simple environment that is easily accessible to most people, I will
    assume the use of an Ubuntu (virtual) machine. If you don’t have a native Ubuntu
    machine available, you can easily run it through VirtualBox on Windows, Linux,
    and OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Since you will often want to run examples on your native system instead, we
    will first show the basics of loading `printf` from the standard C library.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One problem of calling C functions from Python is that the default libraries
    are platform-specific. While the following example will work just fine on Windows
    systems, it won’t run on other platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `c``types` library exposes the functions and attributes of the C/C++ library
    (`MSVCRT.DLL` in this case) to your Python installation. Since the `ms` part of
    `msvcrt` stands for Microsoft, this is one library you generally won’t find on
    non-Windows systems.
  prefs: []
  type: TYPE_NORMAL
- en: There is a difference between Linux/Unix and Windows in loading as well; on
    Windows, the modules will generally be auto-loaded, while on Linux/Unix systems,
    you will need to load them manually, because these systems will often have multiple
    versions of the same library available.
  prefs: []
  type: TYPE_NORMAL
- en: Linux/Unix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calling standard system libraries from Linux/Unix does require manual loading,
    but it’s luckily nothing too involved. Fetching the `printf` function from the
    standard C library is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: OS X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For OS X, explicit loading is also required, but beyond that, it is quite similar
    to how everything works on regular Linux/Unix systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Making it easy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides the way libraries are loaded, there are more differences, unfortunately,
    but the earlier examples at least give you the standard C library, which allows
    you to call functions such as `printf` straight from your C implementation. If,
    for some reason, you have trouble loading the right library, there is always the
    `ctypes.util.find_library` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, I would recommend explicit over implicit declarations, but things
    can be made easier in some cases using this function. To illustrate a run on an
    OS X system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Calling functions and native types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling a function through `ctypes` is nearly as simple as calling native Python
    functions. The notable difference is the arguments and `return` statements. These
    should be converted to native C variables.
  prefs: []
  type: TYPE_NORMAL
- en: These examples assume that you have `libc` in your scope from one of the examples
    in the previous paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create a C string that is effectively a memory block, with the
    characters as ASCII characters and terminated with a null character. After creating
    the C string, we will run `printf` on the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This output might look a bit confusing initially, so let’s analyze it. When
    we call `libc.printf` on `c_string`, it will write the string to `stdout` directly.
    Because of this, you can see that the output is interleaved (`some bytes>>>`)
    with the Python output, as this circumvents the Python output buffering and Python
    does not know this is happening. Additionally, you can see that `libc.printf`
    returned `10`, which is the number of bytes written to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the `printf` function, you *must*—and I cannot stress this enough—convert
    your values from Python to C explicitly. While it might appear to work without this initially,
    it really doesn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Remember to use the `faulthandler` module from *Chapter 11*, *Debugging – Solving
    the Bugs*, to debug `segfaults`.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note from the example is that `ctypes.sizeof(c_string)` returns
    `11` instead of `10`. This is caused by the trailing null character that C strings
    require, which is visible in the raw property of the C string.
  prefs: []
  type: TYPE_NORMAL
- en: Without it, the string functions in C such as `printf` won’t know where the
    string will end, since a C string is just a block of bytes in memory and C only
    knows at what memory address the string starts; the end is indicated by the null
    character. This is why memory management in C requires paying a lot of attention.
  prefs: []
  type: TYPE_NORMAL
- en: If you allocate a string of size 5 and write 10 bytes to it, you will be writing
    into the memory outside of your variable, which could be another function, another
    variable, or outside of your program’s memory. This would result in a segmentation
    fault.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python will generally protect you from silly mistakes; C and C++ most certainly
    won’t. To quote Bjarne Stroustrup (the creator of C++):'
  prefs: []
  type: TYPE_NORMAL
- en: '*“C makes it easy to shoot yourself in the foot; C++ makes it harder, but when
    you do, it blows away your whole leg.”*'
  prefs: []
  type: TYPE_NORMAL
- en: As opposed to C, C++ does have a string type to protect you in these cases.
    However, it is still a language where you have easy access to memory addresses
    and mistakes are easily made.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass along other types (such as integers) toward `libc` functions, we have
    to use some conversion as well. In some cases, it is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But not in all cases, so caution is advised, and explicitly converting is the
    safer option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to note that even though these values are usable as native C
    types, they are still mutable through the `value` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is the case unless the original object was immutable, which is a very important distinction
    to make. The `create_string_buffer` object creates a mutable string object, whereas `c_wchar_p`, `c_char_p`,
    and `c_void_p` create references to the actual Python string. Since strings are
    immutable in Python, these values are also immutable. You can still change the `value` property,
    but it will only assign a new string. Passing one of these immutable variables
    to a C function that mutates the internal value will result in unpredictable behavior
    and/or crashes.
  prefs: []
  type: TYPE_NORMAL
- en: The only values that should convert to C without any issues are integers, strings,
    and bytes, but I personally recommend that you always convert all of your values
    so that you are certain of which type you will get and how to treat it.
  prefs: []
  type: TYPE_NORMAL
- en: Complex data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen that we can’t just pass along Python values to C, but
    what if we need more complex objects such as classes or tuples? Luckily, we can
    easily create (and access) C structures using `ctypes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This supports any of the fundamental data types such as integers, floating-point
    numbers, and strings. Nesting is also supported; for instance, other structures
    could use `ComplexStructure` instead of `ctypes.c_int` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within Python, we generally use a `list` to represent a collection of objects.
    These are very convenient in that you can easily add and remove values. Within
    C, the default collection object is the **array**, which is just a block of memory
    with a fixed size.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the block in bytes is decided by multiplying the number of items
    by the size of the type. In the case of a `char`, this is `8` bits, so if you
    wish to store `100` chars, you would have `100 * 8 bits = 800 bits = 100 bytes`.
  prefs: []
  type: TYPE_NORMAL
- en: This is literally all it is—a block of memory—and the only reference you receive
    from C is a pointer to the memory address where the block of memory begins. Since
    the pointer does have a type, `char*` in this case, C will know how many bytes
    to jump ahead when trying to access a different item. Effectively, when trying
    to access item 25 in a `char` array, you simply need to do `array_pointer + 24
    * sizeof(char)`. This has a convenient shortcut: `array_pointer[24]`. Note that
    we need to access index 24 because we start counting at 0, just like with Python
    collections such as lists and strings.
  prefs: []
  type: TYPE_NORMAL
- en: Note that C does not store the number of items in the array, so even though
    our array has only 100 items, it won’t block us from doing `array_pointer[1000]` and
    reading other (random) memory. At some point, however, you will go outside of
    the reserved memory of your application and your operating system will punish
    you with a segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take all of these limitations into account, C arrays are definitely
    usable but mistakes are quickly made and C is unforgiving. No warnings; just crashes
    and strangely behaving code. Beyond that, let’s see how easily we can declare
    an array with `ctypes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, because of the fixed sizes and the requirement of declaring
    the type before using it, its usage is slightly awkward. However, it does function
    as you would expect. Additionally, as opposed to regular C, the values are initialized
    to zero by default and it will protect you from out-of-bound errors when accessing
    from Python. Naturally, this can be combined with our previously created custom
    structures as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though you cannot simply append to these arrays to resize them, they are
    actually resizable with a few constraints. Firstly, the new array needs to be
    larger than the original array. Secondly, the size needs to be specified in bytes,
    not items. To illustrate, we have this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As a starting point, the `TenNumbers` array has 10 items. Next up, we try to
    resize the array to 11, which works because it’s more than the original 10\. Resizing
    back to 10 is also allowed, but resizing to 9 items is not allowed because that
    is fewer than the 10 items we had originally.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we mutate a slice of items simultaneously, which works as you would
    expect.
  prefs: []
  type: TYPE_NORMAL
- en: Gotchas with memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the obvious memory allocation issues and mixing mutable and immutable
    objects, there is one more non-obvious memory mutability issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In regular Python, we can do something like `a, b = b, a` and it will work
    as you would expect because Python uses internal temporary variables. With regular
    C, you do not have that luxury, unfortunately; with `ctypes`, you do have the
    benefit of Python taking care of the temporary variable for you, but sometimes
    that can still go wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the first example, we get `2, 3, 0, 1` when swapping `a` and `b`, as expected.
    With the second example, we get `2, 3, 2, 3` instead. The problem is that these
    objects are copied to a temporary buffer variable, but the objects themselves
    are being changed in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s elaborate for a bit more clarity. With Python, when you do `a, b = b,
    a`, it will effectively run `temp = a; a = b; b = temp`. That way, the replacement
    works as expected and you will receive the correct values in `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: When you execute `a, b = b, a` in C, you effectively get `a = b; b = a`. By
    the time the `b = a` statement is executed, the value for `a` has already been
    changed by the `a = b` statement, so both `a` and `b` will have the original value
    of `b` at that point.
  prefs: []
  type: TYPE_NORMAL
- en: CFFI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CFFI` (C Foreign Function Interface) library offers options very similar
    to `ctypes`, but it’s a bit more direct. Unlike the `ctypes` library, a C compiler
    is really a necessity for CFFI. With it comes the opportunity to directly call
    your C compiler from Python in an easy way. We illustrate by calling `printf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Okay… so that looks a bit weird, right? We had to define how the `printf` function
    looks and specify the arguments to `printf` with a valid C function header. Additionally,
    we had to specify the C-string as a `char[]` array manually. With `ctypes`, that
    would not be required, but there are several advantages to `CFFI` as opposed to
    `ctypes`.
  prefs: []
  type: TYPE_NORMAL
- en: With CFFI, we can directly control what is sent to the C compiler, which gives
    us much more control over what is happening internally compared to `ctypes`. This
    means you can exactly control what types you feed the functions and what types
    you are returning, and you can use C macros.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, CFFI allows for easy reuse of existing C code. If the C code you
    are using has several `struct` definitions, you don’t have to manually map them
    to a `ctypes.Structure` class; you can use the `struct` definition straightaway.
    You can even write C code directly in your Python code and CFFI will take care
    of calling the compiler and building the library for you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to the declarations, you may notice that we called `ffi.dlopen`
    with a `None` parameter. When you pass `None` to this function, it will automatically
    load the entire C namespace; on non-Windows systems, at least. On Windows systems,
    you will need to explicitly tell CFFI which library to load.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember the `ctypes.util.find_library` function, you can use that again
    in this case, depending on your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: we can see here, the workings are initially quite comparable to `ctypes` and
    loading the library is just as easy. The big difference is when actually calling
    functions and using library attributes; those need to be explicitly defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the function signatures are almost always available in a C header
    file for your convenience so you don’t need to write those yourself. And that
    is one of the advantages of CFFI: it allows you to reuse existing C code.'
  prefs: []
  type: TYPE_NORMAL
- en: Complex data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CFFI` definitions are somewhat similar to the `ctypes` definitions, but
    instead of having Python emulating C, it’s just plain C that is accessible from
    Python. In reality, it’s only a small syntactical difference. While `ctypes` is
    a library for accessing C from Python while remaining as close to the Python syntax
    as possible, CFFI uses plain C syntax to access C systems, which actually removes
    some confusion for people experienced with C. I personally find CFFI easier to
    use because I have experience with C and know what is actually happening, whereas
    I am not always 100% certain with `ctypes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s repeat the `Vertex` and `Point` example with CFFI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the mutable variable issues remain, but the code is just as
    usable. Since the struct can be copied from your C headers, the only thing that
    remains for you is to allocate the memory for the vertex.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C, a regular `int` type variable `x` looks like `int x;`. A pointer to a
    memory address with size `int` looks like this: `int *x;`. The `int` part of the
    pointer tells the compiler how much memory to fetch when using the variable. To
    illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `&` operator returns the memory address for a variable and the `*` operator
    returns the value at the pointer’s address.
  prefs: []
  type: TYPE_NORMAL
- en: The special workings of CFFI allow you to shortcut these operations. Normally
    in C, using `vertex*` would only allocate the memory for the pointer, not the
    `vertex` itself. In the case of CFFI, that is taken care of automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Allocation memory for new variables is almost trivial with CFFI. The previous
    section showed you an example of a single `struct` allocation. Let’s now see how
    we can allocate an array of structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you might wonder why the slice includes both the start and the
    stop. This is a requirement for CFFI. Not problematic, but a tad annoying nonetheless.
    Luckily, as you can see in the example above, CFFI does protect us from allocating
    outside of the bounds of the array.
  prefs: []
  type: TYPE_NORMAL
- en: ABI or API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, there are some caveats. The examples so far have partially used the
    **ABI** (**application binary interface**), which loads the binary structures
    from the libraries. With the standard C library, this is generally safe; with
    other libraries, it generally isn’t. The difference between the **API** (**application
    programming interface**) and the ABI is that the latter calls the functions at
    a binary level, directly addressing memory, calling memory locations directly,
    and expecting them to be functions.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to do this, all sizes need to be consistent as well. When compiled
    as a 32-bit binary, a pointer will be 32 bits; when compiled as a 64-bit binary,
    a pointer will be 64 bits. That means that the offsets are not guaranteed to be
    consistent and you could be calling a random block of memory as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within CFFI, it’s the difference between `ffi.dlopen` and `ffi.set_source`.
    Here, `dlopen` is not always safe, but `set_source` is, because it passes a compiler
    instead of just guessing how to call a method. The downside of using `set_source`
    is that you need the actual source for the library you are planning to use. Let’s
    look at a quick example of using `ffi.set_source` to call a function we defined
    ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The initialization of CFFI is as normal, but instead of using `ffi.dlopen()`
    we are now using `ffi.set_source()` to directly pass the C code to CFFI. By doing
    this, CFFI can compile the library specifically for our system so we know that
    we will not run into ABI issues because we are creating the ABI ourselves with
    the call to `ffi.compile()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `ffi.compile()` step has completed, CFFI has created a `_sum.dll`,
    `sum.so`, or `_sum.cpython-...-os.so` file, which can be imported as a regular
    Python library. Now we will use the generated library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both `import _sum` and `ffi.dlopen(library)` work in this case.
    For use in production applications, I would recommend the `import _sum` method,
    but the `ffi.dlopen()` method can be very convenient to use from long-running
    applications such as Jupyter Notebooks. If you were to use `import _sum` and make
    a change in the library, it would not show your changes without you first calling
    `reload(_sum)`.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a C function, we need to pass a C array for complex types, which
    is why we are using `ffi.new()` here. After that, the function call is straightforward,
    but since a C array does not have a notion of size, we need to pass the array
    size for this to work.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily go out of bounds here and put in some arbitrary number instead
    of `N`, and the function will most likely work without crashes, but it will return
    very strange results because it will be summing random data in your memory.
  prefs: []
  type: TYPE_NORMAL
- en: CFFI or ctypes?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This really depends on what you are looking for. If you have a C library that
    you simply need to call and you don’t need anything special, then `ctypes` is
    most likely the easier choice. If you’re actually writing your own C library and
    trying to link to the library from Python, CFFI is probably a more convenient
    option.
  prefs: []
  type: TYPE_NORMAL
- en: In C/C++, linking a library means using an external pre-compiled library without
    requiring the source. You do need to have the header files, which contain details
    such as the function arguments and return types. This is exactly what we are doing
    when we use CFFI in ABI mode.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with the C programming language, then I would definitely
    recommend `ctypes` or perhaps `cython`.
  prefs: []
  type: TYPE_NORMAL
- en: Native C/C++ extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The libraries that we have used so far only showed us how to access a C/C++
    library within our Python code. Now we are going to look at the other side of
    the story: how C/C++ functions/modules within Python are actually written and
    how modules such as `cPickle` and `cProfile` are created.'
  prefs: []
  type: TYPE_NORMAL
- en: A basic example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can actually start with writing and using native C/C++ extensions,
    we have a few prerequisites. First of all, we need the compiler and Python headers;
    the instructions at the beginning of this chapter should have taken care of this
    for us. After that, we need to tell Python what to compile. The `setuptools` package
    mostly takes care of this, but we do need to create a `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This tells Python that we have an `Extension` object named `sum_of_squares` that
    will be based on `sum_of_squares.c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s write a function in C that sums all perfect squares (`2*2`, `3*3`,
    and so on) up to a given number. The Python code will be stored in `sum_of_squares_python.py`
    and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The raw C version of this code would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how the C code looks, we will create the actual C Python version
    that we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen with `ctypes` and `CFFI`, Python and C have different data types
    and some conversion needs to be done. Since the CPython interpreter is written
    in C, it has definitions specifically to take care of this translation step.
  prefs: []
  type: TYPE_NORMAL
- en: To load these definitions, we need to include `Python.h`, which are the CPython
    header files that should have everything you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look carefully, you will see that the actual summing code is identical
    to the C version, but we need quite a few conversion steps to make Python understand
    what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks quite complicated, but it’s really not that hard. There is just a
    lot of overhead in this case because we only have a single function. Generally,
    you would have several functions, in which case you only need to expand the `methods` array
    and create the functions. We will explain the code in more detail shortly, but
    first, let’s look at how to run our first example. We need to build and install
    the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create a little test script to time the difference between the Python
    version and the C version. First, some imports and setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the modules imported (or got an error if you hadn’t run the
    build step yet), we can start benchmarking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In essence, we have a basic benchmarking script where we compare the C version
    to the Python version here, with a configurable number of repetitions and a maximum
    number to test for. Now, let’s execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Exactly the same results but much faster.
  prefs: []
  type: TYPE_NORMAL
- en: If your goal is speed alone, you should give `numba` a try instead. Adding the
    `@numba.njit` decorator to `sum_of_squares_python` is much easier and probably
    even faster.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of writing C modules is the reuse of existing C code, however.
    For speedups, you are often better off with `cython`, `numba`, or converting your
    code to use libraries such as `numpy` or `jax`.
  prefs: []
  type: TYPE_NORMAL
- en: C is not Python – Size matters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python language makes programming so easy that you might forget about the
    underlying data structures at times; with C and C++, you can’t afford to do that.
    Just take our example from the previous section but with different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It’s still very fast, but what happened to the numbers? The Python and C versions
    give different results, `1953214233` versus `10543148825`. This is caused by integer
    overflows in C. While Python numbers can essentially have any size, with C, a
    regular number has a fixed size. How much you get depends on the type you use
    (`int`, `long`, and so on) and your architecture (32-bit, 64-bit, and so on),
    but it’s definitely something to be careful with. It might be hundreds of times
    faster in some cases, but that is meaningless if the results are incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can increase the size a bit, of course. This makes it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We used `typedef` to create a `bigint` alias for `unsigned long long int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we test it now, we realize that it works great:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: And with the increased size, the difference in performance increases as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the number even larger breaks things again since even an `unsigned long
    long int` still has its limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: So, how can you fix this? The simple answer is that you can’t, and Python hasn’t
    really fixed it either. The complex answer is that you can if you use a different
    data type to store your data. The C language by itself doesn’t have the “big number
    support” that Python has.
  prefs: []
  type: TYPE_NORMAL
- en: Python supports infinitely large numbers by combining several regular numbers
    in the actual memory and automatically switches to those types of numbers when
    needed. With Python 2, that was much more obvious with the distinction between
    the `int` and `long` types. With Python 3, the `long` and `int` types have been
    merged into the `int` type. You will not notice the switchover to the `long` type;
    it will automatically happen in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within C, there are no commonly available provisions for this, so there is
    simply no easy way to get this working. But we can check for errors instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that this only works for `PyObject*`, which means it doesn’t work for internal
    C overflows. However, you can, of course, just keep the original Python long around
    and perform operations on that instead. So, you do have big number support in
    C without too much effort.
  prefs: []
  type: TYPE_NORMAL
- en: The example explained
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the results from our example, but if you’re not familiar with the
    Python C API, you might be confused as to why the function parameters look the
    way they do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic calculations within `sum_of_squares` are identical to the regular
    C `sum_of_squares` function, but there are a few small differences. Firstly, the
    type definition for a function using the Python C API should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break this down.
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that the function is **static**. A function that’s static can be
    called only from the same translation unit within the compiler. This effectively
    results in a function that cannot be linked (imported/used) from other modules,
    which allows the compiler to optimize a bit further. Since functions in C are
    global by default, this can be very useful in preventing naming collisions. Just
    to be sure, however, you could prefix your function names with the name of the
    module if you use a name that is less likely to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to confuse the word `static` here with the `static` before a
    variable. They are completely different beasts. A `static` variable means that
    the variable will exist for the entire runtime of the program instead of the runtime
    of just the function.
  prefs: []
  type: TYPE_NORMAL
- en: PyObject*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `PyObject` type is the basic type for Python data types, which means that
    all Python objects can be cast to `PyObject*` (the `PyObject` pointer). Effectively,
    it only tells the compiler what kind of properties to expect, which can be used
    later for type identification and memory management. Instead of direct access
    to `PyObject*`, it is generally a better idea to use the available macros, such
    as `Py_TYPE(some_object)`. Internally, this expands to `(((PyObject*)(o))->ob_type)`,
    which is why the macro is generally a better idea. Besides being unreadable, a
    typo can easily happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of properties is long and depends greatly on the type of object. For
    those, you can refer to the Python documentation: [https://docs.python.org/3/c-api/typeobj.html](https://docs.python.org/3/c-api/typeobj.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The entire Python C API could fill a book of its own, but it is luckily well
    documented within the Python manual. Its usage, on the other hand, might be less
    obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With regular C and Python, you specify the arguments explicitly, since variable-sized
    arguments are a bit tricky with C. This is because they need to be parsed separately. `PyObject*
    args` is the reference to objects containing the actual values. To parse these,
    you need to know how many and which type of variables to expect. In the example,
    we used the `PyArg_ParseTuple` function, which parses the arguments as positional
    arguments only, but it is quite easily possible to parse named arguments as well
    using `PyArg_ParseTupleAndKeywords` or `PyArg_VaParseTupleAndKeywords`. The difference
    between these is that the first one uses a variable number of arguments to specify
    the destination and the latter uses a `va_list` to set the values to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the code from the actual example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We know that `args` is the object containing the reference to the actual arguments.
    The `"i"` is a format string, which in this case will try to parse a single integer.
    `&n` tells the function to store the value at the memory address of the `n` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The format string is the important part here. Depending on the character, you
    get a different data type, but there are many; `i` specifies a regular integer,
    and `s` converts your variable to a C-string (actually a `char*`, which is a null-terminated
    character array). It should be noted that this function is, luckily, smart enough
    to take overflows into consideration as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parsing multiple arguments is quite similar; you need to add multiple characters
    to the format string and multiple destination variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The version with keyword arguments is similar, but requires a few more code
    changes as the list of methods needs to be informed that the function takes keyword
    arguments. Otherwise, the `kwargs` parameter would never arrive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the differences from the version that only supported `*args`:'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to pure Python, our function header now includes `PyObject *kwargs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we need to pre-allocate strings in C, we have an array of words called
    `keywords` with all of the `kwargs` we plan to parse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of `PyArg_ParseTuple` we now have to use `PyArg_ParseTupleAndKeywords`.
    This function overlaps the `PyArg_ParseTuple` function and adds keyword parsing
    by walking through the previously defined `keywords` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the function registry, we need to specify that the function supports keyword
    arguments by adding the `METH_KEYWORDS` flag in addition to the `METH_VARARGS`
    flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this still supports normal arguments, but keyword arguments are also
    supported now.
  prefs: []
  type: TYPE_NORMAL
- en: C is not Python – Errors are silent or lethal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in a previous example, integer overflows are not something you will
    generally notice, and unfortunately, there’s no good cross-platform way to catch
    them. However, those are actually the easier errors to handle; the worst one is
    generally memory management. With Python, if you get an error, you will get an
    exception that you can catch. With C, you can’t really handle it gracefully. Take
    a division by zero, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simple enough to catch with `try: ... except ZeroDivisionError: ...`.
    With C, on the other hand, if you get a bad error, it will kill your entire process.
    But debugging C code is what C compilers have debuggers for, and to find the cause
    of the error, you can use the `faulthandler` module discussed in *Chapter 11*, *Debugging
    – Solving the Bugs*. Right now, let’s see how we can properly throw errors from
    C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When executing this, it will effectively run `raise RuntimeError('Too many eggs!')`.
    The syntax is slightly different—`PyErr_SetString` instead of `raise`—but it’s
    the same basic principle.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Python from C – Handling complex types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to call C functions from Python, but now let’s try Python from
    C and back. Instead of using the readily available `sum` function, we will build
    one of our own with a callback and handling of any type of iterable. While this
    sounds simple enough, it does actually require a bit of type meddling, as you
    can only expect `PyObject*` as arguments. This is contrary to the simple types,
    such as integers, chars, and strings, which are immediately converted to the native
    Python version.
  prefs: []
  type: TYPE_NORMAL
- en: For clarity, this is just a single function that is broken up into multiple
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start with the `include` function signature, and the declaration
    of the variables we need. Note that the values for `total` and `callback` are
    defaults in the event that these arguments are not specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we parse a `PyObject*` followed by, optionally (the | character), a `PyObject*`
    and a `long long int`. This is specified by the `O|OL` argument. The results will
    be stored in the memory addresses (the `&` sends the memory address of a variable)
    of `iterable`, `callback`, and `total`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We see if we can create an iterator from the iterable. This is effectively
    the same as doing `iter(iterable)` in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we check whether the callback exists or wasn’t specified. If it was specified,
    check whether it’s callable or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Looping through the iterable, if we have a callback available, we call it.
    Otherwise, we just use the `item` as the `value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the value to `total` and check for overflows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If we were indeed using the callback, we decrease the reference count to the
    value because it is a separate object now.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to dereference `item` and the iterator. Forgetting to do this results
    in memory leaks because it decreases the reference count for the Python garbage
    collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, always make sure you call the `PyDECREF` function after using `PyObject*`
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to convert `total` to the correct return type and return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is callable in three different ways. When given only an iterable,
    it will sum the iterable and return the value. Optionally, we can pass a callback
    function, which will be applied to each value in the iterable before summing.
    As a second optional parameter, we can specify the initial value to start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important issue is that even though we catch overflow errors when converting
    to `long long int`, this code is still not safe. If we sum even two very large
    numbers (close to the `long long int` limit), we will still have an overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you could test for this by doing something like `if(value > INT_MAX
    - total)`, but that solution does not always apply, so it is most important to
    be conscious of overflows and underflows when using C.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The possibilities with external libraries are endless, so perhaps you already
    have some ideas about what to implement. If not, here’s some inspiration:'
  prefs: []
  type: TYPE_NORMAL
- en: Try to sort a list of numbers using `ctypes`, `CFFI`, and with a native extension.
    You can use the `qsort` function in `stdlib`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to make the `custom_sum` function we created safer by adding proper errors
    for overflow/underflow issues. Additionally, catch the errors when summing multiple
    numbers that only overflow or underflow in summation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These exercises should be a nice starting point for doing something useful
    with your newly acquired knowledge. If you are looking for more of the native
    C/C++ examples, I would recommend looking through the CPython source. There are
    many examples available: [https://github.com/python/cpython/tree/main/Modules](https://github.com/python/cpython/tree/main/Modules).
    I would suggest starting with a relatively simple one such as the `bisect` module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_17.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about writing and using extensions in C/C++. As
    a quick recap, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading external (system) libraries such as `stdlib` using `ctypes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and handling complex data structures using `ctypes` and `CFFI`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling arrays using `ctypes` and `CFFI`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining C and Python functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important caveats regarding numeric types, arrays, overflows, and other error
    handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though you can now create C/C++ extensions, I still recommend that you
    avoid them, if possible, because it is so easy to end up with bugs. Even the code
    examples in this chapter don’t handle many of the possible error scenarios and,
    as opposed to errors in Python, if these errors happen in C, they can kill your
    interpreter or application entirely.
  prefs: []
  type: TYPE_NORMAL
- en: If your goal is better performance, then I would recommend trying `numba` or
    `cython` instead. If you really need interoperability with non-Python libraries,
    however, these libraries are good options. A few examples of universal libraries
    such as these are TensorFlow and OpenCV, which are available in many languages
    and have Python wrappers for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'While building the examples in this chapter, you may have noticed that we used
    a `setup.py` file and imported from the `setuptools` library. This is what the
    next chapter will cover: packaging your code into an installable Python library
    and distributing it on the Python Package Index.'
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
