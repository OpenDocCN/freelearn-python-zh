- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Extensions in C/C++, System Calls, and C/C++ Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C/C++ 扩展、系统调用和 C/C++ 库
- en: The last few chapters have shown us many machine learning and scientific computing
    libraries. Many of these libraries are not written in pure Python because of code
    reuse from existing libraries, or for performance reasons. In this chapter, we
    will learn how we can do some of this ourselves by creating C/C++ extensions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几章向我们展示了众多机器学习和科学计算库。许多这些库并非纯 Python 编写，因为它们从现有库中复用代码，或者出于性能考虑。在本章中，我们将学习如何通过创建
    C/C++ 扩展来实现其中的一些功能。
- en: In *Chapter 12*, *Performance – Tracking and Reducing Your Memory and CPU Usage*,
    we saw that the `cProfile` module is about 10 times faster than the `profile` module,
    which indicates that at least some C extensions are faster than their pure Python
    equivalents. This chapter will not focus on performance that much, however. The
    goal here is interaction with non-Python libraries. To paraphrase Linus Torvalds,
    any performance improvement will just be a completely unintentional side effect.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 12 章*，*性能 – 跟踪和减少你的内存和 CPU 使用* 中，我们了解到 `cProfile` 模块比 `profile` 模块快约 10
    倍，这表明至少一些 C 扩展比它们的纯 Python 等效物更快。然而，本章不会过多关注性能。这里的目的是与非 Python 库的交互。用 Linus Torvalds
    的话来说，任何性能提升都将是完全无意的结果。
- en: If performance is your main goal, you really should not be looking at writing
    a C/C++ extension manually. For the Python core modules, that was done, of course,
    but in most practical applications you are far better off using `numba` or `cython`.
    Or, if the use case allows, use pre-existing libraries such as `numpy` or `jax`.
    The main reason for using the tools in this chapter should be to reuse existing
    libraries so you don’t have to reinvent the wheel.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能是你的主要目标，你真的不应该考虑手动编写 C/C++ 扩展。对于 Python 核心模块，当然已经这样做了，但在大多数实际应用中，使用 `numba`
    或 `cython` 会更好。或者，如果用例允许，可以使用预存的库，如 `numpy` 或 `jax`。使用本章中工具的主要原因应该是复用现有库，这样你就不必重新发明轮子。
- en: 'We will discuss the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: '`ctypes` for handling foreign (C/C++) functions and data from Python'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctypes` 用于处理来自 Python 的外部（C/C++）函数和数据'
- en: '**C Foreign Function Interface** (**CFFI**), similar to `ctypes`, but with
    a slightly different approach'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C 外部函数接口**（**CFFI**），类似于 `ctypes`，但采用略有不同的方法'
- en: Writing native C/C++ to extend Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写原生 C/C++ 以扩展 Python
- en: Setting up tooling
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置工具
- en: Before we begin, it is important to note that this chapter will require a working
    compiler that plays nicely with your Python interpreter. Unfortunately, these
    vary from platform to platform. For Linux distributions, this can usually be achieved
    with one or two commands without much hassle.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，重要的是要注意，本章将需要一个与你的 Python 解释器兼容的编译器。不幸的是，这些编译器因平台而异。对于 Linux 发行版，通常可以通过一两个命令轻松实现，而无需太多麻烦。
- en: For OS X, the experience is often very similar, mostly because the heavy lifting
    can be offloaded to package management systems such as Homebrew. For Windows,
    it can be slightly trickier, but that process has been streamlined over the last
    few years as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OS X，体验通常非常相似，主要是因为繁重的工作可以委托给包管理系统，如 Homebrew。对于 Windows，可能会稍微复杂一些，但这个过程在过去几年中已经简化了。
- en: 'A good and up-to-date starting point to get the required tooling is the Python
    Developer’s Guide: [https://devguide.python.org/setup/](https://devguide.python.org/setup/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所需工具的一个良好且最新的起点是 Python 开发者指南：[https://devguide.python.org/setup/](https://devguide.python.org/setup/).
- en: 'For building the actual extensions, the Python manual can be useful: [https://docs.python.org/3/extending/building.html](https://docs.python.org/3/extending/building.html).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建实际的扩展，Python 手册可能会有所帮助：[https://docs.python.org/3/extending/building.html](https://docs.python.org/3/extending/building.html).
- en: Do you need C/C++ modules?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你需要 C/C++ 模块吗？
- en: In almost all cases, I’m inclined to say that you don’t need C/C++ modules.
    If you are really strapped for best performance, then there are almost always highly
    optimized Python libraries available that use C/C++/Fortran/etc. internally and
    fit your purpose. There are some cases where native C/C++ (or just “not Python”)
    is a requirement. If you need to communicate directly with hardware that has specific
    timings, then Python might not do the trick. Generally, however, that kind of
    communication should be left to an operating system kernel-level driver that takes
    care of the specific timings. Regardless, even if you will never write one of
    these modules yourself, you might still need to know how they work when you are
    debugging a project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，我倾向于认为你不需要C/C++模块。如果你真的需要最佳性能，那么几乎总是有高度优化的Python库可用，它们内部使用C/C++/Fortran等，并且适合你的需求。有些情况下，原生C/C++（或只是“非Python”）是必需的。如果你需要直接与具有特定时序的硬件通信，那么Python可能不起作用。然而，通常这类通信应留给操作系统内核级驱动程序来处理特定的时序。无论如何，即使你永远不会自己编写这些模块，当你调试项目时，你可能仍然需要了解它们是如何工作的。
- en: Windows
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: 'For Windows, the general recommendation is Visual Studio. The specific version
    depends on your Python version:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，一般推荐使用Visual Studio。具体版本取决于你的Python版本：
- en: '**Python 3.4**: Microsoft Visual Studio 2010'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 3.4**: Microsoft Visual Studio 2010'
- en: '**Python 3.5 and 3.6**: Microsoft Visual Studio 2015 or Visual Studio 2017'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 3.5和3.6**: Microsoft Visual Studio 2015或Visual Studio 2017'
- en: '**Python 3.7–3.10**: Microsoft Visual Studio 2017'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 3.7–3.10**: Microsoft Visual Studio 2017'
- en: Visual Studio 2019 is also supported, but the official builds of Python 3.7
    to Python 3.10 still use Visual Studio 2017, making that the recommended solution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2019也受到支持，但Python 3.7到Python 3.10的官方构建仍然使用Visual Studio 2017，因此这是推荐解决方案。
- en: 'The specifics of installing Visual Studio and compiling Python modules fall
    somewhat outside the scope of this book. Luckily, the Python documentation has
    some documentation available to get you started: [https://devguide.python.org/setup/#windows](https://devguide.python.org/setup/#windows).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Visual Studio和编译Python模块的具体细节超出了本书的范围。幸运的是，Python文档提供了一些文档来帮助你入门：[https://devguide.python.org/setup/#windows](https://devguide.python.org/setup/#windows)。
- en: If you are looking for a more Linux/Unix-like solution, you can also choose
    to use the GCC compiler through MinGW.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个更类似Linux/Unix的解决方案，你也可以选择通过MinGW使用GCC编译器。
- en: OS X
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OS X
- en: For a Mac, the process is mostly straightforward, but there are a few tips specific
    to OS X. First, install Xcode through the Mac App Store.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mac，这个过程主要是直接的，但也有一些针对OS X的特定提示。首先，通过Mac App Store安装Xcode。
- en: 'Once you have done that, you should be able to run the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些，你应该能够运行以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next up is the fun part. Because OS X comes with a bundled Python version (which
    is generally out of date), I would recommend installing a new Python version through
    Homebrew instead. The most up-to-date instructions for installing Homebrew can
    be found on the Homebrew home page ([http://brew.sh/](http://brew.sh/)), but the
    gist of installing Homebrew is this command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是更有趣的部分。因为OS X自带了一个捆绑的Python版本（通常已经过时），我建议通过Homebrew安装一个新的Python版本。安装Homebrew的最新说明可以在Homebrew主页上找到（[http://brew.sh/](http://brew.sh/)），但安装Homebrew的基本命令如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that, make sure you check whether everything is set up correctly using
    the `doctor` command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，请确保使用`doctor`命令检查一切是否设置正确：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When all of this is done, simply install Python through Homebrew and make sure
    you use that Python release when executing your scripts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些完成后，只需通过Homebrew安装Python，并确保在执行脚本时使用该Python版本：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Also ensure that the Python process is in `/usr/local/bin`, that is, the Homebrewed
    version. The regular OS X version would be in `/usr/bin/` instead.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保Python进程在`/usr/local/bin`中，即Homebrew版本。常规OS X版本将在`/usr/bin/`中。
- en: Linux/Unix
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux/Unix
- en: The installation for Linux/Unix systems greatly depends on the distribution,
    but it is generally simple to do.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux/Unix系统的安装，很大程度上取决于发行版，但通常很简单。
- en: 'For Fedora, Red Hat, CentOS, and other systems that use `yum` as the package
    manager, use these lines:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用`yum`作为包管理器的Fedora、Red Hat、CentOS和其他系统，使用以下命令：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For Debian, Ubuntu, and other systems that use `apt` as the package manager,
    use the following line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用`apt`作为包管理器的Debian、Ubuntu和其他系统，使用以下命令：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that Python 3.10 is not available everywhere yet, so you might need Python
    3.9 or even Python 3.8 instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python 3.10 目前并非在所有地方都可用，因此你可能需要使用 Python 3.9 或甚至 Python 3.8。
- en: For most systems, to get help with the installation, a web search along the
    lines of `<operating system> python.h` should do the trick.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数系统，要获取安装帮助，进行类似 `<操作系统> python.h` 的网络搜索应该可以解决问题。
- en: Calling C/C++ with ctypes
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ctypes 调用 C/C++
- en: The `ctypes` library makes it easily possible to call functions from C libraries,
    but you do need to be careful with memory access and data types. Python is generally
    very lenient in memory allocation and type-casting; C is, most definitely, not
    that forgiving.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctypes` 库使得从 C 库调用函数变得非常容易，但你确实需要小心内存访问和数据类型。Python 通常在内存分配和类型转换方面非常宽容；而 C
    则绝对不是那么宽容。'
- en: Platform-specific libraries
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台特定库
- en: Even though all platforms will have a standard C library available somewhere,
    the location and the method of calling it differs per platform. For the purpose
    of having a simple environment that is easily accessible to most people, I will
    assume the use of an Ubuntu (virtual) machine. If you don’t have a native Ubuntu
    machine available, you can easily run it through VirtualBox on Windows, Linux,
    and OS X.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有平台都会在某个地方提供标准 C 库，但它的位置和调用方式因平台而异。为了拥有一个简单且易于大多数人访问的环境，我将假设使用 Ubuntu（虚拟）机器。如果你没有可用的原生
    Ubuntu 机器，你可以在 Windows、Linux 和 OS X 上通过 VirtualBox 运行它。
- en: Since you will often want to run examples on your native system instead, we
    will first show the basics of loading `printf` from the standard C library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你通常会希望在本地系统上运行示例，我们将首先展示从标准 C 库加载 `printf` 的基础知识。
- en: Windows
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: 'One problem of calling C functions from Python is that the default libraries
    are platform-specific. While the following example will work just fine on Windows
    systems, it won’t run on other platforms:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 调用 C 函数的一个问题是默认库是平台特定的。虽然以下示例在 Windows 系统上可以正常运行，但在其他平台上则无法运行：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `c``types` library exposes the functions and attributes of the C/C++ library
    (`MSVCRT.DLL` in this case) to your Python installation. Since the `ms` part of
    `msvcrt` stands for Microsoft, this is one library you generally won’t find on
    non-Windows systems.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`c` `types` 库将 C/C++ 库（在本例中为 `MSVCRT.DLL`）的函数和属性暴露给 Python 安装。由于 `ms` 部分代表
    Microsoft，这是一个你通常在非 Windows 系统上找不到的库。'
- en: There is a difference between Linux/Unix and Windows in loading as well; on
    Windows, the modules will generally be auto-loaded, while on Linux/Unix systems,
    you will need to load them manually, because these systems will often have multiple
    versions of the same library available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载方面，Linux/Unix 和 Windows 之间也存在差异；在 Windows 上，模块通常会被自动加载，而在 Linux/Unix 系统上，你需要手动加载它们，因为这些系统通常会提供同一库的多个版本。
- en: Linux/Unix
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux/Unix
- en: 'Calling standard system libraries from Linux/Unix does require manual loading,
    but it’s luckily nothing too involved. Fetching the `printf` function from the
    standard C library is quite simple:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Linux/Unix 调用标准系统库确实需要手动加载，但幸运的是，这并不复杂。从标准 C 库获取 `printf` 函数相当简单：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: OS X
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OS X
- en: 'For OS X, explicit loading is also required, but beyond that, it is quite similar
    to how everything works on regular Linux/Unix systems:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OS X，也需要显式加载，但除此之外，它与常规的 Linux/Unix 系统上的工作方式相当相似：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Making it easy
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使其变得简单
- en: Besides the way libraries are loaded, there are more differences, unfortunately,
    but the earlier examples at least give you the standard C library, which allows
    you to call functions such as `printf` straight from your C implementation. If,
    for some reason, you have trouble loading the right library, there is always the
    `ctypes.util.find_library` function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了库的加载方式之外，不幸的是还有更多差异，但至少早期的示例为你提供了标准 C 库，这允许你直接从 C 实现中调用如 `printf` 这样的函数。如果你由于某种原因加载正确的库有困难，`ctypes.util.find_library`
    函数总是可用。
- en: 'As always, I would recommend explicit over implicit declarations, but things
    can be made easier in some cases using this function. To illustrate a run on an
    OS X system:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我推荐使用显式声明而不是隐式声明，但在某些情况下，使用此函数可以使事情变得更容易。以下是在 OS X 系统上运行的示例：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Calling functions and native types
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用函数和本地类型
- en: Calling a function through `ctypes` is nearly as simple as calling native Python
    functions. The notable difference is the arguments and `return` statements. These
    should be converted to native C variables.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ctypes`调用函数几乎和调用原生Python函数一样简单。值得注意的是参数和`return`语句。这些应该转换为原生C变量。
- en: These examples assume that you have `libc` in your scope from one of the examples
    in the previous paragraphs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例假设你从上一段中的某个示例中已经有了`libc`。
- en: 'We will now create a C string that is effectively a memory block, with the
    characters as ASCII characters and terminated with a null character. After creating
    the C string, we will run `printf` on the string:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个C字符串，它实际上是一个内存块，字符为ASCII字符，并以空字符结尾。在创建C字符串后，我们将对字符串运行`printf`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This output might look a bit confusing initially, so let’s analyze it. When
    we call `libc.printf` on `c_string`, it will write the string to `stdout` directly.
    Because of this, you can see that the output is interleaved (`some bytes>>>`)
    with the Python output, as this circumvents the Python output buffering and Python
    does not know this is happening. Additionally, you can see that `libc.printf`
    returned `10`, which is the number of bytes written to `stdout`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出一开始可能看起来有点混乱，所以让我们分析一下。当我们对`c_string`调用`libc.printf`时，它将直接将字符串写入`stdout`。正因为如此，你可以看到输出是交织的（`some
    bytes>>>`）与Python输出，因为这绕过了Python输出缓冲区，Python并不知道这件事正在发生。此外，你可以看到`libc.printf`返回了`10`，这是写入`stdout`的字节数。
- en: 'To call the `printf` function, you *must*—and I cannot stress this enough—convert
    your values from Python to C explicitly. While it might appear to work without this initially,
    it really doesn’t:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`printf`函数，你*必须*——我无法强调这一点——明确地将你的值从Python转换为C。虽然一开始可能看起来不需要这样做也能工作，但实际上并不是这样：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Remember to use the `faulthandler` module from *Chapter 11*, *Debugging – Solving
    the Bugs*, to debug `segfaults`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记得使用第11章的`faulthandler`模块来调试`segfaults`。
- en: Another thing to note from the example is that `ctypes.sizeof(c_string)` returns
    `11` instead of `10`. This is caused by the trailing null character that C strings
    require, which is visible in the raw property of the C string.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中还可以注意到，`ctypes.sizeof(c_string)`返回`11`而不是`10`。这是由于C字符串所需的尾随空字符造成的，这在C字符串的原始属性中是可见的。
- en: Without it, the string functions in C such as `printf` won’t know where the
    string will end, since a C string is just a block of bytes in memory and C only
    knows at what memory address the string starts; the end is indicated by the null
    character. This is why memory management in C requires paying a lot of attention.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 没有它，C语言中的字符串函数（如`printf`）将不知道字符串在哪里结束，因为C字符串只是内存中的一块字节，C只知道字符串的起始内存地址；结束由空字符指示。这就是为什么C语言中的内存管理需要非常注意。
- en: If you allocate a string of size 5 and write 10 bytes to it, you will be writing
    into the memory outside of your variable, which could be another function, another
    variable, or outside of your program’s memory. This would result in a segmentation
    fault.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分配了一个大小为5的字符串并写入10个字节，你将写入你的变量之外的内存，这可能是另一个函数、另一个变量，或者程序内存之外。这将导致段错误。
- en: 'Python will generally protect you from silly mistakes; C and C++ most certainly
    won’t. To quote Bjarne Stroustrup (the creator of C++):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python通常会保护你免受愚蠢的错误；C和C++则绝对不会。引用Bjarne Stroustrup（C++的创造者）的话：
- en: '*“C makes it easy to shoot yourself in the foot; C++ makes it harder, but when
    you do, it blows away your whole leg.”*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*“C语言让你容易踩到自己的脚；C++语言让你更难，但当你这么做时，它会让你失去整条腿。”*'
- en: As opposed to C, C++ does have a string type to protect you in these cases.
    However, it is still a language where you have easy access to memory addresses
    and mistakes are easily made.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与C语言不同，C++确实有字符串类型来保护你在这些情况下的安全。然而，它仍然是一种你可以轻松访问内存地址的语言，错误很容易发生。
- en: 'To pass along other types (such as integers) toward `libc` functions, we have
    to use some conversion as well. In some cases, it is optional:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其他类型（如整数）传递给`libc`函数，我们不得不使用一些转换。在某些情况下，这是可选的：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But not in all cases, so caution is advised, and explicitly converting is the
    safer option:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非所有情况都是这样，所以建议谨慎行事，并明确转换是更安全的选项：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It’s important to note that even though these values are usable as native C
    types, they are still mutable through the `value` attribute:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，尽管这些值可以作为原生C类型使用，但它们仍然可以通过`value`属性进行修改：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the case unless the original object was immutable, which is a very important distinction
    to make. The `create_string_buffer` object creates a mutable string object, whereas `c_wchar_p`, `c_char_p`,
    and `c_void_p` create references to the actual Python string. Since strings are
    immutable in Python, these values are also immutable. You can still change the `value` property,
    but it will only assign a new string. Passing one of these immutable variables
    to a C function that mutates the internal value will result in unpredictable behavior
    and/or crashes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除非原始对象是不可变的，否则这种情况才会发生。这是一个非常重要的区别。`create_string_buffer` 对象创建了一个可变字符串对象，而 `c_wchar_p`、`c_char_p`
    和 `c_void_p` 创建了对实际 Python 字符串的引用。由于 Python 中的字符串是不可变的，因此这些值也是不可变的。你仍然可以更改 `value`
    属性，但它只会分配一个新的字符串。将其中一个不可变变量传递给一个会修改内部值的 C 函数会导致不可预测的行为和/或崩溃。
- en: The only values that should convert to C without any issues are integers, strings,
    and bytes, but I personally recommend that you always convert all of your values
    so that you are certain of which type you will get and how to treat it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只有整数、字符串和字节应该能够无问题地转换为 C，但我个人建议你始终转换所有值，这样你就可以确定你会得到哪种类型以及如何处理它。
- en: Complex data structures
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂数据结构
- en: 'We have already seen that we can’t just pass along Python values to C, but
    what if we need more complex objects such as classes or tuples? Luckily, we can
    easily create (and access) C structures using `ctypes`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们不能直接将 Python 值传递给 C，但如果我们需要更复杂的对象，如类或元组怎么办？幸运的是，我们可以轻松地使用 `ctypes`
    创建（并访问）C 结构：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This supports any of the fundamental data types such as integers, floating-point
    numbers, and strings. Nesting is also supported; for instance, other structures
    could use `ComplexStructure` instead of `ctypes.c_int` in this example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这支持任何基本数据类型，如整数、浮点数和字符串。嵌套也是支持的；例如，在这个例子中，其他结构可以使用 `ComplexStructure` 而不是 `ctypes.c_int`。
- en: Arrays
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Within Python, we generally use a `list` to represent a collection of objects.
    These are very convenient in that you can easily add and remove values. Within
    C, the default collection object is the **array**, which is just a block of memory
    with a fixed size.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们通常使用 `list` 来表示对象的集合。这些非常方便，因为你可以轻松地添加和删除值。在 C 中，默认的集合对象是 **array**，它只是一个具有固定大小的内存块。
- en: The size of the block in bytes is decided by multiplying the number of items
    by the size of the type. In the case of a `char`, this is `8` bits, so if you
    wish to store `100` chars, you would have `100 * 8 bits = 800 bits = 100 bytes`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 块的大小（以字节为单位）是通过将元素数量乘以类型大小来确定的。对于 `char` 类型，这是 `8` 位，所以如果你想要存储 `100` 个字符，你将需要
    `100 * 8 bits = 800 bits = 100 bytes`。
- en: This is literally all it is—a block of memory—and the only reference you receive
    from C is a pointer to the memory address where the block of memory begins. Since
    the pointer does have a type, `char*` in this case, C will know how many bytes
    to jump ahead when trying to access a different item. Effectively, when trying
    to access item 25 in a `char` array, you simply need to do `array_pointer + 24
    * sizeof(char)`. This has a convenient shortcut: `array_pointer[24]`. Note that
    we need to access index 24 because we start counting at 0, just like with Python
    collections such as lists and strings.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上就是它——一个内存块——而你从 C 收到的唯一引用是内存块开始地址的指针。由于指针确实有类型，在这个例子中是 `char*`，C 将知道在尝试访问不同项时需要跳过多少字节。实际上，当尝试访问
    `char` 数组中的第 25 项时，你只需执行 `array_pointer + 24 * sizeof(char)`。这有一个方便的快捷方式：`array_pointer[24]`。请注意，我们需要访问索引
    24，因为我们从 0 开始计数，就像 Python 的集合如列表和字符串一样。
- en: Note that C does not store the number of items in the array, so even though
    our array has only 100 items, it won’t block us from doing `array_pointer[1000]` and
    reading other (random) memory. At some point, however, you will go outside of
    the reserved memory of your application and your operating system will punish
    you with a segmentation fault.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C 语言不存储数组中元素的数量，因此尽管我们的数组只有 100 个元素，但这不会阻止我们执行 `array_pointer[1000]` 并读取其他（随机）内存。然而，在某个时刻，你将超出应用程序预留的内存，操作系统将用段错误来惩罚你。
- en: 'If you take all of these limitations into account, C arrays are definitely
    usable but mistakes are quickly made and C is unforgiving. No warnings; just crashes
    and strangely behaving code. Beyond that, let’s see how easily we can declare
    an array with `ctypes`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑到所有这些限制，C 数组确实可以使用，但错误会很快出现，C 语言不会宽容。没有警告；只有崩溃和奇怪的行为代码。除此之外，让我们看看我们如何容易地使用
    `ctypes` 声明一个数组：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, because of the fixed sizes and the requirement of declaring
    the type before using it, its usage is slightly awkward. However, it does function
    as you would expect. Additionally, as opposed to regular C, the values are initialized
    to zero by default and it will protect you from out-of-bound errors when accessing
    from Python. Naturally, this can be combined with our previously created custom
    structures as well:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于固定大小和在使用前必须声明类型的要求，其使用略显笨拙。然而，它确实按您预期的那样工作。此外，与常规C语言不同，默认情况下值会被初始化为零，这可以在从Python访问时保护您免受越界错误。当然，这可以与之前创建的定制结构相结合：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Even though you cannot simply append to these arrays to resize them, they are
    actually resizable with a few constraints. Firstly, the new array needs to be
    larger than the original array. Secondly, the size needs to be specified in bytes,
    not items. To illustrate, we have this example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您不能简单地向这些数组追加内容以调整大小，但它们实际上在几个约束条件下是可以调整大小的。首先，新数组需要比原始数组大。其次，大小需要以字节为单位指定，而不是以项目为单位。为了说明这一点，我们有这个示例：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As a starting point, the `TenNumbers` array has 10 items. Next up, we try to
    resize the array to 11, which works because it’s more than the original 10\. Resizing
    back to 10 is also allowed, but resizing to 9 items is not allowed because that
    is fewer than the 10 items we had originally.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，`TenNumbers` 数组有10个项目。接下来，我们尝试将数组大小调整为11，这是可行的，因为它比原始的10大。将大小调整回10也是允许的，但将大小调整为9个项目是不允许的，因为这将少于我们最初拥有的10个项目。
- en: Lastly, we mutate a slice of items simultaneously, which works as you would
    expect.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们同时修改一个项目切片，这正如您所预期的那样工作。
- en: Gotchas with memory management
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理的陷阱
- en: Besides the obvious memory allocation issues and mixing mutable and immutable
    objects, there is one more non-obvious memory mutability issue.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了明显的内存分配问题和混合可变和不可变对象之外，还有一个不那么明显的内存可变性问题。
- en: 'In regular Python, we can do something like `a, b = b, a` and it will work
    as you would expect because Python uses internal temporary variables. With regular
    C, you do not have that luxury, unfortunately; with `ctypes`, you do have the
    benefit of Python taking care of the temporary variable for you, but sometimes
    that can still go wrong:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规Python中，我们可以做一些像 `a, b = b, a` 的事情，并且它会按您预期的那样工作，因为Python使用内部临时变量。不幸的是，在常规C中，您没有这样的便利；在
    `ctypes` 中，您确实有Python为您处理临时变量的好处，但有时这仍然可能出错：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the first example, we get `2, 3, 0, 1` when swapping `a` and `b`, as expected.
    With the second example, we get `2, 3, 2, 3` instead. The problem is that these
    objects are copied to a temporary buffer variable, but the objects themselves
    are being changed in the meantime.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，当我们交换 `a` 和 `b` 时，我们得到预期的 `2, 3, 0, 1`。在第二个示例中，我们得到 `2, 3, 2, 3`。问题在于这些对象被复制到一个临时缓冲变量中，但在此期间对象本身正在被改变。
- en: Let’s elaborate for a bit more clarity. With Python, when you do `a, b = b,
    a`, it will effectively run `temp = a; a = b; b = temp`. That way, the replacement
    works as expected and you will receive the correct values in `a` and `b`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步阐述以增加清晰度。在Python中，当你执行 `a, b = b, a` 时，它实际上会运行 `temp = a; a = b; b = temp`。这样，替换就会按预期工作，你将在
    `a` 和 `b` 中收到正确的值。
- en: When you execute `a, b = b, a` in C, you effectively get `a = b; b = a`. By
    the time the `b = a` statement is executed, the value for `a` has already been
    changed by the `a = b` statement, so both `a` and `b` will have the original value
    of `b` at that point.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在C语言中执行 `a, b = b, a` 时，实际上得到的是 `a = b; b = a`。在执行 `b = a` 语句时，`a` 的值已经被 `a
    = b` 语句所改变，因此此时 `a` 和 `b` 都将具有 `b` 在那个点的原始值。
- en: CFFI
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CFFI
- en: 'The `CFFI` (C Foreign Function Interface) library offers options very similar
    to `ctypes`, but it’s a bit more direct. Unlike the `ctypes` library, a C compiler
    is really a necessity for CFFI. With it comes the opportunity to directly call
    your C compiler from Python in an easy way. We illustrate by calling `printf`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFFI`（C Foreign Function Interface）库提供了与 `ctypes` 非常相似的选择，但它更为直接。与 `ctypes`
    库不同，CFFI 真正需要C编译器。有了它，您就有机会以简单的方式从Python直接调用您的C编译器。我们通过调用 `printf` 来说明：'
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Okay… so that looks a bit weird, right? We had to define how the `printf` function
    looks and specify the arguments to `printf` with a valid C function header. Additionally,
    we had to specify the C-string as a `char[]` array manually. With `ctypes`, that
    would not be required, but there are several advantages to `CFFI` as opposed to
    `ctypes`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧…这看起来有点奇怪，对吧？我们不得不定义`printf`函数的形态，并使用有效的C函数头指定`printf`的参数。此外，我们还需要手动指定C字符串为`char[]`数组。使用`ctypes`的话，这就不需要了，但与`ctypes`相比，`CFFI`有几个优点。
- en: With CFFI, we can directly control what is sent to the C compiler, which gives
    us much more control over what is happening internally compared to `ctypes`. This
    means you can exactly control what types you feed the functions and what types
    you are returning, and you can use C macros.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CFFI，我们可以直接控制发送给C编译器的信息，这使得我们比使用`ctypes`有更多的内部控制权。这意味着你可以精确控制你提供给函数的类型以及你返回的类型，并且你可以使用C宏。
- en: Additionally, CFFI allows for easy reuse of existing C code. If the C code you
    are using has several `struct` definitions, you don’t have to manually map them
    to a `ctypes.Structure` class; you can use the `struct` definition straightaway.
    You can even write C code directly in your Python code and CFFI will take care
    of calling the compiler and building the library for you.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CFFI允许轻松重用现有的C代码。如果你使用的C代码有几个`struct`定义，你不需要手动将它们映射到`ctypes.Structure`类；你可以直接使用`struct`定义。你甚至可以直接在你的Python代码中编写C代码，CFFI会为你调用编译器和构建库。
- en: Getting back to the declarations, you may notice that we called `ffi.dlopen`
    with a `None` parameter. When you pass `None` to this function, it will automatically
    load the entire C namespace; on non-Windows systems, at least. On Windows systems,
    you will need to explicitly tell CFFI which library to load.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回到声明部分，你可能注意到我们使用`ffi.dlopen`时传入了`None`参数。当你向这个函数传递`None`时，它将自动加载整个C命名空间；至少在非Windows系统上是这样。在Windows系统上，你需要明确告诉CFFI要加载哪个库。
- en: 'If you remember the `ctypes.util.find_library` function, you can use that again
    in this case, depending on your operating system:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得`ctypes.util.find_library`函数，你可以在这种情况下再次使用它，具体取决于你的操作系统：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: we can see here, the workings are initially quite comparable to `ctypes` and
    loading the library is just as easy. The big difference is when actually calling
    functions and using library attributes; those need to be explicitly defined.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，最初的工作方式与`ctypes`相当，加载库也很简单。真正不同的是在调用函数和使用库属性时；那些需要明确定义。
- en: 'Luckily, the function signatures are almost always available in a C header
    file for your convenience so you don’t need to write those yourself. And that
    is one of the advantages of CFFI: it allows you to reuse existing C code.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，函数签名几乎总是可以在C头文件中找到，以便你不必自己编写。这就是CFFI的一个优点：它允许你重用现有的C代码。
- en: Complex data structures
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂数据结构
- en: The `CFFI` definitions are somewhat similar to the `ctypes` definitions, but
    instead of having Python emulating C, it’s just plain C that is accessible from
    Python. In reality, it’s only a small syntactical difference. While `ctypes` is
    a library for accessing C from Python while remaining as close to the Python syntax
    as possible, CFFI uses plain C syntax to access C systems, which actually removes
    some confusion for people experienced with C. I personally find CFFI easier to
    use because I have experience with C and know what is actually happening, whereas
    I am not always 100% certain with `ctypes`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFFI`的定义与`ctypes`的定义有些相似，但与Python模拟C不同，它只是从Python可访问的纯C。实际上，这只是一个小的语法差异。虽然`ctypes`是一个用于从Python访问C的库，同时尽可能接近Python语法，但CFFI使用纯C语法来访问C系统，这实际上消除了对熟悉C的人来说的一些困惑。我个人觉得CFFI更容易使用，因为我有C的经验，知道实际上发生了什么，而我对`ctypes`则不是总是100%确定。'
- en: 'Let’s repeat the `Vertex` and `Point` example with CFFI:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用CFFI重复`Vertex`和`Point`的例子：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the mutable variable issues remain, but the code is just as
    usable. Since the struct can be copied from your C headers, the only thing that
    remains for you is to allocate the memory for the vertex.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可变变量的问题仍然存在，但代码仍然可用。由于结构可以从你的C头文件中复制，你唯一需要做的是为顶点分配内存。
- en: 'In C, a regular `int` type variable `x` looks like `int x;`. A pointer to a
    memory address with size `int` looks like this: `int *x;`. The `int` part of the
    pointer tells the compiler how much memory to fetch when using the variable. To
    illustrate:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，一个普通的`int`类型变量`x`看起来像`int x;`。一个指向具有`int`大小的内存地址的指针看起来像这样：`int *x;`。指针中的`int`部分告诉编译器在使用变量时需要获取多少内存。为了说明：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `&` operator returns the memory address for a variable and the `*` operator
    returns the value at the pointer’s address.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`运算符返回变量的内存地址，而`*`运算符返回指针地址处的值。'
- en: The special workings of CFFI allow you to shortcut these operations. Normally
    in C, using `vertex*` would only allocate the memory for the pointer, not the
    `vertex` itself. In the case of CFFI, that is taken care of automatically.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: CFFI的特殊工作方式允许你简化这些操作。在C语言中，通常使用`vertex*`只会分配指针的内存，而不是`vertex`本身。在CFFI的情况下，这一点会自动处理。
- en: Arrays
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'Allocation memory for new variables is almost trivial with CFFI. The previous
    section showed you an example of a single `struct` allocation. Let’s now see how
    we can allocate an array of structs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CFFI分配新变量的内存几乎是微不足道的。上一节向你展示了单个`struct`分配的例子。现在让我们看看我们如何分配结构体数组：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, you might wonder why the slice includes both the start and the
    stop. This is a requirement for CFFI. Not problematic, but a tad annoying nonetheless.
    Luckily, as you can see in the example above, CFFI does protect us from allocating
    outside of the bounds of the array.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能会想知道为什么切片包括了起始和结束位置。这是CFFI的要求。虽然不是问题，但多少有点令人烦恼。幸运的是，正如你在上面的例子中可以看到的，CFFI确实保护我们不会超出数组边界进行分配。
- en: ABI or API?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABI还是API？
- en: As always, there are some caveats. The examples so far have partially used the
    **ABI** (**application binary interface**), which loads the binary structures
    from the libraries. With the standard C library, this is generally safe; with
    other libraries, it generally isn’t. The difference between the **API** (**application
    programming interface**) and the ABI is that the latter calls the functions at
    a binary level, directly addressing memory, calling memory locations directly,
    and expecting them to be functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有些注意事项。到目前为止的例子部分使用了**ABI**（**应用程序二进制接口**），它从库中加载二进制结构。使用标准C库通常很安全；使用其他库通常则不是。**API**（**应用程序编程接口**）和ABI之间的区别在于后者在二进制级别调用函数，直接访问内存，直接调用内存位置，并期望它们是函数。
- en: To be able to do this, all sizes need to be consistent as well. When compiled
    as a 32-bit binary, a pointer will be 32 bits; when compiled as a 64-bit binary,
    a pointer will be 64 bits. That means that the offsets are not guaranteed to be
    consistent and you could be calling a random block of memory as a function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够这样做，所有的大小都需要保持一致。当作为32位二进制文件编译时，指针将是32位；当作为64位二进制文件编译时，指针将是64位。这意味着偏移量不一定是一致的，你可能会错误地将内存块作为函数调用。
- en: 'Within CFFI, it’s the difference between `ffi.dlopen` and `ffi.set_source`.
    Here, `dlopen` is not always safe, but `set_source` is, because it passes a compiler
    instead of just guessing how to call a method. The downside of using `set_source`
    is that you need the actual source for the library you are planning to use. Let’s
    look at a quick example of using `ffi.set_source` to call a function we defined
    ourselves:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在CFFI中，这是`ffi.dlopen`和`ffi.set_source`之间的区别。在这里，`dlopen`并不总是安全的，但`set_source`是安全的，因为它传递了一个编译器而不是仅仅猜测如何调用方法。使用`set_source`的缺点是你需要你打算使用的库的实际源代码。让我们看看使用`ffi.set_source`调用我们定义的函数的快速示例：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The initialization of CFFI is as normal, but instead of using `ffi.dlopen()`
    we are now using `ffi.set_source()` to directly pass the C code to CFFI. By doing
    this, CFFI can compile the library specifically for our system so we know that
    we will not run into ABI issues because we are creating the ABI ourselves with
    the call to `ffi.compile()`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: CFFI的初始化和往常一样正常，但不是使用`ffi.dlopen()`，我们现在使用`ffi.set_source()`直接将C代码传递给CFFI。通过这样做，CFFI可以为我们自己的系统编译特定的库，因此我们知道我们不会遇到ABI问题，因为我们是通过调用`ffi.compile()`自己创建ABI的。
- en: 'After the `ffi.compile()` step has completed, CFFI has created a `_sum.dll`,
    `sum.so`, or `_sum.cpython-...-os.so` file, which can be imported as a regular
    Python library. Now we will use the generated library:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ffi.compile()`步骤完成后，CFFI已经创建了一个`_sum.dll`、`sum.so`或`_sum.cpython-...-os.so`文件，它可以作为一个普通的Python库导入。现在我们将使用生成的库：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, both `import _sum` and `ffi.dlopen(library)` work in this case.
    For use in production applications, I would recommend the `import _sum` method,
    but the `ffi.dlopen()` method can be very convenient to use from long-running
    applications such as Jupyter Notebooks. If you were to use `import _sum` and make
    a change in the library, it would not show your changes without you first calling
    `reload(_sum)`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a C function, we need to pass a C array for complex types, which
    is why we are using `ffi.new()` here. After that, the function call is straightforward,
    but since a C array does not have a notion of size, we need to pass the array
    size for this to work.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You can easily go out of bounds here and put in some arbitrary number instead
    of `N`, and the function will most likely work without crashes, but it will return
    very strange results because it will be summing random data in your memory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: CFFI or ctypes?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This really depends on what you are looking for. If you have a C library that
    you simply need to call and you don’t need anything special, then `ctypes` is
    most likely the easier choice. If you’re actually writing your own C library and
    trying to link to the library from Python, CFFI is probably a more convenient
    option.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In C/C++, linking a library means using an external pre-compiled library without
    requiring the source. You do need to have the header files, which contain details
    such as the function arguments and return types. This is exactly what we are doing
    when we use CFFI in ABI mode.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with the C programming language, then I would definitely
    recommend `ctypes` or perhaps `cython`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Native C/C++ extensions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The libraries that we have used so far only showed us how to access a C/C++
    library within our Python code. Now we are going to look at the other side of
    the story: how C/C++ functions/modules within Python are actually written and
    how modules such as `cPickle` and `cProfile` are created.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: A basic example
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can actually start with writing and using native C/C++ extensions,
    we have a few prerequisites. First of all, we need the compiler and Python headers;
    the instructions at the beginning of this chapter should have taken care of this
    for us. After that, we need to tell Python what to compile. The `setuptools` package
    mostly takes care of this, but we do need to create a `setup.py` file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This tells Python that we have an `Extension` object named `sum_of_squares` that
    will be based on `sum_of_squares.c`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s write a function in C that sums all perfect squares (`2*2`, `3*3`,
    and so on) up to a given number. The Python code will be stored in `sum_of_squares_python.py`
    and looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The raw C version of this code would look something like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we know how the C code looks, we will create the actual C Python version
    that we will be using.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen with `ctypes` and `CFFI`, Python and C have different data types
    and some conversion needs to be done. Since the CPython interpreter is written
    in C, it has definitions specifically to take care of this translation step.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: To load these definitions, we need to include `Python.h`, which are the CPython
    header files that should have everything you need.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look carefully, you will see that the actual summing code is identical
    to the C version, but we need quite a few conversion steps to make Python understand
    what we are doing:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It looks quite complicated, but it’s really not that hard. There is just a
    lot of overhead in this case because we only have a single function. Generally,
    you would have several functions, in which case you only need to expand the `methods` array
    and create the functions. We will explain the code in more detail shortly, but
    first, let’s look at how to run our first example. We need to build and install
    the module:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let’s create a little test script to time the difference between the Python
    version and the C version. First, some imports and setup:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have the modules imported (or got an error if you hadn’t run the
    build step yet), we can start benchmarking:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In essence, we have a basic benchmarking script where we compare the C version
    to the Python version here, with a configurable number of repetitions and a maximum
    number to test for. Now, let’s execute it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Perfect! Exactly the same results but much faster.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: If your goal is speed alone, you should give `numba` a try instead. Adding the
    `@numba.njit` decorator to `sum_of_squares_python` is much easier and probably
    even faster.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of writing C modules is the reuse of existing C code, however.
    For speedups, you are often better off with `cython`, `numba`, or converting your
    code to use libraries such as `numpy` or `jax`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: C is not Python – Size matters
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python language makes programming so easy that you might forget about the
    underlying data structures at times; with C and C++, you can’t afford to do that.
    Just take our example from the previous section but with different parameters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s still very fast, but what happened to the numbers? The Python and C versions
    give different results, `1953214233` versus `10543148825`. This is caused by integer
    overflows in C. While Python numbers can essentially have any size, with C, a
    regular number has a fixed size. How much you get depends on the type you use
    (`int`, `long`, and so on) and your architecture (32-bit, 64-bit, and so on),
    but it’s definitely something to be careful with. It might be hundreds of times
    faster in some cases, but that is meaningless if the results are incorrect.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'We can increase the size a bit, of course. This makes it better:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We used `typedef` to create a `bigint` alias for `unsigned long long int`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'If we test it now, we realize that it works great:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: And with the increased size, the difference in performance increases as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the number even larger breaks things again since even an `unsigned long
    long int` still has its limits:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, how can you fix this? The simple answer is that you can’t, and Python hasn’t
    really fixed it either. The complex answer is that you can if you use a different
    data type to store your data. The C language by itself doesn’t have the “big number
    support” that Python has.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Python supports infinitely large numbers by combining several regular numbers
    in the actual memory and automatically switches to those types of numbers when
    needed. With Python 2, that was much more obvious with the distinction between
    the `int` and `long` types. With Python 3, the `long` and `int` types have been
    merged into the `int` type. You will not notice the switchover to the `long` type;
    it will automatically happen in the background.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Within C, there are no commonly available provisions for this, so there is
    simply no easy way to get this working. But we can check for errors instead:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that this only works for `PyObject*`, which means it doesn’t work for internal
    C overflows. However, you can, of course, just keep the original Python long around
    and perform operations on that instead. So, you do have big number support in
    C without too much effort.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The example explained
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the results from our example, but if you’re not familiar with the
    Python C API, you might be confused as to why the function parameters look the
    way they do.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic calculations within `sum_of_squares` are identical to the regular
    C `sum_of_squares` function, but there are a few small differences. Firstly, the
    type definition for a function using the Python C API should look something like
    this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let’s break this down.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that the function is **static**. A function that’s static can be
    called only from the same translation unit within the compiler. This effectively
    results in a function that cannot be linked (imported/used) from other modules,
    which allows the compiler to optimize a bit further. Since functions in C are
    global by default, this can be very useful in preventing naming collisions. Just
    to be sure, however, you could prefix your function names with the name of the
    module if you use a name that is less likely to be unique.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to confuse the word `static` here with the `static` before a
    variable. They are completely different beasts. A `static` variable means that
    the variable will exist for the entire runtime of the program instead of the runtime
    of just the function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: PyObject*
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `PyObject` type is the basic type for Python data types, which means that
    all Python objects can be cast to `PyObject*` (the `PyObject` pointer). Effectively,
    it only tells the compiler what kind of properties to expect, which can be used
    later for type identification and memory management. Instead of direct access
    to `PyObject*`, it is generally a better idea to use the available macros, such
    as `Py_TYPE(some_object)`. Internally, this expands to `(((PyObject*)(o))->ob_type)`,
    which is why the macro is generally a better idea. Besides being unreadable, a
    typo can easily happen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of properties is long and depends greatly on the type of object. For
    those, you can refer to the Python documentation: [https://docs.python.org/3/c-api/typeobj.html](https://docs.python.org/3/c-api/typeobj.html).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The entire Python C API could fill a book of its own, but it is luckily well
    documented within the Python manual. Its usage, on the other hand, might be less
    obvious.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Parsing arguments
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With regular C and Python, you specify the arguments explicitly, since variable-sized
    arguments are a bit tricky with C. This is because they need to be parsed separately. `PyObject*
    args` is the reference to objects containing the actual values. To parse these,
    you need to know how many and which type of variables to expect. In the example,
    we used the `PyArg_ParseTuple` function, which parses the arguments as positional
    arguments only, but it is quite easily possible to parse named arguments as well
    using `PyArg_ParseTupleAndKeywords` or `PyArg_VaParseTupleAndKeywords`. The difference
    between these is that the first one uses a variable number of arguments to specify
    the destination and the latter uses a `va_list` to set the values to.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the code from the actual example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We know that `args` is the object containing the reference to the actual arguments.
    The `"i"` is a format string, which in this case will try to parse a single integer.
    `&n` tells the function to store the value at the memory address of the `n` variable.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The format string is the important part here. Depending on the character, you
    get a different data type, but there are many; `i` specifies a regular integer,
    and `s` converts your variable to a C-string (actually a `char*`, which is a null-terminated
    character array). It should be noted that this function is, luckily, smart enough
    to take overflows into consideration as well.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Parsing multiple arguments is quite similar; you need to add multiple characters
    to the format string and multiple destination variables:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The version with keyword arguments is similar, but requires a few more code
    changes as the list of methods needs to be informed that the function takes keyword
    arguments. Otherwise, the `kwargs` parameter would never arrive:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s look at the differences from the version that only supported `*args`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Similar to pure Python, our function header now includes `PyObject *kwargs`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we need to pre-allocate strings in C, we have an array of words called
    `keywords` with all of the `kwargs` we plan to parse.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of `PyArg_ParseTuple` we now have to use `PyArg_ParseTupleAndKeywords`.
    This function overlaps the `PyArg_ParseTuple` function and adds keyword parsing
    by walking through the previously defined `keywords` array.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the function registry, we need to specify that the function supports keyword
    arguments by adding the `METH_KEYWORDS` flag in addition to the `METH_VARARGS`
    flag.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this still supports normal arguments, but keyword arguments are also
    supported now.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: C is not Python – Errors are silent or lethal
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in a previous example, integer overflows are not something you will
    generally notice, and unfortunately, there’s no good cross-platform way to catch
    them. However, those are actually the easier errors to handle; the worst one is
    generally memory management. With Python, if you get an error, you will get an
    exception that you can catch. With C, you can’t really handle it gracefully. Take
    a division by zero, for example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is simple enough to catch with `try: ... except ZeroDivisionError: ...`.
    With C, on the other hand, if you get a bad error, it will kill your entire process.
    But debugging C code is what C compilers have debuggers for, and to find the cause
    of the error, you can use the `faulthandler` module discussed in *Chapter 11*, *Debugging
    – Solving the Bugs*. Right now, let’s see how we can properly throw errors from
    C:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When executing this, it will effectively run `raise RuntimeError('Too many eggs!')`.
    The syntax is slightly different—`PyErr_SetString` instead of `raise`—but it’s
    the same basic principle.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Calling Python from C – Handling complex types
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to call C functions from Python, but now let’s try Python from
    C and back. Instead of using the readily available `sum` function, we will build
    one of our own with a callback and handling of any type of iterable. While this
    sounds simple enough, it does actually require a bit of type meddling, as you
    can only expect `PyObject*` as arguments. This is contrary to the simple types,
    such as integers, chars, and strings, which are immediately converted to the native
    Python version.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: For clarity, this is just a single function that is broken up into multiple
    parts.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start with the `include` function signature, and the declaration
    of the variables we need. Note that the values for `total` and `callback` are
    defaults in the event that these arguments are not specified:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we parse a `PyObject*` followed by, optionally (the | character), a `PyObject*`
    and a `long long int`. This is specified by the `O|OL` argument. The results will
    be stored in the memory addresses (the `&` sends the memory address of a variable)
    of `iterable`, `callback`, and `total`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We see if we can create an iterator from the iterable. This is effectively
    the same as doing `iter(iterable)` in Python:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we check whether the callback exists or wasn’t specified. If it was specified,
    check whether it’s callable or not:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Looping through the iterable, if we have a callback available, we call it.
    Otherwise, we just use the `item` as the `value`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We add the value to `total` and check for overflows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If we were indeed using the callback, we decrease the reference count to the
    value because it is a separate object now.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: We also need to dereference `item` and the iterator. Forgetting to do this results
    in memory leaks because it decreases the reference count for the Python garbage
    collector.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'So, always make sure you call the `PyDECREF` function after using `PyObject*`
    types:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Lastly, we need to convert `total` to the correct return type and return it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This function is callable in three different ways. When given only an iterable,
    it will sum the iterable and return the value. Optionally, we can pass a callback
    function, which will be applied to each value in the iterable before summing.
    As a second optional parameter, we can specify the initial value to start with:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Another important issue is that even though we catch overflow errors when converting
    to `long long int`, this code is still not safe. If we sum even two very large
    numbers (close to the `long long int` limit), we will still have an overflow:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this case, you could test for this by doing something like `if(value > INT_MAX
    - total)`, but that solution does not always apply, so it is most important to
    be conscious of overflows and underflows when using C.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The possibilities with external libraries are endless, so perhaps you already
    have some ideas about what to implement. If not, here’s some inspiration:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Try to sort a list of numbers using `ctypes`, `CFFI`, and with a native extension.
    You can use the `qsort` function in `stdlib`.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to make the `custom_sum` function we created safer by adding proper errors
    for overflow/underflow issues. Additionally, catch the errors when summing multiple
    numbers that only overflow or underflow in summation.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These exercises should be a nice starting point for doing something useful
    with your newly acquired knowledge. If you are looking for more of the native
    C/C++ examples, I would recommend looking through the CPython source. There are
    many examples available: [https://github.com/python/cpython/tree/main/Modules](https://github.com/python/cpython/tree/main/Modules).
    I would suggest starting with a relatively simple one such as the `bisect` module.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_17.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about writing and using extensions in C/C++. As
    a quick recap, we covered:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Loading external (system) libraries such as `stdlib` using `ctypes`
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and handling complex data structures using `ctypes` and `CFFI`
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling arrays using `ctypes` and `CFFI`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining C and Python functions
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important caveats regarding numeric types, arrays, overflows, and other error
    handling
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though you can now create C/C++ extensions, I still recommend that you
    avoid them, if possible, because it is so easy to end up with bugs. Even the code
    examples in this chapter don’t handle many of the possible error scenarios and,
    as opposed to errors in Python, if these errors happen in C, they can kill your
    interpreter or application entirely.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: If your goal is better performance, then I would recommend trying `numba` or
    `cython` instead. If you really need interoperability with non-Python libraries,
    however, these libraries are good options. A few examples of universal libraries
    such as these are TensorFlow and OpenCV, which are available in many languages
    and have Python wrappers for convenience.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'While building the examples in this chapter, you may have noticed that we used
    a `setup.py` file and imported from the `setuptools` library. This is what the
    next chapter will cover: packaging your code into an installable Python library
    and distributing it on the Python Package Index.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
