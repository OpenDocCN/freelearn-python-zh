<html><head></head><body>
		<div><h1 id="_idParaDest-236" class="chapter-number"><a id="_idTextAnchor256"/>10</h1>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor257"/>Patterns for Testing</h1>
			<p>In the previous chapters, we covered architectural patterns and patterns for specific use cases such as concurrency or performance.</p>
			<p>In this chapter, we will explore design patterns that are particularly useful for testing. These patterns help in isolating components, making tests more reliable, and promoting code reusability.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>The Mock Object pattern</li>
				<li>The Dependency Injection pattern</li>
			</ul>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor258"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor259"/>The Mock Object pattern</h1>
			<p>The <strong class="bold">Mock Object</strong> pattern<a id="_idIndexMarker911"/> is a powerful tool for isolating components during testing by <a id="_idIndexMarker912"/>simulating their behavior. Mock objects help create controlled testing environments and verify interactions between components.</p>
			<p>The Mock Object pattern provides three features:</p>
			<ol>
				<li><strong class="bold">Isolation</strong>: Mocks isolate<a id="_idIndexMarker913"/> the unit of code being tested, ensuring that tests run in a controlled environment where dependencies are predictable and do not have external side effects.</li>
				<li><strong class="bold">Behavior verification</strong>: By using mock objects, you can verify that certain behaviors happen during <a id="_idIndexMarker914"/>a test, such as method calls or property accesses.</li>
				<li><strong class="bold">Simplification</strong>: They <a id="_idIndexMarker915"/>simplify the setup of tests by replacing complex real objects that might require significant setup <a id="_idIndexMarker916"/>of their own.</li>
			</ol>
			<p class="callout-heading">Comparison with stubs</p>
			<p class="callout">Stubs also replace real implementations but are used only to provide indirect input to the code under test. Mocks, by contrast, can also verify interactions, making them more flexible in many testing scenarios.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor260"/>Real-world examples</h2>
			<p>We can think of the following analog <a id="_idIndexMarker917"/>concepts or tools in the real world:</p>
			<ul>
				<li>A flight simulator, which is a tool designed to replicate the experience of flying an actual airplane. It allows pilots to learn how to handle various flight scenarios in a controlled and safe environment.</li>
				<li>A <strong class="bold">cardiopulmonary resuscitation</strong> (<strong class="bold">CPR</strong>) dummy, which is used to teach students how to perform CPR <a id="_idIndexMarker918"/>effectively. It simulates the human body to provide a realistic yet controlled setting for learning.</li>
				<li>A crash test dummy, which is used by car manufacturers to simulate human reactions to vehicle collisions. It provides valuable data on the impacts and safety features of a car without putting actual human lives at risk.</li>
			</ul>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor261"/>Use cases for the Mock Object pattern</h2>
			<p>In <strong class="bold">unit testing</strong>, mock objects <a id="_idIndexMarker919"/>are used to replace complex, unreliable, or unavailable dependencies of the code being tested. This allows <a id="_idIndexMarker920"/>developers to focus solely on the unit itself rather than its interactions with external systems. For example, when testing a service that fetches data from an API, a mock object can simulate the API by returning predefined responses, ensuring that the service can handle various data scenarios or errors without needing to interact with the actual A<a id="_idTextAnchor262"/>PI.</p>
			<p>While similar to<a id="_idIndexMarker921"/> unit testing, <strong class="bold">integration testing</strong> with <a id="_idIndexMarker922"/>mock objects focuses on the interaction between components rather than individual units. Mocks can be used to simulate components that have not been developed yet or are too costly to involve in every test. For example, in a microservices architecture, a mock can represent a service that is under development or temporarily unavailable, allowing other services to be tested in terms of how they integrate and communicate with it.</p>
			<p>The Mock Object pattern is also useful <a id="_idIndexMarker923"/>for <strong class="bold">behavior verification</strong>. This use case involves verifying that certain interactions between objects occur as expected. Mock objects can be programmed to expect specific calls, arguments, and even order of interactions, which makes them powerful tools for behavioral testing; for example, testing whether a controller, in a <strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>) architecture, correctly<a id="_idIndexMarker924"/> calls authentication and logging services before processing a user request. Mocks can verify that the controller makes the right calls in the right order, such <a id="_idIndexMarker925"/>as checking credentials before attempting to log the request.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor263"/>Implementing the Mock Object pattern</h2>
			<p>Imagine we have a <a id="_idIndexMarker926"/>function that logs messages to a file. We can mock the file-writing mechanism to ensure our logging function writes the expected content to the log without writing to a file. Let’s see how this can be implemented using Python’s <code>unittest</code> module.</p>
			<p>First, we import what we need for the example:</p>
			<pre class="source-code">
import unittest
from unittest.mock import mock_open, patch</pre>			<p>Then, we create a class representing a simple logger that writes messages to a file specified during initialization:</p>
			<pre class="source-code">
class Logger:
    def __init__(self, filepath):
        self.filepath = filepath
    def log(self, message):
        with open(self.filepath, "a") as file:
            file.write(f"{message}\n")</pre>			<p>Next, we create a test case class that inherits from the <code>unittest.TestCase</code> class, as usual. In this class, we need the <code>test_log()</code> method to test the logger’s <code>log()</code> method, as follows:</p>
			<pre class="source-code">
class TestLogger(unittest.TestCase):
    def test_log(self):
        msg = "Hello, logging world!"</pre>			<p>Next, we<a id="_idIndexMarker927"/> are<a id="_idIndexMarker928"/> going to mock the Python built-in <code>open()</code> function directly within the test scope. Mocking the function is done using <code>unittest.mock.patch()</code>, which temporarily replaces the target object, <code>builtins.open</code>, with a mock object (the result of calling <code>mock_open()</code>). With the context manager we get from calling the <code>unittest.mock.patch()</code> function, we create a <code>Logger</code> object and call its <code>.log()</code> method, which should trigger the <code>open()</code> function:</p>
			<pre class="source-code">
        m_open = mock_open()
        with patch("builtins.open", m_open):
            logger = Logger("dummy.log")
            logger.log(msg)</pre>			<p class="callout-heading">About builtins</p>
			<p class="callout">According to Python documentation, the <code>builtins</code> module<a id="_idIndexMarker929"/> provides direct access to all built-in identifiers of Python; for example, <code>builtins.open</code> is the full name for the <code>open()</code> built-in function. See <a href="https://docs.python.org/3/library/builtins.html">https://docs.python.org/3/library/builtins.html</a>.</p>
			<p class="callout-heading">About mock_open</p>
			<p class="callout">When you call <code>mock_open()</code>, it returns a <a id="_idIndexMarker930"/>Mock object that is configured to behave like the built-in <code>open()</code> function. This mock is set up to simulate file operations such as reading and writing.</p>
			<p class="callout-heading">About unittest.mock.patch</p>
			<p class="callout">It is used to replace objects with<a id="_idIndexMarker931"/> mocks during testing. Its arguments include <code>target</code> to specify the object to replace, and optional arguments: <code>new</code> for an optional replacement object, <code>spec</code> and <code>autospec</code> to limit the mock to the real object’s attributes for accuracy, <code>spec_set</code> for a stricter attribute specification, <code>side_effect</code> to define conditional behavior or exceptions, <code>return_value</code> for setting a fixed response, and <code>wraps</code> to allow the original object’s behavior while modifying certain aspects. These options enable precise control and flexibility in testing scenarios.</p>
			<p>Now, we<a id="_idIndexMarker932"/> check that the log file was opened correctly, which<a id="_idIndexMarker933"/> we do using two verifications. For the first one, we use the <code>assert_called_once_with()</code> method on the mock object, to check that the <code>open()</code> function was called with the expected parameters. For the second one, we need more tricks from <code>unittest.mock.mock_open</code>; our <code>m_open</code> mock object, which was obtained by calling the <code>mock_open()</code> function, is also a callable object that behaves like a factory for creating new mock file handles each time it’s called. We use that to obtain a new file handle, and then we use <code>assert_called_once_with()</code> on the <code>write()</code> method call on that file handle, which helps us check if the <code>write()</code> method was called with the correct message. This part of the test function is as follows:</p>
			<pre class="source-code">
            m_open.assert_called_once_with(
                "dummy.log", "a"
            )
            m_open().write.assert_called_once_with(
                f"{msg}\n"
            )</pre>			<p>Finally, we call <code>unitest.main()</code>:</p>
			<pre class="source-code">
if __name__ == "__main__":
    unittest.main()</pre>			<p>To execute the example (in the <code>ch10/mock_object.py</code> file), as usual, run the following command: </p>
			<pre class="source-code">
<strong class="bold">python ch10/mock_object.py</strong></pre>			<p>You should <a id="_idIndexMarker934"/>get an <a id="_idIndexMarker935"/>output like the following:</p>
			<pre class="console">
.
---------------------------------------------------------
Ran 1 test in 0.012s
OK</pre>			<p>That was a quick demonstration of using mocking to simulate parts of a system within a unit test. We can see that this approach isolates side effects (that is, file I/O), ensuring that the unit tests do not create or require actual files. It allows testing the internal behavior of the class without altering the class structure for testing purposes.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor264"/>The Dependency Injection pattern</h1>
			<p>The <a id="_idIndexMarker936"/>Dependency Injection pattern<a id="_idIndexMarker937"/> involves passing the dependencies of a class as external entities rather than creating them within the class. This promotes loose coupling, modularity, and testability.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor265"/>Real-world examples</h2>
			<p>We come across the following <a id="_idIndexMarker938"/>examples in real life:</p>
			<ul>
				<li><strong class="bold">Electrical appliances and power outlets</strong>: Various electrical appliances can be plugged into different power outlets to use electricity without needing direct and permanent wiring</li>
				<li><strong class="bold">Lenses on cameras</strong>: A photographer can change lenses on a camera to suit different environments and needs without changing the camera itself</li>
				<li><strong class="bold">Modular train systems</strong>: In a modular train system, individual cars (such as sleeper, diner, or baggage cars) can be added or removed depending on the needs of each<a id="_idIndexMarker939"/> journey</li>
			</ul>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor266"/>Use cases for the Dependency Injection pattern</h2>
			<p>In web <a id="_idIndexMarker940"/>applications, injecting <a id="_idIndexMarker941"/>database connection objects into components such as repositories or services enhances modularity and maintainability. This practice allows for an easy switch between different database engines or configurations without the need to alter the component’s code directly. It also significantly simplifies the process of unit testing by enabling the injection of mock database connections, thereby testing various data scenarios without affecting the live databases.</p>
			<p>Another type of use case is managing configuration settings across various environments (development, testing, production, and so on). By dynamically injecting settings into <a id="_idIndexMarker942"/>modules, <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) reduces coupling between the modules and their configuration sources. This flexibility makes it easier to manage and switch environments without needing extensive reconfiguration. In unit testing, this means you can inject specific settings to test how modules perform under different configurations, ensuring robustness and functionality.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor267"/>Implementing the Dependency Injection pattern – using a mock object</h2>
			<p>In this first example, we’ll<a id="_idIndexMarker943"/> create a simple scenario where a <code>WeatherService</code> class depends on a <code>WeatherApiClient</code> interface<a id="_idIndexMarker944"/> to fetch weather data. For the example’s unit test code, we will inject a mock version of this API client.</p>
			<p>We start by defining the interface any weather API client implementation should conform to, using Python’s <code>Protocol</code> feature:</p>
			<pre class="source-code">
from typing import Protocol
class WeatherApiClient(Protocol):
    def fetch_weather(self, location):
        """Fetch weather data for a given<a id="_idTextAnchor268"/> location"""
        ...</pre>			<p>Then, we add a <code>RealWeatherApiClient</code> class that implements that interface and that would <a id="_idIndexMarker945"/>interact with our weather service. In a real scenario, in the provided <code>fetch_weather()</code> method, we would perform a call to a weather service, but we want to keep the example simple and focus on the main concepts of this chapter; so, we provide a simulation, simply returning a string that represents the weather data result. The code is as follows:</p>
			<pre class="source-code">
class RealWeatherApiClient:
    def fetch_weather(self, location):
        return f"Real weather data for {location}"</pre>			<p>Next, we create a weather<a id="_idIndexMarker946"/> service, which uses an object that implements the <code>WeatherApiClient</code> interface to fetch weather data:</p>
			<pre class="source-code">
class WeatherService:
    def __init__(self, weather_api: WeatherApiClient):
        self.weather_api = weather_api
    def get_weather(self, location):
        return self.weather_api.fetch_weather(location)</pre>			<p>Finally, we are ready to inject the API client’s dependency through the <code>WeatherService</code> constructor. We add code that helps manually test the example, using the real service, as follows:</p>
			<pre class="source-code">
if __name__ == "__main__":
    ws = WeatherService(RealWeatherApiClient())
    print(ws.get_weather("Paris"))</pre>			<p>This part of our <a id="_idIndexMarker947"/>example (in the <code>ch10/dependency_injection/di_with_mock.py</code> file) can be manually tested by using the following command:</p>
			<pre class="source-code">
<strong class="bold">python ch10/dependency_injection/di_with_mock.py</strong></pre>			<p>You should get the following output:</p>
			<pre class="source-code">
<code>ch10/dependency_injection/test_di_with_mock.py</code>).</p>
			<p>First, we import the <code>unittest</code> module, as <a id="_idIndexMarker948"/>well as the <code>WeatherService</code> class (from our <code>di_with_mock</code> module), as follows:</p>
			<pre class="source-code">
import unittest
from di_with_mock import WeatherService</pre>			<p>Then, we create a mock<a id="_idIndexMarker949"/> version of the weather API client <a id="_idIndexMarker950"/>implementation that will be useful for unit testing, simulating responses without making real API calls:</p>
			<pre class="source-code">
class MockWeatherApiClient:
    def fetch_weather(self, location):
        return f"Mock weather data for {location}"</pre>			<p>Next, we write the test case class, with a test function. In that function, we inject the mock API client instead of<a id="_idIndexMarker951"/> the real API client, passing it to the <code>WeatherService</code> constructor, as follows:</p>
			<pre class="source-code">
class TestWeatherService(unittest.TestCase):
    def test_get_weather(self):
        mock_api = MockWeatherApiClient()
        weather_service = WeatherService(mock_api)
        self.assertEqual(
            weather_service.get_weather("Anywhere"),
            "Mock weather data for Anywhere",
        )</pre>			<p>We finish by adding the usual lines for executing unit tests when the file is interpreted by Python:</p>
			<pre class="source-code">
if __name__ == "__main__":
    unittest.main()</pre>			<p>Executing this part of the example (in the <code>ch10/dependency_injection/test_di_with_mock.py</code> file), using the <code>python ch10/dependency_injection/test_di_with_mock.py</code> command, gives <a id="_idIndexMarker952"/>the<a id="_idIndexMarker953"/> following output:</p>
			<pre class="console">
.
---------------------------------------------------------
Ran 1 test in 0.000s
OK</pre>			<p>The test with the <a id="_idIndexMarker954"/>dependency injected <a id="_idIndexMarker955"/>using a mock object <a id="_idIndexMarker956"/>succeeded.</p>
			<p>Through this example, we were able to see that the <code>WeatherService</code> class doesn’t need to know whether it’s using a real or a mock API client, making the system more modular and easier to test.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor269"/>Implementing the Dependency Injection pattern – using a decorator</h2>
			<p>It is also possible to use<a id="_idIndexMarker957"/> decorators for DI, which simplifies the injection process. Let’s see a simple example demonstrating how to do that, where we’ll create a notification system that can send notifications through different channels (for example, email or SMS). The first part of the example will show the result based on manual testing, and the second part will provide unit tests.</p>
			<p>First, we define a <code>NotificationSender</code> interface, outlining the methods any notification <a id="_idIndexMarker958"/>sender <a id="_idIndexMarker959"/>should have:</p>
			<pre class="source-code">
from typing import Protocol
class NotificationSender(Protocol):
    def send(self, message: str):
        """Send a notification with the given message"""
        ...</pre>			<p>Then, we implement two specific notification senders: the <code>EmailSender</code> class implements sending a notification using email, and the <code>SMSSender</code> class implements sending using SMS. This part of the code is as follows:</p>
			<pre class="source-code">
class EmailSender:
    def send(self, message: str):
        print(f"Sending Email: {message}")
class SMSSender:
    def send(self, message: str):
        print(f"Sending SMS: {message}")</pre>			<p>We also define a notification service class, <code>NotificationService</code>, with a class attribute sender and a <code>.notify()</code> method, which takes in a message and calls <code>.send()</code> on the provided sender object to send the message, as follows:</p>
			<pre class="source-code">
class NotificationService:
    sender: NotificationSender = None
    def notify(self, message):
        self.sender.send(message)</pre>			<p>What is missing is the<a id="_idIndexMarker960"/> decorator that will operate the DI, to<a id="_idIndexMarker961"/> provide the specific sender object to be used. We create our decorator to decorate the <code>NotificationService</code> class for injecting the sender. It will be used <a id="_idIndexMarker962"/>by calling <code>@inject_sender(EmailSender)</code> if we want to inject the email sender, or <code>@inject_sender(SMSSender)</code> if we want to inject the SMS sender. The code for the decorator is as follows:</p>
			<pre class="source-code">
def inject_sender(sender_cls):
    def decorator(cls):
        cls.sender = sender_cls()
        return cls
    return decorator</pre>			<p>Now, if we come back to<a id="_idIndexMarker963"/> the notification service’s class, the code would be as follows:</p>
			<pre class="source-code">
@inject_sender(EmailSender)
class NotificationService:
    sender: NotificationSender = None
    def notify(self, message):
        self.sender.send(message)</pre>			<p>Finally, we can instantiate <a id="_idIndexMarker964"/>the <code>NotificationService</code> class in our application and notify a message for testing the implementation, as follows:</p>
			<pre class="source-code">
if __name__ == "__main__":
    service = NotificationService()
    service.notify("Hello, this is a test notification!")</pre>			<p>That first part of our example (in the <code>ch10/dependency_injection/di_with_decorator.py</code> file) can be manually tested by using the following command:</p>
			<pre class="source-code">
<strong class="bold">python ch10/dependency_injection/di_with_decorator.py</strong></pre>			<p>You should get the following output:</p>
			<pre class="console">
Sending Email: Hello, this is a test notification!</pre>			<p>If you change the decorating line, replace the <code>EmailSender</code> class with <code>SMSSender</code>, and <a id="_idIndexMarker965"/>rerun that command, you will <a id="_idIndexMarker966"/>get the following output:</p>
			<pre class="console">
Sending SMS: Hello, this is a test notification!</pre>			<p>That shows the DI is effective.</p>
			<p>Next, we want to write<a id="_idIndexMarker967"/> unit tests for that implementation. We could use the mocking technique, but to see other ways, we are going to use the stub classes approach. The stubs manually implement the dependency interfaces and include additional mechanisms to verify that methods have been called correctly. Let’s start by importing what we need:</p>
			<pre class="source-code">
import unittest
from di_with_decorator import (
    NotificationSender,
    NotificationService,
    inject_sender,
)</pre>			<p>Then, we create stub classes that implement the <code>NotificationSender</code> interface. These classes will help record calls to their <code>send()</code> method, using the <code>messages_sent</code> attribute on their instances, allowing us to check whether the correct methods were called<a id="_idIndexMarker968"/> during the test. Both stub<a id="_idIndexMarker969"/> classes are as follows:</p>
			<pre class="source-code">
class EmailSenderStub:
    def __init__(self):
        self.messages_sent = []
    def send(self, message: str):
        self.messages_sent.append(message)
class SMSSenderStub:
    def __init__(self):
        self.messages_sent = []
    def send(self, message: str):
        self.messages_sent.append(message)</pre>			<p>Next, we are going to use<a id="_idIndexMarker970"/> both stubs in our test case to <a id="_idIndexMarker971"/>verify the functionality of <code>NotificationService</code>. In the test function, <code>test_notify_with_email</code>, we create an instance of <code>EmailSenderStub</code>, inject that stub into the service, send a notification message, and then verify that the message was sent by the email <a id="_idIndexMarker972"/>stub. That part of the code is as follows:</p>
			<pre class="source-code">
class TestNotifService(unittest.TestCase):
    def test_notify_with_email(self):
        email_stub = EmailSenderStub()
        service = NotificationService()
        service.sender = email_stub
        service.notify("Test Email Message")
        self.assertIn(
            "Test Email Message",
            email_stub.messages_sent,
        )</pre>			<p>We need another function for the notification with SMS functional<a id="_idTextAnchor270"/>ity, <code>test_notify_with_sms</code>. Similarly to the previous case, we create an instance of <code>SMSSenderStub</code>. Then, we need to inject that stub into the notification service. But, for that, in the scope of the test, we define a custom notification service class, and decorate it with <code>@inject_sender(SMSSenderStub)</code>, as follows:</p>
			<pre class="source-code">
@inject_sender(SMSSenderStub)
class CustomNotificationService:
    sender: NotificationSender = None
    def notify(self, message):
        self.sender.send(message)</pre>			<p>Based on that, we<a id="_idIndexMarker973"/> inject the SMS sender stub into the<a id="_idIndexMarker974"/> custom service, send a notification<a id="_idIndexMarker975"/> message, and then verify that the message was sent by the SMS stub. The complete code for the second unit test is as follows:</p>
			<pre class="source-code">
    def test_notify_with_sms(self):
        sms_stub = SMSSenderStub()
        @inject_sender(SMSSenderStub)
        class CustomNotificationService:
            sender: NotificationSender = None
            def notify(self, message):
                self.sender.send(message)
        service = CustomNotificationService()
        service.sender = sms_stub
        service.notify("Test SMS Message")
        self.assertIn(
            "Test SMS Message", sms_stub.messages_sent
        )</pre>			<p>Finally, we should not<a id="_idIndexMarker976"/> forget to add the lines needed for <a id="_idIndexMarker977"/>executing unit tests when the <a id="_idIndexMarker978"/>file is interpreted by Python:</p>
			<pre class="source-code">
if __name__ == "__main__":
    unittest.main()</pre>			<p>Executing the unit test code (in the <code>ch10/dependency_injection/test_di_with_decorator.py</code> file), using the <code>python ch10/dependency_injection/test_di_with_decorator.py</code> command, gives the following output:</p>
			<pre class="console">
..
---------------------------------------------------------
Ran 2 tests in 0.000s
OK</pre>			<p>This is what was expected.</p>
			<p>So, this example showed how using a decorator to manage dependencies allows for easy changes without modifying the class internals, <a id="_idTextAnchor271"/>which not only keeps the application flexible but also encapsulates the dependency management outside of the core business logic of your application. In addition, we saw how DI can be tested with unit tests using the stubs technique, ensuring the application’s components work as expected in isolation.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor272"/>Summary</h1>
			<p>In this chapter, we’ve explored two pivotal patterns essential for writing clean code and enhancing our testing strategies: the Mock Object pattern and the Dependency Injection pattern.</p>
			<p>The Mock Object pattern is crucial for ensuring test isolation, which helps avoid unwanted side effects. It also facilitates behavior verification and simplifies test setup. We discussed how mocking, particularly through the <code>unittest.mock</code> module, allows us to simulate components within a unit test, demonstrating this with a practical example.</p>
			<p>The Dependency Injection pattern, on the other hand, offers a robust framework for managing dependencies in a way that enhances flexibility, testability, and maintainability. It’s applicable not only in testing scenarios but also in general software design. We illustrated this pattern with an initial example that integrates mocking for either unit or integration tests. Subsequently, we explored a more advanced implementation using a decorator to streamline dependency management across both the application and its tests.</p>
			<p>As we conclude this chapter and prepare to enter the final one, we’ll shift our focus slightly to discuss Python anti-patterns, identifying common pitfalls, and learning how to avoid them.</p>
		</div>
	</body></html>