<html><head></head><body>
		<div id="_idContainer033">
			<h1 id="_idParaDest-236" class="chapter-number"><a id="_idTextAnchor256"/>10</h1>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor257"/>Patterns for Testing</h1>
			<p>In the previous chapters, we covered architectural patterns and patterns for specific use cases such as concurrency <span class="No-Break">or performance.</span></p>
			<p>In this chapter, we will explore design patterns that are particularly useful for testing. These patterns help in isolating components, making tests more reliable, and promoting <span class="No-Break">code reusability.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The Mock <span class="No-Break">Object pattern</span></li>
				<li>The Dependency <span class="No-Break">Injection pattern</span></li>
			</ul>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor258"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor259"/>The Mock Object pattern</h1>
			<p>The <strong class="bold">Mock Object</strong> pattern<a id="_idIndexMarker911"/> is a powerful tool for isolating components during testing by <a id="_idIndexMarker912"/>simulating their behavior. Mock objects help create controlled testing environments and verify interactions <span class="No-Break">between components.</span></p>
			<p>The Mock Object pattern provides <span class="No-Break">three features:</span></p>
			<ol>
				<li><strong class="bold">Isolation</strong>: Mocks isolate<a id="_idIndexMarker913"/> the unit of code being tested, ensuring that tests run in a controlled environment where dependencies are predictable and do not have external <span class="No-Break">side effects.</span></li>
				<li><strong class="bold">Behavior verification</strong>: By using mock objects, you can verify that certain behaviors happen during <a id="_idIndexMarker914"/>a test, such as method calls or <span class="No-Break">property accesses.</span></li>
				<li><strong class="bold">Simplification</strong>: They <a id="_idIndexMarker915"/>simplify the setup of tests by replacing complex real objects that might require significant setup <a id="_idIndexMarker916"/>of <span class="No-Break">their own.</span></li>
			</ol>
			<p class="callout-heading">Comparison with stubs</p>
			<p class="callout">Stubs also replace real implementations but are used only to provide indirect input to the code under test. Mocks, by contrast, can also verify interactions, making them more flexible in many <span class="No-Break">testing scenarios.</span></p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor260"/>Real-world examples</h2>
			<p>We can think of the following analog <a id="_idIndexMarker917"/>concepts or tools in the <span class="No-Break">real world:</span></p>
			<ul>
				<li>A flight simulator, which is a tool designed to replicate the experience of flying an actual airplane. It allows pilots to learn how to handle various flight scenarios in a controlled and <span class="No-Break">safe environment.</span></li>
				<li>A <strong class="bold">cardiopulmonary resuscitation</strong> (<strong class="bold">CPR</strong>) dummy, which is used to teach students how to perform CPR <a id="_idIndexMarker918"/>effectively. It simulates the human body to provide a realistic yet controlled setting <span class="No-Break">for learning.</span></li>
				<li>A crash test dummy, which is used by car manufacturers to simulate human reactions to vehicle collisions. It provides valuable data on the impacts and safety features of a car without putting actual human lives <span class="No-Break">at risk.</span></li>
			</ul>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor261"/>Use cases for the Mock Object pattern</h2>
			<p>In <strong class="bold">unit testing</strong>, mock objects <a id="_idIndexMarker919"/>are used to replace complex, unreliable, or unavailable dependencies of the code being tested. This allows <a id="_idIndexMarker920"/>developers to focus solely on the unit itself rather than its interactions with external systems. For example, when testing a service that fetches data from an API, a mock object can simulate the API by returning predefined responses, ensuring that the service can handle various data scenarios or errors without needing to interact with the <span class="No-Break">actual A<a id="_idTextAnchor262"/>PI.</span></p>
			<p>While similar to<a id="_idIndexMarker921"/> unit testing, <strong class="bold">integration testing</strong> with <a id="_idIndexMarker922"/>mock objects focuses on the interaction between components rather than individual units. Mocks can be used to simulate components that have not been developed yet or are too costly to involve in every test. For example, in a microservices architecture, a mock can represent a service that is under development or temporarily unavailable, allowing other services to be tested in terms of how they integrate and communicate <span class="No-Break">with it.</span></p>
			<p>The Mock Object pattern is also useful <a id="_idIndexMarker923"/>for <strong class="bold">behavior verification</strong>. This use case involves verifying that certain interactions between objects occur as expected. Mock objects can be programmed to expect specific calls, arguments, and even order of interactions, which makes them powerful tools for behavioral testing; for example, testing whether a controller, in a <strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>) architecture, correctly<a id="_idIndexMarker924"/> calls authentication and logging services before processing a user request. Mocks can verify that the controller makes the right calls in the right order, such <a id="_idIndexMarker925"/>as checking credentials before attempting to log <span class="No-Break">the request.</span></p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor263"/>Implementing the Mock Object pattern</h2>
			<p>Imagine we have a <a id="_idIndexMarker926"/>function that logs messages to a file. We can mock the file-writing mechanism to ensure our logging function writes the expected content to the log without writing to a file. Let’s see how this can be implemented using Python’s <span class="No-Break"><strong class="source-inline">unittest</strong></span><span class="No-Break"> module.</span></p>
			<p>First, we import what we need for <span class="No-Break">the example:</span></p>
			<pre class="source-code">
import unittest
from unittest.mock import mock_open, patch</pre>			<p>Then, we create a class representing a simple logger that writes messages to a file specified <span class="No-Break">during initialization:</span></p>
			<pre class="source-code">
class Logger:
    def __init__(self, filepath):
        self.filepath = filepath
    def log(self, message):
        with open(self.filepath, "a") as file:
            file.write(f"{message}\n")</pre>			<p>Next, we create a test case class that inherits from the <strong class="source-inline">unittest.TestCase</strong> class, as usual. In this class, we need the <strong class="source-inline">test_log()</strong> method to test the logger’s <strong class="source-inline">log()</strong> method, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class TestLogger(unittest.TestCase):
    def test_log(self):
        msg = "Hello, logging world!"</pre>			<p>Next, we<a id="_idIndexMarker927"/> are<a id="_idIndexMarker928"/> going to mock the Python built-in <strong class="source-inline">open()</strong> function directly within the test scope. Mocking the function is done using <strong class="source-inline">unittest.mock.patch()</strong>, which temporarily replaces the target object, <strong class="source-inline">builtins.open</strong>, with a mock object (the result of calling <strong class="source-inline">mock_open()</strong>). With the context manager we get from calling the <strong class="source-inline">unittest.mock.patch()</strong> function, we create a <strong class="source-inline">Logger</strong> object and call its <strong class="source-inline">.log()</strong> method, which should trigger the <span class="No-Break"><strong class="source-inline">open()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
        m_open = mock_open()
        with patch("builtins.open", m_open):
            logger = Logger("dummy.log")
            logger.log(msg)</pre>			<p class="callout-heading">About builtins</p>
			<p class="callout">According to Python documentation, the <strong class="source-inline">builtins</strong> module<a id="_idIndexMarker929"/> provides direct access to all built-in identifiers of Python; for example, <strong class="source-inline">builtins.open</strong> is the full name for the <strong class="source-inline">open()</strong> built-in function. <span class="No-Break">See </span><a href="https://docs.python.org/3/library/builtins.html"><span class="No-Break">https://docs.python.org/3/library/builtins.html</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">About mock_open</p>
			<p class="callout">When you call <strong class="source-inline">mock_open()</strong>, it returns a <a id="_idIndexMarker930"/>Mock object that is configured to behave like the built-in <strong class="source-inline">open()</strong> function. This mock is set up to simulate file operations such as reading <span class="No-Break">and writing.</span></p>
			<p class="callout-heading">About unittest.mock.patch</p>
			<p class="callout">It is used to replace objects with<a id="_idIndexMarker931"/> mocks during testing. Its arguments include <strong class="source-inline">target</strong> to specify the object to replace, and optional arguments: <strong class="source-inline">new</strong> for an optional replacement object, <strong class="source-inline">spec</strong> and <strong class="source-inline">autospec</strong> to limit the mock to the real object’s attributes for accuracy, <strong class="source-inline">spec_set</strong> for a stricter attribute specification, <strong class="source-inline">side_effect</strong> to define conditional behavior or exceptions, <strong class="source-inline">return_value</strong> for setting a fixed response, and <strong class="source-inline">wraps</strong> to allow the original object’s behavior while modifying certain aspects. These options enable precise control and flexibility in <span class="No-Break">testing scenarios.</span></p>
			<p>Now, we<a id="_idIndexMarker932"/> check that the log file was opened correctly, which<a id="_idIndexMarker933"/> we do using two verifications. For the first one, we use the <strong class="source-inline">assert_called_once_with()</strong> method on the mock object, to check that the <strong class="source-inline">open()</strong> function was called with the expected parameters. For the second one, we need more tricks from <strong class="source-inline">unittest.mock.mock_open</strong>; our <strong class="source-inline">m_open</strong> mock object, which was obtained by calling the <strong class="source-inline">mock_open()</strong> function, is also a callable object that behaves like a factory for creating new mock file handles each time it’s called. We use that to obtain a new file handle, and then we use <strong class="source-inline">assert_called_once_with()</strong> on the <strong class="source-inline">write()</strong> method call on that file handle, which helps us check if the <strong class="source-inline">write()</strong> method was called with the correct message. This part of the test function is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
            m_open.assert_called_once_with(
                "dummy.log", "a"
            )
            m_open().write.assert_called_once_with(
                f"{msg}\n"
            )</pre>			<p>Finally, we <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">unitest.main()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    unittest.main()</pre>			<p>To execute the example (in the <strong class="source-inline">ch10/mock_object.py</strong> file), as usual, run the following command: </p>
			<pre class="source-code">
<strong class="bold">python ch10/mock_object.py</strong></pre>			<p>You should <a id="_idIndexMarker934"/>get an <a id="_idIndexMarker935"/>output like <span class="No-Break">the following:</span></p>
			<pre class="console">
.
---------------------------------------------------------
Ran 1 test in 0.012s
OK</pre>			<p>That was a quick demonstration of using mocking to simulate parts of a system within a unit test. We can see that this approach isolates side effects (that is, file I/O), ensuring that the unit tests do not create or require actual files. It allows testing the internal behavior of the class without altering the class structure for <span class="No-Break">testing purposes.</span></p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor264"/>The Dependency Injection pattern</h1>
			<p>The <a id="_idIndexMarker936"/>Dependency Injection pattern<a id="_idIndexMarker937"/> involves passing the dependencies of a class as external entities rather than creating them within the class. This promotes loose coupling, modularity, <span class="No-Break">and testability.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor265"/>Real-world examples</h2>
			<p>We come across the following <a id="_idIndexMarker938"/>examples in <span class="No-Break">real life:</span></p>
			<ul>
				<li><strong class="bold">Electrical appliances and power outlets</strong>: Various electrical appliances can be plugged into different power outlets to use electricity without needing direct and <span class="No-Break">permanent wiring</span></li>
				<li><strong class="bold">Lenses on cameras</strong>: A photographer can change lenses on a camera to suit different environments and needs without changing the <span class="No-Break">camera itself</span></li>
				<li><strong class="bold">Modular train systems</strong>: In a modular train system, individual cars (such as sleeper, diner, or baggage cars) can be added or removed depending on the needs of <span class="No-Break">each</span><span class="No-Break"><a id="_idIndexMarker939"/></span><span class="No-Break"> journey</span></li>
			</ul>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor266"/>Use cases for the Dependency Injection pattern</h2>
			<p>In web <a id="_idIndexMarker940"/>applications, injecting <a id="_idIndexMarker941"/>database connection objects into components such as repositories or services enhances modularity and maintainability. This practice allows for an easy switch between different database engines or configurations without the need to alter the component’s code directly. It also significantly simplifies the process of unit testing by enabling the injection of mock database connections, thereby testing various data scenarios without affecting the <span class="No-Break">live databases.</span></p>
			<p>Another type of use case is managing configuration settings across various environments (development, testing, production, and so on). By dynamically injecting settings into <a id="_idIndexMarker942"/>modules, <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) reduces coupling between the modules and their configuration sources. This flexibility makes it easier to manage and switch environments without needing extensive reconfiguration. In unit testing, this means you can inject specific settings to test how modules perform under different configurations, ensuring robustness <span class="No-Break">and functionality.</span></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor267"/>Implementing the Dependency Injection pattern – using a mock object</h2>
			<p>In this first example, we’ll<a id="_idIndexMarker943"/> create a simple scenario where a <strong class="source-inline">WeatherService</strong> class depends on a <strong class="source-inline">WeatherApiClient</strong> interface<a id="_idIndexMarker944"/> to fetch weather data. For the example’s unit test code, we will inject a mock version of this <span class="No-Break">API client.</span></p>
			<p>We start by defining the interface any weather API client implementation should conform to, using Python’s <span class="No-Break"><strong class="source-inline">Protocol</strong></span><span class="No-Break"> feature:</span></p>
			<pre class="source-code">
from typing import Protocol
class WeatherApiClient(Protocol):
    def fetch_weather(self, location):
        """Fetch weather data for a given<a id="_idTextAnchor268"/> location"""
        ...</pre>			<p>Then, we add a <strong class="source-inline">RealWeatherApiClient</strong> class that implements that interface and that would <a id="_idIndexMarker945"/>interact with our weather service. In a real scenario, in the provided <strong class="source-inline">fetch_weather()</strong> method, we would perform a call to a weather service, but we want to keep the example simple and focus on the main concepts of this chapter; so, we provide a simulation, simply returning a string that represents the weather data result. The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class RealWeatherApiClient:
    def fetch_weather(self, location):
        return f"Real weather data for {location}"</pre>			<p>Next, we create a weather<a id="_idIndexMarker946"/> service, which uses an object that implements the <strong class="source-inline">WeatherApiClient</strong> interface to fetch <span class="No-Break">weather data:</span></p>
			<pre class="source-code">
class WeatherService:
    def __init__(self, weather_api: WeatherApiClient):
        self.weather_api = weather_api
    def get_weather(self, location):
        return self.weather_api.fetch_weather(location)</pre>			<p>Finally, we are ready to inject the API client’s dependency through the <strong class="source-inline">WeatherService</strong> constructor. We add code that helps manually test the example, using the real service, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    ws = WeatherService(RealWeatherApiClient())
    print(ws.get_weather("Paris"))</pre>			<p>This part of our <a id="_idIndexMarker947"/>example (in the <strong class="source-inline">ch10/dependency_injection/di_with_mock.py</strong> file) can be manually tested by using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
<strong class="bold">python ch10/dependency_injection/di_with_mock.py</strong></pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">Real weather data for Paris</strong></pre>			<p>Since the interesting part of our example is about unit testing, let’s add that part (in a second <span class="No-Break">file, </span><span class="No-Break"><strong class="source-inline">ch10/dependency_injection/test_di_with_mock.py</strong></span><span class="No-Break">).</span></p>
			<p>First, we import the <strong class="source-inline">unittest</strong> module, as <a id="_idIndexMarker948"/>well as the <strong class="source-inline">WeatherService</strong> class (from our <strong class="source-inline">di_with_mock</strong> module), <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import unittest
from di_with_mock import WeatherService</pre>			<p>Then, we create a mock<a id="_idIndexMarker949"/> version of the weather API client <a id="_idIndexMarker950"/>implementation that will be useful for unit testing, simulating responses without making real <span class="No-Break">API calls:</span></p>
			<pre class="source-code">
class MockWeatherApiClient:
    def fetch_weather(self, location):
        return f"Mock weather data for {location}"</pre>			<p>Next, we write the test case class, with a test function. In that function, we inject the mock API client instead of<a id="_idIndexMarker951"/> the real API client, passing it to the <strong class="source-inline">WeatherService</strong> constructor, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class TestWeatherService(unittest.TestCase):
    def test_get_weather(self):
        mock_api = MockWeatherApiClient()
        weather_service = WeatherService(mock_api)
        self.assertEqual(
            weather_service.get_weather("Anywhere"),
            "Mock weather data for Anywhere",
        )</pre>			<p>We finish by adding the usual lines for executing unit tests when the file is interpreted <span class="No-Break">by Python:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    unittest.main()</pre>			<p>Executing this part of the example (in the <strong class="source-inline">ch10/dependency_injection/test_di_with_mock.py</strong> file), using the <strong class="source-inline">python ch10/dependency_injection/test_di_with_mock.py</strong> command, gives <a id="_idIndexMarker952"/>the<a id="_idIndexMarker953"/> <span class="No-Break">following output:</span></p>
			<pre class="console">
.
---------------------------------------------------------
Ran 1 test in 0.000s
OK</pre>			<p>The test with the <a id="_idIndexMarker954"/>dependency injected <a id="_idIndexMarker955"/>using a mock <span class="No-Break">object </span><span class="No-Break"><a id="_idIndexMarker956"/></span><span class="No-Break">succeeded.</span></p>
			<p>Through this example, we were able to see that the <strong class="source-inline">WeatherService</strong> class doesn’t need to know whether it’s using a real or a mock API client, making the system more modular and easier <span class="No-Break">to test.</span></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor269"/>Implementing the Dependency Injection pattern – using a decorator</h2>
			<p>It is also possible to use<a id="_idIndexMarker957"/> decorators for DI, which simplifies the injection process. Let’s see a simple example demonstrating how to do that, where we’ll create a notification system that can send notifications through different channels (for example, email or SMS). The first part of the example will show the result based on manual testing, and the second part will provide <span class="No-Break">unit tests.</span></p>
			<p>First, we define a <strong class="source-inline">NotificationSender</strong> interface, outlining the methods any notification <a id="_idIndexMarker958"/>sender <a id="_idIndexMarker959"/><span class="No-Break">should have:</span></p>
			<pre class="source-code">
from typing import Protocol
class NotificationSender(Protocol):
    def send(self, message: str):
        """Send a notification with the given message"""
        ...</pre>			<p>Then, we implement two specific notification senders: the <strong class="source-inline">EmailSender</strong> class implements sending a notification using email, and the <strong class="source-inline">SMSSender</strong> class implements sending using SMS. This part of the code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class EmailSender:
    def send(self, message: str):
        print(f"Sending Email: {message}")
class SMSSender:
    def send(self, message: str):
        print(f"Sending SMS: {message}")</pre>			<p>We also define a notification service class, <strong class="source-inline">NotificationService</strong>, with a class attribute sender and a <strong class="source-inline">.notify()</strong> method, which takes in a message and calls <strong class="source-inline">.send()</strong> on the provided sender object to send the message, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class NotificationService:
    sender: NotificationSender = None
    def notify(self, message):
        self.sender.send(message)</pre>			<p>What is missing is the<a id="_idIndexMarker960"/> decorator that will operate the DI, to<a id="_idIndexMarker961"/> provide the specific sender object to be used. We create our decorator to decorate the <strong class="source-inline">NotificationService</strong> class for injecting the sender. It will be used <a id="_idIndexMarker962"/>by calling <strong class="source-inline">@inject_sender(EmailSender)</strong> if we want to inject the email sender, or <strong class="source-inline">@inject_sender(SMSSender)</strong> if we want to inject the SMS sender. The code for the decorator is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def inject_sender(sender_cls):
    def decorator(cls):
        cls.sender = sender_cls()
        return cls
    return decorator</pre>			<p>Now, if we come back to<a id="_idIndexMarker963"/> the notification service’s class, the code would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@inject_sender(EmailSender)
class NotificationService:
    sender: NotificationSender = None
    def notify(self, message):
        self.sender.send(message)</pre>			<p>Finally, we can instantiate <a id="_idIndexMarker964"/>the <strong class="source-inline">NotificationService</strong> class in our application and notify a message for testing the implementation, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    service = NotificationService()
    service.notify("Hello, this is a test notification!")</pre>			<p>That first part of our example (in the <strong class="source-inline">ch10/dependency_injection/di_with_decorator.py</strong> file) can be manually tested by using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
<strong class="bold">python ch10/dependency_injection/di_with_decorator.py</strong></pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Sending Email: Hello, this is a test notification!</pre>			<p>If you change the decorating line, replace the <strong class="source-inline">EmailSender</strong> class with <strong class="source-inline">SMSSender</strong>, and <a id="_idIndexMarker965"/>rerun that command, you will <a id="_idIndexMarker966"/>get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Sending SMS: Hello, this is a test notification!</pre>			<p>That shows the DI <span class="No-Break">is effective.</span></p>
			<p>Next, we want to write<a id="_idIndexMarker967"/> unit tests for that implementation. We could use the mocking technique, but to see other ways, we are going to use the stub classes approach. The stubs manually implement the dependency interfaces and include additional mechanisms to verify that methods have been called correctly. Let’s start by importing what <span class="No-Break">we need:</span></p>
			<pre class="source-code">
import unittest
from di_with_decorator import (
    NotificationSender,
    NotificationService,
    inject_sender,
)</pre>			<p>Then, we create stub classes that implement the <strong class="source-inline">NotificationSender</strong> interface. These classes will help record calls to their <strong class="source-inline">send()</strong> method, using the <strong class="source-inline">messages_sent</strong> attribute on their instances, allowing us to check whether the correct methods were called<a id="_idIndexMarker968"/> during the test. Both stub<a id="_idIndexMarker969"/> classes are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class EmailSenderStub:
    def __init__(self):
        self.messages_sent = []
    def send(self, message: str):
        self.messages_sent.append(message)
class SMSSenderStub:
    def __init__(self):
        self.messages_sent = []
    def send(self, message: str):
        self.messages_sent.append(message)</pre>			<p>Next, we are going to use<a id="_idIndexMarker970"/> both stubs in our test case to <a id="_idIndexMarker971"/>verify the functionality of <strong class="source-inline">NotificationService</strong>. In the test function, <strong class="source-inline">test_notify_with_email</strong>, we create an instance of <strong class="source-inline">EmailSenderStub</strong>, inject that stub into the service, send a notification message, and then verify that the message was sent by the email <a id="_idIndexMarker972"/>stub. That part of the code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class TestNotifService(unittest.TestCase):
    def test_notify_with_email(self):
        email_stub = EmailSenderStub()
        service = NotificationService()
        service.sender = email_stub
        service.notify("Test Email Message")
        self.assertIn(
            "Test Email Message",
            email_stub.messages_sent,
        )</pre>			<p>We need another function for the notification with SMS functional<a id="_idTextAnchor270"/>ity, <strong class="source-inline">test_notify_with_sms</strong>. Similarly to the previous case, we create an instance of <strong class="source-inline">SMSSenderStub</strong>. Then, we need to inject that stub into the notification service. But, for that, in the scope of the test, we define a custom notification service class, and decorate it with <strong class="source-inline">@inject_sender(SMSSenderStub)</strong>, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@inject_sender(SMSSenderStub)
class CustomNotificationService:
    sender: NotificationSender = None
    def notify(self, message):
        self.sender.send(message)</pre>			<p>Based on that, we<a id="_idIndexMarker973"/> inject the SMS sender stub into the<a id="_idIndexMarker974"/> custom service, send a notification<a id="_idIndexMarker975"/> message, and then verify that the message was sent by the SMS stub. The complete code for the second unit test is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
    def test_notify_with_sms(self):
        sms_stub = SMSSenderStub()
        @inject_sender(SMSSenderStub)
        class CustomNotificationService:
            sender: NotificationSender = None
            def notify(self, message):
                self.sender.send(message)
        service = CustomNotificationService()
        service.sender = sms_stub
        service.notify("Test SMS Message")
        self.assertIn(
            "Test SMS Message", sms_stub.messages_sent
        )</pre>			<p>Finally, we should not<a id="_idIndexMarker976"/> forget to add the lines needed for <a id="_idIndexMarker977"/>executing unit tests when the <a id="_idIndexMarker978"/>file is interpreted <span class="No-Break">by Python:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    unittest.main()</pre>			<p>Executing the unit test code (in the <strong class="source-inline">ch10/dependency_injection/test_di_with_decorator.py</strong> file), using the <strong class="source-inline">python ch10/dependency_injection/test_di_with_decorator.py</strong> command, gives the <span class="No-Break">following output:</span></p>
			<pre class="console">
..
---------------------------------------------------------
Ran 2 tests in 0.000s
OK</pre>			<p>This is what <span class="No-Break">was expected.</span></p>
			<p>So, this example showed how using a decorator to manage dependencies allows for easy changes without modifying the class internals, <a id="_idTextAnchor271"/>which not only keeps the application flexible but also encapsulates the dependency management outside of the core business logic of your application. In addition, we saw how DI can be tested with unit tests using the stubs technique, ensuring the application’s components work as expected <span class="No-Break">in isolation.</span></p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor272"/>Summary</h1>
			<p>In this chapter, we’ve explored two pivotal patterns essential for writing clean code and enhancing our testing strategies: the Mock Object pattern and the Dependency <span class="No-Break">Injection pattern.</span></p>
			<p>The Mock Object pattern is crucial for ensuring test isolation, which helps avoid unwanted side effects. It also facilitates behavior verification and simplifies test setup. We discussed how mocking, particularly through the <strong class="source-inline">unittest.mock</strong> module, allows us to simulate components within a unit test, demonstrating this with a <span class="No-Break">practical example.</span></p>
			<p>The Dependency Injection pattern, on the other hand, offers a robust framework for managing dependencies in a way that enhances flexibility, testability, and maintainability. It’s applicable not only in testing scenarios but also in general software design. We illustrated this pattern with an initial example that integrates mocking for either unit or integration tests. Subsequently, we explored a more advanced implementation using a decorator to streamline dependency management across both the application and <span class="No-Break">its tests.</span></p>
			<p>As we conclude this chapter and prepare to enter the final one, we’ll shift our focus slightly to discuss Python anti-patterns, identifying common pitfalls, and learning how to <span class="No-Break">avoid them.</span></p>
		</div>
	</body></html>