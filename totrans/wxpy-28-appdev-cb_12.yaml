- en: Chapter 12. Building and Managing Applications for Distribution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 建立和管理分发应用
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Working with `StandardPaths`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `StandardPaths`
- en: Persisting the state of the UI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持用户界面状态
- en: Using the `SingleInstanceChecker`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SingleInstanceChecker`
- en: Exception handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Optimizing for OS X
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化针对 OS X
- en: Supporting internationalization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持国际化
- en: Distributing an application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发应用程序
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: An application's infrastructure provides the backbone for the application's
    inner workings, which are often things that are not directly apparent to the user
    but are critical to the application's functionality. This includes things such
    as storing configuration and external data files, error handling, and installation.
    Each of these areas provides important functionality and contributes to the usability
    and the end-user's overall perception of the application. In this chapter, we
    will take an in-depth tour of a number of these topics and more, in order to provide
    you with the appropriate tools to help build and distribute your application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的基础设施为应用程序的内部运作提供了骨架，这些内部运作通常是用户无法直接看到的，但对于应用程序的功能至关重要。这包括诸如存储配置和外部数据文件、错误处理和安装等方面。这些领域的每一个都提供了重要的功能，并有助于提高应用程序的可用性和最终用户对应用程序的整体印象。在本章中，我们将深入探讨这些主题以及更多内容，以便为您提供适当的工具来帮助构建和分发您的应用程序。
- en: Working with StandardPaths
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 StandardPaths 一起工作
- en: Nearly every non-trivial application is going to have the need to store data
    to use between usage of the program and to load resources such as images. The
    question is where to put this stuff? The appropriate locations where the operating
    system and users expect to find these files will vary from platform to platform.
    This recipe shows how to use `wx.StandardPaths` to manage an application's configuration
    and resource files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个非平凡的应用都需要在程序使用之间存储数据以及加载资源，如图片。问题是把这些东西放在哪里？操作系统和用户期望在这些平台上找到这些文件的位置可能会有所不同。这个菜谱展示了如何使用
    `wx.StandardPaths` 来管理应用程序的配置和资源文件。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Here, we will create a thin wrapper utility class to help manage an application's
    configuration files and data. The constructor will ensure that any predefined
    directories have been set up in the configuration storage location on the system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个薄封装实用类来帮助管理应用程序的配置文件和数据。构造函数将确保任何预定义的目录已经在系统配置存储位置设置好。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we add a helper function to create a directory in the current user''s
    data directory:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加一个辅助函数来在当前用户的资料目录中创建一个目录：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next function can be used to get the absolute path to a file or directory
    in the user''s data directory:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数可以用来获取用户数据目录中文件或目录的绝对路径：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, the last method in this class can be used to check if a given configuration
    file has been created yet or not:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本类中的最后一个方法可以用来检查指定的配置文件是否已经创建：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ConfigHelper` class just provides a thin simple wrapper around some of
    the `StandardPaths` methods, in order to make it a little easier to use. When
    the object is created, it will make sure that the user data directory and any
    of its application-specific subdirectories have been created. The `StandardPaths`
    singleton uses the application's name to determine the name of the user's data
    directory. Because of this, it is important to wait until the `App` object has
    been created and had its name set with `SetAppName`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigHelper` 类只是对一些 `StandardPaths` 方法进行了一个简单的封装，以便使其使用起来更加方便。当对象被创建时，它会确保用户数据目录及其任何应用程序特定的子目录已经被创建。`StandardPaths`
    单例使用应用程序的名称来确定用户数据目录的名称。因此，在创建 `App` 对象并使用 `SetAppName` 设置其名称之前，等待是很重要的。'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `CreateUserCfgDir` provides a convenient way to create a new directory inside
    the user's main configuration directory. `GetUserConfigPath` can be used to get
    the full path to a file or directory in the configuration directory or subdirectory,
    by using a path relative to the main directory. Finally, `HasConfigFile` is a
    simple way to check if a file exists in the user's configuration files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateUserCfgDir` 提供了一种方便的方法在用户的主要配置目录内创建一个新的目录。`GetUserConfigPath` 可以通过使用相对于主目录的路径来获取配置目录或子目录中文件或目录的完整路径。最后，`HasConfigFile`
    是一种简单的方法来检查用户配置文件中是否存在文件。'
- en: There's more...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `StandardPaths` singleton provides a number of other methods to get other
    system and installation-specific installation paths. The following table describes
    some of these additional methods:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardPaths` 单例提供了许多其他方法来获取其他系统和特定安装的安装路径。以下表格描述了这些附加方法：'
- en: '| Methods | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GetConfigDir()` | Returns the system-level configuration directory |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `GetConfigDir()` | 返回系统级配置目录 |'
- en: '| `GetDataDir()` | Returns the application''s global (non user specific) data
    directory |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `GetDataDir()` | 返回应用程序的全局（非用户特定）数据目录 |'
- en: '| `GetDocumentsDir()` | Returns the current user''s documents directory |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `GetDocumentsDir()` | 返回当前用户的文档目录 |'
- en: '| `GetExecutablePath()` | Returns the path to the currently-running executable
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `GetExecutablePath()` | 返回当前运行的可执行文件的路径 |'
- en: '| `GetPluginsDir()` | Returns the path to where the application''s plug-ins
    should reside |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `GetPluginsDir()` | 返回应用程序插件应驻留的路径 |'
- en: '| `GetTempDir()` | Returns the path to the system''s `TEMP` directory |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `GetTempDir()` | 返回系统 `TEMP` 目录的路径 |'
- en: '| `GetUserConigDir()` | Returns the path to the current user''s configuration
    directory |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `GetUserConigDir()` | 返回当前用户的配置目录路径 |'
- en: See also
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Creating Singletons* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for a discussion
    about what singletons, such as the `StandardPaths` object, are.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第9章](ch09.html "第9章。设计方法和技巧")中的*创建单例*配方，在*设计方法和技巧*中讨论了单例，例如`StandardPaths`对象，是什么。
- en: See the *Persisting the state of the UI* recipe in this chapter for more information
    on storing confirmation information.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关存储确认信息的更多信息，请参阅本章中的*持久化UI状态*配方。
- en: Persisting the state of the UI
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持用户界面状态
- en: A common feature that many applications have is to be able to remember and restore
    their window size and position between launches of the program. This is not a
    built-in feature provided by the toolkit, so this recipe will create a simple
    `Frame` base class that will automatically save and restore its size and position
    on the desktop between uses of the application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序的共同特点是在程序启动之间能够记住并恢复它们的窗口大小和位置。这不是工具包提供的内置功能，因此这个配方将创建一个简单的`Frame`基类，该类将在应用程序使用之间自动保存和恢复其在桌面上的大小和位置。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This example shows one approach to creating a `Frame` class that will automatically
    restore its position and size between runs of the program:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了创建一个`Frame`类的一种方法，该类将在程序运行之间自动恢复其位置和大小：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we handle `EVT_CLOSE` for when the `Frame` is closing, in order to save
    its position and size to the `Config` object, which is the registry on Windows
    and a `.ini` file on other platforms:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们处理 `EVT_CLOSE` 事件，用于在 `Frame` 关闭时，将其位置和大小保存到 `Config` 对象中，在 Windows 上是注册表，在其他平台上是
    `.ini` 文件：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `RestoreState` method restores the currently-stored window state or the
    default state if nothing has been stored yet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestoreState` 方法恢复当前存储的窗口状态，或者如果没有存储任何内容，则恢复默认状态：'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `PersistentFrame` should be used as a base class for any `Frame` in an application
    that should persist its size and position on exit. The way in which this class
    works is rather simple, so let's take a quick look at how it works.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应将`PersistentFrame`用作任何需要在退出时持久化其大小和位置的`Frame`的应用程序的基础类。这个类的工作方式相当简单，所以让我们快速了解一下它是如何工作的。
- en: First, in order to save its size and position, the `PersisistentFrame` binds
    an event handler to `EVT_CLOSE`. Its `_OnClose` method will then be called when
    the user closes the `Frame`. In this event handler, we simply get the current
    size and position of the `Frame` and save it to a `wx.Config` object, which will
    be the registry on Windows and a `.ini` file on other platforms.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了节省其大小和位置，`PersisistentFrame` 将事件处理器绑定到 `EVT_CLOSE`。当用户关闭 `Frame` 时，将调用其
    `_OnClose` 方法。在这个事件处理器中，我们简单地获取 `Frame` 的当前大小和位置，并将其保存到一个 `wx.Config` 对象中，在 Windows
    上这将作为注册表，在其他平台上则是一个 `.ini` 文件。
- en: Conversely, when the `PersistentFrame` is created, it tries to read the previously-saved
    size and position from the configuration. This happens in the `RestoreState` method,
    which is initiated with `CallAfter`. This was done to make sure that we don't
    restore the settings until after the `Frame` has been created, so that if a subclass
    sets up some default sizes they won't override the last state that the user left
    it in. In `RestoreState`, if there is stored information for the `Frame`, it will
    load the strings and convert them back to tuples using the `eval` function, and
    then will simply apply the settings.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当创建`PersistentFrame`时，它会尝试从配置中读取之前保存的大小和位置。这发生在`RestoreState`方法中，该方法通过`CallAfter`来启动。这样做是为了确保我们不会在`Frame`创建之后恢复设置，这样如果子类设置了一些默认大小，它们就不会覆盖用户最后留下的最后状态。在`RestoreState`中，如果为`Frame`存储了信息，它将使用`eval`函数加载字符串并将它们转换回元组，然后简单地应用这些设置。
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For simplicity, we just used `wx.Config` for storing the settings between running
    the application. We could have also used `StandardPaths` and written out our own
    configuration file to the user's configuration directory, like we did in the previous
    recipe in order to ensure that this information was kept where the user expects
    it to be.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们只是使用了`wx.Config`来存储应用程序运行之间的设置。我们也可以使用`StandardPaths`并编写我们自己的配置文件到用户的配置目录，就像我们在之前的菜谱中所做的那样，以确保这些信息被保存在用户期望的位置。
- en: See also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Working with StandardPaths* recipe in this chapter for information
    about another class that can help with storing and locating configuration information.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的 *使用 StandardPaths* 菜单以获取有关另一个可帮助存储和定位配置信息的类的信息。
- en: Using the SingleInstanceChecker
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SingleInstanceChecker
- en: Sometimes it is desirable to only allow a single instance of an application
    to exist at any given time. The `SingleInstanceChecker` class provides a way to
    detect if any instances of the application are already running. This recipe creates
    an `App` class that uses the `SingleInstanceChecker` to maintain only a single
    running instance of the application on the computer at one time, and also uses
    a simple IPC mechanism to allow any subsequent instances of the application to
    send a message to the original instance to tell it to open a new window.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能希望在任何给定时间只允许一个应用程序实例存在。`SingleInstanceChecker` 类提供了一种检测应用程序是否已有实例正在运行的方法。这个配方创建了一个
    `App` 类，它使用 `SingleInstanceChecker` 来确保计算机上一次只运行一个应用程序实例，并且还使用了一个简单的 IPC 机制，允许任何后续的应用程序实例向原始实例发送消息，告知其打开一个新窗口。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here, we will create an `App` base class that ensures that only one instance
    of the process is running at a time, and supports a simple, socket-based inter-process
    communication mechanism to inform an already-running instance that a new one tried
    to start:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个`App`基类，确保同一时间只运行一个进程实例，并支持一个简单的基于套接字的进程间通信机制，以通知已运行的实例有一个新的实例尝试启动：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `SingleInstanceChecker` needs to be explicitly deleted when the application
    exits to ensure that the file lock that it creates is released:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序退出时，需要显式删除`SingleInstanceChecker`以确保它创建的文件锁被释放：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `IpcServer` class implements the inter-process communication by opening
    a connection to a socket on the local loopback of the machine. This has been implemented
    as a background thread that loops, waiting for messages, until it is told to exit:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`IpcServer` 类通过在机器的本地回环上打开一个套接字连接来实现进程间通信。这已被实现为一个循环等待消息的后台线程，直到收到退出指令：'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `run` method runs the server thread''s main loop of checking the socket
    for messages and using `CallAfter` to notify the `App` to call its `DoOpenNewWindow`
    method when the server has received an`''OpenWindow''` command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 方法运行服务器线程的主循环，检查套接字是否有消息，并使用 `CallAfter` 通知 `App` 调用其 `DoOpenNewWindow`
    方法，当服务器接收到 `''OpenWindow''` 命令时：'
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `SendMessage` function is used to open a client connection to the `IpcServer''s`
    socket and send it the given message:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendMessage` 函数用于打开到 `IpcServer` 的套接字的客户端连接并发送指定的消息：'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Included with the code that accompanies this chapter is a complete running application
    showing how to use the above framework. To test it out, try starting multiple
    instances of the application on the same computer, and see that only the original
    process is running and that each subsequent launch results in a new window being
    opened in the original process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章配套的代码中包含了一个完整的运行应用程序，展示了如何使用上述框架。为了测试它，尝试在同一台计算机上启动多个应用程序实例，并观察只有原始进程正在运行，并且每次后续启动都会在原始进程中打开一个新窗口。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We packed a lot of stuff into a small amount of code in this recipe, so let's
    go through how each class works.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们在这段代码里塞进了许多内容，所以让我们来了解一下每个类是如何工作的。
- en: The `SingleInstApp` class creates a `SingleInstanceChecker` object to make it
    possible to detect if there is already another instance of the application running.
    As a part of the ID for the `SingleInstanceChecker`, we used the user's login
    ID to make sure that the instance checker is only checking for other instances
    that the same user has started.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingleInstApp` 类创建一个 `SingleInstanceChecker` 对象，以便能够检测是否有另一个应用程序实例正在运行。作为
    `SingleInstanceChecker` 的 ID 的一部分，我们使用了用户的登录 ID，以确保实例检查器只检查同一用户启动的其他实例。'
- en: In our `SingleInstanceApp` object's `__init__` method, it is important to realize
    the order of operations that will take place when a derived class is initialized.
    Calling the base `wx.App` class `__init__` will result in the derived class's
    virtual `OnInit` being called, and then after that the rest of the code in the
    `SingleInstApp's __init__` will run. If it detects that this is the first instance
    of the application running, it will create and start our `IpcServer`. If not,
    it will simply create and send a simple string command to the other, already-running,
    `IpcServer` object to tell it to inform the other application instance to create
    a new window.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `SingleInstanceApp` 对象的 `__init__` 方法中，重要的是要意识到当派生类被初始化时将要发生的操作顺序。调用基类
    `wx.App` 的 `__init__` 方法将会导致派生类的虚拟 `OnInit` 被调用，然后之后 `SingleInstApp` 的 `__init__`
    方法中的其余代码将执行。如果它检测到这是应用程序的第一个运行实例，它将创建并启动我们的 `IpcServer`。如果不是，它将简单地创建并发送一个简单的字符串命令到另一个已经运行的
    `IpcServer` 对象，告诉它通知其他应用程序实例创建一个新窗口。
- en: Before moving on to look at the `IpcServer` class, one very important thing
    to keep in mind when using the `SingleInstanceChecker` is that you need to explicitly
    delete it when you are done with it. If it is not deleted, the file lock that
    it uses for determining if another instance is active or not may never get released,
    which can cause problems on future launches of the program.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续查看 `IpcServer` 类之前，使用 `SingleInstanceChecker` 时需要牢记的一个重要事项是，当你完成使用后，需要显式地删除它。如果不删除，它用于确定另一个实例是否活跃的文件锁可能永远不会释放，这可能会在程序未来的启动中引起问题。
- en: The `IpcServer` class is a simple class derived from `Thread` that uses a TCP
    socket for inter-process communication. As mentioned, the first `SingleInstanceApp`
    that is started will create an instance of this server. The server will run in
    its own thread, checking for messages at the socket. The `IpcServer` thread's
    `run` method just runs a loop, checking the socket for new data. If it is able
    to read a message, it checks that the last part of the message matches the key
    that was used to create the `App's SingleInstanceChecker`, to make sure that the
    command is coming from another instance of the application. We have only designed
    support for a single`'OpenWindow'` command in our simple IPC protocol right now,
    but it could be easily expanded to support more. Upon receiving an `OpenWindow`
    message, the `IpcServer` will use `CallAfter` to call the `SingleInstanceApp's`
    interface method `DoOpenNewWindow` to inform the application to open a new instance
    of its main window.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`IpcServer` 类是一个简单的从 `Thread` 派生的类，它使用 TCP 套接字进行进程间通信。正如所述，第一个启动的 `SingleInstanceApp`
    将创建此服务器的实例。服务器将在自己的线程中运行，检查套接字上的消息。`IpcServer` 线程的 `run` 方法只是运行一个循环，检查套接字上的新数据。如果它能够读取一条消息，它将检查消息的最后部分是否与创建
    `App''s SingleInstanceChecker` 时使用的密钥匹配，以确保命令来自应用程序的另一个实例。我们目前只为我们的简单 IPC 协议设计了支持单个
    `''OpenWindow''` 命令，但它可以很容易地扩展以支持更多。在接收到 `OpenWindow` 消息后，`IpcServer` 将使用 `CallAfter`
    调用 `SingleInstanceApp` 的接口方法 `DoOpenNewWindow`，通知应用程序打开其主窗口的新实例。'
- en: The last part of this little framework is the `SendMessage` function, which
    is used as a client method to connect and send a message to the `IpcServer`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小框架的最后一部分是`SendMessage`函数，它被用作客户端方法来连接并向`IpcServer`发送消息。
- en: See also
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* for
    an explanation about overriding virtual methods in wxPython classes.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第1章](ch01.html "第1章. wxPython入门")中的*理解继承限制*配方，在*wxPython入门*中解释了wxPython类中重写虚拟方法的内容。
- en: See the *Understanding thread safety* recipe in [Chapter 11](ch11.html "Chapter 11. Using
    Threads and Timers to Create Responsive Interfaces"), *Responsive Interfaces*
    for more information about working with threads in a wxPython GUI.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅[第11章](ch11.html "第11章。使用线程和计时器创建响应式界面")中的*理解线程安全性*配方，以获取更多关于在wxPython GUI中处理线程的信息，详见*响应式界面*。
- en: Exception handling
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: In even seemingly-simple applications, it can be difficult to account for all
    possible error conditions that could occur in the application. This recipe shows
    how to handle unhandled exceptions, and how to display a notification to the user
    to let them know that an unexpected error has happened, before the application
    exits.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在看似简单的应用中，也可能难以考虑到应用中可能发生的所有可能的错误条件。本食谱展示了如何处理未处理的异常，以及如何在应用退出之前向用户显示通知，让他们知道发生了意外的错误。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this recipe, we will show how to create a simple exception hook to handle
    and inform the user of any unexpected errors that occur while the program is running:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将展示如何创建一个简单的异常钩子来处理和通知用户在程序运行过程中发生的任何意外错误：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe showed a very simple way to create an exception hook to catch unhandled
    exceptions in the application. During the start-up of the application, all that
    we needed to do was replace the default `excepthook` function with our own `ExceptionHook`
    function. The `ExceptionHook` function will then be called any time that an unhandled
    exception is raised in the application. In this function, all we do is pop up
    a `MessageBox` to show that an unexpected error has occurred, and then tell the
    `MainLoop` to exit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了一种非常简单的方法来创建一个异常钩子，以捕获应用程序中的未处理异常。在应用程序启动期间，我们所需做的所有事情就是用我们自己的`ExceptionHook`函数替换默认的`excepthook`函数。然后，每当应用程序中抛出未处理的异常时，`ExceptionHook`函数就会被调用。在这个函数中，我们只是弹出一个`MessageBox`来显示发生了意外错误，然后告诉`MainLoop`退出。
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The purpose of this example was to show the process of how to handle these errors
    in a graceful manor. So we kept it pretty simple by just using a `MessageBox`.
    It would be easy to extend and customize this example to also log the error, or
    to allow the user to send a notification to the developer of the application so
    that the error can be debugged.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的目的是展示如何优雅地处理这些错误的处理过程。因此，我们通过仅使用一个`MessageBox`使其保持相当简单。很容易扩展和定制这个例子，以便记录错误，或者允许用户向应用程序的开发者发送通知，以便调试错误。
- en: Optimizing for OS X
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化针对 OS X
- en: There are a number of things that can be done in a wxPython application in order
    to help it fit in better when running on a Macintosh OS X system. There are a
    number of things that users expect from an application on OS X, and this recipe
    shows some of the things to do in order to make sure your application runs and
    looks good on OS X as well as on other platforms. This will include the proper
    positioning of standard menus and menu items, main window behavior, and how to
    enable some Macintosh-specific functionality.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython应用程序中，有许多事情可以做到，以帮助它在Macintosh OS X系统上运行时更好地适应。用户对OS X上的应用程序有一些期望，这个菜谱展示了确保您的应用程序在OS
    X以及其他平台上运行良好和外观美观的一些操作。这包括标准菜单和菜单项的正确定位、主窗口的行为，以及如何启用一些Macintosh特定的功能。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As an example of some of the things to take into consideration, we will create
    a simple application that shows how to make an application conform to Macintosh
    UI standards:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为考虑一些事项的例子，我们将创建一个简单的应用程序，展示如何使应用程序符合Macintosh UI标准：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This simple application creates a `Frame` with a `MenuBar` and a `TextCtrl`
    in it, and demonstrates a few things to take note of when preparing an application
    that will be deployed to Macintosh systems.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的应用程序创建了一个包含`MenuBar`和`TextCtrl`的`Frame`，并演示了在准备部署到Macintosh系统上的应用程序时需要注意的一些事项。
- en: Starting in our `OSXApp` object's `OnInit` method, we used the `SystemOptions`
    singleton to enable the native context menu and spellchecking feature of the `TextCtrl`
    objects on OS X. This option is disabled by default; setting it to `1` enables
    it. Also in our `OSXApp` class, we overrode the `MacReopenApp` method, which is
    a callback for an `AppleEvent` that occurs when the application's dock icon is
    clicked on. We overrode it to make sure that this click will cause our application's
    main window to be brought to the front, as expected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的 `OSXApp` 对象的 `OnInit` 方法开始，我们使用了 `SystemOptions` 单例来启用 OS X 上 `TextCtrl`
    对象的本地上下文菜单和拼写检查功能。此选项默认是禁用的；将其设置为 `1` 可以启用它。同样，在我们的 `OSXApp` 类中，我们重写了 `MacReopenApp`
    方法，这是一个当应用程序的 dock 图标被点击时发生的 `AppleEvent` 的回调。我们重写它以确保这个点击将使我们的应用程序主窗口被带到前台，正如预期的那样。
- en: Next, in our `OSXFrame` class, it can be seen that there is some special handling
    needed for the `Menus`. All native OS X applications have some common elements
    in their menus. All applications have a Help menu, a Windows menu, and an Application
    menu. If your application needs to create a custom Help or Windows menu, then
    some additional steps are necessary to make sure that they will work as expected
    on OS X. In our previous example, we created a custom Help menu that included
    a mnemonic accelerator in its title for Windows/GTK to use with keyboard navigation.
    Since the menu title is not the same as the default, we needed to call `SetMacHelpMenuTitleName`
    on the `App` object so that it knows that our Help menu should be used. If we
    omit this step, our application will end up with two help menus shown in the `MenuBar`
    on OS X. The other important thing to note is to use stock IDs whenever possible
    for menu items. The About, Exit, and Preferences entries in particular will always
    be shown under the Application menu on OS X. By using the stock IDs for these
    items, wxPython will ensure that they end up in the proper locations on each platform.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的`OSXFrame`类中，可以看到对于`菜单`部分有一些特殊处理是必要的。所有原生OS X应用程序在其菜单中都有一些共同元素。所有应用程序都有一个帮助菜单、一个窗口菜单和一个应用程序菜单。如果你的应用程序需要创建自定义的帮助或窗口菜单，那么需要采取一些额外的步骤来确保它们在OS
    X上能够按预期工作。在我们之前的示例中，我们创建了一个包含标题中助记符加速器的自定义帮助菜单，以便Windows/GTK在键盘导航中使用。由于菜单标题与默认标题不同，我们需要在`App`对象上调用`SetMacHelpMenuTitleName`，以便它知道我们的帮助菜单应该被使用。如果我们省略这一步，我们的应用程序最终会在OS
    X的`MenuBar`中显示两个帮助菜单。另一个需要注意的重要事项是尽可能使用库存ID来为菜单项设置。特别是关于“关于”、“退出”和“首选项”的条目，在OS
    X的应用程序菜单下总是会被显示。通过使用这些项目的库存ID，wxPython将确保它们在每个平台上都出现在正确的位置。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Included below are some additional Macintosh-specific methods and notes, for
    quick reference.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下包含一些额外的针对Macintosh系统的方法和注意事项，供快速查阅。
- en: wx.App Macintosh specific methods
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: wx.App Macintosh 特定方法
- en: There are some other additional Macintosh-specific helper methods that belong
    to the `App` object that can be used to customize the handling for the three special
    menu items. These methods will be a no-op when the application is running on another
    platform.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些其他额外的针对Macintosh系统的辅助方法属于`App`对象，可以用来自定义处理三个特殊菜单项。当应用程序在其他平台上运行时，这些方法将不会执行任何操作。
- en: '| Methods | Description |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SetMacAboutMenuItemId` | Change the ID used to identify the `About` menu
    item from `ID_ABOUT` to a custom value |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `SetMacAboutMenuItemId` | 将用于识别“关于”菜单项的ID从`ID_ABOUT`更改为自定义值 |'
- en: '| `SetMacExitMenuItemId` | Change the ID used to identify the `Exit` menu item
    from `ID_EXIT` to a custom value |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `SetMacExitMenuItemId` | 将用于识别 `Exit` 菜单项的 ID 从 `ID_EXIT` 更改为自定义值 |'
- en: '| `SetMacPreferencesMenuItemId` | Change the ID used to identify the `Preferences`
    menu item from `ID_PREFERENCES` to a custom value |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `SetMacPreferencesMenuItemId` | 将用于识别 `Preferences` 菜单项的 ID 从 `ID_PREFERENCES`
    更改为自定义值 |'
- en: '| `SetMacSupportPCMenuShortcuts` | Enable the use of menu mnemonics on OS X
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `SetMacSupportPCMenuShortcuts` | 启用在OS X上使用菜单快捷键的功能 |'
- en: wx.MenuBar
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: wx.MenuBar
- en: It is possible to disable the automatic creation of the Windows menu on OS X
    by using the `wx.MenuBar's` static `SetAutoWindowMenu` method. Calling `SetAutoWindowMenu`
    with the value of `False` before creating a `MenuBar` will prevent the Windows
    menu from being created.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `wx.MenuBar` 的静态 `SetAutoWindowMenu` 方法在 OS X 上禁用 Windows 菜单的自动创建。在创建
    `MenuBar` 之前调用 `SetAutoWindowMenu` 并传入 `False` 值将阻止 Windows 菜单的创建。
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Utilizing Stock IDs* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* for a detailed discussion
    about using the built-in stock IDs.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第1章](ch01.html "第1章. 使用wxPython入门")中的*使用股票ID*配方，以了解有关使用内置股票ID的详细讨论。
- en: See the *Handling Apple events* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for an example of how handle AppleEvents in
    a wxPython application.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第2章](ch02.html "第2章。响应事件")中的*处理Apple事件*配方，了解在wxPython应用程序中如何处理AppleEvents的示例。
- en: See the *Distributing an application* recipe in this chapter for a discussion
    of how to distribute an application on OS X.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的 *分发应用程序* 菜单，以了解如何在 OS X 上分发应用程序。
- en: Supporting internationalization
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持国际化
- en: In the interconnected world that we live in today, it is very important to take
    internationalization into account when developing an application's interface.
    There is very little to lose in designing an application that completely supports
    internationalization right from the beginning, but a whole lot to lose if you
    don't. This recipe will show how to set up an application to use wxPython's built-in
    support for interface translations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们今天所生活的这个互联互通的世界中，在开发应用程序界面时考虑国际化非常重要。在设计一个从一开始就完全支持国际化的应用程序时，损失非常小，但如果您不这样做，损失将会很大。这个指南将展示如何设置一个应用程序以使用wxPython内置的界面翻译支持。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Below, we will create a complete sample application that shows how to support
    localization in a wxPython application''s user interface. The first thing to note
    is the alias for `wx.GetTranslation` that we use below to wrap all interface strings
    in the application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，我们将创建一个完整的示例应用程序，展示如何在 wxPython 应用程序的用户界面中支持本地化。首先要注意的是，我们下面使用的 `wx.GetTranslation`
    的别名，用于将应用程序中所有的界面字符串包装起来：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, during the creation of our `App` object, we create and save a reference
    to a `Locale` object. We then tell the `Locale` object where we keep our translation
    files, so that it knows where to look up translations when the `GetTranslation`
    function is called:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在创建我们的 `App` 对象期间，我们创建并保存对一个 `Locale` 对象的引用。然后我们告诉 `Locale` 对象我们存放翻译文件的位置，这样它就知道在调用
    `GetTranslation` 函数时去哪里查找翻译。
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, in the rest, we create a simple user interface that will allow the application
    to switch the language between English and Japanese:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在剩余部分，我们创建一个简单的用户界面，这将允许应用程序在英语和日语之间切换语言：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The little sample application above shows how to make use of the support for
    translations in a wxPython application. Changing the selected language in the
    `Choice` control and restarting the application will change the interface strings
    between English and Japanese. Making use of translations is pretty easy, so let's
    just take a look at the important parts that make it work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的简单示例展示了如何在 wxPython 应用程序中利用翻译支持。在 `Choice` 控件中更改选定的语言并重新启动应用程序，将改变界面字符串在英语和日语之间的转换。利用翻译相当简单，所以让我们看看使其工作的重要部分。
- en: First, we created an alias of `_` for the function `wx.GetTranslation`, so that
    it is shorter to type and easier to read. This function should be wrapped around
    any string in the application that will be shown to the user in the interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为函数 `wx.GetTranslation` 创建了一个别名 `_`，这样在编写时更短，也更易于阅读。这个函数应该被包裹在应用中任何将要显示给用户的界面字符串周围。
- en: 'Next, in our Application''s `OnInit` method, we did a few things to set up
    the proper locale information for loading the configured translations. First,
    we created a `Locale` object. It is necessary to keep a reference to this object
    so that it does not get garbage collected. Hence, we saved it to `self.locale`.
    Next, we set up the `Locale` object to let it know where our translation resource
    files are located, by first calling `AddCatalogLookupPathPrefix` with the directory
    where we keep our translation files. Then we tell it the name of the resource
    files for our application by calling `AddCatalog` with the name of our application
    object. In order for the translations to be loaded, the following directory structure
    is required for each language under the catalog lookup path prefix directory:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的应用程序的 `OnInit` 方法中，我们做了一些事情来设置适当的区域信息，以便加载配置的翻译。首先，我们创建了一个 `Locale`
    对象。保留对这个对象的引用是必要的，以确保它不会被垃圾回收。因此，我们将它保存到 `self.locale`。接下来，我们设置了 `Locale` 对象，让它知道我们的翻译资源文件所在的位置，首先通过调用
    `AddCatalogLookupPathPrefix` 并传入我们保存翻译文件的目录。然后，我们通过调用 `AddCatalog` 并传入我们的应用程序对象名称来告诉它应用程序的资源文件名称。为了加载翻译，需要在目录查找路径前缀目录下的每个语言都需要以下目录结构：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, for example, for our application's Japanese translation, we have the following
    directory layout under our locale directory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，对于我们的应用程序的日语翻译，我们在locale目录下有以下目录结构。
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After the `Locale` object has been created, any calls to `GetTranslation` will
    use the locale to load the appropriate string from the `gettext` catalog file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Locale`对象之后，任何对`GetTranslation`的调用都将使用该区域设置从`gettext`目录文件中加载适当的字符串。
- en: There's more...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: wxPython uses `gettext-formatted` files for loading string resources from. There
    are two files for each translation. The `.po` file (Portable Object) is the file
    that is edited to create the mapping of the default string to the translated version.
    The other file is the `.mo` file (Machine Object) which is the compiled version
    of the `.po` file. To compile a `.po` file to a `.mo` file, you need to use the
    `msgfmt` tool. This is part of `gettext` on any Linux platform. It can also be
    installed on OS X through `fink`, and on Windows through `Cygwin`. The following
    command line statement will generate the `.mo` file from the given input `.po`
    file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 使用 `gettext 格式化` 文件来加载字符串资源。对于每种翻译，都有两个文件。`.po` 文件（可移植对象）是用于创建默认字符串到翻译版本映射的文件，需要编辑此文件。另一个文件是
    `.mo` 文件（机器对象），它是 `.po` 文件的编译版本。要将 `.po` 文件编译成 `.mo` 文件，您需要使用 `msgfmt` 工具。这是任何
    Linux 平台上 `gettext` 的一部分。它也可以通过 `fink` 在 OS X 上安装，通过 `Cygwin` 在 Windows 上安装。以下命令行语句将从给定的输入
    `.po` 文件生成 `.mo` 文件。
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Distributing an application
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发应用程序
- en: Once the application that you have been working on is complete, it is time to
    put together a way to distribute the application to its users. wxPython applications
    can be distributed like any other Python application or script, by creating a
    `setup.py` script and using the `distutils` module's `setup` function. However,
    this recipe will focus on how to create standalone executables for Windows and
    OS X by creating a build script that uses `py2exe` and `py2app` respectively for
    the two target platforms. Creating a standalone application makes it much easier
    for the user to install the application on their system, which means that more
    people are likely to use it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你正在开发的应用程序完成，就需要准备一种方法将应用程序分发给用户。wxPython应用程序可以像其他Python应用程序或脚本一样进行分发，通过创建一个`setup.py`脚本并使用`distutils`模块的`setup`函数。然而，这个菜谱将专注于如何通过创建一个使用`py2exe`和`py2app`分别针对两个目标平台构建的构建脚本，来创建Windows和OS
    X的独立可执行文件。创建一个独立的应用程序使得用户在自己的系统上安装应用程序变得更加容易，这意味着更多的人可能会使用它。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To build standalone binaries, some extension modules are needed in addition
    to wxPython. So if you haven't already done so, you will need to install `py2exe`
    (Windows) or `py2app` (OS X).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建独立的可执行文件，除了wxPython之外，还需要一些扩展模块。因此，如果您还没有这样做，您将需要安装`py2exe`（Windows）或`py2app`（OS
    X）。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Here, we will create a simple `setup.py` template that, with a few simple customizations,
    can be used to build Windows and OS X binaries for most wxPython applications.
    The **Application Information** section here at the top can be modified to specify
    the application's name and other specific information.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个简单的 `setup.py` 模板，通过一些简单的自定义设置，可以用来构建适用于大多数 wxPython 应用程序的 Windows
    和 OS X 二进制文件。顶部这里的 **应用程序信息** 部分可以被修改，以指定应用程序的名称和其他特定信息。
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we will define a method that uses `py2exe` to build a Windows executable
    from the Python script specified in the `APP` variable in the Application Information
    section:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义一种方法，该方法使用 `py2exe` 从应用程序信息部分中指定的 `APP` 变量的 Python 脚本构建 Windows 可执行文件：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Windows binaries have a manifest embedded in them that specifies dependencies
    and other settings. The sample code that accompanies this chapter includes the
    following two XML files that will ensure that the GUI has the proper themed controls
    when running on Windows XP and greater:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Windows的二进制文件中嵌入了一个清单，该清单指定了依赖项和其他设置。本章附带的示例代码包括以下两个XML文件，这些文件将确保在Windows XP及更高版本上运行时GUI具有适当的主题控件：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `OPTS` dictionary specifies the `py2exe` options. These are some standard
    settings that should be good for most applications, but they can be tweaked further
    if necessary for specific use cases:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPTS` 字典指定了 `py2exe` 选项。这些是一些适用于大多数应用的常规设置，但如果需要针对特定用例进行进一步调整，它们可以进行微调：'
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `windows` keyword to the `setup` function is used to specify that we are
    creating a GUI application and is used to specify what the application icon and
    manifest are to embed in the binary:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup` 函数中的 `windows` 关键字用于指定我们正在创建一个图形用户界面应用程序，并用于指定要嵌入二进制的应用程序图标和清单：'
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next we have our OS X build method that uses py2app to build the binary applet
    bundle:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的 OS X 构建方法，它使用 py2app 来构建二进制小程序包：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we define a `PLIST`, which is very similar in purpose to the manifest
    used by Windows binaries. It is used to define some information about the application
    that the OS uses to know what roles the application fills.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`PLIST`，其用途与Windows二进制文件使用的清单非常相似。它用于定义一些关于应用程序的信息，操作系统使用这些信息来了解应用程序扮演的角色。
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following dictionary specifies the `py2app` options that `setup()` will
    use when building the application:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字典指定了`setup()`在构建应用程序时将使用的`py2app`选项：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With the previous set-up script, we can build standalone binaries on both Windows
    and OS X for our `FileEditor` script. So let's take a look at each of the two
    functions, `BuildPy2exe` and `BuildOSXApp`, to see how each of them works.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的设置脚本，我们可以在 Windows 和 OS X 上为我们的 `FileEditor` 脚本构建独立的可执行文件。因此，让我们分别查看这两个函数，`BuildPy2exe`
    和 `BuildOSXApp`，看看它们是如何工作的。
- en: '`BuildPy2exe` performs the necessary preparations in order to run `setup` for
    building a standalone binary on Windows machines by using `py2exe`. There are
    three important parts to take note of in this function. First is the section where
    we create the manifest. Between versions 2.5 and 2.6, the Windows runtime libraries
    that were used to build the Python interpreter binaries changed. Due to this,
    we need to specify different dependencies in our binary''s manifest in order for
    it to be able to load the correct runtimes and give our GUI application the correct
    themed appearance. The two possible manifests for either Python 2.5 or 2.6 are
    included with this topic''s sample source code.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildPy2exe` 执行必要的准备工作，以便在 Windows 机器上使用 `py2exe` 运行 `setup` 来构建独立的二进制文件。在这个函数中，有三个重要的部分需要注意。首先是创建清单的部分。在
    2.5 和 2.6 版本之间，用于构建 Python 解释器二进制的 Windows 运行时库发生了变化。因此，我们需要在我们的二进制清单中指定不同的依赖项，以便它能够加载正确的运行时，并给我们的
    GUI 应用程序提供正确的主题外观。本主题的示例源代码中包含了 Python 2.5 或 2.6 的两种可能的清单。'
- en: 'Second is the `py2exe` options dictionary. This dictionary contains the `py2exe`
    specific options to use when bundling the script. We used five options: `compressed,
    optimize, bundle_files, excludes`, and `dll_excludes`. The `compressed` option
    states that we want to compress the resulting `.exe` file. The `optimize` says
    to optimize the Python byte code. We can specify `0, 1`, or `2` here, for different
    levels of optimizations. The `bundle_files` option specifies the level at which
    to bundle dependencies into the `library.zip` file. The lower the number (`1-3`),
    the greater the number of files that will be bundled into the ZIP file, reducing
    the overall number of individual files that need to be distributed. Using `1`
    can often cause problems with wxPython applications, so using `2` or `3` is suggested.
    Next, the `excludes` option is a list of modules to exclude from the resulting
    bundle. We specified `Tkinter` here just to ensure that none of its dependencies
    accidentally get drawn in making our binary larger. Finally, the `dll_excludes`
    option was used to work around an issue when using `py2exe` with Python 2.6.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`py2exe`选项字典。这个字典包含了在捆绑脚本时使用的`py2exe`特定选项。我们使用了五个选项：`compressed`、`optimize`、`bundle_files`、`excludes`和`dll_excludes`。`compressed`选项表示我们希望压缩生成的`.exe`文件。`optimize`选项表示要优化Python字节码。在这里我们可以指定`0`、`1`或`2`，以实现不同级别的优化。`bundle_files`选项指定将依赖项捆绑到`library.zip`文件的级别。数字越低（`1-3`），捆绑到ZIP文件中的文件数量就越多，从而减少了需要分发的单个文件的总数。使用`1`可能会经常导致wxPython应用程序出现问题，因此建议使用`2`或`3`。接下来，`excludes`选项是一个要排除在结果捆绑中的模块列表。在这里我们指定了`Tkinter`，只是为了确保其依赖项不会意外地被包含在我们的二进制文件中，从而使文件变大。最后，`dll_excludes`选项用于解决在使用`py2exe`与Python
    2.6时遇到的问题。
- en: Third and finally is the `windows` parameter in the `setup` command. This is
    used to specify that we are building a GUI application, and is where we specify
    the application's icon to embed into the `.exe` as well as the manifest that we
    spoke of earlier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第三点也是最后一点是`setup`命令中的`windows`参数。这个参数用于指定我们正在构建一个GUI应用程序，并且在这里我们指定要嵌入到`.exe`文件中的应用程序图标以及之前提到的清单文件。
- en: 'Running `setup` with `py2exe` is as simple as the following command line statement:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `py2exe` 运行 `setup` 与以下命令行语句一样简单：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let''s look at how `py2app` works. It is very similar to `py2exe` and actually
    even a little easier to use since there is no need to worry about runtime dependencies
    like there is on Windows. The main difference is the `PLIST`, which is somewhat
    similar to a manifest on Windows, but is used to define some application behavior
    and to store information about the application for use by the operating system.
    `Py2app` will use the specified dictionary to generate the `Plist` XML file in
    the resulting application. To learn about the available `Plist` options, see the
    properly listed documentation available at [http://developer.apple.com](http://developer.apple.com).
    The `PLIST` dictionary is passed to `py2app` through the setup function''s `options`
    parameter, along with the other `py2app` options that we specified, such as the
    application''s icon. Also, very similar to `py2exe`, running `py2app` just requires
    the following command line statement:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `py2app` 的工作原理。它与 `py2exe` 非常相似，实际上甚至更易于使用，因为无需担心像在 Windows 上那样的运行时依赖问题。主要区别在于
    `PLIST`，它在某种程度上类似于 Windows 上的清单文件，但用于定义一些应用程序行为并存储操作系统使用应用程序信息。`Py2app` 将使用指定的字典在生成的应用程序中生成
    `Plist` XML 文件。有关可用的 `Plist` 选项，请参阅在 [http://developer.apple.com](http://developer.apple.com)
    提供的适当列出的文档。`PLIST` 字典通过设置函数的 `options` 参数传递给 `py2app`，以及其他我们指定的 `py2app` 选项，例如应用程序的图标。此外，与
    `py2exe` 非常相似，运行 `py2app` 只需要以下命令行语句：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Included below is some additional information about some specific distribution
    dependency issues for Windows applications, as well as some references for creating
    installers for applications on Windows and OS X.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下包含有关Windows应用程序的一些特定分布依赖性问题的附加信息，以及为Windows和OS X上的应用程序创建安装程序的参考资料。
- en: Py2Exe dependencies
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Py2Exe 依赖项
- en: After running the `py2exe` setup command, make sure that you review the list
    of dependencies that were not included, and that are listed at the end of the
    output. There are a couple of additional files that you may need to manually include
    in your application's `dist` folder for it to run properly when deployed on a
    different computer. For Python 2.5, the `msvcr71.dll` and `gdiplus.dll` files
    are typically needed. For Python 2.6, the `msvcr90.dll` and `gdiplus.dll` files
    are needed. The `msvcr .dll` files are copyrighted by Microsoft, so you should
    review the licensing terms to make sure you have the rights to redistribute them.
    If not, users may be required to install them separately using the freely-availably
    redistributable runtime package that can be downloaded from Microsoft's website.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `py2exe` 设置命令后，请确保您审查了末尾列出的未包含的依赖项列表。可能需要手动将一些额外的文件包含到您的应用程序的 `dist` 文件夹中，以便在不同计算机上部署时能够正常运行。对于
    Python 2.5，通常需要 `msvcr71.dll` 和 `gdiplus.dll` 文件。对于 Python 2.6，则需要 `msvcr90.dll`
    和 `gdiplus.dll` 文件。`msvcr .dll` 文件由微软版权所有，因此您应该审查许可条款，以确保您有权重新分发它们。如果没有，用户可能需要单独使用可以从微软网站下载的免费可重新分发的运行时包来安装它们。
- en: Installers
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装程序
- en: 'After building your application with either `py2exe` or `py2app`, you will
    need a way to help the application''s users to properly install the files onto
    their systems. For Windows, there are a number of options available for building
    installers: NSIS ([http://nsis.sourceforge.net](http://nsis.sourceforge.net))
    and Inno Setup ([http://www.jrsoftware.org/isinfo.php](http://www.jrsoftware.org/isinfo.php))
    are two popular free options. On OS X, the necessary tools are already installed.
    Simply use the Disk Utility application to make a disk image (`.dmg`) file and
    then copy the built applet into it.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `py2exe` 或 `py2app` 构建你的应用程序后，你需要一种方法来帮助应用程序的用户将文件正确安装在他们的系统上。对于 Windows，有多个选项可用于构建安装程序：NSIS
    ([http://nsis.sourceforge.net](http://nsis.sourceforge.net)) 和 Inno Setup ([http://www.jrsoftware.org/isinfo.php](http://www.jrsoftware.org/isinfo.php))
    是两种流行的免费选项。在 OS X 上，必要的工具已经安装好了。只需使用磁盘工具应用程序创建一个磁盘镜像（`.dmg`）文件，然后将构建的应用程序复制到其中。
