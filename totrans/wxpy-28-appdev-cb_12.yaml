- en: Chapter 12. Building and Managing Applications for Distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with `StandardPaths`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting the state of the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `SingleInstanceChecker`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing for OS X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting internationalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application's infrastructure provides the backbone for the application's
    inner workings, which are often things that are not directly apparent to the user
    but are critical to the application's functionality. This includes things such
    as storing configuration and external data files, error handling, and installation.
    Each of these areas provides important functionality and contributes to the usability
    and the end-user's overall perception of the application. In this chapter, we
    will take an in-depth tour of a number of these topics and more, in order to provide
    you with the appropriate tools to help build and distribute your application.
  prefs: []
  type: TYPE_NORMAL
- en: Working with StandardPaths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly every non-trivial application is going to have the need to store data
    to use between usage of the program and to load resources such as images. The
    question is where to put this stuff? The appropriate locations where the operating
    system and users expect to find these files will vary from platform to platform.
    This recipe shows how to use `wx.StandardPaths` to manage an application's configuration
    and resource files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will create a thin wrapper utility class to help manage an application's
    configuration files and data. The constructor will ensure that any predefined
    directories have been set up in the configuration storage location on the system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we add a helper function to create a directory in the current user''s
    data directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function can be used to get the absolute path to a file or directory
    in the user''s data directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last method in this class can be used to check if a given configuration
    file has been created yet or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ConfigHelper` class just provides a thin simple wrapper around some of
    the `StandardPaths` methods, in order to make it a little easier to use. When
    the object is created, it will make sure that the user data directory and any
    of its application-specific subdirectories have been created. The `StandardPaths`
    singleton uses the application's name to determine the name of the user's data
    directory. Because of this, it is important to wait until the `App` object has
    been created and had its name set with `SetAppName`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateUserCfgDir` provides a convenient way to create a new directory inside
    the user's main configuration directory. `GetUserConfigPath` can be used to get
    the full path to a file or directory in the configuration directory or subdirectory,
    by using a path relative to the main directory. Finally, `HasConfigFile` is a
    simple way to check if a file exists in the user's configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `StandardPaths` singleton provides a number of other methods to get other
    system and installation-specific installation paths. The following table describes
    some of these additional methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GetConfigDir()` | Returns the system-level configuration directory |'
  prefs: []
  type: TYPE_TB
- en: '| `GetDataDir()` | Returns the application''s global (non user specific) data
    directory |'
  prefs: []
  type: TYPE_TB
- en: '| `GetDocumentsDir()` | Returns the current user''s documents directory |'
  prefs: []
  type: TYPE_TB
- en: '| `GetExecutablePath()` | Returns the path to the currently-running executable
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GetPluginsDir()` | Returns the path to where the application''s plug-ins
    should reside |'
  prefs: []
  type: TYPE_TB
- en: '| `GetTempDir()` | Returns the path to the system''s `TEMP` directory |'
  prefs: []
  type: TYPE_TB
- en: '| `GetUserConigDir()` | Returns the path to the current user''s configuration
    directory |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Creating Singletons* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for a discussion
    about what singletons, such as the `StandardPaths` object, are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Persisting the state of the UI* recipe in this chapter for more information
    on storing confirmation information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting the state of the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common feature that many applications have is to be able to remember and restore
    their window size and position between launches of the program. This is not a
    built-in feature provided by the toolkit, so this recipe will create a simple
    `Frame` base class that will automatically save and restore its size and position
    on the desktop between uses of the application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example shows one approach to creating a `Frame` class that will automatically
    restore its position and size between runs of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we handle `EVT_CLOSE` for when the `Frame` is closing, in order to save
    its position and size to the `Config` object, which is the registry on Windows
    and a `.ini` file on other platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RestoreState` method restores the currently-stored window state or the
    default state if nothing has been stored yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PersistentFrame` should be used as a base class for any `Frame` in an application
    that should persist its size and position on exit. The way in which this class
    works is rather simple, so let's take a quick look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: First, in order to save its size and position, the `PersisistentFrame` binds
    an event handler to `EVT_CLOSE`. Its `_OnClose` method will then be called when
    the user closes the `Frame`. In this event handler, we simply get the current
    size and position of the `Frame` and save it to a `wx.Config` object, which will
    be the registry on Windows and a `.ini` file on other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, when the `PersistentFrame` is created, it tries to read the previously-saved
    size and position from the configuration. This happens in the `RestoreState` method,
    which is initiated with `CallAfter`. This was done to make sure that we don't
    restore the settings until after the `Frame` has been created, so that if a subclass
    sets up some default sizes they won't override the last state that the user left
    it in. In `RestoreState`, if there is stored information for the `Frame`, it will
    load the strings and convert them back to tuples using the `eval` function, and
    then will simply apply the settings.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For simplicity, we just used `wx.Config` for storing the settings between running
    the application. We could have also used `StandardPaths` and written out our own
    configuration file to the user's configuration directory, like we did in the previous
    recipe in order to ensure that this information was kept where the user expects
    it to be.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Working with StandardPaths* recipe in this chapter for information
    about another class that can help with storing and locating configuration information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SingleInstanceChecker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is desirable to only allow a single instance of an application
    to exist at any given time. The `SingleInstanceChecker` class provides a way to
    detect if any instances of the application are already running. This recipe creates
    an `App` class that uses the `SingleInstanceChecker` to maintain only a single
    running instance of the application on the computer at one time, and also uses
    a simple IPC mechanism to allow any subsequent instances of the application to
    send a message to the original instance to tell it to open a new window.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will create an `App` base class that ensures that only one instance
    of the process is running at a time, and supports a simple, socket-based inter-process
    communication mechanism to inform an already-running instance that a new one tried
    to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SingleInstanceChecker` needs to be explicitly deleted when the application
    exits to ensure that the file lock that it creates is released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IpcServer` class implements the inter-process communication by opening
    a connection to a socket on the local loopback of the machine. This has been implemented
    as a background thread that loops, waiting for messages, until it is told to exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run` method runs the server thread''s main loop of checking the socket
    for messages and using `CallAfter` to notify the `App` to call its `DoOpenNewWindow`
    method when the server has received an`''OpenWindow''` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SendMessage` function is used to open a client connection to the `IpcServer''s`
    socket and send it the given message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Included with the code that accompanies this chapter is a complete running application
    showing how to use the above framework. To test it out, try starting multiple
    instances of the application on the same computer, and see that only the original
    process is running and that each subsequent launch results in a new window being
    opened in the original process.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We packed a lot of stuff into a small amount of code in this recipe, so let's
    go through how each class works.
  prefs: []
  type: TYPE_NORMAL
- en: The `SingleInstApp` class creates a `SingleInstanceChecker` object to make it
    possible to detect if there is already another instance of the application running.
    As a part of the ID for the `SingleInstanceChecker`, we used the user's login
    ID to make sure that the instance checker is only checking for other instances
    that the same user has started.
  prefs: []
  type: TYPE_NORMAL
- en: In our `SingleInstanceApp` object's `__init__` method, it is important to realize
    the order of operations that will take place when a derived class is initialized.
    Calling the base `wx.App` class `__init__` will result in the derived class's
    virtual `OnInit` being called, and then after that the rest of the code in the
    `SingleInstApp's __init__` will run. If it detects that this is the first instance
    of the application running, it will create and start our `IpcServer`. If not,
    it will simply create and send a simple string command to the other, already-running,
    `IpcServer` object to tell it to inform the other application instance to create
    a new window.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to look at the `IpcServer` class, one very important thing
    to keep in mind when using the `SingleInstanceChecker` is that you need to explicitly
    delete it when you are done with it. If it is not deleted, the file lock that
    it uses for determining if another instance is active or not may never get released,
    which can cause problems on future launches of the program.
  prefs: []
  type: TYPE_NORMAL
- en: The `IpcServer` class is a simple class derived from `Thread` that uses a TCP
    socket for inter-process communication. As mentioned, the first `SingleInstanceApp`
    that is started will create an instance of this server. The server will run in
    its own thread, checking for messages at the socket. The `IpcServer` thread's
    `run` method just runs a loop, checking the socket for new data. If it is able
    to read a message, it checks that the last part of the message matches the key
    that was used to create the `App's SingleInstanceChecker`, to make sure that the
    command is coming from another instance of the application. We have only designed
    support for a single`'OpenWindow'` command in our simple IPC protocol right now,
    but it could be easily expanded to support more. Upon receiving an `OpenWindow`
    message, the `IpcServer` will use `CallAfter` to call the `SingleInstanceApp's`
    interface method `DoOpenNewWindow` to inform the application to open a new instance
    of its main window.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this little framework is the `SendMessage` function, which
    is used as a client method to connect and send a message to the `IpcServer`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* for
    an explanation about overriding virtual methods in wxPython classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Understanding thread safety* recipe in [Chapter 11](ch11.html "Chapter 11. Using
    Threads and Timers to Create Responsive Interfaces"), *Responsive Interfaces*
    for more information about working with threads in a wxPython GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In even seemingly-simple applications, it can be difficult to account for all
    possible error conditions that could occur in the application. This recipe shows
    how to handle unhandled exceptions, and how to display a notification to the user
    to let them know that an unexpected error has happened, before the application
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will show how to create a simple exception hook to handle
    and inform the user of any unexpected errors that occur while the program is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe showed a very simple way to create an exception hook to catch unhandled
    exceptions in the application. During the start-up of the application, all that
    we needed to do was replace the default `excepthook` function with our own `ExceptionHook`
    function. The `ExceptionHook` function will then be called any time that an unhandled
    exception is raised in the application. In this function, all we do is pop up
    a `MessageBox` to show that an unexpected error has occurred, and then tell the
    `MainLoop` to exit.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this example was to show the process of how to handle these errors
    in a graceful manor. So we kept it pretty simple by just using a `MessageBox`.
    It would be easy to extend and customize this example to also log the error, or
    to allow the user to send a notification to the developer of the application so
    that the error can be debugged.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for OS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of things that can be done in a wxPython application in order
    to help it fit in better when running on a Macintosh OS X system. There are a
    number of things that users expect from an application on OS X, and this recipe
    shows some of the things to do in order to make sure your application runs and
    looks good on OS X as well as on other platforms. This will include the proper
    positioning of standard menus and menu items, main window behavior, and how to
    enable some Macintosh-specific functionality.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of some of the things to take into consideration, we will create
    a simple application that shows how to make an application conform to Macintosh
    UI standards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This simple application creates a `Frame` with a `MenuBar` and a `TextCtrl`
    in it, and demonstrates a few things to take note of when preparing an application
    that will be deployed to Macintosh systems.
  prefs: []
  type: TYPE_NORMAL
- en: Starting in our `OSXApp` object's `OnInit` method, we used the `SystemOptions`
    singleton to enable the native context menu and spellchecking feature of the `TextCtrl`
    objects on OS X. This option is disabled by default; setting it to `1` enables
    it. Also in our `OSXApp` class, we overrode the `MacReopenApp` method, which is
    a callback for an `AppleEvent` that occurs when the application's dock icon is
    clicked on. We overrode it to make sure that this click will cause our application's
    main window to be brought to the front, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in our `OSXFrame` class, it can be seen that there is some special handling
    needed for the `Menus`. All native OS X applications have some common elements
    in their menus. All applications have a Help menu, a Windows menu, and an Application
    menu. If your application needs to create a custom Help or Windows menu, then
    some additional steps are necessary to make sure that they will work as expected
    on OS X. In our previous example, we created a custom Help menu that included
    a mnemonic accelerator in its title for Windows/GTK to use with keyboard navigation.
    Since the menu title is not the same as the default, we needed to call `SetMacHelpMenuTitleName`
    on the `App` object so that it knows that our Help menu should be used. If we
    omit this step, our application will end up with two help menus shown in the `MenuBar`
    on OS X. The other important thing to note is to use stock IDs whenever possible
    for menu items. The About, Exit, and Preferences entries in particular will always
    be shown under the Application menu on OS X. By using the stock IDs for these
    items, wxPython will ensure that they end up in the proper locations on each platform.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Included below are some additional Macintosh-specific methods and notes, for
    quick reference.
  prefs: []
  type: TYPE_NORMAL
- en: wx.App Macintosh specific methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some other additional Macintosh-specific helper methods that belong
    to the `App` object that can be used to customize the handling for the three special
    menu items. These methods will be a no-op when the application is running on another
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: '| Methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SetMacAboutMenuItemId` | Change the ID used to identify the `About` menu
    item from `ID_ABOUT` to a custom value |'
  prefs: []
  type: TYPE_TB
- en: '| `SetMacExitMenuItemId` | Change the ID used to identify the `Exit` menu item
    from `ID_EXIT` to a custom value |'
  prefs: []
  type: TYPE_TB
- en: '| `SetMacPreferencesMenuItemId` | Change the ID used to identify the `Preferences`
    menu item from `ID_PREFERENCES` to a custom value |'
  prefs: []
  type: TYPE_TB
- en: '| `SetMacSupportPCMenuShortcuts` | Enable the use of menu mnemonics on OS X
    |'
  prefs: []
  type: TYPE_TB
- en: wx.MenuBar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to disable the automatic creation of the Windows menu on OS X
    by using the `wx.MenuBar's` static `SetAutoWindowMenu` method. Calling `SetAutoWindowMenu`
    with the value of `False` before creating a `MenuBar` will prevent the Windows
    menu from being created.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Utilizing Stock IDs* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* for a detailed discussion
    about using the built-in stock IDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Handling Apple events* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for an example of how handle AppleEvents in
    a wxPython application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Distributing an application* recipe in this chapter for a discussion
    of how to distribute an application on OS X.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the interconnected world that we live in today, it is very important to take
    internationalization into account when developing an application's interface.
    There is very little to lose in designing an application that completely supports
    internationalization right from the beginning, but a whole lot to lose if you
    don't. This recipe will show how to set up an application to use wxPython's built-in
    support for interface translations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Below, we will create a complete sample application that shows how to support
    localization in a wxPython application''s user interface. The first thing to note
    is the alias for `wx.GetTranslation` that we use below to wrap all interface strings
    in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, during the creation of our `App` object, we create and save a reference
    to a `Locale` object. We then tell the `Locale` object where we keep our translation
    files, so that it knows where to look up translations when the `GetTranslation`
    function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the rest, we create a simple user interface that will allow the application
    to switch the language between English and Japanese:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The little sample application above shows how to make use of the support for
    translations in a wxPython application. Changing the selected language in the
    `Choice` control and restarting the application will change the interface strings
    between English and Japanese. Making use of translations is pretty easy, so let's
    just take a look at the important parts that make it work.
  prefs: []
  type: TYPE_NORMAL
- en: First, we created an alias of `_` for the function `wx.GetTranslation`, so that
    it is shorter to type and easier to read. This function should be wrapped around
    any string in the application that will be shown to the user in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in our Application''s `OnInit` method, we did a few things to set up
    the proper locale information for loading the configured translations. First,
    we created a `Locale` object. It is necessary to keep a reference to this object
    so that it does not get garbage collected. Hence, we saved it to `self.locale`.
    Next, we set up the `Locale` object to let it know where our translation resource
    files are located, by first calling `AddCatalogLookupPathPrefix` with the directory
    where we keep our translation files. Then we tell it the name of the resource
    files for our application by calling `AddCatalog` with the name of our application
    object. In order for the translations to be loaded, the following directory structure
    is required for each language under the catalog lookup path prefix directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, for example, for our application's Japanese translation, we have the following
    directory layout under our locale directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After the `Locale` object has been created, any calls to `GetTranslation` will
    use the locale to load the appropriate string from the `gettext` catalog file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: wxPython uses `gettext-formatted` files for loading string resources from. There
    are two files for each translation. The `.po` file (Portable Object) is the file
    that is edited to create the mapping of the default string to the translated version.
    The other file is the `.mo` file (Machine Object) which is the compiled version
    of the `.po` file. To compile a `.po` file to a `.mo` file, you need to use the
    `msgfmt` tool. This is part of `gettext` on any Linux platform. It can also be
    installed on OS X through `fink`, and on Windows through `Cygwin`. The following
    command line statement will generate the `.mo` file from the given input `.po`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Distributing an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the application that you have been working on is complete, it is time to
    put together a way to distribute the application to its users. wxPython applications
    can be distributed like any other Python application or script, by creating a
    `setup.py` script and using the `distutils` module's `setup` function. However,
    this recipe will focus on how to create standalone executables for Windows and
    OS X by creating a build script that uses `py2exe` and `py2app` respectively for
    the two target platforms. Creating a standalone application makes it much easier
    for the user to install the application on their system, which means that more
    people are likely to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build standalone binaries, some extension modules are needed in addition
    to wxPython. So if you haven't already done so, you will need to install `py2exe`
    (Windows) or `py2app` (OS X).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will create a simple `setup.py` template that, with a few simple customizations,
    can be used to build Windows and OS X binaries for most wxPython applications.
    The **Application Information** section here at the top can be modified to specify
    the application's name and other specific information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will define a method that uses `py2exe` to build a Windows executable
    from the Python script specified in the `APP` variable in the Application Information
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows binaries have a manifest embedded in them that specifies dependencies
    and other settings. The sample code that accompanies this chapter includes the
    following two XML files that will ensure that the GUI has the proper themed controls
    when running on Windows XP and greater:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OPTS` dictionary specifies the `py2exe` options. These are some standard
    settings that should be good for most applications, but they can be tweaked further
    if necessary for specific use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `windows` keyword to the `setup` function is used to specify that we are
    creating a GUI application and is used to specify what the application icon and
    manifest are to embed in the binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have our OS X build method that uses py2app to build the binary applet
    bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a `PLIST`, which is very similar in purpose to the manifest
    used by Windows binaries. It is used to define some information about the application
    that the OS uses to know what roles the application fills.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following dictionary specifies the `py2app` options that `setup()` will
    use when building the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the previous set-up script, we can build standalone binaries on both Windows
    and OS X for our `FileEditor` script. So let's take a look at each of the two
    functions, `BuildPy2exe` and `BuildOSXApp`, to see how each of them works.
  prefs: []
  type: TYPE_NORMAL
- en: '`BuildPy2exe` performs the necessary preparations in order to run `setup` for
    building a standalone binary on Windows machines by using `py2exe`. There are
    three important parts to take note of in this function. First is the section where
    we create the manifest. Between versions 2.5 and 2.6, the Windows runtime libraries
    that were used to build the Python interpreter binaries changed. Due to this,
    we need to specify different dependencies in our binary''s manifest in order for
    it to be able to load the correct runtimes and give our GUI application the correct
    themed appearance. The two possible manifests for either Python 2.5 or 2.6 are
    included with this topic''s sample source code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second is the `py2exe` options dictionary. This dictionary contains the `py2exe`
    specific options to use when bundling the script. We used five options: `compressed,
    optimize, bundle_files, excludes`, and `dll_excludes`. The `compressed` option
    states that we want to compress the resulting `.exe` file. The `optimize` says
    to optimize the Python byte code. We can specify `0, 1`, or `2` here, for different
    levels of optimizations. The `bundle_files` option specifies the level at which
    to bundle dependencies into the `library.zip` file. The lower the number (`1-3`),
    the greater the number of files that will be bundled into the ZIP file, reducing
    the overall number of individual files that need to be distributed. Using `1`
    can often cause problems with wxPython applications, so using `2` or `3` is suggested.
    Next, the `excludes` option is a list of modules to exclude from the resulting
    bundle. We specified `Tkinter` here just to ensure that none of its dependencies
    accidentally get drawn in making our binary larger. Finally, the `dll_excludes`
    option was used to work around an issue when using `py2exe` with Python 2.6.'
  prefs: []
  type: TYPE_NORMAL
- en: Third and finally is the `windows` parameter in the `setup` command. This is
    used to specify that we are building a GUI application, and is where we specify
    the application's icon to embed into the `.exe` as well as the manifest that we
    spoke of earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `setup` with `py2exe` is as simple as the following command line statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at how `py2app` works. It is very similar to `py2exe` and actually
    even a little easier to use since there is no need to worry about runtime dependencies
    like there is on Windows. The main difference is the `PLIST`, which is somewhat
    similar to a manifest on Windows, but is used to define some application behavior
    and to store information about the application for use by the operating system.
    `Py2app` will use the specified dictionary to generate the `Plist` XML file in
    the resulting application. To learn about the available `Plist` options, see the
    properly listed documentation available at [http://developer.apple.com](http://developer.apple.com).
    The `PLIST` dictionary is passed to `py2app` through the setup function''s `options`
    parameter, along with the other `py2app` options that we specified, such as the
    application''s icon. Also, very similar to `py2exe`, running `py2app` just requires
    the following command line statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Included below is some additional information about some specific distribution
    dependency issues for Windows applications, as well as some references for creating
    installers for applications on Windows and OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Py2Exe dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After running the `py2exe` setup command, make sure that you review the list
    of dependencies that were not included, and that are listed at the end of the
    output. There are a couple of additional files that you may need to manually include
    in your application's `dist` folder for it to run properly when deployed on a
    different computer. For Python 2.5, the `msvcr71.dll` and `gdiplus.dll` files
    are typically needed. For Python 2.6, the `msvcr90.dll` and `gdiplus.dll` files
    are needed. The `msvcr .dll` files are copyrighted by Microsoft, so you should
    review the licensing terms to make sure you have the rights to redistribute them.
    If not, users may be required to install them separately using the freely-availably
    redistributable runtime package that can be downloaded from Microsoft's website.
  prefs: []
  type: TYPE_NORMAL
- en: Installers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After building your application with either `py2exe` or `py2app`, you will
    need a way to help the application''s users to properly install the files onto
    their systems. For Windows, there are a number of options available for building
    installers: NSIS ([http://nsis.sourceforge.net](http://nsis.sourceforge.net))
    and Inno Setup ([http://www.jrsoftware.org/isinfo.php](http://www.jrsoftware.org/isinfo.php))
    are two popular free options. On OS X, the necessary tools are already installed.
    Simply use the Disk Utility application to make a disk image (`.dmg`) file and
    then copy the built applet into it.'
  prefs: []
  type: TYPE_NORMAL
