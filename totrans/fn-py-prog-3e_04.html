<html><head></head><body>
<section id="chapter-4-working-with-collections" class="level2 chapterHead" data-number="0.8">&#13;
<h2 class="chapterHead" data-number="0.8"><span class="titlemark"> 4</span><br/>&#13;
<span id="x1-740004"/>Working with Collections</h2>&#13;
<p>Python offers a number of functions that process whole collections. They can be applied to sequences (lists or tuples), sets, mappings, and iterable results of generator expressions. We’ll look at Python’s collection-processing features from a functional programming viewpoint.</p>&#13;
<p>We’ll start out by looking at iterables and some simple functions that work with iterables. We’ll look at some design patterns to handle iterables and sequences with recursive functions as well as explicit <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statements. We’ll look at how we can apply a scalar function to a collection of data with a generator expression.</p>&#13;
<p>In this chapter, we’ll show you examples of how to use the following functions with collections:</p>&#13;
<ul>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">any()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span></p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span>, and some higher-order statistical processing related to these functions</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> and some related techniques to structure and flatten lists of data</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">reversed()</code></span></span> to impose an ordering on a collection</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span></p></li>&#13;
</ul>&#13;
<p>The first four functions can be called<span id="dx1-74001"/> <span class="keyWord">reductions</span>: they reduce a collection to a single value. The other three functions, <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">reversed()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span>, are <span class="keyWord">mappings</span>; they produce new collections<span id="dx1-74002"/> from existing collections. In the next chapter, we’ll look at some more mapping and reduction functions that use an additional function as an argument to customize their processing.</p>&#13;
<p>In this chapter, we’ll start by looking at ways to process data using generator expressions. Then, we’ll apply different kinds of collection-level functions to show how they can simplify the syntax of iterative processing. We’ll also look at some different ways of restructuring data.</p>&#13;
<p>In the next chapter, we’ll focus on using higher-order collection functions to do similar kinds of processing. <span id="x1-74003r69"/></p>&#13;
<section id="an-overview-of-function-varieties" class="level3 sectionHead" data-number="0.8.1">&#13;
<h3 class="sectionHead" data-number="0.8.1"><span class="titlemark">4.1 </span> <span id="x1-750001"/>An overview of function varieties</h3>&#13;
<p>We need to distinguish between two broad species of functions, as follows:</p>&#13;
<ul>&#13;
<li><p><span class="keyWord">Scalar functions</span>: These apply to individual<span id="dx1-75001"/> values and compute<span id="dx1-75002"/> an individual result. Functions such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">abs()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">pow()</code></span></span>, and the entire <span class="obeylines-h"><span class="verb"><code class="inlineCode">math</code></span></span> module are examples of scalar functions.</p></li>&#13;
<li><p><span class="keyWord">Collection functions</span>: These work with iterable<span id="dx1-75003"/> collections.</p></li>&#13;
</ul>&#13;
<p>We can further subdivide these collection<span id="dx1-75004"/> functions into three subspecies:</p>&#13;
<ul>&#13;
<li><p><span class="keyWord">Reduction</span>: This uses a function<span id="dx1-75005"/> to fold values in the collection together, resulting in a single final value. For example, if we fold + operations into a sequence of integers, this will compute the sum. This can be also be called<span id="dx1-75006"/> an <span class="keyWord">aggregate function</span>, as it produces a single aggregate value for an input collection. Functions like <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> are examples of reducing a collection to a single value.</p></li>&#13;
<li><p><span class="keyWord">Mapping</span>: This applies a scalar<span id="dx1-75007"/> function to each individual item of a collection; the result is a collection of the same size. The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function does this; a function like <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> can be seen as a mapping from items to pairs of values.</p></li>&#13;
<li><p><span class="keyWord">Filter</span>: This applies<span id="dx1-75008"/> a scalar function to all items of a collection to reject some items and pass others. The result is a subset of the input. The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function does this.</p></li>&#13;
</ul>&#13;
<p>Some functions, for example, <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">reversed()</code></span></span>, don’t fit this framework in a simple, tidy way. Because these two ”reordering” functions don’t compute new values from existing values, it seems sensible to set them off to one side.</p>&#13;
<p>We’ll use this conceptual framework to characterize ways in which we use the built-in collection functions. <span id="x1-75009r81"/></p>&#13;
</section>&#13;
<section id="working-with-iterables" class="level3 sectionHead" data-number="0.8.2">&#13;
<h3 class="sectionHead" data-number="0.8.2"><span class="titlemark">4.2 </span> <span id="x1-760002"/>Working with iterables</h3>&#13;
<p>As noted in the previous<span id="dx1-76001"/> chapters, Python’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement works with iterables, including Python’s rich variety of collections. When working with materialized collections such as tuples, lists, maps, and sets, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement involves the explicit management of state.</p>&#13;
<p>While this strays from purely functional programming, it reflects a necessary optimization for Python. The state management is localized to an iterator object that’s created as a part of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement evaluation; we can leverage this feature without straying too far from pure, functional programming. If, for example, we use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement’s variable outside the indented body of the statement, we’ve strayed from purely functional programming by leveraging this state control variable.</p>&#13;
<p>We’ll return to this in <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and Reductions</span></a>. It’s an important topic, and we’ll just scratch the surface in this section with a quick example of working with generators.</p>&#13;
<p>One common application of iterable processing with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">unwrap(process(wrap(iterable)))</code></span></span> design pattern. A <span class="obeylines-h"><span class="verb"><code class="inlineCode">wrap()</code></span></span> function will first transform each item of an iterable into a two-tuple with a derived sort key and the original item. We can then process these two-tuple items as a single, wrapped value. Finally, we’ll use an <span class="obeylines-h"><span class="verb"><code class="inlineCode">unwrap()</code></span></span> function to discard the value used to wrap, which recovers the original item.</p>&#13;
<p>This happens so often in a functional context that two functions are used heavily for this; they are the following:</p>&#13;
<pre id="listing-55" class="lstlisting"><code>from collections.abc import Callable, Sequence &#13;
from typing import Any, TypeAlias &#13;
 &#13;
Extractor: TypeAlias = Callable[[Sequence[Any]], Any] &#13;
 &#13;
fst: Extractor = lambda x: x[0] &#13;
snd: Extractor = lambda x: x[1]</code></pre>&#13;
<p>These two functions<span id="dx1-76009"/> pick the first and second values from a two-tuple, and both are handy for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">process()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">unwrap()</code></span></span> phases of the processing.</p>&#13;
<p>Another common pattern is <span class="obeylines-h"><span class="verb"><code class="inlineCode">wrap3(wrap2(wrap1()))</code></span></span>. In this case, we’re starting with simple tuples and then wrapping them with additional results to build up larger and more complex tuples. We looked at an example in <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 2</span></a>, <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Introducing Essential Functional Concepts</span></a>, in the <a href="Chapter_02.xhtml#x1-380002"><span class="cmti-10x-x-109">Immutable data</span></a> section. A common variation on this theme builds new, more complex named tuple instances from source objects. We might call this the <span class="keyWord">Accretion</span><span id="dx1-76010"/> design pattern—an item that accretes derived values.</p>&#13;
<p>As an example, consider using the <span class="keyWord">Accretion </span>pattern to work with a simple sequence of latitude and longitude values. The first step will convert the simple point represented as a <span class="obeylines-h"><span class="verb"><code class="inlineCode">(lat,</code><code class="inlineCode"> lon)</code></span></span> pair on a path into pairs of legs <span class="obeylines-h"><span class="verb"><code class="inlineCode">(begin,</code><code class="inlineCode"> end)</code></span></span>. Each pair in the result will be represented as <span class="obeylines-h"><span class="verb"><code class="inlineCode">((lat,</code><code class="inlineCode"> lon),</code><code class="inlineCode"> (lat,</code><code class="inlineCode"> lon))</code></span></span>. The value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">fst(item)</code></span></span> is the starting position; the value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">snd(item)</code></span></span> is the ending position for each value of each item in the collection. We’ll expose this design through a series of examples.</p>&#13;
<p>In the next sections, we’ll show you how to create a generator function that will iterate over the content of a source file. This iterable will contain the raw input data that we will process. Once we have the raw data, later sections will show how to decorate each leg with the haversine distance along the leg. The final result of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">wrap(wrap(iterable()))</code></span></span> design will be a sequence of three tuples: <span class="obeylines-h"><span class="verb"><code class="inlineCode">((lat,</code><code class="inlineCode"> lon),</code><code class="inlineCode"> (lat,</code><code class="inlineCode"> lon),</code><code class="inlineCode"> distance)</code></span></span>. We can then analyze the results for the longest and shortest distance, bounding rectangle, and other summaries.</p>&#13;
<p>The haversine formula is long-ish, but computes the distance along the surface of a sphere between two points:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file34.jpg" class="math-display" alt=" ∘ --------------------------------------------- (ϕ − ϕ ) ( λ − λ ) a = sin2 --1---2 + cos(ϕ1)cos(ϕ2)sin2 -1----2 2 2 "/>&#13;
</div>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file35.jpg" class="math-display" alt="d = R × 2 arcsin(a) "/>&#13;
</div>&#13;
<p>The first part, <span class="italic">a</span>, is the angle between<span id="dx1-76011"/> the two points. The distance, <span class="italic">d</span>, is computed from the angle, using the radius of the sphere, <span class="italic">R</span>, in the desired units. For a distance in nautical miles, we can use <span class="italic">R </span>= <img src="../Images/file36.jpg" class="frac" data-align="middle" alt="360×60- 2×π"/> <span class="cmsy-10x-x-109">≈ </span>3437<span class="italic">.</span>7. For a distance in kilometers, we can use <span class="italic">R </span>= 6371. <span id="x1-76012r76"/></p>&#13;
<section id="parsing-an-xml-file" class="level4 subsectionHead" data-number="0.8.2.1">&#13;
<h4 class="subsectionHead" data-number="0.8.2.1"><span class="titlemark">4.2.1 </span> <span id="x1-770001"/>Parsing an XML file</h4>&#13;
<p>We’ll start by parsing<span id="dx1-77001"/> an <span class="keyWord">Extensible Markup Language </span>(<span class="keyWord">XML</span>) file to get the raw latitude and longitude pairs. This will show you how we can encapsulate some not-quite-functional features of Python to create an iterable sequence of values.</p>&#13;
<p>We’ll make use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">xml.etree</code></span></span> module. After parsing, the resulting <span class="obeylines-h"><span class="verb"><code class="inlineCode">ElementTree</code></span></span> object has an <span class="obeylines-h"><span class="verb"><code class="inlineCode">iterfind()</code></span></span> method that will iterate through the available values.</p>&#13;
<p>We’ll be looking for constructs such as the following XML example:</p>&#13;
<pre id="listing-56" class="lstlisting"><code>&lt;Placemark&gt;&lt;Point&gt; &#13;
&lt;coordinates&gt;-76.33029518659048, 37.54901619777347,0&lt;/coordinates&gt; &#13;
&lt;/Point&gt;&lt;/Placemark&gt;</code></pre>&#13;
<p>The file will have a number of <span class="obeylines-h"><span class="verb"><code class="inlineCode">&lt;Placemark&gt;</code></span></span> tags, each of which has a point and coordinate structure within it. The coordinate tag’s values are East-West longitude, North-South latitude, and altitude above mean sea level. This means there are two tiers of parsing: the XML tier, and then the details of each coordinate. This is typical of <span class="keyWord">Keyhole Markup Language </span>(<span class="keyWord">KML</span>) files that contain geographic information. (For more information, see <a href="https://developers.google.com/kml/documentation" class="url">https://developers.google.com/kml/documentation</a>.)</p>&#13;
<p>Extracting data from an XML file can be approached at two levels of abstraction:</p>&#13;
<ul>&#13;
<li><p>At the lower level, we need to locate the various tags, attribute values, and content within the XML file.</p></li>&#13;
<li><p>At a higher level, we want to make useful objects out of the text and attribute values.</p></li>&#13;
</ul>&#13;
<p>The lower-level processing<span id="dx1-77005"/> can be approached in the following way:</p>&#13;
<pre id="listing-57" class="lstlisting"><code>from collections.abc import Iterable &#13;
from typing import TextIO &#13;
import xml.etree.ElementTree as XML &#13;
 &#13;
def row_iter_kml(file_obj: TextIO) -&gt; Iterable[list[str]]: &#13;
    ns_map = { &#13;
        "ns0": "http://www.opengis.net/kml/2.2", &#13;
        "ns1": "http://www.google.com/kml/ext/2.2" &#13;
    } &#13;
    path_to_points = ( &#13;
      "./ns0:Document/ns0:Folder/ns0:Placemark/" &#13;
      "ns0:Point/ns0:coordinates" &#13;
    ) &#13;
    doc = XML.parse(file_obj) &#13;
    text_blocks = ( &#13;
        coordinates.text &#13;
        for coordinates in doc.iterfind(path_to_points, ns_map) &#13;
    ) &#13;
    return ( &#13;
        comma_split(text) &#13;
        for text in text_blocks &#13;
        if text is not None &#13;
    )</code></pre>&#13;
<p>This function requires text; generally this will come from a file opened via a <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> statement. The result of this function is a generator that creates list objects from the latitude/longitude pairs. As a part of the XML processing, this function uses a simple static <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> object, <span class="obeylines-h"><span class="verb"><code class="inlineCode">ns_map</code></span></span>, that provides the namespace mapping information for the XML tags being parsed. This dictionary will be used by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ElementTree.iterfind()</code></span></span> method to locate only the <span class="obeylines-h"><span class="verb"><code class="inlineCode">&lt;coordinates&gt;</code></span></span> tags in the XML source document.</p>&#13;
<p>The essence of the parsing is a generator function that uses the sequence of tags located by <span class="obeylines-h"><span class="verb"><code class="inlineCode">doc.iterfind()</code></span></span>. This sequence of tags is then processed by a <span class="obeylines-h"><span class="verb"><code class="inlineCode">comma_split()</code></span></span> function to tease the text value into its comma-separated components.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">path_to_points</code></span></span> object is a string<span id="dx1-77029"/> that defines how to navigate through the XML structure. It describes the location of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">&lt;coordinates&gt;</code></span></span> tag within the other tags of the document. Using this path means the generator expression will avoid the values of other, irrelevant tags.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code><code class="inlineCode"> text</code><code class="inlineCode"> is</code><code class="inlineCode"> not</code><code class="inlineCode"> None</code></span></span> clause reflects the definition of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">text</code></span></span> attribute of an element tree tag. If there’s no body in the tag, the text value will be <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>. While it is extremely unlikely to see an empty <span class="obeylines-h"><span class="verb"><code class="inlineCode">&lt;coordinates/&gt;</code></span></span> tag, the type hints require we handle this case.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">comma_split()</code></span></span> function has a more functional syntax than the the <span class="obeylines-h"><span class="verb"><code class="inlineCode">split()</code></span></span> method of a string. This function is defined as follows:</p>&#13;
<pre id="listing-58" class="lstlisting"><code>def comma_split(text: str) -&gt; list[str]: &#13;
    return text.split(",")</code></pre>&#13;
<p>We’ve used a wrapper to emphasize a slightly more uniform syntax. We’ve also added explicit type hints to make it clear that a string is converted to a list of <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code></span></span> values. Without the type hint, there are two potential definitions of <span class="obeylines-h"><span class="verb"><code class="inlineCode">split()</code></span></span> that could be meant. It turns out, this method applies to <span class="obeylines-h"><span class="verb"><code class="inlineCode">bytes</code></span></span> as well as <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code></span></span>. We’ve used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code></span></span> type name to narrow the domain of types.</p>&#13;
<p>The result of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter_kml()</code></span></span> function is an iterable sequence of rows of data. Each row will be a list composed of three strings: latitude, longitude, and altitude of a waypoint along this path. This isn’t directly useful yet. We’ll need to do some more processing to get latitude and longitude as well as converting these two strings into useful floating-point values.</p>&#13;
<p>This idea of an iterable sequence of tuples (or lists) allows us to process some kinds of data files in a simple and uniform way. In <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions,</span> <span class="cmti-10x-x-109">Iterators, and Generators</span></a>, we looked at how <span class="keyWord">Comma-Separated Values</span> (<span class="keyWord">CSV</span>) files are easily handled as rows of tuples. In <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions</span> <span class="cmti-10x-x-109">and Reductions</span></a>, we’ll revisit the parsing idea to compare these various examples.</p>&#13;
<p>The output from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter_kml()</code></span></span> function can be collected by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> function. The following interactive<span id="dx1-77032"/> example will read the file and extract the details. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> function will create a single list from each <span class="obeylines-h"><span class="verb"><code class="inlineCode">&lt;coordinate&gt;</code></span></span> tag. The accumulated result object looks like the following example:</p>&#13;
<div id="tcolobox-51" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pprint import pprint &#13;
&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; with urllib.request.urlopen(source_url) as source: &#13;
...     v1 = list(row_iter_kml(source)) &#13;
&gt;&gt;&gt; pprint(v1) &#13;
[[’-76.33029518659048’, ’37.54901619777347’, ’0’], &#13;
 [’-76.27383399999999’, ’37.840832’, ’0’], &#13;
 [’-76.459503’, ’38.331501’, ’0’], &#13;
 ... &#13;
 [’-76.47350299999999’, ’38.976334’, ’0’]]</code></pre>&#13;
&#13;
</div>&#13;
<p>These are all string values. To be more useful, it’s important to apply some additional functions to the output of this function that will create a usable subset of the data. <span id="x1-77044r83"/></p>&#13;
</section>&#13;
<section id="parsing-a-file-at-a-higher-level" class="level4 subsectionHead" data-number="0.8.2.2">&#13;
<h4 class="subsectionHead" data-number="0.8.2.2"><span class="titlemark">4.2.2 </span> <span id="x1-780002"/>Parsing a file at a higher level</h4>&#13;
<p>After parsing<span id="dx1-78001"/> the low-level syntax to transform XML to Python, we can restructure the raw data into something usable<span id="dx1-78002"/> in our Python program. This kind of structuring applies to XML, <span class="keyWord">JavaScript Object Notation </span>(<span class="keyWord">JSON</span>), CSV, YAML, TOML, and any of the wide variety of physical formats in which data is serialized.</p>&#13;
<p>We’ll aim to write a small suite of generator functions that transforms the parsed data into a form our application can use. The generator functions include some simple transformations on the text that are found by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter_kml()</code></span></span> function, which are as follows:</p>&#13;
<ul>&#13;
<li><p>Discarding altitude, which can also be stated as keeping only latitude and longitude</p></li>&#13;
<li><p>Changing the order from <span class="obeylines-h"><span class="verb"><code class="inlineCode">(longitude,</code><code class="inlineCode"> latitude)</code></span></span> to <span class="obeylines-h"><span class="verb"><code class="inlineCode">(latitude,</code><code class="inlineCode"> longitude)</code></span></span></p></li>&#13;
</ul>&#13;
<p>We can make these two transformations have more syntactic uniformity by defining a utility function, as follows:</p>&#13;
<pre id="listing-59" class="lstlisting"><code>def pick_lat_lon( &#13;
        lon: str, lat: str, alt: str &#13;
) -&gt; tuple[str, str]: &#13;
    return lat, lon</code></pre>&#13;
<p>We’ve created a function<span id="dx1-78007"/> to take three argument values and create a tuple from two of them. The type hints are more complex than the function itself. The conversion of source data to usable data often involves selecting a subset of fields, as well as conversion from strings to numbers. We’ve separated the two problems because these aspects often evolve separately.</p>&#13;
<p>We can use this function as follows:</p>&#13;
<pre id="listing-60" class="lstlisting"><code>from collections.abc import Iterable &#13;
from typing import TypeAlias &#13;
 &#13;
Rows: TypeAlias = Iterable[list[str]] &#13;
LL_Text: TypeAlias = tuple[str, str] &#13;
 &#13;
def lat_lon_kml(row_iter: Rows) -&gt; Iterable[LL_Text]: &#13;
    return (pick_lat_lon(*row) for row in row_iter)</code></pre>&#13;
<p>This function will apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pick_lat_lon()</code></span></span> function to each row from a source iterator. We’ve used <span class="obeylines-h"><span class="verb"><code class="inlineCode">*row</code></span></span> to assign each element of the row’s three-tuple to separate parameters of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pick_lat_lon()</code></span></span> function. The function can then extract and reorder the two relevant values from each three-tuple.</p>&#13;
<p>To simplify the function definition, we’ve defined two type aliases: <span class="obeylines-h"><span class="verb"><code class="inlineCode">Rows</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">LL_Text</code></span></span>. These type aliases can simplify a function definition. They can also be reused to ensure that several related functions are all working with the same types of objects. This kind of functional design allows us to freely replace any function with its equivalent, which makes refactoring less risky.</p>&#13;
<p>These functions can be combined to parse the file and build a structure we can use. Here’s an example of some code that could be used for this purpose:</p>&#13;
<div id="tcolobox-52" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import urllib &#13;
&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; with urllib.request.urlopen(source_url) as source: &#13;
...     v1 = tuple(lat_lon_kml(row_iter_kml(source))) &#13;
&gt;&gt;&gt; v1[0] &#13;
(’37.54901619777347’, ’-76.33029518659048’) &#13;
&gt;&gt;&gt; v1[-1] &#13;
(’38.976334’, ’-76.47350299999999’)</code></pre>&#13;
&#13;
</div>&#13;
<p>This script<span id="dx1-78025"/> uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">request.urlopen()</code></span></span> function to open a source. In this case, it’s a local file. However, we can also open a KML file on a remote server. Our objective in using this kind of file opening is to ensure that our processing is uniform no matter what the source of the data is.</p>&#13;
<p>The script is built around the two functions that do low-level parsing of the KML source. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter_kml(source)</code></span></span> expression produces a sequence of text columns. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">lat_lon_kml()</code></span></span> function will extract and reorder the latitude and longitude values. This creates an intermediate result that sets the stage for further processing. The subsequent processing can be designed to be independent of the original format.</p>&#13;
<p>The final function provides the latitude and longitude values from a complex XML file using an almost purely functional approach. As the result is iterable, we can continue to use functional programming techniques to process each point that we retrieve from the file.</p>&#13;
<div id="tcolobox-53" class="infobox note">&#13;
&#13;
&#13;
<p>Purists will sometimes argue that using a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement introduces a non-functional element. To be pure, the iteration should be defined recursively. Since a recursion isn’t a good use of Python language features, we’ll prefer to sacrifice some purity for a more Pythonic approach.</p>&#13;
&#13;
</div>&#13;
<p>This design explicitly separates low-level XML parsing from higher-level reorganization of the data. The XML parsing<span id="dx1-78026"/> produced a generic tuple of string structure. This is compatible with parsers for other file formats. As one example, the result value is compatible with the output from the CSV parser. When working with SQL databases, it can help to use a similar iterable of tuple structures. This permits a design for higher-level processing that can work with data from a variety of sources.</p>&#13;
<p>We’ll show you a series of transformations to re-arrange this data from a collection of strings to a collection of waypoints along a route. This will involve a number of transformations. We’ll need to restructure the data as well as convert from strings to floating-point values. We’ll also look at a few ways to simplify and clarify the subsequent processing steps. We’ll use this dataset in later chapters because it’s quite complex. <span id="x1-78027r84"/></p>&#13;
</section>&#13;
<section id="pairing-up-items-from-a-sequence" class="level4 subsectionHead" data-number="0.8.2.3">&#13;
<h4 class="subsectionHead" data-number="0.8.2.3"><span class="titlemark">4.2.3 </span> <span id="x1-790003"/>Pairing up items from a sequence</h4>&#13;
<p>A common restructuring<span id="dx1-79001"/> requirement is to make start-stop pairs out of points in a sequence. Given a sequence, <span class="italic">S </span>= <span class="cmsy-10x-x-109">{</span><span class="italic">s</span><sub><span class="cmr-8">0</span></sub><span class="italic">,s</span><sub><span class="cmr-8">1</span></sub><span class="italic">,s</span><sub><span class="cmr-8">2</span></sub><span class="italic">,...,s</span><sub><span class="cmmi-8">n</span></sub><span class="cmsy-10x-x-109">}</span>, we would also want to create a paired sequence, <span class="italic">S </span>= <span class="cmsy-10x-x-109">{</span>(<span class="italic">s</span><sub><span class="cmr-8">0</span></sub><span class="italic">,s</span><sub><span class="cmr-8">1</span></sub>)<span class="italic">,</span>(<span class="italic">s</span><sub><span class="cmr-8">1</span></sub><span class="italic">,s</span><sub><span class="cmr-8">2</span></sub>)<span class="italic">,</span>(<span class="italic">s</span><sub><span class="cmr-8">2</span></sub><span class="italic">,s</span><sub><span class="cmr-8">3</span></sub>)<span class="italic">,...,</span>(<span class="italic">s</span><sub><span class="cmmi-8">n</span><span class="cmsy-8">−</span><span class="cmr-8">1</span></sub><span class="italic">,s</span><sub><span class="cmmi-8">n</span></sub>)<span class="cmsy-10x-x-109">}</span>. The first and second items form a pair. The second and third items form the next pair. Note that the pairs overlap; each point (other than the first or last) will be the end of one pair and the start of the next pair.</p>&#13;
<p>These overlapping pairs are used to compute distances from point to point using a trivial application of a haversine function. This technique is also used to convert a path of points into a series of line segments in a graphics application.</p>&#13;
<p>Why pair up items? Why not insert a few additional lines of code into a function such as this:</p>&#13;
<pre id="listing-61" class="lstlisting"><code>begin = next(iterable) &#13;
for end in iterable: &#13;
    compute_something(begin, end) &#13;
    begin = end</code></pre>&#13;
<p>This code snippet will process each leg of the data as a <span class="obeylines-h"><span class="verb"><code class="inlineCode">begin,</code><code class="inlineCode"> end</code></span></span> pair. However, the processing function and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to restructure the data are tightly bound, making reuse more complex than necessary. The algorithm for pairing is hard to test in isolation when it is one part of a more complex <span class="obeylines-h"><span class="verb"><code class="inlineCode">compute_something()</code></span></span> function.</p>&#13;
<p>Creating a combined<span id="dx1-79006"/> function also limits our ability to reconfigure the application. There’s no easy way to inject an alternative implementation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">compute_something()</code></span></span> function. Additionally, we’ve got a piece of an explicit state, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">begin</code></span></span> variable, which makes life potentially complex. If we try to add features to the body of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement, we can easily fail to set the <span class="obeylines-h"><span class="verb"><code class="inlineCode">begin</code></span></span> variable correctly when an item in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">iterable</code></span></span> source is filtered out from processing.</p>&#13;
<p>We achieve better reuse by separating this pairing function from other processing. Simplification, in the long run, is one of our goals. If we build up a library of helpful primitives such as this pairing function, we can tackle larger problems more quickly and confidently.</p>&#13;
<div id="tcolobox-54" class="infobox note">&#13;
&#13;
&#13;
<p>Indeed, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> library (the subject of <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The</span> <span class="cmti-10x-x-109">Itertools Module</span></a>) includes a <span class="obeylines-h"><span class="verb"><code class="inlineCode">pairwise()</code></span></span> function we can also use to perform this pairing of values from a source iterator. While we can use this function, we’ll also look at how to design our own.</p>&#13;
&#13;
</div>&#13;
<p>There are many ways to pair up the points along the route to create start and stop information for each leg. We’ll look at a few here and then revisit this in <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>, and again in <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The Itertools</span> <span class="cmti-10x-x-109">Module</span></a>. Creating pairs can be done in a purely functional way using a recursion:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file37.jpg" class="math-display" alt=" ( |{ [] if |l| ≤ 1 pairs(l) = |( [(l0,l1)]+ pairs(l[1:]) if |l| &gt; 1 "/>&#13;
</div>&#13;
<p>While the mathematical formalism seems simple, it doesn’t account for the way item <span class="italic">l</span><sub><span class="cmr-8">1</span></sub> is both part of the first pair and also the head of the remaining items in <span class="italic">l</span><sub><span class="cmr-8">[1:]</span></sub>.</p>&#13;
<p>The functional ideal is to avoid assigning this value to a variable. Variables—and the resulting stateful code—can turn into a problem when we try to make a ”small” change and misuse the variable’s value.</p>&#13;
<p>An alternative is to somehow ”peek” at the upcoming item in the iterable source of data. This doesn’t work out well in Python. Once we’ve used <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> to examine the value, it can’t be put back into the iterable. This makes a recursive, functional version of creating overlapping pairs a bit too complex to be of any real value.</p>&#13;
<p>Our strategy for performing<span id="dx1-79007"/> tail-call optimization is to replace the recursion in the mathematical formalism with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement. In some cases, we can further optimize this into a generator expression. Because this works with an explicit variable to track the state of the computation, it’s a better fit for Python, while being less purely functional.</p>&#13;
<p>The following code is an optimized version of a function to pair up the points along a route:</p>&#13;
<pre id="listing-62" class="lstlisting"><code>from collections.abc import Iterator, Iterable &#13;
from typing import Any, TypeVar &#13;
 &#13;
LL_Type = TypeVar(’LL_Type’) &#13;
 &#13;
def legs(lat_lon_iter: Iterator[LL_Type]) -&gt; Iterator[tuple[LL_Type, LL_Type]]: &#13;
    begin = next(lat_lon_iter) &#13;
    for end in lat_lon_iter: &#13;
        yield begin, end &#13;
        begin = end</code></pre>&#13;
<p>The version is simpler, quite fast, and free from the stack limits of a recursive definition. It’s independent of any particular type of sequence, as it will pair up anything emitted by a sequence generator. As there’s no processing function inside the loop, we can reuse the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function as needed. We could also redesign this function slightly to accept a processing function as a parameter value, and apply the given function to each <span class="obeylines-h"><span class="verb"><code class="inlineCode">(begin,</code><code class="inlineCode"> end)</code></span></span> pair that’s created.</p>&#13;
<p>The type variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">LL_Type</code></span></span>, is used to clarify precisely how the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function restructures the data. The hint says that the input type is preserved on output. The input type is an <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator</code></span></span> of some arbitrary type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">LL_Type</code></span></span>; the output will include tuples of the same type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">LL_Type</code></span></span>. No other conversion is implied by the function.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">begin</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">end</code></span></span> variables<span id="dx1-79018"/> maintain the state of the computation. The use of stateful variables doesn’t fit the ideal of using immutable objects for functional programming. The optimization, however, is important in Python. It’s also invisible to users of the function, making it a Pythonic-functional hybrid.</p>&#13;
<p>Note that this function requires an iterable source of individual values. This can be an iterable collection or a generator.</p>&#13;
<p>We can think of this function as one that yields the following kind of sequence of pairs:</p>&#13;
<div id="tcolobox-55" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[items[0:2], items[1:3], items[2:4], ..., items[-2:]]</code></pre>&#13;
&#13;
</div>&#13;
<p>Another view of this function using the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function is as follows:</p>&#13;
<div id="tcolobox-56" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>list(zip(items, items[1:]))</code></pre>&#13;
&#13;
</div>&#13;
<p>While informative, this <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span>-based example only works for sequence objects. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">pairs()</code></span></span> function shown earlier will work for any iterable, including sequence objects. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function only works for an <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator</code></span></span> object as the source of data. The good news is we can make an iterator object from an iterable collection with the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function. <span id="x1-79023r85"/></p>&#13;
</section>&#13;
<section id="using-the-iter-function-explicitly" class="level4 subsectionHead" data-number="0.8.2.4">&#13;
<h4 class="subsectionHead" data-number="0.8.2.4"><span class="titlemark">4.2.4 </span> <span id="x1-800004"/>Using the iter() function explicitly</h4>&#13;
<p>From a purely functional<span id="dx1-80001"/> viewpoint, all of our iterables can be processed with recursive functions, where the state is managed by the recursive call stack. Pragmatically, processing iterables in Python will often involve evaluation of <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statements. There are two common situations: collection objects and iterables. When working with a collection object, an <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator</code></span></span> object is created by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement. When working with a generator function, the generator function is an iterator and maintains its own internal state. Often, these are equivalent, from a Python programming perspective. In rare cases—generally those situations where we have to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> function explicitly—the two won’t be precisely equivalent.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function shown previously<span id="dx1-80002"/> has an explicit <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> evaluation to get the first value from the iterable. This works wonderfully well with generator functions, expressions, and other iterables. It doesn’t work with sequence objects such as tuples or lists.</p>&#13;
<p>The following code contains three examples to clarify the use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> functions:</p>&#13;
<div id="tcolobox-57" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code># Iterator as input: &#13;
&gt;&gt;&gt; list(legs(x for x in range(3))) &#13;
[(0, 1), (1, 2)] &#13;
 &#13;
# List object as input: &#13;
&gt;&gt;&gt; list(legs([0, 1, 2])) &#13;
Traceback (most recent call last): &#13;
... &#13;
TypeError: ’list’ object is not an iterator &#13;
 &#13;
# Explicit iterator created from list object: &#13;
&gt;&gt;&gt; list(legs(iter([0,1,2]))) &#13;
[(0, 1), (1, 2)]</code></pre>&#13;
&#13;
</div>&#13;
<p>In the first case, we applied the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function to an iterable. In this case, the iterable was a generator expression. This is the expected behavior based on our previous examples in this chapter. The items are properly paired up to create two legs from three waypoints.</p>&#13;
<p>In the second case, we tried to apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function to a sequence. This resulted in an error. While a list object and an iterable are equivalent when used in a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement, they aren’t equivalent everywhere. A sequence isn’t an iterator; a sequence doesn’t implement the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__next__()</code></span></span> special method allowing it to be used by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement handles this gracefully, however, by creating an iterator from a sequence automatically.</p>&#13;
<p>To make the second case work, we need to explicitly create an iterator from a list object. This permits the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function to get the first item from the iterator over the list items. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function will create an iterator<span id="dx1-80017"/> from a list. <span id="x1-80018r86"/></p>&#13;
</section>&#13;
<section id="extending-an-iteration" class="level4 subsectionHead" data-number="0.8.2.5">&#13;
<h4 class="subsectionHead" data-number="0.8.2.5"><span class="titlemark">4.2.5 </span> <span id="x1-810005"/>Extending an iteration</h4>&#13;
<p>We have two kinds of extensions<span id="dx1-81001"/> we could factor into a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement that processes iterable data. We’ll look first at a filter extension. In this case, we may be rejecting values from further consideration. They may be data outliers, or perhaps source data that’s improperly formatted. Then, we’ll look at mapping source data by performing a simple transformation to create new objects from the original objects. In our case, we’ll be transforming strings to floating-point numbers. The idea of extending a simple <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement with a mapping, however, applies to many situations. We’ll look at refactoring the above <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function. What if we need to adjust the sequence of points to discard a value? This will introduce a filter extension that rejects some data values.</p>&#13;
<p>The iterative process we’re designing returns pairs without performing any additional application-related processing—the complexity is minimal. Simplicity means we’re somewhat less likely to confuse the processing state.</p>&#13;
<p>Adding a filter extension to this design could look something like the following code snippet:</p>&#13;
<pre id="listing-63" class="lstlisting"><code>from collections.abc import Iterator, Iterable, Callable &#13;
from typing import TypeAlias &#13;
 &#13;
Waypoint: TypeAlias = tuple[float, float] &#13;
Pairs_Iter: TypeAlias = Iterator[Waypoint] &#13;
Leg: TypeAlias = tuple[Waypoint, Waypoint] &#13;
Leg_Iter: TypeAlias = Iterable[Leg] &#13;
 &#13;
def legs_filter( &#13;
        lat_lon_iter: Pairs_Iter, &#13;
        rejection_rule: Callable[[Waypoint, Waypoint], bool]) -&gt; Leg_Iter: &#13;
    begin = next(lat_lon_iter) &#13;
    for end in lat_lon_iter: &#13;
        if rejection_rule(begin, end): &#13;
            pass &#13;
        else: &#13;
            yield begin, end &#13;
        begin = end</code></pre>&#13;
<p>We have plugged in a processing<span id="dx1-81020"/> rule to reject certain values. As the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement remains succinct and expressive, we are confident that the processing will be done properly. We have, on the other hand, cluttered up a relatively simple function with two separate collections of features. This kind of clutter is not an ideal approach to functional design.</p>&#13;
<p>We haven’t really provided much information about the <span class="obeylines-h"><span class="verb"><code class="inlineCode">rejection_rule()</code></span></span> function. This needs to be a kind of condition that applies to a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> tuple to reject the point from further consideration. For example, it may reject <span class="obeylines-h"><span class="verb"><code class="inlineCode">begin</code><code class="inlineCode"> ==</code><code class="inlineCode"> end</code></span></span> to avoid zero-length legs. A handy default value for <span class="obeylines-h"><span class="verb"><code class="inlineCode">rejection_rule</code></span></span> is <span class="obeylines-h"><span class="verb"><code class="inlineCode">lambda</code><code class="inlineCode"> s,</code><code class="inlineCode"> e:</code><code class="inlineCode"> False</code></span></span>. This will preserve all of the legs.</p>&#13;
<p>The next refactoring will introduce additional mapping to an iteration. Adding mappings is common when a design is evolving. In our case, we have a sequence of string values. We need to convert these to float values for later use.</p>&#13;
<p>The following is one way to handle this data mapping, through a generator expression that wraps a generator function:</p>&#13;
<div id="tcolobox-58" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import urllib &#13;
&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; with urllib.request.urlopen(source_url) as source: &#13;
...     trip = list( &#13;
...         legs( &#13;
...            (float(lat), float(lon)) &#13;
...            for lat, lon in lat_lon_kml(row_iter_kml(source)) &#13;
...         ) &#13;
...     )</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve applied the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function to a generator expression that creates float values from the output of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">lat_lon_kml()</code></span></span> function. We can read this in an inside-out order as well. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">lat_lon_kml()</code></span></span> function’s output is transformed into a pair of float values, which is then transformed into a sequence of legs.</p>&#13;
<p>This is starting to get complex. We’ve got a large number<span id="dx1-81031"/> of nested functions here. We’re applying <span class="obeylines-h"><span class="verb"><code class="inlineCode">float()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> to a data generator. One common way of refactoring complex expressions is to separate the generator expression from any materialized collection. We can do the following to simplify the expression:</p>&#13;
<div id="tcolobox-59" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import urllib &#13;
&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; with urllib.request.urlopen(source_url) as source: &#13;
...     ll_iter = ( &#13;
...         (float(lat), float(lon)) &#13;
...         for lat, lon in lat_lon_kml(row_iter_kml(source)) &#13;
...     ) &#13;
...     trip = list( &#13;
...         legs(ll_iter) &#13;
...     )</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve assigned the generator function to a variable named <span class="obeylines-h"><span class="verb"><code class="inlineCode">ll_iter</code></span></span>. This variable isn’t a collection object; it’s a generator of item two-tuples. We’re not using a list comprehension to create an object. We’ve merely assigned the generator expression to a variable name. We’ve then used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ll_iter</code></span></span> variable in a subsequent expression.</p>&#13;
<p>The evaluation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> function actually leads to a proper object being built so that we can print the output. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">ll_iter</code></span></span> variable’s items are created only as needed.</p>&#13;
<p>There is yet another refactoring we might like to do. In general, the source of the data is something we often want to change. In our example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">lat_lon_kml()</code></span></span> function is tightly bound in the rest of the expression. This makes reuse difficult when we have a different data source.</p>&#13;
<p>In the case where the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float()</code></span></span> operation is something we’d like to parameterize so that we can reuse it, we can define a function around the generator expression. We’ll extract some of the processing into a separate function merely to group the operations. In our case, the string-pair to float-pair is unique to particular source data. We can rewrite a complex float-from-string expression<span id="dx1-81043"/> into a simpler function, such as:</p>&#13;
<pre id="listing-64" class="lstlisting"><code>from collections.abc import Iterator, Iterable &#13;
from typing import TypeAlias &#13;
 &#13;
Text_Iter: TypeAlias = Iterable[tuple[str, str]] &#13;
LL_Iter: TypeAlias = Iterable[tuple[float, float]] &#13;
 &#13;
def floats_from_pair(lat_lon_iter: Text_Iter) -&gt; LL_Iter: &#13;
    return ( &#13;
        (float(lat), float(lon)) &#13;
        for lat, lon in lat_lon_iter &#13;
    )</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">floats_from_pair()</code></span></span> function applies the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float()</code></span></span> function to the first and second values of each item in the iterable, yielding a two-tuple of floats created from an input value. We’ve relied on Python’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to decompose the two-tuple.</p>&#13;
<p>The type hints detail the transformation from an iterable sequence of <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple[str,</code><code class="inlineCode"> str]</code></span></span> items to <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple[float,</code><code class="inlineCode"> float]</code></span></span> items. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">LL_Iter</code></span></span> type alias can then be used elsewhere in a complex set of function definitions to show how the float pairs are processed.</p>&#13;
<p>We can use this function in the following context:</p>&#13;
<div id="tcolobox-60" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import urllib &#13;
&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; with urllib.request.urlopen(source_url) as source: &#13;
...     trip = list( &#13;
...         legs( &#13;
...             floats_from_pair( &#13;
...                 lat_lon_kml( &#13;
...                     row_iter_kml(source)))) &#13;
...     )</code></pre>&#13;
&#13;
</div>&#13;
<p>We’re going to create legs that are built from float values that come from a KML file. It’s fairly easy to visualize the processing, as each stage in the process is a prefix function. Each function’s input is the output from the next function in the nested processing steps. This seems like a natural way to express a pipeline of processing.</p>&#13;
<p>When parsing, we often have sequences<span id="dx1-81065"/> of string values. For numeric applications, we’ll need to convert strings to float, int, or <span class="obeylines-h"><span class="verb"><code class="inlineCode">Decimal</code></span></span> values. This often involves inserting a function such as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">floats_from_pair()</code></span></span> function into a sequence of expressions that clean up the source data.</p>&#13;
<p>Our previous output was all strings; it looked like the following code snippet:</p>&#13;
<div id="tcolobox-61" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>((’37.54901619777347’, ’-76.33029518659048’), &#13;
 (’37.840832’, ’-76.27383399999999’), &#13;
 ... &#13;
 (’38.976334’, ’-76.47350299999999’))</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ll want data like the following code snippet, where we have floats:</p>&#13;
<div id="tcolobox-62" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>(((37.54901619777347, -76.33029518659048), &#13;
(37.840832, -76.273834)), ((37.840832, -76.273834), &#13;
... &#13;
((38.330166, -76.458504), (38.976334, -76.473503)))</code></pre>&#13;
&#13;
</div>&#13;
<p>After building this processing pipeline, there are some simplifications available. We’ll look at some refactoring in <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>. We will revisit this in <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and Reductions</span></a>, to see how to apply these simplifications to the file parsing problem. <span id="x1-81076r87"/></p>&#13;
</section>&#13;
<section id="applying-generator-expressions-to-scalar-functions" class="level4 subsectionHead" data-number="0.8.2.6">&#13;
<h4 class="subsectionHead" data-number="0.8.2.6"><span class="titlemark">4.2.6 </span> <span id="x1-820006"/>Applying generator expressions to scalar functions</h4>&#13;
<p>We’ll look at a more complex kind of generator<span id="dx1-82001"/> expression to map data values from one kind of data to another. In this case, we’ll apply a fairly complex function to individual data values created by a generator.</p>&#13;
<p>We’ll call these non-generator functions<span id="dx1-82002"/> <span class="keyWord">scalar</span>, as they work with simple atomic values. To work with collections of data, a scalar function will be embedded in a generator expression.</p>&#13;
<p>To continue the example started earlier, we’ll provide a haversine function to compute the distance between latitude<span id="dx1-82003"/> and longitude values. Technically, these are angles, and some spherical trigonometry is required to convert angles to distances on the surface of the sphere. We can use a generator expression to apply a scalar <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine()</code></span></span> function to a sequence of pairs from our KML file.</p>&#13;
<p>The important part of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine()</code></span></span> function is to compute a distance between two points following the proper spherical geometry of the earth. It can involve some tricky-looking math, but we’ve provided the whole definition here. We also mentioned this function at the beginning of the <a href="#x1-760002"><span class="cmti-10x-x-109">Working with iterables</span></a> section.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine()</code></span></span> function is implemented by the following code:</p>&#13;
<pre id="listing-65" class="lstlisting"><code>from math import radians, sin, cos, sqrt, asin &#13;
from typing import TypeAlias &#13;
 &#13;
MI = 3959 &#13;
NM = 3440 &#13;
KM = 6371 &#13;
 &#13;
Point: TypeAlias = tuple[float, float] &#13;
 &#13;
def haversine(p1: Point, p2: Point, R: float=NM) -&gt; float: &#13;
    lat_1, lon_1 = p1 &#13;
    lat_2, lon_2 = p2 &#13;
    Δ_lat = radians(lat_2 - lat_1) &#13;
    Δ_lon = radians(lon_2 - lon_1) &#13;
    lat_1 = radians(lat_1) &#13;
    lat_2 = radians(lat_2) &#13;
 &#13;
    a = sqrt( &#13;
        sin(Δ_lat / 2) ** 2 + &#13;
        cos(lat_1) * cos(lat_2) * sin(Δ_lon / 2) ** 2 &#13;
    ) &#13;
    c = 2 * asin(a) &#13;
    return R * c</code></pre>&#13;
<p>The start and end points, <span class="obeylines-h"><span class="verb"><code class="inlineCode">p1</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">p2</code></span></span>, have type hints to show their structure. The return value is also provided<span id="dx1-82027"/> with a hint. The explicit use of a type alias for <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> makes it possible for the <span class="keyWord">mypy </span>tool to confirm that this function is used properly.</p>&#13;
<div id="tcolobox-63" class="packt_tip">&#13;
&#13;
&#13;
<p>For short distances covered by coastal sailors, the equirectangular distance computation is more useful:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file38.jpg" class="math-display" alt=" Δ ϕ x = R × Δ λ × cos--- 2 "/>&#13;
</div>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file39.jpg" class="math-display" alt="y = R × Δϕ "/>&#13;
</div>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file40.jpg" class="math-display" alt="d = ∘x2-+-y2- "/>&#13;
</div>&#13;
<p>Where <span class="italic">R </span>is the earth’s mean radius, <span class="italic">R </span>= <img src="../Images/file41.jpg" class="frac" data-align="middle" alt="360×60 --2π---"/> nautical miles. The <span class="italic">ϕ </span>values are N-S latitude, and the <span class="italic">λ </span>values are E-W longitude. This means (<span class="italic">ϕ</span><sub><span class="cmr-8">0</span></sub><span class="italic">,λ</span><sub><span class="cmr-8">0</span></sub>) and (<span class="italic">ϕ</span><sub><span class="cmr-8">1</span></sub><span class="italic">,λ</span><sub><span class="cmr-8">1</span></sub>) are the two points we’re navigating between.</p>&#13;
<p>See <a href="https://edwilliams.org/avform147.htm" class="url">https://edwilliams.org/avform147.htm</a> for more information.</p>&#13;
&#13;
</div>&#13;
<p>The following code is how we could use our collection of functions to examine some KML data and produce a sequence of distances:</p>&#13;
<div id="tcolobox-64" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import urllib &#13;
&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; with urllib.request.urlopen(source_url) as source: &#13;
...     trip = ( &#13;
...         (start, end, round(haversine(start, end), 4)) &#13;
...         for start,end in &#13;
...             legs( &#13;
...                 floats_from_pair( &#13;
...                     lat_lon_kml(row_iter_kml(source)) &#13;
...                 ) &#13;
...             ) &#13;
...     ) &#13;
...     for start, end, dist in trip: &#13;
...         print(f"({start} to {end} is {dist:.1f}")</code></pre>&#13;
&#13;
</div>&#13;
<p>The essence of the processing<span id="dx1-82043"/> is the generator expression assigned to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">trip</code></span></span> variable. We’ve assembled three-tuples with a start, end, and the distance from start to end. The start and end pairs come from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function works with floating-point data built from the latitude-longitude pairs extracted from a KML file.</p>&#13;
<p>The output looks like the following command snippet:</p>&#13;
<div id="tcolobox-65" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>((37.54901619777347, -76.33029518659048) to (37.840832, -76.273834) is 17.7 &#13;
((37.840832, -76.273834) to (38.331501, -76.459503) is 30.7 &#13;
((38.331501, -76.459503) to (38.845501, -76.537331) is 31.1 &#13;
((38.845501, -76.537331) to (38.992832, -76.451332) is 9.7 &#13;
...</code></pre>&#13;
&#13;
</div>&#13;
<p>Each individual processing step has been defined succinctly. The overview, similarly, can be expressed succinctly as a composition of functions and generator expressions.</p>&#13;
<p>Clearly, there are several further processing steps we may like to apply to this data. The first, of course, is to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">format()</code></span></span> method of a string to produce better-looking output.</p>&#13;
<p>More importantly, there are a number of aggregate values we’d like to extract from this data. We’ll call these values <span class="cmti-10x-x-109">reductions </span>of the available data. We’d like to reduce the data to get the maximum and minimum latitude, for example, to show the extreme north and south ends of this route. We’d like to reduce the data to get the maximum distance in one leg as well as the total distance for all legs.</p>&#13;
<p>The problem we’ll have using Python is that the output generator in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">trip</code></span></span> variable can be used only once. We can’t easily perform several reductions of this detailed data. While we can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.tee()</code></span></span> to work with the iterable several times, it takes a fair amount of memory. It can be wasteful, also, to read and parse the KML file for each reduction. We can make our processing<span id="dx1-82050"/> more efficient by materializing intermediate results as a list object.</p>&#13;
<p>In the next section, we look at two specific kinds of reductions that compute a single boolean result from a collection of booleans. <span id="x1-82051r82"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="using-any-and-all-as-reductions" class="level3 sectionHead" data-number="0.8.3">&#13;
<h3 class="sectionHead" data-number="0.8.3"><span class="titlemark">4.3 </span> <span id="x1-830003"/>Using any() and all() as reductions</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">any()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span> functions provide boolean reduction capabilities. Both functions reduce a collection<span id="dx1-83001"/> of values to a single <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span>. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span> function ensures that all items have a true value; the <span class="obeylines-h"><span class="verb"><code class="inlineCode">any()</code></span></span> function ensures that at least one item has a true value. In both cases, these functions<span id="dx1-83002"/> rely on the Pythonic concept of ”truish”, or truthy: values for which the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">bool()</code></span></span> function returns <span class="obeylines-h"><span class="verb"><code class="inlineCode">true</code></span></span>. Generally, ”falsish” values include <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>, as well as zero, an empty string, and empty collections. Non-false values are true.</p>&#13;
<p>These functions are closely related to a universal quantifier and an existential quantifier used to express mathematical logic. We may, for example, want to assert that all elements in a given collection have a property. One formalism for this could look like the following:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file42.jpg" class="math-display" alt="(∀x∈S)Prime (x ) "/>&#13;
</div>&#13;
<p>We read this as <span class="cmti-10x-x-109">for all x in S, the function, Prime(x), is true</span>. We’ve used the universal quantifier, for all, <span class="cmsy-10x-x-109">∀</span>, in front of the logical expression.</p>&#13;
<p>In Python we switch the order of the items slightly to transcribe the logic expression as follows:</p>&#13;
<pre id="listing-66" class="lstlisting"><code>all(isprime(x) for x in someset)</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span> function will evaluate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">isprime(x)</code></span></span> function for each distinct value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span> and reduce the collection of values to a single <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span>.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">any()</code></span></span> function is related to the existential quantifier. If we want to assert that no value in a collection is prime, we could use one of these two equivalent expressions:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file43.jpg" class="math-display" alt="¬ (∀ )Prime (x) ≡ (∃ )¬ Prime (x) x∈S x∈S "/>&#13;
</div>&#13;
<p>The left side states that it is not the case that all elements<span id="dx1-83004"/> in <span class="italic">S </span>are prime. The right side asserts that there exists one element<span id="dx1-83005"/> in <span class="italic">S </span>that is not prime. These two are equivalent; that is, if not all elements are prime, then one element must be non-prime.</p>&#13;
<div id="tcolobox-66" class="infobox note">&#13;
&#13;
&#13;
<p>This rule of equivalence<span id="dx1-83006"/> is called <span class="keyWord">De Morgan’s Law</span>. It can be stated generally as <span class="cmsy-10x-x-109">∀</span><span class="italic">xP</span>(<span class="italic">x</span>) <span class="cmsy-10x-x-109">≡ ¬∃</span><span class="italic">x</span><span class="cmsy-10x-x-109">¬</span><span class="italic">P</span>(<span class="italic">x</span>). If some proposition, <span class="italic">P</span>(<span class="italic">x</span>), is true for all <span class="italic">x</span>, there is no <span class="italic">x </span>for which <span class="italic">P</span>(<span class="italic">x</span>) is false.</p>&#13;
&#13;
</div>&#13;
<p>In Python, we can switch the order of the terms and transcribe these to working code in either of these two forms:</p>&#13;
<pre id="listing-67" class="lstlisting"><code>not_p_1 = not all(isprime(x) for x in someset)</code></pre>&#13;
<pre id="listing-68" class="lstlisting"><code>not_p_2 = any(not isprime(x) for x in someset)</code></pre>&#13;
<p>As these two lines are equivalent, there are two common reasons for choosing one over the other: performance and clarity. The performance is nearly identical, so it boils down to clarity. Which of these states the condition the most clearly?</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span> function can be described as an <span class="cmti-10x-x-109">and reduction </span>of a set of values. The result is similar to folding the <span class="obeylines-h"><span class="verb"><code class="inlineCode">and</code></span></span> operator between the given sequence of values. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">any()</code></span></span> function, similarly, can be described as an <span class="cmti-10x-x-109">or reduction</span>. We’ll return to this kind of general-purpose reducing when we look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function in <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 10</span></a>, <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">The Functools Module</span></a>. There’s no best answer here; it’s a question of what seems most readable to the intended audience.</p>&#13;
<p>We also need to look at the degenerate case of these functions. What if the sequence has no elements? What are the values of <span class="obeylines-h"><span class="verb"><code class="inlineCode">all(())</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">all([])</code></span></span>?</p>&#13;
<p>Consider a list, <span class="obeylines-h"><span class="verb"><code class="inlineCode">[1,</code><code class="inlineCode"> 2,</code><code class="inlineCode"> 3]</code></span></span>. The expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">[]</code><code class="inlineCode"> +</code><code class="inlineCode"> [1,</code><code class="inlineCode"> 2,</code><code class="inlineCode"> 3]</code><code class="inlineCode"> ==</code><code class="inlineCode"> [1,</code><code class="inlineCode"> 2,</code><code class="inlineCode"> 3]</code></span></span> is true because the empty list is the identity<span id="dx1-83009"/> value for list concatenation. This also works for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum(())</code></span></span> function: <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum([])</code><code class="inlineCode"> +</code><code class="inlineCode"> sum([1,</code><code class="inlineCode"> 2,</code><code class="inlineCode"> 3])</code><code class="inlineCode"> ==</code><code class="inlineCode"> sum([1,</code><code class="inlineCode"> 2,</code><code class="inlineCode"> 3])</code></span></span>. The sum of an empty list must be the additive identity<span id="dx1-83010"/> value for addition, zero.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">and</code></span></span> identity value is <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span>. This is because <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code><code class="inlineCode"> and</code><code class="inlineCode"> whatever</code><code class="inlineCode"> ==</code><code class="inlineCode"> whatever</code></span></span>. Similarly, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">or</code></span></span> identity value is <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span>. The following code demonstrates that Python follows these rules:</p>&#13;
<div id="tcolobox-67" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; all(()) &#13;
True &#13;
&gt;&gt;&gt; any(()) &#13;
False</code></pre>&#13;
&#13;
</div>&#13;
<p>Python gives us some very nice tools to perform processing that involves logic. We have the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">and</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">or</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">not</code></span></span> operators. However, we also have these collection-oriented <span class="obeylines-h"><span class="verb"><code class="inlineCode">any()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span> functions. <span id="x1-83016r89"/></p>&#13;
</section>&#13;
<section id="using-len-and-sum-on-collections" class="level3 sectionHead" data-number="0.8.4">&#13;
<h3 class="sectionHead" data-number="0.8.4"><span class="titlemark">4.4 </span> <span id="x1-840004"/>Using len() and sum() on collections</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> functions provide<span id="dx1-84001"/> two simple reductions—a count of the elements and the sum of the elements<span id="dx1-84002"/> in a sequence. These two functions<span id="dx1-84003"/> are mathematically similar, but their Python implementation is quite different.</p>&#13;
<p>Mathematically, we can observe this cool parallelism:</p>&#13;
<ul>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> function returns the sum of ones for each value in a collection, X: <span class="cmex-10x-x-109">∑</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">∈</span><span class="cmmi-8">X</span></sub>1 = <span class="cmex-10x-x-109">∑</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">∈</span><span class="cmmi-8">X</span></sub><span class="italic">x</span><sup><span class="cmr-8">0</span></sup>.</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> function returns the sum of each value in a collection, X: <span class="cmex-10x-x-109">∑</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">∈</span><span class="cmmi-8">X</span></sub><span class="italic">x </span>= <span class="cmex-10x-x-109">∑</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">∈</span><span class="cmmi-8">X</span></sub><span class="italic">x</span><sup><span class="cmr-8">1</span></sup>.</p></li>&#13;
</ul>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> function works for any iterable. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> function doesn’t apply to iterables; it only applies to sequences. This little asymmetry in the implementation of these functions is a little awkward around the edges of statistical algorithms.</p>&#13;
<p>As noted above, for empty<span id="dx1-84004"/> sequences, both of these functions<span id="dx1-84005"/> return a proper additive identity value of zero:</p>&#13;
<div id="tcolobox-68" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; sum(()) &#13;
0 &#13;
&gt;&gt;&gt; len(()) &#13;
0</code></pre>&#13;
&#13;
</div>&#13;
<p>While <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum(())</code></span></span> returns an integer zero, this isn’t a problem when working<span id="dx1-84011"/> with float values. When other numeric types are used, the integer zero can be used along with values of the types of the available data. Python’s numeric types generally have rules for performing operations with values of other numeric types. <span id="x1-84012r88"/></p>&#13;
<section id="using-sums-and-counts-for-statistics" class="level4 subsectionHead" data-number="0.8.4.1">&#13;
<h4 class="subsectionHead" data-number="0.8.4.1"><span class="titlemark">4.4.1 </span> <span id="x1-850001"/>Using sums and counts for statistics</h4>&#13;
<p>In this section, we’ll implement<span id="dx1-85001"/> a number of functions useful for statistics. The point is show how functional programming can be applied to the kinds of processing that are common in statistical functions.</p>&#13;
<p>Several common functions are described as ”measure of central tendency”. Functions like the arithmetic mean or the standard deviation provide a summary of a collection of values. A transformation<span id="dx1-85002"/> called ”normalization” shifts and scales values around a population mean and standard deviation. We’ll also look at how to compute a coefficient of correlation to show to what extent two sets of data are related to each other.</p>&#13;
<div id="tcolobox-69" class="infobox note">&#13;
&#13;
&#13;
<p>Readers might want to look at <a href="https://towardsdatascience.com/descriptive-statistics-f2beeaf7a8df" class="url">https://towardsdatascience.com/descriptive-statistics-f2beeaf7a8df</a> for more information on descriptive statistics.</p>&#13;
&#13;
</div>&#13;
<p>The arithmetic mean seems to have an appealingly trivial definition based on <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span>. It looks like the following might work:</p>&#13;
<pre id="listing-69" class="lstlisting"><code>def mean(items): &#13;
    return sum(items) / len(items)</code></pre>&#13;
<p>This simple-looking function<span id="dx1-85005"/> doesn’t work for <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterable</code></span></span> objects. This definition only works for collections that support the <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> function. This is easy to discover when trying to write proper type annotations. The definition of <span class="obeylines-h"><span class="verb"><code class="inlineCode">mean(items:</code><code class="inlineCode"> Iterable[float])</code><code class="inlineCode"> -&gt;</code><code class="inlineCode"> float</code></span></span> won’t work because more general <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterable[float]</code></span></span> types don’t support <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span>.</p>&#13;
<p>Indeed, we have a hard time performing a computation like standard deviation based on iterables. In Python, we must either materialize a sequence object or resort to somewhat more complex processing that computes multiple sums on a single pass through the data. To use simpler functions means using a <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> to create a concrete sequence that can be processed multiple times.</p>&#13;
<p>To pass muster with <span class="keyWord">mypy</span>, the definition needs to look like this:</p>&#13;
<pre id="listing-70" class="lstlisting"><code>from collections.abc import Sequence &#13;
 &#13;
def mean(items: Sequence[float]) -&gt; float: &#13;
    return sum(items)/len(items)</code></pre>&#13;
<p>This includes the appropriate type hints to ensure that <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> will both work for the expected types of data. The <span class="keyWord">mypy </span>tool<span id="dx1-85010"/> is aware of the arithmetic type matching rules: any value that could be treated as a float would be considered valid. This means that <span class="obeylines-h"><span class="verb"><code class="inlineCode">mean([1,</code><code class="inlineCode"> 2,</code><code class="inlineCode"> 3])</code></span></span> will be accepted by the <span class="keyWord">mypy </span>tool in spite of the values being all integers.</p>&#13;
<p>We have some alternative and elegant expressions for mean and standard deviation in the following definitions:</p>&#13;
<pre id="listing-71" class="lstlisting"><code>import math &#13;
from collections.abc import Sequence &#13;
 &#13;
def stdev(data: Sequence[float]) -&gt; float: &#13;
 &#13;
    s0 = len(data)  # sum(1 for x in data) &#13;
    s1 = sum(data)  # sum(x for x in data) &#13;
    s2 = sum(x**2 for x in data) &#13;
 &#13;
    mean = s1 / s0 &#13;
    stdev = math.sqrt(s2 / s0 - mean ** 2) &#13;
    return stdev</code></pre>&#13;
<p>These three sums, <span class="obeylines-h"><span class="verb"><code class="inlineCode">s0</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">s1</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">s2</code></span></span>, have a tidy, parallel structure. We can easily compute the mean from two of the sums. The standard deviation is a bit more complex, but it’s based on the three available sums.</p>&#13;
<p>This kind of pleasant symmetry<span id="dx1-85023"/> also works for more complex statistical functions, such as correlation and even least-squares linear regression.</p>&#13;
<p>The moment of correlation between two sets of samples can be computed from their standardized value. The following is a function to compute the standardized value:</p>&#13;
<pre id="listing-72" class="lstlisting"><code>def z(x: float, m_x: float, s_x: float) -&gt; float: &#13;
    return (x - m_x) / s_x</code></pre>&#13;
<p>The calculation subtracts the mean, <span class="italic">μ</span><sub><span class="cmmi-8">x</span></sub>, from each sample, <span class="italic">x</span>, and divides it by the standard deviation, <span class="italic">σ</span><sub><span class="cmmi-8">x</span></sub>. This gives us a value measured in units of sigma, <span class="italic">σ</span>. For normally-distributed data, a value <span class="cmsy-10x-x-109">±</span>1<span class="italic">σ </span>is expected about two-thirds of the time. More extreme values should be less common. A value outside <span class="cmsy-10x-x-109">±</span>3<span class="italic">σ </span>should happen less than one percent of the time.</p>&#13;
<p>We can use this scalar function as follows:</p>&#13;
<div id="tcolobox-70" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; d = [2, 4, 4, 4, 5, 5, 7, 9] &#13;
&gt;&gt;&gt; list(z(x, mean(d), stdev(d)) for x in d) &#13;
[-1.5, -0.5, -0.5, -0.5, 0.0, 0.0, 1.0, 2.0]</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve built a list that consists of normalized scores based on some raw data in the variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">d</code></span></span>. We used a generator expression to apply the scalar function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">z()</code></span></span>, to the sequence object.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">mean()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">stdev()</code></span></span> functions are based on the examples<span id="dx1-85030"/> shown previously:</p>&#13;
<pre id="listing-73" class="lstlisting"><code>from math import sqrt &#13;
from collections.abc import Sequence &#13;
 &#13;
def mean(samples: Sequence[float]) -&gt; float: &#13;
    return s1(samples)/s0(samples) &#13;
 &#13;
def stdev(samples: Sequence[float]) -&gt; float: &#13;
    N = s0(samples) &#13;
    return sqrt((s2(samples) / N) - (s1(samples) / N) ** 2)</code></pre>&#13;
<p>The three sum functions, similarly, can be defined as shown in the following code:</p>&#13;
<pre id="listing-74" class="lstlisting"><code>def s0(samples: Sequence[float]) -&gt; float: &#13;
    return sum(1 for x in samples)  # or len(data) &#13;
 &#13;
def s1(samples: Sequence[float]) -&gt; float: &#13;
    return sum(x for x in samples)  # or sum(data) &#13;
 &#13;
def s2(samples: Sequence[float]) -&gt; float: &#13;
    return sum(x*x for x in samples)</code></pre>&#13;
<p>While this is very expressive and succinct, it’s a little frustrating because we can’t use an iterable here. When evaluating the <span class="obeylines-h"><span class="verb"><code class="inlineCode">mean()</code></span></span> function, for example, both a sum of the iterable and a count of the iterable are required. For the standard deviation, two sums and a count of the iterable are all required. For this kind of statistical processing, we must materialize a sequence object (in other words, create a <span class="obeylines-h"><span class="verb"><code class="inlineCode">list</code></span></span>) so that we can examine the data multiple times.</p>&#13;
<p>The following code shows how we can compute the correlation between two sets of samples:</p>&#13;
<pre id="listing-75" class="lstlisting"><code>def corr(samples1: Sequence[float], samples2: Sequence[float]) -&gt; float: &#13;
    m_1, s_1 = mean(samples1), stdev(samples1) &#13;
    m_2, s_2 = mean(samples2), stdev(samples2) &#13;
    z_1 = (z( x, m_1, s_1 ) for x in samples1) &#13;
    z_2 = (z( x, m_2, s_2 ) for x in samples2) &#13;
    r = ( &#13;
        sum(zx1 * zx2 for zx1, zx2 in zip(z_1, z_2)) &#13;
        / len(samples1) &#13;
    ) &#13;
    return r</code></pre>&#13;
<p>This correlation function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">corr()</code></span></span>, gathers basic statistical summaries of the two sets of samples: the mean and standard deviation. Given these summaries, we define two generator functions that will create normalized<span id="dx1-85058"/> values for each set of samples. We can then use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function (see the next example) to pair up items from the two sequences of normalized values and compute the product of those two normalized values. The average of the product of the normalized scores is the correlation.</p>&#13;
<p>The following code is an example of gathering the correlation between two sets of samples:</p>&#13;
<div id="tcolobox-71" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; xi = [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, &#13;
... 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83,] &#13;
 &#13;
&gt;&gt;&gt; yi = [52.21,53.12,54.48,55.84,57.20,58.57,59.93,61.29, &#13;
... 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46,] &#13;
 &#13;
&gt;&gt;&gt; round(corr(xi, yi), 5) &#13;
0.99458</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve shown two sequences of data points, <span class="obeylines-h"><span class="verb"><code class="inlineCode">xi</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">yi</code></span></span>. The correlation is over <span class="obeylines-h"><span class="verb"><code class="inlineCode">0.99</code></span></span>, which shows a very strong relationship between the two sequences.</p>&#13;
<p>This shows one of the strengths of functional programming. We’ve created a handy statistical module using a half-dozen functions with definitions that are single expressions. Interestingly, the the <span class="obeylines-h"><span class="verb"><code class="inlineCode">corr()</code></span></span> function can’t easily be reduced to a single expression. (It can be reduced to a single very long expression, but it would be terribly hard to read.) Each internal variable in this function’s implementation is used only once. This shows us that the <span class="obeylines-h"><span class="verb"><code class="inlineCode">corr()</code></span></span> function has a functional<span id="dx1-85068"/> design, even though it’s written out in six separate lines of Python. <span id="x1-85069r90"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="using-zip-to-structure-and-flatten-sequences" class="level3 sectionHead" data-number="0.8.5">&#13;
<h3 class="sectionHead" data-number="0.8.5"><span class="titlemark">4.5 </span> <span id="x1-860005"/>Using zip() to structure and flatten sequences</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function interleaves<span id="dx1-86001"/> values from several iterators or sequences. It will create <span class="cmti-10x-x-109">n </span>tuples from the values in each of the <span class="cmti-10x-x-109">n </span>input iterables or sequences. We used it in the previous section to interleave data points from two sets of samples, creating two-tuples.</p>&#13;
<div id="tcolobox-72" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function is a generator. It does not materialize a resulting collection.</p>&#13;
&#13;
</div>&#13;
<p>The following is an example<span id="dx1-86002"/> of code that shows what the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function does:</p>&#13;
<div id="tcolobox-73" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; xi = [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, &#13;
... 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83,] &#13;
&gt;&gt;&gt; yi = [52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29, &#13;
... 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46,] &#13;
 &#13;
&gt;&gt;&gt; zip(xi, yi) &#13;
&lt;zip object at ...&gt; &#13;
 &#13;
&gt;&gt;&gt; pairs = list(zip(xi, yi)) &#13;
&gt;&gt;&gt; pairs[:3] &#13;
[(1.47, 52.21), (1.5, 53.12), (1.52, 54.48)] &#13;
&gt;&gt;&gt; pairs[-3:] &#13;
[(1.78, 69.92), (1.8, 72.19), (1.83, 74.46)]</code></pre>&#13;
&#13;
</div>&#13;
<p>There are a number of edge cases for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function. We must ask the following questions about its behavior:</p>&#13;
<ul>&#13;
<li><p>What happens where then are no arguments at all?</p></li>&#13;
<li><p>What happens where there’s only one argument?</p></li>&#13;
<li><p>What happens when the sequences are different lengths?</p></li>&#13;
</ul>&#13;
<p>As with other functions, such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">any()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span>, we want an identity value as a result when applying<span id="dx1-86017"/> the reduction to an empty sequence. For example, <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum(())</code></span></span> should be zero. This concept tells us what the identity value for <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> should be.</p>&#13;
<p>Clearly, each of these edge cases must produce some kind of iterable output. Here are some examples of code that clarify the behaviors. First, the empty argument list:</p>&#13;
<div id="tcolobox-74" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(zip()) &#13;
[]</code></pre>&#13;
&#13;
</div>&#13;
<p>The production of an empty list fits with the idea of a list identity value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">[]</code></span></span>. Next, we’ll try a single iterable:</p>&#13;
<div id="tcolobox-75" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(zip((1,2,3))) &#13;
[(1,), (2,), (3,)]</code></pre>&#13;
&#13;
</div>&#13;
<p>In this case, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function emitted one tuple from each input value. This, too, makes considerable sense.</p>&#13;
<p>Finally, we’ll look at the different-length list approach used by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function:</p>&#13;
<div id="tcolobox-76" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(zip((1, 2, 3), (’a’, ’b’))) &#13;
[(1, ’a’), (2, ’b’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>This result is debatable. Why truncate the longer list? Why not pad the shorter list with <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values? This alternate definition of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function is available in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_longest()</code></span></span> function. We’ll look at this in <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The Itertools Module</span></a>. <span id="x1-86027r91"/></p>&#13;
<section id="unzipping-a-zipped-sequence" class="level4 subsectionHead" data-number="0.8.5.1">&#13;
<h4 class="subsectionHead" data-number="0.8.5.1"><span class="titlemark">4.5.1 </span> <span id="x1-870001"/>Unzipping a zipped sequence</h4>&#13;
<p>We can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> to create a sequence<span id="dx1-87001"/> of tuples. We also need to look at several ways to unzip a collection of tuples into separate collections.</p>&#13;
<div id="tcolobox-77" class="packt_tip">&#13;
&#13;
&#13;
<p>We can’t fully unzip an iterable of tuples, since we might want to make multiple passes over the data. Depending on our needs, we may need to materialize the iterable to extract multiple values.</p>&#13;
&#13;
</div>&#13;
<p>The first way to unzip tuples is something<span id="dx1-87002"/> we’ve seen many times: we can use a generator function to unzip a sequence of tuples. For example, assume that the following pairs are a sequence object with two-tuples:</p>&#13;
<div id="tcolobox-78" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; p0 = list(x[0] for x in pairs) &#13;
&gt;&gt;&gt; p0[:3] &#13;
[1.47, 1.5, 1.52] &#13;
&gt;&gt;&gt; p1 = list(x[1] for x in pairs) &#13;
&gt;&gt;&gt; p1[:3] &#13;
[52.21, 53.12, 54.48]</code></pre>&#13;
&#13;
</div>&#13;
<p>This snippet created two sequences. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">p0</code></span></span> sequence has the first element of each two-tuple; the <span class="obeylines-h"><span class="verb"><code class="inlineCode">p1</code></span></span> sequence has the second element of each two-tuple.</p>&#13;
<p>Under some circumstances, we can use the multiple assignment of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to decompose the tuples. The following is an example that computes the sum of the products:</p>&#13;
<div id="tcolobox-79" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; round(sum(p0*p1 for p0, p1 in pairs), 3) &#13;
1548.245</code></pre>&#13;
&#13;
</div>&#13;
<p>We used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to decompose each two-tuple into <span class="obeylines-h"><span class="verb"><code class="inlineCode">p0</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">p1</code></span></span>. <span id="x1-87013r93"/></p>&#13;
</section>&#13;
<section id="flattening-sequences" class="level4 subsectionHead" data-number="0.8.5.2">&#13;
<h4 class="subsectionHead" data-number="0.8.5.2"><span class="titlemark">4.5.2 </span> <span id="x1-880002"/>Flattening sequences</h4>&#13;
<p>Sometimes, we’ll have zipped<span id="dx1-88001"/> data that needs to be flattened. That is, we need to turn a sequence of sub-sequences into a single list. For example, our input could be a file that has rows of columnar data. It looks like this:</p>&#13;
<pre id="listing-76" class="lstlisting"><code>2 3 5 7 11 13 17 19 23 29 &#13;
31 37 41 43 47 53 59 61 67 71 &#13;
...</code></pre>&#13;
<p>We can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">(line.split()</code><code class="inlineCode"> for</code><code class="inlineCode"> line</code><code class="inlineCode"> in</code><code class="inlineCode"> file)</code></span></span> to create a sequence from the lines in the source file. Each item within that sequence<span id="dx1-88005"/> will be a nested 10-item tuple from the values on a single line.</p>&#13;
<p>This creates data in blocks of 10 values. It looks as follows:</p>&#13;
<div id="tcolobox-80" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; blocked = list(line.split() for line in file) &#13;
&gt;&gt;&gt; from pprint import pprint &#13;
&gt;&gt;&gt; pprint(blocked) &#13;
[[’2’, ’3’, ’5’, ’7’, ’11’, ’13’, ’17’, ’19’, ’23’, ’29’], &#13;
 [’31’, ’37’, ’41’, ’43’, ’47’, ’53’, ’59’, ’61’, ’67’, ’71’], &#13;
 ... &#13;
 [’179’, ’181’, ’191’, ’193’, ’197’, ’199’, ’211’, ’223’, ’227’, ’229’]]</code></pre>&#13;
&#13;
</div>&#13;
<p>This is a start, but it isn’t complete. We want to get the numbers into a single, flat sequence. Each item in the input is a 10-tuple; we’d rather not deal with decomposing this one item at a time.</p>&#13;
<p>We can use a two-level generator expression, as shown in the following code snippet, for this kind of flattening:</p>&#13;
<div id="tcolobox-81" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; len(blocked) &#13;
5 &#13;
&gt;&gt;&gt; (x for line in blocked for x in line) &#13;
&lt;generator object &lt;genexpr&gt; at ...&gt; &#13;
&gt;&gt;&gt; flat = list(x for line in blocked for x in line) &#13;
&gt;&gt;&gt; len(flat) &#13;
50 &#13;
&gt;&gt;&gt; flat[:10] &#13;
[’2’, ’3’, ’5’, ’7’, ’11’, ’13’, ’17’, ’19’, ’23’, ’29’]</code></pre>&#13;
&#13;
</div>&#13;
<p>The first <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> clause assigns each item—a list of 10 values—from the blocked list to the line variable. The second <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> clause assigns each individual string from the line variable to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span> variable. The final generator is this sequence<span id="dx1-88024"/> of values assigned to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span> variable.</p>&#13;
<p>We can understand this via a rewrite as follows:</p>&#13;
<pre id="listing-77" class="lstlisting"><code>from collections.abc import Iterable &#13;
from typing import Any &#13;
 &#13;
def flatten(data: Iterable[Iterable[Any]]) -&gt; Iterable[Any]: &#13;
    for line in data: &#13;
        for x in line: &#13;
            yield x</code></pre>&#13;
<p>This transformation shows us how the generator expression works. The first <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> clause (<span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code><code class="inlineCode"> line</code><code class="inlineCode"> in</code><code class="inlineCode"> data</code></span></span>) steps through each 10-tuple in the data. The second <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> clause (<span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> line</code></span></span>) steps through each item in the first <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> clause.</p>&#13;
<p>This expression flattens a sequence-of-sequence structure into a single sequence. More generally, it flattens any iterable that contains iterables into a single, flat iterable. It will work for list-of-list as well as list-of-set or any other combination of nested iterables. <span id="x1-88032r94"/></p>&#13;
</section>&#13;
<section id="structuring-flat-sequences" class="level4 subsectionHead" data-number="0.8.5.3">&#13;
<h4 class="subsectionHead" data-number="0.8.5.3"><span class="titlemark">4.5.3 </span> <span id="x1-890003"/>Structuring flat sequences</h4>&#13;
<p>Sometimes, we’ll have raw data that is a flat list of values that we’d like to bunch up into subgroups. In the <a href="#x1-790003"><span class="cmti-10x-x-109">Pairing up items from a sequence</span></a> section earlier in this chapter, we looked at overlapping<span id="dx1-89001"/> pairs. In this section, we’re looking at non-overlapping pairs.</p>&#13;
<p>One approach is to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function to implement this. This will have to wait until <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The Itertools</span> <span class="cmti-10x-x-109">Module</span></a>.</p>&#13;
<p>Let’s say we have a flat list, as follows:</p>&#13;
<div id="tcolobox-82" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; flat = [’2’, ’3’, ’5’, ’7’, ’11’, ’13’, ’17’, ’19’, ’23’, ’29’, &#13;
... ’31’, ’37’, ’41’, ’43’, ’47’, ’53’, ’59’, ’61’, ’67’, ’71’, &#13;
... ]</code></pre>&#13;
&#13;
</div>&#13;
<p>We can write nested generator functions to build a sequence-of-sequence structure from flat data. To do this, we’ll need a single iterator<span id="dx1-89006"/> that we can use multiple times. The expression looks like the following code snippet:</p>&#13;
<div id="tcolobox-83" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; flat_iter = iter(flat) &#13;
&gt;&gt;&gt; (tuple(next(flat_iter) for i in range(5)) &#13;
...     for row in range(len(flat) // 5) &#13;
... ) &#13;
&lt;generator object &lt;genexpr&gt; at ...&gt; &#13;
 &#13;
&gt;&gt;&gt; grouped = list(_) &#13;
&gt;&gt;&gt; from pprint import pprint &#13;
&gt;&gt;&gt; pprint(grouped) &#13;
[(’2’, ’3’, ’5’, ’7’, ’11’), &#13;
 (’13’, ’17’, ’19’, ’23’, ’29’), &#13;
 (’31’, ’37’, ’41’, ’43’, ’47’), &#13;
 (’53’, ’59’, ’61’, ’67’, ’71’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>First, we create an iterator that exists outside either of the two loops that we’ll use to create our sequence-of-sequences. The generator expression uses <span class="lstinline"><span style="color:#000000"><code class="inlineCode">tuple</code></span><span style="color:#000000"><code class="inlineCode">(</code></span><span style="color:#000000"><code class="inlineCode">next</code></span><span style="color:#000000"><code class="inlineCode">(</code></span><span style="color:#000000"><code class="inlineCode">flat_iter</code></span><span style="color:#000000"><code class="inlineCode">)</code></span><span style="color:#000000"><code class="inlineCode">for</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">i</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">in</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">range</code></span><span style="color:#000000"><code class="inlineCode">(5)</code></span><span style="color:#000000"><code class="inlineCode">)</code></span></span> to create five-item tuples from the iterable values in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">flat_iter</code></span></span> variable. This expression is nested inside another generator that repeats the inner loop the proper number of times to create the required sequence of values.</p>&#13;
<p>This works only when the flat list is divided evenly. If the last row has partial elements, we’ll need to process them separately.</p>&#13;
<p>We can use this kind of function to group data into same-sized tuples, with an odd-sized tuple at the end, using the following definitions:</p>&#13;
<pre id="listing-78" class="lstlisting"><code>from collections.abc import Sequence &#13;
from typing import TypeVar &#13;
 &#13;
ItemType = TypeVar("ItemType") &#13;
# Flat = Sequence[ItemType] &#13;
# Grouped = list[tuple[ItemType, ...]] &#13;
 &#13;
def group_by_seq(n: int, sequence: Sequence[ItemType]) -&gt; list[tuple[ItemType,...]]: &#13;
    flat_iter = iter(sequence) &#13;
    full_sized_items = list( &#13;
        tuple(next(flat_iter) for i in range(n)) &#13;
        for row in range(len(sequence) // n) &#13;
    ) &#13;
    trailer = tuple(flat_iter) &#13;
    if trailer: &#13;
        return full_sized_items +  [trailer] &#13;
    else: &#13;
        return full_sized_items</code></pre>&#13;
<p>Within the <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_by_seq()</code></span></span> function, an initial list is built and assigned to the variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">full_sized_items</code></span></span>. Each tuple in this list is of size <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>. If there are leftovers, the trailing items are used to build<span id="dx1-89039"/> a tuple with a non-zero length that we can append to the list of full-sized items. If the <span class="obeylines-h"><span class="verb"><code class="inlineCode">trailer</code></span></span> tuple is of the length zero, it can be safely ignored.</p>&#13;
<p>The type hints include a generic definition of <span class="obeylines-h"><span class="verb"><code class="inlineCode">ItemType</code></span></span> as a type variable. The intent of a type variable is to show that whatever type is an input to this function will be returned from the function. A sequence of strings or a sequence of floats would both work properly.</p>&#13;
<p>The input is summarized as a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Sequence</code></span></span> of items. The output is a <span class="obeylines-h"><span class="verb"><code class="inlineCode">List</code></span></span> of tuples of items. The items are all of a common type, described with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ItemType</code></span></span> type variable.</p>&#13;
<p>This isn’t as delightfully simple and functional-looking as other algorithms we’ve looked at. We can rework this into a simpler generator function that yields an iterable instead of a list.</p>&#13;
<p>The following code uses a <span class="obeylines-h"><span class="verb"><code class="inlineCode">while</code></span></span> statement as part of tail recursion optimization:</p>&#13;
<pre id="listing-79" class="lstlisting"><code>from collections.abc import Iterator &#13;
from typing import TypeVar &#13;
 &#13;
ItemT = TypeVar("ItemT") &#13;
 &#13;
def group_by_iter(n: int, iterable: Iterator[ItemT]) -&gt; Iterator[tuple[ItemT, ...]]: &#13;
    def group(n: int, iterable: Iterator[ItemT]) -&gt; Iterator[ItemT]: &#13;
        for i in range(n): &#13;
            try: &#13;
                yield next(iterable) &#13;
            except StopIteration: &#13;
                return &#13;
 &#13;
    while row := tuple(group(n, iterable)): &#13;
        yield row</code></pre>&#13;
<p>We’ve created a row of the required<span id="dx1-89055"/> length from the input iterable. At the end of the input iterable, the value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple(next(iterable)</code><code class="inlineCode"> for</code><code class="inlineCode"> i</code><code class="inlineCode"> in</code><code class="inlineCode"> range(n))</code></span></span> will be a zero-length tuple. This can be the base case of a recursive definition. This was manually optimized into the terminating condition of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">while</code></span></span> statement.</p>&#13;
<p>The walrus operator, <span class="obeylines-h"><span class="verb"><code class="inlineCode">:=</code></span></span>, is used to assign the result of the expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple(group(n,</code><code class="inlineCode"> iterable))</code></span></span> to a variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">row</code></span></span>. If this is a non-empty tuple, it will be the output from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code></span></span> statement. If this is an empty tuple, the loop will terminate.</p>&#13;
<p>The type hints have been modified to reflect the way this works with an iterator. These iteration processing techniques are not limited to sequences. Because the internal <span class="obeylines-h"><span class="verb"><code class="inlineCode">group()</code></span></span> function uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> explicitly, it has to be used like this: <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_by_iter(7,</code><code class="inlineCode"> iter(flat))</code></span></span>. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function must be used to create an iterator from a collection.</p>&#13;
<p>We can, as an alternative, use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function inside the <span class="obeylines-h"><span class="verb"><code class="inlineCode">group()</code></span></span> function. When presented with a collection, this will create a fresh, new iterator. When presented with an iterator, it will do nothing. This makes the function easier to use. <span id="x1-89056r95"/></p>&#13;
</section>&#13;
<section id="structuring-flat-sequences-an-alternative-approach" class="level4 subsectionHead" data-number="0.8.5.4">&#13;
<h4 class="subsectionHead" data-number="0.8.5.4"><span class="titlemark">4.5.4 </span> <span id="x1-900004"/>Structuring flat sequences – an alternative approach</h4>&#13;
<p>Let’s say we have a simple, flat list and we want to create non-overlapping pairs from this list. The following<span id="dx1-90001"/> is the data we have:</p>&#13;
<div id="tcolobox-84" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; flat = [’2’, ’3’, ’5’, ’7’, ’11’, ’13’, ’17’, ’19’, ’23’, ’29’, &#13;
...     ’31’, ’37’, ’41’, ’43’, ’47’, ’53’, ’59’, ’61’, ’67’, ’71’, &#13;
... ]</code></pre>&#13;
&#13;
</div>&#13;
<p>We can create pairs using list slices, as follows:</p>&#13;
<div id="tcolobox-85" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; pairs = list(zip(flat[0::2], flat[1::2])) &#13;
&gt;&gt;&gt; pairs[:3] &#13;
[(’2’, ’3’), (’5’, ’7’), (’11’, ’13’)] &#13;
&gt;&gt;&gt; pairs[-3:] &#13;
[(’47’, ’53’), (’59’, ’61’), (’67’, ’71’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>The slice <span class="obeylines-h"><span class="verb"><code class="inlineCode">flat[0::2]</code></span></span> is all of the even positions. The slice <span class="obeylines-h"><span class="verb"><code class="inlineCode">flat[1::2]</code></span></span> is all of the odd positions. If we zip these together, we get a two-tuple. The item at index <span class="obeylines-h"><span class="verb"><code class="inlineCode">[0]</code></span></span> is the value from the first even position, and then the item at index <span class="obeylines-h"><span class="verb"><code class="inlineCode">[1]</code></span></span> is the value from the first odd position. If the number of elements is even, this will produce pairs nicely. If the total number of items is odd, the final item will be dropped. This is a problem with a handy solution.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">list(zip(...))</code></span></span> expression has the advantage of being quite short. We can follow the approach in the previous section and define our own functions to solve the same problem.</p>&#13;
<p>We can also build a solution using Python’s built-in features. Specifically, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*(args)</code></span></span> approach to generate a sequence-of-sequences that must be zipped together. It looks like the following:</p>&#13;
<div id="tcolobox-86" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; n = 2 &#13;
&gt;&gt;&gt; pairs = list( &#13;
...     zip(*(flat [i::n] for i in range(n))) &#13;
... ) &#13;
&gt;&gt;&gt; pairs[:5] &#13;
[(’2’, ’3’), (’5’, ’7’), (’11’, ’13’), (’17’, ’19’), (’23’, ’29’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>This will generate n slices: <span class="obeylines-h"><span class="verb"><code class="inlineCode">flat[0::n],</code><code class="inlineCode"> flat[1::n],</code><code class="inlineCode"> flat[2::n]</code></span></span>, and so on, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">flat[n-1::n]</code></span></span>. This collection of slices becomes the arguments to <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span>, which then interleaves values from each slice.</p>&#13;
<p>Recall that <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> truncates the sequence<span id="dx1-90019"/> at the shortest list. This means that if the list is not an even multiple of the grouping factor, <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>, items will be dropped. When the list’s length, <span class="obeylines-h"><span class="verb"><code class="inlineCode">len(flat)</code></span></span>, isn’t a multiple of <span class="italic">n</span>, we’ll see <span class="obeylines-h"><span class="verb"><code class="inlineCode">len(flat)</code><code class="inlineCode"> %</code><code class="inlineCode"> n</code></span></span> is not zero; this will be the size of the final slice.</p>&#13;
<p>If we switch to using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.zip_longest()</code></span></span> function, then we’ll see that the final tuple will be padded with enough <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values to make it have a length of <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>.</p>&#13;
<p>We have two approaches to structuring a list into groups. We need to select the approach based on what will be done if the length of the list is not a multiple of the group size. We can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> to truncate or <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_longest()</code></span></span> to add a ”padding” constant to make the final group the expected size.</p>&#13;
<p>The list slicing approach to grouping data is another way to approach the problem of structuring a flat sequence of data into blocks. As it is a general solution, it doesn’t seem to offer too many advantages over the functions in the previous section. As a solution specialized for making two-tuples from a flat list, it’s elegantly simple. <span id="x1-90020r92"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="using-sorted-and-reversed-to-change-the-order" class="level3 sectionHead" data-number="0.8.6">&#13;
<h3 class="sectionHead" data-number="0.8.6"><span class="titlemark">4.6 </span> <span id="x1-910006"/>Using sorted() and reversed() to change the order</h3>&#13;
<p>Python’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> function<span id="dx1-91001"/> produces a new list by rearranging<span id="dx1-91002"/> the order of items in a list. This is similar to the way the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list.sort()</code></span></span> method changes the order of list.</p>&#13;
<p>Here’s the important distinction between <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted(aList)</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">aList.sort()</code></span></span>:</p>&#13;
<ul>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">aList.sort()</code></span></span> method modifies the <span class="obeylines-h"><span class="verb"><code class="inlineCode">aList</code></span></span> object. It can only be meaningfully applied to a <span class="obeylines-h"><span class="verb"><code class="inlineCode">list</code></span></span> object.</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted(aList)</code></span></span> function creates a new list from an existing collection of items. The source object is not changed. Further, a variety of collections can be sorted. A <span class="obeylines-h"><span class="verb"><code class="inlineCode">set</code></span></span> or the keys of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> can be put into order.</p></li>&#13;
</ul>&#13;
<p>There are times when we need a sequence<span id="dx1-91003"/> reversed. Python offers us two approaches to this: the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reversed()</code></span></span> function, and slices with reversed indices.</p>&#13;
<p>For example, consider performing<span id="dx1-91004"/> a base conversion to hexadecimal or binary. The following code is a simple conversion function:</p>&#13;
<pre id="listing-80" class="lstlisting"><code>from collections.abc import Iterator &#13;
 &#13;
def digits(x: int, base: int) -&gt; Iterator[int]: &#13;
    if x == 0: return &#13;
    yield x % base &#13;
    yield from digits(x // base, base)</code></pre>&#13;
<p>This function uses a recursion to yield the digits from the least significant to the most significant. The value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code><code class="inlineCode"> %</code><code class="inlineCode"> base</code></span></span> will be the least significant digits of <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span> in the base <span class="obeylines-h"><span class="verb"><code class="inlineCode">base</code></span></span>.</p>&#13;
<p>We can formalize it as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file44.jpg" class="math-display" alt=" (| {[] if x = 0 digits(x,b) = | x ([x mod b]+ digits(⌊b⌋,b) if x &gt; 0 "/>&#13;
</div>&#13;
<p>In Python, we can use a long name like <span class="obeylines-h"><span class="verb"><code class="inlineCode">base</code></span></span>. This is uncommon in conventional mathematics, so a single letter, <span class="italic">b</span>, is used.</p>&#13;
<p>In some cases, we’d prefer the digits to be yielded in the reverse order; most significant first. We can wrap this function with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reversed()</code></span></span> function to swap the order of the digits:</p>&#13;
<pre id="listing-81" class="lstlisting"><code>def to_base(x: int, base: int) -&gt; Iterator[int]: &#13;
    return reversed(tuple(digits(x, base)))</code></pre>&#13;
<div id="tcolobox-87" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">reversed()</code></span></span> function produces an iterable, but the argument value must be a collection object. The function then yields the items from that object in the reverse order. While a dictionary can be reversed, the operation is an iterator over the keys of the dictionary.</p>&#13;
&#13;
</div>&#13;
<p>We can do a similar<span id="dx1-91013"/> kind of thing with a slice, such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple(digits(x,</code><code class="inlineCode"> base))[::-1]</code></span></span>. The slice, however, is not an iterator. A slice is a materialized object built from another materialized<span id="dx1-91014"/> object. In this case, for such small collections of values, the allocation of extra memory for the slice is minor. As the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reversed()</code></span></span> function uses less memory than creating slices, it can be advantageous for working with larger collections.</p>&#13;
<div id="tcolobox-88" class="packt_tip">&#13;
&#13;
&#13;
<p>The ”Martian Smiley”, <span class="obeylines-h"><span class="verb"><code class="inlineCode">[:]</code></span></span>, is an edge case for slicing. The expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">some_list[:]</code></span></span> is a copy of the list made by taking a slice that includes all the items in order.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-91015r97"/></p>&#13;
</section>&#13;
<section id="using-enumerate-to-include-a-sequence-number" class="level3 sectionHead" data-number="0.8.7">&#13;
<h3 class="sectionHead" data-number="0.8.7"><span class="titlemark">4.7 </span> <span id="x1-920007"/>Using enumerate() to include a sequence number</h3>&#13;
<p>Python offers the <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function to apply index information to values in a sequence or iterable. It performs<span id="dx1-92001"/> a specialized kind of wrap that can be used as part of an <span class="obeylines-h"><span class="verb"><code class="inlineCode">unwrap(process(wrap(data)))</code></span></span> design pattern.</p>&#13;
<p>It looks like the following code snippet:</p>&#13;
<div id="tcolobox-89" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; xi[:3] &#13;
[1.47, 1.5, 1.52] &#13;
&gt;&gt;&gt; len(xi) &#13;
15 &#13;
 &#13;
&gt;&gt;&gt; id_values = list(enumerate(xi)) &#13;
&gt;&gt;&gt; id_values[:3] &#13;
[(0, 1.47), (1, 1.5), (2, 1.52)] &#13;
&gt;&gt;&gt; len(id_values) &#13;
15</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function transformed each input item into a pair with a sequence number and the original item. It’s similar to the following:</p>&#13;
<pre id="listing-82" class="lstlisting"><code>zip(range(len(source)), source)</code></pre>&#13;
<p>An important<span id="dx1-92014"/> feature of <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> is that the result is an iterable and it works with any iterable input.</p>&#13;
<p>When looking at statistical processing, for example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function comes in handy to transform a single sequence of values into a more proper time series by prefixing each sample with a number. <span id="x1-92015r98"/></p>&#13;
</section>&#13;
<section id="summary-3" class="level3 sectionHead" data-number="0.8.8">&#13;
<h3 class="sectionHead" data-number="0.8.8"><span class="titlemark">4.8 </span> <span id="x1-930008"/>Summary</h3>&#13;
<p>In this chapter, we saw detailed ways to use a number of built-in reductions.</p>&#13;
<p>We’ve used <span class="obeylines-h"><span class="verb"><code class="inlineCode">any()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span> to do essential logic processing. These are tidy examples of reductions using a simple operator, such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">or</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">and</code></span></span>. We’ve also looked at numeric reductions such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span>. We’ve applied these functions to create some higher-order statistical processing. We’ll return to these reductions in <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and Reductions</span></a>.</p>&#13;
<p>We’ve also looked at some of the built-in mappings. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function merges multiple sequences. This leads us to look at using this in the context of structuring and flattening more complex data structures. As we’ll see in examples in later chapters, nested data is helpful in some situations and flat data is helpful in others. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function maps an iterable to a sequence of two-tuples. Each two-tuple has the sequence number at index <span class="obeylines-h"><span class="verb"><code class="inlineCode">[0]</code></span></span> and the original value at index <span class="obeylines-h"><span class="verb"><code class="inlineCode">[1]</code></span></span>.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">reversed()</code></span></span> function iterates over the items in a sequence object, with their original order reversed. Some algorithms are more efficient at producing results in one order, but we’d like to present these results in the opposite order. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> function imposes an order either based on the direct comparisons of objects, or by using a key function to compare a derived value of each object.</p>&#13;
<p>In the next chapter, we’ll look at the mapping and reduction functions that use an additional function as an argument to customize their processing. Functions that accept a function as an argument are our first examples of higher-order functions. We’ll also touch on functions that return functions as a result. <span id="x1-93001r99"/></p>&#13;
</section>&#13;
<section id="exercises-3" class="level3 sectionHead" data-number="0.8.9">&#13;
<h3 class="sectionHead" data-number="0.8.9"><span class="titlemark">4.9 </span> <span id="x1-940009"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-94001r96"/></p>&#13;
<section id="palindromic-numbers" class="level4 subsectionHead" data-number="0.8.9.1">&#13;
<h4 class="subsectionHead" data-number="0.8.9.1"><span class="titlemark">4.9.1 </span> <span id="x1-950001"/>Palindromic numbers</h4>&#13;
<p>See Project Euler problem number 4, <a href="https://projecteuler.net/problem=4" class="url">https://projecteuler.net/problem=4</a>. The idea here is to locate a number that has a specific property. In this exercise, we want to look at the question of a number being (or not being) a palindrome.</p>&#13;
<p>One way to handle this is to decompose a number into a sequence of decimal digits. We can then examine the sequence of decimal digits to see if it forms a proper palindrome.</p>&#13;
<p>See the <a href="#x1-910006"><span class="cmti-10x-x-109">Using sorted() and reversed() to change the order</span></a> section for a snippet of code to extract digits in base 10 from a given number. Do we need the digits in the conventional order of most-significant digits first? Does it matter if the digits are generated in reverse order?</p>&#13;
<p>We can leverage this function in two separate ways to check for a palindrome:</p>&#13;
<ul>&#13;
<li><p>Compare positions within a sequence of digits, <span class="obeylines-h"><span class="verb"><code class="inlineCode">d[0]</code><code class="inlineCode"> ==</code><code class="inlineCode"> d[-1]</code></span></span>. We only need to compare the first half of the digits with the second half. Be sure your algorithm handles an odd number of digits correctly.</p></li>&#13;
<li><p>Use <span class="obeylines-h"><span class="verb"><code class="inlineCode">reversed()</code></span></span> to create a second sequence of digits and compare the two sequences. This is waste of time and memory, but may be easier to understand.</p></li>&#13;
</ul>&#13;
<p>Implement both alternatives and compare the resulting code for clarity and expressiveness. <span id="x1-95001r101"/></p>&#13;
</section>&#13;
<section id="hands-of-cards" class="level4 subsectionHead" data-number="0.8.9.2">&#13;
<h4 class="subsectionHead" data-number="0.8.9.2"><span class="titlemark">4.9.2 </span> <span id="x1-960002"/>Hands of cards</h4>&#13;
<p>Given five cards, there are a number of ways the five cards form groups. The full set of hands for a game like poker is fairly complex. A simplified set of hands, however, provides a tool for establishing whether data is random or not. Here are the hand types we are interested in:</p>&#13;
<ol>&#13;
<li><div id="x1-96002x1">&#13;
<p>All five cards match.</p>&#13;
</div></li>&#13;
<li><div id="x1-96004x2">&#13;
<p>Four of the five cards match.</p>&#13;
</div></li>&#13;
<li><div id="x1-96006x3">&#13;
<p>Three of the five cards match. Unlike poker, we’ll ignore whether or not the other two cards match.</p>&#13;
</div></li>&#13;
<li><div id="x1-96008x4">&#13;
<p>There are two separate matching pairs.</p>&#13;
</div></li>&#13;
<li><div id="x1-96010x5">&#13;
<p>Two cards match, forming a single pair.</p>&#13;
</div></li>&#13;
<li><div id="x1-96012x6">&#13;
<p>No cards match.</p>&#13;
</div></li>&#13;
</ol>&#13;
<p>For truly random data, the probabilities can be computed with some clever math. A good random number generator allows us to build a simulation that provides expected values.</p>&#13;
<p>To get started, we need a function to distinguish which flavor of hand is represented by five random values in the domain 1 to 13 (inclusive). The input is a list of five values. The output should be a numeric code for which of the six kinds of hands has been found.</p>&#13;
<p>The broad outline of this function is the following:</p>&#13;
<div class="algorithm">&#13;
<figure>&#13;
<img src="../Images/Algo_4.1.JPG" class="frac" data-align="middle" alt="Algorithm 4: Imperative iteration "/>&#13;
&#13;
</figure>&#13;
</div>&#13;
<p><span class="keyWord">Hint</span>: For the more general poker-hand identification, it can help to sort the values into ascending order. For this simplified algorithm, it helps to convert the list into a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter</code></span></span> object and examine the frequencies of the various card ranks. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter</code></span></span> class is defined in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections</code></span></span> module with many other useful collection classes.</p>&#13;
<p>Each of the hands can be recognized by a function of the form:</p>&#13;
<pre id="listing-83" class="lstlisting"><code>    def hand_flavor(cards: Sequence[int]) -&gt; bool: &#13;
        examine the cards</code></pre>&#13;
<p>This lets us write each individual hand-detection algorithm separately. We can then test them in isolation. This gives us confidence the overall hand classifier will work. It means you’ll need to write test cases on the individual classifiers to be sure they work properly. <span id="x1-96017r102"/></p>&#13;
</section>&#13;
<section id="replace-legs-with-pairwise" class="level4 subsectionHead" data-number="0.8.9.3">&#13;
<h4 class="subsectionHead" data-number="0.8.9.3"><span class="titlemark">4.9.3 </span> <span id="x1-970003"/>Replace legs() with pairwise()</h4>&#13;
<p>In the <a href="#x1-790003"><span class="cmti-10x-x-109">Pairing up items from a sequence</span></a> section, we looked at the design for a <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function to create pairs of legs from a sequence of waypoints.</p>&#13;
<p>This function can be replaced with <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.pairwise()</code></span></span>. After making this change, determine which implementation is faster. <span id="x1-97001r104"/></p>&#13;
</section>&#13;
<section id="expand-legs-to-include-processing" class="level4 subsectionHead" data-number="0.8.9.4">&#13;
<h4 class="subsectionHead" data-number="0.8.9.4"><span class="titlemark">4.9.4 </span> <span id="x1-980004"/>Expand legs() to include processing</h4>&#13;
<p>In the <a href="#x1-790003"><span class="cmti-10x-x-109">Pairing up items from a sequence</span></a> section, we looked at the design for a <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function to create pairs of legs from a sequence of waypoints.</p>&#13;
<p>A design alternative is to incorporate a function into the processing of <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> to perform a computation on each pair that’s created.</p>&#13;
<p>The function might look the following:</p>&#13;
<pre id="listing-84" class="lstlisting"><code>RT = TypeVar("RT") &#13;
 &#13;
def legs(transform: Callable[[LL_Type, LL_Type], RT], lat_lon_iter: Iterator[LL_Type]) -&gt; Iterator[RT]: &#13;
    begin = next(lat_lon_iter) &#13;
    for end in lat_lon_iter: &#13;
        yield transform(begin, end) &#13;
        begin = end</code></pre>&#13;
<p>This changes the design of subsequent examples. Follow this design change through subsequent examples to see if this leads to simpler, easier-to-understand Python function definitions.</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-4" class="level3 likesectionHead" data-number="0.8.10">&#13;
<h3 class="likesectionHead" data-number="0.8.10"><span id="x1-990004"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/> <span id="x1-99001r80"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>