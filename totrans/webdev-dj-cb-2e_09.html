<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Data Import and Export</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Importing data from a local CSV file</li><li class="listitem" style="list-style-type: disc">Importing data from a local Excel file</li><li class="listitem" style="list-style-type: disc">Importing data from an external JSON file</li><li class="listitem" style="list-style-type: disc">Importing data from an external XML file</li><li class="listitem" style="list-style-type: disc">Creating filterable RSS feeds</li><li class="listitem" style="list-style-type: disc">Using Tastypie to create API</li><li class="listitem" style="list-style-type: disc">Using Django REST framework to create API</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Introduction</h1></div></div></div><p>There are times when your data needs to be transported from a local format to the database, imported from external resources, or provided to third parties. In this chapter, we will take a look at some practical examples of how to write management commands and APIs to do this.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Importing data from a local CSV file</h1></div></div></div><p>The <strong>comma-separated values</strong> (<strong>CSV</strong>) format is probably the simplest way to store tabular <a class="indexterm" id="id440"/>data in a text file. In this recipe, we will <a class="indexterm" id="id441"/>create a management command that imports data<a class="indexterm" id="id442"/> from CSV to a Django database. We will need a CSV list of movies with a title, URL, and release year. You can easily create such files with Excel, Calc, or another spreadsheet application.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec285"/>Getting ready</h2></div></div></div><p>Create a <code class="literal">movies</code> app with the <code class="literal">Movie</code> model containing the following fields: <code class="literal">title</code>, <code class="literal">url</code>, and <code class="literal">release_year</code>. Place the app under <code class="literal">INSTALLED_APPS</code> in the settings.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec286"/>How to do it...</h2></div></div></div><p>Follow these<a class="indexterm" id="id443"/> steps to create and use a management<a class="indexterm" id="id444"/> command that imports movies from a local CSV file:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">movies</code> app, create a <code class="literal">management</code> directory and then a <code class="literal">commands</code> directory in the new <code class="literal">management</code> directory. Put the empty <code class="literal">__init__.py</code> files in both new directories to make them Python packages.</li><li class="listitem">Add an <code class="literal">import_movies_from_csv.py</code> file there with the following content:<div><pre class="programlisting">
<strong># movies/management/commands/import_movies_from_csv.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import csv
from django.core.management.base import BaseCommand
from movies.models import Movie

SILENT, NORMAL, VERBOSE, VERY_VERBOSE = 0, 1, 2, 3

class Command(BaseCommand):
    help = (
        "Imports movies from a local CSV file. "
        "Expects title, URL, and release year."
    )

    def add_arguments(self, parser):
        # Positional arguments
        parser.add_argument(
            "file_path",
            nargs=1,
            type=unicode,
        )

    def handle(self, *args, **options):
        verbosity = options.get("verbosity", NORMAL)
        file_path = options["file_path"][0]

        if verbosity &gt;= NORMAL:
            self.stdout.write("=== Movies imported ===")

        with open(file_path) as f:
            reader = csv.reader(f)
            for rownum, (title, url, release_year) in \
            enumerate(reader):
                if rownum == 0:
                    # let's skip the column captions
                    continue
                movie, created = \
                Movie.objects.get_or_create(
                    title=title,
                    url=url,
                    release_year=release_year,
                )
                if verbosity &gt;= NORMAL:
                    self.stdout.write("{}. {}".format(
                        rownum, movie.title
                    ))</pre></div></li><li class="listitem">To run the import,  call the following in the command line:<div><pre class="programlisting">
<strong>(myproject_env)$ python manage.py import_movies_from_csv \</strong>
<strong>data/movies.csv</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec287"/>How it works...</h2></div></div></div><p>For a <a class="indexterm" id="id445"/>management command, we need to create<a class="indexterm" id="id446"/> a <code class="literal">Command</code> class deriving from <code class="literal">BaseCommand</code> and overwriting the <code class="literal">add_arguments()</code> and <code class="literal">handle()</code> method. The <code class="literal">help</code> attribute defines the help text for the management command. It can be seen when you type the following in the command line:</p><div><pre class="programlisting">
<strong>(myproject_env)$ python manage.py help import_movies_from_csv</strong>
</pre></div><p>Django management commands use the built-in argparse module to parse the passed arguments. The <code class="literal">add_arguments()</code> method defines what positional or named arguments should be <a class="indexterm" id="id447"/>passed to the management command. In our case, we will add a positional <code class="literal">file_path</code> argument of Unicode type. By <code class="literal">nargs</code> set to the <code class="literal">1</code> attribute, we allow only one value. To learn about the other arguments that you can define<a class="indexterm" id="id448"/> and how to do this, refer to the official argparse documentation at <a class="ulink" href="https://docs.python.org/2/library/argparse.html#the-add-argument-method">https://docs.python.org/2/library/argparse.html#the-add-argument-method</a>.</p><p>At the beginning of the <code class="literal">handle()</code> method, the <code class="literal">verbosity</code> argument is checked. Verbosity defines how verbose the command is, from <code class="literal">0</code> not giving any output to the command-line tool to <code class="literal">3</code> being very verbose. You can pass this argument to the command as follows:</p><div><pre class="programlisting">
<strong>(myproject_env)$ python manage.py import_movies_from_csv \</strong>
<strong>data/movies.csv --verbosity=0</strong>
</pre></div><p>Then, we also expect the filename as the first positional argument. The <code class="literal">options["file_path"]</code> returns a list of the values defined in the nargs, therefore, it is one value in this case.</p><p>We <a class="indexterm" id="id449"/>open the given file and pass its pointer to <code class="literal">csv.reader</code>. Then, for each line in the file, we will create a new <code class="literal">Movie</code> object if a matching<a class="indexterm" id="id450"/> movie doesn't exist yet. The management command will print out the imported movie titles to the console, unless you set the verbosity to <code class="literal">0</code>.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>If you want to debug the errors of a management command while developing it, pass the <code class="literal">--traceback</code> parameter for it. If an error occurs, you will see the full stack trace of the problem.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec288"/>There's more...</h2></div></div></div><p>You can<a class="indexterm" id="id451"/> learn more about the CSV library from the official documentation at <a class="ulink" href="https://docs.python.org/2/library/csv.html">https://docs.python.org/2/library/csv.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec289"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Importing data from a local Excel file</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Importing data from a local Excel file</h1></div></div></div><p>Another <a class="indexterm" id="id452"/>popular format to store tabular data is an Excel spread <a class="indexterm" id="id453"/>sheet. In this recipe, we will import movies from a file of this format.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec290"/>Getting ready</h2></div></div></div><p>Let's start with the <code class="literal">movies</code> app that we created in the previous recipe. Install the <code class="literal">xlrd</code> package to read Excel files, as follows:</p><div><pre class="programlisting">
<strong>(project_env)$ pip install xlrd</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec291"/>How to do it...</h2></div></div></div><p>Follow these steps to create and use a management command that imports movies from a local XLS file:</p><div><ol class="orderedlist arabic"><li class="listitem">If you <a class="indexterm" id="id454"/>haven't done that, in the <code class="literal">movies</code> app, create a <code class="literal">management</code> directory and then a <code class="literal">commands</code> directory in the<a class="indexterm" id="id455"/> new <code class="literal">management</code> directory. Put the empty <code class="literal">__init__.py</code> files in both the new directories to make them Python packages.</li><li class="listitem">Add the <code class="literal">import_movies_from_xls.py</code> file with the following content:<div><pre class="programlisting">
<strong># movies/management/commands/import_movies_from_xls.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import xlrd
from django.utils.six.moves import range
from django.core.management.base import BaseCommand
from movies.models import Movie

SILENT, NORMAL, VERBOSE, VERY_VERBOSE = 0, 1, 2, 3

class Command(BaseCommand):
    help = (
        "Imports movies from a local XLS file. "
        "Expects title, URL, and release year."
    )

    def add_arguments(self, parser):
        # Positional arguments
        parser.add_argument(
            "file_path",
            nargs=1,
            type=unicode,
        )

    def handle(self, *args, **options):
        verbosity = options.get("verbosity", NORMAL)
        file_path = options["file_path"][0]

        wb = xlrd.open_workbook(file_path)
        sh = wb.sheet_by_index(0)

        if verbosity &gt;= NORMAL:
            self.stdout.write("=== Movies imported ===")
        for rownum in range(sh.nrows):
            if rownum == 0:
                # let's skip the column captions
                continue
            (title, url, release_year) = \
                sh.row_values(rownum)
            movie, created = Movie.objects.get_or_create(
                title=title,
                url=url,
                release_year=release_year,
            )
            if verbosity &gt;= NORMAL:
                self.stdout.write("{}. {}".format(
                    rownum, movie.title
                ))</pre></div></li><li class="listitem">To run the import, call the following in the command line:<div><pre class="programlisting">
<strong>(myproject_env)$ python manage.py import_movies_from_xls \</strong>
<strong>data/movies.xls</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec292"/>How it works...</h2></div></div></div><p>The<a class="indexterm" id="id456"/> principle of importing from an XLS file is the<a class="indexterm" id="id457"/> same as with CSV. We open the file, read it row by row, and create the <code class="literal">Movie</code> objects from the provided data. A detailed explanation is as follows.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Excel files are workbooks containing sheets as different tabs.</li><li class="listitem" style="list-style-type: disc">We are using the <code class="literal">xlrd</code> library to open a file passed as a positional argument to the command. Then, we will read the first sheet from the workbook.</li><li class="listitem" style="list-style-type: disc">Afterwards, we will read the rows one by one (except the first row with the column titles) and create the <code class="literal">Movie</code> objects from them. Once again, the management command will print out the imported movie titles to the console, unless you set the verbosity to <code class="literal">0</code>.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec293"/>There's more...</h2></div></div></div><p>You can learn more about how to<a class="indexterm" id="id458"/> work with Excel files at <a class="ulink" href="http://www.python-excel.org/">http://www.python-excel.org/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec294"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Importing data from a local CSV file</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec87"/>Importing data from an external JSON file</h1></div></div></div><p>The <code class="literal">Last.fm</code> music website has an API under the <a class="ulink" href="http://ws.audioscrobbler.com/">http://ws.audioscrobbler.com/</a> domain<a class="indexterm" id="id459"/> that you can use to read the albums, artists, tracks, events, and more. The API allows you to either use the JSON or XML<a class="indexterm" id="id460"/> format. In this recipe, we will import the top tracks tagged disco using the JSON format.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec295"/>Getting ready</h2></div></div></div><p>Follow these steps in order to import data in the JSON format from <code class="literal">Last.fm</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">To use <code class="literal">Last.fm</code>, you need to <a class="indexterm" id="id461"/>register and get an API key. The API key can be created at <a class="ulink" href="http://www.last.fm/api/account/create">http://www.last.fm/api/account/create</a>.</li><li class="listitem">The API key has to be set in the settings as <code class="literal">LAST_FM_API_KEY</code>.</li><li class="listitem">Also, install the <code class="literal">requests</code> library in your virtual environment using the following command:<div><pre class="programlisting">
<strong>(myproject_env)$ pip install requests</strong>
</pre></div></li><li class="listitem">Let's check<a class="indexterm" id="id462"/> the structure of the JSON endpoint (<a class="ulink" href="http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&amp;tag=disco&amp;api_key=xxx&amp;format=json">http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&amp;tag=disco&amp;api_key=xxx&amp;format=json</a>):<div><pre class="programlisting">{
  "tracks":{
<strong>    "track":[</strong>
      {
<strong>        "name":"Billie Jean",</strong>
        "duration":"293",
        "mbid":"f980fc14-e29b-481d-ad3a-5ed9b4ab6340",
        <strong>"url":"http://www.last.fm/music/Michael+Jackson/_/Billie+Jean",</strong>
        "streamable":{
          "#text":"0",
          "fulltrack":"0"
        },
<strong>        "artist":{</strong>
<strong>          "name":"Michael Jackson",</strong>
          "mbid":"f27ec8db-af05-4f36-916e-3d57f91ecf5e",
          "url":"http://www.last.fm/music/Michael+Jackson"
        },
        "image":[
          {
            "#text":"http://img2-ak.lst.fm/i/u/34s/114a4599f3bd451ca915f482345bc70f.png",
            "size":"small"
          },
<strong>          {</strong>
<strong>            "#text":"http://img2-ak.lst.fm/i/u/64s/114a4599f3bd451ca915f482345bc70f.png",</strong>
<strong>            "size":"medium"</strong>
<strong>          },</strong>
          {
            "#text":"http://img2-ak.lst.fm/i/u/174s/114a4599f3bd451ca915f482345bc70f.png",
            "size":"large"
          },
          {
            "#text":"http://img2-ak.lst.fm/i/u/300x300/114a4599f3bd451ca915f482345bc70f.png",
            "size":"extralarge"
          }
        ],
        "@attr":{
          "rank":"1"
        }
      },
      ...
    ],
    "@attr":{
      "tag":"disco",
      "page":"1",
      "perPage":"50",
<strong>      "totalPages":"26205",</strong>
      "total":"1310249"
    }
  }
}</pre></div></li></ol></div><p>We <a class="indexterm" id="id463"/>want to read the track name, artist, URL, and<a class="indexterm" id="id464"/> medium-sized images.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec296"/>How to do it...</h2></div></div></div><p>Follow these steps to create a <code class="literal">Track</code> model and management command, which imports top tracks from <code class="literal">Last.fm</code> to the database:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's create a <code class="literal">music</code> app with a simple <code class="literal">Track</code> model, as follows:<div><pre class="programlisting">
<strong># music/models.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import os
from django.utils.translation import ugettext_lazy as _
from django.db import models
from django.utils.text import slugify
from django.utils.encoding import \
    python_2_unicode_compatible

def upload_to(instance, filename):
    filename_base, filename_ext = \
        os.path.splitext(filename)
    return "tracks/%s--%s%s" % (
        slugify(instance.artist),
        slugify(instance.name),
        filename_ext.lower(),
    )

@python_2_unicode_compatible
class Track(models.Model):
    name = models.CharField(_("Name"), max_length=250)
    artist = models.CharField(_("Artist"), max_length=250)
    url = models.URLField(_("URL"))
    image = models.ImageField(_("Image"),
        upload_to=upload_to, blank=True, null=True)

    class Meta:
        verbose_name = _("Track")
        verbose_name_plural = _("Tracks")

    def __str__(self):
        return "%s - %s" % (self.artist, self.name)</pre></div></li><li class="listitem">Then, create<a class="indexterm" id="id465"/> the management<a class="indexterm" id="id466"/> command as shown in the following:<div><pre class="programlisting">
<strong># music/management/commands/import_music_from_lastfm_as_json.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import os
import requests
from StringIO import StringIO
from django.utils.six.moves import range
from django.core.management.base import BaseCommand
from django.utils.encoding import force_text
from django.conf import settings
from django.core.files import File
from music.models import Track

SILENT, NORMAL, VERBOSE, VERY_VERBOSE = 0, 1, 2, 3

class Command(BaseCommand):
    help = "Imports top tracks from last.fm as XML."

    def add_arguments(self, parser):
        # Named (optional) arguments
        parser.add_argument(
            "--max_pages",
            type=int,
            default=0,
        )

    def handle(self, *args, **options):
        self.verbosity = options.get("verbosity", NORMAL)
        max_pages = options["max_pages"]

        params = {
            "method": "tag.gettoptracks",
            "tag": "disco",
            "api_key": settings.LAST_FM_API_KEY,
            "format": "json",
        }

        r = requests.get(
            "http://ws.audioscrobbler.com/2.0/",
            params=params
        )

        response_dict = r.json()
        total_pages = int(
            response_dict["tracks"]["@attr"]["totalPages"]
        )
        if max_pages &gt; 0:
            total_pages = max_pages

        if self.verbosity &gt;= NORMAL:
            self.stdout.write("=== Tracks imported ===")

        self.save_page(response_dict)
        for page_number in range(2, total_pages + 1):
            params["page"] = page_number
            r = requests.get(
                "http://ws.audioscrobbler.com/2.0/",
                params=params
            )
            response_dict = r.json()
            self.save_page(response_dict)</pre></div></li><li class="listitem">As the<a class="indexterm" id="id467"/> list is paginated, we will <a class="indexterm" id="id468"/>add the <code class="literal">save_page()</code> method to the <code class="literal">Command</code> class to save a single page of tracks. This method takes the dictionary with the top tracks from a single page as a parameter, as follows:<div><pre class="programlisting">    def save_page(self, d):
        for track_dict in d["tracks"]["track"]:
            track, created = Track.objects.get_or_create(
                name=force_text(track_dict["name"]),
                artist=force_text(
                    track_dict["artist"]["name"]
                ),
                url=force_text(track_dict["url"]),
            )
            image_dict = track_dict.get("image", None)
            if created and image_dict:
                image_url = image_dict[1]["#text"]
                image_response = requests.get(image_url)
                track.image.save(
                    os.path.basename(image_url),
                    File(StringIO(image_response.content))
                )
            if self.verbosity &gt;= NORMAL:
                self.stdout.write(" - {} - {}".format(
                    track.artist, track.name
                ))</pre></div></li><li class="listitem">To run the import, call the following in the command line:<div><pre class="programlisting">
<strong>(myproject_env)$ python manage.py \</strong>
<strong>import_music_from_lastfm_as_json --max_pages=3</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec297"/>How it works...</h2></div></div></div><p>The optional named <code class="literal">max_pages</code> argument limits the imported data to three pages. Just skip it if you want to download all the available top tracks; however, beware that there are above 26,000 pages as detailed in the <code class="literal">totalPages</code> value and this will take a while.</p><p>Using the <code class="literal">requests.get()</code> method, we read the data from <code class="literal">Last.fm</code>, passing the <code class="literal">params</code> query parameters. The response object has a built-in method called <code class="literal">json()</code>, which converts a JSON string and returns a parsed dictionary.</p><p>We read the total pages value from this dictionary and then save the first page of results. Then, we get the second and later pages one by one and save them. One interesting part in the<a class="indexterm" id="id469"/> import is downloading and saving the<a class="indexterm" id="id470"/> image. Here, we also use <code class="literal">request.get()</code> to retrieve the image data and then we pass it to <code class="literal">File</code> through <code class="literal">StringIO</code>, which is accordingly used in the <code class="literal">image.save()</code> method. The first parameter of <code class="literal">image.save()</code> is a filename that will be overwritten anyway by the value from the <code class="literal">upload_to</code> function and is necessary only for the file extension.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec298"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Importing data from an external XML file</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec88"/>Importing data from an external XML file</h1></div></div></div><p>The<code class="literal"> Last.fm</code> file also allows you to take data from their services in XML format. In this recipe, I<a class="indexterm" id="id471"/> will show you how to do this.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec299"/>Getting ready</h2></div></div></div><p>To prepare<a class="indexterm" id="id472"/> importing top tracks from <code class="literal">Last.fm</code> in the XML format, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start with the first three steps from the <em>Getting ready</em> section in the <em>Importing data from an external JSON file</em> recipe.</li><li class="listitem">Then, let's check the structure of the XML endpoint (<a class="ulink" href="http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&amp;tag=disco&amp;api_key=xxx&amp;format=xml">http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&amp;tag=disco&amp;api_key=xxx&amp;format=xml</a>), as follows:<div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;lfm status="ok"&gt;
  &lt;tracks tag="disco" page="1" perPage="50" <strong>totalPages="26205" total="1310249"&gt;</strong>
<strong>    &lt;track rank="1"&gt;</strong>
<strong>      &lt;name&gt;Billie Jean&lt;/name&gt;</strong>
      &lt;duration&gt;293&lt;/duration&gt;
      &lt;mbid&gt;f980fc14-e29b-481d-ad3a-5ed9b4ab6340&lt;/mbid&gt;
      <strong>&lt;url&gt;http://www.last.fm/music/Michael+Jackson/_/Billie+Jean&lt;/url&gt;</strong>
      &lt;streamable fulltrack="0"&gt;0&lt;/streamable&gt;
<strong>      &lt;artist&gt;</strong>
<strong>        &lt;name&gt;Michael Jackson&lt;/name&gt;</strong>
        &lt;mbid&gt;f27ec8db-af05-4f36-916e-3d57f91ecf5e&lt;/mbid&gt;
        &lt;url&gt;http://www.last.fm/music/Michael+Jackson&lt;/url&gt;
      &lt;/artist&gt;
      &lt;image size="small"&gt;http://img2-ak.lst.fm/i/u/34s/114a4599f3bd451ca915f482345bc70f.png&lt;/image&gt;
<strong>      &lt;image size="medium"&gt;http://img2-ak.lst.fm/i/u/64s/114a4599f3bd451ca915f482345bc70f.png&lt;/image&gt;</strong>
      &lt;image size="large"&gt;http://img2-ak.lst.fm/i/u/174s/114a4599f3bd451ca915f482345bc70f.png&lt;/image&gt;
      &lt;image size="extralarge"&gt;http://img2-ak.lst.fm/i/u/300x300/114a4599f3bd451ca915f482345bc70f.png&lt;/image&gt;
    &lt;/track&gt;
    ...
  &lt;/tracks&gt;
&lt;/lfm&gt;</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec300"/>How to do it...</h2></div></div></div><p>Execute the<a class="indexterm" id="id473"/> following steps one by one to import<a class="indexterm" id="id474"/> the top tracks from <code class="literal">Last.fm</code> in the XML format:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">music</code> app with a <code class="literal">Track</code> model similar to the previous recipe, if you've not already done this.</li><li class="listitem">Then, create an <code class="literal">import_music_from_lastfm_as_xml.py</code> management command. We will be using the <code class="literal">ElementTree</code> XML API that comes with Python to parse the XML nodes, as follows:<div><pre class="programlisting">
<strong># music/management/commands/import_music_from_lastfm_as_xml.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import os
import requests
from xml.etree import ElementTree
from StringIO import StringIO
from django.utils.six.moves import range
from django.core.management.base import BaseCommand
from django.utils.encoding import force_text
from django.conf import settings
from django.core.files import File
from music.models import Track

SILENT, NORMAL, VERBOSE, VERY_VERBOSE = 0, 1, 2, 3

class Command(BaseCommand):
    help = "Imports top tracks from last.fm as XML."

    def add_arguments(self, parser):
        # Named (optional) arguments
        parser.add_argument(
            "--max_pages",
            type=int,
            default=0,
        )

    def handle(self, *args, **options):
        self.verbosity = options.get("verbosity", NORMAL)
        max_pages = options["max_pages"]

        params = {
            "method": "tag.gettoptracks",
            "tag": "disco",
            "api_key": settings.LAST_FM_API_KEY,
            "format": "xml",
        }

        r = requests.get(
            "http://ws.audioscrobbler.com/2.0/",
            params=params
        )

        root = ElementTree.fromstring(r.content)
        total_pages = int(
            root.find("tracks").attrib["totalPages"]
        )
        if max_pages &gt; 0:
            total_pages = max_pages

        if self.verbosity &gt;= NORMAL:
            self.stdout.write("=== Tracks imported ===")

        self.save_page(root)
        for page_number in range(2, total_pages + 1):
            params["page"] = page_number
            r = requests.get(
                "http://ws.audioscrobbler.com/2.0/",
                params=params
            )
            root = ElementTree.fromstring(r.content)
            self.save_page(root)</pre></div></li><li class="listitem">As the list is paginated, we will add a <code class="literal">save_page()</code> method to the <code class="literal">Command</code> class to <a class="indexterm" id="id475"/>save a single page of tracks. This<a class="indexterm" id="id476"/> method takes the root node of the XML as a parameter, as shown in the following:<div><pre class="programlisting">    def save_page(self, root):
        for track_node in root.findall("tracks/track"):
            track, created = Track.objects.get_or_create(
                name=force_text(
                    track_node.find("name").text
                ),
                artist=force_text(
                    track_node.find("artist/name").text
                ),
                url=force_text(
                    track_node.find("url").text
                ),
            )
            image_node = track_node.find(
                "image[@size='medium']"
            )
            if created and image_node is not None:
                image_response = \
                    requests.get(image_node.text)
                track.image.save(
                    os.path.basename(image_node.text),
                    File(StringIO(image_response.content))
                )
            if self.verbosity &gt;= NORMAL:
                self.stdout.write(" - {} - {}".format(
                    track.artist, track.name
                ))</pre></div></li><li class="listitem">To run the import, call the following in the command line:<div><pre class="programlisting">
<strong>(myproject_env)$ python manage.py \</strong>
<strong>import_music_from_lastfm_as_xml --max_pages=3</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec301"/>How it works...</h2></div></div></div><p>The process is analogous to the JSON approach. Using the <code class="literal">requests.get()</code> method, we read the data from <code class="literal">Last.fm</code>, passing the query parameters as <code class="literal">params</code>. The XML content of the response is passed to the <code class="literal">ElementTree</code> parser and the root node is returned.</p><p>The <code class="literal">ElementTree</code> nodes have the <code class="literal">find()</code> and <code class="literal">findall()</code> methods, where you can pass XPath queries to filter out specific subnodes.</p><p>The following<a class="indexterm" id="id477"/> is a table of the available XPath<a class="indexterm" id="id478"/> syntax supported by <code class="literal">ElementTree</code>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>XPath Syntax Component</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">tag</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id479"/>selects all the child elements with the given tag.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">*</code></p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id480"/> selects all the child elements.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">.</code></p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id481"/> selects the current node.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">//</code></p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id482"/> selects all the subelements on all the levels beneath the current element.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">..</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id483"/>selects the parent element.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">[@attrib]</code></p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id484"/> selects all the elements that have the given attribute.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">[@attrib='value']</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id485"/>selects all the elements for which the given attribute has the given value.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">[tag]</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id486"/>selects all the elements that have a child named tag. Only immediate children are supported.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">[position]</code></p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id487"/> selects all the elements that are located at the given position. The position can either be an integer (<code class="literal">1</code> is the first position), the <code class="literal">last()</code>expression (for the last position), or a position relative to the last position (for example, <code class="literal">last()-1</code>).</p>
</td></tr></tbody></table></div><p>Therefore, using <code class="literal">root.find("tracks").attrib["totalPages"]</code>, we read the total amount of pages. We will save the first page and then go through the other pages one by one and save them too.</p><p>In the <code class="literal">save_page()</code> method, <code class="literal">root.findall("tracks/track")</code> returns an iterator through the <code class="literal">&lt;track&gt;</code> nodes under the <code class="literal">&lt;tracks&gt;</code> node. With <code class="literal">track_node.find("image[@size='medium']")</code>, we get the medium-sized image.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec302"/>There's more...</h2></div></div></div><p>You can learn <a class="indexterm" id="id488"/>more about XPath at <a class="ulink" href="https://en.wikipedia.org/wiki/XPath">https://en.wikipedia.org/wiki/XPath</a>.</p><p>The full <a class="indexterm" id="id489"/>documentation of <code class="literal">ElementTree</code> can be found at <a class="ulink" href="https://docs.python.org/2/library/xml.etree.elementtree.html">https://docs.python.org/2/library/xml.etree.elementtree.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec303"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Importing data from an external JSON file</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec89"/>Creating filterable RSS feeds</h1></div></div></div><p>Django comes <a class="indexterm" id="id490"/>with a syndication feed framework that allows you to create RSS and Atom feeds easily. RSS and Atom feeds are XML documents with specific semantics. They can be subscribed in an RSS reader such as Feedly or they can be aggregated in other websites, mobile applications, or desktop applications. In this recipe, we will create <code class="literal">BulletinFeed</code>, which provides a bulletin board with images. Moreover, the results will be filterable by URL query parameters.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec304"/>Getting ready</h2></div></div></div><p>Create a new <code class="literal">bulletin_board</code> app and put it under <code class="literal">INSTALLED_APPS</code> in the settings.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec305"/>How to do it...</h2></div></div></div><p>We will create a <code class="literal">Bulletin</code> model and an RSS feed for it. We will be able to filter the RSS feed by type or category so that it is possible to only subscribe to the bulletins that are, for example, offering used books:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">models.py</code> file of this app, add the <code class="literal">Category</code> and <code class="literal">Bulletin</code> models with a foreign key relationship between them, as follows:<div><pre class="programlisting">
<strong># bulletin_board/models.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.core.urlresolvers import reverse
from django.utils.encoding import \
    python_2_unicode_compatible
from utils.models import CreationModificationDateMixin
from utils.models import UrlMixin

TYPE_CHOICES = (
    ("searching", _("Searching")),
    ("offering", _("Offering")),
)

@python_2_unicode_compatible
class Category(models.Model):
    title = models.CharField(_("Title"), max_length=200)

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = _("Category")
        verbose_name_plural = _("Categories")

@python_2_unicode_compatible
class Bulletin(CreationModificationDateMixin, UrlMixin):
    bulletin_type = models.CharField(_("Type"),
        max_length=20, choices=TYPE_CHOICES)
    category = models.ForeignKey(Category,
        verbose_name=_("Category"))

    title = models.CharField(_("Title"), max_length=255)
    description = models.TextField(_("Description"),
        max_length=300)

    contact_person = models.CharField(_("Contact person"),
        max_length=255)
    phone = models.CharField(_("Phone"), max_length=50,
        blank=True)
    email = models.CharField(_("Email"), max_length=254,
        blank=True)

    image = models.ImageField(_("Image"), max_length=255,
        upload_to="bulletin_board/", blank=True)

    class Meta:
        verbose_name = _("Bulletin")
        verbose_name_plural = _("Bulletins")
        ordering = ("-created",)

    def __str__(self):
        return self.title

    def get_url_path(self):
        try:
            path = reverse(
                "bulletin_detail",
                kwargs={"pk": self.pk}
            )
        except:
            # the apphook is not attached yet
            return ""
        else:
            return path</pre></div></li><li class="listitem">Then, create <code class="literal">BulletinFilterForm</code> that allows the visitor to filter the bulletins<a class="indexterm" id="id491"/> by type and category, as follows:<div><pre class="programlisting">
<strong># bulletin_board/forms.py</strong>
# -*- coding: UTF-8 -*-
from django import forms
from django.utils.translation import ugettext_lazy as _
from models import Category, TYPE_CHOICES

class BulletinFilterForm(forms.Form):
    bulletin_type = forms.ChoiceField(
        label=_("Bulletin Type"),
        required=False,
        choices=(("", "---------"),) + TYPE_CHOICES,
    )
    category = forms.ModelChoiceField(
        label=_("Category"),
        required=False,
        queryset=Category.objects.all(),
    )</pre></div></li><li class="listitem">Add a <code class="literal">feeds.py</code> file with the <code class="literal">BulletinFeed</code> class, as shown in the following:<div><pre class="programlisting">
<strong># bulletin_board/feeds.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.contrib.syndication.views import Feed
from django.core.urlresolvers import reverse
from .models import Bulletin, TYPE_CHOICES
from .forms import BulletinFilterForm

class BulletinFeed(Feed):
    description_template = \
        "bulletin_board/feeds/bulletin_description.html"

    def get_object(self, request, *args, **kwargs):
        form = BulletinFilterForm(data=request.REQUEST)
        obj = {}
        if form.is_valid():
            obj = {
                "bulletin_type": \
                    form.cleaned_data["bulletin_type"],
                "category": form.cleaned_data["category"],
                "query_string": \
                    request.META["QUERY_STRING"],
            }
        return obj

    def title(self, obj):
        t = "My Website - Bulletin Board"
        # add type "Searching" or "Offering"
        if obj.get("bulletin_type", False):
            tp = obj["bulletin_type"]
            t += " - %s" % dict(TYPE_CHOICES)[tp]
        # add category
        if obj.get("category", False):
            t += " - %s" % obj["category"].title
        return t

    def link(self, obj):
        if obj.get("query_string", False):
            return reverse("bulletin_list") + "?" + \
                obj["query_string"]
        return reverse("bulletin_list")

    def feed_url(self, obj):
        if obj.get("query_string", False):
            return reverse("bulletin_rss") + "?" + \
                obj["query_string"]
        return reverse("bulletin_rss")

    def item_pubdate(self, item):
        return item.created

    def items(self, obj):
        qs = Bulletin.objects.order_by("-created")
        if obj.get("bulletin_type", False):
            qs = qs.filter(
                bulletin_type=obj["bulletin_type"],
            ).distinct()
        if obj.get("category", False):
            qs = qs.filter(
                category=obj["category"],
            ).distinct()
        return qs[:30]</pre></div></li><li class="listitem">Create a template for the bulletin description that will be provided in the feed, as <a class="indexterm" id="id492"/>shown in the following:<div><pre class="programlisting">
<strong>{# templates/bulletin_board/feeds/bulletin_description.html #}</strong>
{% if obj.image %}
    &lt;p&gt;&lt;a href="{{ obj.get_url }}"&gt;&lt;img src="img/{{ request.META.HTTP_HOST }}{{ obj.image.url }}" alt="" /&gt;&lt;/a&gt;&lt;/p&gt;
{% endif %}
&lt;p&gt;{{ obj.description }}&lt;/p&gt;</pre></div></li><li class="listitem">Create a URL configuration for the bulletin board app and include it in the root URL configuration, as follows:<div><pre class="programlisting">
<strong># templates/bulletin_board/urls.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.conf.urls import *
from .feeds import BulletinFeed

urlpatterns = patterns("bulletin_board.views",
    url(r"^$", "bulletin_list", name="bulletin_list"),
    url(r"^(?P&lt;bulletin_id&gt;[0-9]+)/$", "bulletin_detail",
         name="bulletin_detail"),
    url(r"^rss/$", BulletinFeed(), name="bulletin_rss"),
)</pre></div></li><li class="listitem">You will also need the views and templates for the filterable list and details of the bulletins. In the <code class="literal">Bulletin</code> list page template, add the following link:<div><pre class="programlisting">&lt;a href="{% url "bulletin_rss" %}?{{ request.META.QUERY_STRING }}"&gt;RSS Feed&lt;/a&gt;</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec306"/>How it works...</h2></div></div></div><p>Therefore, if you have some data in the database and you open <code class="literal">http://127.0.0.1:8000/bulletin-board/rss/?bulletin_type=offering&amp;category=4</code> in your browser, you will get an RSS feed of bulletins with the <code class="literal">Offering</code> type and the <code class="literal">4</code> category ID.</p><p>The <code class="literal">BulletinFeed</code> class has the <code class="literal">get_objects()</code> method that takes the current <code class="literal">HttpRequest</code> and defines the <code class="literal">obj</code> dictionary used in other methods of the same class. The <code class="literal">obj</code> dictionary contains the bulletin type, category, and current query string.</p><p>The <code class="literal">title()</code> method returns the title of the feed. It can either be generic or related to the selected bulletin type or category. The <code class="literal">link()</code> method returns the link to the original bulletin list with the filtering done. The <code class="literal">feed_url()</code> method returns the URL of the current feed. The <code class="literal">items()</code> method does the filtering itself and returns a filtered <code class="literal">QuerySet</code> of bulletins. Finally, the <code class="literal">item_pubdate()</code> method returns the creation date of the bulletin.</p><p>To see <a class="indexterm" id="id493"/>all the available methods and properties of the <code class="literal">Feed</code> class that we are extending, refer to the following documentation at <a class="ulink" href="https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference">https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference</a>.</p><p>The other parts of the code are self-explanatory.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec307"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating a model mixin with URL-related methods</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. Database Structure">Chapter 2</a>, <em>Database Structure</em></li><li class="listitem" style="list-style-type: disc">The <em>Creating a model mixin to handle creation and modification dates</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. Database Structure">Chapter 2</a>, <em>Database Structure</em></li><li class="listitem" style="list-style-type: disc">The <em>Using Tastypie to create API</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec90"/>Using Tastypie to create API</h1></div></div></div><p><strong>Tastypie</strong> is a<a class="indexterm" id="id494"/> framework for Django to create web service <strong>Application Program Interface</strong> (<strong>API</strong>). It supports full <code class="literal">GET</code>/<code class="literal">POST</code>/<code class="literal">PUT</code>/<code class="literal">DELETE</code>/<code class="literal">PATCH HTTP</code> methods to deal with online resources. It also supports different types of authentication and authorization, serialization, caching, throttling, and so on. In this recipe, you<a class="indexterm" id="id495"/> will learn <a class="indexterm" id="id496"/>how to provide bulletins to third parties for reading, that is, we will implement only the <code class="literal">GET HTTP</code> method.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec308"/>Getting ready</h2></div></div></div><p>First of all, install <code class="literal">Tastypie</code> in your virtual environment using the following command:</p><div><pre class="programlisting">
<strong>(myproject_env)$ pip install django-tastypie</strong>
</pre></div><p>Add Tastypie to <code class="literal">INSTALLED_APPS</code> in the settings. Then, enhance the <code class="literal">bulletin_board</code> app that we defined in the <em>Creating filterable RSS feeds</em> recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec309"/>How to do it...</h2></div></div></div><p>We will <a class="indexterm" id="id497"/>create an<a class="indexterm" id="id498"/> API for bulletins and inject it in the URL configuration as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">bulletin_board</code> app, create an <code class="literal">api.py</code> file with two resources, <code class="literal">CategoryResource</code> and <code class="literal">BulletinResource</code>, as follows:<div><pre class="programlisting">
<strong># bulletin_board/api.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from tastypie.resources import ModelResource
from tastypie.resources import ALL, ALL_WITH_RELATIONS
from tastypie.authentication import ApiKeyAuthentication
from tastypie.authorization import DjangoAuthorization
from tastypie import fields
from .models import Category, Bulletin

class CategoryResource(ModelResource):
    class Meta:
        queryset = Category.objects.all()
        resource_name = "categories"
        fields = ["title"]
        allowed_methods = ["get"]
        authentication = ApiKeyAuthentication()
        authorization = DjangoAuthorization()
        filtering = {
            "title": ALL,
        }

class BulletinResource(ModelResource):
    category = fields.ForeignKey(CategoryResource,
        "category", full=True)

    class Meta:
        queryset = Bulletin.objects.all()
        resource_name = "bulletins"
        fields = [
            "bulletin_type", "category", "title",
            "description", "contact_person", "phone",
            "email", "image"
        ]
        allowed_methods = ["get"]
        authentication = ApiKeyAuthentication()
        authorization = DjangoAuthorization()
        filtering = {
            "bulletin_type": ALL,
            "title": ALL,
            "category": ALL_WITH_RELATIONS,
        }</pre></div></li><li class="listitem">In the<a class="indexterm" id="id499"/> main <a class="indexterm" id="id500"/>URL configuration, include the API URLs, as follows:<div><pre class="programlisting">
<strong># myproject/urls.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.conf.urls import patterns, include, url
from django.conf import settings
from django.conf.urls.static import static
from django.contrib.staticfiles.urls import \
    staticfiles_urlpatterns

from django.contrib import admin
admin.autodiscover()

<strong>from tastypie.api import Api</strong>
<strong>from bulletin_board.api import CategoryResource</strong>
<strong>from bulletin_board.api import BulletinResource</strong>

<strong>v1_api = Api(api_name="v1")</strong>
<strong>v1_api.register(CategoryResource())</strong>
<strong>v1_api.register(BulletinResource())</strong>

urlpatterns = patterns('',
    url(r"^admin/", include(admin.site.urls)),
<strong>    url(r"^api/", include(v1_api.urls)),</strong>
)

urlpatterns += staticfiles_urlpatterns()
urlpatterns += static(settings.MEDIA_URL,
    document_root=settings.MEDIA_ROOT)</pre></div></li><li class="listitem">Create a Tastypie API key for the admin user in the model administration. To do this, navigate to <strong>Tastypie</strong> | <strong>Api key</strong> | <strong>Add Api key</strong>, select the admin user, and save the entry. This will generate a random API key, as shown in the following screenshot:<div><img alt="How to do it..." src="img/B04912_09_01.jpg"/></div></li><li class="listitem">Then, you can open this URL to see the JSON response in action (simply replace xxx with your API key): <code class="literal">http://127.0.0.1:8000/api/v1/bulletins/?format=json&amp;username=admin&amp;api_key=xxx</code>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec310"/>How it works...</h2></div></div></div><p>Each <a class="indexterm" id="id501"/>endpoint of <code class="literal">Tastypie</code> should have a class extending <code class="literal">ModelResource</code> defined. Similar to the Django<a class="indexterm" id="id502"/> models, the configuration of the resource is set in the <code class="literal">Meta</code> class:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">queryset</code> parameter defines the <code class="literal">QuerySet</code> of objects to list.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">resource_name</code> parameter defines the name of the URL endpoint.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">fields</code> parameter lists out the fields of the model that should be shown in the API.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">allowed_methods</code> parameter lists out the request methods, such as <code class="literal">get</code>, <code class="literal">post</code>, <code class="literal">put</code>, <code class="literal">delete</code>, and <code class="literal">patch</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">authentication</code> parameter defines how third parties can authenticate themselves when connecting to the API. The available options are <code class="literal">Authentication</code>, <code class="literal">BasicAuthentication</code>, <code class="literal">ApiKeyAuthentication</code>, <code class="literal">SessionAuthentication</code>, <code class="literal">DigestAuthentication</code>, <code class="literal">OAuthAuthentication</code>, <code class="literal">MultiAuthentication</code>, or your own custom authentication. In our case, we are using <code class="literal">ApiKeyAuthentication</code> as we want each user to use <code class="literal">username</code> and <code class="literal">api_key</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">authorization</code> parameter answers the authorization question: is permission granted to this user to take the stated action? The possible choices are <code class="literal">Authorization</code>, <code class="literal">ReadOnlyAuthorization</code>, <code class="literal">DjangoAuthorization</code>, or your own custom authorization. In our case, we are using <code class="literal">ReadOnlyAuthorization</code> as we only want to allow read access to the users.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">filtering</code> parameter defines by which fields one can filter the lists in the URL query parameters. For example, with the current configuration, you can filter the items by titles that contain the word "<code class="literal">movie</code>": <code class="literal">http://127.0.0.1:8000/api/v1/bulletins/?format=json&amp;username=admin&amp;api_key=xxx&amp;title__contains=movie</code>.</li></ul></div><p>Also, there <a class="indexterm" id="id503"/>is a <code class="literal">category</code> foreign key that is defined in <code class="literal">BulletinResource</code> with the <code class="literal">full=True</code> argument, meaning that the full list of category fields will be shown in the bulletin resource<a class="indexterm" id="id504"/> instead of an endpoint link.</p><p>Besides JSON, <code class="literal">Tastypie</code> allows you to use other formats such as XML, YAML, and bplist.</p><p>There is a lot more that you can do with APIs using Tastypie. To find out more details, check the<a class="indexterm" id="id505"/> official documentation at <a class="ulink" href="http://django-tastypie.readthedocs.org/en/latest/">http://django-tastypie.readthedocs.org/en/latest/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec311"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating filterable RSS feeds</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Using Django REST framework to create API</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec91"/>Using Django REST framework to create API</h1></div></div></div><p>Besides Tastypie, there is a newer and fresher framework to create API for your data transfers<a class="indexterm" id="id506"/> to and from third parties. That's Django REST Framework. This framework<a class="indexterm" id="id507"/> has more extensive documentation and Django-ish implementation, it is also more maintainable. Therefore, if you have to choose between Tastypie or Django REST Framework, I would recommend the latter one. In this recipe, you will learn how to use Django REST Framework in order to allow your project partners, mobile clients, or Ajax-based website to access data on your site to create, read, update, and delete.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec312"/>Getting ready</h2></div></div></div><p>First of all, install Django REST Framework and its optional dependencies in your virtual environment using the following commands:</p><div><pre class="programlisting">
<strong>(myproject_env)$ pip install djangorestframework</strong>
<strong>(myproject_env)$ pip install markdown</strong>
<strong>(myproject_env)$ pip install django-filter</strong>
</pre></div><p>Add <code class="literal">rest_framework</code> to <code class="literal">INSTALLED_APPS</code> in the settings. Then, enhance the <code class="literal">bulletin_board</code> app that we defined in the <em>Creating filterable RSS feeds</em> recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec313"/>How to do it...</h2></div></div></div><p>To<a class="indexterm" id="id508"/> integrate<a class="indexterm" id="id509"/> a new REST API in our <code class="literal">bulletin_board</code> app, execute the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the specific configurations to the settings:<div><pre class="programlisting">
<strong># conf/base.py or settings.py</strong>
REST_FRAMEWORK = {
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions."
            "DjangoModelPermissionsOrAnonReadOnly"
    ],
    "DEFAULT_PAGINATION_CLASS": \
        "rest_framework.pagination.LimitOffsetPagination",
    "PAGE_SIZE": 100,
}</pre></div></li><li class="listitem">In the <code class="literal">bulletin_board</code> app, create the <code class="literal">serializers.py</code> file with the following content:<div><pre class="programlisting">
<strong># bulletin_board/serializers.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from rest_framework import serializers
from .models import Category, Bulletin

class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        model = Category
        fields = ["id", "title"]

class BulletinSerializer(serializers.ModelSerializer):
    category = CategorySerializer()

    class Meta:
        model = Bulletin
        fields = [
            "id", "bulletin_type", "category", "title",
            "description", "contact_person", "phone",
            "email", "image"
        ]

    def create(self, validated_data):
        category_data = validated_data.pop('category')
        category, created = Category.objects.\
            get_or_create(title=category_data['title'])
        bulletin = Bulletin.objects.create(
            category=category, **validated_data
        )
        return bulletin

    def update(self, instance, validated_data):
        category_data = validated_data.pop('category')
        category, created = Category.objects.get_or_create(
            title=category_data['title'],
        )
        for fname, fvalue in validated_data.items():
            setattr(instance, fname, fvalue)
        instance.category = category
        instance.save()
        return instance</pre></div></li><li class="listitem">Add <a class="indexterm" id="id510"/>two<a class="indexterm" id="id511"/> new class-based views to the <code class="literal">views.py</code> file in the <code class="literal">bulletin_board</code> app:<div><pre class="programlisting">
<strong># bulletin_board/views.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from rest_framework import generics

from .models import Bulletin
from .serializers import BulletinSerializer

class RESTBulletinList(generics.ListCreateAPIView):
    queryset = Bulletin.objects.all()
    serializer_class = BulletinSerializer


class RESTBulletinDetail(
    generics.RetrieveUpdateDestroyAPIView
):
    queryset = Bulletin.objects.all()
    serializer_class = BulletinSerializer</pre></div></li><li class="listitem">Finally, plug in the new views to the URL configuration:<div><pre class="programlisting">
<strong># myproject/urls.py</strong>
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.conf.urls import patterns, include, url
from bulletin_board.views import RESTBulletinList
from bulletin_board.views import RESTBulletinDetail

urlpatterns = [
    # ...
    url(
        r"^api-auth/",
        include("rest_framework.urls",
        namespace="rest_framework")
    ),
    url(
        r"^rest-api/bulletin-board/$",
        RESTBulletinList.as_view(),
        name="rest_bulletin_list"
    ),
    url(
        r"^rest-api/bulletin-board/(?P&lt;pk&gt;[0-9]+)/$",
        RESTBulletinDetail.as_view(),
        name="rest_bulletin_detail"
    ),
]</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec314"/>How it works...</h2></div></div></div><p>What we<a class="indexterm" id="id512"/> created here is an API for the bulletin board, where one can read a paginated bulletin<a class="indexterm" id="id513"/> list; create a new bulletin; and read, change, or delete a single bulletin by ID. Reading is allowed without authentication; whereas, one has to have a user account with appropriate permissions to add, change, or delete a bulletin.</p><p>Here's how you can approach the created API:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>URL</p>
</th><th style="text-align: left" valign="bottom">
<p>HTTP Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">http://127.0.0.1:8000/rest-api/bulletin-board/</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">GET</code></p>
</td><td style="text-align: left" valign="top">
<p>List bulletins paginated by 100</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">http://127.0.0.1:8000/rest-api/bulletin-board/</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">POST</code></p>
</td><td style="text-align: left" valign="top">
<p>Create a new bulletin if the requesting user is authenticated and authorized to create bulletins</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">http://127.0.0.1:8000/rest-api/bulletin-board/1/</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">GET</code></p>
</td><td style="text-align: left" valign="top">
<p>Get a bulletin with the <code class="literal">1</code> ID</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">http://127.0.0.1:8000/rest-api/bulletin-board/1/</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">PUT</code></p>
</td><td style="text-align: left" valign="top">
<p>Update a bulletin with the <code class="literal">1</code> ID, if the user is authenticated and authorized to change bulletins</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">http://127.0.0.1:8000/rest-api/bulletin-board/1/</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">DELETE</code></p>
</td><td style="text-align: left" valign="top">
<p>Delete the bulletin with the <code class="literal">1</code> ID, if the user is authenticated and authorized to delete bulletins</p>
</td></tr></tbody></table></div><p>How<a class="indexterm" id="id514"/> to use<a class="indexterm" id="id515"/> the API practically? For example, if you have the <code class="literal">requests</code> library installed, you can create a new bulletin in the Django shell as follows:</p><div><pre class="programlisting">
<strong>(myproject_env)$ python manage.py shell</strong>
<strong>&gt;&gt;&gt; import requests</strong>
<strong>&gt;&gt;&gt; response = requests.post("http://127.0.0.1:8000/rest-api/bulletin-board/", auth=("admin", "admin"), data={"title": "TEST", "category.title": "TEST", "contact_person": "TEST", "bulletin_type": "searching", "description": "TEST"})</strong>
<strong>&gt;&gt;&gt; response.status_code</strong>
<strong>201</strong>
<strong>&gt;&gt;&gt; response.json()</strong>
<strong>{u'category': {u'id': 6, u'title': u'TEST'}, u'description': u'TEST', u'title': u'TEST', u'image': None, u'email': u'', u'phone': u'', u'bulletin_type': u'searching', u'contact_person': u'TEST', u'id': 3}</strong>
</pre></div><p>Additionally, Django REST Framework provides you with a web-based API documentation that is shown when you access the API endpoints in a browser. There you can also try out the APIs by integrated forms, as shown in the following screenshot:</p><div><img alt="How it works..." src="img/B04912_09_02.jpg"/></div><p>Let's take a quick look at how the code that we wrote works. In the settings, we have set the <a class="indexterm" id="id516"/>access to be dependent on the permissions of the Django system. For anonymous requests, only <a class="indexterm" id="id517"/>reading is allowed. Other access options include allowing any permission to everyone, allowing any permission only to authenticated users, allowing any permission to staff users, and so on. The full list can be found at <a class="ulink" href="http://www.django-rest-framework.org/api-guide/permissions/">http://www.django-rest-framework.org/api-guide/permissions/</a>.</p><p>Then, in the settings, pagination is set. The current option is to have the <code class="literal">limit</code> and <code class="literal">offset</code> parameters like in an SQL query. Other options are to have either pagination by page numbers for rather static content or cursor pagination for real-time data. We set the default pagination to 100 items per page.</p><p>Later we define serializers for categories and bulletins. They handle the data that will be shown in the output or validated by the input. In order to handle category retrieval or saving, we had to overwrite the <code class="literal">create()</code> and <code class="literal">update()</code> methods of <code class="literal">BulletinSerializer</code>. There are various ways to serialize relations in Django REST Framework and we chose the most verbose one in our example. To read more about how to <a class="indexterm" id="id518"/>serialize relations, refer to the documentation at <a class="ulink" href="http://www.django-rest-framework.org/api-guide/relations/">http://www.django-rest-framework.org/api-guide/relations/</a>.</p><p>After<a class="indexterm" id="id519"/> defining<a class="indexterm" id="id520"/> the serializers, we created two class-based views to handle the API endpoints and plugged them in the URL configuration. In the URL configuration, we have a rule (<code class="literal">/api-auth/</code>) for browsable API pages, login, and logout.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec315"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating filterable RSS feeds</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Using Tastypie to create API</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Testing API created using Django REST framework</em> recipe in <a class="link" href="ch11.html" title="Chapter 11. Testing and Deployment">Chapter 11</a>, <em>Testing and Deployment</em></li></ul></div></div></div></body></html>