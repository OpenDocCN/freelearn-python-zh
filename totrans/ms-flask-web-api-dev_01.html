<html><head></head><body>
		<div><h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/><st c="0">1</st></h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><st c="2">A Deep Dive into the Flask Framework</st></h1>
			<p><strong class="bold"><st c="38">Flask</st></strong><st c="44"> is a </st><strong class="bold"><st c="50">Python</st></strong><st c="56"> web framework that was created by Armin Ronacher to solve both web-based and API-related</st><a id="_idIndexMarker000"/><st c="145"> requirements that need a rapid development approach. </st><st c="199">It is a lightweight framework with helper classes and methods, a built-in server, a debugger, and a reloader, all of which are required for building scalable web applications and </st><st c="378">web services.</st></p>
			<p><st c="391">Unlike the Django framework, Flask is minimalistic and slimmer in that it requires more experience in using Python to craft various coding techniques and workarounds to implement its components. </st><st c="587">It is more open-ended and extensible than the full-stack Django, which is more friendly to newbies because of its easy-to-build projects and </st><st c="728">reusable components.</st></p>
			<p><st c="748">This first chapter will showcase the essential task itineraries that cover the initial components and base features of Flask 3.x that are essential in initiating our </st><st c="915">web development.</st></p>
			<p><st c="931">In this chapter, we will cover the following </st><st c="977">development tasks:</st></p>
			<ul>
				<li><st c="995">Setting up the </st><st c="1011">project baseline</st></li>
				<li><st c="1027">Creating routes </st><st c="1044">and navigations</st></li>
				<li><st c="1059">Managing the requests and </st><st c="1086">response data</st></li>
				<li><st c="1099">Implementing </st><st c="1113">view templates</st></li>
				<li><st c="1127">Creating </st><st c="1137">web forms</st></li>
				<li><st c="1146">Building the data layer </st><st c="1171">with PostgreSQL</st></li>
				<li><st c="1186">Managing the </st><st c="1200">project structure</st></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><st c="1217">Technical requirements</st></h1>
			<p><st c="1240">The first chapter will focus on building a prototype for an </st><em class="italic"><st c="1301">Online Personal Counseling System</st></em><st c="1334"> that simulates a face-to-face consultation between a patient and a counselor while highlighting the base components of </st><em class="italic"><st c="1454">Flask 3.x</st></em><st c="1463">. The application will cover modules such as managing users, questionnaires, and some reports. </st><st c="1558">The code for this chapter can be found </st><st c="1597">at </st><a href="https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch01"><st c="1600">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch01</st></a><st c="1681">.</st></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><st c="1682">Setting up the project baseline</st></h1>
			<p><st c="1714">Gathering and studying the</st><a id="_idIndexMarker001"/><st c="1741"> system requirements for the development environment for the proposed project is essential. </st><st c="1833">Some of these requirements include the correct versions of the installers and libraries, the appropriate servers, and the inclusion of other essential dependencies. </st><st c="1998">We have to perform various setups before kicking off </st><st c="2051">our projects.</st></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/><st c="2064">Installing the latest Python version</st></h2>
			<p><st c="2101">All our applications will run</st><a id="_idIndexMarker002"/><st c="2131"> on the </st><em class="italic"><st c="2139">Python 11</st></em><st c="2148"> environment for faster performance. </st><st c="2185">The updated Python installer for all operating systems is available </st><st c="2253">at </st><a href="https://www.python.org/downloads/"><st c="2256">https://www.python.org/downloads/</st></a><st c="2289">.</st></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/><st c="2290">Installing the Visual Studio (VS) Code editor</st></h2>
			<p><st c="2336">The Django framework has a </st><code><st c="2364">django-admin</st></code><st c="2376"> command that generates a project structure, but Flask does</st><a id="_idIndexMarker003"/><st c="2435"> not have that. </st><st c="2451">We can use a terminal console or a tool such as the </st><strong class="bold"><st c="2503">Visual Studio</st></strong><st c="2516"> (</st><strong class="bold"><st c="2518">VS</st></strong><st c="2520">) </st><strong class="bold"><st c="2523">Code</st></strong><st c="2527"> editor that can</st><a id="_idIndexMarker004"/><st c="2543"> help developers create a Flask project. </st><st c="2584">The VS Code installer is available </st><st c="2619">at </st><a href="https://code.visualstudio.com/download"><st c="2622">https://code.visualstudio.com/download</st></a><st c="2660">.</st></p>
			<p><st c="2661">After installing the VS Code editor, we can create a filesystem folder through it and start a Flask project. </st><st c="2771">To create the folder, we should go to the </st><strong class="bold"><st c="2813">Open Folder</st></strong><st c="2824"> option under </st><strong class="bold"><st c="2838">File</st></strong><st c="2842"> or use the </st><em class="italic"><st c="2854">Ctrl</st></em><st c="2858"> + </st><em class="italic"><st c="2861">K</st></em><st c="2862"> + </st><em class="italic"><st c="2865">O</st></em><st c="2866"> shortcut to open the </st><strong class="bold"><st c="2888">Open Folder</st></strong><st c="2899"> mini-window. </st><em class="italic"><st c="2913">Figure 1</st></em><em class="italic"><st c="2921">.1</st></em><st c="2923"> shows a sample process of creating a Flask project using </st><st c="2981">the editor:</st></p>
			<div><div><img src="img/B19383_01_001.jpg" alt="Figure 1.1 – Creating a Flask project folder using the VS Code editor"/><st c="2992"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="3923">Figure 1.1 – Creating a Flask project folder using the VS Code editor</st></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/><st c="3992">Creating the virtual environment</st></h2>
			<p><st c="4025">Another aspect of developing a Flask project is having a </st><a id="_idIndexMarker005"/><st c="4083">repository called a </st><strong class="bold"><st c="4103">virtual environment</st></strong><st c="4122"> that can hold its libraries. </st><st c="4152">It is a mechanism or a tool that can manage all dependencies of a project by isolating these dependencies from the global repository and other project</st><a id="_idIndexMarker006"/><st c="4302"> dependencies. </st><st c="4317">The following are the advantages of using this tool in developing </st><st c="4383">Flask-based applications:</st></p>
			<ul>
				<li><st c="4408">It can avoid broken module versions and collisions with other existing similar global </st><st c="4495">repository libraries.</st></li>
				<li><st c="4516">It can help build a dependency tree for </st><st c="4557">the project.</st></li>
				<li><st c="4569">It can help ease the deployment of applications with libraries to both physical and </st><st c="4654">cloud-based servers.</st></li>
			</ul>
			<p><st c="4674">A Python extension named </st><code><st c="4700">virtualenv</st></code><st c="4710"> is required to set up these virtual environments. </st><st c="4761">To install the extension, run the following command in </st><st c="4816">the terminal:</st></p>
			<pre class="console"><st c="4829">
pip install virtualenv</st></pre>			<p><st c="4852">After this installation, we need to run </st><code><st c="4893">python virtualenv -m ch01-01</st></code><st c="4921"> to create our first virtual environment for our Flask project. </st><em class="italic"><st c="4985">Figure 1</st></em><em class="italic"><st c="4993">.2</st></em><st c="4995"> shows a snapshot of creating our </st><code><st c="5029">ch01-env</st></code><st c="5037"> repository:</st></p>
			<div><div><img src="img/B19383_01_002.jpg" alt="Figure 1.2 – Creating a virtual environment"/><st c="5049"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5289">Figure 1.2 – Creating a virtual environment</st></p>
			<p><st c="5332">The next step is to open the</st><a id="_idIndexMarker007"/><st c="5361"> project and link it to the virtual environment created for it. </st><st c="5425">Pressing </st><em class="italic"><st c="5434">Ctrl</st></em><st c="5438"> + </st><em class="italic"><st c="5441">Shift</st></em><st c="5446"> + </st><em class="italic"><st c="5449">P</st></em><st c="5450"> in VS Code will open the </st><code><st c="5522">Python: Select Interpreter</st></code><st c="5548">. Clicking this option will lead you to the </st><code><st c="5730">Python.exe</st></code><st c="5740"> file in the </st><code><st c="5753">/Scripts</st></code><st c="5761"> folder. </st><em class="italic"><st c="5770">Figure 1</st></em><em class="italic"><st c="5778">.3</st></em><st c="5780"> shows a snapshot of locating the Python interpreter in the repository’s </st><code><st c="5853">/</st></code><code><st c="5854">Scripts</st></code><st c="5861"> folder:</st></p>
			<div><div><img src="img/B19383_01_003.jpg" alt="Figure 1.3 – Locating the Python interpreter of the virtual environment"/><st c="5869"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="6759">Figure 1.3 – Locating the Python interpreter of the virtual environment</st></p>
			<p><st c="6830">Afterward, the virtual environment must be activated for the project to utilize it. </st><st c="6915">You must run </st><code><st c="6928">/Scripts/activate.bat</st></code><st c="6949"> in Windows or </st><code><st c="6964">/bin/activate</st></code><st c="6977"> in Linux through the editor’s internal </st><a id="_idIndexMarker008"/><st c="7017">console. </st><st c="7026">Upon activation, the terminal should show the name of the virtual environment in its prompt (for example, </st><code><st c="7132">(</st></code><code><st c="7133">ch01-env) C:\</st></code><st c="7146">).</st></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/><st c="7149">Installing the Flask 3.x libraries</st></h2>
			<p><st c="7184">The integrated </st><a id="_idIndexMarker009"/><st c="7200">terminal of VS Code will appear after right-clicking the explorer portion of the editor, which leads to the </st><code><st c="7497">pip </st></code><code><st c="7501">install flask</st></code><st c="7514">.</st></p>
			<p><st c="7515">Once all the requirements are in place, we are ready to create our </st><st c="7583">baseline application.</st></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/><st c="7604">Creating the Flask project</st></h2>
			<p><st c="7631">The first component that </st><a id="_idIndexMarker011"/><st c="7657">must be implemented in the main project folder (that is, </st><code><st c="7714">ch01</st></code><st c="7718">) is the application file, which can be </st><code><st c="7759">main.py</st></code><st c="7766"> or</st><a id="_idIndexMarker012"/><st c="7769"> sometimes </st><code><st c="7780">app.py</st></code><st c="7786">. This component will become the top-level module the Flask will recognize when the server starts. </st><st c="7885">Here is the baseline application file for our </st><em class="italic"><st c="7931">Online Personal Counseling </st></em><em class="italic"><st c="7958">System</st></em><st c="7964"> prototype:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="7975">from flask import Flask</st></strong>
<strong class="bold"><st c="7999">app = Flask(__name__)</st></strong><st c="8021">
@app.route('/', methods = ['GET'])
def index():
    return "This is an online … counseling system (OPCS)"
</st><code><st c="8233">main.py</st></code><st c="8240"> file:</st></p>
			<ul>
				<li><st c="8246">An imported </st><code><st c="8259">Flask</st></code><st c="8264"> class from the </st><code><st c="8280">flask</st></code><st c="8285"> package plays a considerable role in building the application. </st><st c="8349">This class provides all the utilities that implement the </st><code><st c="8708">Flask</st></code><st c="8713"> instance is the main element in building a </st><strong class="bold"><st c="8757">Web Server Gateway Interface</st></strong><st c="8785"> (</st><strong class="bold"><st c="8787">WSGI</st></strong><st c="8791">)-compliant </st><a id="_idIndexMarker014"/><st c="8804">application.</st></li>
			</ul>
			<p class="callout-heading"><st c="8816">Werkzeug</st></p>
			<p class="callout"><code><st c="8825">Werkzeug</st></code><st c="8834"> is a WSGI-based library </st><a id="_idIndexMarker015"/><st c="8859">or module that provides Flask with the necessary utilities, including a built-in server, for running </st><st c="8960">WSGI-based applications.</st></p>
			<ul>
				<li><st c="8984">The imported </st><code><st c="8998">Flask</st></code><st c="9003"> instance must be instantiated once per application. </st><st c="9056">The </st><code><st c="9060">__name__</st></code><st c="9068"> argument must be passed to its constructor to provide </st><code><st c="9123">Flask</st></code><st c="9128"> with a reference to the main module without explicitly setting its actual package. </st><st c="9212">Its purpose is to provide Flask with the reach it needs in providing the utilities across the application and to register the components of the project to </st><st c="9367">the framework.</st></li>
				<li><st c="9381">The </st><code><st c="9386">if</st></code><st c="9388"> statement tells the Python interpreter to run Werkzeug’s built-in development server if the module is </st><code><st c="9491">main.py</st></code><st c="9498">. This line validates the </st><code><st c="9524">main.py</st></code><st c="9531"> module as the top-level module of </st><st c="9566">the project.</st></li>
				<li><code><st c="9578">app.run()</st></code><st c="9588"> calls and starts the built-in development server of Werkzeug. </st><st c="9651">Setting its </st><code><st c="9663">debug</st></code><st c="9668"> parameter to </st><code><st c="9682">True</st></code><st c="9686"> sets development or debug mode and enables Werkzeug’s debugger tool and automatic reloading. </st><st c="9780">Another way is to create a configuration file that will set </st><code><st c="9840">FLASK_DEBUG</st></code><st c="9851"> to </st><code><st c="9855">True</st></code><st c="9859">. We can also set development mode by running </st><code><st c="9905">main.py</st></code><st c="9912"> using the </st><code><st c="9923">flask run</st></code><st c="9932"> command with the </st><code><st c="9950">--debug</st></code><st c="9957"> option. </st><st c="9966">Other configuration approaches before Flask 3.0, such as using </st><code><st c="10029">FLASK_ENV</st></code><st c="10038">, are </st><st c="10044">already deprecated.</st></li>
			</ul>
			<p><st c="10063">Running the </st><code><st c="10076">python main.py</st></code><st c="10090"> command on the VS Code terminal will start the built-in development server and run our application. </st><st c="10191">A server log will be displayed on the console with details that include the development mode, the debugger ID, and the </st><code><st c="10343">5000</st></code><st c="10347">, while the host </st><st c="10364">is </st><code><st c="10367">localhost</st></code><st c="10376">.</st></p>
			<p><st c="10377">Now, it is time to explore the view functions of our Flask application. </st><st c="10450">These are the components that manage </st><a id="_idIndexMarker016"/><st c="10487">the incoming requests and </st><st c="10513">outgoing responses.</st></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/><st c="10532">Creating routes and navigations</st></h1>
			<p><strong class="bold"><st c="10564">Routing</st></strong><st c="10572"> is a mapping of</st><a id="_idIndexMarker017"/><st c="10588"> URL pattern(s) and other related details to a view function that’s done using Flask’s route decorators. </st><st c="10693">On the other hand, the view function is a transaction that processes an incoming request from the clients and, at the same time, returns the necessary response to them. </st><st c="10862">It follows a life cycle and returns an HTTP status as part of </st><st c="10924">its response.</st></p>
			<p><st c="10937">There are different approaches to assigning URL patterns to view functions. </st><st c="11014">These include creating static and dynamic URL patterns, mapping URLs externally, and mapping multiple URLs to a </st><st c="11126">view function.</st></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/><st c="11140">Creating static URLs</st></h2>
			<p><st c="11161">Flask has several built-in route</st><a id="_idIndexMarker018"/><st c="11194"> decorators that implement some of its components, and </st><code><st c="11249">@route</st></code><st c="11255"> decorator is one of these. </st><code><st c="11283">@route</st></code><st c="11289"> directly maps the URL address to the view function seamlessly. </st><st c="11353">For instance, </st><code><st c="11367">@route</st></code><st c="11373"> maps the </st><code><st c="11383">index()</st></code><st c="11390"> view function presented in the project’s </st><code><st c="11432">main.py</st></code><st c="11439"> file to the root URL or </st><code><st c="11464">/</st></code><st c="11465">, which makes </st><code><st c="11479">index()</st></code><st c="11486"> the view function of the </st><st c="11512">root URL.</st></p>
			<p><st c="11521">But </st><code><st c="11526">@route</st></code><st c="11532"> can map any valid URL pattern to any view function. </st><st c="11585">A URL pattern is accepted if it follows the following </st><st c="11639">best practices:</st></p>
			<ul>
				<li><st c="11654">All characters must be </st><st c="11678">in lowercase.</st></li>
				<li><st c="11691">Use only forward slashes to establish </st><st c="11730">site hierarchy.</st></li>
				<li><st c="11745">URL names must be concise, clear, and within the </st><st c="11795">business context.</st></li>
				<li><st c="11812">Avoid spaces and special symbols and characters as much </st><st c="11869">as possible.</st></li>
			</ul>
			<p><st c="11881">The following </st><code><st c="11896">home()</st></code><st c="11902"> view function renders an introductory page of our </st><code><st c="11953">ch01</st></code><st c="11957"> application and uses the URL pattern of </st><code><st c="11998">/home</st></code><st c="12003"> for </st><st c="12008">its access:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="12019">@app.route('/home')</st></strong>
<strong class="bold"><st c="12039">def home():</st></strong><st c="12051">
    return '''
       &lt;html&gt;&lt;head&gt;&lt;title&gt;Online Personal … System&lt;/title&gt;
          &lt;/head&gt;&lt;body&gt;
           &lt;h1&gt;Online … Counseling System (OPCS)&lt;/h1&gt;
           &lt;p&gt;This is a template of a web-based counseling
              application where counselors can … … …&lt;/em&gt;
           &lt;/body&gt;&lt;/html&gt;
       '''</st></pre>			<p><st c="12282">Now, Flask accepts simple URLs such as </st><code><st c="12322">/home</st></code><st c="12327"> or complex ones with slashes and path-like hierarchy, including</st><a id="_idIndexMarker019"/><st c="12391"> these </st><st c="12398">multiple URLs.</st></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/><st c="12412">Assigning multiple URLs</st></h2>
			<p><st c="12436">A view function can have a </st><a id="_idIndexMarker020"/><st c="12464">stack of </st><code><st c="12473">@route</st></code><st c="12479"> decorators annotated on it. </st><st c="12508">Flask allows us to map these valid multiple URLs if there is no conflict with other view functions and within that stack of </st><code><st c="12632">@route</st></code><st c="12638"> mappings. </st><st c="12649">The following version of the </st><code><st c="12678">home()</st></code><st c="12684"> view function now has three URLs, which means any of these addresses can render the </st><st c="12769">home page:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="12779">@app.route('/home')</st></strong>
<strong class="bold"><st c="12799">@app.route('/information')</st></strong>
<strong class="bold"><st c="12826">@app.route('/introduction')</st></strong>
<strong class="bold"><st c="12854">def home():</st></strong><st c="12866">
    return '''&lt;html&gt;&lt;head&gt;
             &lt;title&gt;Online Personal … System&lt;/title&gt;
        &lt;/head&gt;&lt;body&gt;
           &lt;h1&gt;Online … Counseling System (OPCS)&lt;/h1&gt;
            … … … … …
        &lt;/body&gt;&lt;/html&gt;
       '''</st></pre>			<p><st c="13015">Aside from complex URLs, Flask is </st><a id="_idIndexMarker021"/><st c="13050">also capable of creating </st><em class="italic"><st c="13075">dynamic routes</st></em><st c="13089">.</st></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/><st c="13090">Applying path variables</st></h2>
			<p><st c="13114">Adding path variables makes a URL </st><a id="_idIndexMarker022"/><st c="13149">dynamic and changeable depending on the variations of the values passed to it. </st><st c="13228">Although some SEO experts may disagree with having dynamic URLs, the Flask framework can allow view functions with changeable URL patterns to </st><st c="13370">be implemented.</st></p>
			<p><st c="13385">In Flask, a path variable is declared inside a diamond operator (</st><code><st c="13451">&lt;&gt;</st></code><st c="13454">) and placed within the URL path. </st><st c="13489">The following view function has a dynamic URL with several </st><st c="13548">path variables:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="13563">@app.route('/exam/passers/list/&lt;float:rate&gt;/&lt;uuid:docId&gt;')</st></strong><st c="13622">
def report_exam_passers(</st><strong class="bold"><st c="13647">rating:float, docId:uuid4 = None</st></strong><st c="13680">):
    exams = list_passing_scores(</st><strong class="bold"><st c="13712">rating</st></strong><st c="13719">)
    response = make_response(
      render_template('exam/list_exam_passers.html',
           exams=exams, docId=</st><strong class="bold"><st c="13814">docId</st></strong><st c="13820">), 200)
    return response</st></pre>			<p><st c="13844">As we can see, path variables are identified with data types inside the diamond operator (</st><code><st c="13935">&lt;&gt;</st></code><st c="13938">) using the </st><code><st c="13951">&lt;type:variable&gt;</st></code><st c="13966"> pattern. </st><st c="13976">These parameters are set to </st><code><st c="14004">None</st></code><st c="14008"> if the path variables are optional. </st><st c="14045">The path variable is considered a string type by default if it has no associated type hint. </st><em class="italic"><st c="14137">Flask 3.x</st></em><st c="14146"> offers these built-in data types for </st><st c="14184">path variables:</st></p>
			<ul>
				<li><strong class="bold"><st c="14199">string</st></strong><st c="14206">: Allows all valid characters except </st><st c="14244">for slashes.</st></li>
				<li><strong class="bold"><st c="14256">int</st></strong><st c="14260">: Takes </st><st c="14269">integer values.</st></li>
				<li><strong class="bold"><st c="14284">float</st></strong><st c="14290">: Accepts </st><st c="14301">real numbers.</st></li>
				<li><strong class="bold"><st c="14314">uuid</st></strong><st c="14319">: Takes unique 32 hexadecimal digits that are used to identify or represent records, documents, hardware gadgets, software licenses, and </st><st c="14457">other information.</st></li>
				<li><strong class="bold"><st c="14475">path</st></strong><st c="14480">: Fetches characters, </st><st c="14503">including slashes.</st></li>
			</ul>
			<p><st c="14521">These path variables can’t function </st><a id="_idIndexMarker023"/><st c="14558">without the corresponding parameters of the same name and type declared in the view function’s parameter list. </st><st c="14669">In the previous </st><code><st c="14685">report_exam_passers()</st></code><st c="14706"> view function, the local </st><code><st c="14732">rating</st></code><st c="14738"> and </st><code><st c="14743">docId</st></code><st c="14748"> parameters are the variables that will hold the values of the path </st><st c="14816">variables, respectively.</st></p>
			<p><st c="14840">But there are particular or rare cases where path variables should be of a type different than the supported ones. </st><st c="14956">View functions with path variables declared as </st><code><st c="15003">list</st></code><st c="15007">, </st><code><st c="15009">set</st></code><st c="15012">, </st><code><st c="15014">date</st></code><st c="15018">, or </st><code><st c="15023">time</st></code><st c="15027"> will throw </st><code><st c="15039">Status Code 500</st></code><st c="15054"> in Flask. </st><st c="15065">As a workaround, the Werkzeug bundle of libraries offers a </st><code><st c="15124">BaseConverter</st></code><st c="15137"> utility class that can help customize a variable type for paths that allows other types to be part of the type hints. </st><st c="15256">The following view function requires a </st><code><st c="15295">date</st></code><st c="15299"> type hint to generate a certificate in </st><st c="15339">HTML format:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="15351">@app.route('/certificate/accomp/&lt;string:name&gt;/</st></strong><strong class="bold"><st c="15398">&lt;string:course&gt;/&lt;date:accomplished_date&gt;')</st></strong><st c="15441">
def show_certification(</st><strong class="bold"><st c="15465">name:str, course:str, accomplished_date:date</st></strong><st c="15510">):
    certificate = """&lt;html&gt;&lt;head&gt;
          &lt;title&gt;Certificate of Accomplishment&lt;/title&gt;
         &lt;/head&gt;&lt;body&gt;
           &lt;h1&gt;Certificate of Accomplishment&lt;/h1&gt;
           &lt;p&gt;The participant {} is, hereby awarded this certificate of accomplishment, in {} course on {} date for passing all exams. </st><st c="15766">He/she proved to be ready for any of his/her future endeavors.&lt;/em&gt;
         &lt;/body&gt;&lt;/html&gt;
    """.format(</st><strong class="bold"><st c="15860">name, course, accomplished_date</st></strong><st c="15892">)
    return certificate, 200</st></pre>			<p><code><st c="15918">accomplished_date</st></code><st c="15936"> in </st><code><st c="15940">show_certification()</st></code><st c="15960"> is a </st><code><st c="15966">date</st></code><st c="15970"> hint type and will not be valid until the following tasks </st><st c="16029">are implemented:</st></p>
			<ul>
				<li><st c="16045">First, subclass </st><code><st c="16062">BaseConverter</st></code><st c="16075"> from the </st><code><st c="16085">werkzeug.routing</st></code><st c="16101"> module. </st><st c="16110">In the </st><code><st c="16117">/converter</st></code><st c="16127"> package of this project, there is a module called </st><code><st c="16178">date_converter.py</st></code><st c="16195"> that implements our </st><code><st c="16216">date</st></code><st c="16220"> hint type, as shown in the </st><st c="16248">following code:</st><pre class="source-code">
<strong class="bold"><st c="16263">from werkzeug.routing import BaseConverter</st></strong><st c="16306">
from datetime import datetime
class DateConverter(</st><strong class="bold"><st c="16357">BaseConverter</st></strong><st c="16371">):
   </st><strong class="bold"><st c="16375">def to_python(self, value):</st></strong><st c="16402">
     date_value = datetime.strptime(value, "%Y-%m-%d")
     return date_value</st></pre><p class="list-inset"><st c="16470">The given </st><code><st c="16481">DateConverter</st></code><st c="16494"> will custom-handle date variables within our </st><st c="16540">Flask application.</st></p></li>				<li><code><st c="16558">BaseConverter</st></code><st c="16572"> has a </st><code><st c="16579">to_python()</st></code><st c="16590"> method that must be overridden to implement the necessary conversion</st><a id="_idIndexMarker024"/><st c="16659"> process. </st><st c="16669">In the case of </st><code><st c="16684">DateConverter</st></code><st c="16697">, we need </st><code><st c="16707">strptime()</st></code><st c="16717"> so that we can convert the path variable value in the </st><code><st c="16772">yyyy-mm-dd</st></code><st c="16782"> format into the </st><st c="16799">datetime type.</st></li>
				<li><st c="16813">Lastly, declare our new custom converter in the Flask instance of the </st><code><st c="16884">main.py</st></code><st c="16891"> module. </st><st c="16900">The following snippet registers </st><code><st c="16932">DateConverter</st></code> <st c="16945">to </st><code><st c="16949">app</st></code><st c="16952">:</st><pre class="source-code"><st c="16954">
app = Flask(__name__)
</st><strong class="bold"><st c="16977">app.url_map.converters['date'] = DateConverter</st></strong></pre></li>			</ul>
			<p><st c="17023">After following all these steps, the custom path variable type – for instance, </st><code><st c="17103">date</st></code><st c="17107"> – can now be utilized across </st><st c="17137">the application.</st></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/><st c="17153">Assigning URLs externally</st></h2>
			<p><st c="17179">There is also a way to</st><a id="_idIndexMarker025"/><st c="17202"> implement a routing mechanism without using the </st><code><st c="17251">@route</st></code><st c="17257"> decorator, and that’s by utilizing Flask’s </st><code><st c="17301">add_url_rule()</st></code><st c="17315"> method to register views. </st><st c="17342">This approach binds a valid request handler to a unique URL pattern for every call to </st><code><st c="17428">add_url_rule()</st></code><st c="17442"> of the </st><code><st c="17450">app</st></code><st c="17453"> instance in the </st><code><st c="17470">main.py</st></code><st c="17477"> module, not in the handler’s module scripts, thus making this approach an external way of building routes. </st><st c="17585">The following arguments are needed by the </st><code><st c="17627">add_url_rule()</st></code><st c="17641"> method to </st><st c="17652">perform mapping:</st></p>
			<ul>
				<li><st c="17668">The URL pattern with or without the </st><st c="17705">path variables.</st></li>
				<li><st c="17720">The URL name and, usually, the exact name of the </st><st c="17770">view function.</st></li>
				<li><st c="17784">The view </st><st c="17794">function itself.</st></li>
			</ul>
			<p><st c="17810">The invocation of this method must be in the </st><code><st c="17856">main.py</st></code><st c="17863"> file, anywhere after its </st><code><st c="17889">@route</st></code><st c="17895"> implementations and view imports. </st><st c="17930">The following </st><code><st c="17944">main.py</st></code><st c="17951"> snippet shows the external route mapping of the </st><code><st c="18000">show_honor_dismissal()</st></code><st c="18022"> view function to its dynamic URL pattern. </st><st c="18065">This view function generates a termination letter for the counseling and consultation agreement between a clinic and </st><st c="18182">a patient:</st></p>
			<pre class="source-code"><st c="18192">
app = Flask(__name__)
def show_honor_dissmisal(</st><strong class="bold"><st c="18240">counselor:str, effective_date:date, patient:str</st></strong><st c="18288">):
    letter = """
       … … … … …
       &lt;/head&gt;&lt;body&gt;
           &lt;h1&gt; Termination of Consultation &lt;/h1&gt;
           &lt;p&gt;From: </st><strong class="bold"><st c="18377">{}</st></strong><st c="18379">
           &lt;p&gt;Head, Counselor
           &lt;p&gt;Date: </st><strong class="bold"><st c="18408">{}</st></strong><st c="18410">
           &lt;p&gt;To: </st><strong class="bold"><st c="18418">{}</st></strong><st c="18420">
           &lt;p&gt;Subject: Termination of consultation
                    &lt;p&gt;Dear {},
                    … … … … … …
                    &lt;p&gt;Yours Sincerely,
                    &lt;p&gt;</st><strong class="bold"><st c="18508">{}</st></strong><st c="18511">
                &lt;/body&gt;
            &lt;/html&gt;
    """.format(</st><strong class="bold"><st c="18539">counselor, effective_date, patient, patient, counselor</st></strong><st c="18594">)
    return letter, 200
</st><code><st c="18818">add_url_rule()</st></code><st c="18832"> is not only confined to the decorated function views </st><a id="_idIndexMarker026"/><st c="18886">but is also necessary for </st><em class="italic"><st c="18912">class-based views</st></em><st c="18929">.</st></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/><st c="18930">Implementing class-based views</st></h2>
			<p><st c="18961">Another way to create </st><a id="_idIndexMarker027"/><st c="18984">the view layer is through Flask’s class-based view approach. </st><st c="19045">Unlike the Django framework, which uses mixin programming to implement its class-based views, Flask provides two API classes, namely </st><code><st c="19178">View</st></code><st c="19182"> and </st><code><st c="19187">MethodView</st></code><st c="19197">, that can directly subclass any custom </st><st c="19237">view implementations.</st></p>
			<p><st c="19258">The most common and generic class to implement HTTP </st><code><st c="19311">GET</st></code><st c="19314"> operations is the </st><code><st c="19333">View</st></code><st c="19337"> class from the </st><code><st c="19353">flask.views</st></code><st c="19364"> module. </st><st c="19373">It has a </st><code><st c="19382">dispatch_request()</st></code><st c="19400"> method that executes the request-response transactions like a typical view function. </st><st c="19486">Thus, subclasses must override this core method to implement their view transactions. </st><st c="19572">The following class, </st><code><st c="19593">ListUnpaidContractView</st></code><st c="19615">, renders a list of patients with payments due to </st><st c="19665">the clinic:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="19676">from flask.views import View</st></strong>
<strong class="bold"><st c="19705">class ListUnpaidContractView(View):</st></strong><strong class="bold"><st c="19741">def dispatch_request(self):</st></strong><st c="19769">
        contracts = select_all_unpaid_patient()
        return render_template("contract/ list_patient_contract.html", contracts=contracts)</st></pre>			<p><code><st c="19893">select_all_unpaid_patient()</st></code><st c="19921"> will provide the patient records from the database. </st><st c="19974">All these records will be rendered to the </st><code><st c="20016">list_patient_contract.html</st></code><st c="20042"> template. </st><st c="20053">Now, aside from overriding the </st><code><st c="20084">dispatch_request()</st></code><st c="20102"> method, </st><code><st c="20111">ListUnpaidContractView</st></code><st c="20133"> also inherits all the attributes and helper methods from the </st><code><st c="20195">View</st></code><st c="20199"> class, including the </st><code><st c="20221">as_view()</st></code><st c="20230"> static method, which creates a view name for the view. </st><st c="20286">During view registration, this view name will serve as the </st><code><st c="20345">view_func</st></code><st c="20354"> name </st><a id="_idIndexMarker028"/><st c="20360">of the custom </st><code><st c="20374">View</st></code><st c="20378"> class in the </st><code><st c="20392">add_url_rule()</st></code><st c="20406"> method with its mapped URL pattern. </st><st c="20443">The following </st><code><st c="20457">main.py</st></code><st c="20464"> snippet shows how to </st><st c="20486">register </st><code><st c="20495">ListUnpaidContractView</st></code><st c="20517">:</st></p>
			<pre class="source-code"><st c="20519">
app.</st><code><st c="20636">View</st></code><st c="20640"> subclass needs an HTTP </st><code><st c="20664">POST</st></code><st c="20668"> transaction, it has a built-class class attribute called </st><code><st c="20726">methods</st></code><st c="20733"> that accepts a list of HTTP methods the class needs to support. </st><st c="20798">Without it, the default is the </st><code><st c="20829">[ "GET" ]</st></code><st c="20838"> value. </st><st c="20846">Here is another custom </st><code><st c="20869">View</st></code><st c="20873"> class of our </st><em class="italic"><st c="20887">Online Personal Counselling System</st></em><st c="20921"> app that deletes existing patient contracts of </st><st c="20969">the clinic:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="20980">class DeleteContractByPIDView(View):</st></strong><strong class="bold"><st c="21017">methods = ['GET', 'POST']</st></strong><st c="21043">
    … … … … … …
    def dispatch_request(self):
       if request.method == "GET":
          pids = list_pid()
          return render_template("contract/ delete_patient_contract.html", pids=pids)
       else:
          pid = int(request.form['pid'])
          result = delete_patient_contract_pid(pid)
          if result == False:
               pids = list_pid()
               return render_template("contract/ delete_patient_contract.html", pids=pids)
          contracts = select_all_patient_contract()
          return render_template("contract/ list_patient_contract.html", contracts=contracts)</st></pre>			<p><code><st c="21523">DeleteContractByPIDView</st></code><st c="21547"> handles a typical form-handling transaction, which has both a </st><code><st c="21610">GET</st></code><st c="21613"> operation for loading the form page and a </st><code><st c="21656">POST</st></code><st c="21660"> operation to manage the submitted form data. </st><st c="21706">The </st><code><st c="21710">POST</st></code><st c="21714"> operation will verify if the patient ID submitted by the form page exists, and it will eventually delete the contract(s) of the patient using the patient ID and render an updated list </st><st c="21899">of contracts.</st></p>
			<p><st c="21912">Other than the </st><code><st c="21928">View</st></code><st c="21932"> class, an alternative API that</st><a id="_idIndexMarker029"/><st c="21963"> can also build view transactions is the </st><code><st c="22004">MethodView</st></code><st c="22014"> class. </st><st c="22022">This class is suitable for web forms since it has the built-in </st><code><st c="22085">GET</st></code><st c="22088"> and </st><code><st c="22093">POST</st></code><st c="22097"> hints or templates that subclasses need to define but without the need to identify the </st><code><st c="22185">GET</st></code><st c="22188"> transactions from </st><code><st c="22207">POST</st></code><st c="22211">, like in a view function. </st><st c="22238">Here is a view that uses </st><code><st c="22263">MethodView</st></code><st c="22273"> to manage the contracts of the patients in </st><st c="22317">the clinic:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="22328">from flask.views import MethodView</st></strong>
<strong class="bold"><st c="22363">class ContractView(MethodView):</st></strong><st c="22395">
    … … … … … …
    </st><strong class="bold"><st c="22407">def get(self):</st></strong><st c="22421">
        return render_template("contract/ add_patient_contract.html")
    </st><strong class="bold"><st c="22484">def post(self):</st></strong><st c="22499">
        pid = request.form['pid']
        approver = request.form['approver']
        … … … … … …
        result = insert_patient_contract(pid=int(pid), approved_by=approver, approved_date=approved_date, hcp=hcp, payment_mode=payment_mode, amount_paid=float(amount_paid), amount_due=float(amount_due))
        if result == False:
          return render_template("contract/ add_patient_contract.html")
        contracts = select_all_patient_contract()
        return render_template("contract/ list_patient_contract.html", contracts=contracts)</st></pre>			<p><st c="22977">The </st><code><st c="22982">MethodView</st></code><st c="22992"> class does not have a </st><code><st c="23015">methods</st></code><st c="23022"> class variable to indicate the HTTP methods supported by the view. </st><st c="23090">Instead, the subclass can select the appropriate HTTP hints from </st><code><st c="23155">MethodView</st></code><st c="23165">, which will then implement the required HTTP transactions of the custom </st><st c="23238">view class.</st></p>
			<p><st c="23249">Since </st><code><st c="23256">MethodView</st></code><st c="23266"> is a subclass of the </st><code><st c="23288">View</st></code><st c="23292"> class, it also has an </st><code><st c="23315">as_view()</st></code><st c="23324"> class method that creates a </st><code><st c="23353">view_func</st></code><st c="23362"> name of the view. </st><st c="23381">This is also necessary for </st><code><st c="23408">add_url_rule()</st></code><st c="23422"> registration.</st></p>
			<p><st c="23436">Aside from </st><code><st c="23448">GET</st></code><st c="23451"> and </st><code><st c="23456">POST</st></code><st c="23460">, the </st><code><st c="23466">MethodView</st></code><st c="23476"> class also provides the </st><code><st c="23501">PUT</st></code><st c="23504">, </st><code><st c="23506">PATCH</st></code><st c="23511">, and </st><code><st c="23517">DELETE</st></code><st c="23523"> method hints for API-based</st><a id="_idIndexMarker030"/><st c="23550"> applications. </st><code><st c="23565">MethodView</st></code><st c="23575"> is better than the </st><code><st c="23595">View</st></code><st c="23599"> API because it organizes the transactions according to HTTP methods and checks and executes these HTTP methods by itself at runtime. </st><st c="23733">In general, between the decorated view function and the class-based ones, the latter approach provides a complete Flask view component because of the attributes and built-in methods inherited by the view implementation from these API classes. </st><st c="23976">Although the decorated view function can support a flexible and open-ended strategy for scalable applications, it cannot provide an organized base functionality that can supply baseline view features to other related views, unlike in a class-based approach. </st><st c="24234">However, the choice still depends on the scope and requirements of </st><st c="24301">the application.</st></p>
			<p><st c="24317">Now that we’ve created and registered the routes, let’s scrutinize these view implementations and identify the</st><a id="_idIndexMarker031"/><st c="24428"> essential Flask components that </st><st c="24461">compose them.</st></p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/><st c="24474">Managing request and response data</st></h1>
			<p><st c="24509">At this point, we already know that routing is a mechanism for mapping view functions to their URLs. </st><st c="24611">But besides that, routing declares any valid functions to be view implementations that can manage the incoming request and </st><st c="24734">outgoing response.</st></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/><st c="24752">Retrieving the request object</st></h2>
			<p><st c="24782">Flask uses its </st><code><st c="24798">request</st></code><st c="24805"> object to carry </st><a id="_idIndexMarker032"/><st c="24822">cookies, headers, parameters, form data, form objects, authorization data, and other request-related details. </st><st c="24932">But the view function doesn’t need to declare a variable to auto-wire the request instance, just like in Django, because Flask has a built-in proxy object for it, the </st><code><st c="25099">request</st></code><st c="25106"> object, which is part of the </st><code><st c="25136">flask</st></code><st c="25141"> package. </st><st c="25151">The following view function takes the </st><code><st c="25189">username</st></code><st c="25197"> and </st><code><st c="25202">password</st></code><st c="25210"> request parameters and checks if the credentials are in </st><st c="25267">the database:</st></p>
			<pre class="source-code"><st c="25280">
from __main__ import app
from </st><strong class="bold"><st c="25311">flask</st></strong><st c="25316"> import </st><strong class="bold"><st c="25324">request</st></strong><st c="25331">, Response, render_template, redirect
from repository.user import validate_user
@app.route('/login/params')
def login_with_params():
    </st><strong class="bold"><st c="25464">username = request.args['username']</st></strong><strong class="bold"><st c="25499">password = request.args['password']</st></strong><st c="25535">
    result = validate_user(username, password)
    if result:
      resp = Response(
       response=render_template('/main.html'), status=200, content_type='text/html')
      return resp
    else:
        return redirect('/error')</st></pre>			<p><st c="25728">For instance, running the URL pattern of the given view function, </st><code><st c="25795">http://localhost:5000/login/params?username=sjctrags&amp;password=sjctrags2255</st></code><st c="25869">, will provide us with </st><code><st c="25892">sjctrags</st></code><st c="25900"> and </st><code><st c="25905">sjctrags2255</st></code><st c="25917"> as values when </st><code><st c="25933">request.args['username']</st></code><st c="25957"> and </st><code><st c="25962">request.args['password']</st></code><st c="25986"> are </st><st c="25991">accessed, respectively.</st></p>
			<p><st c="26014">Here is the complete list of objects </st><a id="_idIndexMarker033"/><st c="26052">and details that we can retrieve from the </st><code><st c="26094">Request</st></code><st c="26101"> object through its request </st><st c="26129">instance proxy:</st></p>
			<ul>
				<li><code><st c="26144">request.args</st></code><st c="26157">: Returns a </st><code><st c="26170">MultiDict</st></code><st c="26179"> class that carries URL arguments or request parameters from the </st><st c="26244">query string.</st></li>
				<li><code><st c="26257">request.form</st></code><st c="26270">: Returns a </st><code><st c="26283">MultiDict</st></code><st c="26292"> class that contains parameters from an HTML form or JavaScript’s </st><code><st c="26358">FormData</st></code><st c="26366"> object.</st></li>
				<li><code><st c="26374">request.data</st></code><st c="26387">: Returns request data in a byte stream that Flask couldn’t parse to form parameters and values due to an unrecognizable </st><st c="26509">mime type.</st></li>
				<li><code><st c="26519">request.files</st></code><st c="26533">: Returns a </st><code><st c="26546">MultiDict</st></code><st c="26555"> class containing all file objects from a form </st><st c="26602">with </st><code><st c="26607">enctype=multipart/form-data</st></code><st c="26634">.</st></li>
				<li><code><st c="26635">request.get_data()</st></code><st c="26654">: This function returns the request data in byte streams before </st><st c="26719">calling </st><code><st c="26727">request.data</st></code><st c="26739">.</st></li>
				<li><code><st c="26740">request.json</st></code><st c="26753">: Returns parsed JSON data when the incoming request has a </st><code><st c="26813">Content-Type</st></code><st c="26825"> header </st><st c="26833">of </st><code><st c="26836">application/json</st></code><st c="26852">.</st></li>
				<li><code><st c="26853">request.method</st></code><st c="26868">: Returns the HTTP </st><st c="26888">method name.</st></li>
				<li><code><st c="26900">request.values</st></code><st c="26915">: Returns the combined parameters of </st><code><st c="26953">args</st></code><st c="26957"> and </st><code><st c="26962">form</st></code><st c="26966"> and encounters collision problems when both </st><code><st c="27011">args</st></code><st c="27015"> and </st><code><st c="27020">form</st></code><st c="27024"> carry the same </st><st c="27040">parameter name.</st></li>
				<li><code><st c="27055">request.headers</st></code><st c="27071">: Returns request headers included in the </st><st c="27114">incoming request.</st></li>
				<li><code><st c="27131">request.cookies</st></code><st c="27147">: Returns all the cookies that are part of </st><st c="27191">the request.</st></li>
			</ul>
			<p><st c="27203">The following view function utilizes some of the given request objects to perform an HTTP </st><code><st c="27294">GET</st></code><st c="27297"> operation to fetch a user login </st><a id="_idIndexMarker034"/><st c="27330">application through an </st><code><st c="27353">ID</st></code><st c="27355"> value and an HTTP </st><code><st c="27374">POST</st></code><st c="27378"> operation to retrieve the user details, approve its preferred user role, and save the login details as new, valid </st><st c="27493">user credentials:</st></p>
			<pre class="source-code"><st c="27510">
from __main__ import app
from flask import render_template
from model.candidates import AdminUser, CounselorUser, PatientUser
from urllib.parse import parse_qsl
@app.route('/signup/approve', methods = ['POST'])
@app.route('/signup/approve/&lt;int:utype&gt;',methods = ['GET'])
def signup_approve(utype:int=None):
    if (request.method == 'GET'):
        </st><strong class="bold"><st c="27848">id = request.args['id']</st></strong><st c="27871">
        user = select_single_signup(id)
        … … … … … … …
    else:
        utype = int(utype)
        if int(utype) == 1:
            </st><strong class="bold"><st c="27963">adm = request.get_data()</st></strong><st c="27987">
            adm_dict = dict(parse_qsl(adm.decode('utf-8')))
            adm_model = AdminUser(**adm_dict)
            user_approval_service(int(utype), adm_model)
        elif int(utype) == 2:
            </st><strong class="bold"><st c="28137">cnsl = request.get_data()</st></strong><st c="28162">
            cnsl_dict = dict(parse_qsl(
                   cnsl.decode('utf-8')))
            cnsl_model = CounselorUser(**cnsl_dict)
            user_approval_service(int(utype), cnsl_model)
        elif int(utype) == 3:
            </st><strong class="bold"><st c="28322">pat = request.get_data()</st></strong><st c="28346">
            pat_dict = dict(parse_qsl(pat.decode('utf-8')))
            pat_model = PatientUser(**pat_dict)
            user_approval_service(int(utype), pat_model)
        return render_template('approved_user.html', message='approved'), 200</st></pre>			<p><st c="28545">Our application has a listing view that renders hyperlinks that can redirect users to this </st><code><st c="28637">signup_approve()</st></code><st c="28653"> form page with a context variable </st><code><st c="28688">id</st></code><st c="28690">, a code for a user type. </st><st c="28716">The view function retrieves the variable </st><code><st c="28757">id</st></code><st c="28759"> through </st><code><st c="28768">request.args</st></code><st c="28780">, checks what the user type </st><code><st c="28808">id</st></code><st c="28810"> is, and renders the appropriate page based on the user type detected. </st><st c="28881">The function also uses </st><code><st c="28904">request.method</st></code><st c="28918"> to check if the user request will pursue either the </st><code><st c="28971">GET</st></code><st c="28974"> or </st><code><st c="28978">POST</st></code><st c="28982"> transaction since the given view function caters to both HTTP methods, as defined in its </st><em class="italic"><st c="29072">dual</st></em><st c="29076"> route </st><a id="_idIndexMarker035"/><st c="29083">declaration. </st><st c="29096">When clicking the </st><code><st c="29150">POST</st></code><st c="29154"> transaction retrieves all the form parameters and values in a byte stream type via </st><code><st c="29238">request.get_data()</st></code><st c="29256">. It is decoded to a query string object and converted into a dictionary by </st><code><st c="29332">parse_sql</st></code><st c="29341"> from the </st><code><st c="29351">urllib.parse</st></code><st c="29363"> module.</st></p>
			<p><st c="29371">Now, if Flask can handle the request, it can also manage the outgoing response from the </st><st c="29460">view functions.</st></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/><st c="29475">Creating the response object</st></h2>
			<p><st c="29504">Flask uses </st><code><st c="29516">Response</st></code><st c="29524"> to generate a</st><a id="_idIndexMarker036"/><st c="29538"> client response for every request. </st><st c="29574">The following view function renders a form page using the </st><code><st c="29632">Response</st></code><st c="29640"> object:</st></p>
			<pre class="source-code"><st c="29648">
from flask import render_template, request, Response
@app.route('/admin/users/list')
def generate_admin_users():
    users = select_admin_join_user()
    user_list = [list(rec) for rec in users]
    content = '''&lt;html&gt;&lt;head&gt;
                    &lt;title&gt;User List&lt;/title&gt;
            &lt;/head&gt;&lt;body&gt;
                    &lt;h1&gt;List of Users&lt;/h1&gt;
                    &lt;p&gt;{}
            &lt;/body&gt;&lt;/html&gt;
           '''.format(user_list)
    </st><strong class="bold"><st c="29967">resp = Response(response=content, status=200,</st></strong> <strong class="bold"><st c="30012">content_type='text/html')</st></strong><st c="30038">
    return </st><code><st c="30050">Response</st></code><st c="30059"> is instantiated with its required constructor parameters and returned by the view function as a response object. </st><st c="30173">The following are the </st><st c="30195">required parameters:</st></p>
			<ul>
				<li><code><st c="30215">response</st></code><st c="30224">: Contains the content that needs to be rendered either in a string, byte stream, or iterable of either of the </st><st c="30336">two types.</st></li>
				<li><code><st c="30346">status</st></code><st c="30353">: Accepts the HTTP status code as an integer </st><st c="30399">or string.</st></li>
				<li><code><st c="30409">content_type</st></code><st c="30422">: Accepts the mime type of the response object that </st><st c="30475">needs rendering.</st></li>
				<li><code><st c="30491">headers</st></code><st c="30499">: A dictionary that contains the response header(s) that is/are necessary for the rendition process, such as </st><code><st c="30609">Access-Control-Allow-Origin</st></code><st c="30636">, </st><code><st c="30638">Content-Disposition</st></code><st c="30657">, </st><code><st c="30659">Origin</st></code><st c="30665">, </st><st c="30667">and </st><code><st c="30671">Accept</st></code><st c="30677">.</st></li>
			</ul>
			<p><st c="30678">But if the purpose is to render HTML pages, Flask has a </st><code><st c="30735">render_template()</st></code><st c="30752"> method that references an HTML template file that needs rendering. </st><st c="30820">The following route function, </st><code><st c="30850">signup_users_form()</st></code><st c="30869">, yields the content of a signup page – that is, </st><code><st c="30918">add_signup.html</st></code><st c="30933"> from </st><a id="_idIndexMarker037"/><st c="30939">the </st><code><st c="30943">/pages</st></code><st c="30949"> template folder – for new </st><st c="30976">user applicants:</st></p>
			<pre class="source-code"><st c="30992">
@app.route('/signup/form', methods= ['GET'])
def signup_users_form():
    resp = Response(  response=</st><strong class="bold"><st c="31089">render_template('add_signup.html')</st></strong><st c="31124">, status=200, content_type="text/html")
    return resp</st></pre>			<p><code><st c="31175">render_template()</st></code><st c="31193"> returns HTML content with its context data, if there is any, as a string. </st><st c="31268">To simplify the syntax, Flask allows us to return the method’s result and the </st><em class="italic"><st c="31346">status code</st></em><st c="31357"> instead of the </st><code><st c="31373">Response</st></code><st c="31381"> instance since the framework can automatically create a </st><code><st c="31438">Response</st></code><st c="31446"> instance from these details. </st><st c="31476">Like the previous examples, the following </st><code><st c="31518">signup_list_users()</st></code><st c="31537"> uses </st><code><st c="31543">render_template()</st></code><st c="31560"> to show the list of new user applications subject to </st><st c="31614">admin approval:</st></p>
			<pre class="source-code"><st c="31629">
@app.route('/signup/list', methods = ['GET'])
def signup_list_users():
    </st><code><st c="31845">render_template()</st></code><st c="31862"> can accept and pass context data to the template page. </st><st c="31918">The </st><code><st c="31922">candidates</st></code><st c="31932"> variable in this snippet handles an extracted list of records from the database needed by the template for content generation using the </st><strong class="bold"><st c="32069">Jinja2</st></strong><st c="32075"> engine.</st></p>
			<p class="callout-heading"><st c="32083">Jinja2</st></p>
			<p class="callout"><st c="32090">Jinja2 is Python’s fast, flexible, robust, expressive, and extensive templating engine for creating HTML, XML, LaTeX, and other supported formats for Flask’s </st><st c="32249">rendition purposes.</st></p>
			<p><st c="32268">On the other hand, Flask has a utility called </st><code><st c="32315">make_response()</st></code><st c="32330"> that can modify the response by changing headers and cookies before sending them to the client. </st><st c="32427">This method is suitable when the base response frequently undergoes some changes in its response headers and cookies. </st><st c="32545">The following code modifies the content type of the original response to XLS with a</st><a id="_idIndexMarker038"/><st c="32628"> given filename – in this </st><st c="32654">case, </st><code><st c="32660">question.xls</st></code><st c="32672">:</st></p>
			<pre class="source-code"><st c="32674">
@app.route('/exam/details/list')
def report_exam_list():
    exams = list_exam_details()
    </st><strong class="bold"><st c="32760">response = make_response(</st></strong> <strong class="bold"><st c="32785">render_template('exam/list_exams.html',</st></strong><strong class="bold"><st c="32825">exams=exams), 200)</st></strong><strong class="bold"><st c="32844">headers = dict()</st></strong><strong class="bold"><st c="32861">headers['Content-Type'] = 'application/vnd.ms-excel'</st></strong><strong class="bold"><st c="32914">headers['Content-Disposition'] =</st></strong> <strong class="bold"><st c="32947">'attachment;filename=questions.xls'</st></strong><strong class="bold"><st c="32983">response.headers = headers</st></strong><st c="33010">
    return response</st></pre>			<p><st c="33026">Flask will require additional Python extensions when serializing and yielding PDF, XLSX, DOCX, RTF, and other complex content types. </st><st c="33160">But for old and simple mime type values such as </st><code><st c="33208">application/msword</st></code><st c="33226"> and </st><code><st c="33231">application/vnd.ms-excel</st></code><st c="33255">, Flask can easily and seamlessly serialize the content since Python has a built-in serializer for them. </st><st c="33360">Other than mime types, Flask also supports adding web cookies for route functions. </st><st c="33443">The following </st><code><st c="33457">assign_exam()</st></code><st c="33470"> route shows how to add cookies to the </st><code><st c="33509">response</st></code><st c="33517"> value that renders a form for scheduling and assigning counseling exams for patients with their </st><st c="33614">respective counselors:</st></p>
			<pre class="source-code"><st c="33636">
@app.route('/exam/assign', methods=['GET', 'POST'])
def assign_exam():
    if request.method == 'GET':
        cids = list_cid()
        pids = list_pid()
        </st><strong class="bold"><st c="33772">response = make_response( render_template('exam/assign_exam_form.html', pids=pids, cids=cids), 200)</st></strong><strong class="bold"><st c="33871">response.set_cookie('exam_token', str(uuid4()))</st></strong><st c="33919">
        return response, 200
    else:
        id = int(request.form['id'])
        cid = request.form['cid']
        pid = int(request.form['pid'])
        exam_date = request.form['exam_date']
        duration = int(request.form['duration'])
        result = insert_question_details(id=id, cid=cid, pid=pid, exam_date=exam_date, duration=duration)
        if result:
            </st><strong class="bold"><st c="34221">task_token = request.cookies.get('exam_token')</st></strong><st c="34267">
            task = "exam assignment (task id {})".format(task_token)
            return redirect(url_for('redirect_success_exam',        message=task ))
        else:
            return redirect('/exam/task/error')</st></pre>			<p><st c="34431">The </st><code><st c="34436">Response</st></code><st c="34444"> instance has a </st><code><st c="34460">set_cookie()</st></code><st c="34472"> method that creates cookies before the view dispatches the</st><a id="_idIndexMarker039"/><st c="34531"> response to the client. </st><st c="34556">It also has </st><code><st c="34568">delete_cookie()</st></code><st c="34583">, which deletes a particular cookie before yielding the response. </st><st c="34649">To retrieve the cookies, </st><code><st c="34674">request.cookies</st></code><st c="34689"> has a </st><code><st c="34696">get()</st></code><st c="34701"> method that can retrieve the cookie value through its cookie name. </st><st c="34769">The given </st><code><st c="34779">assign_exam()</st></code><st c="34792"> route shows how the </st><code><st c="34813">get()</st></code><st c="34818"> method</st><a id="_idIndexMarker040"/><st c="34825"> retrieves </st><code><st c="34836">exam_cookie</st></code><st c="34847"> in its </st><code><st c="34855">POST</st></code><st c="34859"> transaction.</st></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/><st c="34872">Implementing page redirection</st></h2>
			<p><st c="34902">Sometimes, it is ideal for the route transaction to redirect the user to another view page using the </st><code><st c="35004">redirect()</st></code><st c="35014"> utility</st><a id="_idIndexMarker041"/><st c="35022"> method instead of building its own </st><code><st c="35058">Response</st></code><st c="35066"> instance. </st><st c="35077">Flask redirection requires a URL pattern of the destination to where the view function will redirect. </st><st c="35179">For instance, in the previous </st><code><st c="35209">assign_exam()</st></code><st c="35222"> route, the output of its </st><code><st c="35248">POST</st></code><st c="35252"> transaction is not a </st><code><st c="35274">Response</st></code><st c="35282"> instance but a </st><code><st c="35298">redirect()</st></code><st c="35308"> method:</st></p>
			<pre class="source-code"><st c="35316">
@app.route('/exam/assign', methods=['GET', 'POST'])
def assign_exam():
        … … … … … …
        if result:
            task_token = request.cookies.get('exam_token')
            task = "exam assignment (task id {})".format(task_token)
            </st><strong class="bold"><st c="35515">return redirect(url_for('redirect_success_exam',</st></strong><strong class="bold"><st c="35563">message=task ))</st></strong><st c="35579">
        else:
            </st><code><st c="35631">result</st></code><st c="35637"> variable is </st><code><st c="35650">False</st></code><st c="35655">, redirection to an error view called </st><code><st c="35693">/exam/task/error</st></code><st c="35709"> will occur. </st><st c="35722">Otherwise, the route will redirect to an endpoint or view name called </st><code><st c="35792">redirect_success_exam</st></code><st c="35813">. Every </st><code><st c="35821">@route</st></code><st c="35827"> has an endpoint equivalent, by default, to its view function name. </st><st c="35895">So, </st><code><st c="35899">redirect_success_exam</st></code><st c="35920"> is the function name of a route with the </st><st c="35962">following implementation:</st></p>
			<pre class="source-code"><st c="35987">
@app.route('/exam/success', methods=['GET'])
def </st><strong class="bold"><st c="36037">redirect_success_exam</st></strong><st c="36058">():
    </st><strong class="bold"><st c="36063">message = request.args['message']</st></strong><st c="36096">
    return render_template('exam/redirect_success_view.html', message=message)</st></pre>			<p><code><st c="36171">url_for()</st></code><st c="36181">, which is used in the </st><code><st c="36204">assign_exam()</st></code><st c="36217"> view, is a route handler that allows us to pass the endpoint name of the destination view to </st><code><st c="36311">redirect()</st></code><st c="36321"> instead of passing the actual URL pattern of the destination. </st><st c="36384">It can also pass context data to the Jinja2 template of the redirected page or values to path variables if the view uses a dynamic URL pattern. </st><st c="36528">The </st><code><st c="36532">redirect_success_exam()</st></code><st c="36555"> function shows a perfect scenario of context data passing, where it uses </st><code><st c="36629">request.args</st></code><st c="36641"> to access a message context passed from </st><code><st c="36682">assign_exam()</st></code><st c="36695">, which is where the redirection </st><st c="36728">call originated.</st></p>
			<p><st c="36744">More content negotiations </st><a id="_idIndexMarker042"/><st c="36771">and how to serialize various mime types for responses will be showcased in the succeeding chapters, but in the meantime, let’s scrutinize the view templates of our route functions. </st><st c="36952">View templates are essential for web-based applications because all form-handling transactions, report generation, and page generation depend on effective </st><st c="37107">dynamic templates.</st></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/><st c="37125">Implementing view templates</st></h1>
			<p><st c="37153">Jinja2 is the default templating engine of the Flask framework and is used to create HTML, XML, LaTeX, and markup </st><a id="_idIndexMarker043"/><st c="37268">documents. </st><st c="37279">It is a simple, extensive, fast, and easy-to-use templating approach with powerful features such as layout capabilities, built-in programming constructs, support for asynchronous operations, context data filtering, and utility for </st><st c="37510">unit testing.</st></p>
			<p><st c="37523">Firstly, Flask requires all template files to be in the </st><code><st c="37580">templates</st></code><st c="37589"> directory of the main project. </st><st c="37621">To change this setting, the </st><code><st c="37649">Flask()</st></code><st c="37656"> constructor has a </st><code><st c="37675">template_folder</st></code><st c="37690"> parameter that can set and replace the default directory with another one. </st><st c="37766">Our prototype, for instance, has the following Flask instantiation that overrides the default templates directory with a more high-level </st><st c="37903">directory name:</st></p>
			<pre class="source-code"><st c="37918">
from flask import Flask
app = Flask(__name__, </st><code><st c="38049">pages</st></code><st c="38054"> directory when calling the template files through the </st><code><st c="38109">render_template()</st></code><st c="38126"> method.</st></p>
			<p><st c="38134">When it comes to syntax, Jinja2 has a placeholder (</st><code><st c="38186">{{ }}</st></code><st c="38192">) that renders dynamic content passed by the view functions to its template file. </st><st c="38275">It also has a Jinja block (</st><code><st c="38302">{% %}</st></code><st c="38308">) that supports control structures such as loops, conditional statements, macros, and template inheritance. </st><st c="38417">In the previous route function, </st><code><st c="38449">assign_exam()</st></code><st c="38462">, the </st><code><st c="38468">GET</st></code><st c="38471"> transaction retrieves a list of counselor IDs (</st><code><st c="38519">cids</st></code><st c="38524">) and patient IDs (</st><code><st c="38544">pids</st></code><st c="38549">) from the database and passes them to the </st><code><st c="38593">assign_exam_form.html</st></code><st c="38614"> template found in the </st><code><st c="38637">exam</st></code><st c="38641"> subfolder</st><a id="_idIndexMarker044"/><st c="38651"> of the </st><code><st c="38659">pages</st></code><st c="38664"> directory. </st><st c="38676">The following snippet shows the implementation of the </st><code><st c="38730">assign_exam_form.html</st></code> <st c="38751">view template:</st></p>
			<pre class="source-code"><st c="38766">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;&lt;head&gt;&lt;title&gt;Patient's Score Form&lt;/title&gt;
    &lt;/head&gt;&lt;body&gt;
        &lt;form action="/exam/score" method="POST"&gt;
           &lt;h3&gt;Exam Score&lt;/h3&gt;
           &lt;label for="qid"&gt;Enter Questionnaire ID:&lt;/label&gt;
           </st><strong class="bold"><st c="38966">&lt;select name="qid"&gt;</st></strong><strong class="bold"><st c="38985">{% for id in qids %}</st></strong><strong class="bold"><st c="39006">&lt;option value="{{ id }}"&gt;{{ id }}&lt;/option&gt;</st></strong><strong class="bold"><st c="39049">{% endfor %}</st></strong><strong class="bold"><st c="39062">&lt;/select&gt;</st></strong><st c="39072">&lt;br/&gt;
           &lt;label for="pid"&gt;Enter patient ID:&lt;/label&gt;
           </st><strong class="bold"><st c="39122">&lt;select name="pid"&gt;</st></strong><strong class="bold"><st c="39141">{% for id in pids %}</st></strong><strong class="bold"><st c="39162">&lt;option value="{{ id }}"&gt;{{ id }}&lt;/option&gt;</st></strong><strong class="bold"><st c="39205">{% endfor %}</st></strong><strong class="bold"><st c="39218">&lt;/select&gt;</st></strong><st c="39228">&lt;br/&gt;
           … … … … … …
           &lt;input type="submit" value="Assign Exam"/&gt;
        &lt;/form&gt;&lt;/body&gt;
&lt;/html&gt;</st></pre>			<p><st c="39311">This template uses the Jinja block to iterate all the IDs and embed each in the </st><code><st c="39392">&lt;option&gt;</st></code><st c="39400"> tag of the </st><code><st c="39412">&lt;select&gt;</st></code><st c="39420"> component with the </st><st c="39440">placeholder operator.</st></p>
			<p><st c="39461">More about Jinja2 and Flask 3.x will be </st><a id="_idIndexMarker045"/><st c="39502">covered in </st><a href="B19383_02.xhtml#_idTextAnchor047"><em class="italic"><st c="39513">Chapter 2</st></em></a><st c="39522">, but for now, let’s delve into how Flask can implement the most common type of web-based transaction – that is, by capturing form data from </st><st c="39663">the client.</st></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/><st c="39674">Creating web forms</st></h1>
			<p><st c="39693">In Flask, we can</st><a id="_idIndexMarker046"/><st c="39710"> choose from the following two approaches when implementing view functions for form </st><st c="39794">data processing:</st></p>
			<ul>
				<li><st c="39810">Creating two separate routes, one for the </st><code><st c="39853">GET</st></code><st c="39856"> operation and the other for the </st><code><st c="39889">POST</st></code><st c="39893"> transaction, as shown for the following user </st><st c="39939">signup transaction:</st><pre class="source-code">
<strong class="bold"><st c="39958">@app.route('/signup/form', methods= ['GET'])</st></strong>
<strong class="bold"><st c="40003">def signup_users_form():</st></strong><st c="40028">
    resp = Response(response= render_template('add_signup.html'), status=200, content_type="text/html")
    return resp
</st><strong class="bold"><st c="40141">@app.route('/signup/submit', methods= ['POST'])</st></strong>
<strong class="bold"><st c="40188">def signup_users_submit():</st></strong><st c="40215">
    username = request.form['username']
    password = request.form['password']
    user_type = request.form['utype']
    firstname = request.form['firstname']
    lastname = request.form['lastname']
    cid = request.form['cid']
    insert_signup(user=username, passw=password, utype=user_type, fname=firstname, lname=lastname, cid=cid)
    return render_template('add_signup_submit.html', message='Added new user!'), 200</st></pre></li>				<li><st c="40606">Utilizing only one view function for both the </st><code><st c="40653">GET</st></code><st c="40656"> and </st><code><st c="40661">POST</st></code><st c="40665"> transactions, as shown in the </st><a id="_idIndexMarker047"/><st c="40696">previous </st><code><st c="40705">signup_approve()</st></code><st c="40721"> route and in the following </st><code><st c="40749">assign_exam()</st></code><st c="40762"> view:</st><pre class="source-code">
<strong class="bold"><st c="40768">@app.route('/exam/assign', methods=['GET', 'POST'])</st></strong>
<strong class="bold"><st c="40820">def assign_exam():</st></strong><st c="40839">
    if request.method == 'GET':
       cids = list_cid()
       pids = list_pid()
       response = make_response(render_template('exam/assign_exam_form.html', pids=pids, cids=cids), 200)
       response.set_cookie('exam_token', str(uuid4()))
       return response, 200
    else:
       id = int(request.form['id'])
       … … … … … …
       duration = int(request.form['duration'])
       result = insert_question_details(id=id, cid=cid, pid=pid, exam_date=exam_date, duration=duration)
       if result:
           exam_token = request.cookies.get('exam_token')
           return redirect(url_for('introduce_exam', message=str(exam_token)))
       else:
           return redirect('/error')</st></pre></li>			</ul>
			<p><st c="41415">Compared to the first, the second approach needs </st><code><st c="41465">request.method</st></code><st c="41479"> to separate </st><code><st c="41492">GET</st></code><st c="41495"> from the </st><code><st c="41505">POST</st></code><st c="41509"> transaction.</st></p>
			<p><st c="41522">In setting up the form template, binding context data to the form components through </st><code><st c="41608">render_template()</st></code><st c="41625"> is a fast way to provide the form with parameters with default values. </st><st c="41697">The form model must derive the names of its attributes from the form parameters to establish a </st><a id="_idIndexMarker048"/><st c="41792">successful mapping, such as in the </st><code><st c="41827">signup_approve()</st></code><st c="41843"> route. </st><st c="41851">When it comes to retrieving the form data, the </st><code><st c="41898">request</st></code><st c="41905"> proxy has a </st><code><st c="41918">form</st></code><st c="41922"> dictionary object that can store form parameters and their data while its  </st><code><st c="41997">get_data()</st></code><st c="42007"> function can access the entire query string in byte stream type. </st><st c="42073">After a successful </st><code><st c="42092">POST</st></code><st c="42096"> transaction, the view function can use </st><code><st c="42136">render_template()</st></code><st c="42153"> to load a success page or go back to the form page. </st><st c="42206">It may also apply redirection to bring the client to </st><st c="42259">another view.</st></p>
			<p><st c="42272">But what happens to the form data after form submission? </st><st c="42330">Usually, form parameter values are rendered as request attributes, stored as values of the session scope, or saved into a data store using a data persistency mechanism. </st><st c="42499">Let’s explore how Flask can manage data from user requests using a relational database such </st><st c="42591">as PostgreSQL.</st></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/><st c="42605">Building the data layer with PostgreSQL</st></h1>
			<p><code><st c="42795">psycopg2-binary</st></code><st c="42810"> extension module. </st><st c="42829">To install this extension module into the </st><code><st c="42871">venv</st></code><st c="42875">, run the</st><a id="_idIndexMarker050"/> <st c="42884">following command:</st></p>
			<pre class="console"><st c="42903">
pip install psycopg2-binary</st></pre>			<p><st c="42931">Now, we can write an approach to establish a connection to the </st><st c="42995">PostgreSQL database.</st></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/><st c="43015">Setting up database connectivity</st></h2>
			<p><st c="43048">There are multiple ways to create a connection to a database, but this chapter will showcase a Pythonic way to </st><a id="_idIndexMarker051"/><st c="43160">extract that connection using a custom decorator. </st><st c="43210">In the project’s </st><code><st c="43227">/config</st></code><st c="43234"> directory, there is a </st><code><st c="43257">connect_db</st></code><st c="43267"> decorator that uses </st><code><st c="43288">psycopgy2.connect()</st></code><st c="43307"> to establish connectivity to the </st><code><st c="43341">opcs</st></code><st c="43345"> database of our prototype. </st><st c="43373">Here is the implementation of this </st><st c="43408">custom decorator:</st></p>
			<pre class="source-code"><st c="43425">
import psycopg2
import functools
from os import environ
def connect_db(func):
    @functools.wraps(func)
    </st><strong class="bold"><st c="43527">def repo_function(*args, **kwargs):</st></strong><strong class="bold"><st c="43562">conn = psycopg2.connect(</st></strong><strong class="bold"><st c="43587">host=environ.get('DB_HOST'),</st></strong><strong class="bold"><st c="43616">database=environ.get('DB_NAME'),</st></strong><strong class="bold"><st c="43649">port=environ.get('DB_PORT'),</st></strong><strong class="bold"><st c="43678">user = environ.get('DB_USER'),</st></strong><strong class="bold"><st c="43709">password = environ.get('DB_PASS'))</st></strong><strong class="bold"><st c="43744">resp = func(conn, *args, **kwargs)</st></strong><st c="43779">
        conn.commit()
        conn.close()
        return resp
    return </st><code><st c="43894">conn</st></code><st c="43898">, to a repository function and commits all the changes to the database after a transaction’s successful execution. </st><st c="44013">Also, it will close the database connection at the end of the process. </st><st c="44084">All the database details, such as </st><code><st c="44118">DB_HOST</st></code><st c="44125">, </st><code><st c="44127">DB_NAME</st></code><st c="44134">, and </st><code><st c="44140">DB_PORT</st></code><st c="44147">, are stored as environment variables inside a </st><code><st c="44194">.env</st></code><st c="44198"> file. </st><st c="44205">To retrieve them using the </st><code><st c="44232">environ</st></code><st c="44239"> dictionary of the </st><code><st c="44258">os</st></code><st c="44260"> module, run the following command</st><a id="_idIndexMarker052"/><st c="44294"> to install the </st><st c="44310">required extension:</st></p>
			<pre class="console"><st c="44329">
pip install python-dotenv</st></pre>			<p><st c="44355">However, there are other ways to manage these custom and built-in configuration variables instead of storing them as </st><code><st c="44473">.env</st></code><st c="44477"> variables. </st><st c="44489">The next topic will expound on this, but first, let’s apply </st><code><st c="44549">@connect_db</st></code><st c="44560"> to our </st><st c="44568">repository layer.</st></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/><st c="44585">Implementing the repository layer</st></h2>
			<p><st c="44619">The following </st><code><st c="44634">insert_signup()</st></code><st c="44649"> transaction </st><a id="_idIndexMarker053"/><st c="44662">adds a new user signup record to the database. </st><st c="44709">It gets the </st><code><st c="44721">conn</st></code><st c="44725"> instance from the </st><code><st c="44744">@connect_db</st></code><st c="44755"> decorator. </st><st c="44767">Our application has no </st><code><st c="44845">psycopg2</st></code><st c="44853"> driver to perform the </st><a id="_idIndexMarker054"/><st c="44876">CRUD operation. </st><st c="44892">The </st><code><st c="44896">cursor</st></code><st c="44902"> instance created by </st><code><st c="44923">conn</st></code><st c="44927"> executes the </st><em class="italic"><st c="44941">INSERT</st></em><st c="44947"> statement of the following transaction with form data provided by its </st><st c="45018">view function:</st></p>
			<pre class="source-code"><st c="45032">
from config.db import connect_db
from typing import Dict, Any, List
</st><strong class="bold"><st c="45101">@connect_db</st></strong><st c="45112">
def insert_signup(</st><strong class="bold"><st c="45131">conn</st></strong><st c="45136">, user:str, passw:str, utype:str, fname:str, lname:str, cid:str) -&gt; bool:
    try:
        </st><strong class="bold"><st c="45215">cur = conn.cursor()</st></strong><st c="45234">
        sql = 'INSERT INTO signup (username, password, user_type, firstname, lastname, cid) VALUES (%s, %s, %s, %s, %s, %s)'
        values = (user, passw, utype, fname, lname, cid)
        </st><strong class="bold"><st c="45401">cur.execute(sql, values)</st></strong><strong class="bold"><st c="45425">cur.close()</st></strong><st c="45437">
        return True
    except Exception as e:
        cur.close()
        print(e)
    return False</st></pre>			<p><code><st c="45506">cursor</st></code><st c="45513"> is an object derived from </st><code><st c="45540">conn</st></code><st c="45544"> that uses a database session to perform insert, update, delete, and fetch operations. </st><st c="45631">So, just like </st><code><st c="45645">insert_signup()</st></code><st c="45660">, the following transaction</st><a id="_idTextAnchor038"/><a id="_idTextAnchor039"/><st c="45687"> uses </st><code><st c="45693">cursor</st></code><st c="45699"> again to </st><a id="_idIndexMarker055"/><st c="45709">execute the </st><em class="italic"><st c="45721">UPDATE</st></em><st c="45727"> statement:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="45738">@connect_db</st></strong><st c="45750">
def update_signup(</st><strong class="bold"><st c="45769">conn</st></strong><st c="45774">, id:int, details:Dict[str, Any]) -&gt; bool:
    try:
        </st><strong class="bold"><st c="45822">cur = conn.cursor()</st></strong><st c="45841">
        params = ['{} = %s'.format(key) for key in details.keys()]
        values = tuple(details.values())
        sql = 'UPDATE signup SET {} where id = {}'.format(', '.join(params), id);
        </st><strong class="bold"><st c="46008">cur.execute(sql, values)</st></strong><strong class="bold"><st c="46032">cur.close()</st></strong><st c="46044">
        return True
    except Exception as e:
        cur.close()
        print(e)
    return False</st></pre>			<p><st c="46113">To complete the CRUD operations for the </st><code><st c="46154">signup</st></code><st c="46160"> table, here is the </st><em class="italic"><st c="46180">DELETE</st></em><st c="46186"> transaction from </st><st c="46204">our application:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="46220">@connect_db</st></strong><st c="46232">
def delete_signup(conn, id) -&gt; bool:
    try:
        </st><strong class="bold"><st c="46275">cur = conn.cursor()</st></strong><st c="46294">
        sql = 'DELETE FROM signup WHERE id = %s'
        values = (id, )
        </st><strong class="bold"><st c="46352">cur.execute(sql, values)</st></strong><strong class="bold"><st c="46376">cur.close()</st></strong><st c="46388">
        return True
    except Exception as e:
        cur.close()
        print(e)
    return False</st></pre>			<p><st c="46457">The use of an ORM to build the model layer </st><a id="_idIndexMarker056"/><st c="46501">will be part of </st><a href="B19383_02.xhtml#_idTextAnchor047"><em class="italic"><st c="46517">Chapter 2</st></em></a><st c="46526">’s discussions. </st><st c="46543">For now, the views and services of our application rely on a repository layer that manages PostgreSQL data directly through the </st><code><st c="46671">psycopg2</st></code><st c="46679"> driver.</st></p>
			<p><st c="46687">After creating the repository layer, many applications can build a service layer to provide loose coupling between the CRUD operations and </st><st c="46827">the views.</st></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor040"/><st c="46837">Creating the service layer</st></h2>
			<p><st c="46864">The service layer of the </st><a id="_idIndexMarker057"/><st c="46890">application builds the business logic of the view functions and the repository. </st><st c="46970">Instead of loading the view functions with transaction-related and business processes, we place all these implementations in the service layer by creating lists of all the counselor and patient IDs, validating where to persist the newly approved user, and creating a list of patients who excelled in the examinations. </st><st c="47288">The following service function evaluates and records </st><a id="_idIndexMarker058"/><st c="47341">patients’ </st><st c="47351">exam scores:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="47363">def record_patient_exam(formdata:Dict[str, Any]) -&gt; bool:</st></strong><st c="47421">
    try:
        pct = round((</st><strong class="bold"><st c="47440">formdata['score']</st></strong><st c="47458"> / </st><strong class="bold"><st c="47461">formdata['total']</st></strong><st c="47478">) * 100, 2)
        status = None
        if (pct &gt;= 70):
            status = 'passed'
        elif (pct &lt; 70) and (pct &gt;= 55):
            status = 'conditional'
        else:
            status = 'failed'
        </st><strong class="bold"><st c="47619">insert_patient_score(pid=formdata['pid'],</st></strong> <strong class="bold"><st c="47660">qid=formdata['qid'], score=formdata['score'],</st></strong> <strong class="bold"><st c="47706">total=formdata['total'], status=status,</st></strong> <strong class="bold"><st c="47746">percentage=pct)</st></strong><st c="47762">
        return True
    except Exception as e:
        print(e)
    return False</st></pre>			<p><st c="47819">Instead of directly accessing </st><code><st c="47850">insert_patient_score()</st></code><st c="47872"> to save patient exam scores, </st><code><st c="47902">record_score()</st></code><st c="47916"> accesses the </st><code><st c="47930">record_patient_exam()</st></code><st c="47951"> service to compute some formulas before invoking </st><code><st c="48001">insert_patient_score()</st></code><st c="48023"> from the repository layer for record insertion. </st><st c="48072">The service lessens some friction between the database transactions and the view layer. </st><st c="48160">The following snippet is the view function that accesses the </st><code><st c="48221">record_patient_exam()</st></code><st c="48242"> service for record exam </st><st c="48267">record insertion:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="48284">@app.route('/exam/score', methods=['GET', 'POST'])</st></strong>
<strong class="bold"><st c="48335">def record_score():</st></strong><st c="48355">
    if request.method == 'GET':
        </st><strong class="bold"><st c="48384">pids = list_pid()</st></strong><strong class="bold"><st c="48401">qids = list_qid()</st></strong><st c="48419">
        return render_template( 'exam/add_patient_score_form.html', pids=pids, qids=qids), 200
    else:
        params = dict()
        params['pid'] = int(request.form['pid'])
        params['qid'] = int(request.form['qid'])
        params['score'] = float(request.form['score'])
        params['total'] = float(request.form['total'])
        </st><strong class="bold"><st c="48705">result = record_patient_exam(params)</st></strong><st c="48741">
        … … … … … … …
        else:
            return redirect('/exam/task/error')</st></pre>			<p><st c="48796">Aside from calling </st><code><st c="48816">record_patient_exam()</st></code><st c="48837">, it also utilizes the </st><code><st c="48860">list_pid()</st></code><st c="48870"> and </st><code><st c="48875">list_qid()</st></code><st c="48885"> services to retrieve the IDs. </st><st c="48916">The use of services can help separate the abstraction and use cases from the route functions, which has a beneficial impact on the scope, clean coding, and runtime </st><a id="_idIndexMarker059"/><st c="49080">performance of the routes. </st><st c="49107">Moreover, the project structure can also contribute to clear business flow, maintainability, flexibility, </st><st c="49213">and adaptability.</st></p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor041"/><st c="49230">Managing the project structure</st></h1>
			<p><st c="49261">Flask provides developers </st><a id="_idIndexMarker060"/><st c="49288">with the convenience of building their desired project structure. </st><st c="49354">It is open to any design patterns and architectural strategies for building a project directory because of its Pythonic characteristics. </st><st c="49491">The focus of this discussion revolves around setting up our </st><em class="italic"><st c="49551">Online Personal Counseling System</st></em><st c="49584"> application using the simple and single-structured project approach while highlighting the different configuration </st><st c="49700">variable setups.</st></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/><st c="49716">Building the directory structure</st></h2>
			<p><st c="49749">The first aspect to consider in</st><a id="_idIndexMarker061"/><st c="49781"> building the project structure is the level of complexity of the project scope. </st><st c="49862">Since our project focuses only on small-scale clientele, a typical </st><em class="italic"><st c="49929">single-structured</st></em><st c="49946"> approach is enough to cater to a less scalable application. </st><st c="50007">Second, we must ensure the proper layering or breakdown of various project components from the view layer down to the test modules so that the developers can identify what parts to prioritize, maintain, bug-fix, and test. </st><st c="50229">The following is a screenshot of the directory structure of </st><st c="50289">our prototype:</st></p>
			<div><div><img src="img/B19383_01_004.jpg" alt="Figure 1.4 – The single-structured project directory"/><st c="50303"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="50319">Figure 1.4 – The single-structured project directory</st></p>
			<p><a href="B19383_02.xhtml#_idTextAnchor047"><em class="italic"><st c="50371">Chapter 2</st></em></a><st c="50381"> will discuss other project structure techniques, especially when applications are scalable </st><st c="50473">and complex.</st></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/><st c="50485">Setting up a development environment</st></h2>
			<p><st c="50522">A Flask application, by default, is production-ready, even though its server, the Werkzeug’s built-in server, is not. </st><st c="50641">We need to replace it with an enterprise-grade server to be fully ready for </st><a id="_idIndexMarker062"/><st c="50717">production setup. </st><st c="50735">However, our goal is to set up a Flask project with a development environment that we can sample and experiment on with various features and test cases. </st><st c="50888">There are three ways to set up a Flask 3.x project for development and </st><st c="50959">testing purposes:</st></p>
			<ul>
				<li><st c="50976">Running the server with </st><code><st c="51001">app.run(debug=True)</st></code> <st c="51020">in </st><code><st c="51024">main.py</st></code><st c="51031">.</st></li>
				<li><st c="51032">Setting the </st><code><st c="51045">FLASK_DEBUG</st></code><st c="51056"> and </st><code><st c="51061">TESTING</st></code><st c="51068"> built-in configuration variables to </st><code><st c="51105">true</st></code><st c="51109"> in the </st><st c="51117">configuration file.</st></li>
				<li><st c="51136">Running the application with the </st><code><st c="51170">flask run --</st></code><code><st c="51182">debug</st></code><st c="51188"> command.</st></li>
			</ul>
			<p><st c="51197">Setting the development environment will also enable automatic reloading and the default debugger of the framework. </st><st c="51314">However, turn off debugging mode after deploying the application to production to avoid security risks for the applications and software logging problems. </st><st c="51469">The following screenshot shows the server log when running a Flask project with a development </st><st c="51563">environment setup:</st></p>
			<div><div><img src="img/B19383_01_005.jpg" alt="Figure 1.5 – The server log of Flask’s built-in server"/><st c="51581"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="51745">Figure 1.5 – The server log of Flask’s built-in server</st></p>
			<p><em class="italic"><st c="51799">Figure 1</st></em><em class="italic"><st c="51808">.5</st></em><st c="51810"> shows that debug mode is set to </st><code><st c="51843">ON</st></code><st c="51845"> and that the debugger is enabled and given a </st><code><st c="51891">PIN</st></code><st c="51894"> value.</st></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/><st c="51901">Implementing the main.py module</st></h2>
			<p><st c="51933">When creating a simple </st><a id="_idIndexMarker063"/><st c="51957">project like our specimen, the main module usually contains the Flask instantiation and some of its parameters (for example, </st><code><st c="52082">template_folder</st></code><st c="52097"> for the new directory of the HTML templates) and the required imports of the </st><a id="_idIndexMarker064"/><st c="52175">views below it. </st><st c="52191">The following is the complete code of our </st><code><st c="52233">main.py</st></code><st c="52240"> file:</st></p>
			<pre class="source-code"><st c="52246">
from flask import Flask
from converter.date_converter import DateConverter
</st><strong class="bold"><st c="52322">app = Flask(__name__, template_folder='pages')</st></strong>
<strong class="bold"><st c="52368">app.url_map.converters['date'] = DateConverter</st></strong><st c="52415">
@app.route('/', methods = ['GET'])
def index():
    return "This is an online … counseling system (OPCS)"
</st><strong class="bold"><st c="52518">import views.index</st></strong>
<strong class="bold"><st c="52536">import views.certificates</st></strong>
<strong class="bold"><st c="52562">import views.signup</st></strong>
<strong class="bold"><st c="52582">import views.examination</st></strong>
<strong class="bold"><st c="52607">import views.reports</st></strong>
<strong class="bold"><st c="52628">import views.admin</st></strong>
<strong class="bold"><st c="52647">import views.login</st></strong>
<strong class="bold"><st c="52666">import views.profile</st></strong><st c="52687">
app.add_url_rule('/certificate/terminate/&lt;string:counselor&gt;/&lt;date:effective_date&gt;/&lt;string:patient&gt;', 'show_honor_dissmisal', views.certificates.show_honor_dissmisal)
</st><code><st c="53086">app</st></code><st c="53089"> instance of the main module while the main module has the imports to the views declared at the beginning. </st><st c="53196">This occurrence is called a circular dependency between two modules importing components from each other, which leads to some circular import</st><a id="_idIndexMarker065"/><st c="53337"> issues. </st><st c="53346">To avoid this problem with the main and view modules, the area below the Flask instantiation is where we place these view imports. </st><st c="53477">The </st><code><st c="53481">if</st></code><st c="53483"> statement at the bottom of </st><code><st c="53511">main.py</st></code><st c="53518">, on the other hand, verifies that only the main module can run the Flask server through the </st><code><st c="53611">app.run()</st></code><st c="53620"> command.</st></p>
			<p><st c="53629">The main module usually sets the configuration settings through its </st><code><st c="53698">app</st></code><st c="53701"> instance to build the sessions and other context-based objects or integrate other custom components, such as the security and database modules. </st><st c="53846">But the ideal setup doesn’t recommend including them there; instead, you should place them separately from the code, say using a configuration file, to seamlessly manage the environment variables when configuration blunders arise, to avoid performance degradation or congestion when the Flask </st><code><st c="54139">app</st></code><st c="54142"> instance has several variables to load at server startup, and to replicate and back up the environment settings with less effort during project migration </st><st c="54297">or replication.</st></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/><st c="54312">Creating environment variables</st></h2>
			<p><st c="54343">Configuration variables will always be part of any project setup, and how the frameworks or platforms </st><a id="_idIndexMarker066"/><st c="54446">manage them gives an impression of the kind of framework they are. </st><st c="54513">A good framework should be able to decouple both built-in and custom configuration variables from the implementation area while maintaining their easy access across the application. </st><st c="54695">It can support having a configuration file that can do </st><st c="54750">the following:</st></p>
			<ul>
				<li><st c="54764">Contain the variables in a structured and </st><st c="54807">readable manner.</st></li>
				<li><st c="54823">Easily integrate with </st><st c="54846">the application.</st></li>
				<li><st c="54862">Allow comments to be part of </st><st c="54892">its content.</st></li>
				<li><st c="54904">Work even when deployed to other servers </st><st c="54946">or containers.</st></li>
				<li><st c="54960">Decouple the variables from the </st><st c="54993">implementation area.</st></li>
			</ul>
			<p><st c="55013">Aside from the </st><code><st c="55029">.env</st></code><st c="55033"> file, Flask can also support configuration files in JSON, Python, and </st><code><st c="55284">config.json</st></code><st c="55295"> file, which contains the database and Flask development </st><st c="55352">environment settings:</st></p>
			<pre class="source-code"><st c="55373">
{
    «DB_USER» : «postgres»,
    «DB_PASS» : «admin2255»,
    «DB_PORT» : 5433,
    "DB_HOST" : "localhost",
    "DB_NAME" : "opcs",
    "FLASK_DEBUG" : true,
    "TESTING": true
}</st></pre>			<p><st c="55527">This next is a Python </st><code><st c="55550">config.py</st></code><st c="55559"> file with the same variable settings </st><st c="55597">in </st><code><st c="55600">config.json</st></code><st c="55611">:</st></p>
			<pre class="source-code"><st c="55613">
DB_USER = «postgres»
DB_PASS = «admin2255»
DB_PORT = 5433
DB_HOST = "localhost"
DB_NAME = "opcs"
FLASK_DEBUG = True
TESTING = True</st></pre>			<p><st c="55744">The </st><code><st c="55749">app</st></code><st c="55752"> instance has the </st><code><st c="55770">config</st></code><st c="55776"> attribute with a </st><code><st c="55794">from_file()</st></code><st c="55805"> method that can load the JSON  file, as shown in the </st><st c="55858">following snippet:</st></p>
			<pre class="source-code"><st c="55876">
app.config.from_file("config.json", load=json.load)</st></pre>			<p><st c="55928">On the other hand, </st><code><st c="55948">config</st></code><st c="55954"> has a </st><code><st c="55961">from_pyfile()</st></code><st c="55974"> method that can manage the Python config file when invoked, as shown in </st><st c="56047">this snippet:</st></p>
			<pre class="source-code"><st c="56060">
app.config.from_pyfile('myconfig.py')</st></pre>			<p><st c="56098">The recent addition to the supported type, </st><code><st c="56178">toml</st></code><st c="56182"> extension module before</st><a id="_idIndexMarker069"/><st c="56206"> loading the </st><code><st c="56219">.toml</st></code><st c="56224"> file into the platform. </st><st c="56249">After running the </st><code><st c="56267">pip install toml</st></code><st c="56283"> command, the </st><code><st c="56297">config</st></code><st c="56303"> attribute’s </st><code><st c="56316">from_file()</st></code><st c="56327"> method can now load the following settings of the </st><code><st c="56378">config.toml</st></code><st c="56389"> file:</st></p>
			<pre class="source-code"><st c="56395">
DB_USER = «postgres»
DB_PASS = «admin2255»
DB_PORT = 5433
DB_HOST = "localhost"
DB_NAME = "opcs"
FLASK_DEBUG = true
TESTING = true</st></pre>			<p><st c="56526">TOML, like JSON and Python, has data types. </st><st c="56571">It supports arrays and tables and has structural patterns that may seem more complex than the JSON and Python configuration syntax. </st><st c="56703">A TOML file will have the </st><code><st c="56729">.</st></code><code><st c="56730">toml</st></code><st c="56735"> extension.</st></p>
			<p><st c="56746">When accessing variables from these file types, the Flask instance uses its </st><code><st c="56823">config</st></code><st c="56829"> object to access each variable. </st><st c="56862">This can be seen in the following version of our </st><code><st c="56911">db.py</st></code><st c="56916"> module for database connectivity, which uses the </st><code><st c="56966">config.toml</st></code><st c="56977"> file:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="56983">from __main__ import app</st></strong><st c="57008">
import psycopg2
import functools
def connect_db(func):
    @functools.wraps(func)
    def repo_function(*args, **kwargs):
        conn = psycopg2.connect(
            </st><strong class="bold"><st c="57148">host=app.config['DB_HOST'],</st></strong><strong class="bold"><st c="57175">database=app.config['DB_NAME'],</st></strong><strong class="bold"><st c="57207">port=app.config['DB_PORT'],</st></strong><strong class="bold"><st c="57235">user=app.config['DB_USER'],</st></strong><strong class="bold"><st c="57263">password=app.config['DB_PASS'])</st></strong><st c="57295">
        resp = func(conn, *args, **kwargs)
        conn.commit()
        conn.close()
        return resp
    return repo_function</st></pre>			<h1 id="_idParaDest-45"><a id="_idTextAnchor046"/><st c="57390">Summary</st></h1>
			<p><st c="57398">This chapter has presented the initial requirements to set up a development environment for a single-structured Flask project. </st><st c="57526">It provided the basic elements that are essential to creating a simple Flask prototype, such as the </st><code><st c="57626">main.py</st></code><st c="57633"> module, routes, database connectivity, repository, services, and configuration files. </st><st c="57720">The nuts and bolts of every procedure in building every aspect of the project describe Flask as a web framework. </st><st c="57833">The many ways to store the configuration settings, the possibility of using custom decorators for database connectivity, and the many options to capture the form data are indicators of Flask being so flexible, extensible, handy, and Pythonic in many ways. </st><st c="58089">The next chapter will focus on the core components and advanced features that Flask can provide in building a more </st><st c="58204">scalable application.</st></p>
		</div>
	<div></body></html>