<html><head></head><body>
  <div><h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-231" class="chapterTitle">String Matching Algorithms</h1>
    <p class="normal">There <a id="_idIndexMarker1019"/>are many popular string matching algorithms. String matching algorithms have very important applications, such as searching for an element in a text document, plagiarism detection, text editing programs, and so on. In this chapter, we will study the pattern matching algorithms that find the locations of a given pattern or substring in any given text. We will discuss the <strong class="keyWord">brute force algorithm</strong>, along with the <strong class="keyWord">Rabin-Karp</strong>, <strong class="keyWord">Knuth-Morris-Pratt</strong> (<strong class="keyWord">KMP</strong>), and <strong class="keyWord">Boyer-Moore pattern matching algorithms</strong>. This chapter aims to discuss algorithms that are related to strings. The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Learning pattern matching algorithms and their implementation</li>
      <li class="bulletList">Understanding and implementing the <strong class="keyWord">Rabin-Karp pattern matching algorithm</strong></li>
      <li class="bulletList">Understanding and implementing the <strong class="keyWord">Knuth-Morris-Pratt</strong> (<strong class="keyWord">KMP</strong>) <strong class="keyWord">algorithm</strong></li>
      <li class="bulletList">Understanding and implementing the <strong class="keyWord">Boyer-Moore pattern matching algorithm</strong></li>
    </ul>
    <h1 id="_idParaDest-232" class="heading-1">Technical requirements</h1>
    <p class="normal">All of the programs based on the concepts and algorithms discussed in this chapter are provided in the book as well as in the GitHub repository at the following link: <a href="https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter13">https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter13</a>.</p>
    <h1 id="_idParaDest-233" class="heading-1">String notations and concepts</h1>
    <p class="normal">Strings <a id="_idIndexMarker1020"/>are sequences of characters. Python provides a rich set of operations and functions that can be applied to the string data type. Strings are textual data and are handled very efficiently in Python. The following is an example of a string <code class="inlineCode">(s)</code>—<code class="inlineCode">"packt publishing"</code>.</p>
    <p class="normal">A substring<a id="_idIndexMarker1021"/> is a sequence of characters that’s part of the given string, i.e., specified indices in the string in a continuous order. For example, “<code class="inlineCode">packt</code>" is a substring of the string “<code class="inlineCode">packt publishing</code>". On the other hand, a subsequence is also a sequence of characters that can be obtained from the given string by removing some of the characters from the string by keeping the order of occurrence of the characters. For example, “<code class="inlineCode">pct pblishing</code>" is a valid subsequence for the string “<code class="inlineCode">packt publishing</code>" that is obtained by removing the characters <code class="inlineCode">a</code>, <code class="inlineCode">k</code>, and <code class="inlineCode">u</code>. However, this is not a substring since “<code class="inlineCode">pct pblishing</code>" is not a continuous sequence of characters. Hence, a subsequence is different from a substring, and it can be considered a generalization of substrings.</p>
    <p class="normal">The prefix <code class="inlineCode">(p)</code> is a<a id="_idIndexMarker1022"/> substring of the string <code class="inlineCode">(s)</code> in that it is present at the start of the string. There is also another string <code class="inlineCode">(u)</code> that exists in the string <code class="inlineCode">(s)</code> after the prefix. For example, the substring “<code class="inlineCode">pack</code>" is a prefix for the string <code class="inlineCode">(s) = "packt publishing"</code> as it is the starting substring and there is another substring <code class="inlineCode">u = "publishing"</code> after it. Thus, the prefix plus string <code class="inlineCode">(u)</code> makes “<code class="inlineCode">packt publishing</code>", which is the whole string.</p>
    <p class="normal">The suffix <code class="inlineCode">(d)</code> is a <a id="_idIndexMarker1023"/>substring that is present at the end of the string <code class="inlineCode">(s)</code>. For example, the substring “<code class="inlineCode">shing</code>" is one of the many possible suffixes for the string “<code class="inlineCode">packt publishing</code>". Python has built-in functions to check whether a string starts or ends with a specific string, as shown in the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">string = "this is data structures book by packt publisher"
suffix = "publisher"
prefix = "this"
print(string.endswith(suffix))  #Check if string contains given suffix. 
print(string.startswith(prefix)) #Check if string starts with given prefix.
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">True
True
</code></pre>
    <p class="normal">In the above example of the given string, we can see that the given text string ends with another substring “<code class="inlineCode">publisher</code>", which is a valid suffix, and that also has another substring “<code class="inlineCode">this</code>", which is a substring of the string start and is also a valid prefix.</p>
    <p class="normal">Note that the pattern matching algorithms discussed here are not to be confused with the matching statements of Python 3.10. </p>
    <p class="normal">Pattern matching algorithms are the most important string processing algorithms and we will discuss them in the subsequent sections, starting with pattern matching algorithms.</p>
    <h1 id="_idParaDest-234" class="heading-1">Pattern matching algorithms</h1>
    <p class="normal">A pattern matching algorithm<a id="_idIndexMarker1024"/> is used to determine the index positions where a given pattern string (<code class="inlineCode">P</code>) is matched in a text string (<code class="inlineCode">T</code>). Thus, the pattern matching algorithm finds and returns the index where a given string pattern appears in a text string. It returns <code class="inlineCode">"pattern not found"</code> if the pattern does not have a match in the text string.</p>
    <p class="normal">For example, for the given text string <code class="inlineCode">(s) = "packt publisher"</code> and the pattern string <code class="inlineCode">(p) = "publisher"</code>, the pattern-matching algorithm returns the index position where the pattern string is matched in the text string. An example of a string matching problem is shown in <em class="italic">Figure 13.1</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.1: An example of a string matching problem</p>
    <p class="normal">We will discuss four pattern matching algorithms, that is, the brute force method, Rabin-Karp algorithm, and the <strong class="keyWord">Knuth-Morris-Pratt</strong> (<strong class="keyWord">KMP</strong>) and Boyer-Moore pattern-matching algorithms. We start with the brute force pattern matching algorithm.</p>
    <h1 id="_idParaDest-235" class="heading-1">The brute force algorithm</h1>
    <p class="normal">The brute force algorithm is also <a id="_idIndexMarker1025"/>called the naive approach to pattern matching algorithms. Naive approach means that it is a very basic and simple algorithm. In<a id="_idIndexMarker1026"/> this approach, we match all the possible combinations of the input pattern in the given text string to find the position of the occurrence of the pattern. This algorithm is very naive and is not suitable if the text is very long.</p>
    <p class="normal">In this algorithm, we start by comparing the characters of the pattern string and the text string one by one, and if all the characters of the pattern are matched with the text, we return the index position of the text where the first character of the pattern is located. If any character of the pattern is mismatched with the text string, we shift the pattern by one position to check if the pattern appears at the next index position. We continue comparing the pattern and text string by shifting the pattern by one index position.</p>
    <p class="normal">To better understand how the brute force algorithm works, let’s look at an example. Suppose we have a text string <code class="inlineCode">(T)</code> = “<strong class="keyWord">acbcabccababcaacbcac</strong>”, and the pattern string <code class="inlineCode">(P)</code> is “<strong class="keyWord">acbcac</strong>”. Now, the objective of the pattern matching algorithm is to determine the index position of the pattern string in the given text, <code class="inlineCode">T</code>, as shown in <em class="italic">Figure 13.2</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.2: An example of the brute force algorithm for string matching</p>
    <p class="normal">We start by comparing the first character of the text, that is, <strong class="keyWord">a</strong>, and the first character of the pattern. Here, the initial five characters of the pattern are matched, and then there is a mismatch in the last character of the pattern. This is a mismatch, so we shift the pattern by one place. We again start comparing the first character of the pattern and the second character of the text string one by one. Here, character <strong class="screenText">c</strong> of the text string does not match with the character <strong class="keyWord">a</strong> of the pattern. So, this is also a mismatch, and we shift the pattern by one space, as shown in <em class="italic">Figure 13.2</em>. We continue comparing the characters of the pattern and the text string until we traverse the whole text string. In this example, we find a match at index position <code class="inlineCode">14</code>, which is shown in <em class="italic">Figure 13.2</em>.</p>
    <p class="normal">Let’s consider the<a id="_idIndexMarker1027"/> Python implementation of the brute force algorithm for<a id="_idIndexMarker1028"/> pattern matching:</p>
    <pre class="programlisting code"><code class="hljs-code">def brute_force(text, pattern):
    l1 = len(text)      # The length of the text string
    l2 = len(pattern)   # The length of the pattern 
    i = 0
    j = 0               # looping variables are set to 0
    flag = False        # If the pattern doesn't appear at all, then set this to false and execute the last if statement
    while i &lt; l1:         # iterating from the 0th index of text
        j = 0
        count = 0    
        # Count stores the length upto which the pattern and the text have matched
        while j &lt; l2:
            if i+j &lt; l1 and text[i+j] == pattern[j]:  
        # statement to check if a match has occurred or not
                count += 1     # Count is incremented if a character is matched 
            j += 1
        if count == l2:   # it shows a matching of pattern in the text 
                print("\nPattern occurs at index", i) 
                # print the starting index of the successful match
                flag = True 
                # flag is True as we wish to continue looking for more matching of pattern in the text. 
        i += 1
    if not flag: 
        # If the pattern doesn't occur at all, means no match of pattern in the text string
        print('\nPattern is not at all present in the array')
</code>
'acbcac'</code> in the given string:</pre>
    <pre class="programlisting code"><code class="hljs-code">brute_force('acbcabccababcaacbcac','acbcac')         # function call
</code></pre>
    <p class="normal">The output of the above function call is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Pattern occurs at index 14
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker1029"/>preceding code for the brute force approach, we start by computing<a id="_idIndexMarker1030"/> the length of the given text strings and pattern. We also initialize the looping variables with <code class="inlineCode">0</code> and set the flag to <code class="inlineCode">False</code>. </p>
    <p class="normal">This variable is used to continue searching for a match of the pattern in the string. If the <code class="inlineCode">flag</code> variable is <code class="inlineCode">False</code> by the end of the text string, it means that there is no match for the pattern at all in the text string.</p>
    <p class="normal">Next, we start the searching loop from the <code class="inlineCode">0</code><sup class="superscript">th</sup> index to the end of the text string. In this loop, we have a <code class="inlineCode">count</code> variable that is used to keep track of the length up to which the pattern and the text have been matched. Next, we have another nested loop that runs from the <code class="inlineCode">0</code><sup class="superscript">th</sup> index to the length of the pattern. Here, the variable <code class="inlineCode">i</code> keeps track of the index position in the text string and the variable <code class="inlineCode">j</code> keeps track of the characters in the pattern. Next, we compare the characters of the patterns and the text string using the following code fragment:</p>
    <pre class="programlisting code"><code class="hljs-code">if i+j&lt;l1 and text[i+j] == pattern[j]:
</code></pre>
    <p class="normal">Furthermore, we increment the <code class="inlineCode">count</code> variable after every match of the character of the pattern in the text string. Then, we continue matching the characters of the pattern and text string. If the length of the pattern becomes equal to the <code class="inlineCode">count</code> variable, it means there is a match.</p>
    <p class="normal">We print the index position of the text string if there is a match for the pattern string in the text string and keep the <code class="inlineCode">flag</code> variable as to <code class="inlineCode">True</code> as we wish to continue searching for more matches of the patterns in the text string. Finally, if the value of the variable <code class="inlineCode">flag</code> is <code class="inlineCode">False</code>, it means that there was not a match for the pattern in the text string at all.</p>
    <p class="normal">The best-case and worst-case time complexities for the naive string matching algorithms are <code class="inlineCode">O(n)</code> and <code class="inlineCode">O(m*(n-m+1))</code>, respectively. The best-case scenario occurs when the pattern is not found in the text and the first character of the pattern is not present in the text at all, for example, if the text string is <code class="inlineCode">ABAACEBCCDAAEE</code>, and the pattern is <code class="inlineCode">FAA</code>. Here, as the first character of the pattern will not find a match anywhere in the text, it will have comparisons equal to the length of the text (<code class="inlineCode">n</code>). </p>
    <p class="normal">The <a id="_idIndexMarker1031"/>worst-case scenario occurs when all characters of the text string and the <a id="_idIndexMarker1032"/>pattern are the same and we want to find out all the occurrences of the given pattern string in the text string, for example, if the text string is <code class="inlineCode">AAAAAAAAAAAAAAAA</code>, and the pattern string is <code class="inlineCode">AAAA</code>. Another worst-case scenario occurs when only the last character is different, for example, if the text string is <code class="inlineCode">AAAAAAAAAAAAAAAF</code> and the pattern is <code class="inlineCode">AAAAF</code>. Thus, the total number of comparisons will be <code class="inlineCode">m*(n-m+1)</code> and the worst-case time complexity will be <code class="inlineCode">O(m*(n-m+1))</code>.</p>
    <p class="normal">Next, we discuss the Rabin-Karp pattern matching algorithm.</p>
    <h1 id="_idParaDest-236" class="heading-1">The Rabin-Karp algorithm</h1>
    <p class="normal">The Rabin-Karp pattern matching algorithm is an improved version of the brute force approach to find the location of the given pattern in the text string. The performance of the Rabin-Karp algorithm is <a id="_idIndexMarker1033"/>improved by reducing the number of comparisons with <a id="_idIndexMarker1034"/>the help of hashing. We discussed the concept of hashing in <em class="chapterRef">Chapter 8</em>, <em class="italic">Hash Tables</em>. The hashing function returns a unique numeric value for a given string. </p>
    <p class="normal">This algorithm is faster than the brute force approach as it avoids unnecessary comparisons. In this algorithm, we compare the hash value of the pattern with the hash value of the substring of the text string. If the hash values are not matched, the pattern is shifted forward one position. This is a better algorithm as compared to the brute-force algorithm since there is no need to compare all the characters of the pattern one by one.</p>
    <p class="normal">This algorithm is based on the concept that if the hash values of the two strings are equal, then it is assumed that both the strings are also equal. However, it is also possible that there can be two different strings whose hash values are equal. In that case, the algorithm will not work; this situation is known as a spurious hit and happens due to a collision in hashing. To avoid this with the Rabin-Karp algorithm, after matching the hash values of the pattern and the substring, we ensure that the pattern is actually matched in the string by comparing the pattern and the substring character by character.</p>
    <p class="normal">The Rabin-Karp pattern matching algorithm works as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, we<a id="_idIndexMarker1035"/> preprocess the pattern before starting <a id="_idIndexMarker1036"/>the search, that is, we compute the hash value of the pattern of length <code class="inlineCode">m</code> and the hash values of all the possible substrings of the text of length <code class="inlineCode">m</code>. The total number of possible substrings would be (<code class="inlineCode">n-m+1</code>). Here, <code class="inlineCode">n</code> is the length of the text.</li>
      <li class="numberedList">We compare the hash value of the pattern with the hash value of the substrings of the text one by one.</li>
      <li class="numberedList">If the hash values are not matched, then we shift the pattern by one position.</li>
      <li class="numberedList">If the hash value of the pattern and the hash value of the substring of the text match, then we compare the pattern and substring character by character to ensure that the pattern is actually matched in the text. </li>
      <li class="numberedList">We continue the process of <em class="italic">steps 2-5</em> until we reach the end of the given text string.</li>
    </ol>
    <p class="normal">In this algorithm, we compute the numerical hash values using Horner’s rule (any other hashing function can also be used) that returns a unique value for the given string. We also compute the hash value using the sum of the ordinal values of all the characters of the string.</p>
    <p class="normal">Let’s consider an example to understand the <strong class="keyWord">Rabin-Karp algorithm</strong>. Let’s say we have a text string <code class="inlineCode">(T) = "publisher paakt packt"</code>, and the pattern <code class="inlineCode">(P) = "packt"</code>. First, we compute the hash values of the pattern (length <code class="inlineCode">m</code>) and all the substrings (of length <code class="inlineCode">m</code>) of the text string. The functionality of the <strong class="keyWord">Rabin-Karp algorithm</strong> is shown in <em class="italic">Figure 13.3</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.3: An example of the Rabin-Karp algorithm for string matching</p>
    <p class="normal">We start comparing the hash value of the pattern <code class="inlineCode">"packt"</code> with the first substring <code class="inlineCode">"publi"</code>. Since the hash values do not match, we shift the pattern by one position, and then we compare the hash value of pattern with the hash value of the next substring of the text, i.e. <code class="inlineCode">"ublis"</code>. As these hash values also do not match, we again shift the pattern by one position. We shift the pattern by one position at a time if<a id="_idIndexMarker1037"/> the hash values do not match. And, if the hash value of the pattern and the hash value of the substring match, we compare the pattern and substring character by <a id="_idIndexMarker1038"/>character and we return the location of the text string if they match.</p>
    <p class="normal">In the example shown in <em class="italic">Figure 13.3</em>, hash values of the pattern and the substring of the text are matched at location <code class="inlineCode">17</code>. </p>
    <p class="normal">It is important to note that there can be a different string whose hash value can match with the hash of the pattern, i.e. a spurious hit.</p>
    <p class="normal">Next, let us discuss the implementation of the <strong class="keyWord">Rabin-Karp pattern matching algorithm</strong>.</p>
    <h2 id="_idParaDest-237" class="heading-2">Implementing the Rabin-Karp algorithm</h2>
    <p class="normal">The <a id="_idIndexMarker1039"/>implementation of the <strong class="keyWord">Rabin-Karp algorithm</strong> is done in two steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We implement the <code class="inlineCode">generate_hash()</code> method, which is used to compute the hash value of the pattern and all the possible combinations of the substrings of length equal to the length of the pattern.</li>
      <li class="numberedList">We implement the <strong class="keyWord">Rabin-Karp algorithm</strong>, which uses the <code class="inlineCode">generate_hash()</code> method to identify the substring whose hash value matches the hash value of the pattern. Finally, we match them character by character to ensure we have correctly found the pattern.</li>
    </ol>
    <p class="normal">Let us first discuss the<a id="_idIndexMarker1040"/> implementation of generating hash values for the patterns and substrings of the text. For this, we need to first decide on the hash function. Here, we use the sum of all the ordinal values of all the characters of the string as the hashing function.</p>
    <p class="normal">The complete Python implementation to compute the hashing values is given below:</p>
    <pre class="programlisting code"><code class="hljs-code">def generate_hash(text, pattern):
    ord_text = [ord(i) for i in text]       # stores unicode value of each character in text
    ord_pattern = [ord(j) for j in pattern] # stores unicode value of each character in pattern
    len_text = len(text)                    # stores length of the text 
    len_pattern = len(pattern)              # stores length of the pattern
    len_hash_array = len_text - len_pattern + 1 # stores the length of new array that will contain the hash values of text
    hash_text = [0]*(len_hash_array)        # Initialize all the values in the array to 0.
    hash_pattern = sum(ord_pattern)                                                
    for i in range(0,len_hash_array):       # step size of the loop will be the size of the pattern
        if i == 0:                          # Base condition 
            hash_text[i] = sum(ord_text[:len_pattern])   # initial value of hash function
        else:
            hash_text[i] = ((hash_text[i-1] - ord_text[i-1]) + ord
[i+len_pattern-1])   # calculating next hash value using previous value
    return [hash_text, hash_pattern]                 # return the hash values
</code></pre>
    <p class="normal">In the above code, we start by storing the ordinal values of all the characters of the text and the pattern in the <code class="inlineCode">ord_text</code> and <code class="inlineCode">ord_pattern</code> variables. Next, we store the length of the text and the pattern in the <code class="inlineCode">len_text</code> and <code class="inlineCode">len_pattern</code> variables.</p>
    <p class="normal">Next, we create a variable called <code class="inlineCode">len_hash_array</code> that stores the number of all the possible substrings of length (equal to the length of the pattern) using <code class="inlineCode">len_text - len_pattern + 1</code>, and we create an array called <code class="inlineCode">hash_text</code> that stores the hash value for all the possible substrings. This is shown in the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">    len_hash_array = len_text - len_pattern + 1        
    hash_text = [0]*(len_hash_array)  
</code></pre>
    <p class="normal">Next, we compute the hash value for the pattern by summing up the ordinal values of all the characters in the pattern using the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">    hash_pattern = sum(ord_pattern)
</code></pre>
    <p class="normal">Next, we start a <a id="_idIndexMarker1041"/>loop that executes for all the possible substrings of the text. For this, initially, we compute the hash value for the first substring by summing the ordinal values of all of its characters using <code class="inlineCode">sum(ord_text[:len_pattern])</code>. Further, the hash values for all of the substrings are computed using the hash value of the previous substrings as shown in the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">    hash_text[i] = ((hash_text[i-1] - ord_text[i-1]) + ord_text[i+len_pattern-1])
</code></pre>
    <p class="normal">So, we have precomputed the hash values for the pattern and all the substrings of the text that we will use for comparing the pattern and the text in the implementation of the <strong class="keyWord">Rabin-Karp algorithm</strong>. The <strong class="keyWord">Rabin-Karp algorithm</strong> works as follows. Firstly, we compare the hash values of the pattern and substrings of the text. Next, we take the substring for which the hash matches with the hash of the pattern and compare them both character by character.</p>
    <p class="normal">The complete Python implementation of the <strong class="keyWord">Rabin-Karp algorithm</strong> is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def Rabin_Karp_Matcher(text, pattern):
    text = str(text)                            # convert text into string format
    pattern = str(pattern)                 # convert pattern into string format
    hash_text, hash_pattern = generate_hash(text, pattern) # generate hash values using generate_hash function
    len_text = len(text)          # length of text
    len_pattern = len(pattern)    # length of pattern 
    flag = False                  # checks if pattern is present atleast once or not at all 
    for i in range(len(hash_text)):                         
        if hash_text[i] == hash_pattern:   # if the hash value matches
            count = 0                      # count the total characters upto which both are similar
            for j in range(len_pattern):                                 
                if pattern[j] == text[i+j]: # checking equality for each character
                    count += 1              # if value is equal, then update the count value
                else:
                    break
            if count == len_pattern:        # if count is equal to length of pattern, it means there is a match
                    flag = True             # update flag accordingly
                    print('Pattern occurs at index',i)
    if not flag:                            # if pattern doesn't match even once, then this if statement is executed
        print('Pattern is not at all present in the text')
</code></pre>
    <p class="normal">In the above code, firstly, we convert the given text and pattern into string format as the ordinal values can only be computed for strings. Next, we use the <code class="inlineCode">generate_hash</code> function to compute the hash values of patterns and texts. We store the length of the text and patterns in the <code class="inlineCode">len_text</code> and <code class="inlineCode">len_pattern</code> variables. We also initialize the <code class="inlineCode">flag</code> variable to <code class="inlineCode">False</code> so that it keeps track of whether the pattern is present in the text at least once.</p>
    <p class="normal">Next, we start a<a id="_idIndexMarker1042"/> loop that implements the main concept of the algorithm. This loop executes for the length of <code class="inlineCode">hash_text</code>, which is the total number of possible substrings. Initially, we compare the hash value of the first substring with the hash of the pattern by using <code class="inlineCode">if hash_text[i] == hash_pattern</code>. If they do not match; we move one index position and look for another substring. We iteratively move further until we get a match.</p>
    <p class="normal">If we find a match, we compare the substring and the pattern character by character through a loop by using <code class="inlineCode">if pattern[j] == text[i+j]</code>.</p>
    <p class="normal">We then create a <code class="inlineCode">count</code> variable to keep track of how many characters match in the pattern and the substring. If the length of the count and the length of the pattern are equal, this means that all of the characters match, and the index location where the pattern was found is returned. Finally, if the <code class="inlineCode">flag</code> variable remains <code class="inlineCode">False</code>, this means that the pattern does not match at all with the text. The following code snippets can be used to execute the <strong class="keyWord">Rabin-Karp matching algorithm</strong>:</p>
    <pre class="programlisting code"><code class="hljs-code">  Rabin_Karp_Matcher("101110000011010010101101","1011")
  Rabin_Karp_Matcher("ABBACCADABBACCEDF","ACCE")
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">   Pattern occurs at index 0
   Pattern occurs at index 18
   Pattern occurs at index 11
</code></pre>
    <p class="normal">In the above code, we first check whether the pattern “<code class="inlineCode">1011</code>" appears in the given text string “<code class="inlineCode">101110000011010010101101</code>". The output shows that the given pattern occurs at index position <code class="inlineCode">0</code> and <code class="inlineCode">18</code>. Next, the pattern “<code class="inlineCode">ACCE</code>" occurs at index position <code class="inlineCode">11</code> in the text string “<code class="inlineCode">ABBACCADABBACCEDF</code>".</p>
    <p class="normal">The Rabin-Karp pattern matching algorithm preprocesses the pattern before the searching; that is, it <a id="_idIndexMarker1043"/>computes the hash value for the pattern that has the complexity of <code class="inlineCode">O(m)</code>. Also, the worst-case running time complexity of the Rabin-Karp algorithm is <code class="inlineCode">O(m *(n-m+1))</code>. The worst-case scenario is when the pattern does not occur in the text at all. The average-case scenario is when the pattern occurs at least once.</p>
    <p class="normal">Next, we will discuss the KMP string matching algorithm.</p>
    <h1 id="_idParaDest-238" class="heading-1">The Knuth-Morris-Pratt algorithm</h1>
    <p class="normal">The KMP algorithm is <a id="_idIndexMarker1044"/>a pattern matching<a id="_idIndexMarker1045"/> algorithm based on the idea that the overlapping text in the pattern itself can be used to immediately know at the time of any mismatch how much the pattern should be shifted to skip unnecessary comparisons. In this algorithm, we will precompute the <code class="inlineCode">prefix</code> function that indicates the required number of shifts of the pattern whenever we get a mismatch. The KMP algorithm preprocesses the pattern to avoid unnecessary comparisons using the <code class="inlineCode">prefix</code> function. So, the algorithm utilizes the <code class="inlineCode">prefix</code> function to estimate how much the pattern should be shifted to search the pattern in the text string whenever we get a mismatch. The <strong class="keyWord">KMP algorithm</strong> is efficient as it minimizes the number of comparisons of the given patterns with respect to the text string.</p>
    <p class="normal">The motivation behind the <strong class="keyWord">KMP algorithm</strong> can be observed in <em class="italic">Figure 13.4</em>. In this example, it can be seen that the mismatch occurred at the 6<sup class="superscript">th</sup> position with the last character “d” after matching the initial 5 characters. It is also known from the <code class="inlineCode">prefix</code> function that the character “d” did not appear before in the pattern, and utilizing this information, the pattern can be shifted by six places:</p>
    <figure class="mediaobject"><img src="img/B17217_13_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.4: Example of the KMP algorithm</p>
    <p class="normal">So, in this <a id="_idIndexMarker1046"/>example, the pattern has shifted six positions instead <a id="_idIndexMarker1047"/>of one. Let us discuss another example to understand the concept of the <strong class="keyWord">KMP algorithm</strong>, as shown in <em class="italic">Figure 13.5</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_05.png" alt=""/></figure>
    <figure class="mediaobject">Figure 13.5: Second example of the KMP algorithm</figure>
    <p class="normal">In the above example, the mismatch occurs at the last character of the pattern. Since the pattern at the location of the mismatch has a partial match of the prefix <strong class="keyWord">bc</strong>, this information is given by the <code class="inlineCode">prefix</code> function. Here, the pattern can be shifted to align with the other occurrence of the matched prefix <strong class="keyWord">bc</strong> in the pattern.</p>
    <p class="normal">We will look into the <code class="inlineCode">prefix</code> function next for a better understanding of how we use it to know by how much we should shift the pattern.</p>
    <h2 id="_idParaDest-239" class="heading-2">The prefix function</h2>
    <p class="normal">The <code class="inlineCode">prefix</code> function (also known as the failure function) finds the pattern within the pattern. It finds <a id="_idIndexMarker1048"/>out how much the previous comparisons can be reused due to repetition in the pattern itself when there is a mismatch. The <code class="inlineCode">prefix</code> function returns a value for each position wherever we get a mismatch, which tells us by how much the pattern should be shifted.</p>
    <p class="normal">Let us understand how we use the <code class="inlineCode">prefix</code> function to find the required shift amount with the following examples. Consider the first example: if we had a <code class="inlineCode">prefix</code> function for a pattern where all of the characters are different, the <code class="inlineCode">prefix</code> function would have a value of <code class="inlineCode">0</code>. This means that if we find any mismatch, the pattern will be shifted by the number of characters compared up to that position in the pattern.</p>
    <p class="normal">Consider an example with the pattern <strong class="keyWord">abcde</strong>, which contains all different characters. We start comparing the first character of the pattern with the first character of the text string, as shown in <em class="italic">Figure 13.6</em>. As shown in the figure, the mismatch occurs at the 4<sup class="superscript">th</sup> character in the pattern. Since the prefix function has the value 0, it means that there is no overlap in the pattern and no previous comparisons would be reused, so the pattern will be shifted to the number of characters compared up until that point:</p>
    <figure class="mediaobject"><img src="img/B17217_13_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.6: Prefix function in the KMP algorithm</p>
    <p class="normal">Let’s consider another<a id="_idIndexMarker1049"/> example to better understand how the <code class="inlineCode">prefix</code> function works for the pattern <code class="inlineCode">(P)</code> <strong class="keyWord">abcabbcab</strong> as shown in <em class="italic">Figure 13.7</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.7: Example of the prefix function in the KMP algorithm</p>
    <p class="normal">In <em class="italic">Figure 13.7</em>, we start calculating the values of the <code class="inlineCode">prefix</code> function starting from index <code class="inlineCode">1</code>. We assign the value <strong class="keyWord">0</strong> if there is no repetition of the characters in the pattern. So, in this example, we assign <strong class="keyWord">0</strong> to the <code class="inlineCode">prefix</code> function for index positions 1 to 3. Next, at index position <code class="inlineCode">4</code>, we can see that there is a character, <strong class="screenText">a</strong>, which is a repetition of the first character of the pattern itself, so we assign the value <strong class="keyWord">1</strong> here, as shown in <em class="italic">Figure 13.8</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.8: Value of the prefix function at index 4 in the KMP algorithm</p>
    <p class="normal">Next, we look <a id="_idIndexMarker1050"/>at the next character at position 5. It has the longest suffix pattern, <strong class="keyWord">ab</strong>, and so it would have a value of <strong class="keyWord">2</strong>, as shown in <em class="italic">Figure 13.9</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.9: Value of the prefix function at index 5 in the KMP algorithm</p>
    <p class="normal">Similarly, we look at the next index position of <code class="inlineCode">6</code>. Here, the character is <strong class="keyWord">b</strong>. This character does not have the longest suffix in the pattern, so it has the value <strong class="keyWord">0</strong>. Next, we assign value <strong class="keyWord">0</strong> at index position <code class="inlineCode">7</code>. Then, we look at the index position <code class="inlineCode">8</code>, and we assign the value <strong class="keyWord">1</strong> as it has the longest suffix of length <strong class="keyWord">1</strong>. </p>
    <p class="normal">Finally, at the index position of <code class="inlineCode">9</code>, we have the longest suffix of <strong class="keyWord">2</strong>. This is shown in <em class="italic">Figure 13.10</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.10: Value of the prefix function at index 6 to 9 in the KMP algorithm</p>
    <p class="normal">The value<a id="_idIndexMarker1051"/> of the <code class="inlineCode">prefix</code> function shows how much of the start of the string can be reused if there is a mismatch. For example, if the comparison fails at index position <code class="inlineCode">5</code>, the <code class="inlineCode">prefix</code> function value is <strong class="keyWord">2</strong>, which means that the two starting characters don’t need to be compared, and the pattern can be shifted accordingly.</p>
    <p class="normal">Next, we discuss the details of the <strong class="keyWord">KMP algorithm</strong>.</p>
    <h2 id="_idParaDest-240" class="heading-2">Understanding the KMP algorithm</h2>
    <p class="normal">The <strong class="keyWord">KMP pattern matching algorithm</strong> detects overlaps in the pattern itself so that it avoids <a id="_idIndexMarker1052"/>unnecessary comparisons. The main idea behind the <strong class="keyWord">KMP algorithm</strong> is to detect how much the pattern should be shifted, based on the overlaps in the patterns. The algorithm works as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, we precompute the <code class="inlineCode">prefix</code> function for the given pattern and initialize a counter <strong class="keyWord">q</strong> that represents the number of characters that matched.</li>
      <li class="numberedList">We start by comparing the first character of the pattern with the first character of the text string, and if this matches, then we increment the counter <strong class="keyWord">q</strong> for the pattern and the counter for the text string, and we compare the next character.</li>
      <li class="numberedList">If there is a mismatch, then we assign the value of the precomputed <code class="inlineCode">prefix</code> function for <code class="inlineCode">q</code> to the index value of <code class="inlineCode">q</code>.</li>
      <li class="numberedList">We continue searching the pattern in the text string until we reach the end of the text, that is, if we do not find any matches. If all of the characters in the pattern are matched in the text string, we return the position where the pattern is matched in the text and continue to search for another match.</li>
    </ol>
    <p class="normal">Let’s consider the following example to understand the working of the <strong class="keyWord">KMP algorithm</strong>. We have a pattern <code class="inlineCode">acacac</code> along with index positions from <code class="inlineCode">1</code> to <code class="inlineCode">6</code> (just for simplicity, we have index positions starting from 1 instead of 0), shown in <em class="italic">Figure 13.11</em>. The <code class="inlineCode">prefix</code> function for the given pattern is constructed as shown in <em class="italic">Figure 13.11</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.11: The prefix function for pattern “acacac”</p>
    <p class="normal">Let us take an <a id="_idIndexMarker1053"/>example to understand how we use the <code class="inlineCode">prefix</code> function to shift the pattern according to the <strong class="keyWord">KMP algorithm</strong> for the text string and pattern given in <em class="italic">Figure 13.12</em>. We start comparing the pattern and the text character by character. When we mismatch at index position <code class="inlineCode">6</code>, we see the prefix value for this position is <strong class="keyWord">2</strong>. Then we shift the pattern according to the return value of the <code class="inlineCode">prefix</code> function. Next, we start comparing the pattern and text string from the index position of <code class="inlineCode">2</code> on the pattern (character <strong class="keyWord">c</strong>), and the character <strong class="keyWord">b</strong> of the text string. Since this is a mismatch, the pattern will be shifted according to the value of the <code class="inlineCode">prefix</code> function at this position. This description is depicted in <em class="italic">Figure 13.12</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.12: The pattern is shifted according to the return value of the prefix function</p>
    <p class="normal">Now let’s take <a id="_idIndexMarker1054"/>another example shown in <em class="italic">Figure 13.13</em> where the position of the pattern over the text is shown. When we start comparing the characters <strong class="keyWord">b</strong> and <strong class="keyWord">a</strong>, these do not match, and we see the <code class="inlineCode">prefix</code> function for index position <code class="inlineCode">1</code> shows a value of <strong class="keyWord">0</strong>, meaning no overlapping of text in the pattern has occurred. Therefore, we shift the pattern by <strong class="keyWord">1</strong> place as shown in <em class="italic">Figure 13.12</em>. Next, we compare the pattern and text string character by character, and we find a mismatch at index position 10 in the text between characters <strong class="keyWord">b</strong> and <strong class="keyWord">c</strong>. </p>
    <p class="normal">Here, we use the precomputed <code class="inlineCode">prefix</code> function to shift the pattern – as the <code class="inlineCode">prefix_function(4)</code> is <strong class="keyWord">2</strong>, we shift the pattern to align over the text at index position <code class="inlineCode">2</code> of the pattern. After that, we compare characters <strong class="keyWord">b</strong> and <strong class="keyWord">c</strong> at index position <code class="inlineCode">10</code>, and since they do not match, we shift the pattern by one place. This process is shown in <em class="italic">Figure 13.13</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.13: Shifting of the pattern according to the return value of the prefix function</p>
    <p class="normal">Let us continue<a id="_idIndexMarker1055"/> our searching from index position <code class="inlineCode">11</code>, as shown in <em class="italic">Figure 13.14</em>. Next, we compare the characters at index <code class="inlineCode">11</code> in the text and continue until a mismatch is found. We find a mismatch between characters <strong class="keyWord">b</strong> and <strong class="keyWord">c</strong> at index position <code class="inlineCode">12</code>, as shown in <em class="italic">Figure 13.14</em>. We shift the pattern and move it next to the mismatched character since the <code class="inlineCode">prefix_function(2)</code> is <code class="inlineCode">0</code>. We repeat the same process until we reach the end of the string. We find a match of the pattern in the text string at index location <strong class="keyWord">13</strong> in the text string, as in <em class="italic">Figure 13.14</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.14: Shifting of the pattern for index positions of 11 to 18</p>
    <p class="normal">The <strong class="keyWord">KMP algorithm</strong> has two <a id="_idIndexMarker1056"/>phases: first, the preprocessing phase, which is where we compute the <code class="inlineCode">prefix</code> function, which has the space and time complexity of <code class="inlineCode">O(m)</code>. Further, the second phase involves searching, for which the <strong class="keyWord">KMP algorithm</strong> has a time complexity of <code class="inlineCode">O(n)</code>. So, the worst-case time complexity of the <strong class="keyWord">KMP algorithm</strong> is <code class="inlineCode">O(m +n)</code>.</p>
    <p class="normal">Now, we will discuss the implementation of the <strong class="keyWord">KMP algorithm</strong> using Python.</p>
    <h2 id="_idParaDest-241" class="heading-2">Implementing the KMP algorithm</h2>
    <p class="normal">The<a id="_idIndexMarker1057"/> Python implementation of the KMP algorithm is explained here. We start by implementing the <code class="inlineCode">prefix</code> function for the given pattern. The code for the <code class="inlineCode">prefix</code> function is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def pfun(pattern):              # function to generate prefix function for the given pattern,  
    n = len(pattern)            # length of the pattern 
    prefix_fun = [0]*(n)        # initialize all elements of the list to 0 
    k = 0 
    for q in range(2,n):
        while k&gt;0 and pattern[k+1] != pattern[q]: 
            k = prefix_fun[k] 
        if pattern[k+1] == pattern[q]:     # If the kth element of the pattern is equal to the qth element 
            k += 1                       # update k accordingly 
        prefix_fun[q] = k 
    return prefix_fun           # return the prefix function
</code></pre>
    <p class="normal">In the above code, we first compute the length of the pattern using the <code class="inlineCode">len()</code> function, and then we initialize a list to store the values computed by the <code class="inlineCode">prefix</code> function.</p>
    <p class="normal">Next, we<a id="_idIndexMarker1058"/> start the loop that executes from 2 to the length of the pattern. Then, we have a nested loop that is executed until we have processed the whole pattern. The variable <code class="inlineCode">k</code> is initialized to <code class="inlineCode">0</code>, which is the <code class="inlineCode">prefix</code> function for the first element of the pattern. If the <code class="inlineCode">k</code><sup class="superscript">th</sup> element of the pattern is equal to the <code class="inlineCode">q</code><sup class="superscript">th</sup> element, then we increment the value of <code class="inlineCode">k</code> by <code class="inlineCode">1</code>. The value of <code class="inlineCode">k</code> is the value computed by the <code class="inlineCode">prefix</code> function, and so we assign it at the index position of <code class="inlineCode">q</code> in the pattern. Finally, we return the list of the <code class="inlineCode">prefix</code> function that has the computed value for each character of the pattern. </p>
    <p class="normal">Once we have created the <code class="inlineCode">prefix</code> function, we implement the main <strong class="keyWord">KMP matching algorithm</strong>. The following code shows this in detail:</p>
    <pre class="programlisting code"><code class="hljs-code">def KMP_Matcher(text,pattern):   # KMP matcher function
    m = len(text)
    n = len(pattern)
    flag = False
    text = '-' + text   # append dummy character to make it 1-based indexing
    pattern = '-' + pattern # append dummy character to the pattern also
    prefix_fun = pfun(pattern) # generate prefix function for the pattern
    q = 0
    for i in range(1,m+1):
        while q&gt;0 and pattern[q+1] != text[i]: # while pattern and text are not equal, decrement the value of q if it is &gt; 0
            q = prefix_fun[q]
        if pattern[q+1] == text[i]:                 # if pattern and text are equal, update value of q
            q += 1
        if q == n:                                      # if q is equal to the length of the pattern, it means that the pattern has been found.
            print("Pattern occurs at positions ",i-n)     # print the index, where first match occurs.
            flag = True
            q = prefix_fun[q]
    if not flag:
        print('\nNo match found')
</code></pre>
    <p class="normal">In the above code, we start by computing the length of the text string and the pattern, which are stored in the variables <code class="inlineCode">m</code> and <code class="inlineCode">n</code>, respectively. Next, we define a variable <code class="inlineCode">flag</code> to indicate whether the pattern has found a match or not. Further, we add a dummy character <code class="inlineCode">-</code> in the text and pattern to make the indexing start from index <code class="inlineCode">1</code> instead of index <code class="inlineCode">0</code>. Next, we call the <code class="inlineCode">pfun()</code> method to construct the array containing the prefix values for all the positions of the pattern using <code class="inlineCode">prefix_fun = pfun(pattern)</code>. Next, we execute a loop starting from <code class="inlineCode">1</code> to <code class="inlineCode">m+1</code>, where <code class="inlineCode">m</code> is the length of the pattern. Further, for each iteration of the <code class="inlineCode">for</code> loop, we compare the pattern and text in a <code class="inlineCode">while</code> loop until we finish searching the pattern.</p>
    <p class="normal">If we get a<a id="_idIndexMarker1059"/> mismatch, we use the value of the <code class="inlineCode">prefix</code> function at index <code class="inlineCode">q</code> (here, <code class="inlineCode">q</code> is the index where the mismatch occurs) to find out by how much we have to shift the pattern. If the pattern and text are equal, then the value of <code class="inlineCode">1</code> and <code class="inlineCode">n</code> will be equal, and we can return the index where the pattern was matched in the text. Further, we update the <code class="inlineCode">flag</code> variable to <code class="inlineCode">True</code> when the pattern is found in the text. If we finished searching the whole text string and still the variable <code class="inlineCode">flag</code> was <code class="inlineCode">False</code>, it would mean the pattern was not present in the given text.</p>
    <p class="normal">The following code snippet can be used to execute the KMP algorithm for string matching:</p>
    <pre class="programlisting code"><code class="hljs-code">    KMP_Matcher('aabaacaadaabaaba','aabaa')   # function call, with two parameters, text and pattern
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">   Pattern occurs at positions 0
   Pattern occurs at positions 9
</code></pre>
    <p class="normal">In the above output, we see that the pattern is present at index positions 0 and 9 in the given text string.</p>
    <p class="normal">Next, we will discuss another pattern matching algorithm, the Boyer-Moore algorithm.</p>
    <h1 id="_idParaDest-242" class="heading-1">The Boyer-Moore algorithm</h1>
    <p class="normal">As we have<a id="_idIndexMarker1060"/> already discussed, the main objective of the string pattern<a id="_idIndexMarker1061"/> matching algorithm is to find ways of skipping comparisons as much as possible by avoiding unnecessary comparisons.</p>
    <p class="normal">The Boyer-Moore pattern matching algorithm is another such algorithm (along with the KMP algorithm) that further improves the performance of pattern matching by skipping comparisons using different methods. We have to understand the following concepts in order to understand the Boyer-Moore algorithm:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In this algorithm, we shift the pattern in the direction from left to right, similar to the KMP algorithm.</li>
      <li class="numberedList">We compare the characters of the pattern and the text string from right to left, which is the opposite of what we do in the case of the KMP algorithm.</li>
      <li class="numberedList">The algorithm skips the unnecessary comparisons by using the good suffix and bad character shift heuristics. These heuristics themselves find the possible number of comparisons that can be skipped. We slide the pattern over the given text with the greatest offsets suggested by both of these heuristics.</li>
    </ol>
    <p class="normal">Let us understand all about these heuristics and the details of how the Boyer-Moore pattern matching algorithm works.</p>
    <h2 id="_idParaDest-243" class="heading-2">Understanding the Boyer-Moore algorithm</h2>
    <p class="normal">The Boyer-Moore algorithm compares the pattern with the text from right to left, meaning that <a id="_idIndexMarker1062"/>in this algorithm if the end of the pattern does not match with the text, the pattern can be shifted rather than checking every character of the text. The key idea is that the pattern is aligned with the text and the last character of the pattern is compared with the text, and if they do not match, then it is not required to continue comparing each character and we can rather shift the pattern.</p>
    <p class="normal">Here, how much we shift the pattern depends upon the mismatched character. If the mismatched character of the text does not appear in the pattern, it means we can shift the pattern by the whole length of the pattern, whereas if the mismatched character appears in the pattern somewhere, then we partially shift the pattern in such a way that the mismatched character is aligned with the other occurrence of that character in the pattern.</p>
    <p class="normal">In addition, in this algorithm, we can also see what portion of the pattern has matched (with the matched suffix), so we utilize this information and align the text and pattern by skipping any unnecessary comparisons. Making the pattern jump along the text to reduce the number of comparisons rather than checking every character of the pattern with the text is the main idea of an efficient string matching algorithm.</p>
    <p class="normal">The concept <a id="_idIndexMarker1063"/>behind the Boyer-Moore algorithm is demonstrated in <em class="italic">Figure 13.15</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.15: A example to demonstrate the concept of the Boyer-Moore algorithm</p>
    <p class="normal">In the example shown in <em class="italic">Figure 13.15</em>, where character <strong class="keyWord">b</strong> of the pattern mismatches with character <strong class="keyWord">d</strong> of the text, we can shift the entire pattern since the mismatched character <strong class="keyWord">d</strong> is not present in the pattern anywhere. In the second mismatch, we can see that the mismatched character <strong class="keyWord">a</strong> in the text is present in the pattern, so we shift the pattern to align with that character. This example shows how we can skip unnecessary comparisons. Next, we will discuss further the details of the algorithm.</p>
    <p class="normal">The Boyer-Moore algorithm has two heuristics to determine the maximum shift possible for the pattern when we find a mismatch:</p>
    <ul>
      <li class="bulletList">Bad character heuristic</li>
      <li class="bulletList">Good suffix heuristic</li>
    </ul>
    <p class="normal">At the time of a mismatch, each of these heuristics suggests possible shifts, and the Boyer-Moore algorithm shifts the pattern over the text string by a longer distance considering the maximum shift given by bad character and good suffix heuristics. The details of the bad <a id="_idIndexMarker1064"/>character and good suffix heuristics are explained in detail with examples in the following subsections.</p>
    <h3 id="_idParaDest-244" class="heading-3">Bad character heuristic</h3>
    <p class="normal">The Boyer-Moore<a id="_idIndexMarker1065"/> algorithm compares the pattern and the text string in the direction of right to left. It uses the bad character heuristic to shift the pattern, where we start comparing character by character from the end of the pattern, and if they match then we compare the second to-last character, and if that also matches, then the process is repeated until the entire pattern is matched or we get a mismatch. </p>
    <p class="normal">The mismatched character of the text is also known as a bad character. If we get any mismatch in this process, we shift the pattern according to one of the following conditions:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">If the mismatched character of the text does not occur in the pattern, then we shift the pattern next to the mismatched character.</li>
      <li class="numberedList">If the mismatched character has one occurrence in the pattern, then we shift the pattern in such a way that we align with the mismatched character.</li>
      <li class="numberedList">If the mismatched character has more than one occurrence in the pattern, then we make the most minimal shift possible to align the pattern with that character.</li>
    </ol>
    <p class="normal">Let us understand these three cases with examples. Consider a text string (<code class="inlineCode">T</code>) and the pattern = {<strong class="keyWord">acacac</strong>}. We start by comparing the characters from right to left, that is, character <strong class="keyWord">c</strong> of the pattern and character <strong class="keyWord">b</strong> of the text string. Since they do not match, we look for the mismatched character of the text string (that is <strong class="keyWord">b</strong>) in the pattern. Since the bad character <strong class="keyWord">b</strong> does not appear in the pattern, we shift the pattern next to the mismatched character, as shown in <em class="italic">Figure 13.16</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.16: Example of the bad character heuristic in the Boyer-Moore algorithm</p>
    <p class="normal">Let’s take another<a id="_idIndexMarker1066"/> example with a given text string and the pattern = {<strong class="keyWord">acacac</strong>} as shown in <em class="italic">Figure 13.17</em>. For the given example, we compare the characters of the text string and the pattern from right to left, and we get a mismatch for the character <strong class="keyWord">d</strong> of the text. Here, the suffix <strong class="keyWord">ac</strong> is matched, but the characters <strong class="keyWord">d</strong> and <strong class="keyWord">c</strong> do not match, and the mismatched character <strong class="keyWord">d</strong> does not appear in the pattern. Therefore, we shift the pattern next to the mismatched character, as shown in <em class="italic">Figure 13.17</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.17: Second example of the bad character heuristic in the Boyer-Moore algorithm</p>
    <p class="normal">Let’s consider an<a id="_idIndexMarker1067"/> example to understand the second and third cases of the bad character heuristic for the given text string and the pattern as shown in <em class="italic">Figure 13.18</em>. Here, the suffix <strong class="keyWord">ac</strong> is matched, but the next characters, <strong class="keyWord">a</strong> and <strong class="keyWord">c</strong>, do not match, so we search for the occurrences of the mismatched character <strong class="keyWord">a</strong> in the pattern. Since it has two occurrences in the pattern, we have two options for shifting the pattern to align it with the mismatched character. Both of these options are shown in <em class="italic">Figure 13.18</em>:</p>
    <p class="normal">In such situations where we have more than one option to shift the pattern, we apply the least possible number of shifts to prevent missing any possible match. If on the other hand we have only one occurrence of the mismatched character in the pattern, we can easily shift the pattern in such a way that the mismatched character is aligned. So, in this example, we would prefer option 1 to shift the pattern as shown in <em class="italic">Figure 13.18</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.18: Third example of the bad character heuristic in the Boyer-Moore algorithm</p>
    <p class="normal">We have<a id="_idIndexMarker1068"/> discussed the bad character heuristic so far, and we consider the good suffix heuristic in the next section.</p>
    <h3 id="_idParaDest-245" class="heading-3">Good suffix heuristic</h3>
    <p class="normal">The bad<a id="_idIndexMarker1069"/> character heuristic does not always provide good suggestions for shifting the pattern. The Boyer-Moore algorithm also uses the good suffix heuristic to shift the pattern over the text string, which is based on the matched suffix. In this method, we shift the pattern to the right in such a way that the matched suffix of the pattern is aligned with another occurrence of the same suffix in the pattern.</p>
    <p class="normal">It works like this: we start by comparing the pattern and the text string from right to left, and if we find any mismatch, then we check the occurrence of the suffix in the pattern that has been matched so far, which is known as a good suffix. </p>
    <p class="normal">In such situations, we shift the pattern in such a way that we align another occurrence of the good suffix to the text. The good suffix heuristic has two main cases:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The matching suffix has one or more occurrences in the pattern</li>
      <li class="numberedList">Some part of the matching suffix is present at the start of the pattern (this means that the suffix of the matched suffix exists as the prefix of the pattern)</li>
    </ol>
    <p class="normal">Let’s understand <a id="_idIndexMarker1070"/>these cases with the following examples. Suppose we have a given text string and the pattern <strong class="keyWord">acabac</strong> as shown in <em class="italic">Figure 13.19</em>. We start comparing the characters from right to left, and we get a mismatch with the character <strong class="keyWord">a</strong> of the text string and <strong class="keyWord">b</strong> of the pattern. By the point of this mismatch, we have already matched the suffix <strong class="keyWord">ac</strong>, which is called the “good suffix.” Now, we search for another occurrence of the good suffix <strong class="keyWord">ac</strong> in the pattern (which is present at the starting position of the pattern in this example) and we shift the pattern to align it with that suffix, as shown in <em class="italic">Figure 13.19</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.19: Example of the good suffix heuristic in the Boyer-Moore algorithm</p>
    <p class="normal">Let’s take another example to understand the good suffix heuristic. Consider the text string and pattern given in <em class="italic">Figure 13.18</em>. Here, we get a mismatch between characters <strong class="keyWord">a</strong> and <strong class="keyWord">c</strong>, and we get a good suffix <strong class="keyWord">ac</strong>. Here, we have two options for shifting the pattern to align it with the good suffix string. </p>
    <p class="normal">In a situation where we have more than one option to shift the pattern, we take the option with the lower number of shifts. For this reason, we take option 1 in this example, as shown in <em class="italic">Figure 13.20</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.20: Second example of the good suffix heuristic in the Boyer-Moore algorithm</p>
    <p class="normal">Let’s take a look at<a id="_idIndexMarker1071"/> another example of the text string and pattern shown in <em class="italic">Figure 13.19</em>. In this example, we get a good suffix string <strong class="keyWord">aac</strong>, and we get a mismatch for the characters <strong class="keyWord">b</strong> of the text string and <strong class="keyWord">a</strong> of the pattern. Now, we search for the good suffix <strong class="keyWord">aac</strong> in the pattern, but we do not find another occurrence of it. When this happens, we check whether the prefix of the pattern matches the suffix of the good suffix, and if so, we shift the pattern to align with it.</p>
    <p class="normal">For this example, we find that the prefix <strong class="keyWord">ac</strong> at the start of the pattern does not match with the full good suffix, but does match the suffix <strong class="keyWord">ac</strong> of the good suffix <strong class="keyWord">aac</strong>. In such a situation, we shift the pattern by aligning with the suffix of <strong class="keyWord">aac</strong> that is also a prefix of the pattern as shown in <em class="italic">Figure 13.21</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.21: Third example of the good suffix heuristic in the Boyer-Moore algorithm</p>
    <p class="normal">Another case for the <a id="_idIndexMarker1072"/>good suffix heuristic for the given text string and pattern is shown in <em class="italic">Figure 13.22</em>. In this example, we compare the text and pattern and find the good suffix <strong class="keyWord">aac</strong>, and we get a mismatch with character <strong class="keyWord">b</strong> of the text and <strong class="keyWord">a</strong> of the pattern.</p>
    <p class="normal">Next, we search for the matched good suffix in the pattern, but there is no occurrence of the suffix in the pattern, nor does any prefix of the pattern match the suffix of the good suffix. So, in this kind of situation, we shift the pattern after the matched good suffix as shown in <em class="italic">Figure 13.22</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_13_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.22: Fourth example of the good suffix heuristic in the Boyer-Moore algorithm</p>
    <p class="normal">In the Boyer-Moore algorithm, we compute the shifts given by the bad character and good suffix<a id="_idIndexMarker1073"/> heuristics. Further, we shift the pattern by the longer of the distances given by the bad character and good suffix heuristics.</p>
    <p class="normal">The Boyer-Moore algorithm has a time complexity of <code class="inlineCode">O(m)</code> for the preprocessing of the pattern, and the searching has a time complexity of <code class="inlineCode">O(mn)</code>, where <code class="inlineCode">m</code> is the length of the pattern and <code class="inlineCode">n</code> is the length of the text.</p>
    <p class="normal">Next, let us discuss the implementation of the Boyer-Moore algorithm.</p>
    <h3 id="_idParaDest-246" class="heading-3">Implementing the Boyer-Moore algorithm</h3>
    <p class="normal">Let’s understand<a id="_idIndexMarker1074"/> the implementation of the Boyer-Moore algorithm. The complete implementation of the Boyer-Moore algorithm is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">text = "acbaacacababacacac"
pattern = "acacac"
 
 
matched_indexes = []
 
i=0
flag = True
while i&lt;=len(text)-len(pattern):
    for j in range(len(pattern)-1, -1, -1):     #reverse searching
        if pattern[j] != text[i+j]:
            flag = False    #indicates there is a mismatch
            if j == len(pattern)-1:     #if good-suffix is not present, we test bad character 
                if text[i+j] in pattern[0:j]:
                    i=i+j-pattern[0:j].rfind(text[i+j])   
                    #i+j is index of bad character, this line is used for jumping pattern to match bad character of text with same character in pattern
                else:
                    i=i+j+1     #if bad character is not present, jump pattern next to it
            else:
                k=1
                while text[i+j+k:i+len(pattern)] not in pattern[0:len(pattern)-1]:     
                    #used for finding sub part of a good-suffix
                    k=k+1
                if len(text[i+j+k:i+len(pattern)]) != 1:    #good-suffix should not be of one character
                    gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)])    
                    #jumps pattern to a position where good-suffix of pattern matches with good-suffix of text
                else:
                    #gsshift=i+len(pattern)
                    gsshift=0   #when good-suffix heuristic is not applicable, 
                                #we prefer bad character heuristic
                if text[i+j] in pattern[0:j]:
                    bcshift=i+j-pattern[0:j].rfind(text[i+j])  
                    #i+j is index of bad character, this line is used for jumping pattern to match bad character of text with same character in pattern
                else:
                    bcshift=i+j+1
                i=max((bcshift, gsshift))
            break
    if flag:    #if pattern is found then normal iteration
        matched_indexes.append(i)
        i = i+1
    else:   #again set flag to True so new string in text can be examined
        flag = True
    
print ("Pattern found at", matched_indexes)
</code></pre>
    <p class="normal">An explanation<a id="_idIndexMarker1075"/> of each of the statements of the preceding code is presented here. Initially, we have the text string and the pattern. After initializing the variables, we start with a <code class="inlineCode">while</code> loop that starts by comparing the last character of the pattern with the corresponding character of the text.</p>
    <p class="normal">Then, the characters are compared from right to left by the use of the nested loop from the last index of the pattern to the first character of the pattern. This uses <code class="inlineCode">range(len(pattern)-1, -1, -1)</code>.</p>
    <p class="normal">The outer <code class="inlineCode">while</code> loop keeps track of the index in the text string while the inner <code class="inlineCode">for</code> loop keeps track of the index position in the pattern.</p>
    <p class="normal">Next, we start comparing the characters by using <code class="inlineCode">pattern[j] != text[i+j]</code>. If they are mismatched, we make the <code class="inlineCode">flag</code> variable <code class="inlineCode">False</code>, denoting that there is a mismatch.</p>
    <p class="normal">Now, we check whether the good suffix is present using the condition <code class="inlineCode">j == len(pattern)-1</code>. If this condition is true, it means that there is no good suffix possible, so we check for the bad character heuristics, that is, whether a mismatched character is present in the pattern using the condition <code class="inlineCode">text[i+j] in pattern[0:j]</code>, and if the condition is true, then it means that the bad character is present in the pattern. In this case, we move the pattern to align this bad character to the other occurrence of this character in the pattern by using <code class="inlineCode">i=i+j-pattern[0:j].rfind(text[i+j])</code>. Here, <code class="inlineCode">(i+j)</code> is the index of the bad character.</p>
    <p class="normal">If the bad<a id="_idIndexMarker1076"/> character is not present in the pattern (it isn’t in the <code class="inlineCode">else</code> part of it), we move the whole pattern next to the mismatched character by using the index <code class="inlineCode">i=i+j+1</code>.</p>
    <p class="normal">Next, we go into the <code class="inlineCode">else</code> part of the condition to check the good suffix. When we find the mismatch, we further test to see whether we have any subpart of a good suffix present in the prefix of the pattern. We do this using the following condition:</p>
    <pre class="programlisting code"><code class="hljs-code">text[i+j+k:i+len(pattern)] not in pattern[0:len(pattern)-1]
</code></pre>
    <p class="normal">Furthermore, we check whether the length of the good suffix is <code class="inlineCode">1</code> or not. If the length of the good suffix is <code class="inlineCode">1</code>, we do not consider this shift. If the good suffix is more than <code class="inlineCode">1</code>, we find out the number of shifts by using the good suffix heuristics and store this in the <code class="inlineCode">gsshift</code> variable. This is the pattern, which leads to a position where the good suffix of the pattern matches the good suffix in the text using the instruction <code class="inlineCode">gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)])</code>. Furthermore, we computed the number of shifts possible due to the bad character heuristic and stored this in the <code class="inlineCode">bcshift</code> variable. The number of shifts possible is <code class="inlineCode">i+j-pattern[0:j].rfind(text[i+j])</code> when the bad character is present in the pattern, and the number of shifts possible would be <code class="inlineCode">i+j+1</code> in the case of the bad character not being present in the pattern.</p>
    <p class="normal">Next, we shift <a id="_idIndexMarker1077"/>the pattern on the text string by the maximum number of moves given by the bad character and good suffix heuristics by using the instruction <code class="inlineCode">i=max((bcshift, gsshift))</code>. Finally, we check whether the <code class="inlineCode">flag</code> variable is <code class="inlineCode">True</code> or not. If it is <code class="inlineCode">True</code>, this means that the pattern has been found and that the matched index has been stored in the <code class="inlineCode">matched_indexes</code> variable.</p>
    <p class="normal">We have discussed the concept of the Boyer-Moore pattern matching algorithm, which is an efficient algorithm that skips unnecessary comparisons using the bad character and good suffix heuristics.</p>
    <h1 id="_idParaDest-247" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we have discussed the most popular and important string matching algorithms that have a wide range of applications in real-time scenarios. We discussed the brute force, Rabin-Karp, KMP, and Boyer-Moore pattern matching algorithms. In string matching algorithms, we try to uncover ways to skip unnecessary comparisons and move the pattern over the text as fast as possible. The <strong class="keyWord">KMP algorithm</strong> detects unnecessary comparisons by looking at the overlapping substrings in the pattern itself to avoid redundant comparisons. Furthermore, we discussed the <strong class="keyWord">Boyer-Moore algorithm</strong>, which is very efficient when the text and pattern are long. It is the most popular algorithm used for string matching in practice.</p>
    <h1 id="_idParaDest-248" class="heading-1">Exercise</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Show the KMP <code class="inlineCode">prefix</code> function for the pattern <code class="inlineCode">"aabaabcab"</code>.</li>
      <li class="numberedList">If the expected number of valid shifts is small and the modulus is larger than the length of the pattern, then what is the matching time of the Rabin-Karp algorithm?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Theta (m)</li>
          <li class="alphabeticList">Big O (n+m)</li>
          <li class="alphabeticList">Theta (n-m)</li>
          <li class="alphabeticList">Big O (n)</li>
        </ol>
      </li>
      <li class="numberedList">How many spurious hits does the Rabin-Karp string matching algorithm encounter in the text <code class="inlineCode">T = "3141512653849792"</code> when looking for all occurrences of the pattern <code class="inlineCode">P = "26"</code>, working modulo <code class="inlineCode">q = 11</code>, and over the alphabet set <code class="inlineCode">Σ = {0, 1, 2,..., 9}</code>?</li>
      <li class="numberedList">What is the basic formula applied in the Rabin-Karp algorithm to get the computation time as Theta (m)?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Halving rule</li>
          <li class="alphabeticList">Horner’s rule</li>
          <li class="alphabeticList">Summation lemma</li>
          <li class="alphabeticList">Cancellation lemma</li>
        </ol>
      </li>
      <li class="numberedList">The Rabin-Karp algorithm can be used for discovering plagiarism in text documents.<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">True</li>
          <li class="alphabeticList">False</li>
        </ol>
      </li>
    </ol>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4">https://packt.link/MEvK4</a></p>
    <p class="normal"><img src="img/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>