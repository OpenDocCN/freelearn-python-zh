<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Writing a Flappy Bird Clone</h1></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter 6. Making the 2048 Game">Chapter 6</a>, <em>Making the 2048 Game</em>, we already fiddled with simple game development, exemplified by the well-known <strong>2048</strong> puzzle. This is the logical continuation: we're going to build an arcade game, more specifically a <strong>Flappy Bird</strong>-style side scroller.</p><p>Flappy Bird is<a id="id459" class="indexterm"/> an incredibly simple yet very addictive mobile game released by Dong Nguyen back in 2013; by the end of January 2014, it was the most downloaded free game in the iOS App Store. The Flappy Bird phenomenon is very interesting, game design-wise. The game features exactly one action (tap anywhere on screen to bump the bird, changing its trajectory) and one player activity (fly through gaps in obstacles without touching them). This simple and repetitive gameplay has become quite a trend lately, as explained in the following section.</p><p>
<strong>Asceticism in mobile game design</strong>
</p><p>The <em>classical</em> two-dimensional arcade genre was recently reborn on mobile. There are currently lots of commercial re-issues of retro games, with the price tag being about the only difference from the original 30-year-old titles—these include Dizzy, Sonic, Double Dragon, and R-Type, to name a few.</p><p>One huge letdown many of these games share in a new environment is control scheme awkwardness: the touch screen and gyroscope that are commonly present in modern gadgets just don't replace a gamepad very well, if at all. This fact also became a selling point of new titles—designing a game from the ground up with the available control scheme in mind can be a huge win.</p><p>Some developers tackled with this problem by radically simplifying things upfront: it turns out that there is a huge market for simplistic toys, especially for low-cost or free (optionally, ad-supported) titles.</p><p>Games that feature very limited controls and gameplay can indeed become very popular, and Flappy Bird just landed in a sweet spot, providing extremely challenging yet minimalistic and easily accessible gameplay. In this chapter, we will be re-implementing this particular gem of a game design using Kivy. We are going to introduce a number of new things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Simulating very simple arcade physics</li><li class="listitem" style="list-style-type: disc">Using Kivy widgets as fully featured game sprites, complete with arbitrary positioning and two-dimensional transformations, such as rotation</li><li class="listitem" style="list-style-type: disc">Implementing basic collision detection</li><li class="listitem" style="list-style-type: disc">Producing and implementing sound effects for games</li></ul></div><p>The game we're building doesn't have a winning condition, and the slightest collision with an obstacle ends the game. In the original Flappy Bird title, players competed for a higher score (number of pipes passed without crashing into something). Similar to the previous chapter though, the implementation of a scoreboard is purposefully left out as an exercise for you.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Project overview</h1></div></div></div><p>We're <a id="id460" class="indexterm"/>aiming to create a game conceptually similar to the<a id="id461" class="indexterm"/> original Flappy Bird, but with different visuals. It's unimaginatively called <strong>Kivy Bird</strong>. The end result is depicted as follows:</p><div><img src="img/7849OS_07_01.jpg" alt="Project overview"/><div><p>Kivy Bird gameplay screenshot</p></div></div><p>Let's take a closer look at the game and dissect it into logical parts, creating a project outline that will be used for development:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Background</strong>: The <a id="id462" class="indexterm"/>scenery consists of a number of layers moving at different speeds, resulting in a neat fake depth (parallax effect). The movement is constant and not related to any game events; this makes the background an ideal starting point for the implementation.</li><li class="listitem" style="list-style-type: disc"><strong>Obstacles (pipes)</strong>: This<a id="id463" class="indexterm"/> is a separate graphical layer that also advances towards the player at a constant speed. As opposed to the background, the pipes are procedurally adjusted to have different relative heights, keeping the gap between them passable for the player. A collision with a pipe ends the game.</li><li class="listitem" style="list-style-type: disc"><strong>Playable character (the bird)</strong>: This <a id="id464" class="indexterm"/>sprite moves only vertically, constantly falling down. The player bumps it by clicking or tapping anywhere on the screen, this pushes the bird upwards. As soon as the bird meets floor, ceiling, or a pipe, the game ends.</li></ul></div><p>This is roughly the order in which we're going to write the implementation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Creating an animated background</h1></div></div></div><p>We are <a id="id465" class="indexterm"/>going <a id="id466" class="indexterm"/>to use the following images to create the background for our game:</p><div><img src="img/7849OS_07_02.jpg" alt="Creating an animated background"/><div><p>Images for the background</p></div></div><p>Note that all of these can be seamlessly tiled horizontally—this isn't a strict requirement, but a desirable property nonetheless, as the background looks nicer this way.</p><p>As mentioned in the description, the background is always in motion, disconnected from the rest of the game. This effect can be achieved in at least two ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the straightforward approach, we can just move a huge textured polygon (or any number of polygons) in the background. Creating seamless looping animation in this case may require a bit of work.</li><li class="listitem" style="list-style-type: disc">A more efficient way to achieve the same visual effect is to create a number of static polygons (one per layer) that span the whole viewport, and then animate just texture coordinates. With a tileable texture, this approach produces seamless and visually pleasing results, and amounts to less work overall—there is no need to reposition objects.</li></ul></div><p>We will <a id="id467" class="indexterm"/>implement the second approach, as it's both easier and more effective. Let's start with the <code class="literal">kivybird.kv</code> file that contains the layout:</p><div><pre class="programlisting">FloatLayout:
    Background:
        id: background
        canvas:
            Rectangle:
                pos: self.pos
                size: (self.width, 96)
                <strong>texture: self.tx_floor</strong>

            Rectangle:
                pos: (self.x, self.y + 96)
                size: (self.width, 64)
                <strong>texture: self.tx_grass</strong>

            Rectangle:
                pos: (self.x, self.height - 144)
                size: (self.width, 128)
                <strong>texture: self.tx_cloud</strong>
</pre></div><div><div><h3 class="title"><a id="tip40"/>Tip</h3><p>All "magic numbers" from here on refer mostly to texture dimensions: <code class="literal">96</code> is the ground level, <code class="literal">64</code> is the height of grass, and <code class="literal">144</code> is a somewhat arbitrary level of clouds. Hardcoding things like that in production code is usually frowned upon, but we shall do it occasionally for the sake of simplicity and to minimize code size of examples.</p></div></div><p>As you can<a id="id468" class="indexterm"/> see, there are no moving parts here at all, just three rectangles positioned along the top and bottom edges of the screen. This scene depends on textures being exposed as properties (beginning with <code class="literal">tx_</code>) of the <code class="literal">Background</code> class, which we're going to implement next.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec85"/>Loading tileable textures</h2></div></div></div><p>We <a id="id469" class="indexterm"/>shall start with the helper function for loading tileable textures: this functionality will be used a lot in the following code, so it's a good idea to abstract it up front.</p><p>One way to do so is creating an intermediate <code class="literal">Widget</code> subclass, which will then serve as a base class for our custom widgets (in <code class="literal">main.py</code>):</p><div><pre class="programlisting">from kivy.core.image import Image
from kivy.uix.widget import Widget

class BaseWidget(Widget):
    def load_tileable(self, name):
        t = Image('%s.png' % name).texture
        t.wrap = 'repeat'
        setattr(self, 'tx_%s' % name, t)</pre></div><p>The bit that warrants creating the helper function is <code class="literal">t.wrap = 'repeat'</code>. We need to apply this to every tiled texture.</p><p>While we're at that, we also store the newly loaded texture using the naming convention of <code class="literal">tx_</code> followed by the filename of an image. For example, a call to <code class="literal">load_tileable('grass')</code> will load the file called <code class="literal">grass.png</code> and store the resulting texture in a <code class="literal">self.tx_grass</code> attribute. This naming logic should be easy to follow.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec86"/>The Background widget</h2></div></div></div><a id="id470" class="indexterm"/><p>Being able to conveniently load textures, we can now implement the <code class="literal">Background</code> widget as follows:</p><div><pre class="programlisting">from kivy.properties import ObjectProperty

class Background(BaseWidget):
    tx_floor = ObjectProperty(None)
    tx_grass = ObjectProperty(None)
    tx_cloud = ObjectProperty(None)

    def __init__(self, **kwargs):
        super(Background, self).__init__(**kwargs)

        for name in ('floor', 'grass', 'cloud'):
            self.load_tileable(name)</pre></div><p>If you run the code at this point, you'll see distorted textures stretched to fill corresponding rectangles; this happens in the absence of explicitly given texture coordinates. To fix this, we need to adjust the <code class="literal">uvsize</code> property of each texture, which denotes how many times a texture is repeated to fill a polygon. For example, a <code class="literal">uvsize</code> of <code class="literal">(2, 2)</code> means that a texture fills one fourth of a rectangle.</p><p>This helper method will be used to set <code class="literal">uvsize</code> to an appropriate value so that our textures aren't distorted:</p><div><pre class="programlisting">def set_background_size(self, tx):
    tx.uvsize = (self.width / tx.width, -1)</pre></div><div><div><h3 class="title"><a id="note42"/>Note</h3><p>Negative texture coordinates, as seen in this example, mean that the texture gets flipped. Kivy uses this effect to avoid costly raster operations, shifting the load to the GPU (graphics card), which is designed to handle these operations with ease.</p></div></div><p>This<a id="id471" class="indexterm"/> method depends on the width of a background, so it's appropriate to invoke it every time the widget's <code class="literal">size</code> property changes, using the <code class="literal">on_size()</code> callback. This keeps each texture's <code class="literal">uvsize</code> in sync, for example, when the user resizes the application window manually:</p><div><pre class="programlisting">def on_size(self, *args):
    for tx in (self.tx_floor, self.tx_grass, self.tx_cloud):
        self.set_background_size(tx)</pre></div><p>If done properly, the code so far produces a background similar to the following:</p><div><img src="img/7849OS_07_03.jpg" alt="The Background widget"/><div><p>Static background with textures</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec87"/>Animating the background</h2></div></div></div><p>The last<a id="id472" class="indexterm"/> thing that we need to do before moving on to other parts of the application is a background animation. First, we add a monotonous timer running at roughly 60 ticks per second to the <code class="literal">KivyBirdApp</code> application class:</p><div><pre class="programlisting">from kivy.app import App
from kivy.clock import Clock

class KivyBirdApp(App):
    def on_start(self):
        self.background = self.root.ids.background
        Clock.schedule_interval(self.update, 0.016)

    def update(self, nap):
        self.background.update(nap)</pre></div><p>The <code class="literal">update()</code> method<a id="id473" class="indexterm"/> just passes control to a similar method of the <code class="literal">Background</code> widget for now. The scope of this method is going to expand later, when we have more moving parts in our program.</p><p>In <code class="literal">Background.update()</code>, we change the texture origin (namely, a property called <code class="literal">uvpos</code>) to simulate movement:</p><div><pre class="programlisting">def update(self, nap):
    self.set_background_uv('tx_floor', 2 * nap)
    self.set_background_uv('tx_grass', 0.5 * nap)
    self.set_background_uv('tx_cloud', 0.1 * nap)

def set_background_uv(self, name, val):
    t = getattr(self, name)
    t.uvpos = ((t.uvpos[0] + val) % self.width, t.uvpos[1])
    self.property(name).dispatch(self)</pre></div><p>Again, the interesting stuff happens in a helper function, <code class="literal">set_background_uv()</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It increments the first component of the <code class="literal">uvpos</code> property, shifting the texture origin horizontally</li><li class="listitem" style="list-style-type: disc">It calls <code class="literal">dispatch()</code> on the texture property, signaling that it has changed</li></ul></div><p>Canvas instructions (in <code class="literal">kivybird.kv</code>) listen to this change and react accordingly, rendering the texture with updated origin. This results in a smooth animation.</p><p>Multipliers that control the animation speed of different layers (see the second argument of all <code class="literal">set_background_uv()</code> calls) are selected arbitrarily to create the desired parallax effect. This is purely cosmetic; go ahead and change them to witness the effect it has on the animation.</p><p>The background is now complete, and the next thing on our list is making pipes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Making pipes</h1></div></div></div><p>A pipe is <a id="id474" class="indexterm"/>divided into two parts, lower and upper, with <a id="id475" class="indexterm"/>a gap in between for player to pass through. Each part, in turn, consists of variable-length body and the pipe cap, or <em>pcap</em>—a fixed-size thickening at the end of the pipe facing the gap. We are going to use the following images to draw pipes:</p><div><img src="img/7849OS_07_04.jpg" alt="Making pipes"/><div><p>Images for pipes</p></div></div><p>If the preceding explanation doesn't ring the bell, see the first illustration in this chapter and you'll immediately understand what this means.</p><p>Again, the layout in the <code class="literal">kivybird.kv</code> file provides a convenient starting point:</p><div><pre class="programlisting">&lt;Pipe&gt;:
    canvas:
        Rectangle:
            pos: (self.x + 4, <strong>self.FLOOR</strong>)
            size: (56, <strong>self.lower_len</strong>)
            texture: <strong>self.tx_pipe</strong>
            tex_coords: <strong>self.lower_coords</strong>

        Rectangle:
            pos: (self.x, <strong>self.FLOOR</strong> + <strong>self.lower_len</strong>)
            size: (64, <strong>self.PCAP_HEIGHT</strong>)
            texture: <strong>self.tx_pcap</strong>

        Rectangle:
            pos: (self.x + 4, <strong>self.upper_y</strong>)
            size: (56, <strong>self.upper_len</strong>)
            texture: <strong>self.tx_pipe</strong>
            tex_coords: <strong>self.upper_coords</strong>

        Rectangle:
            pos: (self.x, <strong>self.upper_y</strong> - <strong>self.PCAP_HEIGHT</strong>)
            size: (64, <strong>self.PCAP_HEIGHT</strong>)
            texture: <strong>self.tx_pcap</strong>

    size_hint: (None, 1)
    width: 64</pre></div><p>Conceptually, this<a id="id476" class="indexterm"/> is very simple: four rectangles are being rendered on canvas, listed in the order of appearance in the source:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Lower pipe body</li><li class="listitem" style="list-style-type: disc">Lower pipe cap</li><li class="listitem" style="list-style-type: disc">Upper pipe body</li><li class="listitem" style="list-style-type: disc">Upper pipe cap</li></ul></div><div><img src="img/7849OS_07_09.jpg" alt="Making pipes"/><div><p>Composition of pipes from rectangles</p></div></div><p>This listing depends on many attributes of the <code class="literal">Pipe</code> object; similar to how the <code class="literal">Background</code> widget is implemented, these properties are used to connect the Python implementation of an algorithm to a graphical representation of the widget (canvas instructions).</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec88"/>An overview of the pipe properties</h2></div></div></div><p>All the interesting<a id="id477" class="indexterm"/> attributes of the <code class="literal">Pipe</code> widget are shown in the following code snippet:</p><div><pre class="programlisting">from kivy.properties import (AliasProperty,
                             ListProperty,
                             NumericProperty,
                             ObjectProperty)

class Pipe(BaseWidget):
    FLOOR = 96
    PCAP_HEIGHT = 26
    PIPE_GAP = 120

    tx_pipe = ObjectProperty(None)
    tx_pcap = ObjectProperty(None)

    ratio = NumericProperty(0.5)
    lower_len = NumericProperty(0)
    lower_coords = ListProperty((0, 0, 1, 0, 1, 1, 0, 1))
    upper_len = NumericProperty(0)
    upper_coords = ListProperty((0, 0, 1, 0, 1, 1, 0, 1))

    upper_y = AliasProperty(
        lambda self: self.height - self.upper_len,
        None, bind=['height', 'upper_len'])</pre></div><p>First, constants are set in <code class="literal">ALL_CAPS</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FLOOR</code>: This <a id="id478" class="indexterm"/>is the ground level (height of the floor texture)</li><li class="listitem" style="list-style-type: disc"><code class="literal">PCAP_HEIGHT</code>: This<a id="id479" class="indexterm"/> is the height of a pipe cap, also derived from the corresponding texture</li><li class="listitem" style="list-style-type: disc"><code class="literal">PIPE_GAP</code>: This<a id="id480" class="indexterm"/> is the size of passage left for the player</li></ul></div><p>Next come the <a id="id481" class="indexterm"/>texture properties <code class="literal">tx_pipe</code> and <a id="id482" class="indexterm"/>
<code class="literal">tx_pcap</code>. They<a id="id483" class="indexterm"/> are used in the same fashion as those found in the <code class="literal">Background</code> class:</p><div><pre class="programlisting">class Pipe(BaseWidget):
    def __init__(self, **kwargs):
        super(Pipe, self).__init__(**kwargs)

        for name in ('pipe', 'pcap'):
            self.load_tileable(name)</pre></div><p>The <code class="literal">ratio</code> property<a id="id484" class="indexterm"/> indicates where the gap is located: the value of <code class="literal">0.5</code> (the default) means center, <code class="literal">0</code> is the bottom of the screen (on the ground), and <code class="literal">1</code> is the top of the screen (in the sky).</p><p>The <a id="id485" class="indexterm"/>
<code class="literal">lower_len</code> and<a id="id486" class="indexterm"/> <code class="literal">upper_len</code> properties represent pipe lengths, excluding the cap. These are derived from <code class="literal">ratio</code> and the available screen height.</p><p>The <code class="literal">upper_y</code>
<a id="id487" class="indexterm"/> alias is a helper introduced to reduce typing; it's computed on the fly and is always equal to <code class="literal">height - upper_len</code> (see the implementation).</p><p>This leaves us with two important properties used to set texture coordinates for canvas instructions, namely <code class="literal">lower_coords</code> and <code class="literal">upper_coords</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec89"/>Setting texture coordinates</h2></div></div></div><p>In the<a id="id488" class="indexterm"/> implementation of the <code class="literal">Background</code> widget, we were tweaking the texture's own attributes, such as <code class="literal">uvsize</code> and <code class="literal">uvpos</code>, to control its rendering. The problem with this approach is that it affects all instances of the texture.</p><p>This is perfectly fine as long as textures aren't reused on different geometries, which is exactly the case with the background. This time around, however, we need to control texture coordinates per canvas primitive, so we're not going to touch <code class="literal">uvsize</code> and <code class="literal">uvpos</code> at all. Instead, we will use <code class="literal">Rectangle.tex_coords</code>.</p><p>The <code class="literal">Rectangle.tex_coords</code> property accepts a list or tuple of eight numbers, assigning texture coordinates to corners of the rectangle in question. The mapping of coordinates to indices in the <code class="literal">tex_coords</code> list is shown in the following screenshot:</p><div><img src="img/7849OS_07_05.jpg" alt="Setting texture coordinates"/><div><p>Mapping of texture coordinates to a rectangular polygon</p></div></div><div><div><h3 class="title"><a id="note43"/>Note</h3><p>Texture mapping commonly uses <em>u</em> and <em>v</em> variables instead of <em>x</em> and <em>y</em>. This makes it easier to tell apart geometry and texture coordinates, which are often interleaved in code.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec90"/>Implementing pipes</h2></div></div></div><p>This <a id="id489" class="indexterm"/>whole topic may sound confusing at first, so let's simplify things a bit: we're only going to fix tiling on pipes vertically, and we just need to adjust the fifth and seventh elements of <code class="literal">tex_coords</code> to achieve our noble goal. Moreover, the values in <code class="literal">tex_coords</code> have the same meaning as those in <code class="literal">uvsize</code>.</p><p>Long story short, the following function adjusts the coordinates for correct tiling based on pipe length:</p><div><pre class="programlisting">def set_coords(self, coords, len):
    len /= 16  # height of the texture
    coords[5:] = (len, 0, len)  # set the last 3 items</pre></div><p>Easy, right? What's left to do is a boring, yet also not at all complicated math: computing the length of pipes based on <code class="literal">ratio</code> and screen height. The code is as follows:</p><div><pre class="programlisting">def on_size(self, *args):
    pipes_length = self.height - (
        Pipe.FLOOR + Pipe.PIPE_GAP + 2 * Pipe.PCAP_HEIGHT)
    self.lower_len = self.ratio * pipes_length
    self.upper_len = pipes_length - self.lower_len
    self.set_coords(self.lower_coords, self.lower_len)
    self.set_coords(self.upper_coords, self.upper_len)</pre></div><p>This pretty <a id="id490" class="indexterm"/>self-evident code lives in the <code class="literal">on_size()</code> handler to keep all related properties in sync with the screen size. To also reflect changes to <code class="literal">ratio</code>, we can issue the following function call:</p><div><pre class="programlisting">self.bind(ratio=self.on_size)</pre></div><p>You may have noticed that we don't change this property in our code yet. This is because the whole lifecycle of the pipes will be handled by the application class, <code class="literal">KivyBirdApp</code>, as you will see shortly.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec91"/>Spawning pipes</h2></div></div></div><p>It turns out<a id="id491" class="indexterm"/> that to create an illusion of an endless forest of pipes, we need just a screenful of them, as we can recycle ones that went off the screen and push them to the back of the queue.</p><p>We're going to create pipes about half screen width apart from one another to give the player some wiggle room; this means that only three pipes can be seen on the screen at the same time. We will create four of them for a good measure.</p><p>The following code snippet contains an implementation of the described algorithm:</p><div><pre class="programlisting">class KivyBirdApp(App):
    pipes = []

    def on_start(self):
        self.spacing = 0.5 * self.root.width
        # ...

    def spawn_pipes(self):
        for p in self.pipes:
            self.root.remove_widget(p)

        self.pipes = []

        for i in range(4):
            p = Pipe(x=self.root.width + (self.spacing * i))
            p.ratio = random.uniform(0.25, 0.75)
            self.root.add_widget(p)
            self.pipes.append(p)</pre></div><p>The use of the <code class="literal">pipes</code> list should be considered an implementation detail. We could have traversed the list of child widgets to access pipes, but it's just nicer this way.</p><p>The cleanup code at the beginning of the <code class="literal">spawn_pipes()</code> method will allow us to easily restart the game later.</p><p>We also <a id="id492" class="indexterm"/>randomize each pipe's <code class="literal">ratio</code> in this function. Notice that the range is artificially constrained to [0.25, 0.75], while technically it's [0, 1]—narrowing this space makes the game somewhat easier to play, with fewer vertical maneuvers necessary to go from gate to gate.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec92"/>Moving and recycling pipes</h2></div></div></div><p>Unlike<a id="id493" class="indexterm"/> the background <a id="id494" class="indexterm"/>where we shifted the textures' <code class="literal">uvpos</code> attribute to imitate movement, pipes actually move. This is the revised <code class="literal">KivyBirdApp.update()</code> method that involves repositioning and recycling pipes:</p><div><pre class="programlisting">def update(self, nap):
    self.background.update(nap)

    for p in self.pipes:
        p.x -= 96 * nap
        if p.x &lt;= -64:  # pipe gone off screen
            p.x += 4 * self.spacing
            p.ratio = random.uniform(0.25, 0.75)</pre></div><p>As with the previous animations, <code class="literal">96</code> is an ad hoc time multiplier that just happens to work; increasing it makes the game more fast-paced.</p><p>When pushing back a pipe, we randomize its <code class="literal">ratio</code> again, creating a unique path for the player to follow. The following screenshot summarizes the endlessly looping result so far:</p><div><img src="img/7849OS_07_06.jpg" alt="Moving and recycling pipes"/><div><p>Moving pipes and background – a Flappy Bird-themed screensaver</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Introducing Kivy Bird</h1></div></div></div><p>Next on <a id="id495" class="indexterm"/>our list is the playable character, that is, the <a id="id496" class="indexterm"/>biologically improbable Kivy Bird:</p><div><img src="img/7849OS_07_07.jpg" alt="Introducing Kivy Bird"/><div><p>Rare species, the Kivy Bird sprite</p></div></div><p>There will be <a id="id497" class="indexterm"/>nothing fancy related to textures this time; in fact, the <code class="literal">Bird</code> class will be derived from Kivy's <code class="literal">Image</code> widget (<code class="literal">kivy.uix.image.Image</code>) to completely avoid doing any clever rendering whatsoever.</p><p>In <code class="literal">kivybird.kv</code> we need a bare minimum of properties involving the bird image depicted earlier; its initial position and size are given as follows:</p><div><pre class="programlisting">Bird:
    id: bird
    pos_hint: {'center_x': 0.3333, 'center_y': 0.6}
    size: (54, 54)
    size_hint: (None, None)
    source: 'bird.png'</pre></div><p>This is the initial implementation of the <code class="literal">Bird</code> class in Python:</p><div><pre class="programlisting">from kivy.uix.image import Image as ImageWidget

class Bird(ImageWidget):
    pass</pre></div><p>Yup, it does nothing at all. Soon, we're going to spoil it by adding rudimentary physics and other things, but first we need to lay some groundwork in the application class in order to make the game stateful.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Revised application flow</h2></div></div></div><p>Now, we<a id="id498" class="indexterm"/> shall mimic the original game somewhat:</p><div><ol class="orderedlist arabic"><li class="listitem">At first, we'll just show the bird sitting there without any pipes or gravitation. Such a state will be denoted by <code class="literal">playing = False</code> in the code.</li><li class="listitem">As soon as the user interacts with the game (either clicks or taps anywhere on the screen, or presses the space bar on the keyboard), the state changes to <code class="literal">playing = True</code>, pipes start spawning, and gravity starts to affect the bird, which falls as a rock to an imaginary death. The user needs to continue interacting with the game to keep the bird airborne.</li><li class="listitem">In the event of collision with something, the game goes back to <code class="literal">playing = False</code> and everything sits in place until the next user interaction, which in turn restarts the process from step 2.</li></ol></div><p>In order to<a id="id499" class="indexterm"/> implement this, we need to receive user input. Thankfully, this is borderline trivial, especially since we're interested just in the fact that an event occurred (we aren't checking where the click or tap landed, for example—the whole screen is one big button for the purposes of this game).</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec25"/>Accepting user input</h3></div></div></div><p>Let's take <a id="id500" class="indexterm"/>a look at the implementation right away, since there is very little left to discuss on this particular topic:</p><div><pre class="programlisting">from kivy.core.window import Window, Keyboard

class KivyBirdApp(App):
    playing = False

    def on_start(self):
        # ...
        Window.bind(on_key_down=self.on_key_down)
        self.background.on_touch_down = self.user_action

    def on_key_down(self, window, key, *args):
        if key == Keyboard.keycodes['spacebar']:
            self.user_action()

    def user_action(self, *args):
        if not self.playing:
            self.spawn_pipes()
            self.playing = True</pre></div><p>This is the whole user input handling we're going to need: the <code class="literal">on_key_down</code> event handles the keyboard input, checking for a specific key (in this case, the spacebar). The <code class="literal">on_touch_down</code> event handles the rest—clicking, tapping, and whatnot. Both ultimately end up calling the <code class="literal">user_action()</code> method, which in turn runs <code class="literal">spawn_pipes()</code> and sets <code class="literal">playing</code> to <code class="literal">True</code> (only when needed).</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec94"/>Learning to fly straight down</h2></div></div></div><p>Next, we're going to implement gravity<a id="id501" class="indexterm"/> so that our bird could fly in at least one direction. For this, we will introduce a new <code class="literal">Bird.speed</code> property and a new constant—the acceleration of free fall. The speed vector will grow downwards each frame, resulting in a uniformly accelerated animation of falling.</p><p>The following listing contains the implementation of a described shooting bird:</p><div><pre class="programlisting">class Bird(ImageWidget):
    ACCEL_FALL = 0.25

    speed = NumericProperty(0)

    def gravity_on(self, height):
        # Replace pos_hint with a value
        self.pos_hint.pop('center_y', None)
        self.center_y = 0.6 * height

    def update(self, nap):
        self.speed -= Bird.ACCEL_FALL
        self.y += self.speed</pre></div><p>The <code class="literal">gravity_on()</code> method will be called when <code class="literal">playing</code> becomes <code class="literal">True</code>. Insert the highlighted line into the <code class="literal">KivyBirdApp.user_action()</code> method:</p><div><pre class="programlisting">if not self.playing:
    <strong>self.bird.gravity_on(self.root.height)</strong>
    self.spawn_pipes()
    self.playing = True</pre></div><p>This method effectively resets the initial position of a bird and allows vertical motion by removing the <code class="literal">'center_y'</code> constraint from <code class="literal">pos_hint</code>.</p><div><div><h3 class="title"><a id="note44"/>Note</h3><p>The <code class="literal">self.bird</code> reference is similar to <code class="literal">self.background</code> that we've seen earlier. The following code snippet should reside in the <code class="literal">KivyBirdApp.on_start()</code> method:</p><div><pre class="programlisting">self.background = self.root.ids.background
self.bird = self.root.ids.bird</pre></div><p>This is done for convenience alone.</p></div></div><p>We also need to call <code class="literal">Bird.update()</code> from <code class="literal">KivyBirdApp.update()</code>. At the same time, this is the perfect opportunity to put a guard preventing useless updates to game objects while not playing:</p><div><pre class="programlisting">    def update(self, nap):
        self.background.update(nap)
        <strong>if not self.playing:</strong>
<strong>            return  # don't move bird or pipes</strong>

<strong>        self.bird.update(nap)</strong>
        # rest of the code omitted</pre></div><p>As you can<a id="id502" class="indexterm"/> see, the <code class="literal">Background.update()</code> method gets called no matter what; everything else is invoked only when necessary.</p><p>What's missing from this implementation is the ability to stay in the air. This will be our next topic.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec26"/>Remaining in flight</h3></div></div></div><p>Implementing the<a id="id503" class="indexterm"/> Flappy Bird-style jumpy flight is incredibly easy. We can just override the <code class="literal">Bird.speed</code> momentarily, setting it to a positive value and then letting it decay normally as the bird continues to fall. Let's add the following method to the <code class="literal">Bird</code> class:</p><div><pre class="programlisting">ACCEL_JUMP = 5

def bump(self):
    self.speed = Bird.ACCEL_JUMP</pre></div><p>Now we need to put a call to <code class="literal">self.bird.bump()</code> at the end of the <code class="literal">KivyBirdApp.user_action()</code> function, and there, all done: we can stay in the air by mashing the spacebar or clicking inside the viewport repeatedly.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Rotating the bird</h2></div></div></div><p>Rotating <a id="id504" class="indexterm"/>the bird is a brief topic and isn't related to the physics of the bird, but instead focuses on the eye candy. It would be nice if the bird would rotate accordingly to its trajectory: if it's going up, its nose should point in a general direction of the top-right corner of the screen and towards the bottom-right corner when it declines.</p><p>The easiest way to approximate the angle is by using the value of <code class="literal">Bird.speed</code> instead:</p><div><pre class="programlisting">class Bird(ImageWidget):
    speed = NumericProperty(0)
    angle = AliasProperty(
        lambda self: 5 * self.speed,
        None, bind=['speed'])</pre></div><p>Again, the multiplier shown here is completely arbitrary.</p><p>Now, in order to actually rotate the sprite, we can introduce the following definition to the <code class="literal">kivybird.kv</code> file:</p><div><pre class="programlisting">&lt;Bird&gt;:
    canvas.before:
        PushMatrix
        Rotate:
            angle: root.angle
            axis: (0, 0, 1)
            origin: root.center

    canvas.after:
        PopMatrix</pre></div><p>This operation changes the local coordinate system that OpenGL uses for this sprite, potentially affecting all subsequent rendering. Don't forget to save (<code class="literal">PushMatrix</code>) and restore (<code class="literal">PopMatrix</code>) the <a id="id505" class="indexterm"/>coordinate system state; otherwise, catastrophic glitches may occur, and the whole scene can end up skewed or spinning.</p><div><div><h3 class="title"><a id="note46"/>Note</h3><p>The opposite is also true: if you're experiencing inexplicable application-wide rendering problems, look for low-level OpenGL instructions that aren't properly scoped.</p></div></div><p>After these changes, the bird should properly align itself with the trajectory of the flight.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Collision detection</h1></div></div></div><p>The last<a id="id506" class="indexterm"/> thing that is absolutely vital for the gameplay is the collision detection, which ends the game when the bird collides with either the floor, the ceiling, or a pipe.</p><p>Checking whether we've met floor or ceiling is as simple as comparing <code class="literal">bird.y</code> to a ground level or screen height (taking into account the height of the bird itself in the second comparison). In <code class="literal">KivyBirdApp</code>, we have the following code</p><div><pre class="programlisting">def test_game_over(self):
    if self.bird.y &lt; 90 or \
            self.bird.y &gt; self.root.height - 50:
        return True

    return False</pre></div><p>It's a bit more complex when looking for a collision with pipes, but not substantially so. We can subdivide this next check in two: first, we test for a horizontal collision using Kivy's built-in <code class="literal">collide_widget()</code> method, and then check whether vertical coordinates are within limits imposed by the <code class="literal">lower_len</code> and <code class="literal">upper_len</code> attributes of a pipe we're flying into.</p><p>Hence, the revised version of the <code class="literal">KivyBirdApp.test_game_over()</code> method is shown as follows:</p><div><pre class="programlisting">    def test_game_over(self):
        screen_height = self.root.height

        if self.bird.y &lt; 90 or \
                self.bird.y &gt; screen_height - 50:
            return True

        for p in self.pipes:
            if not p.collide_widget(self.bird):
                continue

            # The gap between pipes
            if (self.bird.y &lt; p.lower_len + 116 or
                self.bird.y &gt; screen_height - (
                    p.upper_len + 75)):
                return True

        return False</pre></div><p>This function <a id="id507" class="indexterm"/>returns <code class="literal">False</code> only if every check failed. This could be further optimized to test a maximum of one pipe at a time (the one which is roughly in the same area on screen as the bird; there is always at most one such pipe, given enough spacing between them).</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Game over</h2></div></div></div><p>So what happens<a id="id508" class="indexterm"/> when a collision was indeed found? As it turns out, very little; we just switch <code class="literal">self.playing</code> to <code class="literal">False</code>, and that's it. The check can be added to the bottom of <code class="literal">KivyBirdApp.update()</code> after all other computations take place:</p><div><pre class="programlisting">def update(self, nap):
    # ...
    if self.test_game_over():
        self.playing = False</pre></div><p>This stops the world until the user triggers another interaction, restarting the game. The most rewarding part of writing the collision detection code is playtesting it, triggering the game over state in a multitude of amusing ways:</p><div><img src="img/7849OS_07_08.jpg" alt="Game over"/><div><p>Exploring different approaches to failing (collage)</p></div></div><p>If there is no <a id="id509" class="indexterm"/>winning condition, then at least losing should be fun.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Producing sound effects</h1></div></div></div><p>This part <a id="id510" class="indexterm"/>will be <a id="id511" class="indexterm"/>less focused on the Kivy Bird game specifically; it's more of an overview of various tools that can be employed to add sound effects to a game or application.</p><p>The biggest problem with sound effects is rarely a technical one. Creating good-quality sound effects is no small task, and software engineers oftentimes aren't skilled musicians or audio engineers. Moreover, most applications are actually usable with no sound, which is why audio can easily be purposefully neglected or just overlooked during development.</p><p>Fortunately, there are tools that facilitate producing okay-quality sound effects while possessing zero domain-specific knowledge. A perfect example is <a id="id512" class="indexterm"/>
<strong>Bfxr</strong>, a<a id="id513" class="indexterm"/> synthesizer specifically aimed at sporadic game development. It is available for free at <a class="ulink" href="http://www.bfxr.net">www.bfxr.net</a>.</p><p>The usage <a id="id514" class="indexterm"/>of Bfxr family of tools boils down to clicking preset buttons until it generates a nice sound, and then hitting <strong>Save to Disk</strong> to store the result as a <code class="literal">.wav</code> (uncompressed sound) file.</p><div><img src="img/7849OS_07_10.jpg" alt="Producing sound effects"/><div><p>Bfxr's user interface may not seem friendly at first, but it's actually very easy to use</p></div></div><p>This is a<a id="id515" class="indexterm"/> great<a id="id516" class="indexterm"/> tool in terms of productivity. Using Bfxr, you can create passable sound effects literally within minutes—and they will be (mostly) unique to your app. For many hobbyist game developers, this program is truly a game changer, pun intended.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Kivy sound playback</h2></div></div></div><p>On<a id="id517" class="indexterm"/> the programmatic side of things, the API for playback that Kivy provides is dead simple:</p><div><pre class="programlisting">from kivy.core.audio import SoundLoader

snd = SoundLoader.load('sound.wav')
snd.play()</pre></div><p>The <code class="literal">play()</code> method starts playback, and that's it. Well, not really: there is a slight problem with this simplistic approach, especially for games.</p><p>In many game situations, it may be desirable to play the same sound over and over in rapid succession so that samples overlap. Take, for example, automatic fire. The problem with Kivy's <code class="literal">Sound</code> class (not unique to it, however—for example, the <code class="literal">&lt;audio&gt;</code> tag in HTML5 behaves similarly) is that it allows only one instance of the sample to play at any given time.</p><p>The options are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Wait until the previous playback has ended (the default behavior, all subsequent events will be silent)</li><li class="listitem" style="list-style-type: disc">Stop and restart the playback for each event, which is also problematic (this may introduce unnecessary delays, clicks, or other audio artifacts)</li></ul></div><p>To solve <a id="id518" class="indexterm"/>this issue, we need to create a pool (actually a queue) of <code class="literal">Sound</code> objects so that each subsequent call to <code class="literal">play()</code> involves another <code class="literal">Sound</code>. When the queue is exhausted, we rewind it and start from the beginning. Given a queue large enough, we can get rid of the aforementioned <code class="literal">Sound</code> limitation completely. In practice, such pool rarely exceeds a size of 10.</p><p>Let's take a look at the implementation of the described technique:</p><div><pre class="programlisting">class MultiAudio:
    _next = 0

    def __init__(self, filename, count):
        self.buf = [SoundLoader.load(filename)
                    for i in range(count)]

    def play(self):
        self.buf[self._next].play()
        self._next = (self._next + 1) % len(self.buf)</pre></div><p>The usage is as follows:</p><div><pre class="programlisting">snd = MultiAudio('sound.wav', 5)
snd.play()</pre></div><p>The second argument to the constructor stands for pool size. Note how we keep rudimentary compatibility with the existing <code class="literal">Sound</code> API, namely the <code class="literal">play()</code> method. This allows using the code as a drop-in replacement of a <code class="literal">Sound</code> object in simple scenarios.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Adding sound to the Kivy Bird game</h2></div></div></div><p>To finish<a id="id519" class="indexterm"/> things off with a practical example, let's add sound effects to the Kivy Bird game we've written over the course of this chapter.</p><p>There are two frequent events that could use a soundtrack, namely, the bird climbing and the bird colliding with objects and triggering the game over state.</p><p>The former event, initiated by clicking or tapping, can indeed happen very frequently in a rapid succession; we'll use a sample pool for this one. The latter, game over, can't possibly occur quite as fast, so it's fine to leave it as a plain <code class="literal">Sound</code> object:</p><div><pre class="programlisting">snd_bump = MultiAudio('bump.wav', 4)
snd_game_over = SoundLoader.load('game_over.wav')</pre></div><p>This code makes use of the <code class="literal">MultiAudio</code> class laid out earlier. The only thing left is to put calls to the <code class="literal">play()</code> method at the appropriate points, as shown in the following code snippet:</p><div><pre class="programlisting">if self.test_game_over():
    <strong>snd_game_over.play()</strong>
    self.playing = False

def user_action(self, *args):
    <strong>snd_bump.play()</strong>
</pre></div><p>From now<a id="id520" class="indexterm"/> on, the gameplay will be accompanied by heart-rending sounds. This concludes the Kivy Bird game tutorial; I hope you liked it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Summary</h1></div></div></div><p>In this chapter, we made a small Kivy game from simple building blocks such as canvas instructions and widgets.</p><p>As a UI toolkit, Kivy gets many things right and its remarkable flexibility allows you to build pretty much anything, be it another boring Twitter client or a video game. One aspect that deserves special mention is Kivy's implementation of properties—these are immensely helpful to organize data flow across the board and help us to effectively eliminate useless updates (such as redraws in the absence of changed properties).</p><p>Another thing about Kivy that may be surprising and counterintuitive at first is its relatively high performance—especially since Python isn't exactly famous for being extremely quick. This is partly because low-level subsystems in Kivy are written in Cython and compiled to a blazing fast machine code, with performance levels about the same as, for example, the C language. Also, the use of hardware-accelerated graphics all but guarantees smooth animations, if done properly.</p><p>We will explore the topic of cranking up the rendering performance in the next chapter.</p></div></body></html>