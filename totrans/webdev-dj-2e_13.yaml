- en: 13\. Generating CSV, PDF, and Other Binary Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 生成 CSV、PDF 以及其他二进制文件
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter teaches you how to generate files in different data formats, such
    as **CSV**, **PDF**, and other binary file formats (for example, Excel-compatible
    files) using some of the common libraries that are available inside Python. This
    knowledge will help you build web projects that let your users export and download
    records from your site into familiar CSV or Excel-based formats. You will also
    learn how to generate graph plots inside Python and render them as HTML and display
    them inside your web applications. Moreover, you will be able to build features
    that let users export your data in PDF format.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教会你如何使用 Python 中的一些常用库生成不同数据格式的文件，例如 **CSV**、**PDF** 以及其他二进制文件格式（例如，兼容 Excel
    的文件）。这些知识将帮助你构建允许用户将网站上的记录导出并下载到熟悉的 CSV 或 Excel 格式的 Web 项目。你还将学习如何在 Python 中生成图表，并将其渲染为
    HTML，在 Web 应用程序中显示。此外，你将能够构建允许用户以 PDF 格式导出数据的特性。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we have learned the various aspects of the Django framework and explored
    how we can build web applications using Django with all the features and customizations
    we want.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了 Django 框架的各个方面，并探讨了如何使用 Django 构建具有我们所需的所有功能和自定义的 Web 应用程序。
- en: Let's say that while building a web application, we need to do some analysis
    and prepare some reports. We may need to analyze user demographics about how the
    platform is being used or generate data that can be fed into machine learning
    systems to find patterns. We want our website to display some of the results of
    our analysis in a tabular format and other results as detailed graphs and charts.
    Furthermore, we also want to allow our users to export the reports and peruse
    them further in applications such as Jupyter Notebook and Excel.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在构建 Web 应用程序时需要进行分析并准备一些报告。我们可能需要分析用户的人口统计信息，了解平台的使用情况，或者生成可以输入到机器学习系统中以寻找模式的数据。我们希望我们的网站能够以表格形式显示我们分析的一些结果，并以详细的图表和图形显示其他结果。此外，我们还希望允许我们的用户将报告导出，并在
    Jupyter Notebook 和 Excel 等应用程序中进一步查看。
- en: As we work our way through this chapter, we will learn how to bring these ideas
    to fruition and implement functionality in our web application that allows us
    to export records into structured formats such as tables through the use of **Comma-Separated
    Value** (**CSV**) files or Excel files. We will also learn how to allow our users
    to generate visual representations of the data we have stored inside our web application
    and export it as PDF so it can be distributed easily for quick reference.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐步学习本章内容，我们将了解如何将这些想法付诸实践，并在我们的 Web 应用程序中实现功能，使我们能够通过使用 **逗号分隔值**（**CSV**）文件或
    Excel 文件将记录导出为结构化格式，如表格。我们还将学习如何允许我们的用户生成我们存储在 Web 应用程序中的数据的视觉表示，并将其导出为 PDF 格式，以便可以轻松分发以供快速参考。
- en: Let's start our journey by learning how to work with CSV files in Python. Learning
    this skill will help us create functionality that allows our readers to export
    our data for further analysis.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习如何在 Python 中处理 CSV 文件开始我们的旅程。掌握这项技能将帮助我们创建允许我们的读者将我们的数据导出以进行进一步分析的功能。
- en: Working with CSV Files inside Python
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 中处理 CSV 文件
- en: There are several reasons we may need to export the data in our application.
    One of the reasons may involve performing analysis of that data – for example,
    we may need to understand the demographics of users registered on the application
    or extract patterns of application usage. We may also need to find out how our
    application is working for users to design future improvements. Such use cases
    require data to be in a format that can be easily consumed and analyzed. Here,
    the CSV file format comes to the rescue.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要将应用程序中的数据导出出去，原因有很多。其中一个原因可能涉及对该数据进行分析——例如，我们可能需要了解在应用程序上注册的用户的人口统计信息或提取应用程序使用的模式。我们可能还需要了解我们的应用程序对用户的工作情况，以便设计未来的改进。这些用例需要数据以易于消费和分析的格式存在。在这里，CSV
    文件格式就派上用场了。
- en: CSV is a handy file format that can be used to quickly export data from an application
    in a row-and-column format. CSV files usually have data separated by simple delimiters,
    which are used to differentiate one column from another, and newlines, which are
    used to indicate the start of a new record (or row) inside the table.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 是一种方便的文件格式，可以用于快速将数据从应用程序中以行和列的格式导出。CSV 文件通常使用简单的分隔符来分隔数据，这些分隔符用于区分一列与另一列，以及换行符，用于在表格内指示新记录（或行）的开始。
- en: Python has great support for working with CSV files in its standard library
    thanks to the `csv` module. This support enables the reading, parsing, and writing
    of CSV files. Let's take a look at how we can leverage the CSV module provided
    by Python to work on CSV files and read and write data from them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python的标准库通过`csv`模块提供了对CSV文件的良好支持。这种支持使得读取、解析和写入CSV文件成为可能。让我们看看我们如何利用Python提供的CSV模块来处理CSV文件，并从中读取和写入数据。
- en: Working with Python's CSV Module
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python的CSV模块
- en: The `csv` module from Python provides us with the ability to interact with files
    that are in CSV format, which is nothing but a text file format. That is, the
    data stored inside the CSV files is human-readable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`csv`模块为我们提供了与CSV格式文件交互的能力，CSV格式实际上是一种文本文件格式。也就是说，存储在CSV文件中的数据是可读的。
- en: The `csv` module requires that the file is opened before the methods supplied
    by the `csv` module can be applied. Let's take a look at how we can start with
    the very basic operation of reading data from CSV files.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv`模块要求在应用`csv`模块提供的方法之前打开文件。让我们看看我们如何从读取CSV文件的基本操作开始。'
- en: Reading Data from a CSV File
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从CSV文件读取数据
- en: 'Reading data from CSV files is quite easy and consists of the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从CSV文件读取数据相当简单，包括以下步骤：
- en: 'First, we open the file:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们打开文件：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we are reading the file using the Python `open()` method and then passing
    it the name of the file from which the data is to be read.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们使用Python的`open()`方法读取文件，然后将要读取数据的文件名传递给它。
- en: 'Then, we read the data from the `file` object using the `csv` module''s `reader` method:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`csv`模块的`reader`方法从`file`对象中读取数据：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the first line, we imported the `csv` module, which contains the set of
    methods required to work on CSV files:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一行，我们导入了`csv`模块，它包含处理CSV文件所需的方法集：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With the file opened, the next step is to create a CSV `reader` object by using
    the `csv` module''s `reader` method. This method takes in the `file` object as
    returned by the `open()` call and uses the `file` object to read the data from
    the CSV file:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件打开后，下一步是使用`csv`模块的`reader`方法创建一个CSV`reader`对象。此方法接受由`open()`调用返回的`file`对象，并使用该`file`对象从CSV文件中读取数据：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The data read by the `reader()` method is returned as a list of a list, where
    every sub-list is a new record and every value inside the list is a value for
    the specified column. Generally, the first record in the list is referred to as
    a header, which denotes the different columns that are present inside the CSV
    file, but it is not necessary to have a `header` field inside a CSV file.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过`reader()`方法读取的数据以列表的列表形式返回，其中每个子列表是一个新记录，列表中的每个值都是指定列的值。通常，列表中的第一个记录被称为标题，它表示CSV文件中存在的不同列，但CSV文件中不需要有`header`字段。
- en: 'Once the data is read by the `csv` module, we can iterate over this data to
    perform any kind of operation we may desire. This can be done as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据被`csv`模块读取，我们就可以遍历这些数据以执行我们可能需要的任何操作。这可以按照以下方式完成：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the processing is done, we close the CSV file simply by using the `close()`
    method in Python''s file handler object:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦处理完成，我们可以通过在Python的文件处理对象中调用`close()`方法简单地关闭CSV文件：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let's look at our first exercise, where we will implement a simple module
    that helps us read a CSV file and output its contents on our screen.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的第一个练习，我们将实现一个简单的模块，帮助我们读取CSV文件并将内容输出到屏幕上。
- en: 'Exercise 13.01: Reading a CSV File with Python'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01：使用Python读取CSV文件
- en: 'In this exercise, you will read and process a CSV file inside Python using
    Python''s built-in `csv` module. The CSV file contains fictitious market data
    of several NASDAQ-listed companies:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用Python的内置`csv`模块在Python中读取并处理CSV文件。CSV文件包含几家纳斯达克上市公司虚构的市场数据：
- en: 'First, download the `market_cap.csv` file from the GitHub repository for this
    book by clicking the following link: [http://packt.live/2MNWzOV](http://packt.live/2MNWzOV).'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过点击以下链接从本书的GitHub存储库下载`market_cap.csv`文件：[http://packt.live/2MNWzOV](http://packt.live/2MNWzOV)。
- en: Note
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The CSV file consists of randomly generated data and does not correspond to
    any historical market trends.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CSV文件由随机生成数据组成，并不对应任何历史市场趋势。
- en: 'Once the file is downloaded, open it and take a look at its contents. You will
    realize that the file contains a set of comma-separated values with each different
    record on its own line:![Figure 13.1: Contents of the market cap CSV file'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件下载完成，打开它并查看其内容。您会发现文件包含一组以逗号分隔的值，每个不同的记录都在自己的行上：![图 13.1：市值 CSV 文件内容
- en: '](img/B15509_13_01.jpg)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_13_01.jpg)'
- en: 'Figure 13.1: Contents of the market cap CSV file'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.1：市值 CSV 文件内容
- en: 'Once the file is downloaded, you can proceed to write the first piece of code.
    For this, create a new file named `csv_reader.py` in the same directory where
    the CSV file was downloaded and add the following code inside it:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件下载完成，您可以继续编写第一段代码。为此，在 CSV 文件下载的同一目录中创建一个名为 `csv_reader.py` 的新文件，并在其中添加以下代码：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's try to understand what you just implemented in the preceding snippet of code.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们尝试理解您在上面的代码片段中刚刚实现的内容。
- en: 'After importing the `csv` module, to keep the code modular, you created a new
    method named `read_csv()` that takes in a single parameter, the filename to read
    the data from:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入 `csv` 模块后，为了使代码模块化，您创建了一个名为 `read_csv()` 的新方法，它接受一个参数，即从其中读取数据的文件名：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, if you are not familiar with the approach of opening the file shown in
    the preceding snippet, this is also known as the `with` block will have access
    to the `file` object, and once the code exits the scope of the `with` block, the
    file will be closed automatically.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果您不熟悉前面代码片段中显示的文件打开方法，这也被称为 `with` 块将有权访问 `file` 对象，一旦代码退出 `with` 块的作用域，文件将自动关闭。
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once this is done, you write the entry point method, from which your code will
    begin executing, by calling the `read_csv()` method and passing the name of the
    CSV file to read:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此操作后，您需要编写入口点方法，您的代码将从该方法开始执行，通过调用 `read_csv()` 方法并传递要读取的 CSV 文件名：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this, you are done and ready to parse your CSV file now. You can do this
    by running your Python file in the Terminal or Command Prompt as shown here:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些步骤，您现在可以解析您的 CSV 文件了。您可以通过在终端或命令提示符中运行您的 Python 文件来完成此操作，如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Or, on Windows, use **python csv_reader.py** as shown in *Figure 13.2*.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，在 Windows 上，如 *图 13.2* 所示，使用 **python csv_reader.py**。
- en: 'Once the code executes, you should expect to see the following output:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码执行后，您应该会看到以下输出：
- en: '![Figure 13.2: Output from the CSV reader program'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.2：CSV 读取程序输出'
- en: '](img/B15509_13_02.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_13_02.jpg)'
- en: 'Figure 13.2: Output from the CSV reader program'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：CSV 读取程序输出
- en: With this, now you know how to read CSV file contents. Also, as you can see
    from the output of *Exercise 13.01*, *Reading a CSV File with Python*, the output
    for individual rows is represented in the form of a list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，现在您已经知道了如何读取 CSV 文件内容。同时，如您从 *练习 13.01* 的输出中看到，使用 Python 读取 CSV 文件，单个行的输出以列表的形式表示。
- en: Now, let's look at how we can use the Python `csv` module to create new CSV
    files.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 Python 的 `csv` 模块创建新的 CSV 文件。
- en: Writing to CSV Files Using Python
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 写入 CSV 文件
- en: In the previous section, we explored how we can use the `csv` module in Python
    to read the contents of the CSV-formatted files. Now, let us learn how we can
    write CSV data to files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了如何使用 Python 的 `csv` 模块读取 CSV 格式文件的 内容。现在，让我们学习如何将 CSV 数据写入文件。
- en: 'Writing CSV data follows a similar approach as reading from a CSV file, with
    some minor differences. The following steps outline the process of writing data
    to CSV files:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 CSV 数据的方法与从 CSV 文件读取类似，但有细微差别。以下步骤概述了将数据写入 CSV 文件的过程：
- en: 'Open the file in writing mode:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以写入模式打开文件：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Obtain a CSV writer object, which can help us write data that is correctly
    formatted in the CSV format. This is done by calling the `writer()` method of
    the `csv` module, which returns a `writer` object, which can be used to write
    CSV format-compatible data to a CSV file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个 CSV 写入器对象，这可以帮助我们写入正确格式化的 CSV 格式的数据。这是通过调用 `csv` 模块的 `writer()` 方法来完成的，它返回一个
    `writer` 对象，可以用来将 CSV 格式兼容的数据写入 CSV 文件：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the `writer` object is available, we can start writing the data. This
    is facilitated by the `write_row()` method of the `writer` object. The `write_row()`
    method takes in a list of values that it writes to the CSV file. The list itself
    indicates a single row and the values inside the list indicate the values of columns:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 `writer` 对象可用，我们就可以开始写入数据。这可以通过 `writer` 对象的 `write_row()` 方法来实现。`write_row()`
    方法接收一个值列表，将其写入 CSV 文件。列表本身表示一行，列表内的值表示列的值：
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you want to write multiple records in a single call, you can also use the
    `writerows()` method of the CSV writer. The `writerows()` method behaves similarly
    to the `writerow()` method but takes a list of lists and can write multiple rows
    in one go:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the records are written, we can then close the CSV file:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's apply what we've learned in the next exercise and implement a program
    that will help us in writing values to CSV files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.02: Generating a CSV File Using Python''s csv Module'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the Python `csv` module to create new CSV files:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `csv_writer.py`, inside which you will write the code
    for the CSV writer. Inside this file, add the following code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this code, you should now be able to create new CSV files easily. Now,
    going step by step, let''s understand what you are trying to do in this code:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You define a new method called `write_csv()`, which takes three parameters:
    the name of the file to which the data should be written (`filename`), the list
    of column names that should be used as headers (`header`), and lastly a list of
    a list that contains the data that needs to be mapped to individual columns (`data`):'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, with the parameters in place, the next step is to open the file to which
    the data needs to be written and map it to an object:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the file is opened, you perform three main steps: first, obtain a new
    CSV writer object by using the `writer()` method from the `csv` module and passing
    it to the file handler that holds a reference to your opened file:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next step involves using the CSV writer''s `writerow()` method to write
    your dataset''s header fields into the file:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you have written the header, the last step is to write the data to the
    CSV file for the individual columns that are present. For this, use the `csv`
    module''s `writerows()` method to write multiple rows at once:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We could also have merged the step of writing the header and data into a single
    line of code by having the header list as the first element of the data list and
    calling the `writerows()` method with the data list as a parameter.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you have created the methods that can write the provided data to a CSV
    file, you write the code for the entry point call, and inside it, set up the values
    for the header, data, and filename fields, and finally call the `write_csv()`
    method that you defined earlier:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now with the code in place, execute the file you just created and see whether
    it creates the CSV file. To execute, run the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the execution finishes, you will see that a new file has been created
    in the same directory as the one in which you executed the command. When you open
    the file, the contents should resemble what you see in the following figure:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.3: Output from the CSV writer sample_output.csv'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_13_03.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.3: Output from the CSV writer sample_output.csv'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: With this, now you are well equipped to read and write the contents of CSV files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise, we have learned how to write data to a CSV file. Now, it
    is time to look at some enhancements that can make reading and writing data to
    CSV files as a developer more convenient.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们学习了如何将数据写入CSV文件。现在，是时候看看一些增强功能，这些功能可以使作为开发者的您在读取和写入CSV文件时更加方便。
- en: A Better Way to Read and Write CSV Files
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好地读取和写入CSV文件的方法
- en: Now, there is one important thing that needs to be taken care of. If you remember,
    the data read by the CSV reader usually maps values to a list. Now, if you want
    to access the values of individual columns, you need to use list indexes to access
    them. This way is not natural and causes a higher degree of coupling between the
    program responsible for writing the file and the one responsible for reading the
    file. For example, what if the writer program shuffled the order of the rows?
    In this case, you now have to update the reader program to make sure it identifies
    correct rows. So, the question arises, do we have a better way to read and write
    values that, instead of using list indexes, uses column names while preserving
    the context?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一件重要的事情需要注意。如果您还记得，CSV读取器读取的数据通常将值映射到列表。现在，如果您想访问单个列的值，您需要使用列表索引来访问它们。这种方式并不自然，并且会导致编写文件和读取文件之间的耦合度更高。例如，如果编写程序打乱了行的顺序怎么办？在这种情况下，您现在必须更新读取程序以确保它能够识别正确的行。因此，问题出现了，我们是否有更好的方法来读取和写入值，而不是使用列表索引，而是使用列名，同时保留上下文？
- en: The answer to this is yes, and the solution is provided by another set of CSV
    modules known as `DictReader` and `DictWriter`, which provide the functionality
    of mapping objects in a CSV file to `dict`, rather than to a list.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是肯定的，解决方案由另一组名为`DictReader`和`DictWriter`的CSV模块提供，这些模块提供将CSV文件中的对象映射到`dict`的功能，而不是映射到列表。
- en: 'This interface is easy to implement. Let''s revisit the code you wrote in *Exercise
    13.01*, *Reading a CSV File with Python*. If you wanted to parse the code as dict,
    the implementation of the `read_csv()` method would need to be changed as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口易于实现。让我们回顾一下您在*练习13.01*，*使用Python读取CSV文件*中编写的代码。如果您想将代码解析为字典，`read_csv()`方法的实现需要按如下所示更改：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you will notice, the only change we did was to change `csv.reader()` to
    `csv.DictReader()`, which should represent individual rows in the CSV file as
    `OrderedDict`. You can also verify this by making this change and executing the
    following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到，我们做的唯一改变是将`csv.reader()`改为`csv.DictReader()`，这应该将CSV文件中的单独行表示为`OrderedDict`。您也可以通过进行此更改并执行以下命令来验证这一点：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should result in the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '![Figure 13.4: Output with DictReader'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4：使用DictReader的输出'
- en: '](img/B15509_13_04.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_13_04.jpg)'
- en: 'Figure 13.4: Output with DictReader'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：使用DictReader的输出
- en: 'As you can see in the preceding figure, the individual rows are mapped as key-value
    pairs in the dictionary. To access these individual fields in rows, we can use
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，单独的行被映射为字典中的键值对。要访问这些单独的行中的字段，我们可以使用以下方法：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That should give us the value of the `stock_symbol` field from our individual records.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给出我们单个记录中的`stock_symbol`字段的值。
- en: 'Similarly, you can also use the `DictWriter()` interface to operate on CSV
    files as dictionaries. To see this, let''s take a look at the `write_csv()` method
    in *Exercise 13.02*, *Generating a CSV File Using Python''s csv Module*, and modify
    it as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您也可以使用`DictWriter()`接口将CSV文件操作为字典。为了了解这一点，让我们看看*练习13.02*，*使用Python的csv模块生成CSV文件*中的`write_csv()`方法，并按如下方式修改它：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we replaced `csv.writer()` with `csv.DictWriter()`, which
    provides a dictionary-like interface to interact with CSV files. `DictWriter()`
    also takes in a `fieldnames` parameter, which is used to map the individual columns
    in a CSV file before writing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`csv.writer()`替换为`csv.DictWriter()`，它提供了一个类似字典的接口来与CSV文件交互。`DictWriter()`还接受一个`fieldnames`参数，该参数用于在写入之前将CSV文件中的单独列映射。
- en: Next, to write this header, call the `writeheader()` method, which writes the
    `fieldname` header to the CSV file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了写入这个标题，调用`writeheader()`方法，它将`fieldname`标题写入CSV文件。
- en: 'The final call involves the `writerows()` method, which takes in a list of
    dictionaries and writes them to the CSV file. For the code to work correctly,
    you also need to modify the data list to resemble the one shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的调用涉及`writerows()`方法，它接受一个字典列表并将其写入CSV文件。为了使代码正确运行，您还需要修改数据列表，使其类似于以下所示：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this, you will have enough knowledge to work with CSV files inside Python.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Since we are talking about how to deal with tabular data, specifically reading
    and writing it to files, let's take a look at one of the more well-known file
    formats used by one of the most popular tabular data editors – Microsoft Excel.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Working with Excel Files in Python
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft Excel is a world-renowned software in the field of book-keeping and
    tabular record management. Similarly, the XLSX file format that was introduced
    with Excel has seen rapid and widespread adoption and is now supported by all
    the major product vendors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: You will find that Microsoft Excel and its XLSX format are used quite a lot
    in the marketing and sales departments of many companies. Let's say, for one such
    company's marketing department, you are building a web portal in Django that keeps
    track of the products purchased by users. It also displays data about the purchases,
    such as the time of purchase and the location where the purchase was made. The
    marketing and sales teams are planning to use this data to generate leads or to
    create relevant advertisements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Since the marketing and sales teams use Excel quite a lot, we might want to
    export the data available inside our web application in XLSX format, which is
    native to Excel. Soon, we will look at how we can make our website work with this
    XLSX format. But before that, let's quickly take a look at the usage of binary
    file formats.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Binary File Formats for Data Exports
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have worked mainly with textual data and how we can read and write
    it from text files. But often, text-based formats are not enough. For example,
    imagine you want to export an image or a graph. How will you represent an image
    or a graph as text, and how will you read and write to these images?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'In these situations, binary file formats can come to our rescue. They can help
    us read and write to and from a rich and diverse set of data. All commercial operating
    systems provide native support for working with both text and binary file formats,
    and it comes as no surprise that Python provides one of the most versatile implementations
    to work on binary data files. A simple example of this is the `open` command,
    which you use to state the format you would like to open a file in:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `b` indicates binary.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Starting from this section, we will now be dealing with how we can work on binary
    files and use them to represent and export data from our Django web application.
    The first of the formats we are going to look at is the XLSX file format made
    popular by Microsoft Excel.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: So, let's dive into the handling of XLSX files with Python.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Working with XLSX Files Using the XlsxWriter Package
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn more about the XLSX file format and understand
    how we can work with it using the **XlsxWriter** package.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: XLSX Files
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'XLSX files are binary files that are used to store tabular data. These files
    can be read by any software that implements support for this format. The XLSX
    format arranges data into two logical partitions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '`Example_file.xlsx` is a workbook **(1)**:![Figure 13.5: Workbooks and Worksheets
    in Excel'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B15509_13_05.jpg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.5: Workbooks and Worksheets in Excel'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`Sheet1` and `Sheet2` are two worksheets **(2)**.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with XLSX format, these are the two units that we generally work
    on. If you know about relational databases, you can think of workbooks as databases
    and worksheets as tables.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: With that, let's try to understand how we can start working on XLSX files inside Python.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The XlsxWriter Python Package
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python does not provide native support for working with XLSX files through its
    standard library. But thanks to the vast community of developers within the Python
    ecosystem, it is easy to find a number of packages that can help us manage our
    interaction with XLSX files. One popular package in this category is **XlsxWriter**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '`XlsxWriter` is an actively maintained package by the developer community,
    providing support for interacting with XLSX files. The package provides a lot
    of useful functionalities and supports the creation and management of workbooks
    as well as worksheets in individual workbooks. You can install it by running the
    following command in Terminal or Command Prompt:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once installed, you can import the `xlsxwriter` module as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So, let's look at how we can start creating XLSX files with the support of the
    `XlsxWriter` package.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Workbook
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start working on XLSX files, we first need to create them. An XLSX file
    is also known as a workbook and can be created by calling the `Workbook` class
    from the `xlsxwriter` module as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The call to the `Workbook` class opens a binary file, specified with the `filename`
    argument, and returns an instance of `workbook` that can be used to further create
    worksheets and write data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Worksheet
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can start writing data to an XLSX file, we first need to create a
    worksheet. This can be done easily by calling the `add_worksheet()` method of
    the `workbook` object we obtained in the previous step:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `add_worksheet()` method creates a new worksheet, adds it to the workbook,
    and returns an object mapping the worksheet to a Python object, through which
    we can write data to the worksheet.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Writing Data to the Worksheet
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once a reference to the worksheet is available, we can start writing data to
    it by calling the `write` method of the `worksheet` object as shown:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, the `write()` method takes three parameters: a row number (`row_num`),
    a column number (`col_num`), and the data that belongs to the [`row_num, col_num`]
    pair as represented by `col_value`. This call can be repeated to insert multiple
    data items into the worksheet.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Data to the Workbook
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once all the data is written, to finalize the written datasets and cleanly
    close the XLSX file, you call the `close()` method on the workbook:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有数据都写入，为了最终确定写入的数据集并干净地关闭XLSX文件，您需要在工作簿上调用`close()`方法：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method writes any data that may be in the file buffer and finally closes
    the workbook. Now, let's use this knowledge to implement our own code, which will
    help us write data to an XLSX file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法写入文件缓冲区中可能存在的任何数据，并最终关闭工作簿。现在，让我们利用这些知识来实现我们自己的代码，这将帮助我们向XLSX文件写入数据。
- en: Further Reading
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'It''s not possible to cover all the methods and features the `XlsxWriter` package
    provides in this chapter. For more information, you can read the official documentation:
    [https://xlsxwriter.readthedocs.io/contents.html](https://xlsxwriter.readthedocs.io/contents.html).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，无法涵盖`XlsxWriter`包提供的所有方法和功能。更多信息，您可以阅读官方文档：[https://xlsxwriter.readthedocs.io/contents.html](https://xlsxwriter.readthedocs.io/contents.html)。
- en: 'Exercise 13.03: Creating XLSX Files in Python'
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.03：在Python中创建XLSX文件
- en: 'In this exercise, you will use the `XlsxWriter` package to create a new Excel
    (XLSX) file and add data to it from Python:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用`XlsxWriter`包创建一个新的Excel（XLSX）文件，并从Python向其中添加数据：
- en: 'For this exercise, you will need the `XlsxWriter` package installed on your
    system. You can install it by running the following command in your Terminal app
    or Command Prompt:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，您需要在系统中安装`XlsxWriter`包。您可以通过在终端应用程序或命令提示符中运行以下命令来安装它：
- en: '[PRE36]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once the command finishes, you will have the package installed on your system.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦命令执行完毕，您将在系统中安装上该包。
- en: 'With the package installed, you can start writing the code that will create
    the Excel file. Create a new file named `xlsx_demo.py` and add the following code
    inside it:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装了包之后，您就可以开始编写创建Excel文件的代码了。创建一个名为`xlsx_demo.py`的新文件，并在其中添加以下代码：
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code snippet, you have created a new function that will assist
    you in creating a new workbook in which you can store your data. Once you have
    created a new workbook, the next step is to create a worksheet that provides you
    with the tabular format needed for you to organize the data to be stored inside
    the XLSX workbook.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您已创建了一个新的函数，该函数将帮助您创建一个新的工作簿，您可以在其中存储数据。一旦创建了新的工作簿，下一步就是创建一个工作表，它为您提供了组织要存储在XLSX工作簿中的数据的表格格式。
- en: 'With the workbook created, create a new worksheet by adding the following code
    snippet to your `xlsx_demo.py` file:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建工作簿后，通过在您的`xlsx_demo.py`文件中添加以下代码片段来创建一个新的工作表：
- en: '[PRE38]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code snippet, you have created a new worksheet using the `add_worksheet()`
    method of the `workbook` object provided by the `XlsxWriter` package. This worksheet
    will then be used to write the data for the objects.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您已使用`XlsxWriter`包提供的`workbook`对象中的`add_worksheet()`方法创建了一个新的工作表。然后，这个工作表将被用来写入对象的数据。
- en: 'The next step is to create a helper function that can assist in writing the
    data to the worksheet in a tabular format defined by the row and column numbering.
    For this, add the following snippet of code to your `xlsx_writer.py` file:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个辅助函数，它可以协助将数据以表格格式写入工作表，该表格格式由行和列编号定义。为此，将以下代码片段添加到您的`xlsx_writer.py`文件中：
- en: '[PRE39]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code snippet, you have created a new function named `write_data()`
    that takes two parameters: the `worksheet` object to which the data needs to be
    written and the `data` object represented by a list of lists that needs to be
    written to the worksheet. The function iterates over the data passed to it and
    then writes the data to the row and column it belongs to.'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您已创建了一个名为`write_data()`的新函数，该函数接受两个参数：需要写入的`worksheet`对象和表示为列表的列表的`data`对象，这些列表需要写入工作表。该函数遍历传递给它的数据，然后将数据写入其所属的行和列。
- en: 'With all the core methods now implemented, you can now add the method that
    can help close the `workbook` object cleanly, such that the data is written to
    the file without any file corruption happening. For this, implement the following
    code snippet in the `xlsx_demo.py` file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有核心方法都已实现，您现在可以添加一个可以帮助干净地关闭`workbook`对象的方法，这样数据就可以写入文件而不会发生任何文件损坏。为此，在`xlsx_demo.py`文件中实现以下代码片段：
- en: '[PRE40]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The last step in the exercise is to integrate all the methods you have implemented
    in the previous steps. For this, create a new entry point method as shown in the
    following code snippet in your `xlsx_demo.py` file:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习的最后一步是将你在前几步中实现的所有方法集成在一起。为此，在你的 `xlsx_demo.py` 文件中创建一个新的入口点方法，如下面的代码片段所示：
- en: '[PRE41]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code snippet, you first created a dataset that you want to
    write to the XLSX file in the form of a list of lists. Once that was done, you
    obtained a new `workbook` object, which will be used to create an XLSX file. Inside
    this `workbook` object, you then created a worksheet to organize your data in
    a row-and-column format and then wrote the data to the worksheet and closed the
    workbook to persist the data to the disk.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你首先创建了一个数据集，你希望将其以列表的形式写入 XLSX 文件。一旦完成，你获得了一个新的 `workbook` 对象，该对象将用于创建
    XLSX 文件。在这个 `workbook` 对象内部，你创建了一个工作表来以行列格式组织你的数据，然后将数据写入工作表，并关闭工作簿以将数据持久化到磁盘。
- en: 'Now, let''s see whether the code you wrote works the way it is expected to
    work. For this, run the following command:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看你编写的代码是否按预期工作。为此，运行以下命令：
- en: '[PRE42]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once the command is finished executing, you will see a new file with the name
    `sample_workbook.xlsx` being created in the directory where the command was executed.
    To verify whether it contains the correct results, open this file with either
    Microsoft Excel or Google Sheets and view the contents. It should resemble what
    you see here:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦命令执行完毕，你将在命令执行的目录中看到一个名为 `sample_workbook.xlsx` 的新文件被创建。为了验证它是否包含正确的结果，你可以用
    Microsoft Excel 或 Google Sheets 打开此文件，查看内容。它应该看起来像这里所示：
- en: '![Figure 13.6: Excel sheet generated using xlsxwriter'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.6：使用 xlsxwriter 生成的 Excel 表格]'
- en: '](img/B15509_13_06.jpg)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_13_06.jpg]'
- en: 'Figure 13.6: Excel sheet generated using xlsxwriter'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6：使用 xlsxwriter 生成的 Excel 表格
- en: 'With the help of the `xlsxwriter` module, you can also apply formulas to your
    columns. For example, if you wanted to add another row that shows the average
    age of the people in the spreadsheet, you can do that simply by modifying the
    `write_data()` method as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `xlsxwriter` 模块的帮助下，你还可以将公式应用到你的列上。例如，如果你想添加一行来显示电子表格中人们的平均年龄，你可以通过简单地修改如下的
    `write_data()` 方法来实现：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code snippet, you added an additional `write` call to the worksheet
    and used the `AVERAGE` function provided by Excel to calculate the average age
    of the people in the worksheet.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你向工作表添加了一个额外的 `write` 调用，并使用了 Excel 提供的 `AVERAGE` 函数来计算工作表中人们的平均年龄。
- en: With this, you now know how we can generate Microsoft Excel-compatible XLSX
    files using Python and how to export tabular content that's easily consumable
    by the different teams in your organization.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你现在知道了如何使用 Python 生成与 Microsoft Excel 兼容的 XLSX 文件，以及如何导出易于组织内部不同团队消费的表格内容。
- en: Now, let's cover another interesting file format that is widely used across
    the world.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨另一个在全球范围内广泛使用的有趣文件格式。
- en: Working with PDF Files in Python
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中处理 PDF 文件
- en: '**Portable Document Format** or **PDF** is one of the most common file formats
    in the world. You must have encountered PDF documents at some point. These documents
    can include business reports, digital books, and more.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**便携式文档格式**或**PDF**是世界上最常见的文件格式之一。你肯定在某些时候遇到过 PDF 文档。这些文档可以包括商业报告、数字书籍等等。'
- en: Also, do you remember ever having encountered websites that have a button that
    reads `Print` `page` `as` `PDF`? A lot of websites for government agencies readily
    provide this option, which allows you to print the web page directly as a PDF.
    So, the question arises, how can we do this for our web app? How should we add
    the option to export certain content as a PDF?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还记得曾经遇到过有“打印”页面“作为 PDF”按钮的网站吗？许多政府机构的网站都提供了这个选项，允许你直接将网页打印成 PDF。因此，问题来了，我们如何为我们的
    Web 应用程序做这件事？我们应该如何添加导出某些内容为 PDF 的选项？
- en: Over the years, a huge community of developers has contributed a lot of useful
    packages to the Python ecosystem. One of those packages can help us achieve PDF
    file generation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，一个庞大的开发者社区为 Python 生态系统贡献了大量的有用包。其中之一可以帮助我们实现 PDF 文件生成。
- en: Converting Web Pages to PDFs
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将网页转换为 PDF
- en: Sometimes, we may run into situations where we want to convert a web page into
    a PDF. For example, we may want to print a web page to store it as a local copy.
    This also comes in handy when trying to print a certificate that is natively displayed
    as a web page.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: To help us in such efforts, we can leverage a simple library known as `weasyprint`,
    which is maintained by a community of Python developers and allows the quick and
    easy conversion of web pages to PDFs. So, let's take a look at how we can generate
    a PDF version of a web page.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.04: Generating a PDF Version of a Web Page in Python'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will generate a PDF version of a website using Python.
    You will use a community-contributed Python module known as `weasyprint` that
    will help you generate the PDF:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the code in the upcoming steps work correctly, install the `weasyprint`
    module on your system. To do this, run the following command:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`weasyprint` depends on the `cairo` library. In case you haven''t installed `cairo`
    libraries, usage of `weasyprint` might raise an error with the message: `libcairo-2.dll`
    `file` `not` `found`. If you''re facing this issue or any other issue installing
    the module, use the `requirements.txt` file we''ve provided on our GitHub repository
    at [http://packt.live/3btLoVV](http://packt.live/3btLoVV). Download the file to
    your disk and open your Terminal, shell or Command Prompt and type the following
    command (you will need to `cd` to the path where you saved this file locally):
    `pip install -r requirements.txt`. If that doesn''t work, follow the steps as
    mentioned in the `weasyprint` documentation: [https://weasyprint.readthedocs.io/en/stable/install.html](https://weasyprint.readthedocs.io/en/stable/install.html).'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the package now installed, create a new file named `pdf_demo.py` that
    will contain the PDF generation logic. Inside this file, write the following code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s try to understand what this code does. In the first line, you imported
    the `HTML` class from the `weasyprint` package, which you installed in *step 1*:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This HTML class provides us with a mechanism through which we can read the HTML
    content of a website if we have its URL.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the next step, you created a new method named `generate_pdf()` that takes
    in two parameters, namely, the URL that should be used as the source URL for the
    generation of the PDF and the `pdf_file` parameter, which takes in the name of
    the file to which the document should be written:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, you passed the URL to the `HTML` class object you imported earlier. This
    caused the URL to be parsed by the `weasyprint` library and caused its HTML content
    to be read. Once this was done, you called the `write_pdf()` method of the `HTML`
    class object and provided to it the name of the file to which the content should
    be written:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After this, write the entry point code that sets up the URL (for this exercise,
    we will use the text version of the `generate_pdf()` method to generate the content:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, to see the code in action, run the following command:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once the command finishes executing, you will have a new PDF file named `demo_page.pdf`
    that is saved in the same directory where the command was executed. When you open
    the file, it should resemble what you see here:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.7: Web page converted to a PDF using weasyprint'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_13_07.jpg)'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.7: Web page converted to a PDF using weasyprint'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In the PDF file generated, we can see that the content seems to lack the formatting
    that the actual website has. This happens because the `weasyprint` package reads
    the HTML content but does not parse the attached CSS stylesheets for the page,
    so the page formatting is lost.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '`weasyprint` also makes it quite easy to change the formatting of a page. This
    can be done simply by introducing the stylesheet parameter to the `write_pdf()`
    method. A simple modification to our `generate_pdf()` method is described next:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, when the preceding code is executed, we will see that the font size for
    all the text inside the HTML body content of the page has a size of `8px` in the
    printed PDF version.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The `HTML` class in `weasyprint` is also capable of taking any local files as
    well as raw HTML string content and can use those files to generate PDFs. For
    further information, please visit the `weasyprint` documentation at [https://weasyprint.readthedocs.io](https://weasyprint.readthedocs.io).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned about how we can generate different types of binary
    files with Python, which can help us export our data in a structured manner or
    help us print PDF versions of our pages. Next, we will see how we can generate
    graph representations of our data using Python.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Graphs in Python
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs are a great way to visually represent data that changes within a specific
    dimension. We come across graphs quite frequently in our day-to-day lives, be
    it weather charts for a week, stock market movements, or student performance report cards.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, graphs can come in quite handy when we are working with our web applications.
    For Bookr, we can use graphs as a visual medium to show the user information about
    the number of books they read each week. Alternatively, we can show them the popularity
    of a book over time based on how many readers were reading the given book at a
    specific time. Now, let's look at how we can generate plots with Python and have
    them show up on our web pages.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Generating Graphs with plotly
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graphs can come in quite handy when trying to visualize patterns in the data
    maintained by our applications. There are a lot of Python libraries that help
    developers in generating static or interactive graphs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we will use `plotly`, a community-supported Python library that
    generates graphs and renders them on web pages. `plotly` is particularly interesting
    to us due to its ease of integration with Django.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it on your system, you can type in the following command in the
    command line:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that's done, let's take a look at how we can generate a graph visualization
    using `plotly`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Figure
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can get started with generating a graph, we first need to initialize
    a `plotly` `Figure` object, which essentially acts as a container for our graph.
    A `plotly` `Figure` object is quite easy to initialize; it can be done by using
    the following code snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `Figure()` constructor from the `graph_objs` module of `plotly` library
    returns an instance of the `Figure` graph container, inside which a graph can
    be generated. Once the `Figure` object is in place, the next thing that needs
    to be done is to generate a plot.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Plot
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A plot is a visual representation of a dataset. This plot could be a scatter
    plot, a line graph, a chart, and so on. For example, to generate a scatter plot,
    the following code snippet is used:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `Scatter` constructor takes in the values for the *X*-axis and *Y*-axis
    and returns an object that can be used to build a scatter plot. Once the `scatter_plot`
    object is generated, the next step is to add this plot to our `Figure`. This can
    be done as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `add_trace()` method is responsible for adding a plotting object to the
    figure and generating its visualization inside the figure.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a Plot on a Web Page
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the plot is added to the figure, it can be rendered on a web page by calling
    the `plot` method from the `offline` plotting module of `plotly` library. This
    is shown in the following code snippet:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `plot` method takes two primary parameters: the first is the figure that
    needs to be rendered and the second one is the HTML tag of the container inside
    which the figure HTML will be generated. The `plot` method returns fully integrated
    HTML that can be embedded in any web page or made a part of the template to render
    a graph.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Now, with this understanding of how graph plotting works, let's try a hands-on
    exercise to generate a graph for our sample dataset.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.05: Generating Graphs in Python'
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will generate a Graph plot using Python. It will be a
    scatter plot that will represent two-dimensional data:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you will be using the `plotly` library. To use this library,
    you first need to install it on the system. To do this, run the following command:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can install `plotly` and other dependencies for this exercise using the
    `requirements.txt` file we''ve provided on our GitHub repository: [http://packt.live/38y5OLR](http://packt.live/38y5OLR).'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the library now installed, create a new file named `scatter_plot_demo.py`
    and add the following `import` statements inside it:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once the imports are sorted, create a method named `generate_scatter_plot()`
    that takes in two parameters, the values for the *X*-axis and the values for the
    *Y*-axis:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Inside this method, first, create an object to act as a container for the graph:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the container for the graph is set up, create a new `Scatter` object with
    the values for the *X*-axis and *Y*-axis and add it to the graph `Figure` container:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once the scatter plot is ready and added to the figure, the last step is to
    generate the HTML, which can be used to render this plot inside a web page. To
    do this, call the `plot` method and pass the graph container object to it, and
    render the HTML inside an HTML `div` tag:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The complete `generate_scatter_plot()` method should look like this now:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once the HTML for the plot is generated, it needs to be rendered somewhere.
    For this, create a new method named `generate_html()`, which will take in the
    plot HTML as its parameter and render an HTML file consisting of the plot:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once the method is set up, the last step is to call it. For this, create a
    script entry point that will set up the values for the *X*-axis list and the *Y*-axis
    list and then call the `generate_scatter_plot()` method. With the value returned
    by the method, make a call to the `generate_html()` method, which will create
    an HTML page consisting of the scatter plot:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'With the code in place, run the file and see what output is generated. To run
    the code, execute the following command:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once the execution completes, there will be a new `plot_demo.html` file created
    in the same directory in which the script was executed. Upon opening the file,
    you should see the following:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.8: Graph generated in the browser using plotly'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_13_08.jpg)'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.8: Graph generated in the browser using plotly'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have generated our first scatter plot, where different points
    are connected by a line.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you used the `plotly` library to generate a graph that can
    be rendered inside a browser for your readers to visualize data.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know how you can work with graphs in Python and how to generate HTML
    pages from them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: But as a web developer, how you can use these graphs in Django? Let's find out.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Integrating plotly with Django
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The graphs generated by `plotly` are quite easy to embed in Django templates.
    Since the `plot` method returns a fully contained HTML that can be used to render
    a graph, we can use the HTML returned as a template variable in Django and pass
    it as it is. The Django templating engine will then take care of adding this generated
    HTML to the final template before it is shown in the browser.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Some sample code for doing this is shown next:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The preceding code will cause the `{{ plt_div }}` content used inside the template
    to be replaced by the HTML stored inside the `scatter_plot_demo` variable, and
    the final template to render the scatter plot of the number of books read per
    week.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Visualizations with Django
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections, you have learned how data can be read and written
    in different formats that cater to the different needs of users. But how can we
    use what we've learned to integrate with Django?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: For example, in Bookr, we might want to allow the user to export a list of books
    that they have read or visualize their book reading activity over a year. How
    can that be done? The next exercise in this chapter focuses on that aspect, where
    you will learn how the components we have seen so far can be integrated into Django
    web applications.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.06: Visualizing a User''s Reading History on the User Profile Page'
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will aim to modify the user's profile page such that the
    user can visualize their book reading history when they visit their profile page
    on Bookr.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how this can be done:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with integrating the ability to visualize the reading history
    of the user, you first need to install the `plotly` library. To do this, run the
    following command in your terminal:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can install `plotly` and other dependencies for this exercise using the
    `requirements.txt` file we''ve provided on our GitHub repository: [http://packt.live/3scIvPp](http://packt.live/3scIvPp).'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the library is installed, the next step is to write the code that will
    fetch the total books read by the user as well as the books read by the user on
    a per-month basis. For this, create a new file named `utils.py` under the `bookr`
    application directory and add the required imports, which will be used to fetch
    the book reading history of the user from the `Review` model of the `reviews` application:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Next, create a new utility method named `get_books_read_by_month()`, which takes
    in the username of the user for whom the reading history needs to be fetched.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the method, we query the `Review` model and return a dictionary of books
    read by the user on a per-month basis:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, let''s examine the following query, which is responsible for fetching
    the results of books read this year on a monthly basis:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This query can be broken down into the following components:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`year` field can be easily accessed from our `date_created` field by appending
    `__year`.'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`values()` call to select only the `month` field from the `date_created` attribute
    of the `Review` model on which you are going to run the group by operation.'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`annotate` method to the `QuerySet` instance returned by the `values()` call.'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have the utilities file in place, the next thing is to write the view
    function, which is going to help in showing the books-read-per-month plot on the
    user''s profile page. For this, open the `views.py` file under the `bookr` directory
    and start by adding the following imports to it:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Once these imports are done, the next thing to do is to modify the view function
    that renders the profile page. Currently, the profile page is being handled by
    the `profile()` method inside the `views.py` file. Modify the method to resemble
    the one shown here:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In this method, you did a couple of things. The first thing was that you called
    the `get_books_read_by_month()` method and provided it with the username of the
    currently logged-in user. This method returns the list of books read by a given
    user on a per-month basis in the current year:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The next thing you did was pre-initialize the *X*-axis and *Y*-axis for the
    graph with some default values. For this visualization, use the *X*-axis to display
    months and the *Y*-axis to display the number of books read.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, since you already know that a year is going to have only 12 months, pre-initialize
    the *X*-axis with a value between `1` and `12`:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For the books read, initialize the *Y*-axis with all the `12` indexes set to
    `0` as follows:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, with the pre-initialization done, fill in some actual values for the books
    read per month. For this, iterate upon the list you got as a result of the call
    made to `get_books_read_by_month(user.username)` and extract the month and the
    book count for the month from it.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the book count and month are extracted, the next step is to assign the
    `book_count` value to the `books_read` list at the month index:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, with the values for the axes set, generate a scatter plot using the `plotly` library:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Once the HTML for the plot is generated, pass it to the template using the
    `render()` method such that it can be visualized on the profile page:'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'With the view function done, the next step is to modify the template to render
    this graph. For this, open the `profile.html` file under the `templates` directory
    and add the following highlighted code to the file, just before the last `{% endblock
    %}` statement:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To try the visualization, run the following command and then navigate to your
    user profile by visiting `http://localhost:8080`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You should see a page that resembles the one shown next:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.9: User book reading history scatter plot'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_13_09.jpg)'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.9: User book reading history scatter plot'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding exercise, you saw how you can integrate a plotting library
    with Django to visualize the reading history of a user. Similarly, Django allows
    you to integrate any generic Python code into a web application, with the only
    constraint being that the data generated as a result of the integration should
    be transformed into a valid HTTP response that can be handled by any standard
    HTTP-compatible tool, such as a web browser or command-line tools such as CURL.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.01: Exporting the Books Read by a User as an XLSLX File'
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you will implement a new API endpoint inside Bookr that will
    allow your users to export and download a list of books they have read as an XLSX
    file:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Install the `XlsxWriter` library.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `utils.py` file created under the `bookr` application, create a new
    function that will help in fetching the list of books that have been read by the user.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `views.py` file under the `bookr` directory, create a new view function
    that will allow the user to download their reading history in the XLSX file format.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create an XLSX file inside the view function, first create a `BytesIO`-based
    in-memory file that can be used to store the data from the `XlsxWriter` library.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the data stored inside the in-memory file using the `getvalue()` method
    of the temporary file object.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a new `HttpResponse` instance with the `'application/vnd.ms-excel'`
    content type header, and then write the data obtained in step 5 to the response
    object.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the response object prepared, return the response object from the view function.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the view function ready, map it to a URL endpoint that can be visited by
    a user to download their book reading history.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have the URL endpoint mapped, start the application and log in to it
    with your user account. Once done, visit the URL endpoint you just created, and
    if upon visiting the URL endpoint your browser starts to download an Excel file,
    you have successfully completed the activity.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how we can deal with binary files and how Python's
    standard library, which comes pre-loaded with the necessary tools, can allow us
    to handle commonly used file formats such as CSV. We then moved on to learning
    how to read and write CSV files in Python using Python's CSV module. Later, we
    worked with the `XlsxWriter` package, which provides us with the ability to generate
    Microsoft Excel-compatible files right from our Python environment without worrying
    about the internal formatting of the file.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The second half of the chapter was dedicated to learning how to use the `weasyprint`
    library to generate PDF versions of HTML pages. This skill can come in handy when
    we want to provide our users with an easy option to print the HTML version of
    our page with any added CSS styling of our choosing. The last section of the chapter
    discussed how we can generate interactive graphs in Python and render them as
    HTML pages that can be viewed inside the browser using the `plotly` library.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can test the different components
    we have been implementing in the previous chapters to make sure that code changes
    do not break our website's functionality.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
