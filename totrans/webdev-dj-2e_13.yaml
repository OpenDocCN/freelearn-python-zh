- en: 13\. Generating CSV, PDF, and Other Binary Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter teaches you how to generate files in different data formats, such
    as **CSV**, **PDF**, and other binary file formats (for example, Excel-compatible
    files) using some of the common libraries that are available inside Python. This
    knowledge will help you build web projects that let your users export and download
    records from your site into familiar CSV or Excel-based formats. You will also
    learn how to generate graph plots inside Python and render them as HTML and display
    them inside your web applications. Moreover, you will be able to build features
    that let users export your data in PDF format.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned the various aspects of the Django framework and explored
    how we can build web applications using Django with all the features and customizations
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that while building a web application, we need to do some analysis
    and prepare some reports. We may need to analyze user demographics about how the
    platform is being used or generate data that can be fed into machine learning
    systems to find patterns. We want our website to display some of the results of
    our analysis in a tabular format and other results as detailed graphs and charts.
    Furthermore, we also want to allow our users to export the reports and peruse
    them further in applications such as Jupyter Notebook and Excel.
  prefs: []
  type: TYPE_NORMAL
- en: As we work our way through this chapter, we will learn how to bring these ideas
    to fruition and implement functionality in our web application that allows us
    to export records into structured formats such as tables through the use of **Comma-Separated
    Value** (**CSV**) files or Excel files. We will also learn how to allow our users
    to generate visual representations of the data we have stored inside our web application
    and export it as PDF so it can be distributed easily for quick reference.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start our journey by learning how to work with CSV files in Python. Learning
    this skill will help us create functionality that allows our readers to export
    our data for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CSV Files inside Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several reasons we may need to export the data in our application.
    One of the reasons may involve performing analysis of that data – for example,
    we may need to understand the demographics of users registered on the application
    or extract patterns of application usage. We may also need to find out how our
    application is working for users to design future improvements. Such use cases
    require data to be in a format that can be easily consumed and analyzed. Here,
    the CSV file format comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: CSV is a handy file format that can be used to quickly export data from an application
    in a row-and-column format. CSV files usually have data separated by simple delimiters,
    which are used to differentiate one column from another, and newlines, which are
    used to indicate the start of a new record (or row) inside the table.
  prefs: []
  type: TYPE_NORMAL
- en: Python has great support for working with CSV files in its standard library
    thanks to the `csv` module. This support enables the reading, parsing, and writing
    of CSV files. Let's take a look at how we can leverage the CSV module provided
    by Python to work on CSV files and read and write data from them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Python's CSV Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `csv` module from Python provides us with the ability to interact with files
    that are in CSV format, which is nothing but a text file format. That is, the
    data stored inside the CSV files is human-readable.
  prefs: []
  type: TYPE_NORMAL
- en: The `csv` module requires that the file is opened before the methods supplied
    by the `csv` module can be applied. Let's take a look at how we can start with
    the very basic operation of reading data from CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Data from a CSV File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading data from CSV files is quite easy and consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we open the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are reading the file using the Python `open()` method and then passing
    it the name of the file from which the data is to be read.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we read the data from the `file` object using the `csv` module''s `reader` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the first line, we imported the `csv` module, which contains the set of
    methods required to work on CSV files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the file opened, the next step is to create a CSV `reader` object by using
    the `csv` module''s `reader` method. This method takes in the `file` object as
    returned by the `open()` call and uses the `file` object to read the data from
    the CSV file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The data read by the `reader()` method is returned as a list of a list, where
    every sub-list is a new record and every value inside the list is a value for
    the specified column. Generally, the first record in the list is referred to as
    a header, which denotes the different columns that are present inside the CSV
    file, but it is not necessary to have a `header` field inside a CSV file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the data is read by the `csv` module, we can iterate over this data to
    perform any kind of operation we may desire. This can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the processing is done, we close the CSV file simply by using the `close()`
    method in Python''s file handler object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's look at our first exercise, where we will implement a simple module
    that helps us read a CSV file and output its contents on our screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.01: Reading a CSV File with Python'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will read and process a CSV file inside Python using
    Python''s built-in `csv` module. The CSV file contains fictitious market data
    of several NASDAQ-listed companies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, download the `market_cap.csv` file from the GitHub repository for this
    book by clicking the following link: [http://packt.live/2MNWzOV](http://packt.live/2MNWzOV).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The CSV file consists of randomly generated data and does not correspond to
    any historical market trends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the file is downloaded, open it and take a look at its contents. You will
    realize that the file contains a set of comma-separated values with each different
    record on its own line:![Figure 13.1: Contents of the market cap CSV file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_13_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.1: Contents of the market cap CSV file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the file is downloaded, you can proceed to write the first piece of code.
    For this, create a new file named `csv_reader.py` in the same directory where
    the CSV file was downloaded and add the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's try to understand what you just implemented in the preceding snippet of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After importing the `csv` module, to keep the code modular, you created a new
    method named `read_csv()` that takes in a single parameter, the filename to read
    the data from:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you are not familiar with the approach of opening the file shown in
    the preceding snippet, this is also known as the `with` block will have access
    to the `file` object, and once the code exits the scope of the `with` block, the
    file will be closed automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, you write the entry point method, from which your code will
    begin executing, by calling the `read_csv()` method and passing the name of the
    CSV file to read:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this, you are done and ready to parse your CSV file now. You can do this
    by running your Python file in the Terminal or Command Prompt as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Or, on Windows, use **python csv_reader.py** as shown in *Figure 13.2*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the code executes, you should expect to see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.2: Output from the CSV reader program'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_13_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.2: Output from the CSV reader program'
  prefs: []
  type: TYPE_NORMAL
- en: With this, now you know how to read CSV file contents. Also, as you can see
    from the output of *Exercise 13.01*, *Reading a CSV File with Python*, the output
    for individual rows is represented in the form of a list.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how we can use the Python `csv` module to create new CSV
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to CSV Files Using Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we explored how we can use the `csv` module in Python
    to read the contents of the CSV-formatted files. Now, let us learn how we can
    write CSV data to files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing CSV data follows a similar approach as reading from a CSV file, with
    some minor differences. The following steps outline the process of writing data
    to CSV files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file in writing mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Obtain a CSV writer object, which can help us write data that is correctly
    formatted in the CSV format. This is done by calling the `writer()` method of
    the `csv` module, which returns a `writer` object, which can be used to write
    CSV format-compatible data to a CSV file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the `writer` object is available, we can start writing the data. This
    is facilitated by the `write_row()` method of the `writer` object. The `write_row()`
    method takes in a list of values that it writes to the CSV file. The list itself
    indicates a single row and the values inside the list indicate the values of columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to write multiple records in a single call, you can also use the
    `writerows()` method of the CSV writer. The `writerows()` method behaves similarly
    to the `writerow()` method but takes a list of lists and can write multiple rows
    in one go:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the records are written, we can then close the CSV file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's apply what we've learned in the next exercise and implement a program
    that will help us in writing values to CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.02: Generating a CSV File Using Python''s csv Module'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the Python `csv` module to create new CSV files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `csv_writer.py`, inside which you will write the code
    for the CSV writer. Inside this file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this code, you should now be able to create new CSV files easily. Now,
    going step by step, let''s understand what you are trying to do in this code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You define a new method called `write_csv()`, which takes three parameters:
    the name of the file to which the data should be written (`filename`), the list
    of column names that should be used as headers (`header`), and lastly a list of
    a list that contains the data that needs to be mapped to individual columns (`data`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, with the parameters in place, the next step is to open the file to which
    the data needs to be written and map it to an object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the file is opened, you perform three main steps: first, obtain a new
    CSV writer object by using the `writer()` method from the `csv` module and passing
    it to the file handler that holds a reference to your opened file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step involves using the CSV writer''s `writerow()` method to write
    your dataset''s header fields into the file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have written the header, the last step is to write the data to the
    CSV file for the individual columns that are present. For this, use the `csv`
    module''s `writerows()` method to write multiple rows at once:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We could also have merged the step of writing the header and data into a single
    line of code by having the header list as the first element of the data list and
    calling the `writerows()` method with the data list as a parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you have created the methods that can write the provided data to a CSV
    file, you write the code for the entry point call, and inside it, set up the values
    for the header, data, and filename fields, and finally call the `write_csv()`
    method that you defined earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now with the code in place, execute the file you just created and see whether
    it creates the CSV file. To execute, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the execution finishes, you will see that a new file has been created
    in the same directory as the one in which you executed the command. When you open
    the file, the contents should resemble what you see in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.3: Output from the CSV writer sample_output.csv'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_13_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.3: Output from the CSV writer sample_output.csv'
  prefs: []
  type: TYPE_NORMAL
- en: With this, now you are well equipped to read and write the contents of CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise, we have learned how to write data to a CSV file. Now, it
    is time to look at some enhancements that can make reading and writing data to
    CSV files as a developer more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: A Better Way to Read and Write CSV Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, there is one important thing that needs to be taken care of. If you remember,
    the data read by the CSV reader usually maps values to a list. Now, if you want
    to access the values of individual columns, you need to use list indexes to access
    them. This way is not natural and causes a higher degree of coupling between the
    program responsible for writing the file and the one responsible for reading the
    file. For example, what if the writer program shuffled the order of the rows?
    In this case, you now have to update the reader program to make sure it identifies
    correct rows. So, the question arises, do we have a better way to read and write
    values that, instead of using list indexes, uses column names while preserving
    the context?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this is yes, and the solution is provided by another set of CSV
    modules known as `DictReader` and `DictWriter`, which provide the functionality
    of mapping objects in a CSV file to `dict`, rather than to a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This interface is easy to implement. Let''s revisit the code you wrote in *Exercise
    13.01*, *Reading a CSV File with Python*. If you wanted to parse the code as dict,
    the implementation of the `read_csv()` method would need to be changed as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you will notice, the only change we did was to change `csv.reader()` to
    `csv.DictReader()`, which should represent individual rows in the CSV file as
    `OrderedDict`. You can also verify this by making this change and executing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: Output with DictReader'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_13_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.4: Output with DictReader'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding figure, the individual rows are mapped as key-value
    pairs in the dictionary. To access these individual fields in rows, we can use
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That should give us the value of the `stock_symbol` field from our individual records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can also use the `DictWriter()` interface to operate on CSV
    files as dictionaries. To see this, let''s take a look at the `write_csv()` method
    in *Exercise 13.02*, *Generating a CSV File Using Python''s csv Module*, and modify
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we replaced `csv.writer()` with `csv.DictWriter()`, which
    provides a dictionary-like interface to interact with CSV files. `DictWriter()`
    also takes in a `fieldnames` parameter, which is used to map the individual columns
    in a CSV file before writing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, to write this header, call the `writeheader()` method, which writes the
    `fieldname` header to the CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final call involves the `writerows()` method, which takes in a list of
    dictionaries and writes them to the CSV file. For the code to work correctly,
    you also need to modify the data list to resemble the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this, you will have enough knowledge to work with CSV files inside Python.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are talking about how to deal with tabular data, specifically reading
    and writing it to files, let's take a look at one of the more well-known file
    formats used by one of the most popular tabular data editors – Microsoft Excel.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Excel Files in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft Excel is a world-renowned software in the field of book-keeping and
    tabular record management. Similarly, the XLSX file format that was introduced
    with Excel has seen rapid and widespread adoption and is now supported by all
    the major product vendors.
  prefs: []
  type: TYPE_NORMAL
- en: You will find that Microsoft Excel and its XLSX format are used quite a lot
    in the marketing and sales departments of many companies. Let's say, for one such
    company's marketing department, you are building a web portal in Django that keeps
    track of the products purchased by users. It also displays data about the purchases,
    such as the time of purchase and the location where the purchase was made. The
    marketing and sales teams are planning to use this data to generate leads or to
    create relevant advertisements.
  prefs: []
  type: TYPE_NORMAL
- en: Since the marketing and sales teams use Excel quite a lot, we might want to
    export the data available inside our web application in XLSX format, which is
    native to Excel. Soon, we will look at how we can make our website work with this
    XLSX format. But before that, let's quickly take a look at the usage of binary
    file formats.
  prefs: []
  type: TYPE_NORMAL
- en: Binary File Formats for Data Exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have worked mainly with textual data and how we can read and write
    it from text files. But often, text-based formats are not enough. For example,
    imagine you want to export an image or a graph. How will you represent an image
    or a graph as text, and how will you read and write to these images?
  prefs: []
  type: TYPE_NORMAL
- en: 'In these situations, binary file formats can come to our rescue. They can help
    us read and write to and from a rich and diverse set of data. All commercial operating
    systems provide native support for working with both text and binary file formats,
    and it comes as no surprise that Python provides one of the most versatile implementations
    to work on binary data files. A simple example of this is the `open` command,
    which you use to state the format you would like to open a file in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, `b` indicates binary.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from this section, we will now be dealing with how we can work on binary
    files and use them to represent and export data from our Django web application.
    The first of the formats we are going to look at is the XLSX file format made
    popular by Microsoft Excel.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's dive into the handling of XLSX files with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Working with XLSX Files Using the XlsxWriter Package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn more about the XLSX file format and understand
    how we can work with it using the **XlsxWriter** package.
  prefs: []
  type: TYPE_NORMAL
- en: XLSX Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'XLSX files are binary files that are used to store tabular data. These files
    can be read by any software that implements support for this format. The XLSX
    format arranges data into two logical partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Example_file.xlsx` is a workbook **(1)**:![Figure 13.5: Workbooks and Worksheets
    in Excel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B15509_13_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.5: Workbooks and Worksheets in Excel'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sheet1` and `Sheet2` are two worksheets **(2)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with XLSX format, these are the two units that we generally work
    on. If you know about relational databases, you can think of workbooks as databases
    and worksheets as tables.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let's try to understand how we can start working on XLSX files inside Python.
  prefs: []
  type: TYPE_NORMAL
- en: The XlsxWriter Python Package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python does not provide native support for working with XLSX files through its
    standard library. But thanks to the vast community of developers within the Python
    ecosystem, it is easy to find a number of packages that can help us manage our
    interaction with XLSX files. One popular package in this category is **XlsxWriter**.
  prefs: []
  type: TYPE_NORMAL
- en: '`XlsxWriter` is an actively maintained package by the developer community,
    providing support for interacting with XLSX files. The package provides a lot
    of useful functionalities and supports the creation and management of workbooks
    as well as worksheets in individual workbooks. You can install it by running the
    following command in Terminal or Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can import the `xlsxwriter` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So, let's look at how we can start creating XLSX files with the support of the
    `XlsxWriter` package.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Workbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start working on XLSX files, we first need to create them. An XLSX file
    is also known as a workbook and can be created by calling the `Workbook` class
    from the `xlsxwriter` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The call to the `Workbook` class opens a binary file, specified with the `filename`
    argument, and returns an instance of `workbook` that can be used to further create
    worksheets and write data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Worksheet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can start writing data to an XLSX file, we first need to create a
    worksheet. This can be done easily by calling the `add_worksheet()` method of
    the `workbook` object we obtained in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `add_worksheet()` method creates a new worksheet, adds it to the workbook,
    and returns an object mapping the worksheet to a Python object, through which
    we can write data to the worksheet.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Data to the Worksheet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once a reference to the worksheet is available, we can start writing data to
    it by calling the `write` method of the `worksheet` object as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `write()` method takes three parameters: a row number (`row_num`),
    a column number (`col_num`), and the data that belongs to the [`row_num, col_num`]
    pair as represented by `col_value`. This call can be repeated to insert multiple
    data items into the worksheet.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Data to the Workbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once all the data is written, to finalize the written datasets and cleanly
    close the XLSX file, you call the `close()` method on the workbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This method writes any data that may be in the file buffer and finally closes
    the workbook. Now, let's use this knowledge to implement our own code, which will
    help us write data to an XLSX file.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not possible to cover all the methods and features the `XlsxWriter` package
    provides in this chapter. For more information, you can read the official documentation:
    [https://xlsxwriter.readthedocs.io/contents.html](https://xlsxwriter.readthedocs.io/contents.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.03: Creating XLSX Files in Python'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the `XlsxWriter` package to create a new Excel
    (XLSX) file and add data to it from Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you will need the `XlsxWriter` package installed on your
    system. You can install it by running the following command in your Terminal app
    or Command Prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the command finishes, you will have the package installed on your system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the package installed, you can start writing the code that will create
    the Excel file. Create a new file named `xlsx_demo.py` and add the following code
    inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, you have created a new function that will assist
    you in creating a new workbook in which you can store your data. Once you have
    created a new workbook, the next step is to create a worksheet that provides you
    with the tabular format needed for you to organize the data to be stored inside
    the XLSX workbook.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the workbook created, create a new worksheet by adding the following code
    snippet to your `xlsx_demo.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, you have created a new worksheet using the `add_worksheet()`
    method of the `workbook` object provided by the `XlsxWriter` package. This worksheet
    will then be used to write the data for the objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to create a helper function that can assist in writing the
    data to the worksheet in a tabular format defined by the row and column numbering.
    For this, add the following snippet of code to your `xlsx_writer.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code snippet, you have created a new function named `write_data()`
    that takes two parameters: the `worksheet` object to which the data needs to be
    written and the `data` object represented by a list of lists that needs to be
    written to the worksheet. The function iterates over the data passed to it and
    then writes the data to the row and column it belongs to.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With all the core methods now implemented, you can now add the method that
    can help close the `workbook` object cleanly, such that the data is written to
    the file without any file corruption happening. For this, implement the following
    code snippet in the `xlsx_demo.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step in the exercise is to integrate all the methods you have implemented
    in the previous steps. For this, create a new entry point method as shown in the
    following code snippet in your `xlsx_demo.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, you first created a dataset that you want to
    write to the XLSX file in the form of a list of lists. Once that was done, you
    obtained a new `workbook` object, which will be used to create an XLSX file. Inside
    this `workbook` object, you then created a worksheet to organize your data in
    a row-and-column format and then wrote the data to the worksheet and closed the
    workbook to persist the data to the disk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s see whether the code you wrote works the way it is expected to
    work. For this, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the command is finished executing, you will see a new file with the name
    `sample_workbook.xlsx` being created in the directory where the command was executed.
    To verify whether it contains the correct results, open this file with either
    Microsoft Excel or Google Sheets and view the contents. It should resemble what
    you see here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.6: Excel sheet generated using xlsxwriter'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_13_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.6: Excel sheet generated using xlsxwriter'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of the `xlsxwriter` module, you can also apply formulas to your
    columns. For example, if you wanted to add another row that shows the average
    age of the people in the spreadsheet, you can do that simply by modifying the
    `write_data()` method as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you added an additional `write` call to the worksheet
    and used the `AVERAGE` function provided by Excel to calculate the average age
    of the people in the worksheet.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you now know how we can generate Microsoft Excel-compatible XLSX
    files using Python and how to export tabular content that's easily consumable
    by the different teams in your organization.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's cover another interesting file format that is widely used across
    the world.
  prefs: []
  type: TYPE_NORMAL
- en: Working with PDF Files in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Portable Document Format** or **PDF** is one of the most common file formats
    in the world. You must have encountered PDF documents at some point. These documents
    can include business reports, digital books, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, do you remember ever having encountered websites that have a button that
    reads `Print` `page` `as` `PDF`? A lot of websites for government agencies readily
    provide this option, which allows you to print the web page directly as a PDF.
    So, the question arises, how can we do this for our web app? How should we add
    the option to export certain content as a PDF?
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, a huge community of developers has contributed a lot of useful
    packages to the Python ecosystem. One of those packages can help us achieve PDF
    file generation.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Web Pages to PDFs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we may run into situations where we want to convert a web page into
    a PDF. For example, we may want to print a web page to store it as a local copy.
    This also comes in handy when trying to print a certificate that is natively displayed
    as a web page.
  prefs: []
  type: TYPE_NORMAL
- en: To help us in such efforts, we can leverage a simple library known as `weasyprint`,
    which is maintained by a community of Python developers and allows the quick and
    easy conversion of web pages to PDFs. So, let's take a look at how we can generate
    a PDF version of a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.04: Generating a PDF Version of a Web Page in Python'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will generate a PDF version of a website using Python.
    You will use a community-contributed Python module known as `weasyprint` that
    will help you generate the PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the code in the upcoming steps work correctly, install the `weasyprint`
    module on your system. To do this, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`weasyprint` depends on the `cairo` library. In case you haven''t installed `cairo`
    libraries, usage of `weasyprint` might raise an error with the message: `libcairo-2.dll`
    `file` `not` `found`. If you''re facing this issue or any other issue installing
    the module, use the `requirements.txt` file we''ve provided on our GitHub repository
    at [http://packt.live/3btLoVV](http://packt.live/3btLoVV). Download the file to
    your disk and open your Terminal, shell or Command Prompt and type the following
    command (you will need to `cd` to the path where you saved this file locally):
    `pip install -r requirements.txt`. If that doesn''t work, follow the steps as
    mentioned in the `weasyprint` documentation: [https://weasyprint.readthedocs.io/en/stable/install.html](https://weasyprint.readthedocs.io/en/stable/install.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the package now installed, create a new file named `pdf_demo.py` that
    will contain the PDF generation logic. Inside this file, write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s try to understand what this code does. In the first line, you imported
    the `HTML` class from the `weasyprint` package, which you installed in *step 1*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This HTML class provides us with a mechanism through which we can read the HTML
    content of a website if we have its URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the next step, you created a new method named `generate_pdf()` that takes
    in two parameters, namely, the URL that should be used as the source URL for the
    generation of the PDF and the `pdf_file` parameter, which takes in the name of
    the file to which the document should be written:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you passed the URL to the `HTML` class object you imported earlier. This
    caused the URL to be parsed by the `weasyprint` library and caused its HTML content
    to be read. Once this was done, you called the `write_pdf()` method of the `HTML`
    class object and provided to it the name of the file to which the content should
    be written:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, write the entry point code that sets up the URL (for this exercise,
    we will use the text version of the `generate_pdf()` method to generate the content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to see the code in action, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the command finishes executing, you will have a new PDF file named `demo_page.pdf`
    that is saved in the same directory where the command was executed. When you open
    the file, it should resemble what you see here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.7: Web page converted to a PDF using weasyprint'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_13_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.7: Web page converted to a PDF using weasyprint'
  prefs: []
  type: TYPE_NORMAL
- en: In the PDF file generated, we can see that the content seems to lack the formatting
    that the actual website has. This happens because the `weasyprint` package reads
    the HTML content but does not parse the attached CSS stylesheets for the page,
    so the page formatting is lost.
  prefs: []
  type: TYPE_NORMAL
- en: '`weasyprint` also makes it quite easy to change the formatting of a page. This
    can be done simply by introducing the stylesheet parameter to the `write_pdf()`
    method. A simple modification to our `generate_pdf()` method is described next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the preceding code is executed, we will see that the font size for
    all the text inside the HTML body content of the page has a size of `8px` in the
    printed PDF version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `HTML` class in `weasyprint` is also capable of taking any local files as
    well as raw HTML string content and can use those files to generate PDFs. For
    further information, please visit the `weasyprint` documentation at [https://weasyprint.readthedocs.io](https://weasyprint.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned about how we can generate different types of binary
    files with Python, which can help us export our data in a structured manner or
    help us print PDF versions of our pages. Next, we will see how we can generate
    graph representations of our data using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Graphs in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs are a great way to visually represent data that changes within a specific
    dimension. We come across graphs quite frequently in our day-to-day lives, be
    it weather charts for a week, stock market movements, or student performance report cards.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, graphs can come in quite handy when we are working with our web applications.
    For Bookr, we can use graphs as a visual medium to show the user information about
    the number of books they read each week. Alternatively, we can show them the popularity
    of a book over time based on how many readers were reading the given book at a
    specific time. Now, let's look at how we can generate plots with Python and have
    them show up on our web pages.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Graphs with plotly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graphs can come in quite handy when trying to visualize patterns in the data
    maintained by our applications. There are a lot of Python libraries that help
    developers in generating static or interactive graphs.
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we will use `plotly`, a community-supported Python library that
    generates graphs and renders them on web pages. `plotly` is particularly interesting
    to us due to its ease of integration with Django.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it on your system, you can type in the following command in the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now that's done, let's take a look at how we can generate a graph visualization
    using `plotly`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Figure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can get started with generating a graph, we first need to initialize
    a `plotly` `Figure` object, which essentially acts as a container for our graph.
    A `plotly` `Figure` object is quite easy to initialize; it can be done by using
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `Figure()` constructor from the `graph_objs` module of `plotly` library
    returns an instance of the `Figure` graph container, inside which a graph can
    be generated. Once the `Figure` object is in place, the next thing that needs
    to be done is to generate a plot.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Plot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A plot is a visual representation of a dataset. This plot could be a scatter
    plot, a line graph, a chart, and so on. For example, to generate a scatter plot,
    the following code snippet is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Scatter` constructor takes in the values for the *X*-axis and *Y*-axis
    and returns an object that can be used to build a scatter plot. Once the `scatter_plot`
    object is generated, the next step is to add this plot to our `Figure`. This can
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `add_trace()` method is responsible for adding a plotting object to the
    figure and generating its visualization inside the figure.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a Plot on a Web Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the plot is added to the figure, it can be rendered on a web page by calling
    the `plot` method from the `offline` plotting module of `plotly` library. This
    is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plot` method takes two primary parameters: the first is the figure that
    needs to be rendered and the second one is the HTML tag of the container inside
    which the figure HTML will be generated. The `plot` method returns fully integrated
    HTML that can be embedded in any web page or made a part of the template to render
    a graph.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, with this understanding of how graph plotting works, let's try a hands-on
    exercise to generate a graph for our sample dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.05: Generating Graphs in Python'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will generate a Graph plot using Python. It will be a
    scatter plot that will represent two-dimensional data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you will be using the `plotly` library. To use this library,
    you first need to install it on the system. To do this, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can install `plotly` and other dependencies for this exercise using the
    `requirements.txt` file we''ve provided on our GitHub repository: [http://packt.live/38y5OLR](http://packt.live/38y5OLR).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the library now installed, create a new file named `scatter_plot_demo.py`
    and add the following `import` statements inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the imports are sorted, create a method named `generate_scatter_plot()`
    that takes in two parameters, the values for the *X*-axis and the values for the
    *Y*-axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this method, first, create an object to act as a container for the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the container for the graph is set up, create a new `Scatter` object with
    the values for the *X*-axis and *Y*-axis and add it to the graph `Figure` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the scatter plot is ready and added to the figure, the last step is to
    generate the HTML, which can be used to render this plot inside a web page. To
    do this, call the `plot` method and pass the graph container object to it, and
    render the HTML inside an HTML `div` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete `generate_scatter_plot()` method should look like this now:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the HTML for the plot is generated, it needs to be rendered somewhere.
    For this, create a new method named `generate_html()`, which will take in the
    plot HTML as its parameter and render an HTML file consisting of the plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the method is set up, the last step is to call it. For this, create a
    script entry point that will set up the values for the *X*-axis list and the *Y*-axis
    list and then call the `generate_scatter_plot()` method. With the value returned
    by the method, make a call to the `generate_html()` method, which will create
    an HTML page consisting of the scatter plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the code in place, run the file and see what output is generated. To run
    the code, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the execution completes, there will be a new `plot_demo.html` file created
    in the same directory in which the script was executed. Upon opening the file,
    you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.8: Graph generated in the browser using plotly'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_13_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.8: Graph generated in the browser using plotly'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have generated our first scatter plot, where different points
    are connected by a line.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you used the `plotly` library to generate a graph that can
    be rendered inside a browser for your readers to visualize data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know how you can work with graphs in Python and how to generate HTML
    pages from them.
  prefs: []
  type: TYPE_NORMAL
- en: But as a web developer, how you can use these graphs in Django? Let's find out.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating plotly with Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The graphs generated by `plotly` are quite easy to embed in Django templates.
    Since the `plot` method returns a fully contained HTML that can be used to render
    a graph, we can use the HTML returned as a template variable in Django and pass
    it as it is. The Django templating engine will then take care of adding this generated
    HTML to the final template before it is shown in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some sample code for doing this is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will cause the `{{ plt_div }}` content used inside the template
    to be replaced by the HTML stored inside the `scatter_plot_demo` variable, and
    the final template to render the scatter plot of the number of books read per
    week.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Visualizations with Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections, you have learned how data can be read and written
    in different formats that cater to the different needs of users. But how can we
    use what we've learned to integrate with Django?
  prefs: []
  type: TYPE_NORMAL
- en: For example, in Bookr, we might want to allow the user to export a list of books
    that they have read or visualize their book reading activity over a year. How
    can that be done? The next exercise in this chapter focuses on that aspect, where
    you will learn how the components we have seen so far can be integrated into Django
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.06: Visualizing a User''s Reading History on the User Profile Page'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will aim to modify the user's profile page such that the
    user can visualize their book reading history when they visit their profile page
    on Bookr.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with integrating the ability to visualize the reading history
    of the user, you first need to install the `plotly` library. To do this, run the
    following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can install `plotly` and other dependencies for this exercise using the
    `requirements.txt` file we''ve provided on our GitHub repository: [http://packt.live/3scIvPp](http://packt.live/3scIvPp).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the library is installed, the next step is to write the code that will
    fetch the total books read by the user as well as the books read by the user on
    a per-month basis. For this, create a new file named `utils.py` under the `bookr`
    application directory and add the required imports, which will be used to fetch
    the book reading history of the user from the `Review` model of the `reviews` application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create a new utility method named `get_books_read_by_month()`, which takes
    in the username of the user for whom the reading history needs to be fetched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the method, we query the `Review` model and return a dictionary of books
    read by the user on a per-month basis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s examine the following query, which is responsible for fetching
    the results of books read this year on a monthly basis:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This query can be broken down into the following components:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`year` field can be easily accessed from our `date_created` field by appending
    `__year`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`values()` call to select only the `month` field from the `date_created` attribute
    of the `Review` model on which you are going to run the group by operation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`annotate` method to the `QuerySet` instance returned by the `values()` call.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have the utilities file in place, the next thing is to write the view
    function, which is going to help in showing the books-read-per-month plot on the
    user''s profile page. For this, open the `views.py` file under the `bookr` directory
    and start by adding the following imports to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once these imports are done, the next thing to do is to modify the view function
    that renders the profile page. Currently, the profile page is being handled by
    the `profile()` method inside the `views.py` file. Modify the method to resemble
    the one shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this method, you did a couple of things. The first thing was that you called
    the `get_books_read_by_month()` method and provided it with the username of the
    currently logged-in user. This method returns the list of books read by a given
    user on a per-month basis in the current year:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next thing you did was pre-initialize the *X*-axis and *Y*-axis for the
    graph with some default values. For this visualization, use the *X*-axis to display
    months and the *Y*-axis to display the number of books read.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, since you already know that a year is going to have only 12 months, pre-initialize
    the *X*-axis with a value between `1` and `12`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the books read, initialize the *Y*-axis with all the `12` indexes set to
    `0` as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, with the pre-initialization done, fill in some actual values for the books
    read per month. For this, iterate upon the list you got as a result of the call
    made to `get_books_read_by_month(user.username)` and extract the month and the
    book count for the month from it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the book count and month are extracted, the next step is to assign the
    `book_count` value to the `books_read` list at the month index:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, with the values for the axes set, generate a scatter plot using the `plotly` library:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the HTML for the plot is generated, pass it to the template using the
    `render()` method such that it can be visualized on the profile page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the view function done, the next step is to modify the template to render
    this graph. For this, open the `profile.html` file under the `templates` directory
    and add the following highlighted code to the file, just before the last `{% endblock
    %}` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To try the visualization, run the following command and then navigate to your
    user profile by visiting `http://localhost:8080`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see a page that resembles the one shown next:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.9: User book reading history scatter plot'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_13_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.9: User book reading history scatter plot'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding exercise, you saw how you can integrate a plotting library
    with Django to visualize the reading history of a user. Similarly, Django allows
    you to integrate any generic Python code into a web application, with the only
    constraint being that the data generated as a result of the integration should
    be transformed into a valid HTTP response that can be handled by any standard
    HTTP-compatible tool, such as a web browser or command-line tools such as CURL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.01: Exporting the Books Read by a User as an XLSLX File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you will implement a new API endpoint inside Bookr that will
    allow your users to export and download a list of books they have read as an XLSX
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `XlsxWriter` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `utils.py` file created under the `bookr` application, create a new
    function that will help in fetching the list of books that have been read by the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `views.py` file under the `bookr` directory, create a new view function
    that will allow the user to download their reading history in the XLSX file format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create an XLSX file inside the view function, first create a `BytesIO`-based
    in-memory file that can be used to store the data from the `XlsxWriter` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the data stored inside the in-memory file using the `getvalue()` method
    of the temporary file object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a new `HttpResponse` instance with the `'application/vnd.ms-excel'`
    content type header, and then write the data obtained in step 5 to the response
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the response object prepared, return the response object from the view function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the view function ready, map it to a URL endpoint that can be visited by
    a user to download their book reading history.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have the URL endpoint mapped, start the application and log in to it
    with your user account. Once done, visit the URL endpoint you just created, and
    if upon visiting the URL endpoint your browser starts to download an Excel file,
    you have successfully completed the activity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how we can deal with binary files and how Python's
    standard library, which comes pre-loaded with the necessary tools, can allow us
    to handle commonly used file formats such as CSV. We then moved on to learning
    how to read and write CSV files in Python using Python's CSV module. Later, we
    worked with the `XlsxWriter` package, which provides us with the ability to generate
    Microsoft Excel-compatible files right from our Python environment without worrying
    about the internal formatting of the file.
  prefs: []
  type: TYPE_NORMAL
- en: The second half of the chapter was dedicated to learning how to use the `weasyprint`
    library to generate PDF versions of HTML pages. This skill can come in handy when
    we want to provide our users with an easy option to print the HTML version of
    our page with any added CSS styling of our choosing. The last section of the chapter
    discussed how we can generate interactive graphs in Python and render them as
    HTML pages that can be viewed inside the browser using the `plotly` library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can test the different components
    we have been implementing in the previous chapters to make sure that code changes
    do not break our website's functionality.
  prefs: []
  type: TYPE_NORMAL
