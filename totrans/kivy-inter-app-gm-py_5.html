<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 5. Invaders Revenge – an Interactive Multi-touch Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Invaders Revenge – an Interactive Multi-touch Game</h1></div></div></div><p>This chapter introduces a collection of components and strategies to make animated and dynamic applications. Most of them are particularly useful for game development. This chapter is full of examples of how to combine different Kivy elements and teaches strategies to control multiple events happening at the same time. The examples are all integrated in a completely new<a id="id475" class="indexterm"/> project, a version of the classic <span class="emphasis"><em>Space Invaders</em></span> game (Copyright ©1978 Taito Corporation, <a class="ulink" href="http://en.wikipedia.org/wiki/Space_Invaders">http://en.wikipedia.org/wiki/Space_Invaders</a>). The following is a list of the main components that we will work on in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Atlas</strong></span>: A <a id="id476" class="indexterm"/>Kivy package that allows us to load images efficiently</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sound</strong></span>: Classes<a id="id477" class="indexterm"/> that allow sound management</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Animations</strong></span>: Transitions, time control, events, and operations that can be applied to animate widgets</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Clock</strong></span>: A <a id="id478" class="indexterm"/>class that allows us to schedule events</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Multi-touch</strong></span>: A<a id="id479" class="indexterm"/> strategy that allows us to control different actions according to touches</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Keyboard</strong></span>: The<a id="id480" class="indexterm"/> Kivy strategy of capturing keyboard events</li></ul></div><p>The first section presents an overview of the project, the GUI, and the rules of the game. After that, we will follow a bottom-up approach. The simple classes that refer to individual components of the game will be explained, and additional topics of the chapter will then be introduced one after another. We will finish with the classes that have the main control over the game. By the end of this chapter, you should be able to start any game application you have always wanted to implement for your mobile device.</p><div class="section" title="Invaders Revenge – an animated multi-touch game"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Invaders Revenge – an animated multi-touch game</h1></div></div></div><p>
<span class="emphasis"><em>Invaders Revenge</em></span> is<a id="id481" class="indexterm"/> the name of our Kivy version of Space Invaders©. The following screenshot shows you the game we will build in this chapter:</p><div class="mediaobject"><img src="images/B04244_05_01.jpg" alt="Invaders Revenge – an animated multi-touch game"/></div><p>There are several tags in yellow and cyan in the screenshot (or gray dashed lines in the printed version). They help identify the structure of our game; the game will consist of one <span class="emphasis"><em>shooter</em></span> (the player), who shoots (<span class="emphasis"><em>shots</em></span>) at 32 (8x4) <span class="emphasis"><em>invaders</em></span> who are trying to destroy the <span class="emphasis"><em>shooter</em></span> with their <span class="emphasis"><em>missiles</em></span>. The <span class="emphasis"><em>invaders</em></span> are organized in a <span class="emphasis"><em>fleet</em></span> (which moves horizontally) and sometimes an individual <span class="emphasis"><em>invader</em></span> can break out of the grid formation and fly around the screen before going back to its corresponding position (<span class="emphasis"><em>dock</em></span>) in the <span class="emphasis"><em>fleet</em></span>.</p><p>The cyan (gray in the printed version) line across the screen indicates an internal division of the screen into the <span class="emphasis"><em>enemy area</em></span> and <span class="emphasis"><em>shooter area</em></span>. This division is used to distinguish between actions that should occur according to touches that happen in different sections of the screen.</p><p>The skeleton of the game is presented in the <code class="literal">invasion.kv</code> file:</p><div class="informalexample"><pre class="programlisting">1. # File name: invasion.kv
2. &lt;Invasion&gt;:
3.   id: _invasion
4.   shooter: _shooter
5.   fleet: _fleet
6.   AnchorLayout:
7.     anchor_y: 'top'
8.     anchor_x: 'center'
9.     FloatLayout:
10.       id: _enemy_area
11.       size_hint: 1, .7
12.       Fleet:
13.         id: _fleet
14.         invasion: _invasion
15.         shooter: _shooter
16.         cols: 8
17.         spacing: 40
18.         size_hint: .5, .4
19.         pos_hint: {'top': .9}
20.         x: root.width/2-root.width/4
21.   AnchorLayout:
22.     anchor_y: 'bottom'
23.     anchor_x: 'center'
24.     FloatLayout:
25.       size_hint: 1, .3
26.       Shooter:
27.         id: _shooter
28.         invasion: _invasion
29.         enemy_area: _enemy_area</pre></div><p>There<a id="id482" class="indexterm"/> are two <code class="literal">AnchorLayout</code> instances. The top one is the <span class="emphasis"><em>enemy area</em></span> that contains the <span class="emphasis"><em>fleet</em></span> and the bottom one is the <span class="emphasis"><em>shooter area</em></span> that contains the <span class="emphasis"><em>shooter</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>The <span class="emphasis"><em>enemy area</em></span> and <span class="emphasis"><em>shooter area</em></span> are very important for the logic of the game in order to distinguish between the types of touches on the screen.</p></div></div><p>We also created some IDs and references that will allow the interaction between different instances of the interface. The following diagram summarizes these relations:</p><div class="mediaobject"><img src="images/B04244_05_02.jpg" alt="Invaders Revenge – an animated multi-touch game"/></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Atlas – An efficient management of images"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Atlas – An efficient management of images</h1></div></div></div><p>When it <a id="id483" class="indexterm"/>comes to applications that use many images, it is <a id="id484" class="indexterm"/>important to reduce their loading time, especially when they are requested from a remote server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>One strategy to <a id="id485" class="indexterm"/>reduce the loading time is to use an <span class="strong"><strong>Atlas</strong></span> (also known as sprite). An Atlas groups all the application images into one big image, so it reduces the number of necessary requests to the operating system, or online requests.</p></div></div><p>Here is the image of the Atlas we use for invaders revenge:</p><div class="mediaobject"><img src="images/B04244_05_03.jpg" alt="Atlas – An efficient management of images"/></div><p>Instead of requesting five images for the <span class="emphasis"><em>invaders revenge</em></span>, we will just request the Atlas image. We will also need an associated <code class="literal">json</code> file that tells us the exact coordinates of each unit in the image. The good news is that we don't need to do this manually. Kivy provides a simple command to create both the Atlas image and the <code class="literal">json</code> file. Assuming that all the images are in a directory called <code class="literal">img</code>, we just need to open a terminal, go to the <code class="literal">img</code> directory (that contains the individual images), and run the following command in the terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python -m kivy.atlas invasion 100 *.png</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>In order to <a id="id486" class="indexterm"/>execute the previous command, will you need to install the <span class="strong"><strong>Pillow library</strong></span> (<a class="ulink" href="http://python-pillow.github.io/">http://python-pillow.github.io/</a>).</p></div></div><p>The <a id="id487" class="indexterm"/>command contains three parameters, namely <span class="strong"><strong><code class="literal">basename</code></strong></span>, <span class="strong"><strong><code class="literal">size</code></strong></span>, and <span class="strong"><strong><code class="literal">images list</code></strong></span>. The <code class="literal">basename</code> parameter is the prefix of the <code class="literal">json</code> file (<code class="literal">img/invasion.json</code>) and the Atlas image or images (<code class="literal">img/invasion-0.png</code>). It <a id="id488" class="indexterm"/>could happen that several Atlas images are generated, in which case we would have several <a id="id489" class="indexterm"/>images with <code class="literal">basename</code> as a prefix followed by a numerical identifier, for example, <code class="literal">invasion-0.png</code> and <code class="literal">invasion-1.png</code>. The<a id="id490" class="indexterm"/> <code class="literal">size</code> parameter indicates the size in pixels of the resulting Atlas image. Be sure to specify a size that is larger than the biggest <a id="id491" class="indexterm"/>of the images. The <span class="strong"><strong><code class="literal">image list</code></strong></span> parameter is the list of all the images that will be added to the Atlas, and we can use the <code class="literal">*</code> wildcard. In our case, we will use it to indicate all files with the <code class="literal">.png</code> extension.</p><p>In order to use the Atlas in the Kivy language, we have to use the following format: <code class="literal">atlas://path/to/atlas/atlas_name/id</code>. The <code class="literal">id</code> file refers to the image filename without the extension. For example, normally we would have referenced the <span class="emphasis"><em>shooter</em></span> image as a source: <code class="literal">'img/shooter.png'</code>. After generating the Atlas, it becomes <code class="literal">source: 'atlas://images/invasion/shooter'</code>. The following <code class="literal">image.kv</code> file presents the code for all the images of <span class="emphasis"><em>Invaders Revenge</em></span>:</p><div class="informalexample"><pre class="programlisting">30. # File name: images.kv
31. &lt;Invader&gt;:
32.   source: 'atlas://img/invasion/invader'
33.   size_hint: None,None
34.   size: 40,40
35. &lt;Shooter&gt;:
36.   source: 'atlas://img/invasion/shooter'
37.   size_hint: None,None
38.   size: 40,40
39.   pos: self.parent.width/2, 0
40. &lt;Boom&gt;:
41.   source: 'atlas://img/invasion/boom'
42.   size_hint: None,None
43.   size: 26,30
44. &lt;Shot&gt;:
45.   source: 'atlas://img/invasion/shot'
46.   size_hint: None,None
47.   size: 12,15
48. &lt;Missile&gt;:
49.   source: 'atlas://img/invasion/missile'
50.   size_hint: None,None
51.   size: 12,27</pre></div><p>All the<a id="id492" class="indexterm"/> classes in this file inherit, directly or indirectly, from<a id="id493" class="indexterm"/> the <code class="literal">Image</code> class. The <code class="literal">Missile</code> and <code class="literal">Shot</code> inherit first from the class called <code class="literal">Ammo</code>, which also inherits from <code class="literal">Image</code>. There is also the <code class="literal">Boom</code> class that will create the effect of an explosion when any <code class="literal">Ammo</code> is triggered. Apart from the <code class="literal">Boom</code> image (a star in the Atlas), the <code class="literal">Boom</code> class will be associated with a sound that we will add in the next section.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Boom – simple sound effects"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Boom – simple sound effects</h1></div></div></div><p>Adding <a id="id494" class="indexterm"/>sound effects in Kivy is very <a id="id495" class="indexterm"/>simple. A <code class="literal">Boom</code> instance will produce a sound when it is created, and this will happen every time a <span class="emphasis"><em>shot</em></span> or <span class="emphasis"><em>missile</em></span> is fired. Here is the code for <code class="literal">boom.py</code>:</p><div class="informalexample"><pre class="programlisting">52. # File name: boom.py
53. from kivy.uix.image import Image
54. from kivy.core.audio import SoundLoader
55. 
56. class Boom(Image):
57.   sound = SoundLoader.load('boom.wav')
58.   def boom(self, **kwargs):
59.     self.__class__.sound.play()
60.     super(Boom, self).__init__(**kwargs)</pre></div><p>Reproducing<a id="id496" class="indexterm"/> a sound involves the use of two classes, <span class="strong"><strong><code class="literal">Sound</code></strong></span> and <span class="strong"><strong><code class="literal">SoundLoader</code></strong></span> (line 54). <code class="literal">SoundLoader</code> loads an audio file (<code class="literal">.wav</code>) and returns a <code class="literal">Sound</code> instance (line 57) that<a id="id497" class="indexterm"/> we keep in the <code class="literal">sound</code> reference (a static attribute of the <code class="literal">Boom</code> class). We play a sound every time a new <code class="literal">Boom</code> instance is created.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Ammo – simple animation"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Ammo – simple animation</h1></div></div></div><p>This section<a id="id498" class="indexterm"/> explains how to animate <span class="emphasis"><em>shots</em></span> and <span class="emphasis"><em>missiles</em></span>, which show very similar behavior. They move from their original <a id="id499" class="indexterm"/>position to a destination, constantly checking whether a target has been hit. The following is the code for the <code class="literal">ammo.py</code> class:</p><div class="informalexample"><pre class="programlisting">61. # File name: ammo.py
62. from kivy.animation import Animation
63. from kivy.uix.image import Image
64. from boom import Boom
65. 
66. class Ammo(Image):
67.   def shoot(self, tx, ty, target):
68.     self.target = target
69.     self.animation = Animation(x=tx, top=ty)
70.     self.animation.bind(on_start = self.on_start)
71.     self.animation.bind(on_progress = self.on_progress)
72.     self.animation.bind(on_complete = self.on_stop)
73.     self.animation.start(self)
74. 
75.   def on_start(self, instance, value):
76.     self.boom = Boom()
77.     self.boom.center=self.center
78.     self.parent.add_widget(self.boom)
79. 
80.   def on_progress(self, instance, value, progression):
81.     if progression &gt;= .1:
82.       self.parent.remove_widget(self.boom)
83.     if self.target.collide_ammo(self):
84.       self.animation.stop(self)
85. 
86.   def on_stop(self, instance,value):
87.     self.parent.remove_widget(self)
88. 
89. class Shot(Ammo):
90.   pass
91. class Missile(Ammo):
92.   pass</pre></div><p>For the <code class="literal">Ammo</code> animation, we<a id="id500" class="indexterm"/> require a simple <span class="strong"><strong><code class="literal">Animation</code></strong></span> (line 69). We send <code class="literal">x</code> and <code class="literal">top</code> as parameters.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note4200"/>Note</h3><p>The parameters of an <code class="literal">Animation</code> instance can be any properties of the widget to which we are applying the animation.</p></div></div><p>In this case, the <code class="literal">x</code> and <code class="literal">top</code> properties belong to <code class="literal">Ammo</code> itself. This is enough to set <code class="literal">Animation</code> of <code class="literal">Ammo</code> from its original position to <code class="literal">tx</code>, <code class="literal">ty</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>By default, the<a id="id501" class="indexterm"/> execution period of <span class="strong"><strong><code class="literal">Animation</code></strong></span> is one second.</p></div></div><p>We need <code class="literal">Ammo</code> to do a few more things in its trajectory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>The <code class="literal">Animation</code> class<a id="id502" class="indexterm"/> includes three events, which<a id="id503" class="indexterm"/> are triggered when the animations<a id="id504" class="indexterm"/> starts (<span class="strong"><strong><code class="literal">on_start</code></strong></span>), during its progress (<span class="strong"><strong><code class="literal">on_progress</code></strong></span>), and when it stops (<span class="strong"><strong><code class="literal">on_stop</code></strong></span>).</p></div></div><p>We bind<a id="id505" class="indexterm"/> these events (lines 70 to 72) to our<a id="id506" class="indexterm"/> own methods. The <span class="strong"><strong><code class="literal">on_start</code></strong></span> method (line 75) displays a <code class="literal">Boom</code> instance (line 76) when<a id="id507" class="indexterm"/> the animation starts. The <span class="strong"><strong><code class="literal">on_progress</code></strong></span> (lines 80 to 84) method <a id="id508" class="indexterm"/>removes <code class="literal">Boom</code> after 10 percent of <span class="strong"><strong><code class="literal">progression</code></strong></span> (lines 81 and 82). Also, it is constantly checking <code class="literal">target</code> (line 83). When <a id="id509" class="indexterm"/>
<code class="literal">target</code> is hit, the animation is stopped (line 84). Once the animation ends (or is stopped), <code class="literal">Ammo</code> is removed from the parent (line 82).</p><p>Lines 89 to 92 define two classes, <code class="literal">Shot</code> and <code class="literal">Missile</code>. The <code class="literal">Shot</code> and <code class="literal">Missile</code> classes inherit from <code class="literal">Ammo</code> and their only difference right now is the image that is used in <code class="literal">images.kv</code>. Eventually, we will use <code class="literal">Shot</code> instances for the <span class="emphasis"><em>shooter</em></span>, and <code class="literal">Missile</code> instances for the <span class="emphasis"><em>invaders</em></span>. Before this, let's give the <span class="emphasis"><em>invaders</em></span> some freedom, so they can leave their <span class="emphasis"><em>fleet</em></span> and perform an individual attack.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Invader – transitions for animations"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Invader – transitions for animations</h1></div></div></div><p>The previous<a id="id510" class="indexterm"/> section uses the default <code class="literal">Animation</code> transition. This is a <code class="literal">Linear</code> transition, which means that the <code class="literal">Widget</code> instance<a id="id511" class="indexterm"/> moves from one point to another in a straight line. <span class="emphasis"><em>Invaders</em></span> trajectories can be more interesting. For example, there could be accelerations, or changes of direction, as shown by the line in the following screenshot:</p><div class="mediaobject"><img src="images/B04244_05_04.jpg" alt="Invader – transitions for animations"/></div><p>The <a id="id512" class="indexterm"/>following<a id="id513" class="indexterm"/> is the code of <code class="literal">invader.py</code>:</p><div class="informalexample"><pre class="programlisting">93. # File name: invader.py
94. from kivy.core.window import Window
95. from kivy.uix.image import Image
96. from kivy.animation import Animation
97. from random import choice, randint
98. from ammo import Missile
99. 
100. class Invader(Image):
101.   pre_fix = ['in_','out_','in_out_']
102.   functions = ['back','bounce','circ','cubic',
103.     'elastic','expo','quad','quart','quint','sine']
104.   formation = True
105. 
106.   def solo_attack(self):
107.     if self.formation:
108.       self.parent.unbind_invader()
109.       animation = self.trajectory()
110.       animation.bind(on_complete = self.to_dock)
111.       animation.start(self)
112. 
113.   def trajectory(self):
114.     fleet = self.parent.parent
115.     area = fleet.parent
116.     x = choice((-self.width,area.width+self.width))
117.     y = randint(round(area.y), round(fleet.y))
118.     t = choice(self.pre_fix) + choice(self.functions)
119.     return Animation(x=x, y=y,d=randint(2,7),t=t)
120. 
121.   def to_dock(self, instance, value):
122.     self.y = Window.height
123.     self.center_x = Window.width/2
124.     animation = Animation(pos=self.parent.pos, d=2)
125.     animation.bind(on_complete = self.parent.bind_invader)
126.     animation.start(self)
127. 
128.   def drop_missile(self):
129.     missile = Missile()
130.     missile.center = (self.center_x, self.y)
131.     fleet = self.parent.parent
132.     fleet.invasion.add_widget(missile)
133.     missile.shoot(self.center_x,0,fleet.shooter)</pre></div><p>The idea<a id="id514" class="indexterm"/> behind this code is to let<a id="id515" class="indexterm"/> an <span class="emphasis"><em>invader</em></span> break the formation from the <span class="emphasis"><em>fleet</em></span> and proceed into a <code class="literal">solo_attack</code> (lines 106 to 111) method. The <span class="emphasis"><em>invader's</em></span> <code class="literal">Animation</code> is created in the <code class="literal">trajectory</code> method (lines 113 and 119) by randomizing the final point of the <span class="emphasis"><em>invader's</em></span> trajectory (lines 116 and 117). This randomization will pick up two coordinates <a id="id516" class="indexterm"/>on the left or right borders of the <span class="emphasis"><em>enemy area</em></span>. Also, we randomize the type of <span class="strong"><strong><code class="literal">transition</code></strong></span> (line 118), and <span class="strong"><strong><code class="literal">duration</code></strong></span> (line 119) to create more diverse<a id="id517" class="indexterm"/> and unpredictable trajectories.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>Kivy<a id="id518" class="indexterm"/> currently includes 31 <span class="strong"><strong>transitions</strong></span>. They are represented by a string such as <code class="literal">'in_out_cubic'</code>, where <code class="literal">in_out</code> is a prefix that describes the way in which the function (<code class="literal">cubic</code>) is used. There are three possible prefixes (<code class="literal">in</code>, <code class="literal">out</code>, and <code class="literal">in_out</code>), and 10 functions (line 102), such as <code class="literal">cubic</code>, <code class="literal">exponential</code>, <code class="literal">sin</code>, <code class="literal">quadratic</code>. Please visit the Kivy API for a description <a id="id519" class="indexterm"/>of all of them (<a class="ulink" href="http://kivy.org/docs/api-kivy.animation.html">http://kivy.org/docs/api-kivy.animation.html</a>).</p></div></div><p>Line 118 selects one of the transitions randomly. The transition is applied to the progress, and therefore to <code class="literal">x</code> and <code class="literal">y</code> at the same time, which produces an interesting acceleration effect on the trajectories.</p><p>When<a id="id520" class="indexterm"/> the <code class="literal">Animation</code> class ends its<a id="id521" class="indexterm"/> trajectory (line 110), the <code class="literal">to_dock</code> method (lines 121 to 126) brings the <span class="emphasis"><em>invader</em></span> back to its original position starting from the top-center <a id="id522" class="indexterm"/>part of <code class="literal">Window</code>. We use the <span class="strong"><strong><code class="literal">Window</code></strong></span> class to get <code class="literal">height</code> and <code class="literal">width</code>. Sometimes this is easier than traversing the chain of parents, to find the root widget. When the <span class="emphasis"><em>invader</em></span> reaches the <span class="emphasis"><em>dock</em></span>, it is bound back to it (line 125).</p><p>The last method (<code class="literal">drop_missile</code> in lines 128 to 133) shoots one <span class="emphasis"><em>missile</em></span> that follows a vertical line starting from the <span class="emphasis"><em>invader's</em></span> bottom-center position (line 130) to the bottom of the screen (line 133). Remember that the <code class="literal">Missile</code> class inherits from the <code class="literal">Ammo</code> class we created in the previous section.</p><p>Our invaders can now move freely around the enemy area. However, we would also like to have some sort of group movement. In the next section, we will create a <span class="emphasis"><em>dock</em></span> for each corresponding invader. In this way, the <span class="emphasis"><em>invader</em></span> has a corresponding placeholder in the <span class="emphasis"><em>fleet</em></span> formation. After this, we will create the <span class="emphasis"><em>fleet</em></span>, which constantly moves all the <span class="emphasis"><em>docks</em></span>.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Dock – automatic binding in the Kivy language"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Dock – automatic binding in the Kivy language</h1></div></div></div><p>You <a id="id523" class="indexterm"/>might realize from<a id="id524" class="indexterm"/> previous chapters that the Kivy language does more than simply transform its rules to Python instructions. For instance, you might see that when it creates properties, it also binds them.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>When we do something common such as <code class="literal">pos: self.parent.pos</code> inside a layout, then the property of the parent is bound to its child. The child always moves to the parent position when the parent moves.</p></div></div><p>This is usually desirable but not all the time. Think about <code class="literal">solo_attack</code> of the <span class="emphasis"><em>invader</em></span>. We need it to break formation and follow a free trajectory on the screen. While this happens, the whole formation of <span class="emphasis"><em>invaders</em></span> continues moving from right to left and vice versa. This means that the <span class="emphasis"><em>invader</em></span> will receive two orders at the same time; one from the moving parent and another from the trajectory's <code class="literal">Animation</code>.</p><p>This means that we need a placeholder (the <span class="emphasis"><em>dock</em></span>) for each <span class="emphasis"><em>invader</em></span>. This will secure the space for the <span class="emphasis"><em>invader</em></span> when it comes back from executing a solo attack. If we don't have a placeholder, the layout (<code class="literal">GridLayout</code>, as we will see in the next section) of the <span class="emphasis"><em>fleet</em></span> will automatically reconfigure the formation, reallocating the rest of the <span class="emphasis"><em>invaders</em></span> to fill the empty space. Also, the <span class="emphasis"><em>invader</em></span> needs to free itself from the parent (the <span class="emphasis"><em>dock</em></span>) so it can float to <a id="id525" class="indexterm"/>any location<a id="id526" class="indexterm"/> on the screen. The following code (<code class="literal">dock.py</code>) binds (lines 145 to 147) and unbinds (lines 149 to 151) the <span class="emphasis"><em>invader</em></span> using Python, and not the Kivy language:</p><div class="informalexample"><pre class="programlisting">134. # File name: dock.py
135. from kivy.uix.widget import Widget
136. from invader import Invader
137. 
138. class Dock(Widget):
139.   def __init__(self, **kwargs):
140.     super(Dock, self).__init__(**kwargs)
141.     self.invader = Invader()
142.     self.add_widget(self.invader)
143.     self.bind_invader()
144. 
145.   def bind_invader(self, instance=None, value=None):
146.     self.invader.formation = True
147.     self.bind(pos = self.on_pos)
148. 
149.   def unbind_invader(self):
150.     self.invader.formation = False
151.     self.unbind(pos = self.on_pos)
152. 
153.   def on_pos(self, instance, value):
154.     self.invader.pos = self.pos</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>We use the knowledge from <a class="link" href="ch03.html" title="Chapter 3. Widget Events – Binding Actions">Chapter 3</a>, <span class="emphasis"><em>Widget Events – Binding Actions</em></span>, for this code, but the important part is the strategy that we apply.</p></div></div><p>There will be situations in which we will want to avoid using the Kivy language because it is preferable to have complete control.</p><p>This doesn't mean that it is impossible to solve this using the Kivy language. For example, one common approach is to switch the <span class="emphasis"><em>invader's</em></span> parent (<span class="emphasis"><em>dock</em></span>) to, let's say, the root <code class="literal">Widget</code> instance of the application; this unbinds the position of the <span class="emphasis"><em>invader</em></span> from its current parent. It doesn't really matter which approach we follow. As long as we understand the mechanisms, we will be able to find elegant solutions.</p><p>Now that each invader has a <span class="emphasis"><em>dock</em></span> securing its place in the <span class="emphasis"><em>invaders</em></span> formation, we are ready<a id="id527" class="indexterm"/> to introduce some <a id="id528" class="indexterm"/>movement to the <span class="emphasis"><em>fleet</em></span>.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Fleet – infinite concatenation of animations"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Fleet – infinite concatenation of animations</h1></div></div></div><p>In this<a id="id529" class="indexterm"/> section, we will animate the <a id="id530" class="indexterm"/>fleet so that it has perpetual movement from right to left and vice versa, as shown by the arrows in the following screenshot:</p><div class="mediaobject"><img src="images/B04244_05_05.jpg" alt="Fleet – infinite concatenation of animations"/></div><p>In order to do this, we will learn how to concatenate one animation just after another one is completed. Indeed, we will create an infinite loop of animations so that the <span class="emphasis"><em>fleet</em></span> is in perpetual movement.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>We can concatenate two animations with the <code class="literal">on_complete</code> event.</p></div></div><p>The following code, fragment 1 (of 2), of <code class="literal">fleet.py</code> shows how to concatenate these events:</p><div class="informalexample"><pre class="programlisting">155. # File name: fleet.py (Fragment 1)
156. from kivy.uix.gridlayout import GridLayout
157. from kivy.properties import ListProperty
158. from kivy.animation import Animation
159. from kivy.clock import Clock
160. from kivy.core.window import Window
161. from random import randint, random
162. from dock import Dock
163. 
164. class Fleet(GridLayout):
165.   survivors = ListProperty(())
166. 
167.   def __init__(self,  **kwargs):
168.     super(Fleet, self).__init__(**kwargs)
169.     for x in range(0, 32):
170.       dock = Dock()
171.       self.add_widget(dock)
172.       self.survivors.append(dock)
173.     self.center_x= Window.width/4
174. 
175.   def start_attack(self, instance, value):
176.     self.invasion.remove_widget(value)
177.     self.go_left(instance, value)
178.     self.schedule_events()
179. 
180.   def go_left(self, instance, value):
181.     animation = Animation(x = 0)
182.     animation.bind(on_complete = self.go_right)
183.     animation.start(self)
184. 
185.   def go_right(self, instance, value):
186.     animation = Animation(right=self.parent.width)
187.     animation.bind(on_complete = self.go_left)
188.     animation.start(self)</pre></div><p>The <code class="literal">go_left</code> method (lines 180 to 183) binds the <code class="literal">on_complete</code> (line 182) event of an <code class="literal">Animation</code> instance<a id="id531" class="indexterm"/> to the <code class="literal">go_right</code> method (lines 185 to 188). Similarly, the <code class="literal">go_right</code> method binds the <code class="literal">on_complete</code> (line 187) event<a id="id532" class="indexterm"/> of another <code class="literal">Animation</code> instance to the <code class="literal">go_left</code> method. With this strategy, we create an infinite loop of two animations.</p><p>The <code class="literal">fleet.py</code> class also overloads the constructor to add 32 <span class="emphasis"><em>invaders</em></span> (lines 169 to 173) to the children of <code class="literal">Fleet</code>. These <span class="emphasis"><em>invaders</em></span> are <a id="id533" class="indexterm"/>added to the survivors <span class="strong"><strong><code class="literal">ListProperty</code></strong></span> that we use to keep track of the <span class="emphasis"><em>invaders</em></span> that haven't been shot down. The <code class="literal">start_attack</code> method (lines 175 to 178) starts the <code class="literal">Fleet</code> animation calling the <code class="literal">go_left</code> method (line 177) and the <code class="literal">schedule_events</code> method (line 178). The latter makes use of <code class="literal">Clock</code>, which will<a id="id534" class="indexterm"/> be explained in the next section.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Scheduling events with the clock"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Scheduling events with the clock</h1></div></div></div><p>We<a id="id535" class="indexterm"/> saw that <code class="literal">Animation</code> has a<a id="id536" class="indexterm"/> duration parameter that establishes the time in which an animation should take place. A different time-related topic is the scheduling of a particular task<a id="id537" class="indexterm"/> at a certain time or during intervals of n seconds. In these cases, we use the <span class="strong"><strong><code class="literal">Clock</code></strong></span> class. Let's analyze the following code, fragment 2 (of 2), of <code class="literal">fleet.py</code>:</p><div class="informalexample"><pre class="programlisting">189. # File name: fleet.py (Fragment 2)
190.   def schedule_events(self):
191.     Clock.schedule_interval(self.solo_attack, 2)
192.     Clock.schedule_once(self.shoot,random())
193. 
194.   def solo_attack(self, dt):
195.     if len(self.survivors):
196.       rint = randint(0, len(self.survivors) - 1)
197.       child = self.survivors[rint]
198.       child.invader.solo_attack()
199. 
200.   def shoot(self, dt):
201.     if len(self.survivors):
202.       rint = randint(0,len(self.survivors) - 1)
203.       child = self.survivors[rint]
204.       child.invader.drop_missile()
205.       Clock.schedule_once(self.shoot,random())
206. 
207.   def collide_ammo(self, ammo):
208.     for child in self.survivors:
209.       if child.invader.collide_widget(ammo):
210.         child.canvas.clear()
211.         self.survivors.remove(child)
212.         return True
213.     return False
214. 
215.   def on_survivors(self, instance, value):
216.     if len(self.survivors) == 0:
217.       Clock.unschedule(self.solo_attack)
218.       Clock.unschedule(self.shoot)
219.       self.invasion.end_game("You Win!")</pre></div><p>The <code class="literal">schedule_events</code> method (lines 190 to 192) schedules actions for a particular time. Line 191 schedules the <code class="literal">solo_attack</code> method every two seconds. Line 192 schedules <code class="literal">shoot</code> just once at random (between 0 and 1) seconds.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>The <span class="strong"><strong><code class="literal">schedule_interval</code></strong></span> method schedules <a id="id538" class="indexterm"/>actions<a id="id539" class="indexterm"/> periodically, whereas the <span class="strong"><strong><code class="literal">schedule_once</code></strong></span> method schedules an action just once.</p></div></div><p>The <code class="literal">solo_attack</code> method (lines 194 to 198) randomly selects one of the survivors to perform<a id="id540" class="indexterm"/> the solo attack that we <a id="id541" class="indexterm"/>studied for the <span class="emphasis"><em>invaders</em></span> (lines 106 to 111 of <code class="literal">invader.py</code>). The <code class="literal">shoot</code> method (lines 200 to 205) randomly selects one survivor to fire a <span class="emphasis"><em>missile</em></span> at the <span class="emphasis"><em>shooter</em></span> (lines 201 to 204). After this, the method schedules another <code class="literal">shoot</code> (line 205).</p><p>In the <code class="literal">Ammo</code> class, we used the <code class="literal">collide_ammo</code> method to verify that an <code class="literal">Ammo</code> instance hits any of the <span class="emphasis"><em>invaders</em></span> (line 83 of <code class="literal">ammo.py</code>). Now, in <code class="literal">fleet.py</code>, we implemented such a method (lines 207 or 213) that hides and removes the <span class="emphasis"><em>invader</em></span> from the survivors list. The <code class="literal">on_survivors</code> event is triggered every time we modify the survivors <code class="literal">ListProperty</code>. When there are no survivors left, we unschedule the events with the <span class="strong"><strong><code class="literal">unscheduled</code></strong></span> method (lines 217 and 218) and end the game by displaying the <span class="strong"><strong>You Win!</strong></span> message.</p><p>We <a id="id542" class="indexterm"/>finished creating the shooter enemies. Now it is time to provide the <span class="emphasis"><em>shooter</em></span> with movement to dodge the <span class="emphasis"><em>missiles</em></span> and <span class="emphasis"><em>shots</em></span> to hit the <span class="emphasis"><em>invaders</em></span>.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Shooter – multi-touch control"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Shooter – multi-touch control</h1></div></div></div><p>Kivy supports<a id="id543" class="indexterm"/> multi-touch interactions. This<a id="id544" class="indexterm"/> feature is always present but we haven't paid too much attention to it except when we used the <code class="literal">Scatter</code> widget in <a class="link" href="ch04.html" title="Chapter 4. Improving the User Experience">Chapter 4</a>, <span class="emphasis"><em>Improving the User Experience</em></span>. Additionally, we didn't clarify that the entire screen and GUI components are already capable of multi-touch, and that Kivy handles the events accordingly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>Kivy<a id="id545" class="indexterm"/> handles multi-touch actions internally. This means that all the Kivy widgets and components support multi-touch interaction; we don't have to worry about it. Kivy solves all the possible conflicts of ambiguous situations that are common in multi-touch control, for example, touching two buttons at the same time.</p></div></div><p>That said, it is up to us to control particular implementations. Multi-touch programming introduces logic problems that we need to solve as developers. Nevertheless, Kivy provides the data related to each particular touch so we can work on the logic. The main problem is that we need to constantly distinguish one touch from another, and then take the respective actions.</p><p>With<a id="id546" class="indexterm"/> Invaders Revenge, we need<a id="id547" class="indexterm"/> to distinguish between two actions that are triggered by the same type of touch. The first action is the <span class="emphasis"><em>shooter's</em></span> horizontal movement in order to avoid the invaders' <span class="emphasis"><em>missiles</em></span>. The second is touching the screen to fire at the <span class="emphasis"><em>invaders</em></span>. The following screenshot illustrates these two actions with the wide thick arrows (sliding touch) and the dotted thin arrow (shot action):</p><div class="mediaobject"><img src="images/B04244_05_06.jpg" alt="Shooter – multi-touch control"/></div><p>The following code, fragment 1 (of 2), of <code class="literal">shooter.py</code> controls these two actions by using the <span class="emphasis"><em>enemy area</em></span> and <span class="emphasis"><em>shooter area</em></span>:</p><div class="informalexample"><pre class="programlisting">220. # File name: shooter.py (Fragment 1)
221. from kivy.clock import Clock
222. from kivy.uix.image import Image
223. from ammo import Shot
224. 
225. class Shooter(Image):
226.   reloaded = True
227.   alife = False
228. 
229.   def on_touch_down(self, touch):
230.     if self.parent.collide_point(*touch.pos):
231.       self.center_x = touch.x
232.       touch.ud['move'] = True
233.     elif self.enemy_area.collide_point(*touch.pos):
234.       self.shoot(touch.x,touch.y)
235.       touch.ud['shoot'] = True
236. 
237.   def on_touch_move(self, touch):
238.     if self.parent.collide_point(*touch.pos):
239.       self.center_x = touch.x
240.     elif self.enemy_area.collide_point(*touch.pos):
241.       self.shoot(touch.x,touch.y)
242. 
243.   def on_touch_up(self, touch):
244.     if 'shoot' in touch.ud and touch.ud['shoot']:
245.       self.reloaded = True</pre></div><p>The <code class="literal">on_touch_down</code> (lines 229 to 235) and <code class="literal">on_touch_move</code> (lines 237 to 241) methods distinguish <a id="id548" class="indexterm"/>between the two actions, <span class="emphasis"><em>movement</em></span> or <span class="emphasis"><em>shoot</em></span>, by<a id="id549" class="indexterm"/> using the <span class="emphasis"><em>shooter area</em></span> (lines 230 and 238) and the <span class="emphasis"><em>enemy area</em></span> (lines 233 and 240) widgets, respectively, in order to collide the coordinates of the event.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>The touch coordinates are the most common strategy to identify specific touches. However, touches have many other attributes that could help to distinguish between them, for example, timing, a double (or triple) tap, or the input device. You<a id="id550" class="indexterm"/> can check the <code class="literal">MotionEvent</code> class to review all the attributes of a touch (<a class="ulink" href="http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent">http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent</a>).</p></div></div><p>In contrast, the <code class="literal">on_touch_up</code> method (line 243) follows a different approach. It uses the <span class="strong"><strong><code class="literal">ud</code></strong></span> attribute (user data dictionary to store personalized data on the touch) of a <code class="literal">MotionEvent</code> instance (touch) to determine whether the touchdown that started the event was a <span class="emphasis"><em>movement</em></span> (in the <span class="emphasis"><em>shooter area</em></span>) or a <span class="emphasis"><em>shoot</em></span> (in the <span class="emphasis"><em>enemy area</em></span>). We set <code class="literal">touch.ud</code> (lines 232 and 235) previously on <code class="literal">on_touch_down</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>Kivy keeps the touch event associated with the three basic touch events (down, move, and up), so the touch references we get for <code class="literal">on_touch_down</code>, <code class="literal">on_touch_move</code>, and <code class="literal">on_touch_up</code> are the same, and we can distinguish between touches.</p></div></div><p>Let's <a id="id551" class="indexterm"/>now analyze the details of the methods that are called on by these events. The following is the code, fragment 2 (of 2), of <code class="literal">shooter.py</code>:</p><div class="informalexample"><pre class="programlisting">246. # File name: shooter.py (Fragment 2) 
247.   def start(self, instance, value):
248.     self.alife=True
249. 
250.   def shoot(self, fx, fy):
251.     if self.reloaded and self.alife:
252.       self.reloaded = False
253.       Clock.schedule_once(self.reload_gun, .5)
254.       shot = Shot()
255.       shot.center = (self.center_x, self.top)
256.       self.invasion.add_widget(shot)
257.       (fx,fy) = self.project(self.center_x,self.top,fx,fy)
258.       shot.shoot(fx,fy,self.invasion.fleet)
259. 
260.   def reload_gun(self, dt):
261.     self.reloaded = True
262. 
263.   def collide_ammo(self, ammo):
264.     if self.collide_widget(ammo) and self.alife:
265.       self.alife = False
266.       self.color = (0,0,0,0)
267.       self.invasion.end_game("Game Over")
268.       return True
269.     return False
270. 
271.   def project(self,ix,iy,fx,fy):
272.     (w,h) = self.invasion.size
273.     if ix == fx: return (ix, h)
274.     m = (fy-iy) / (fx-ix)
275.     b = iy - m*ix
276.     x = (h-b)/m
277.     if x &lt; 0: return (0, b)
278.     elif x &gt; w: return (w, m*w+b)
279.     return (x, h)</pre></div><p>We first <a id="id552" class="indexterm"/>created a method to start the shooter by bringing it to life (line 247 and 248), which we will use when we start the game. Then, we implement an interesting behavior for the <code class="literal">on_touch_move</code> method with the <code class="literal">shoot</code> method (lines 250 to 258). Instead of shooting as fast as possible, we delay the next <code class="literal">shoot</code> by <code class="literal">0.5</code> seconds. This delay simulates a time lapse in which the gun needs to be reloaded (line 253). Otherwise, it would be unfair to the <span class="emphasis"><em>invaders</em></span> to shoot as fast as the computer allows. Conversely, when we use the <code class="literal">on_touch_up</code> method, the gun is reloaded immediately so, in this case, it would be the skill of the player who could fire faster with a touchdown and touch-up sequence.</p><p>The <code class="literal">collide_ammo</code> method (lines 263 to 269) is almost equivalent to the <code class="literal">collide_ammo</code> method of the <code class="literal">Fleet</code> (lines 207 to 213). The only difference is that there is just one <span class="emphasis"><em>shooter</em></span> instead of a set of <span class="emphasis"><em>invaders</em></span>. If the <span class="emphasis"><em>shooter</em></span> is hit, then the game is over and the message <span class="strong"><strong>Game Over</strong></span> is displayed. Notice that we don't remove the <span class="emphasis"><em>shooter</em></span>, we simply set its <code class="literal">alife</code> flag to <code class="literal">False</code> (line 265), and hide it by setting the <a id="id553" class="indexterm"/>color to black (line 266). With this, we avoid inconsistencies in references that point to an instance that no longer exists in the interface context.</p><p>The <code class="literal">project</code> method (lines 271 to 278) extends (project) the touch coordinates to the border of the screen, so the <span class="emphasis"><em>shot</em></span> will continue its trajectory until it reaches the end of the screen and not stop exactly at the touch coordinate. The mathematical details are beyond the scope of this book but it is a simple linear projection.</p><p>The application is almost ready. There is just one minor problem. If you don't have a multi-touch screen, you would actually not be able to play this game. The next section introduces how to handle keyboard events in order to have a more classic gaming approach, which combines the keyboard and mouse.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Invasion – moving the shooter with the keyboard"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Invasion – moving the shooter with the keyboard</h1></div></div></div><p>This<a id="id554" class="indexterm"/> section offers a second possibility of how to move the <span class="emphasis"><em>shooter</em></span>. If you don't have a multi-touch device, you will need to use something else to control the position of the <span class="emphasis"><em>shooter</em></span> easily while you use the mouse to shoot. The following is the code, fragment 1, (of 2) of <code class="literal">main.py</code>:</p><div class="informalexample"><pre class="programlisting">280. # File name: main.py (Fragment 1)
281. from kivy.app import App
282. from kivy.lang import Builder
283. from kivy.core.window import Window
284. from kivy.uix.floatlayout import FloatLayout
285. from kivy.uix.label import Label
286. from kivy.animation import Animation
287. from kivy.clock import Clock
288. from fleet import Fleet
289. from shooter import Shooter
290. 
291. Builder.load_file('images.kv')
292. 
293. class Invasion(FloatLayout):
294. 
295.   def __init__(self, **kwargs):
296.     super(Invasion, self).__init__(**kwargs)
297.     self._keyboard = Window.request_keyboard(self.close,          self)
298.     self._keyboard.bind(on_key_down=self.press)
399.     self.start_game()
300. 
301.   def close(self):
302.     self._keyboard.unbind(on_key_down=self.press)
303.     self._keyboard = None
304. 
305.   def press(self, keyboard, keycode, text, modifiers):
306.     if keycode[1] == 'left':
307.       self.shooter.center_x -= 30
308.     elif keycode[1] == 'right':
309.       self.shooter.center_x += 30
310.     return True
311. 
312.   def start_game(self):
313.     label = Label(text='Ready!')
314.     animation = Animation (font_size = 72, d=2)
315.     animation.bind(on_complete=self.fleet.start_attack)
316.     animation.bind(on_complete=self.shooter.start)
317.     self.add_widget(label)
318.     animation.start(label)</pre></div><p>The <a id="id555" class="indexterm"/>preceding code illustrates the keyboard event control. The <code class="literal">__init__</code> constructor (lines 295 to 299) will request<a id="id556" class="indexterm"/> <span class="strong"><strong><code class="literal">keyboard</code></strong></span> (line 297) to the <code class="literal">Window</code> and <code class="literal">bind</code> (line 298) the <span class="strong"><strong><code class="literal">on_keyboard_down</code></strong></span> event to<a id="id557" class="indexterm"/> the <span class="strong"><strong><code class="literal">press</code></strong></span> method. One <a id="id558" class="indexterm"/>important parameter of the <code class="literal">Window._request_keyboard</code> method is the method that is called when <code class="literal">keyboard</code> is closed (lines 301 to 303). There are many reasons why the keyboard can become closed, including when another widget requests it. The <code class="literal">press</code> method (lines 305 to 310) is the one in charge of handling the keyboard input, the pressed key. The pressed key is kept in the <code class="literal">keycode</code> parameter and it is used in lines 306 and 308 to decide whether the <span class="emphasis"><em>shooter</em></span> should move left or right.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>The keyboard binding in the game is for testing purposes on devices that have no multi-touch functionality. If you want to try it on your mobile device, you should comment out lines 297 and 298 to deactivate the keyboard binding.</p></div></div><a id="id559" class="indexterm"/><p>Line 299 calls the <code class="literal">start_game</code> method (lines 312 to 318). The method displays <code class="literal">Label</code> with the text <span class="strong"><strong>Ready!</strong></span> Notice that we applied an <code class="literal">Animation</code> instance to <code class="literal">font_size</code> in line 314. So far, we have been using the animations to move widgets around with the <code class="literal">x</code>, <code class="literal">y</code>, or <code class="literal">pos</code> properties. However, animations work with any property (that supports arithmetic operators; as a counter example, <code class="literal">String</code> doesn't support such operations). For example, we could use them to animate the rotation or scaling of <code class="literal">Scatter</code>. When the animation is complete, it will start both the <span class="emphasis"><em>fleet</em></span> and the <span class="emphasis"><em>shooter</em></span> (lines 315 and 316). Notice how we just bound two methods to the same event.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>There is no limit to the number of methods that we can bind to an event.</p></div></div><p>In the next section, we will discuss how to animate multiple properties in a sequence or simultaneously.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Combining animations with '+' and '&amp;'"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Combining animations with '+' and '&amp;'</h1></div></div></div><p>You<a id="id560" class="indexterm"/> already learned <a id="id561" class="indexterm"/>that you can add several properties to the same animation so that they are modified together (line 69 of <code class="literal">ammo.py</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>We can <a id="id562" class="indexterm"/>combine animations by using the <code class="literal">+</code> and <code class="literal">&amp;</code> <span class="strong"><strong>operators</strong></span>. The <code class="literal">+</code> operator<a id="id563" class="indexterm"/> is used to create sequenced animations (one after another). The <code class="literal">&amp;</code> operator lets us execute two animations at the same time.</p></div></div><p>The following code is fragment 2 of <code class="literal">main.py</code>, and illustrates the use of these two operators:</p><div class="informalexample"><pre class="programlisting">319. # File name: main.py (Fragment 2)
320.   def end_game(self, message):
321.     label = Label(markup=True, size_hint = (.2, .1), 
322.       pos=(0,self.parent.height/2), text = message)
323.     self.add_widget(label)
324.     self.composed_animation().start(label)
325. 
326.   def composed_animation(self):
327.     animation = Animation (center=self.parent.center)
328.     animation &amp;= Animation (font_size = 72, d=3)
329.     animation += Animation(font_size = 24,y=0,d=2)
330.     return animation
331. 
332. class InvasionApp(App):
333.   def build(self):
334.     return Invasion()
335. 
336. if __name__=="__main__":
337.   InvasionApp().run()</pre></div><p>The <code class="literal">end_game</code> method (lines 320 to 324) displays a final message to indicate how the game ended (<span class="strong"><strong>You Win</strong></span> on line 219 of <code class="literal">fleet.py</code> or <span class="strong"><strong>Game Over</strong></span> on line 267 of <code class="literal">shooter.py</code>). This method uses the <code class="literal">composed_animation</code> method (lines 326 to 330) to create a composed <code class="literal">Animation</code>, in which <a id="id564" class="indexterm"/>we use<a id="id565" class="indexterm"/> all the possibilities to combine animations. Line 327 is a simple <code class="literal">Animation</code> that is joined (with the '<code class="literal">&amp;</code>' operator) to execute at the same time with another simple <code class="literal">Animation</code> of a different duration (line 328). In line 329, an <code class="literal">Animation</code> containing two properties (<code class="literal">font_size</code> and <code class="literal">y</code>) is attached to the previous one with the '<code class="literal">+</code>' operator.</p><p>The resulting animation does the following: it takes one second to move the message from the left to the middle, while the font size increases in size. When it gets to the middle, the increase in the font size continues for two more seconds. Once the font reaches its full size (72 points), the message moves to the bottom and keeps decreasing in size at the same time. The following diagram illustrates the whole animation sequence:</p><div class="mediaobject"><img src="images/B04244_05_08.jpg" alt="Combining animations with '+' and '&amp;'"/></div><p>The '<code class="literal">+</code>' operator is similar to what we did when we bound the <code class="literal">Animation on_complete</code> event to a method that creates another <code class="literal">Animation</code> in the <span class="emphasis"><em>invader</em></span>: <code class="literal">animation.bind(on_complete = self.to_dock)</code> (line 110 of <code class="literal">invader.py</code>). The difference is that when we use the '<code class="literal">+</code>' operator, there is no chance to create an infinite loop as we did with the <span class="emphasis"><em>fleet</em></span>, or change<a id="id566" class="indexterm"/> the <code class="literal">Widget</code> properties<a id="id567" class="indexterm"/> before starting another animation. For example, in the <span class="emphasis"><em>invader</em></span> case, we relocated the <span class="emphasis"><em>invader</em></span> to the top-center (lines 122 and 123) of the screen before the animation that carries it back to the <span class="emphasis"><em>dock</em></span> (lines 124 to 126):</p><div class="informalexample"><pre class="programlisting">121.   def to_dock(self, instance, value):
122.     self.y = Window.height
123.     self.center_x = Window.width/2
124.     animation = Animation(pos=self.parent.pos, d=2)
125.     animation.bind(on_complete = self.parent.bind_invader)
126.     animation.start(self)</pre></div><p>The <code class="literal">&amp;</code> operator is similar to sending two properties as parameters of the <code class="literal">Animation</code>, as we did in line 69: <code class="literal">self.animation = Animation(x=tx, top=ty)</code>. The difference in sending two properties as parameters is that they share the same duration and transition, whereas in line 328, we change the duration of the second property.</p><p>Here is one last screenshot that shows how the invaders have finally taken their revenge:</p><div class="mediaobject"><img src="images/B04244_05_07.jpg" alt="Combining animations with '+' and '&amp;'"/></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Summary</h1></div></div></div><p>This chapter covered the whole construction process of an interactive and animated application. You learned how to integrate various Kivy components and you should now be able to comfortably build a 2D animated game.</p><p>Let's review all the new classes and components we used in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Atlas</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Image</code>: The <code class="literal">source</code> property</li><li class="listitem" style="list-style-type: disc"><code class="literal">SoundLoader</code> and <code class="literal">Sound</code>: The <code class="literal">load</code> and <code class="literal">play</code> methods, respectively</li><li class="listitem" style="list-style-type: disc"><code class="literal">Window</code>: The <code class="literal">height</code> and <code class="literal">width</code> properties, and the <code class="literal">request_keyboard</code>, <code class="literal">remove_widget</code>, and <code class="literal">add_widget</code> methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">Animation</code>: The properties as parameters; <code class="literal">d</code> and <code class="literal">t</code> parameters; <code class="literal">start</code>, <code class="literal">stop</code>, and <code class="literal">bind</code> methods; <code class="literal">on_start</code>, <code class="literal">on_progress</code>, and <code class="literal">on_complete</code> events; and <code class="literal">'+'</code> and <code class="literal">'&amp;'</code> operators</li><li class="listitem" style="list-style-type: disc"><code class="literal">Touch</code>: <code class="literal">ud</code> attribute</li><li class="listitem" style="list-style-type: disc"><code class="literal">Clock</code>: <code class="literal">schedule_interval</code> and <code class="literal">schedule_once</code> methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">Keyboard</code>: <code class="literal">bind</code> and <code class="literal">unbind</code> methods, <code class="literal">on_key_down</code> event</li></ul></div><p>The information contained in this chapter presents tools and strategies you can use to develop highly interactive applications. By combining the previous chapters information with this chapter's insights into the use of properties, binding events, and further understanding of the Kivy language, you should be able to quickly start using all the other components of the Kivy API (<a class="ulink" href="http://kivy.org/docs/api-kivy.html">http://kivy.org/docs/api-kivy.html</a>).</p><p>The last chapter, <a class="link" href="ch06.html" title="Chapter 6. Kivy Player – a TED Video Streamer">Chapter 6</a>, <span class="emphasis"><em>Kivy Player – a TED Video Streamer,</em></span> of this book will teach you how to control multimedia components, in particular video and audio. It will present another example in order to present a few more Kivy components, but more importantly, it will teach you how to build a more professional looking interface. It will also introduce some Kivy tools to debug our applications.</p></div></div>
</body></html>