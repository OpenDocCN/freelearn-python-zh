- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concepts of authentication—proving that the user is who they claim to be—and
    authorization—making sure that the authenticated user should or should not be
    able to perform certain operations on your API—are very complex. In this chapter,
    you will explore the topics of authentication and authorization from a very practical
    standpoint and from the FARM stack perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter will detail a simple yet robust and extensible setup for your FastAPI
    backend, based on **JSON Web Token** (**JWT**)—arguably the most popular and practical
    authentication method that has emerged in the last years. Then, you will see how
    to integrate your JWT-based authentication methods into React, leveraging some
    of React’s powerful features—namely, Hooks, Context, and React Router.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a solid grasp of authentication
    methods that both FastAPI on the backend and React on the frontend have to offer,
    and you will be able to authenticate users and control what they can and cannot
    do within your application with granularity and precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The user model and how it relates to other resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JWT authentication mechanism—the big picture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization tools in FastAPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to protect the routes, routers, or the entire app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various solutions for authenticating with React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the sample application in this chapter, you should have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js version 18 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.11.7 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The requirements are identical to those in the previous chapters, and the new
    packages that you will install will be described as they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JSON Web Token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP is a stateless protocol, and that fact alone implies several important
    consequences. One of them is that if you want to persist some kind of state between
    requests, you must resort to a mechanism that will be able to remember a set of
    data, such as who the logged-in user was, what the selected items during a previous
    browser session were, or what the site preferences were. In order to achieve such
    functionality, and identify the current user, you as a developer have numerous
    options at your disposal. Some of the most popular and modern solutions are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Credential-based authentication:** It requires the user to enter personal
    credentials, such as a username or email, along with a password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passwordless login:** Users receive a secure, time-limited token via email
    or another communication channel for authentication instead of using a traditional
    password after creating an account. The secure token is used for session authentication,
    eliminating the need to type or remember passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Biometric passwords:** It utilizes a bio-feature of the user, such as a fingerprint,
    for authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Social authentication:** Users leverage their existing social media accounts
    (e.g., Google, Facebook, or LinkedIn) for authentication. This associates the
    user’s social media account with their account on the platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classic personal credentials method:** Users provide an email and choose
    a password during registration. Optionally, users can also select a username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will consider the classic personal credentials method. When users
    register, they provide an email and choose a password and, optionally, a username.
  prefs: []
  type: TYPE_NORMAL
- en: What is JWT?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While there are different ways of maintaining the identity of a user across
    different parts of an app, JWT is arguably the most common and popular method
    of connecting frontend applications (React, Vue.js, and Angular) or mobile apps
    with an API (in our case, a REST API). JWT is nothing but a standard, a way of
    structuring a big string composed of seemingly random characters and numbers that
    encapsulate user data in a secure way.
  prefs: []
  type: TYPE_NORMAL
- en: JWTs contain three parts—the **header**, the **payload**, and the **signature**.
    The header hosts metadata about the token itself—the algorithm used for signing
    the token and the type of the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The payload is the most interesting part. It contains the following information
    necessary for authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data (claims): The ID of the user (or the username)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **issued at field** (**iat**): The date and time of issuing the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The time at which the token ceases to be valid: Tied to the duration of the
    token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optionally, other fields: For example, the username, roles etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The payload is decodable and readable by everyone. You can read more about
    tokens and understand how they look in the JWT documentation: [https://jwt.io](https://jwt.io).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the most important part of the token is the signature. The signature
    guarantees the claims made by the token. The signature is reproduced (calculated)
    and compared with the original—thus preventing the modification of the claims.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a JWT stating that the username is `John`. Now, if someone
    were to attempt to change this to `Rita`, they would also need to modify the signature
    to match. However, altering the signature would render the token invalid. This
    mechanism ensures that the token’s content remains unchanged and authentic.
  prefs: []
  type: TYPE_NORMAL
- en: The token is hence able to completely replace the authentication data—user or
    email and password combinations that do not need to be transmitted more than once.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, you will learn how to implement a JWT-based authentication
    flow in your app.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI backend with users and dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications (or mobile apps, for that matter) are not very useful if they
    are not secure. You must have heard about tiny errors in the authentication implementations
    that result in hundreds of thousands or even millions of compromised accounts,
    potentially exposing sensitive and valuable information.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI is based on OpenAPI—previously known as `apiKey`, `http`, `OAuth 2.0`,
    `openIdConnect`, and so on). While the FastAPI documentation website ([https://fastapi.tiangolo.com/tutorial/security/](https://fastapi.tiangolo.com/tutorial/security/))
    provides an excellent and detailed tutorial on creating an authentication flow,
    it is based on the `OAuth 2.0` protocol, which uses form data to send the credentials
    (username and password).
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will devise a simple user model that will enable
    an authentication flow. You will then learn how to encode the user data into a
    JWT and how to use the token for accessing protected routes.
  prefs: []
  type: TYPE_NORMAL
- en: User model for authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basis of every authentication flow is the user model, which has to be able
    to store a minimum set of data needed for unequivocally identifying the users.
    The most common unique fields are an email address, a username, and, of course,
    a primary key—an `ObjectId` instance in the case of MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling data with MongoDB is inherently different from modeling relational
    databases as discussed in [*Chapter 2*](B22406_02.xhtml#_idTextAnchor026), *Setting
    Up the Database with MongoDB*. The driving idea is to think of queries upfront
    and model your relationships taking into account the queries that your app is
    going to be making most frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication and authorization with FastAPI: a walk-through'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authentication and authorization with FastAPI are much easier to understand
    through an example. In the next few sub-sections, you will develop a simple yet
    fully functional authentication system that will contain all the mandatory steps.
    To highlight the important parts, while keeping the example as concise as possible,
    you will not use a real MongoDB connection. Instead, you will make your own JSON
    file-based **database** that will store users as they register into the app and
    effectively mock a MongoDB collection. The first and foremost step is to review
    your authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing all the parts of your authentication system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following list provides a quick recapitulation of the tools and packages
    needed for implementing a FastAPI authentication workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a FastAPI authentication workflow, you must use FastAPI’s security
    tools. In FastAPI, when you need to declare dependencies with `Security()` class.
    The other FastAPI import that will be needed is the type of dependable—in this
    case, you will use **bearer** tokens for authorization. You can refer to the FastAPI
    documentation: [https://fastapi.tiangolo.com/reference/security/#fastapi.security.HTTPBearer](https://fastapi.tiangolo.com/reference/security/#fastapi.security.HTTPBearer).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You also need password hashing and comparing functionality, which `passlib`
    can provide. The `passlib.context` module contains one main class: `passlib.context.CryptContext`,
    designed to take care of many of the more frequent coding tasks associated with
    hashing and comparing strings through various algorithms. Your authentication
    system requires two main functionalities: hashing passwords during user registration
    and comparing hashed passwords during login with those stored in your database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, **PyJWT** will provide the functionality to encode and decode JWT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next steps involve creating the basic FastAPI application in a new virtual
    environment, activating the environment, installing the necessary packages, and
    creating a suitable model of the users with the required fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory, set it as the working directory with the `cd` (change
    directory) command, create a new Python environment in `/venv`, and activate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the new Python environment is active, install the needed packages for
    the authentication system and the application overall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to be able to reproduce exactly the code in the book, you are strongly
    encouraged to use the `/backend/requirements.txt` file from the accompanying repository
    and install the packages with the `pip install -r` `requirements.txt` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the last three packages needed for your authentication system:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Passlib` is a password hashing library for Python, and it supports a wide
    range of hashing algorithms, including `bcrypt`. It is very useful as it provides
    a unified interface for hashing and verifying passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bcrypt` package is a Python module that provides the password hashing method
    based on the Blowfish password hashing algorithm that you will be using. Please
    stick to the provided version of the package as there are some unresolved issues
    with later versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PyJWT` is the Python library for encoding and decoding JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, create the models for the application. As this app will only deal with
    users, the `models.py` file is rather simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The models are self-explanatory, and they are left to be as explicit as possible.
    `UserBase` corresponds to the user representation that will be stored in your
    dummy database, or in a MongoDB collection (pay special attention to `Object_id`).
    In the given solution, the `id` field will be a UUID, so you set it to a string
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A Python `ObjectId()` class for the purpose of this demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `models.py` file contains two additional auxiliary Pydantic models: `UserIn`,
    which accepts the user data for registration or login (typically username and
    password, but can easily be extended to include email or other data), and `UserOut`,
    which is responsible for representing users within the application, excluding
    the hashed password but including the ID and the username.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UsersList` finally just outputs the list of all users, and you will use this
    model as an example for your protected route. Now, build your `app.py` file and
    create the actual application.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After defining the models, you can now proceed and create the main FastAPI
    application and the authentication class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Python file and name it `app.py`. Inside this file, create a minimal
    FastAPI application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will return to this file shortly, but for now, let’s keep it as short as
    possible. Now it is time to build out the heart of your authentication system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same folder, create the `authentication.py` file and start building
    it. Having all this at hand, open the newly created `authentication.py` file and
    begin crafting the authentication class. For this, you must first scaffold the
    `AuthHandler` class and add the required imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you have learned about all these imports, you can craft a class named
    `AuthHandler`, that uses FastAPI’s `HTTPBearer` as the security dependency and
    defines a password-processing context from `passlib`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding security dependency and password-processing context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This procedure consists of multiple steps. You’ll need to add a secret string
    that would ideally be generated randomly and kept safe in an environment variable,
    far from any `git commit`. The secret string is necessary for hashing the passwords.
    Here, you will hardcode it in this file for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, continue with the same file and code the desired functionality step by
    step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`authentication.py` file under the `AuthHandler` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function simply creates a hash of the given password, and this result is
    what you will be storing in your database. It is making good use of your previously
    defined `passlib` context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`authentication.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar to the previous function, `verify_password` simply verifies that the
    hash of `plain_password` is indeed equal to the (already) hashed password and
    it returns `True` or `False`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`authentication.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `encode_token` method of your class leverages the `PyJWT` package’s `encode`
    method to create the JWT itself, and it is very explicit; the payload contains
    the expiration time (very important—you do not want the JWTs to last for too long)
    and the *issued-at time* (the `iat` part). Also, it references the dictionary
    named `sub`, which contains all the data that you wish to encode—in this case,
    the user ID and the username, although you could also add a role (regular user,
    administrator, and so on) or other data. To recap, the JWT encodes three pieces
    of data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The expiration duration, in this example, 30 minutes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The time of issuing the token, in this example, it is set to `now()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sub` part is the data (in the form of a dictionary) that you want to include
    in the token. In this example, it is the user ID and the username.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decoding** **the token**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continue building out the class, as now the reverse functionality is required—a
    way of decoding the token:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: def auth_wrapper(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'auth: HTTPAuthorizationCredentials = Security(security)) -> dict:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return self.decode_token(auth.credentials)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will use this `auth_wrapper` as the dependency—it will check for the presence
    of a valid JWT passed as a bearer token in the request headers for all the routes
    or entire routers that need authorization.
  prefs: []
  type: TYPE_NORMAL
- en: The `authorization.py` file is a minimal implementation of an authentication/authorization
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous steps you wrapped most of the authentication and authorization
    functionality into a simple and compact class. The creation of the token, its
    encoding and decoding, as well as the password hashing and verification. Finally,
    you have created a simple dependency that will be used for verifying the user
    and enabling or disabling access to protected routes.
  prefs: []
  type: TYPE_NORMAL
- en: Building the FastAPI router for the application will be very similar to the
    ones that you have already built in [*C**hapter 2*](B22406_02.xhtml#_idTextAnchor026),
    *Setting Up the Database with MongoDB*. You will have two basic endpoints for
    registering and logging in, and they will rely heavily on the `AuthHandler` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the APIRouter for the users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you will create the APIRouter for the users and implement
    the login and register functionalities with the help of the authentication class
    and a mock database service implemented with dictionaries and UUID. To achieve
    this functionality, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder `routers` in the root of your application and a file named
    `users.py` inside of it. Add the following code to the `users.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After adding the imports at the start of the file, create the APIRouter and
    the registration endpoint. The registration function uses the fake JSON database
    to store the username and the hashed password, by using the `authentication.py`
    file that you created before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to demonstrate a basic JWT-based authentication and authorization system,
    a fake data storage solution is used. Instead of connecting through a driver to
    a MongoDB cluster, you use a simple JSON file for storing users along with their
    hashed passwords—a solution similar to the popular JSON Server Node package, used
    for testing and scaffolding purposes. However, all the functionality and logic
    presented will apply to real database scenarios, and it is easily adaptable for
    MongoDB drivers or ODMs, such as PyMongo, Motor, or Beanie.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the imports, which include a couple of packages that you will likely not
    need when working with a real MongoDB database, such as `uuid`, you have instantiated
    APIRouter and the custom-made `AuthHandler` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `/register` endpoint accepts the new user’s data in the body and molds it
    through the `UserIn` Pydantic class defined in the `models.py` file, while the
    output is set to be of class `UserBase`. This is something that you would likely
    avoid as it will send the hashed password back to the newly registered user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instead of a real MongoDB database, you are reading the contents of a JSON
    file called `users.json`—this file will host a very simple data structure that
    will mimic your users’ MongoDB collection: a simple array of dictionaries containing
    user data – the ID, the username, and the hashed password.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you have this “database,” or array of users, it is easy to just loop
    over them and verify whether it contains a user with the same username as the
    user trying to register—if so, you just dismiss it with a gentle `HTTP 409` response
    code and a `Username already` `taken` message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the username is not taken, proceed to start using your `auth_handler` instance
    and set the plain-text raw password to its hashed counterpart, safe to be stored
    inside the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to be able to store the user as a Python dictionary, use `jsonable_encoder`
    and add a new key to it: the `uuid` string that will be used as the ID of the
    new user.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, append the user (represented as a dictionary with an ID, username,
    and hashed password) to your list of users, write the modified list to the JSON
    file, and return the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, continuing with the `users.py` router, you can create the `login` endpoint
    as well by adding the following code at the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code follows a similar logic: it loads the user data and attempts to find
    the login user by their username (similar to a find query). If the user is not
    found or the password verification fails, the endpoint raises an exception. It’s
    considered a good security practice to inform the user that the entire combination
    of username and password is invalid, without specifying which part exactly failed.
    If both checks pass, you encode the token and return it to the user.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Time to hook up the router. Edit the previously created `app.py` file by replacing
    the contents of the file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you added the `users` router.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a file called `users.json` in the root of your project and populate
    it with an empty `users` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file and start the FastAPI application from the shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should be able to perform a user registration and a user login. Try it
    with the HTTPie client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The server should send the following response, but bear in mind that your hash
    and UUID will be different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you peek in the `users.json` file, you should see something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world system, you would not want to send the hashed password even
    to the logged-in user, but this whole system is for demonstration purposes and
    created to be as illustrative as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have created a full authentication flow (for demonstration purposes—you
    will not use a JSON file with dictionaries and UUIDs in production) and you have
    crafted all the mandatory functionalities: creating users (registration), checking
    for the validity of the submitted data, and user login. Finally, you tested the
    registration functionality by creating a test user.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the login functionality with HTTPie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, test the login functionality with the correct user/password combination
    and then a wrong one.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, log in. In the terminal, issue the following HTTPie command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The response should be just a big string—your JWT—the value of this token (here,
    it starts with the string *eyJhbGciOiJ…*) should be copied and saved for testing
    the authenticated route later:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try something like the following (notice the password is wrong):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The response will be similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have just implemented your own authentication system with FastAPI from scratch.
    Now it would be great to put it to use in a route.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a protected route
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Say that now you want a new endpoint that lists all the users in your system,
    and you want to make it visible only to logged-in users. This method would allow
    you to protect any route in different routers, just by leveraging the powerful
    FastAPI dependency injection system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `users.py` file and add the following route at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The key to this route is the `user_data` part—if the dependency is not met,
    the route will respond with an exception and the messages defined in `authentication.py`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try to log in, grab the JWT that you got from the login endpoint and have copied
    (if it hasn''t expired!), and then pass it as the bearer token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result should contain all the users that you have created so far:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you try to modify the token, or if you let it expire, the result will be
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, you saw how to create a simple but efficient authentication
    system on your FastAPI backend, create a JWT generator, verify the tokens, protect
    some routes, and provide the routes needed for creating (registering) new users
    and logging in. The next section will show how things work on the front end.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating the users in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will go through a basic mechanism that will enable you
    to have a simple authentication flow on the client side. Everything will revolve
    around the JWT and the way you decide to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: React.js is an unopinionated UI library. It provides numerous ways of implementing
    user authentication and authorization. Since your FastAPI backend implements JWT-based
    authentication, you have to decide how to deal with the JWT in React.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you are going to store it in memory, then in `localStorage`
    (an HTML5 simple web storage object in JavaScript that allows applications to
    store key-value pairs in a user’s web browser with no expiration date). This chapter
    will not cover cookie-based solutions, which tend to be the most robust and secure,
    as one such solution will be covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these methods has its benefits and drawbacks, and it is very useful
    to get acquainted with them. Authentication should always be taken very seriously
    and, depending on your application scope and requirements, it should always be
    a topic that requires thorough analysis.
  prefs: []
  type: TYPE_NORMAL
- en: There is an ongoing debate on what the optimal solution for storing authentication
    data is—in this case, the JWT. As always, there are pros and cons to each solution.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies have been around for a very long time—they can store data in key-value
    pairs in the browser and are readable from both the browser and the server. Their
    popularity coincided with the classic server-side-rendered websites. However,
    they can store a very limited amount of data and the structure of said data has
    to be very simple.
  prefs: []
  type: TYPE_NORMAL
- en: '`localstorage` and `sessionStorage` were introduced with HTML5 as a way to
    address the need for storing complex data structures in **single-page applications**
    (**SPAs**), among other things. Their capacity is around 10 MB, depending on the
    browser’s implementation, compared to 4 KB of cookie capacity. Session storage
    data persists through a session, while local storage remains in the browser even
    after it is closed and reopened until manually deleted, making SPAs the most pleasant
    but also the most vulnerable solution. Both can host complex JSON data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing JWTs in `localstorage` is easy and it provides a great user and developer
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of authorities on the subject suggest storing JWTs in HTTP-only
    cookies, as they cannot be accessed through JavaScript and require the frontend
    and the backend to run on the same domain.
  prefs: []
  type: TYPE_NORMAL
- en: This can be accomplished in different ways, through routing requests or using
    a proxy. Another popular strategy is the use of so-called refresh tokens. In this
    method, the application issues one token upon login, and then this token is used
    to generate other (refresh) tokens automatically, allowing you to strike the right
    balance between security and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: The Context API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051), *Python Type Hints and Pydantic*,
    you learned how to manage simple pieces of the state of a component through the
    `useState` hook.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have a top-level component—maybe even the root `App.js` component—and
    you need to pass some piece of state to a deeply nested component inside the React
    component tree. You would need to pass that piece of data to a component that
    is inside the `App.js` stateful component and then pass it further down the tree
    until it reaches the subcomponent that actually needs said data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is known as **prop drilling**—passing a state value through props
    and having multiple components that do not use this state value; they just pass
    it on. Prop drilling has several implications, most of which are best avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and changing code is more difficult because you must keep the state
    value channels of communication intact at all times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is less reusable as components need to always provide the state value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More code needs to be written, as components need to accept and forward props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React introduced the **Context API** as a way of providing values across components
    without the need for prop drilling.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple SPA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following section, you will create a very simple SPA that will allow
    users to register (if they are not registered yet), log in with a username and
    password, and, if authenticated, see the list of all registered users. The UI
    will tightly mimic your backend.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the frontend to be functional and testable, it is mandatory to
    provide the backend from the previous section, so be sure to run the FastAPI backend
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uvicorn` `app:app --reload`'
  prefs: []
  type: TYPE_NORMAL
- en: The frontend will connect to the running FastAPI backend through the API. While
    FastAPI is serving the application on the address `http://127.0.0.1:8000`, the
    React frontend will use this same URL to connect, perform GET and POST requests,
    authenticate users and list resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will go through the main concepts of the Context API storing the JWT in
    the application. Begin with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Vite React project, install Tailwind, and add Tailwind CSS as it
    simplifies the styling of the application. Please refer to [*Chapter 5*](B22406_05.xhtml#_idTextAnchor090),
    *Setting up a React Workflow*, in order to do so. Also, delete files and folder
    that will not be needed (assets such as `App.css`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create in the `/src` folder a new file and name it `AuthContext.jsx`. The `.jsx`
    extension is a reminder that the context is indeed a React component that will
    wrap all the other components that need access to the context variables, functions,
    objects, or arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code shows the structure of the context creation – you imported
    `createContext` from React and created your first context (`AuthContext`). After
    defining a couple of state variables and setters (for the user, the `jwt` token
    and the message), you returned the `AuthContext` component and the values that
    will be available in the context. The syntax is a bit different from the one used
    for the hooks examined in [*Chapter 4*](B22406_04.xhtml#_idTextAnchor071), *Getting
    Started with FastAPI*, but this is a straightforward template that you will reuse
    many times, should you opt for the Context API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While simple, creating a context involves several steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, you will need to create the actual context that will be shared across
    the application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, the context should be provided to all the components needing access
    to its values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The components that need to access the context values need to subscribe to the
    context in order to be able to read, but also write to it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: So, the first step when creating a context should be defining exactly what type
    of information you need to pass to components. If you think about it, you would
    definitely want the JWT since that is the whole point of this exercise. In order
    to showcase context functionality, you will also include the logged-in user and
    a message that will display the state of the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But since the context can also contain and pass functions—and that’s indeed
    one of its most useful features—you will also add to the context the `register`,
    `login`, and `logout` functions. That may not be something you would do in a production
    system, but it will showcase the capabilities of Context API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, the only thing left to do is add the functions to the context. To do that,
    edit the existing `AuthContext.jsx` file and, after declaring the state variables,
    define the function for registering new users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This simple JavaScript function is part of the context, and the only thing that
    interacts with your context is the setting of the status message—if a user is
    successfully created, the message confirms it. In case of an error, the message
    is set to the error. You will want to provide a more complex validation logic
    and a nicer UI, but this is quite illustrative of the context functioning.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now add the other function related to authentication—the `login()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is similar to the `register` function—it sends a `POST` request
    to the FastAPI `/login` endpoint with the user-provided username and password,
    and it clears any pre-existing JWT in the process. If the request is successful,
    the retrieved token is set to its state variable and the username accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final piece of the puzzle is logging the user out. Since you are dealing
    only with the Context API and not some persistent storage solutions, the code
    is very short; it just needs to clear the context variables and set the appropriate
    message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your `AuthContext` is nearly complete—the only thing left is to inform the
    context that it needs to provide the previously defined functions. So, modify
    the `return` statement to include everything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a final touch, add a `useContext` React hook that facilitates working with
    contexts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This simple one-line hook allows you to now use `AuthContext` in any component
    that has access to the context—so any component wrapped inside `AuthContext`—with
    some simple ES6 destructuring. With your `AuthContext` now in place, you can put
    it directly in the `App.jsx` component and wrap it around all the other components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `App.jsx` file and edit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This root component doesn’t contain anything that you haven’t seen already—apart
    from importing `AuthProvider`—the component of your custom authentication context
    responsible for wrapping the area of components and a bit of Tailwind styles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now comes the part where you will define the components that will be wrapped
    inside the context – as those components will be able to consume the context,
    have access to the context data, and modify it. For a bit more complex application,
    you would likely resort to the React Router package, but since this will be a
    very simple application, you will cram all the components into one page. There
    aren’t many of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`login()` function from the context.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Register**: Similar to the login component, but for registering new users.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message**: The simplest component, used only to display the status of the
    app.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Users**: The component whose state depends on the authentication status:
    if the user is logged in, they can see the list of users, meaning the JWT is present
    and valid; otherwise, the user is prompted to make a login.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Register` component will be used for user registration. It needs to display
    a form. Create the `Register.jsx` file in the `/src` folder and create a simple
    form with two fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have just created a React-specific form with the help of two local state
    variables that take care of keeping track and sending the username and password
    to your FastAPI instance. The `register` function is imported from `AuthContext`
    through the `useAuth()` hook. That line really shows how easy it is to work with
    the context from within the wrapped components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, `handleSubmit` performs the call to the `register` function, clears
    the fields, and prevents the default HTML form behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `Login.jsx` file, which is nearly identical (and here you could
    practice your React skills and perform some refactoring). The component has a
    login form that will be used for logging in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are two components left to be inserted in your simple auth application
    powered by FastAPI and React. First, create the `src/Message.jsx` component, which
    will be used to display the status message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Messages` component reads the message state variable from the context and
    displays it to the users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you can finally create the `src/Users.jsx` component and edit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This component does a bit of heavy lifting compared to the others. It imports
    `jwt` (along with the `logout` function) from the context. This is important since
    the output of the `Users.jsx` component depends entirely on the existence and
    validity of the JWT.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After declaring a local state variable—`users`—the component uses the `useEffect`
    React hook to perform a call to the REST API, and since the `/users/list` endpoint
    is protected, the JWT token needs to be present and valid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the call to the `/users/list` endpoint is successful, the retrieved users
    data is sent to the `users` variable and displayed. Finally, if there is no `jwt`
    in the context, the user is asked to perform a login and the `logout` function
    from the context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, to tie everything together, replace the `App.jsx` file with the following
    code to import the components, and finalize the root component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you’ll be able to test the application—try registering, logging in, entering
    invalid data, and so on. You have created a very simple but complete full stack
    authentication solution. In the next section, you will learn about some methods
    of persisting the login data.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting authentication data with localStorage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, the most developer-friendly option for persisting authentication
    is the use of `localStorage` or `sessionStorage`. `localStorage` becomes very
    useful when it comes to storing temporary, local data. It is widely used for tasks
    such as remembering shopping cart data or user login on any website where security
    is not paramount. `localStorage` has a higher storage limit than cookies (5 MB
    versus 4 KB) and does not get sent with every HTTP request. This makes it a better
    choice for client-side storage.
  prefs: []
  type: TYPE_NORMAL
- en: To use `localStorage`, you can set and get JSON items using the `setItem()`
    and `getItem()` methods, respectively. One important thing to remember is that
    `localStorage` only stores strings, so you will need to use `JSON.stringify()`
    and `JSON.parse()` to convert between JavaScript objects and strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with this knowledge, try to summarize what the app requirements are –
    you want the user to be able to refresh or close and reopen the application window/tab
    and remain logged in if they were logged in, in the first place. Translated into
    React language, you need a `useEffect` hook that will run and verify whether there
    is a token stored in `localStorage`. If it is present, you want to check this
    token through the FastAPI `/me` endpoint and set the username accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the existing `AuthContext.jsx` file, and after the `useState` hook, define
    the `useEffect` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The bulk of your persistence logic is located in the `useEffect` call. First,
    you can try to get the `jwt` token from `localStorage` and then use that token
    to get the user data from the `/me` route. If the username is found, it is set
    in the context and the user is (already) logged in. If not, you clear `localStorage`
    or send a message that the token has expired (in the `Users.jsx` component).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `login()` function also has to be modified in order to take account of
    `localStorage`. In the same `AuthContext.jsx`, modify the `login()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only modification involves setting the new JWT to the `localStorage` `jwt`
    variable. Hence, the `logout()` function will also need to clear `localstorage`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same `AuthContext.jsx` file, modify the `logout` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in order to make your application even more explicit and informative,
    open the `Users.jsx` component and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The app is now able to persist the logged-in user, retrieve the stored JWT,
    and restore the previous authentication state. Before trying to log in, make sure
    that the FastAPI backend is working properly on port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: Try logging in, refreshing the browser, closing the tab, and reopening it.
  prefs: []
  type: TYPE_NORMAL
- en: You can also try this with the token inside the **Application** tab in the developer
    toolbar of Chrome or Firefox and see what happens if you tamper with it or delete
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Other authentication solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to emphasize again that the `localStorage` for instance, but
    keeping in mind the specificities of both solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is important to get acquainted with the various third-party authentication
    options. **Firebase** and **Supabase** are popular database and authentication
    services that can be used solely for managing users and authenticating them. **Clerk**
    and **Kinde** are newer players in the field and are particularly geared toward
    the React/Next.js/Remix.js ecosystem, while **Auth0** and **Cognito** are industry-standard
    solutions. Almost all third-party authentication systems offer a generous free
    or almost-free tier, but once your application grows, you are bound to hit a paid
    tier, and the costs vary and replacing these services, should the need arise,
    is not easy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ve seen a very basic, but quite representative, implementation
    of two versions of an authentication mechanism. You learned how FastAPI enables
    the use of standard-compliant authentication methods and implemented one of the
    simplest possible yet effective solutions – without persisting the authentication
    data and storing the `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how elegant and flexible FastAPI is when it comes to defining
    granular roles and permissions, especially with MongoDB, with the aid of **Pydantic**
    as the middleman. This chapter was focused exclusively on **JWTs** as the means
    of communication because it is the primary and most popular tool in SPAs nowadays,
    and it enables great connectivity between services or microservices. **JWT** mechanisms
    shine when you need to develop different applications with the same FastAPI and
    MongoDB-powered backend—for instance, a React web application and a React Native
    or Flutter-based mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, carefully considering your authentication and authorization strategy
    is crucial, especially when extracting user data from third-party systems may
    not be feasible or practical. This highlights the importance of devising robust
    authentication and authorization methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will create a more complex FastAPI backend, with image
    uploading through a third-party service and use a MongoDB database for persistance.
  prefs: []
  type: TYPE_NORMAL
