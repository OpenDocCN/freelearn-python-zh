<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer150">
   <h1 class="chapterNumber">
    <span class="koboSpan" id="kobo.1.1">
     8
    </span>
   </h1>
   <h1 class="chapterTitle" id="_idParaDest-222">
    <span class="koboSpan" id="kobo.2.1">
     Files and Data Persistence
    </span>
   </h1>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.3.1">
      ”It is not that I’m so smart, it is just that I stay with problems longer.”
     </span>
    </p>
    <p class="cite">
     <span class="koboSpan" id="kobo.4.1">
      – Albert Einstein
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.5.1">
     In the previous chapters, we explored several different aspects of Python.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     As the examples have a didactic purpose, we ran them in a simple Python shell or in the form of a Python module.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     They ran, maybe printed something on the console, and then they terminated, leaving no trace of their brief existence.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.6.1">
     Real-world applications are rather different.
    </span>
    <span class="koboSpan" id="kobo.6.2">
     Naturally, they still run in memory, but they interact with networks, disks, and databases.
    </span>
    <span class="koboSpan" id="kobo.6.3">
     They also exchange information with other applications and devices, using formats that are suitable for the situation.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.7.1">
     In this chapter, we are going to start closing in on the real world by exploring the following:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.8.1">
      Files and directories
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.9.1">
      Compression
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.10.1">
      Networks and streams
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.11.1">
      The JSON data-interchange format
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.12.1">
      Data persistence with
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.13.1">
       pickle
      </span>
     </code>
     <span class="koboSpan" id="kobo.14.1">
      and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.15.1">
       shelve
      </span>
     </code>
     <span class="koboSpan" id="kobo.16.1">
      from the standard library
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.17.1">
      Data persistence with SQLAlchemy
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.18.1">
      Configuration files
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.19.1">
     As usual, we will try to balance breadth and depth so that by the end of the chapter, you will have a solid grasp of the fundamentals and will know how to fetch further information from the web.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-223">
    <span class="koboSpan" id="kobo.20.1">
     Working with files and directories
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.21.1">
     When it
    </span>
    <a id="_idIndexMarker739">
    </a>
    <span class="koboSpan" id="kobo.22.1">
     comes to
    </span>
    <a id="_idIndexMarker740">
    </a>
    <span class="koboSpan" id="kobo.23.1">
     files and directories, Python offers plenty of useful tools.
    </span>
    <span class="koboSpan" id="kobo.23.2">
     In the following examples, we will use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.24.1">
      os
     </span>
    </code>
    <span class="koboSpan" id="kobo.25.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.26.1">
      pathlib
     </span>
    </code>
    <span class="koboSpan" id="kobo.27.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.28.1">
      shutil
     </span>
    </code>
    <span class="koboSpan" id="kobo.29.1">
     modules.
    </span>
    <span class="koboSpan" id="kobo.29.2">
     As we will be reading and writing on the disk, we will be using a file,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.30.1">
      fear.txt
     </span>
    </code>
    <span class="koboSpan" id="kobo.31.1">
     , which contains an excerpt from
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.32.1">
      Fear
     </span>
    </em>
    <span class="koboSpan" id="kobo.33.1">
     , by Thich Nhat Hanh, as a base for some of our examples.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-224">
    <span class="koboSpan" id="kobo.34.1">
     Opening files
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.35.1">
     Opening a
    </span>
    <a id="_idIndexMarker741">
    </a>
    <span class="koboSpan" id="kobo.36.1">
     file in Python is simple and intuitive.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     In fact, we just need to use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.37.1">
      open()
     </span>
    </code>
    <span class="koboSpan" id="kobo.38.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.38.2">
     Let us see a quick example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.39.1"># files/open_try.py</span></span><span class="koboSpan" id="kobo.40.1">
fh = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.41.1">open</span></span><span class="koboSpan" id="kobo.42.1">("fear.txt", "rt")  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.43.1"># r: read, t: text</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.44.1">for</span></span><span class="koboSpan" id="kobo.45.1"> line </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.46.1">in</span></span><span class="koboSpan" id="kobo.47.1"> fh.readlines():
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.48.1">print</span></span><span class="koboSpan" id="kobo.49.1">(line.strip())  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.50.1"># remove whitespace and print</span></span><span class="koboSpan" id="kobo.51.1">
fh.close()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.52.1">
     The previous code is straightforward.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     We call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.53.1">
      open()
     </span>
    </code>
    <span class="koboSpan" id="kobo.54.1">
     , passing the filename, and telling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.55.1">
      open()
     </span>
    </code>
    <span class="koboSpan" id="kobo.56.1">
     that we want to read it in text mode (via the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.57.1">
      "rt"
     </span>
    </code>
    <span class="koboSpan" id="kobo.58.1">
     flag).
    </span>
    <span class="koboSpan" id="kobo.58.2">
     There is no path information before the filename; therefore,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.59.1">
      open()
     </span>
    </code>
    <span class="koboSpan" id="kobo.60.1">
     will assume the file is in the same folder the script is run from.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     This means that if we run this script from outside the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.61.1">
      files
     </span>
    </code>
    <span class="koboSpan" id="kobo.62.1">
     folder, then
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.63.1">
      fear.txt
     </span>
    </code>
    <span class="koboSpan" id="kobo.64.1">
     will not be found.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.65.1">
     Once the file has been opened, we obtain a file object,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.66.1">
      fh
     </span>
    </code>
    <span class="koboSpan" id="kobo.67.1">
     , which we can use to work on the content of the file.
    </span>
    <span class="koboSpan" id="kobo.67.2">
     We chose that name because, in Python, a file object is essentially a high-level abstraction that wraps the underlying file handle (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.68.1">
      fh
     </span>
    </code>
    <span class="koboSpan" id="kobo.69.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.69.2">
     In this case, we use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.70.1">
      readlines()
     </span>
    </code>
    <span class="koboSpan" id="kobo.71.1">
     method to iterate over all the lines in the file and print them.
    </span>
    <span class="koboSpan" id="kobo.71.2">
     We call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.72.1">
      strip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.73.1">
     on each line to get rid of any extra spaces around the content, including the line termination character at the end, since
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.74.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.75.1">
     will already add one for us.
    </span>
    <span class="koboSpan" id="kobo.75.2">
     This is a quick and dirty solution that works in this example but should the content of the file contain meaningful spaces that need to be preserved, you will have to be slightly more careful in how you sanitize the data.
    </span>
    <span class="koboSpan" id="kobo.75.3">
     At the end of the script, we close the stream.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.76.1">
     Closing a file is important as we do not want to risk failing to release the handle (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.77.1">
      fh
     </span>
    </code>
    <span class="koboSpan" id="kobo.78.1">
     ) we have on it.
    </span>
    <span class="koboSpan" id="kobo.78.2">
     When that happens, you can encounter issues such as memory leaks, or the annoying
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.79.1">
      “you cannot delete this file”
     </span>
    </em>
    <span class="koboSpan" id="kobo.80.1">
     pop-up that informs you that some software is still using it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.81.1">
     Therefore, we
    </span>
    <a id="_idIndexMarker742">
    </a>
    <span class="koboSpan" id="kobo.82.1">
     need to apply some precautions and wrap the previous logic in a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.83.1">
      try/finally
     </span>
    </code>
    <span class="koboSpan" id="kobo.84.1">
     block.
    </span>
    <span class="koboSpan" id="kobo.84.2">
     This means that, whatever error might occur when we try to open and read the file, we can rest assured that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.85.1">
      close()
     </span>
    </code>
    <span class="koboSpan" id="kobo.86.1">
     will be called:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.87.1"># files/open_try.py</span></span><span class="koboSpan" id="kobo.88.1">
fh = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.89.1">open</span></span><span class="koboSpan" id="kobo.90.1">("fear.txt", "rt")
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.91.1">try</span></span><span class="koboSpan" id="kobo.92.1">:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.93.1">for</span></span><span class="koboSpan" id="kobo.94.1"> line </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.95.1">in</span></span><span class="koboSpan" id="kobo.96.1"> fh.readlines():
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.97.1">print</span></span><span class="koboSpan" id="kobo.98.1">(line.strip())
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.99.1">finally</span></span><span class="koboSpan" id="kobo.100.1">:
    fh.close()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.101.1">
     The logic is the same, but now it is also safe.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.102.1">
      If you are not familiar with the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.103.1">
       try
      </span>
     </code>
     <span class="koboSpan" id="kobo.104.1">
      /
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.105.1">
       finally
      </span>
     </code>
     <span class="koboSpan" id="kobo.106.1">
      block, make sure you go back to the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.107.1">
       Handling Exceptions
      </span>
     </em>
     <span class="koboSpan" id="kobo.108.1">
      section of
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.109.1">
       Chapter 7
      </span>
     </em>
     <span class="koboSpan" id="kobo.110.1">
      ,
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.111.1">
       Exceptions and Context Managers
      </span>
     </em>
     <span class="koboSpan" id="kobo.112.1">
      , and study it.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.113.1">
     We can simplify the previous example further like this:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.114.1"># files/open_try.py</span></span><span class="koboSpan" id="kobo.115.1">
fh = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.116.1">open</span></span><span class="koboSpan" id="kobo.117.1">("fear.txt")  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.118.1"># rt is default</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.119.1">try</span></span><span class="koboSpan" id="kobo.120.1">:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.121.1">for</span></span><span class="koboSpan" id="kobo.122.1"> line </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.123.1">in</span></span><span class="koboSpan" id="kobo.124.1"> fh:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.125.1"># we can iterate directly on fh</span></span>
        <span class="hljs-built_in"><span class="koboSpan" id="kobo.126.1">print</span></span><span class="koboSpan" id="kobo.127.1">(line.strip())
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.128.1">finally</span></span><span class="koboSpan" id="kobo.129.1">:
    fh.close()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.130.1">
     The default mode for opening files is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.131.1">
      "rt"
     </span>
    </code>
    <span class="koboSpan" id="kobo.132.1">
     , so we do not need to specify it.
    </span>
    <span class="koboSpan" id="kobo.132.2">
     Moreover, we can simply iterate on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.133.1">
      fh
     </span>
    </code>
    <span class="koboSpan" id="kobo.134.1">
     without explicitly calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.135.1">
      readlines()
     </span>
    </code>
    <span class="koboSpan" id="kobo.136.1">
     on it.
    </span>
    <span class="koboSpan" id="kobo.136.2">
     Python often gives us shorthands to make our code more compact and simpler to read.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.137.1">
     All the previous examples produce a print of the file on the console (check out the source code to read the whole content):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.138.1">An excerpt from Fear - By Thich Nhat Hanh
The Present Is Free from Fear
When we are not fully present, we are not really living. </span><span class="koboSpan" id="kobo.138.2">We are not
really there, either for our loved ones or for ourselves. </span><span class="koboSpan" id="kobo.138.3">If we are
not there, then where are we? </span><span class="koboSpan" id="kobo.138.4">We are running, running, running,
even during our sleep. </span><span class="koboSpan" id="kobo.138.5">We run because we are trying to escape from
our fear. </span><span class="koboSpan" id="kobo.138.6">[…]
</span></code></pre>
   <h3 class="heading-3" id="_idParaDest-225">
    <span class="koboSpan" id="kobo.139.1">
     Using a context manager to open a file
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.140.1">
     To avoid
    </span>
    <a id="_idIndexMarker743">
    </a>
    <span class="koboSpan" id="kobo.141.1">
     having to use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.142.1">
      try
     </span>
    </code>
    <span class="koboSpan" id="kobo.143.1">
     /
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.144.1">
      finally
     </span>
    </code>
    <span class="koboSpan" id="kobo.145.1">
     blocks throughout our
    </span>
    <a id="_idIndexMarker744">
    </a>
    <span class="koboSpan" id="kobo.146.1">
     code, Python gives us a nicer and equally safe way to do it: by using a context manager.
    </span>
    <span class="koboSpan" id="kobo.146.2">
     Let us see the code first:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.147.1"># files/open_with.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.148.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.149.1">open</span></span><span class="koboSpan" id="kobo.150.1">("fear.txt") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.151.1">as</span></span><span class="koboSpan" id="kobo.152.1"> fh:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.153.1">for</span></span><span class="koboSpan" id="kobo.154.1"> line </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.155.1">in</span></span><span class="koboSpan" id="kobo.156.1"> fh:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.157.1">print</span></span><span class="koboSpan" id="kobo.158.1">(line.strip())
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.159.1">
     This example is equivalent to the previous one but reads better.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.160.1">
      open()
     </span>
    </code>
    <span class="koboSpan" id="kobo.161.1">
     function returns a file object when invoked by a context manager, and it conveniently calls
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.162.1">
      fh.close()
     </span>
    </code>
    <span class="koboSpan" id="kobo.163.1">
     automatically when execution exits the context manager scope.
    </span>
    <span class="koboSpan" id="kobo.163.2">
     This will happen even in the case of errors.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-226">
    <span class="koboSpan" id="kobo.164.1">
     Reading from and writing to a file
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.165.1">
     Now that we
    </span>
    <a id="_idIndexMarker745">
    </a>
    <span class="koboSpan" id="kobo.166.1">
     know how to open a file, let us see how to read from and write to it:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.167.1"># files/print_file.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.168.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.169.1">open</span></span><span class="koboSpan" id="kobo.170.1">("print_example.txt", "w") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.171.1">as</span></span><span class="koboSpan" id="kobo.172.1"> fw:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.173.1">print</span></span><span class="koboSpan" id="kobo.174.1">("Hey I am printing into a file!!!", file=fw)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.175.1">
     This first approach
    </span>
    <a id="_idIndexMarker746">
    </a>
    <span class="koboSpan" id="kobo.176.1">
     uses the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.177.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.178.1">
     function, with which we are already familiar from previous chapters.
    </span>
    <span class="koboSpan" id="kobo.178.2">
     After obtaining a file object, this time specifying that we intend to write to it (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.179.1">
      "w"
     </span>
    </code>
    <span class="koboSpan" id="kobo.180.1">
     ), we can tell the call to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.181.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.182.1">
     to direct its output to the file, instead of to
    </span>
    <a id="_idIndexMarker747">
    </a>
    <span class="koboSpan" id="kobo.183.1">
     the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.184.1">
      standard output
     </span>
    </strong>
    <span class="koboSpan" id="kobo.185.1">
     stream as it normally does.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.186.1">
      In Python, the standard input, output, and error streams are represented by the file objects
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.187.1">
       sys.stdin
      </span>
     </code>
     <span class="koboSpan" id="kobo.188.1">
      ,
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.189.1">
       sys.stdout
      </span>
     </code>
     <span class="koboSpan" id="kobo.190.1">
      , and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.191.1">
       sys.stderr
      </span>
     </code>
     <span class="koboSpan" id="kobo.192.1">
      .
     </span>
     <span class="koboSpan" id="kobo.192.2">
      Unless input or output is redirected, reading from
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.193.1">
       sys.stdin
      </span>
     </code>
     <span class="koboSpan" id="kobo.194.1">
      usually corresponds to reading from the keyboard, and writing to
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.195.1">
       sys.stdout
      </span>
     </code>
     <span class="koboSpan" id="kobo.196.1">
      or
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.197.1">
       sys.stderr
      </span>
     </code>
     <span class="koboSpan" id="kobo.198.1">
      usually prints to the console screen.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.199.1">
     The previous
    </span>
    <a id="_idIndexMarker748">
    </a>
    <span class="koboSpan" id="kobo.200.1">
     code creates the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.201.1">
      print_example.txt
     </span>
    </code>
    <span class="koboSpan" id="kobo.202.1">
     file if it does not exist, or truncates
    </span>
    <a id="_idIndexMarker749">
    </a>
    <span class="koboSpan" id="kobo.203.1">
     it if it does, and writes the line
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.204.1">
      Hey I am printing into a file!!!
     </span>
    </code>
    <span class="koboSpan" id="kobo.205.1">
     into it.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.206.1">
      Truncating a file means erasing its contents without deleting it.
     </span>
     <span class="koboSpan" id="kobo.206.2">
      After truncation, the file still exists on the filesystem, but it is empty.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.207.1">
     This example does the job, but it is not what we would typically do when writing to a file.
    </span>
    <span class="koboSpan" id="kobo.207.2">
     Let us see a more common approach:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.208.1"># files/read_write.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.209.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.210.1">open</span></span><span class="koboSpan" id="kobo.211.1">("fear.txt") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.212.1">as</span></span><span class="koboSpan" id="kobo.213.1"> f:
    lines = [line.rstrip() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.214.1">for</span></span><span class="koboSpan" id="kobo.215.1"> line </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.216.1">in</span></span><span class="koboSpan" id="kobo.217.1"> f]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.218.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.219.1">open</span></span><span class="koboSpan" id="kobo.220.1">("fear_copy.txt", "w") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.221.1">as</span></span><span class="koboSpan" id="kobo.222.1"> fw:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.223.1"># w - write</span></span><span class="koboSpan" id="kobo.224.1">
    fw.write("\n".join(lines))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.225.1">
     In this example, we first open
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.226.1">
      fear.txt
     </span>
    </code>
    <span class="koboSpan" id="kobo.227.1">
     and gather its content into a list, line by line.
    </span>
    <span class="koboSpan" id="kobo.227.2">
     Notice that, this time, we are calling a different method,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.228.1">
      rstrip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.229.1">
     , as an example, to make sure we only strip the whitespace on the right-hand side of every line.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.230.1">
     In the second part of the snippet, we create a new file,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.231.1">
      fear_copy.txt
     </span>
    </code>
    <span class="koboSpan" id="kobo.232.1">
     , and we write to it all the strings in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.233.1">
      lines
     </span>
    </code>
    <span class="koboSpan" id="kobo.234.1">
     , joined by a newline,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.235.1">
      \n
     </span>
    </code>
    <span class="koboSpan" id="kobo.236.1">
     .
    </span>
    <span class="koboSpan" id="kobo.236.2">
     Python works by default with
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.237.1">
      universal newlines
     </span>
    </strong>
    <span class="koboSpan" id="kobo.238.1">
     , which
    </span>
    <a id="_idIndexMarker750">
    </a>
    <span class="koboSpan" id="kobo.239.1">
     means that even though the original file might have a newline that is different from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.240.1">
      \n
     </span>
    </code>
    <span class="koboSpan" id="kobo.241.1">
     , it will be translated automatically for us before the line is returned.
    </span>
    <span class="koboSpan" id="kobo.241.2">
     This behavior is, of course, customizable, but normally it is exactly what we want.
    </span>
    <span class="koboSpan" id="kobo.241.3">
     Speaking of newlines, can you think of one that might be missing in the copy?
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-227">
    <span class="koboSpan" id="kobo.242.1">
     Reading and writing in binary mode
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.243.1">
     Notice
    </span>
    <a id="_idIndexMarker751">
    </a>
    <span class="koboSpan" id="kobo.244.1">
     that by
    </span>
    <a id="_idIndexMarker752">
    </a>
    <span class="koboSpan" id="kobo.245.1">
     opening a file and passing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.246.1">
      t
     </span>
    </code>
    <span class="koboSpan" id="kobo.247.1">
     in the options (or omitting it, as it is the default), we are opening the file in text mode.
    </span>
    <span class="koboSpan" id="kobo.247.2">
     This means that the content of the file is treated and interpreted as text.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.248.1">
     If you wish to write bytes to a file, you can
    </span>
    <a id="_idIndexMarker753">
    </a>
    <span class="koboSpan" id="kobo.249.1">
     open it in
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.250.1">
      binary mode
     </span>
    </strong>
    <span class="koboSpan" id="kobo.251.1">
     .
    </span>
    <span class="koboSpan" id="kobo.251.2">
     This is a common requirement when you handle files that do not just contain raw text, such as images, audio/video, and, in general, any other proprietary format.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.252.1">
     To
    </span>
    <a id="_idIndexMarker754">
    </a>
    <span class="koboSpan" id="kobo.253.1">
     handle files in binary mode, simply specify the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.254.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.255.1">
     flag when
    </span>
    <a id="_idIndexMarker755">
    </a>
    <span class="koboSpan" id="kobo.256.1">
     opening them, as in the following example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.257.1"># files/read_write_bin.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.258.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.259.1">open</span></span><span class="koboSpan" id="kobo.260.1">("example.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.261.1">bin</span></span><span class="koboSpan" id="kobo.262.1">", "wb") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.263.1">as</span></span><span class="koboSpan" id="kobo.264.1"> fw:
    fw.write(b"This </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.265.1">is</span></span><span class="koboSpan" id="kobo.266.1"> binary data...")
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.267.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.268.1">open</span></span><span class="koboSpan" id="kobo.269.1">("example.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.270.1">bin</span></span><span class="koboSpan" id="kobo.271.1">", "rb") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.272.1">as</span></span><span class="koboSpan" id="kobo.273.1"> f:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.274.1">print</span></span><span class="koboSpan" id="kobo.275.1">(f.read())  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.276.1"># prints: b'This is binary data...'</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.277.1">
     In this example, we are still using text as binary data, for simplicity, but it could be anything you want.
    </span>
    <span class="koboSpan" id="kobo.277.2">
     You can see it is treated as binary by the fact that you get the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.278.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.279.1">
     prefix in the output string.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-228">
    <span class="koboSpan" id="kobo.280.1">
     Protecting against overwriting an existing file
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.281.1">
     As we have seen, Python
    </span>
    <a id="_idIndexMarker756">
    </a>
    <span class="koboSpan" id="kobo.282.1">
     gives us the ability to open files for writing.
    </span>
    <span class="koboSpan" id="kobo.282.2">
     By using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.283.1">
      w
     </span>
    </code>
    <span class="koboSpan" id="kobo.284.1">
     flag, we open a file and truncate its content.
    </span>
    <span class="koboSpan" id="kobo.284.2">
     This means the file is overwritten with an empty file, and the original content is lost.
    </span>
    <span class="koboSpan" id="kobo.284.3">
     If you wish to only open a file for writing if it does not already exist, you can use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.285.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.286.1">
     flag instead, as in the following example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.287.1"># files/write_not_exists.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.288.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.289.1">open</span></span><span class="koboSpan" id="kobo.290.1">("write_x.txt", "x") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.291.1">as</span></span><span class="koboSpan" id="kobo.292.1"> fw:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.293.1"># this succeeds</span></span><span class="koboSpan" id="kobo.294.1">
    fw.write("Writing line </span><span class="hljs-number"><span class="koboSpan" id="kobo.295.1">1</span></span><span class="koboSpan" id="kobo.296.1">")
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.297.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.298.1">open</span></span><span class="koboSpan" id="kobo.299.1">("write_x.txt", "x") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.300.1">as</span></span><span class="koboSpan" id="kobo.301.1"> fw:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.302.1"># this fails</span></span><span class="koboSpan" id="kobo.303.1">
    fw.write("Writing line </span><span class="hljs-number"><span class="koboSpan" id="kobo.304.1">2</span></span><span class="koboSpan" id="kobo.305.1">")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.306.1">
     If you run this snippet, you will find a file called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.307.1">
      write_x.txt
     </span>
    </code>
    <span class="koboSpan" id="kobo.308.1">
     in your directory, containing only one line of text.
    </span>
    <span class="koboSpan" id="kobo.308.2">
     The second part of the snippet, in fact, fails to execute.
    </span>
    <span class="koboSpan" id="kobo.308.3">
     This is the output we get on our console (the file path has been shortened for editorial purposes):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.309.1">$ python write_not_exists.py
Traceback (most recent call last):
  File "write_not_exists.py", line 6, in &lt;module&gt;
    with open("write_x.txt", "x") as fw:  # this fails
         ^^^^^^^^^^^^^^^^^^^^^^^^
FileExistsError: [Errno 17] File exists: 'write_x.txt'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.310.1">
     As we have
    </span>
    <a id="_idIndexMarker757">
    </a>
    <span class="koboSpan" id="kobo.311.1">
     seen, there are different modes for opening a file.
    </span>
    <span class="koboSpan" id="kobo.311.2">
     You can find the full list of flags at
    </span>
    <a href="https://docs.python.org/3/library/functions.html#open">
     <span class="url">
      <span class="koboSpan" id="kobo.312.1">
       https://docs.python.org/3/library/functions.html#open
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.313.1">
     .
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-229">
    <span class="koboSpan" id="kobo.314.1">
     Checking for file and directory existence
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.315.1">
     If you
    </span>
    <a id="_idIndexMarker758">
    </a>
    <span class="koboSpan" id="kobo.316.1">
     want to make sure a file or directory exists (or does not), the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.317.1">
      pathlib
     </span>
    </code>
    <span class="koboSpan" id="kobo.318.1">
     module
    </span>
    <a id="_idIndexMarker759">
    </a>
    <span class="koboSpan" id="kobo.319.1">
     is what you need.
    </span>
    <span class="koboSpan" id="kobo.319.2">
     Let us see a small example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.320.1"># files/existence.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.321.1">from</span></span><span class="koboSpan" id="kobo.322.1"> pathlib </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.323.1">import</span></span><span class="koboSpan" id="kobo.324.1"> Path
p = Path("fear.txt")
path = p.parent.absolute()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.325.1">print</span></span><span class="koboSpan" id="kobo.326.1">(p.is_file())  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.327.1"># True</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.328.1">print</span></span><span class="koboSpan" id="kobo.329.1">(path)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.330.1"># /Users/fab/code/lpp4ed/ch08/files</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.331.1">print</span></span><span class="koboSpan" id="kobo.332.1">(path.is_dir())  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.333.1"># True</span></span><span class="koboSpan" id="kobo.334.1">
q = Path("/Users/fab/code/lpp4ed/ch08/files")
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.335.1">print</span></span><span class="koboSpan" id="kobo.336.1">(q.is_dir())  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.337.1"># True</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.338.1">
     In the preceding snippet, we create a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.339.1">
      Path
     </span>
    </code>
    <span class="koboSpan" id="kobo.340.1">
     object that we set up with the name of the text file we want to inspect.
    </span>
    <span class="koboSpan" id="kobo.340.2">
     We use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.341.1">
      parent()
     </span>
    </code>
    <span class="koboSpan" id="kobo.342.1">
     method to retrieve the folder in which the file is contained, and we call the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.343.1">
      absolute()
     </span>
    </code>
    <span class="koboSpan" id="kobo.344.1">
     method on it to extract the absolute path information.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.345.1">
     We check if
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.346.1">
      "fear.txt"
     </span>
    </code>
    <span class="koboSpan" id="kobo.347.1">
     is a file and the folder in which it is contained is indeed a folder (or directory, which is equivalent).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.348.1">
     The old way to do these operations was to use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.349.1">
      os.path
     </span>
    </code>
    <span class="koboSpan" id="kobo.350.1">
     module from the standard library.
    </span>
    <span class="koboSpan" id="kobo.350.2">
     While
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.351.1">
      os.path
     </span>
    </code>
    <span class="koboSpan" id="kobo.352.1">
     works on strings,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.353.1">
      pathlib
     </span>
    </code>
    <span class="koboSpan" id="kobo.354.1">
     offers classes representing filesystem paths with semantics appropriate for different operating systems.
    </span>
    <span class="koboSpan" id="kobo.354.2">
     Hence, we suggest using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.355.1">
      pathlib
     </span>
    </code>
    <span class="koboSpan" id="kobo.356.1">
     whenever possible, and reverting to the old way of doing things only when there is no alternative.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-230">
    <span class="koboSpan" id="kobo.357.1">
     Manipulating files and directories
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.358.1">
     Let us see a
    </span>
    <a id="_idIndexMarker760">
    </a>
    <span class="koboSpan" id="kobo.359.1">
     couple of quick examples of how to manipulate files and
    </span>
    <a id="_idIndexMarker761">
    </a>
    <span class="koboSpan" id="kobo.360.1">
     directories.
    </span>
    <span class="koboSpan" id="kobo.360.2">
     The first example manipulates the content:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.361.1"># files/manipulation.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.362.1">from</span></span><span class="koboSpan" id="kobo.363.1"> collections </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.364.1">import</span></span><span class="koboSpan" id="kobo.365.1"> Counter
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.366.1">from</span></span><span class="koboSpan" id="kobo.367.1"> string </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.368.1">import</span></span><span class="koboSpan" id="kobo.369.1"> ascii_letters
chars = ascii_letters + " "
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.370.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.371.1">sanitize</span></span><span class="koboSpan" id="kobo.372.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.373.1">s, chars</span></span><span class="koboSpan" id="kobo.374.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.375.1">return</span></span><span class="koboSpan" id="kobo.376.1"> "".join(c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.377.1">for</span></span><span class="koboSpan" id="kobo.378.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.379.1">in</span></span><span class="koboSpan" id="kobo.380.1"> s </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.381.1">if</span></span><span class="koboSpan" id="kobo.382.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.383.1">in</span></span><span class="koboSpan" id="kobo.384.1"> chars)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.385.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.386.1">reverse</span></span><span class="koboSpan" id="kobo.387.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.388.1">s</span></span><span class="koboSpan" id="kobo.389.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.390.1">return</span></span><span class="koboSpan" id="kobo.391.1"> s[::-</span><span class="hljs-number"><span class="koboSpan" id="kobo.392.1">1</span></span><span class="koboSpan" id="kobo.393.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.394.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.395.1">open</span></span><span class="koboSpan" id="kobo.396.1">("fear.txt") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.397.1">as</span></span><span class="koboSpan" id="kobo.398.1"> stream:
    lines = [line.rstrip() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.399.1">for</span></span><span class="koboSpan" id="kobo.400.1"> line </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.401.1">in</span></span><span class="koboSpan" id="kobo.402.1"> stream]
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.403.1"># let us write the mirrored version of the file</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.404.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.405.1">open</span></span><span class="koboSpan" id="kobo.406.1">("raef.txt", "w") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.407.1">as</span></span><span class="koboSpan" id="kobo.408.1"> stream:
    stream.write("\n".join(reverse(line) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.409.1">for</span></span><span class="koboSpan" id="kobo.410.1"> line </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.411.1">in</span></span><span class="koboSpan" id="kobo.412.1"> lines))
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.413.1"># now we can calculate some statistics</span></span><span class="koboSpan" id="kobo.414.1">
lines = [sanitize(line, chars) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.415.1">for</span></span><span class="koboSpan" id="kobo.416.1"> line </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.417.1">in</span></span><span class="koboSpan" id="kobo.418.1"> lines]
whole = " ".join(lines)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.419.1"># we perform comparisons on the lowercased version of `whole`</span></span><span class="koboSpan" id="kobo.420.1">
cnt = Counter(whole.lower().split())
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.421.1"># we can print the N most common words</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.422.1">print</span></span><span class="koboSpan" id="kobo.423.1">(cnt.most_common(</span><span class="hljs-number"><span class="koboSpan" id="kobo.424.1">3</span></span><span class="koboSpan" id="kobo.425.1">)) </span><span class="hljs-comment"><span class="koboSpan" id="kobo.426.1"># [('we', 17), ('the', 13), ('were', 7)]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.427.1">
     This example defines two functions:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.428.1">
      sanitize()
     </span>
    </code>
    <span class="koboSpan" id="kobo.429.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.430.1">
      reverse()
     </span>
    </code>
    <span class="koboSpan" id="kobo.431.1">
     .
    </span>
    <span class="koboSpan" id="kobo.431.2">
     They are simple functions whose purpose is to remove anything that is not a letter or space from a string and produce the reversed copy of a string, respectively.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.432.1">
     We open
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.433.1">
      fear.txt
     </span>
    </code>
    <span class="koboSpan" id="kobo.434.1">
     and we read its content into a list.
    </span>
    <span class="koboSpan" id="kobo.434.2">
     Then we create a new file,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.435.1">
      raef.txt
     </span>
    </code>
    <span class="koboSpan" id="kobo.436.1">
     , which will contain the horizontally mirrored version of the original.
    </span>
    <span class="koboSpan" id="kobo.436.2">
     We write all the content of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.437.1">
      lines
     </span>
    </code>
    <span class="koboSpan" id="kobo.438.1">
     with a single operation, using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.439.1">
      join
     </span>
    </code>
    <span class="koboSpan" id="kobo.440.1">
     on a newline character.
    </span>
    <span class="koboSpan" id="kobo.440.2">
     Maybe more interesting is the bit at the end.
    </span>
    <span class="koboSpan" id="kobo.440.3">
     First, we reassign
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.441.1">
      lines
     </span>
    </code>
    <span class="koboSpan" id="kobo.442.1">
     to a sanitized version of itself by means of a list comprehension.
    </span>
    <span class="koboSpan" id="kobo.442.2">
     Then we put the lines together in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.443.1">
      whole
     </span>
    </code>
    <span class="koboSpan" id="kobo.444.1">
     string, and
    </span>
    <a id="_idIndexMarker762">
    </a>
    <span class="koboSpan" id="kobo.445.1">
     finally, we pass the result to a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.446.1">
      Counter
     </span>
    </code>
    <span class="koboSpan" id="kobo.447.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.447.2">
     Notice that we split the lowercase version of the string into a list of words.
    </span>
    <span class="koboSpan" id="kobo.447.3">
     This way, each word will be counted correctly, regardless of its case, and, thanks to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.448.1">
      split()
     </span>
    </code>
    <span class="koboSpan" id="kobo.449.1">
     , we don’t need to worry about extra spaces
    </span>
    <a id="_idIndexMarker763">
    </a>
    <span class="koboSpan" id="kobo.450.1">
     anywhere.
    </span>
    <span class="koboSpan" id="kobo.450.2">
     When we print the three most common words, we realize that, truly, Thich Nhat Hanh’s focus was on others, as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.451.1">
      “we”
     </span>
    </em>
    <span class="koboSpan" id="kobo.452.1">
     is the most common word in the text:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.453.1">$ python manipulation.py
[('we', 17), ('the', 13), ('were', 7)]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.454.1">
     Let us now see an example of manipulation that’s more related to disk operations, in which we put the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.455.1">
      shutil
     </span>
    </code>
    <span class="koboSpan" id="kobo.456.1">
     module to use:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.457.1"># files/ops_create.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.458.1">import</span></span><span class="koboSpan" id="kobo.459.1"> shutil
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.460.1">from</span></span><span class="koboSpan" id="kobo.461.1"> pathlib </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.462.1">import</span></span><span class="koboSpan" id="kobo.463.1"> Path
base_path = Path("ops_example")
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.464.1"># let us perform an initial cleanup just in case</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.465.1">if</span></span><span class="koboSpan" id="kobo.466.1"> base_path.exists() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.467.1">and</span></span><span class="koboSpan" id="kobo.468.1"> base_path.is_dir():
    shutil.rmtree(base_path)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.469.1"># now we create the directory</span></span><span class="koboSpan" id="kobo.470.1">
base_path.mkdir()
path_b = base_path / "A" / "B"
path_c = base_path / "A" / "C"
path_d = base_path / "A" / "D"
path_b.mkdir(parents=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.471.1">True</span></span><span class="koboSpan" id="kobo.472.1">)
path_c.mkdir()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.473.1"># no need for parents now, as 'A' has been created</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.474.1"># we add three files in `ops_example/A/B`</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.475.1">for</span></span><span class="koboSpan" id="kobo.476.1"> filename </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.477.1">in</span></span><span class="koboSpan" id="kobo.478.1"> ("ex1.txt", "ex2.txt", "ex3.txt"):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.479.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.480.1">open</span></span><span class="koboSpan" id="kobo.481.1">(path_b / filename, "w") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.482.1">as</span></span><span class="koboSpan" id="kobo.483.1"> stream:
        stream.write(f"Some content here </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.484.1">in</span></span><span class="koboSpan" id="kobo.485.1"> {filename}\n")
shutil.move(path_b, path_d)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.486.1"># we can also rename files</span></span><span class="koboSpan" id="kobo.487.1">
ex1 = path_d / "ex1.txt"
ex1.rename(ex1.parent / "ex1.renamed.txt")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.488.1">
     In the
    </span>
    <a id="_idIndexMarker764">
    </a>
    <span class="koboSpan" id="kobo.489.1">
     preceding code, we start by declaring a base path, which will contain all the files and folders we are going to create.
    </span>
    <span class="koboSpan" id="kobo.489.2">
     We then use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.490.1">
      mkdir()
     </span>
    </code>
    <span class="koboSpan" id="kobo.491.1">
     to create two directories:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.492.1">
      ops_example/A/B
     </span>
    </code>
    <span class="koboSpan" id="kobo.493.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.494.1">
      ops_example/A/C
     </span>
    </code>
    <span class="koboSpan" id="kobo.495.1">
     .
    </span>
    <span class="koboSpan" id="kobo.495.2">
     Notice that we don’t need to specify
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.496.1">
      parents=True
     </span>
    </code>
    <span class="koboSpan" id="kobo.497.1">
     when calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.498.1">
      path_c.mkdir()
     </span>
    </code>
    <span class="koboSpan" id="kobo.499.1">
     , since all the parents have already been created by the previous call on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.500.1">
      path_b
     </span>
    </code>
    <span class="koboSpan" id="kobo.501.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.502.1">
     We
    </span>
    <a id="_idIndexMarker765">
    </a>
    <span class="koboSpan" id="kobo.503.1">
     use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.504.1">
      /
     </span>
    </code>
    <span class="koboSpan" id="kobo.505.1">
     operator to concatenate directory names;
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.506.1">
      pathlib
     </span>
    </code>
    <span class="koboSpan" id="kobo.507.1">
     takes care of using the right path separator for us, behind the scenes.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.508.1">
     After creating the directories, we loop to create three files in directory
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.509.1">
      B
     </span>
    </code>
    <span class="koboSpan" id="kobo.510.1">
     .
    </span>
    <span class="koboSpan" id="kobo.510.2">
     Then, we move directory
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.511.1">
      B
     </span>
    </code>
    <span class="koboSpan" id="kobo.512.1">
     and its contents to a different name:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.513.1">
      D
     </span>
    </code>
    <span class="koboSpan" id="kobo.514.1">
     .
    </span>
    <span class="koboSpan" id="kobo.514.2">
     We also could have done this in another way:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.515.1">
      path_b.rename(path_d)
     </span>
    </code>
    <span class="koboSpan" id="kobo.516.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.517.1">
     Finally, we rename
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.518.1">
      ex1.txt
     </span>
    </code>
    <span class="koboSpan" id="kobo.519.1">
     to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.520.1">
      ex1.renamed.txt
     </span>
    </code>
    <span class="koboSpan" id="kobo.521.1">
     .
    </span>
    <span class="koboSpan" id="kobo.521.2">
     If you open that file, you will see it still contains the original text from the loop logic.
    </span>
    <span class="koboSpan" id="kobo.521.3">
     Calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.522.1">
      tree
     </span>
    </code>
    <span class="koboSpan" id="kobo.523.1">
     on the result produces the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.524.1">$ tree ops_example
ops_example
└── A
    ├── C
    └── D
        ├── ex1.renamed.txt
        ├── ex2.txt
        └── ex3.txt
</span></code></pre>
   <h3 class="heading-3" id="_idParaDest-231">
    <span class="koboSpan" id="kobo.525.1">
     Manipulating pathnames
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.526.1">
     Let us
    </span>
    <a id="_idIndexMarker766">
    </a>
    <span class="koboSpan" id="kobo.527.1">
     explore the abilities of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.528.1">
      pathlib
     </span>
    </code>
    <span class="koboSpan" id="kobo.529.1">
     a little more by means of an
    </span>
    <a id="_idIndexMarker767">
    </a>
    <span class="koboSpan" id="kobo.530.1">
     example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.531.1"># files/paths.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.532.1">from</span></span><span class="koboSpan" id="kobo.533.1"> pathlib </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.534.1">import</span></span><span class="koboSpan" id="kobo.535.1"> Path
p = Path("fear.txt")
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.536.1">print</span></span><span class="koboSpan" id="kobo.537.1">(p.absolute())
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.538.1">print</span></span><span class="koboSpan" id="kobo.539.1">(p.name)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.540.1">print</span></span><span class="koboSpan" id="kobo.541.1">(p.parent.absolute())
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.542.1">print</span></span><span class="koboSpan" id="kobo.543.1">(p.suffix)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.544.1">print</span></span><span class="koboSpan" id="kobo.545.1">(p.parts)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.546.1">print</span></span><span class="koboSpan" id="kobo.547.1">(p.absolute().parts)
readme_path = p.parent / ".." </span><span class="koboSpan" id="kobo.547.2">/ ".." </span><span class="koboSpan" id="kobo.547.3">/ "README.rst"
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.548.1">print</span></span><span class="koboSpan" id="kobo.549.1">(readme_path.absolute())
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.550.1">print</span></span><span class="koboSpan" id="kobo.551.1">(readme_path.resolve())
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.552.1">
     Reading the
    </span>
    <a id="_idIndexMarker768">
    </a>
    <span class="koboSpan" id="kobo.553.1">
     result is probably a good enough explanation for this simple example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.554.1">$ python paths.py
/Users/fab/code/lpp4ed/ch08/files/fear.txt
fear.txt
/Users/fab/code/lpp4ed/ch08/files
.txt
('fear.txt',)
(
    '/', 'Users', 'fab', 'code', 'lpp4ed',
    'ch08', 'files', 'fear.txt'
)
/Users/fab/code/lpp4ed/ch08/files/../../README.rst
/Users/fab/code/lpp4ed/README.rst
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.555.1">
     Note how, in
    </span>
    <a id="_idIndexMarker769">
    </a>
    <span class="koboSpan" id="kobo.556.1">
     the last two lines, we have two different representations of the same path.
    </span>
    <span class="koboSpan" id="kobo.556.2">
     The first one (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.557.1">
      readme_path.absolute()
     </span>
    </code>
    <span class="koboSpan" id="kobo.558.1">
     ) shows two
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.559.1">
      "
     </span>
    </code>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.560.1">
      .."
     </span>
    </code>
    <span class="koboSpan" id="kobo.561.1">
     , each of which, in path terms, indicates changing to the parent folder.
    </span>
    <span class="koboSpan" id="kobo.561.2">
     So, by changing to the parent folder twice in a row, from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.562.1">
      …/lpp4e/ch08/files/
     </span>
    </code>
    <span class="koboSpan" id="kobo.563.1">
     , we go back to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.564.1">
      …/lpp4e/
     </span>
    </code>
    <span class="koboSpan" id="kobo.565.1">
     .
    </span>
    <span class="koboSpan" id="kobo.565.2">
     This is confirmed by the last line in the example, which shows the output of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.566.1">
      readme_path.resolve()
     </span>
    </code>
    <span class="koboSpan" id="kobo.567.1">
     .
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-232">
    <span class="koboSpan" id="kobo.568.1">
     Temporary files and directories
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.569.1">
     Sometimes, it is
    </span>
    <a id="_idIndexMarker770">
    </a>
    <span class="koboSpan" id="kobo.570.1">
     useful to create a temporary directory or file.
    </span>
    <span class="koboSpan" id="kobo.570.2">
     For example, when
    </span>
    <a id="_idIndexMarker771">
    </a>
    <span class="koboSpan" id="kobo.571.1">
     writing tests that affect the disk, you can use temporary files and directories to run your logic and assert that it is correct, and to be sure that at the end of the test run, the test folder has no leftovers.
    </span>
    <span class="koboSpan" id="kobo.571.2">
     Let us see how to do it in Python:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.572.1"># files/tmp.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.573.1">from</span></span><span class="koboSpan" id="kobo.574.1"> tempfile </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.575.1">import</span></span><span class="koboSpan" id="kobo.576.1"> NamedTemporaryFile, TemporaryDirectory
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.577.1">with</span></span><span class="koboSpan" id="kobo.578.1"> TemporaryDirectory(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.579.1">dir</span></span><span class="koboSpan" id="kobo.580.1">=".") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.581.1">as</span></span><span class="koboSpan" id="kobo.582.1"> td:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.583.1">print</span></span><span class="koboSpan" id="kobo.584.1">("Temp directory:", td)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.585.1">with</span></span><span class="koboSpan" id="kobo.586.1"> NamedTemporaryFile(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.587.1">dir</span></span><span class="koboSpan" id="kobo.588.1">=td) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.589.1">as</span></span><span class="koboSpan" id="kobo.590.1"> t:
        name = t.name
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.591.1">print</span></span><span class="koboSpan" id="kobo.592.1">(name)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.593.1">
     The preceding
    </span>
    <a id="_idIndexMarker772">
    </a>
    <span class="koboSpan" id="kobo.594.1">
     example is quite straightforward: we create a temporary directory in the current one (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.595.1">
      "."
     </span>
    </code>
    <span class="koboSpan" id="kobo.596.1">
     ), and we create a named temporary file in it.
    </span>
    <span class="koboSpan" id="kobo.596.2">
     We print the filename, as well as its full path:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.597.1">$ python tmp.py
Temp directory: /Users/fab/code/lpp4ed/ch08/files/tmpqq4quhbc
/Users/fab/code/lpp4ed/ch08/files/tmpqq4quhbc/tmpypwwhpwq
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.598.1">
     Running this
    </span>
    <a id="_idIndexMarker773">
    </a>
    <span class="koboSpan" id="kobo.599.1">
     script will produce a different result every time as these are temporary random names.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-233">
    <span class="koboSpan" id="kobo.600.1">
     Directory content
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.601.1">
     With Python, you can also
    </span>
    <a id="_idIndexMarker774">
    </a>
    <span class="koboSpan" id="kobo.602.1">
     inspect the contents of a directory.
    </span>
    <span class="koboSpan" id="kobo.602.2">
     We will show you two ways of doing this.
    </span>
    <span class="koboSpan" id="kobo.602.3">
     This is the first one:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.603.1"># files/listing.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.604.1">from</span></span><span class="koboSpan" id="kobo.605.1"> pathlib </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.606.1">import</span></span><span class="koboSpan" id="kobo.607.1"> Path
p = Path(".")
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.608.1">for</span></span><span class="koboSpan" id="kobo.609.1"> entry </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.610.1">in</span></span><span class="koboSpan" id="kobo.611.1"> p.glob("*"):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.612.1">print</span></span><span class="koboSpan" id="kobo.613.1">("File:" </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.614.1">if</span></span><span class="koboSpan" id="kobo.615.1"> entry.is_file() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.616.1">else</span></span><span class="koboSpan" id="kobo.617.1"> "Folder:", entry)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.618.1">
     This snippet uses the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.619.1">
      glob()
     </span>
    </code>
    <span class="koboSpan" id="kobo.620.1">
     method of a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.621.1">
      Path
     </span>
    </code>
    <span class="koboSpan" id="kobo.622.1">
     object, applied from the current directory.
    </span>
    <span class="koboSpan" id="kobo.622.2">
     We iterate over the results, each of which is an instance of a subclass of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.623.1">
      Path
     </span>
    </code>
    <span class="koboSpan" id="kobo.624.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.625.1">
      PosixPath
     </span>
    </code>
    <span class="koboSpan" id="kobo.626.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.627.1">
      WindowsPath
     </span>
    </code>
    <span class="koboSpan" id="kobo.628.1">
     , according to which OS we are running).
    </span>
    <span class="koboSpan" id="kobo.628.2">
     For each
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.629.1">
      entry
     </span>
    </code>
    <span class="koboSpan" id="kobo.630.1">
     , we inspect if it is a directory, and print accordingly.
    </span>
    <span class="koboSpan" id="kobo.630.2">
     Running the code yields the following (we omitted a few results for brevity):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.631.1">$ python listing.py
File: existence.py
File: manipulation.py
…
File: open_try.py
File: walking.pathlib.py
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.632.1">
     An alternative
    </span>
    <a id="_idIndexMarker775">
    </a>
    <span class="koboSpan" id="kobo.633.1">
     way is to use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.634.1">
      Path.walk()
     </span>
    </code>
    <span class="koboSpan" id="kobo.635.1">
     method to scan a directory tree.
    </span>
    <span class="koboSpan" id="kobo.635.2">
     Let us see an example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.636.1"># files/walking.pathlib.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.637.1">from</span></span><span class="koboSpan" id="kobo.638.1"> pathlib </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.639.1">import</span></span><span class="koboSpan" id="kobo.640.1"> Path
p = Path(".")
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.641.1">for</span></span><span class="koboSpan" id="kobo.642.1"> root, dirs, files </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.643.1">in</span></span><span class="koboSpan" id="kobo.644.1"> p.walk():
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.645.1">print</span></span><span class="koboSpan" id="kobo.646.1">(f"{root=}")
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.647.1">if</span></span><span class="koboSpan" id="kobo.648.1"> dirs:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.649.1">print</span></span><span class="koboSpan" id="kobo.650.1">("Directories:")
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.651.1">for</span></span><span class="koboSpan" id="kobo.652.1"> dir_ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.653.1">in</span></span><span class="koboSpan" id="kobo.654.1"> dirs:
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.655.1">print</span></span><span class="koboSpan" id="kobo.656.1">(dir_)
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.657.1">print</span></span><span class="koboSpan" id="kobo.658.1">()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.659.1">if</span></span><span class="koboSpan" id="kobo.660.1"> files:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.661.1">print</span></span><span class="koboSpan" id="kobo.662.1">("Files:")
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.663.1">for</span></span><span class="koboSpan" id="kobo.664.1"> filename </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.665.1">in</span></span><span class="koboSpan" id="kobo.666.1"> files:
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.667.1">print</span></span><span class="koboSpan" id="kobo.668.1">(filename)
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.669.1">print</span></span><span class="koboSpan" id="kobo.670.1">()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.671.1">
     Running the preceding snippet will produce a list of all the files and directories in the current one, and it will do the same for each sub-directory.
    </span>
    <span class="koboSpan" id="kobo.671.2">
     In the source code for this book, you will find another module,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.672.1">
      walking.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.673.1">
     , which does exactly the same but uses the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.674.1">
      os.walk()
     </span>
    </code>
    <span class="koboSpan" id="kobo.675.1">
     function instead.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-234">
    <span class="koboSpan" id="kobo.676.1">
     File and directory compression
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.677.1">
     Before we
    </span>
    <a id="_idIndexMarker776">
    </a>
    <span class="koboSpan" id="kobo.678.1">
     leave this section, let us give you an example of how to create a
    </span>
    <a id="_idIndexMarker777">
    </a>
    <span class="koboSpan" id="kobo.679.1">
     compressed file.
    </span>
    <span class="koboSpan" id="kobo.679.2">
     In the source code for this chapter, in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.680.1">
      files/compression
     </span>
    </code>
    <span class="koboSpan" id="kobo.681.1">
     folder, we have two examples: one creates a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.682.1">
      .zip
     </span>
    </code>
    <span class="koboSpan" id="kobo.683.1">
     file, while the other one creates a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.684.1">
      tar.gz
     </span>
    </code>
    <span class="koboSpan" id="kobo.685.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.685.2">
     Python allows you to create compressed files in several different ways and formats.
    </span>
    <span class="koboSpan" id="kobo.685.3">
     Here, we are going to show you how to create the most common one,
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.686.1">
      ZIP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.687.1">
     :
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.688.1"># files/compression/zip.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.689.1">from</span></span><span class="koboSpan" id="kobo.690.1"> zipfile </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.691.1">import</span></span><span class="koboSpan" id="kobo.692.1"> ZipFile
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.693.1">with</span></span><span class="koboSpan" id="kobo.694.1"> ZipFile("example.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.695.1">zip</span></span><span class="koboSpan" id="kobo.696.1">", "w") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.697.1">as</span></span><span class="koboSpan" id="kobo.698.1"> zp:
    zp.write("content1.txt")
    zp.write("content2.txt")
    zp.write("subfolder/content3.txt")
    zp.write("subfolder/content4.txt")
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.699.1">with</span></span><span class="koboSpan" id="kobo.700.1"> ZipFile("example.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.701.1">zip</span></span><span class="koboSpan" id="kobo.702.1">") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.703.1">as</span></span><span class="koboSpan" id="kobo.704.1"> zp:
    zp.extract("content1.txt", "extract_zip")
    zp.extract("subfolder/content3.txt", "extract_zip")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.705.1">
     In the
    </span>
    <a id="_idIndexMarker778">
    </a>
    <span class="koboSpan" id="kobo.706.1">
     preceding
    </span>
    <a id="_idIndexMarker779">
    </a>
    <span class="koboSpan" id="kobo.707.1">
     code, we import
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.708.1">
      ZipFile
     </span>
    </code>
    <span class="koboSpan" id="kobo.709.1">
     , and then, within a context manager, we write into it four files (two of which are in a sub-folder, to show how ZIP preserves the full path).
    </span>
    <span class="koboSpan" id="kobo.709.2">
     Afterward, as an example, we open the compressed file and extract a couple of files from it into the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.710.1">
      extract_zip
     </span>
    </code>
    <span class="koboSpan" id="kobo.711.1">
     directory.
    </span>
    <span class="koboSpan" id="kobo.711.2">
     If you are interested in learning more about data compression, make sure you check out the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.712.1">
      Data Compression and Archiving
     </span>
    </em>
    <span class="koboSpan" id="kobo.713.1">
     section on the standard library (
    </span>
    <a href="https://docs.python.org/3.9/library/archiving.html">
     <span class="url">
      <span class="koboSpan" id="kobo.714.1">
       https://docs.python.org/3.9/library/archiving.html
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.715.1">
     ), where you’ll be able to learn all about this topic.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-235">
    <span class="koboSpan" id="kobo.716.1">
     Data interchange formats
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.717.1">
     Modern
    </span>
    <a id="_idIndexMarker780">
    </a>
    <span class="koboSpan" id="kobo.718.1">
     software architectures tend to split an application into several components.
    </span>
    <span class="koboSpan" id="kobo.718.2">
     Whether you embrace the service-oriented architecture paradigm or push it even further into the microservices realm, these components will have to exchange data.
    </span>
    <span class="koboSpan" id="kobo.718.3">
     But even if you are coding a monolithic application whose codebase is contained in one project, chances are that you still have to exchange data with APIs or programs, or simply handle the data flow between the frontend and backend parts of your website, which likely won’t speak the same language.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.719.1">
     Choosing the right format in which to exchange information is crucial.
    </span>
    <span class="koboSpan" id="kobo.719.2">
     A language-specific format has the advantage that the language itself is likely to provide you with all the tools to
    </span>
    <a id="_idIndexMarker781">
    </a>
    <span class="koboSpan" id="kobo.720.1">
     make
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.721.1">
      serialization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.722.1">
     and
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.723.1">
      deserialization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.724.1">
     a breeze.
    </span>
    <span class="koboSpan" id="kobo.724.2">
     However, you will lack the ability to
    </span>
    <a id="_idIndexMarker782">
    </a>
    <span class="koboSpan" id="kobo.725.1">
     talk natively to other components that have been written in different versions of the same language, or in different languages altogether.
    </span>
    <span class="koboSpan" id="kobo.725.2">
     Regardless of what the future looks like, going with a language-specific format should only be done if it is the only possible choice for the given situation.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.726.1">
     According to
    </span>
    <a id="_idIndexMarker783">
    </a>
    <span class="koboSpan" id="kobo.727.1">
     Wikipedia (
    </span>
    <a href="https://en.wikipedia.org/wiki/Serialization">
     <span class="url">
      <span class="koboSpan" id="kobo.728.1">
       https://en.wikipedia.org/wiki/Serialization
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.729.1">
     ):
    </span>
   </p>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.730.1">
      In computing, serialization is the process of translating a data structure or object state into a format that can be stored (for example, in a file or memory data buffer) or transmitted (for example, over a computer network) and reconstructed later (possibly in a different computer environment).
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.731.1">
     A safer
    </span>
    <a id="_idIndexMarker784">
    </a>
    <span class="koboSpan" id="kobo.732.1">
     approach is to choose a language-agnostic format.
    </span>
    <span class="koboSpan" id="kobo.732.2">
     In software, some popular formats have become the de facto standard for data interchange.
    </span>
    <span class="koboSpan" id="kobo.732.3">
     The most famous ones probably are
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.733.1">
      XML
     </span>
    </strong>
    <span class="koboSpan" id="kobo.734.1">
     ,
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.735.1">
      YAML
     </span>
    </strong>
    <span class="koboSpan" id="kobo.736.1">
     , and
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.737.1">
      JSON
     </span>
    </strong>
    <span class="koboSpan" id="kobo.738.1">
     .
    </span>
    <span class="koboSpan" id="kobo.738.2">
     The Python standard library
    </span>
    <a id="_idIndexMarker785">
    </a>
    <span class="koboSpan" id="kobo.739.1">
     features the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.740.1">
      xml
     </span>
    </code>
    <span class="koboSpan" id="kobo.741.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.742.1">
      json
     </span>
    </code>
    <span class="koboSpan" id="kobo.743.1">
     modules, and, on PyPI (
    </span>
    <a href="https://pypi.org/">
     <span class="url">
      <span class="koboSpan" id="kobo.744.1">
       https://pypi.org/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.745.1">
     ), you can find a few different packages to work with YAML.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.746.1">
     In the Python environment, JSON is perhaps the most commonly used format.
    </span>
    <span class="koboSpan" id="kobo.746.2">
     It wins over the other two because of being part of the standard library, and for its simplicity.
    </span>
    <span class="koboSpan" id="kobo.746.3">
     XML tends to be quite verbose, and harder to read.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.747.1">
     Moreover, when working with a database like PostgreSQL, the ability to use native JSON fields makes a compelling case for adopting JSON in the application as well.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-236">
    <span class="koboSpan" id="kobo.748.1">
     Working with JSON
    </span>
   </h2>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.749.1">
      JSON
     </span>
    </strong>
    <span class="koboSpan" id="kobo.750.1">
     is the
    </span>
    <a id="_idIndexMarker786">
    </a>
    <span class="koboSpan" id="kobo.751.1">
     acronym for
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.752.1">
      JavaScript Object Notation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.753.1">
     , and it
    </span>
    <a id="_idIndexMarker787">
    </a>
    <span class="koboSpan" id="kobo.754.1">
     is a subset of the JavaScript language.
    </span>
    <span class="koboSpan" id="kobo.754.2">
     It has been around for almost two decades now, so it is well known and widely adopted by most languages, even though it is actually language independent.
    </span>
    <span class="koboSpan" id="kobo.754.3">
     You can read all about it on
    </span>
    <a id="_idIndexMarker788">
    </a>
    <span class="koboSpan" id="kobo.755.1">
     its website (
    </span>
    <a href="https://www.json.org/">
     <span class="url">
      <span class="koboSpan" id="kobo.756.1">
       https://www.json.org/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.757.1">
     ), but we are going to
    </span>
    <a id="_idIndexMarker789">
    </a>
    <span class="koboSpan" id="kobo.758.1">
     give you a quick introduction to it now.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.759.1">
     JSON is based on two structures:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.760.1">
      A collection of name/value pairs
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.761.1">
      An ordered list of values
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.762.1">
     Unsurprisingly, these two objects map to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.763.1">
      dict
     </span>
    </code>
    <span class="koboSpan" id="kobo.764.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.765.1">
      list
     </span>
    </code>
    <span class="koboSpan" id="kobo.766.1">
     data types in Python, respectively.
    </span>
    <span class="koboSpan" id="kobo.766.2">
     As data types, JSON offers strings, numbers, objects, and values consisting of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.767.1">
      true
     </span>
    </code>
    <span class="koboSpan" id="kobo.768.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.769.1">
      false
     </span>
    </code>
    <span class="koboSpan" id="kobo.770.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.771.1">
      null
     </span>
    </code>
    <span class="koboSpan" id="kobo.772.1">
     .
    </span>
    <span class="koboSpan" id="kobo.772.2">
     Let us see a quick example to get us started:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.773.1"># json_examples/json_basic.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.774.1">import</span></span><span class="koboSpan" id="kobo.775.1"> sys
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.776.1">import</span></span><span class="koboSpan" id="kobo.777.1"> json
data = {
    "big_number": </span><span class="hljs-number"><span class="koboSpan" id="kobo.778.1">2</span></span><span class="koboSpan" id="kobo.779.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.780.1">3141</span></span><span class="koboSpan" id="kobo.781.1">,
    "max_float": sys.float_info.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.782.1">max</span></span><span class="koboSpan" id="kobo.783.1">,
    "a_list": [</span><span class="hljs-number"><span class="koboSpan" id="kobo.784.1">2</span></span><span class="koboSpan" id="kobo.785.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.786.1">3</span></span><span class="koboSpan" id="kobo.787.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.788.1">5</span></span><span class="koboSpan" id="kobo.789.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.790.1">7</span></span><span class="koboSpan" id="kobo.791.1">],
}
json_data = json.dumps(data)
data_out = json.loads(json_data)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.792.1">assert</span></span><span class="koboSpan" id="kobo.793.1"> data == data_out  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.794.1"># json and back, data matches</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.795.1">
     We
    </span>
    <a id="_idIndexMarker790">
    </a>
    <span class="koboSpan" id="kobo.796.1">
     begin by
    </span>
    <a id="_idIndexMarker791">
    </a>
    <span class="koboSpan" id="kobo.797.1">
     importing the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.798.1">
      sys
     </span>
    </code>
    <span class="koboSpan" id="kobo.799.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.800.1">
      json
     </span>
    </code>
    <span class="koboSpan" id="kobo.801.1">
     modules.
    </span>
    <span class="koboSpan" id="kobo.801.2">
     Then, we create a simple dictionary with some numbers and a list of integers.
    </span>
    <span class="koboSpan" id="kobo.801.3">
     We wanted to test serializing and deserializing using very big numbers, both
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.802.1">
      int
     </span>
    </code>
    <span class="koboSpan" id="kobo.803.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.804.1">
      float
     </span>
    </code>
    <span class="koboSpan" id="kobo.805.1">
     , so we put 2
    </span>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.806.1">
      3141
     </span>
    </sup>
    <span class="koboSpan" id="kobo.807.1">
     and whatever is the biggest floating point number our system can handle.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.808.1">
     We serialize with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.809.1">
      json.dumps()
     </span>
    </code>
    <span class="koboSpan" id="kobo.810.1">
     , which converts data into a JSON formatted string.
    </span>
    <span class="koboSpan" id="kobo.810.2">
     That data is then fed into
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.811.1">
      json.loads()
     </span>
    </code>
    <span class="koboSpan" id="kobo.812.1">
     , which does the opposite: from a JSON formatted string, it reconstructs the data into Python.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.813.1">
      Notice that the JSON module also provides the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.814.1">
       dump
      </span>
     </code>
     <span class="koboSpan" id="kobo.815.1">
      and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.816.1">
       load
      </span>
     </code>
     <span class="koboSpan" id="kobo.817.1">
      functions, which convert data to and from a file-like object.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.818.1">
     On the last line, by means of an assertion, we make sure that the original data and the result of the serialization/deserialization through JSON match.
    </span>
    <span class="koboSpan" id="kobo.818.2">
     Should the condition that follows the assert statement be falsy, that statement will raise an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.819.1">
      AssertionError
     </span>
    </code>
    <span class="koboSpan" id="kobo.820.1">
     .
    </span>
    <span class="koboSpan" id="kobo.820.2">
     We will cover assertions in more detail in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.821.1">
      Chapter 10
     </span>
    </em>
    <span class="koboSpan" id="kobo.822.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.823.1">
      Testing
     </span>
    </em>
    <span class="koboSpan" id="kobo.824.1">
     .
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.825.1">
      In programming, the
     </span>
     <a id="_idIndexMarker792">
     </a>
     <span class="koboSpan" id="kobo.826.1">
      term
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.827.1">
       falsy
      </span>
     </strong>
     <span class="koboSpan" id="kobo.828.1">
      refers to an object or a condition that, when evaluated in a boolean context, is considered false.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.829.1">
     Let us see what JSON data would look like if we printed it:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.830.1"># json_examples/json_basic.py</span></span><span class="koboSpan" id="kobo.831.1">
info = {
    "full_name": "Sherlock Holmes",
    "address": {
        "street": "221B Baker St",
        "</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.832.1">zip</span></span><span class="koboSpan" id="kobo.833.1">": "NW1 6XE",
        "city": "London",
        "country": "UK",
    },
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.834.1">print</span></span><span class="koboSpan" id="kobo.835.1">(json.dumps(info, indent=</span><span class="hljs-number"><span class="koboSpan" id="kobo.836.1">2</span></span><span class="koboSpan" id="kobo.837.1">, sort_keys=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.838.1">True</span></span><span class="koboSpan" id="kobo.839.1">))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.840.1">
     In this
    </span>
    <a id="_idIndexMarker793">
    </a>
    <span class="koboSpan" id="kobo.841.1">
     example, we create a dictionary with
    </span>
    <a id="_idIndexMarker794">
    </a>
    <span class="koboSpan" id="kobo.842.1">
     Sherlock Holmes’ data in it.
    </span>
    <span class="koboSpan" id="kobo.842.2">
     If, like us, you are a fan of Sherlock Holmes, and are in London, you will find his museum at that address (which we recommend visiting; it is small but very nice).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.843.1">
     Notice how we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.844.1">
      json.dumps()
     </span>
    </code>
    <span class="koboSpan" id="kobo.845.1">
     , though.
    </span>
    <span class="koboSpan" id="kobo.845.2">
     We instruct it to indent with two spaces and sort keys alphabetically.
    </span>
    <span class="koboSpan" id="kobo.845.3">
     The result is this:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.846.1">$ python json_basic.py
{
  "address": {
    "city": "London",
    "country": "UK",
    "street": "221B Baker St",
    "zip": "NW1 6XE"
  },
  "full_name": "Sherlock Holmes"
}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.847.1">
     The similarity with Python is evident.
    </span>
    <span class="koboSpan" id="kobo.847.2">
     The one difference is that if you place a comma on the last element in a dictionary, as is customary in Python, JSON will complain.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.848.1">
     Let us show you something interesting:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.849.1"># json_examples/json_tuple.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.850.1">import</span></span><span class="koboSpan" id="kobo.851.1"> json
data_in = {
    "a_tuple": (</span><span class="hljs-number"><span class="koboSpan" id="kobo.852.1">1</span></span><span class="koboSpan" id="kobo.853.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.854.1">2</span></span><span class="koboSpan" id="kobo.855.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.856.1">3</span></span><span class="koboSpan" id="kobo.857.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.858.1">4</span></span><span class="koboSpan" id="kobo.859.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.860.1">5</span></span><span class="koboSpan" id="kobo.861.1">),
}
json_data = json.dumps(data_in)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.862.1">print</span></span><span class="koboSpan" id="kobo.863.1">(json_data)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.864.1"># {"a_tuple": [1, 2, 3, 4, 5]}</span></span><span class="koboSpan" id="kobo.865.1">
data_out = json.loads(json_data)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.866.1">print</span></span><span class="koboSpan" id="kobo.867.1">(data_out)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.868.1"># {'a_tuple': [1, 2, 3, 4, 5]}</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.869.1">
     In this example, we
    </span>
    <a id="_idIndexMarker795">
    </a>
    <span class="koboSpan" id="kobo.870.1">
     have used a tuple instead of a list.
    </span>
    <span class="koboSpan" id="kobo.870.2">
     The interesting bit is that, conceptually, a tuple is also an ordered list of items.
    </span>
    <span class="koboSpan" id="kobo.870.3">
     It does not have the flexibility of a list, but still, it is considered the same from the perspective of JSON.
    </span>
    <span class="koboSpan" id="kobo.870.4">
     Therefore, as you can see by the first
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.871.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.872.1">
     , in JSON a tuple is transformed into a list.
    </span>
    <span class="koboSpan" id="kobo.872.2">
     Naturally, then, the information that the original object was a tuple is lost, and when deserialization happens, what originally was a tuple is instead translated to a Python list.
    </span>
    <span class="koboSpan" id="kobo.872.3">
     It is important that you keep this in mind when dealing with data, as going through a transformation process that involves a format that only comprises a subset of the data structures you can use implies there may be information loss.
    </span>
    <span class="koboSpan" id="kobo.872.4">
     In this case, we lost the information about the type (tuple versus list).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.873.1">
     This is actually
    </span>
    <a id="_idIndexMarker796">
    </a>
    <span class="koboSpan" id="kobo.874.1">
     a common problem.
    </span>
    <span class="koboSpan" id="kobo.874.2">
     For example, you cannot serialize all Python objects to JSON, as it is not always clear how JSON should revert that object.
    </span>
    <span class="koboSpan" id="kobo.874.3">
     Think about
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.875.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.876.1">
     , for example.
    </span>
    <span class="koboSpan" id="kobo.876.2">
     An instance of that class is a Python object that JSON will not be able to serialize.
    </span>
    <span class="koboSpan" id="kobo.876.3">
     If we transform it into a string such as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.877.1">
      2018-03-04T12:00:30Z
     </span>
    </code>
    <span class="koboSpan" id="kobo.878.1">
     , which is the ISO 8601 representation of a date with time and time zone information, what should JSON do when deserializing?
    </span>
    <span class="koboSpan" id="kobo.878.2">
     Should it decide that
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.879.1">
      this is deserializable into a datetime object, so I’d better do it
     </span>
    </em>
    <span class="koboSpan" id="kobo.880.1">
     , or should it simply consider it as a string and leave it as it is?
    </span>
    <span class="koboSpan" id="kobo.880.2">
     What about data types that can be interpreted in more than one way?
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.881.1">
     The answer is that when dealing with data interchange, we often need to transform our objects into a simpler format prior to serializing them with JSON.
    </span>
    <span class="koboSpan" id="kobo.881.2">
     The more we manage to simplify our data, the easier it is to represent that data in a format like JSON, which has limitations.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.882.1">
     In some cases, though, and mostly for internal use, it is useful to be able to serialize custom objects, so, just for fun, we are going to show you how with two examples: complex numbers and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.883.1">
      datetime
     </span>
    </em>
    <span class="koboSpan" id="kobo.884.1">
     objects.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-237">
    <span class="koboSpan" id="kobo.885.1">
     Custom encoding/decoding with JSON
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.886.1">
     In the
    </span>
    <a id="_idIndexMarker797">
    </a>
    <span class="koboSpan" id="kobo.887.1">
     JSON world, we can consider terms like encoding/decoding as synonyms for serializing/deserializing.
    </span>
    <span class="koboSpan" id="kobo.887.2">
     They basically mean transforming to and back from JSON.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.888.1">
     In the following example, we are going to learn how to encode complex numbers – which are not serializable to JSON by default – by writing a custom encoder:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.889.1"># json_examples/json_cplx.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.890.1">import</span></span><span class="koboSpan" id="kobo.891.1"> json
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.892.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.893.1">ComplexEncoder</span></span><span class="koboSpan" id="kobo.894.1">(json.JSONEncoder):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.895.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.896.1">default</span></span><span class="koboSpan" id="kobo.897.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.898.1">self, obj</span></span><span class="koboSpan" id="kobo.899.1">):
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.900.1">print</span></span><span class="koboSpan" id="kobo.901.1">(f"ComplexEncoder.default: {obj=}")
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.902.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.903.1">isinstance</span></span><span class="koboSpan" id="kobo.904.1">(obj, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.905.1">complex</span></span><span class="koboSpan" id="kobo.906.1">):
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.907.1">return</span></span><span class="koboSpan" id="kobo.908.1"> {
                "_meta": "</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.909.1">complex</span></span><span class="koboSpan" id="kobo.910.1">",
                "num": [obj.real, obj.imag],
            }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.911.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.912.1">super</span></span><span class="koboSpan" id="kobo.913.1">().default(obj)
data = {
    "an_int": </span><span class="hljs-number"><span class="koboSpan" id="kobo.914.1">42</span></span><span class="koboSpan" id="kobo.915.1">,
    "a_float": </span><span class="hljs-number"><span class="koboSpan" id="kobo.916.1">3.14159265</span></span><span class="koboSpan" id="kobo.917.1">,
    "a_complex": </span><span class="hljs-number"><span class="koboSpan" id="kobo.918.1">3</span></span><span class="koboSpan" id="kobo.919.1"> + </span><span class="hljs-number"><span class="koboSpan" id="kobo.920.1">4j</span></span><span class="koboSpan" id="kobo.921.1">,
}
json_data = json.dumps(data, cls=ComplexEncoder)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.922.1">print</span></span><span class="koboSpan" id="kobo.923.1">(json_data)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.924.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.925.1">object_hook</span></span><span class="koboSpan" id="kobo.926.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.927.1">obj</span></span><span class="koboSpan" id="kobo.928.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.929.1">print</span></span><span class="koboSpan" id="kobo.930.1">(f"object_hook: {obj=}")
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.931.1">try</span></span><span class="koboSpan" id="kobo.932.1">:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.933.1">if</span></span><span class="koboSpan" id="kobo.934.1"> obj["_meta"] == "</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.935.1">complex</span></span><span class="koboSpan" id="kobo.936.1">":
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.937.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.938.1">complex</span></span><span class="koboSpan" id="kobo.939.1">(*obj["num"])
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.940.1">except</span></span><span class="koboSpan" id="kobo.941.1"> KeyError:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.942.1">return</span></span><span class="koboSpan" id="kobo.943.1"> obj
data_out = json.loads(json_data, object_hook=object_hook)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.944.1">print</span></span><span class="koboSpan" id="kobo.945.1">(data_out)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.946.1">
     We start by defining a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.947.1">
      ComplexEncoder
     </span>
    </code>
    <span class="koboSpan" id="kobo.948.1">
     class as a subclass of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.949.1">
      JSONEncoder
     </span>
    </code>
    <span class="koboSpan" id="kobo.950.1">
     .
    </span>
    <span class="koboSpan" id="kobo.950.2">
     This class overrides the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.951.1">
      default()
     </span>
    </code>
    <span class="koboSpan" id="kobo.952.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.952.2">
     This method is called whenever the encoder encounters an object that it cannot encode natively and is expected to return an encodable representation of that object.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.953.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.954.1">
      default()
     </span>
    </code>
    <span class="koboSpan" id="kobo.955.1">
     method
    </span>
    <a id="_idIndexMarker798">
    </a>
    <span class="koboSpan" id="kobo.956.1">
     checks whether its argument is a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.957.1">
      complex
     </span>
    </code>
    <span class="koboSpan" id="kobo.958.1">
     object, in which case it returns a dictionary with some custom meta information and a list that contains both the real and the imaginary part of the number.
    </span>
    <span class="koboSpan" id="kobo.958.2">
     That is all we need to do to avoid losing information for a complex number.
    </span>
    <span class="koboSpan" id="kobo.958.3">
     If we receive anything other than an instance of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.959.1">
      complex
     </span>
    </code>
    <span class="koboSpan" id="kobo.960.1">
     , we call the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.961.1">
      default()
     </span>
    </code>
    <span class="koboSpan" id="kobo.962.1">
     method from the parent class.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.963.1">
     In the example, we then call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.964.1">
      json.dumps()
     </span>
    </code>
    <span class="koboSpan" id="kobo.965.1">
     , but this time we use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.966.1">
      cls
     </span>
    </code>
    <span class="koboSpan" id="kobo.967.1">
     argument to specify the custom encoder.
    </span>
    <span class="koboSpan" id="kobo.967.2">
     Finally, the result is printed:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.968.1">$ python json_cplx.py
ComplexEncoder.default: obj=(3+4j)
{
    "an_int": 42, "a_float": 3.14159265,
    "a_complex": {"_meta": "complex", "num": [3.0, 4.0]}
}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.969.1">
     Half the job is done.
    </span>
    <span class="koboSpan" id="kobo.969.2">
     For the deserialization part, we could have written another class that would inherit from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.970.1">
      JSONDecoder
     </span>
    </code>
    <span class="koboSpan" id="kobo.971.1">
     , but instead, we have chosen to use a different technique that is simpler and uses a small function:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.972.1">
      object_hook()
     </span>
    </code>
    <span class="koboSpan" id="kobo.973.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.974.1">
     Within the body of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.975.1">
      object_hook()
     </span>
    </code>
    <span class="koboSpan" id="kobo.976.1">
     , we find a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.977.1">
      try
     </span>
    </code>
    <span class="koboSpan" id="kobo.978.1">
     block.
    </span>
    <span class="koboSpan" id="kobo.978.2">
     The important part is the two lines within the body of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.979.1">
      try
     </span>
    </code>
    <span class="koboSpan" id="kobo.980.1">
     block itself.
    </span>
    <span class="koboSpan" id="kobo.980.2">
     The function receives an object (note that the function is only called when
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.981.1">
      obj
     </span>
    </code>
    <span class="koboSpan" id="kobo.982.1">
     is a dictionary), and if the metadata matches our convention for complex numbers, we pass the real and imaginary parts to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.983.1">
      complex()
     </span>
    </code>
    <span class="koboSpan" id="kobo.984.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.984.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.985.1">
      try
     </span>
    </code>
    <span class="koboSpan" id="kobo.986.1">
     /
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.987.1">
      except
     </span>
    </code>
    <span class="koboSpan" id="kobo.988.1">
     block is there because our function will be called for every dictionary object that is decoded, so we need to handle the case where our
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.989.1">
      _meta
     </span>
    </code>
    <span class="koboSpan" id="kobo.990.1">
     key is not present.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.991.1">
     The decoding part of the example outputs:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.992.1">object_hook:
  obj={'_meta': 'complex', 'num': [3.0, 4.0]}
object_hook:
  obj={'an_int': 42, 'a_float': 3.14159265, 'a_complex': (3+4j)}
{'an_int': 42, 'a_float': 3.14159265, 'a_complex': (3+4j)}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.993.1">
     You can see that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.994.1">
      a_complex
     </span>
    </code>
    <span class="koboSpan" id="kobo.995.1">
     has been correctly deserialized.
    </span>
    <span class="koboSpan" id="kobo.995.2">
     As an exercise, we suggest writing your own custom encoders for
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.996.1">
      Fraction
     </span>
    </code>
    <span class="koboSpan" id="kobo.997.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.998.1">
      Decimal
     </span>
    </code>
    <span class="koboSpan" id="kobo.999.1">
     objects.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1000.1">
     Let us now consider a slightly more complex (no pun intended) example: dealing with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1001.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1002.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.1002.2">
     We
    </span>
    <a id="_idIndexMarker799">
    </a>
    <span class="koboSpan" id="kobo.1003.1">
     are going to split the code into two blocks, first the serializing part, and then the deserializing part:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1004.1"># json_examples/json_datetime.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1005.1">import</span></span><span class="koboSpan" id="kobo.1006.1"> json
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1007.1">from</span></span><span class="koboSpan" id="kobo.1008.1"> datetime </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1009.1">import</span></span><span class="koboSpan" id="kobo.1010.1"> datetime, timedelta, timezone
now = datetime.now()
now_tz = datetime.now(tz=timezone(timedelta(hours=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1011.1">1</span></span><span class="koboSpan" id="kobo.1012.1">)))
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1013.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1014.1">DatetimeEncoder</span></span><span class="koboSpan" id="kobo.1015.1">(json.JSONEncoder):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1016.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1017.1">default</span></span><span class="koboSpan" id="kobo.1018.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1019.1">self, obj</span></span><span class="koboSpan" id="kobo.1020.1">):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1021.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1022.1">isinstance</span></span><span class="koboSpan" id="kobo.1023.1">(obj, datetime):
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1024.1">try</span></span><span class="koboSpan" id="kobo.1025.1">:
                off = obj.utcoffset().seconds
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1026.1">except</span></span><span class="koboSpan" id="kobo.1027.1"> AttributeError:
                off = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1028.1">None</span></span>
            <span class="hljs-keyword"><span class="koboSpan" id="kobo.1029.1">return</span></span><span class="koboSpan" id="kobo.1030.1"> {
                "_meta": "datetime",
                "data": obj.timetuple()[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1031.1">6</span></span><span class="koboSpan" id="kobo.1032.1">] + (obj.microsecond,),
                "utcoffset": off,
            }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1033.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1034.1">super</span></span><span class="koboSpan" id="kobo.1035.1">().default(obj)
data = {
    "an_int": </span><span class="hljs-number"><span class="koboSpan" id="kobo.1036.1">42</span></span><span class="koboSpan" id="kobo.1037.1">,
    "a_float": </span><span class="hljs-number"><span class="koboSpan" id="kobo.1038.1">3.14159265</span></span><span class="koboSpan" id="kobo.1039.1">,
    "a_datetime": now,
    "a_datetime_tz": now_tz,
}
json_data = json.dumps(data, cls=DatetimeEncoder)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1040.1">print</span></span><span class="koboSpan" id="kobo.1041.1">(json_data)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1042.1">
     The reason this example is slightly more complex lies in the fact that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1043.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1044.1">
     objects in Python can either be time-zone-aware or not; therefore, we need to handle them carefully.
    </span>
    <span class="koboSpan" id="kobo.1044.2">
     The flow is as before, only we are dealing with a different data type.
    </span>
    <span class="koboSpan" id="kobo.1044.3">
     We start by getting the current date and time information, and we do it both without (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1045.1">
      now
     </span>
    </code>
    <span class="koboSpan" id="kobo.1046.1">
     ) and with (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1047.1">
      now_tz
     </span>
    </code>
    <span class="koboSpan" id="kobo.1048.1">
     ) time zone awareness.
    </span>
    <span class="koboSpan" id="kobo.1048.2">
     We then proceed to define a custom encoder as before, overriding the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1049.1">
      default()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1050.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.1050.2">
     The important bits in that method are how we get the time zone offset (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1051.1">
      off
     </span>
    </code>
    <span class="koboSpan" id="kobo.1052.1">
     ) information, in seconds, and how we structure the dictionary that returns the data.
    </span>
    <span class="koboSpan" id="kobo.1052.2">
     This time, the metadata says it is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1053.1">
      datetime
     </span>
    </em>
    <span class="koboSpan" id="kobo.1054.1">
     information.
    </span>
    <span class="koboSpan" id="kobo.1054.2">
     We save the
    </span>
    <a id="_idIndexMarker800">
    </a>
    <span class="koboSpan" id="kobo.1055.1">
     first six items from the time tuple (year, month, day, hour, minute, and second), plus the microseconds in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1056.1">
      data
     </span>
    </code>
    <span class="koboSpan" id="kobo.1057.1">
     key, and the offset after that.
    </span>
    <span class="koboSpan" id="kobo.1057.2">
     Good job if you could tell that the value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1058.1">
      "data"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1059.1">
     is a concatenation of tuples.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1060.1">
     After the custom encoder, we proceed to create some data, and then we serialize it.
    </span>
    <span class="koboSpan" id="kobo.1060.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1061.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1062.1">
     statement outputs the following (we have reformatted the output to make it more readable):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1063.1">$ python json_datetime.py
{
    "an_int": 42,
    "a_float": 3.14159265,
    "a_datetime": {
        "_meta": "datetime",
        "data": [2024, 3, 29, 23, 24, 22, 232302],
        "utcoffset": null,
    },
    "a_datetime_tz": {
        "_meta": "datetime",
        "data": [2024, 3, 30, 0, 24, 22, 232316],
        "utcoffset": 3600,
    },
}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1064.1">
     Interestingly, we find out that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1065.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.1066.1">
     is translated to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1067.1">
      null
     </span>
    </code>
    <span class="koboSpan" id="kobo.1068.1">
     , its JavaScript equivalent.
    </span>
    <span class="koboSpan" id="kobo.1068.2">
     Moreover, we can see that the data seems to have been encoded properly.
    </span>
    <span class="koboSpan" id="kobo.1068.3">
     Let us proceed with the second part of the script:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1069.1"># json_examples/json_datetime.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1070.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1071.1">object_hook</span></span><span class="koboSpan" id="kobo.1072.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1073.1">obj</span></span><span class="koboSpan" id="kobo.1074.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1075.1">try</span></span><span class="koboSpan" id="kobo.1076.1">:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1077.1">if</span></span><span class="koboSpan" id="kobo.1078.1"> obj["_meta"] == "datetime":
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1079.1">if</span></span><span class="koboSpan" id="kobo.1080.1"> obj["utcoffset"] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1081.1">is</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1082.1">None</span></span><span class="koboSpan" id="kobo.1083.1">:
                tz = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1084.1">None</span></span>
            <span class="hljs-keyword"><span class="koboSpan" id="kobo.1085.1">else</span></span><span class="koboSpan" id="kobo.1086.1">:
                tz = timezone(timedelta(seconds=obj["utcoffset"]))
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1087.1">return</span></span><span class="koboSpan" id="kobo.1088.1"> datetime(*obj["data"], tzinfo=tz)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1089.1">except</span></span><span class="koboSpan" id="kobo.1090.1"> KeyError:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1091.1">return</span></span><span class="koboSpan" id="kobo.1092.1"> obj
data_out = json.loads(json_data, object_hook=object_hook)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1093.1">print</span></span><span class="koboSpan" id="kobo.1094.1">(data_out)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1095.1">
     Once again, we
    </span>
    <a id="_idIndexMarker801">
    </a>
    <span class="koboSpan" id="kobo.1096.1">
     first verify that the metadata is telling us it is a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1097.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1098.1">
     , and then we proceed to fetch the time zone information.
    </span>
    <span class="koboSpan" id="kobo.1098.2">
     Once we have it, we pass the 7-tuple (using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1099.1">
      *
     </span>
    </code>
    <span class="koboSpan" id="kobo.1100.1">
     to unpack its values in the call) and the time zone information to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1101.1">
      datetime()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1102.1">
     call, getting back our original object.
    </span>
    <span class="koboSpan" id="kobo.1102.2">
     Let us verify it by printing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1103.1">
      data_out
     </span>
    </code>
    <span class="koboSpan" id="kobo.1104.1">
     :
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1105.1">{
    "an_int": 42,
    "a_float": 3.14159265,
    "a_datetime": datetime.datetime(
        2024, 3, 29, 23, 24, 22, 232302
    ),
    "a_datetime_tz": datetime.datetime(
        2024, 3, 30, 0, 24, 22, 232316,
        tzinfo=datetime.timezone(
            datetime.timedelta(seconds=3600)
        ),
    ),
}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1106.1">
     As you can see, we got everything back correctly.
    </span>
    <span class="koboSpan" id="kobo.1106.2">
     As an exercise, we suggest you write the same logic but for a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1107.1">
      date
     </span>
    </code>
    <span class="koboSpan" id="kobo.1108.1">
     object, which should be simpler.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1109.1">
     Before we move on to the next topic, a word of caution.
    </span>
    <span class="koboSpan" id="kobo.1109.2">
     Perhaps it is counter-intuitive, but working with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1110.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1111.1">
     objects can be quite tricky, so although we are pretty sure this code is doing what it is supposed to do, we want to stress that we only tested it superficially.
    </span>
    <span class="koboSpan" id="kobo.1111.2">
     So, if you intend to use it, please do test it thoroughly.
    </span>
    <span class="koboSpan" id="kobo.1111.3">
     Test for different time zones, test for daylight saving time being on and off, test for dates before the epoch, and so on.
    </span>
    <span class="koboSpan" id="kobo.1111.4">
     You might find that the code in this section needs some modifications to suit your case.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-238">
    <span class="koboSpan" id="kobo.1112.1">
     I/O, streams, and requests
    </span>
   </h1>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1113.1">
      I/O
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1114.1">
     stands for
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1115.1">
      input/output
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1116.1">
     , and
    </span>
    <a id="_idIndexMarker802">
    </a>
    <span class="koboSpan" id="kobo.1117.1">
     it broadly refers to the communication between a computer and the outside world.
    </span>
    <span class="koboSpan" id="kobo.1117.2">
     There are several different types of I/O, and it is outside the scope of this chapter to explain all of them, but it is worth going through a couple of examples.
    </span>
    <span class="koboSpan" id="kobo.1117.3">
     The first one will introduce the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1118.1">
      io.StringIO
     </span>
    </code>
    <span class="koboSpan" id="kobo.1119.1">
     class, which
    </span>
    <a id="_idIndexMarker803">
    </a>
    <span class="koboSpan" id="kobo.1120.1">
     is an in-memory stream for text I/O.
    </span>
    <span class="koboSpan" id="kobo.1120.2">
     The second one instead will escape the locality of our computer and demonstrate how to perform an HTTP request.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-239">
    <span class="koboSpan" id="kobo.1121.1">
     Using an in-memory stream
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1122.1">
     In-memory objects
    </span>
    <a id="_idIndexMarker804">
    </a>
    <span class="koboSpan" id="kobo.1123.1">
     can be useful in a multitude of situations.
    </span>
    <span class="koboSpan" id="kobo.1123.2">
     Memory is much faster than a hard disk, it is always available, and for small amounts of data can be the perfect choice.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1124.1">
     Let us see the first example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1125.1"># io_examples/string_io.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1126.1">import</span></span><span class="koboSpan" id="kobo.1127.1"> io
stream = io.StringIO()
stream.write("Learning Python Programming.\n")
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1128.1">print</span></span><span class="koboSpan" id="kobo.1129.1">("Become a Python ninja!", file=stream)
contents = stream.getvalue()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1130.1">print</span></span><span class="koboSpan" id="kobo.1131.1">(contents)
stream.close()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1132.1">
     In the preceding code snippet, we import the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1133.1">
      io
     </span>
    </code>
    <span class="koboSpan" id="kobo.1134.1">
     module from the standard library.
    </span>
    <span class="koboSpan" id="kobo.1134.2">
     This module features many tools related to streams and I/O.
    </span>
    <span class="koboSpan" id="kobo.1134.3">
     One of them is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1135.1">
      StringIO
     </span>
    </code>
    <span class="koboSpan" id="kobo.1136.1">
     , which is an in-memory buffer in which we have written two sentences, using two different methods, as we did with files in the first examples of this chapter.
    </span>
   </p>
   <p class="normal">
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1137.1">
      StringIO
     </span>
    </code>
    <span class="koboSpan" id="kobo.1138.1">
     is useful when you need to:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.1139.1">
      Simulate file-like behavior for strings.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.1140.1">
      Test code that works with file-like objects without using actual files.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.1141.1">
      Build or manipulate large strings efficiently.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.1142.1">
      Capture or mock input/output for testing purposes.
     </span>
     <span class="koboSpan" id="kobo.1142.2">
      Tests run much faster because they avoid disk I/O.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.1143.1">
     We can either call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1144.1">
      StringIO.write()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1145.1">
     or we can use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1146.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1147.1">
     , instructing it to direct the data to our stream.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1148.1">
     By calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1149.1">
      getvalue()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1150.1">
     , we can get the content of the stream.
    </span>
    <span class="koboSpan" id="kobo.1150.2">
     We then proceed to print it, and finally, we close it.
    </span>
    <span class="koboSpan" id="kobo.1150.3">
     The call to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1151.1">
      close()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1152.1">
     causes the text buffer to be immediately discarded.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1153.1">
     There is a more elegant way to write the previous code:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1154.1"># io_examples/string_io.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1155.1">with</span></span><span class="koboSpan" id="kobo.1156.1"> io.StringIO() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1157.1">as</span></span><span class="koboSpan" id="kobo.1158.1"> stream:
    stream.write("Learning Python Programming.\n")
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1159.1">print</span></span><span class="koboSpan" id="kobo.1160.1">("Become a Python ninja!", file=stream)
    contents = stream.getvalue()
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1161.1">print</span></span><span class="koboSpan" id="kobo.1162.1">(contents)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1163.1">
     Like the
    </span>
    <a id="_idIndexMarker805">
    </a>
    <span class="koboSpan" id="kobo.1164.1">
     built-in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1165.1">
      open()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1166.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1167.1">
      io.StringIO()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1168.1">
     too works well within a context manager block.
    </span>
    <span class="koboSpan" id="kobo.1168.2">
     Notice the similarity with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1169.1">
      open()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1170.1">
     ; in this case as well, we don’t need to manually close the stream.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1171.1">
     When running the script, the output is:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1172.1">$ python string_io.py
Learning Python Programming.
</span><span class="koboSpan" id="kobo.1172.2">Become a Python ninja!
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1173.1">
     Let us now proceed with the second example.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-240">
    <span class="koboSpan" id="kobo.1174.1">
     Making HTTP requests
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1175.1">
     In this
    </span>
    <a id="_idIndexMarker806">
    </a>
    <span class="koboSpan" id="kobo.1176.1">
     section, we explore two examples of HTTP requests.
    </span>
    <span class="koboSpan" id="kobo.1176.2">
     We will use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1177.1">
      requests
     </span>
    </code>
    <span class="koboSpan" id="kobo.1178.1">
     library for these examples, which you can install with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1179.1">
      pip
     </span>
    </code>
    <span class="koboSpan" id="kobo.1180.1">
     , and it is included in the requirements file for this chapter.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1181.1">
     We are going to perform HTTP requests against the httpbin.org (
    </span>
    <a href="https://httpbin.org/">
     <span class="url">
      <span class="koboSpan" id="kobo.1182.1">
       https://httpbin.org/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1183.1">
     ) API, which, interestingly, was developed by Kenneth Reitz, the creator of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1184.1">
      requests
     </span>
    </code>
    <span class="koboSpan" id="kobo.1185.1">
     library.
    </span>
    <span class="koboSpan" id="kobo.1185.2">
     Httpbin is a simple HTTP request and response service that is useful when we want to experiment with the HTTP protocol.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1186.1">
     This library is among the most widely adopted:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1187.1"># io_examples/reqs.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1188.1">import</span></span><span class="koboSpan" id="kobo.1189.1"> requests
urls = {
    "get": "https://httpbin.org/get?t=learn+python+programming",
    "headers": "https://httpbin.org/headers",
    "ip": "https://httpbin.org/ip",
    "user-agent": "https://httpbin.org/user-agent",
    "UUID": "https://httpbin.org/uuid",
    "JSON": "https://httpbin.org/json",
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1190.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1191.1">get_content</span></span><span class="koboSpan" id="kobo.1192.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1193.1">title, url</span></span><span class="koboSpan" id="kobo.1194.1">):
    resp = requests.get(url)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1195.1">print</span></span><span class="koboSpan" id="kobo.1196.1">(f"Response </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1197.1">for</span></span><span class="koboSpan" id="kobo.1198.1"> {title}")
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1199.1">print</span></span><span class="koboSpan" id="kobo.1200.1">(resp.json())
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1201.1">for</span></span><span class="koboSpan" id="kobo.1202.1"> title, url </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1203.1">in</span></span><span class="koboSpan" id="kobo.1204.1"> urls.items():
    get_content(title, url)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1205.1">print</span></span><span class="koboSpan" id="kobo.1206.1">("-" * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1207.1">40</span></span><span class="koboSpan" id="kobo.1208.1">)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1209.1">
     The
    </span>
    <a id="_idIndexMarker807">
    </a>
    <span class="koboSpan" id="kobo.1210.1">
     preceding snippet should be straightforward.
    </span>
    <span class="koboSpan" id="kobo.1210.2">
     We declare a dictionary of URLs against which we want to perform HTTP requests.
    </span>
    <span class="koboSpan" id="kobo.1210.3">
     We have encapsulated the code that performs the request into the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1211.1">
      get_content()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1212.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1212.2">
     As you can see, we perform a GET request (by using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1213.1">
      requests.get()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1214.1">
     ), and we print the title and the JSON-decoded version of the body of the response.
    </span>
    <span class="koboSpan" id="kobo.1214.2">
     Let us spend a few words on this last bit.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1215.1">
     When we perform a request to a website, or to an API, we get back a response object encapsulating the data that was returned by the server we performed the request against.
    </span>
    <span class="koboSpan" id="kobo.1215.2">
     The body of some responses from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1216.1">
      httpbin.org
     </span>
    </code>
    <span class="koboSpan" id="kobo.1217.1">
     happens to be JSON encoded, so instead of getting the body as it is (by reading
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1218.1">
      resp.text
     </span>
    </code>
    <span class="koboSpan" id="kobo.1219.1">
     ) and manually decoding it by calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1220.1">
      json.loads()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1221.1">
     on it, we simply combine the two by using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1222.1">
      json()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1223.1">
     method of the response object.
    </span>
    <span class="koboSpan" id="kobo.1223.2">
     There are plenty of reasons why the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1224.1">
      requests
     </span>
    </code>
    <span class="koboSpan" id="kobo.1225.1">
     package has become so widely adopted, and one of them is its ease of use.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1226.1">
     Now, when you perform a request in your application, you will want to have a much more robust approach for dealing with errors and so on, but for this chapter, a simple example will do.
    </span>
    <span class="koboSpan" id="kobo.1226.2">
     We will see more examples of requests in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.1227.1">
      Chapter 14
     </span>
    </em>
    <span class="koboSpan" id="kobo.1228.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.1229.1">
      Introduction to API Development
     </span>
    </em>
    <span class="koboSpan" id="kobo.1230.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1231.1">
     Going back to our code, in the end, we run a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1232.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1233.1">
     loop and get all the URLs.
    </span>
    <span class="koboSpan" id="kobo.1233.2">
     When you run it, you will see the result of each call printed on your console, which should look like this (prettified and trimmed for brevity):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1234.1">$ python reqs.py
Response for get
{
    "args": {"t": "learn python programming"},
    "headers": {
        "Accept": "*/*",
        "Accept-Encoding": "gzip, deflate",
        "Host": "httpbin.org",
        "User-Agent": "python-requests/2.31.0",
        "X-Amzn-Trace-Id": "Root=1-123abc-123abc",
    },
    "origin": "86.14.44.233",
    "url": "https://httpbin.org/get?t=learn+python+programming",
}
… rest of the output omitted …
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1235.1">
     Notice that
    </span>
    <a id="_idIndexMarker808">
    </a>
    <span class="koboSpan" id="kobo.1236.1">
     you might get a slightly different output in terms of version numbers and IPs, which is fine.
    </span>
    <span class="koboSpan" id="kobo.1236.2">
     Now,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1237.1">
      GET
     </span>
    </code>
    <span class="koboSpan" id="kobo.1238.1">
     is only one of the HTTP verbs, albeit one of the most commonly used.
    </span>
    <span class="koboSpan" id="kobo.1238.2">
     Let us also look at how to use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1239.1">
      POST
     </span>
    </code>
    <span class="koboSpan" id="kobo.1240.1">
     verb.
    </span>
    <span class="koboSpan" id="kobo.1240.2">
     This is the type of request you make when you need to send data to the server, for example, to request the creation of a resource.
    </span>
    <span class="koboSpan" id="kobo.1240.3">
     Every time you submit a form on the web, you are making a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1241.1">
      POST
     </span>
    </code>
    <span class="koboSpan" id="kobo.1242.1">
     request.
    </span>
    <span class="koboSpan" id="kobo.1242.2">
     So, let us try to make one programmatically:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1243.1"># io_examples/reqs_post.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1244.1">import</span></span><span class="koboSpan" id="kobo.1245.1"> requests
url = "https://httpbin.org/post"
data = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1246.1">dict</span></span><span class="koboSpan" id="kobo.1247.1">(title="Learn Python Programming")
resp = requests.post(url, data=data)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1248.1">print</span></span><span class="koboSpan" id="kobo.1249.1">("Response </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1250.1">for</span></span><span class="koboSpan" id="kobo.1251.1"> POST")
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1252.1">print</span></span><span class="koboSpan" id="kobo.1253.1">(resp.json())
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1254.1">
     The preceding code is very similar to what we saw before, only this time we don’t call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1255.1">
      get()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1256.1">
     , but
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1257.1">
      post()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1258.1">
     , and because we want to send some data, we specify that in the call.
    </span>
    <span class="koboSpan" id="kobo.1258.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1259.1">
      requests
     </span>
    </code>
    <span class="koboSpan" id="kobo.1260.1">
     library offers much more than this.
    </span>
    <span class="koboSpan" id="kobo.1260.2">
     It is a project that we encourage you to check out and explore, as it is quite likely you will be using it too.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1261.1">
     Running the previous script (and applying some prettifying magic to the output) yields the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1262.1">$ python reqs_post.py
Response for POST
{
    "args": {},
    "data": "",
    "files": {},
    "form": {"title": "Learn Python Programming"},
    "headers": {
        "Accept": "*/*",
        "Accept-Encoding": "gzip, deflate",
        "Content-Length": "30",
        "Content-Type": "application/x-www-form-urlencoded",
        "Host": "httpbin.org",
        "User-Agent": "python-requests/2.31.0",
        "X-Amzn-Trace-Id": "Root=1-123abc-123abc",
    },
    "json": None,
    "origin": "86.14.44.233",
    "url": "https://httpbin.org/post",
}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1263.1">
     Notice how
    </span>
    <a id="_idIndexMarker809">
    </a>
    <span class="koboSpan" id="kobo.1264.1">
     the headers are now different, and we find the data we sent in the form of a key/value pair of the response body.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1265.1">
     We hope these short examples are enough to get you started, especially with requests.
    </span>
    <span class="koboSpan" id="kobo.1265.2">
     The web changes every day, so it is worth learning the basics and then brushing up every now and then.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-241">
    <span class="koboSpan" id="kobo.1266.1">
     Persisting data on disk
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1267.1">
     In this section of
    </span>
    <a id="_idIndexMarker810">
    </a>
    <span class="koboSpan" id="kobo.1268.1">
     this chapter, we will look at how to persist data on disk in three different formats.
    </span>
    <span class="koboSpan" id="kobo.1268.2">
     To persist data means that the data is written to non-volatile storage, like a hard drive, for example, and it is not deleted when the process that wrote it ends its life cycle.
    </span>
    <span class="koboSpan" id="kobo.1268.3">
     We will explore the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1269.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.1270.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1271.1">
      shelve
     </span>
    </code>
    <span class="koboSpan" id="kobo.1272.1">
     modules, as well as a short example that will involve accessing a database
    </span>
    <a id="_idIndexMarker811">
    </a>
    <span class="koboSpan" id="kobo.1273.1">
     using
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1274.1">
      SQLAlchemy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1275.1">
     , perhaps the most widely adopted ORM library in the Python ecosystem.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-242">
    <span class="koboSpan" id="kobo.1276.1">
     Serializing data with pickle
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1277.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1278.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.1279.1">
     module, from
    </span>
    <a id="_idIndexMarker812">
    </a>
    <span class="koboSpan" id="kobo.1280.1">
     the Python
    </span>
    <a id="_idIndexMarker813">
    </a>
    <span class="koboSpan" id="kobo.1281.1">
     standard library, offers tools to convert Python objects into byte streams, and vice versa.
    </span>
    <span class="koboSpan" id="kobo.1281.2">
     Even though there is a partial overlap in the API that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1282.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.1283.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1284.1">
      json
     </span>
    </code>
    <span class="koboSpan" id="kobo.1285.1">
     expose, the two are quite different.
    </span>
    <span class="koboSpan" id="kobo.1285.2">
     As we have seen previously in this chapter, JSON is a text format that is human readable, language independent, and supports only a restricted subset of Python data types.
    </span>
    <span class="koboSpan" id="kobo.1285.3">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1286.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.1287.1">
     module, on the other hand, is not human readable, translates to bytes, is Python-specific, and, thanks to the wonderful Python introspection capabilities, supports a large number of data types.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1288.1">
     Besides these differences between
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1289.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.1290.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1291.1">
      json
     </span>
    </code>
    <span class="koboSpan" id="kobo.1292.1">
     , there are also some important security concerns that you need to be aware of if you are considering using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1293.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.1294.1">
     .
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1295.1">
      Unpickling
     </span>
    </em>
    <span class="koboSpan" id="kobo.1296.1">
     erroneous or malicious data from an untrusted source can be dangerous, so if we decide
    </span>
    <a id="_idIndexMarker814">
    </a>
    <span class="koboSpan" id="kobo.1297.1">
     to adopt it in our application, we need to be extra careful.
    </span>
   </p>
   <div class="packt_tip">
    <p class="normal">
     <span class="koboSpan" id="kobo.1298.1">
      If you do use
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1299.1">
       pickle
      </span>
     </code>
     <span class="koboSpan" id="kobo.1300.1">
      , you should consider using a cryptographic signature to ensure that your pickled data has not been tampered with.
     </span>
     <span class="koboSpan" id="kobo.1300.2">
      We will see how to generate cryptographic signatures in Python in
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.1301.1">
       Chapter 9
      </span>
     </em>
     <span class="koboSpan" id="kobo.1302.1">
      ,
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.1303.1">
       Cryptography and Tokens
      </span>
     </em>
     <span class="koboSpan" id="kobo.1304.1">
      .
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.1305.1">
     That said, let us see it in action by means of a simple example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1306.1"># persistence/pickler.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1307.1">import</span></span><span class="koboSpan" id="kobo.1308.1"> pickle
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1309.1">from</span></span><span class="koboSpan" id="kobo.1310.1"> dataclasses </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1311.1">import</span></span><span class="koboSpan" id="kobo.1312.1"> dataclass
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1313.1">@dataclass</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1314.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1315.1">Person</span></span><span class="koboSpan" id="kobo.1316.1">:
    first_name: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1317.1">str</span></span><span class="koboSpan" id="kobo.1318.1">
    last_name: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1319.1">str</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.1320.1">id</span></span><span class="koboSpan" id="kobo.1321.1">: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1322.1">int</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1323.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1324.1">greet</span></span><span class="koboSpan" id="kobo.1325.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1326.1">self</span></span><span class="koboSpan" id="kobo.1327.1">):
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1328.1">print</span></span><span class="koboSpan" id="kobo.1329.1">(
            f"Hi, I am {</span><span class="hljs-variable"><span class="koboSpan" id="kobo.1330.1">self</span></span><span class="koboSpan" id="kobo.1331.1">.first_name} {</span><span class="hljs-variable"><span class="koboSpan" id="kobo.1332.1">self</span></span><span class="koboSpan" id="kobo.1333.1">.last_name}"
            f" </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1334.1">and</span></span><span class="koboSpan" id="kobo.1335.1"> my ID </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1336.1">is</span></span><span class="koboSpan" id="kobo.1337.1"> {</span><span class="hljs-variable"><span class="koboSpan" id="kobo.1338.1">self</span></span><span class="koboSpan" id="kobo.1339.1">.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1340.1">id</span></span><span class="koboSpan" id="kobo.1341.1">}"
        )
people = [
    Person("Obi-Wan", "Kenobi", </span><span class="hljs-number"><span class="koboSpan" id="kobo.1342.1">123</span></span><span class="koboSpan" id="kobo.1343.1">),
    Person("Anakin", "Skywalker", </span><span class="hljs-number"><span class="koboSpan" id="kobo.1344.1">456</span></span><span class="koboSpan" id="kobo.1345.1">),
]
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1346.1"># save data in binary format to a file</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1347.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1348.1">open</span></span><span class="koboSpan" id="kobo.1349.1">("data.pickle", "wb") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1350.1">as</span></span><span class="koboSpan" id="kobo.1351.1"> stream:
    pickle.dump(people, stream)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1352.1"># load data from a file</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1353.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1354.1">open</span></span><span class="koboSpan" id="kobo.1355.1">("data.pickle", "rb") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1356.1">as</span></span><span class="koboSpan" id="kobo.1357.1"> stream:
    peeps = pickle.load(stream)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1358.1">for</span></span><span class="koboSpan" id="kobo.1359.1"> person </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1360.1">in</span></span><span class="koboSpan" id="kobo.1361.1"> peeps:
    person.greet()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1362.1">
     In this
    </span>
    <a id="_idIndexMarker815">
    </a>
    <span class="koboSpan" id="kobo.1363.1">
     example, we create a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1364.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1365.1">
     class using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1366.1">
      dataclass
     </span>
    </code>
    <span class="koboSpan" id="kobo.1367.1">
     decorator, which we saw in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.1368.1">
      Chapter 6
     </span>
    </em>
    <span class="koboSpan" id="kobo.1369.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.1370.1">
      OOP, Decorators, and Iterators
     </span>
    </em>
    <span class="koboSpan" id="kobo.1371.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1371.2">
     The only reason we wrote this example using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1372.1">
      dataclass
     </span>
    </code>
    <span class="koboSpan" id="kobo.1373.1">
     is to show you how effortlessly
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1374.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.1375.1">
     deals with it, with no need for us to do anything we would not do for a simpler data type.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1376.1">
     The class has three attributes:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1377.1">
      first_name
     </span>
    </code>
    <span class="koboSpan" id="kobo.1378.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1379.1">
      last_name
     </span>
    </code>
    <span class="koboSpan" id="kobo.1380.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1381.1">
      id
     </span>
    </code>
    <span class="koboSpan" id="kobo.1382.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1382.2">
     It also exposes a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1383.1">
      greet()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1384.1">
     method, which prints a hello message with the instance data.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1385.1">
     We create a list of instances and save it to a file.
    </span>
    <span class="koboSpan" id="kobo.1385.2">
     In order to do so, we use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1386.1">
      pickle.dump()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1387.1">
     , to which we feed the content to be
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1388.1">
      pickled
     </span>
    </em>
    <span class="koboSpan" id="kobo.1389.1">
     , and the stream to which we want to write.
    </span>
    <span class="koboSpan" id="kobo.1389.2">
     Immediately after that, we read from that same file, using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1390.1">
      pickle.load()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1391.1">
     to convert the entire content of the stream back into Python objects.
    </span>
    <span class="koboSpan" id="kobo.1391.2">
     To make sure that the objects have been converted correctly, we call the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1392.1">
      greet()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1393.1">
     method on both of them.
    </span>
    <span class="koboSpan" id="kobo.1393.2">
     The result is the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1394.1">$ python pickler.py
Hi, I am Obi-Wan Kenobi and my ID is 123
Hi, I am Anakin Skywalker and my ID is 456
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1395.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1396.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.1397.1">
     module also allows you to convert to (and from) byte objects, by means of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1398.1">
      dumps()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1399.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1400.1">
      loads()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1401.1">
     functions (note the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1402.1">
      s
     </span>
    </code>
    <span class="koboSpan" id="kobo.1403.1">
     at the end of both names).
    </span>
    <span class="koboSpan" id="kobo.1403.2">
     In day-to-day applications,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1404.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.1405.1">
     is usually used when we need to persist Python data that is not supposed to be exchanged with another application.
    </span>
    <span class="koboSpan" id="kobo.1405.2">
     One example we stumbled upon a few years ago was the session manager of a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1406.1">
      flask
     </span>
    </code>
    <span class="koboSpan" id="kobo.1407.1">
     plugin, which pickles the session object before storing it in a Redis database.
    </span>
    <span class="koboSpan" id="kobo.1407.2">
     In practice, though, you are unlikely to have to deal with this library very often.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1408.1">
     Another tool that is possibly used even less, but that proves to be useful when you are short on resources, is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1409.1">
      shelve
     </span>
    </code>
    <span class="koboSpan" id="kobo.1410.1">
     .
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-243">
    <span class="koboSpan" id="kobo.1411.1">
     Saving data with shelve
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1412.1">
     A “shelf” is a
    </span>
    <a id="_idIndexMarker816">
    </a>
    <span class="koboSpan" id="kobo.1413.1">
     persistent dictionary-like object.
    </span>
    <span class="koboSpan" id="kobo.1413.2">
     The beauty of it is that the values you save into a shelf can be any objects you can
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1414.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.1415.1">
     , so you’re not restricted like you would be if you were using a database.
    </span>
    <span class="koboSpan" id="kobo.1415.2">
     Albeit interesting and useful, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1416.1">
      shelve
     </span>
    </code>
    <span class="koboSpan" id="kobo.1417.1">
     module is used quite rarely in practice.
    </span>
    <span class="koboSpan" id="kobo.1417.2">
     Just for completeness, let us see a quick example of how it works:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1418.1"># persistence/shelf.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1419.1">import</span></span><span class="koboSpan" id="kobo.1420.1"> shelve
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1421.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1422.1">Person</span></span><span class="koboSpan" id="kobo.1423.1">:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1424.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1425.1">__init__</span></span><span class="koboSpan" id="kobo.1426.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1427.1">self, name, </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1428.1">id</span></span><span class="koboSpan" id="kobo.1429.1">):
        </span><span class="hljs-variable"><span class="koboSpan" id="kobo.1430.1">self</span></span><span class="koboSpan" id="kobo.1431.1">.name = name
        </span><span class="hljs-variable"><span class="koboSpan" id="kobo.1432.1">self</span></span><span class="koboSpan" id="kobo.1433.1">.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1434.1">id</span></span><span class="koboSpan" id="kobo.1435.1"> = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1436.1">id</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1437.1">with</span></span><span class="koboSpan" id="kobo.1438.1"> shelve.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1439.1">open</span></span><span class="koboSpan" id="kobo.1440.1">("shelf1.shelve") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1441.1">as</span></span><span class="koboSpan" id="kobo.1442.1"> db:
    db["obi1"] = Person("Obi-Wan", </span><span class="hljs-number"><span class="koboSpan" id="kobo.1443.1">123</span></span><span class="koboSpan" id="kobo.1444.1">)
    db["ani"] = Person("Anakin", </span><span class="hljs-number"><span class="koboSpan" id="kobo.1445.1">456</span></span><span class="koboSpan" id="kobo.1446.1">)
    db["a_list"] = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.1447.1">2</span></span><span class="koboSpan" id="kobo.1448.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1449.1">3</span></span><span class="koboSpan" id="kobo.1450.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1451.1">5</span></span><span class="koboSpan" id="kobo.1452.1">]
    db["delete_me"] = "we will have to delete this one..."
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1453.1">print</span></span><span class="koboSpan" id="kobo.1454.1">(
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1455.1">list</span></span><span class="koboSpan" id="kobo.1456.1">(db.keys())
    )  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1457.1"># ['ani', 'delete_me', 'a_list', 'obi1']</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1458.1">del</span></span><span class="koboSpan" id="kobo.1459.1"> db["delete_me"]  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1460.1"># gone!</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.1461.1">print</span></span><span class="koboSpan" id="kobo.1462.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1463.1">list</span></span><span class="koboSpan" id="kobo.1464.1">(db.keys()))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1465.1"># ['ani', 'a_list', 'obi1']</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.1466.1">print</span></span><span class="koboSpan" id="kobo.1467.1">("delete_me" </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1468.1">in</span></span><span class="koboSpan" id="kobo.1469.1"> db)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1470.1"># False</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.1471.1">print</span></span><span class="koboSpan" id="kobo.1472.1">("ani" </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1473.1">in</span></span><span class="koboSpan" id="kobo.1474.1"> db)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1475.1"># True</span></span><span class="koboSpan" id="kobo.1476.1">
    a_list = db["a_list"]
    a_list.append(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1477.1">7</span></span><span class="koboSpan" id="kobo.1478.1">)
    db["a_list"] = a_list
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1479.1">print</span></span><span class="koboSpan" id="kobo.1480.1">(db["a_list"])  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1481.1"># [2, 3, 5, 7]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1482.1">
     Apart from
    </span>
    <a id="_idIndexMarker817">
    </a>
    <span class="koboSpan" id="kobo.1483.1">
     the wiring and the boilerplate around it, this example resembles an exercise with dictionaries.
    </span>
    <span class="koboSpan" id="kobo.1483.2">
     We create a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1484.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1485.1">
     class and then we open a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1486.1">
      shelve
     </span>
    </code>
    <span class="koboSpan" id="kobo.1487.1">
     file within a context manager.
    </span>
    <span class="koboSpan" id="kobo.1487.2">
     As you can see, we use the dictionary syntax to store four objects: two
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1488.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1489.1">
     instances, a list, and a string.
    </span>
    <span class="koboSpan" id="kobo.1489.2">
     If we print the keys, we get a list containing the four keys we used.
    </span>
    <span class="koboSpan" id="kobo.1489.3">
     Immediately after printing it, we delete the (aptly named)
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1490.1">
      delete_me
     </span>
    </code>
    <span class="koboSpan" id="kobo.1491.1">
     key/value pair from the shelf.
    </span>
    <span class="koboSpan" id="kobo.1491.2">
     Printing the keys again shows the deletion has succeeded.
    </span>
    <span class="koboSpan" id="kobo.1491.3">
     We then test a couple of keys for membership and, finally, we append number
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1492.1">
      7
     </span>
    </code>
    <span class="koboSpan" id="kobo.1493.1">
     to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1494.1">
      a_list
     </span>
    </code>
    <span class="koboSpan" id="kobo.1495.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1495.2">
     Notice how we have to extract the list from the shelf, modify it, and save it again.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1496.1">
     There is another way to open a shelf that speeds up the process a bit:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1497.1"># persistence/shelf.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1498.1">with</span></span><span class="koboSpan" id="kobo.1499.1"> shelve.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1500.1">open</span></span><span class="koboSpan" id="kobo.1501.1">("shelf2.shelve", writeback=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1502.1">True</span></span><span class="koboSpan" id="kobo.1503.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1504.1">as</span></span><span class="koboSpan" id="kobo.1505.1"> db:
    db["a_list"] = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.1506.1">11</span></span><span class="koboSpan" id="kobo.1507.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1508.1">13</span></span><span class="koboSpan" id="kobo.1509.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1510.1">17</span></span><span class="koboSpan" id="kobo.1511.1">]
    db["a_list"].append(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1512.1">19</span></span><span class="koboSpan" id="kobo.1513.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1514.1"># in-place append!</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.1515.1">print</span></span><span class="koboSpan" id="kobo.1516.1">(db["a_list"])  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1517.1"># [11, 13, 17, 19]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1518.1">
     By
    </span>
    <a id="_idIndexMarker818">
    </a>
    <span class="koboSpan" id="kobo.1519.1">
     opening the shelf with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1520.1">
      writeback=True
     </span>
    </code>
    <span class="koboSpan" id="kobo.1521.1">
     , we enable the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1522.1">
      writeback
     </span>
    </code>
    <span class="koboSpan" id="kobo.1523.1">
     feature, which allows us to simply append to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1524.1">
      a_list
     </span>
    </code>
    <span class="koboSpan" id="kobo.1525.1">
     as if it was a value within a regular dictionary.
    </span>
    <span class="koboSpan" id="kobo.1525.2">
     The reason this feature is not active by default is that it comes with a price that you pay in terms of memory consumption and slower closing of the shelf.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1526.1">
     Now that we have paid homage to the standard library modules related to data persistence, let us look at one of the most widely adopted ORMs in the Python ecosystem: SQLAlchemy.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-244">
    <span class="koboSpan" id="kobo.1527.1">
     Saving data to a database
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1528.1">
     For this
    </span>
    <a id="_idIndexMarker819">
    </a>
    <span class="koboSpan" id="kobo.1529.1">
     example, we are going to work with an in-memory database, which will make things simpler for us.
    </span>
    <span class="koboSpan" id="kobo.1529.2">
     In the source code of the book, we have left a couple of comments to show you how to generate a SQLite file, so we hope you’ll explore that option as well.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1530.1">
      You can find a free database browser for SQLite at
     </span>
     <a href="https://dbeaver.io/">
      <span class="url">
       <span class="koboSpan" id="kobo.1531.1">
        https://dbeaver.io/
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1532.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1532.2">
      DBeaver is a free
     </span>
     <a id="_idIndexMarker820">
     </a>
     <span class="koboSpan" id="kobo.1533.1">
      multi-platform database tool for developers, database administrators, analysts, and all people who need to work with databases.
     </span>
     <span class="koboSpan" id="kobo.1533.2">
      It supports all popular databases: MySQL, PostgreSQL, SQLite, Oracle, DB2, SQL Server, Sybase, MS Access, Teradata, Firebird, Apache Hive, Phoenix, Presto, etc.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.1534.1">
     Before we dive into the code, allow us to briefly introduce the concept of a relational database.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1535.1">
     A relational database
    </span>
    <a id="_idIndexMarker821">
    </a>
    <span class="koboSpan" id="kobo.1536.1">
     is a database that allows you to save data following the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1537.1">
      relational model
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1538.1">
     , invented in 1969 by Edgar F.
    </span>
    <span class="koboSpan" id="kobo.1538.2">
     Codd.
    </span>
    <span class="koboSpan" id="kobo.1538.3">
     In this model, data is stored in one or more tables.
    </span>
    <span class="koboSpan" id="kobo.1538.4">
     Each table has rows (also known as
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1539.1">
      records
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1540.1">
     , or
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1541.1">
      tuples
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1542.1">
     ), each of which represents an entry in the table.
    </span>
    <span class="koboSpan" id="kobo.1542.2">
     Tables also have columns (also known as
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1543.1">
      attributes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1544.1">
     ), each of which represents an attribute of the records.
    </span>
    <span class="koboSpan" id="kobo.1544.2">
     Each record is identified through a unique key, more commonly known as the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1545.1">
      primary key
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1546.1">
     , which consists of one or more columns in the table.
    </span>
    <span class="koboSpan" id="kobo.1546.2">
     To give you an example: imagine a table called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1547.1">
      Users
     </span>
    </code>
    <span class="koboSpan" id="kobo.1548.1">
     , with columns
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1549.1">
      id
     </span>
    </code>
    <span class="koboSpan" id="kobo.1550.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1551.1">
      username
     </span>
    </code>
    <span class="koboSpan" id="kobo.1552.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1553.1">
      password
     </span>
    </code>
    <span class="koboSpan" id="kobo.1554.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1555.1">
      name
     </span>
    </code>
    <span class="koboSpan" id="kobo.1556.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1557.1">
      surname
     </span>
    </code>
    <span class="koboSpan" id="kobo.1558.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1559.1">
     Such a table would be suitable for containing users of our system; each row would represent a different user.
    </span>
    <span class="koboSpan" id="kobo.1559.2">
     For example, a row with the values
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1560.1">
      3
     </span>
    </code>
    <span class="koboSpan" id="kobo.1561.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1562.1">
      fab
     </span>
    </code>
    <span class="koboSpan" id="kobo.1563.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1564.1">
      my_wonderful_pwd
     </span>
    </code>
    <span class="koboSpan" id="kobo.1565.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1566.1">
      Fabrizio
     </span>
    </code>
    <span class="koboSpan" id="kobo.1567.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1568.1">
      Romano
     </span>
    </code>
    <span class="koboSpan" id="kobo.1569.1">
     would represent Fabrizio’s user in the system.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1570.1">
     The
    </span>
    <a id="_idIndexMarker822">
    </a>
    <span class="koboSpan" id="kobo.1571.1">
     model is called
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1572.1">
      relational
     </span>
    </em>
    <span class="koboSpan" id="kobo.1573.1">
     because you can establish relations between tables.
    </span>
    <span class="koboSpan" id="kobo.1573.2">
     For example, if you added a table called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1574.1">
      PhoneNumbers
     </span>
    </code>
    <span class="koboSpan" id="kobo.1575.1">
     to this database, you could insert phone numbers into it, and then, through a relation, establish which phone number belongs to which user.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1576.1">
     To query a relational database, we need a special language.
    </span>
    <span class="koboSpan" id="kobo.1576.2">
     The main standard is called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1577.1">
      SQL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1578.1">
     , which stands
    </span>
    <a id="_idIndexMarker823">
    </a>
    <span class="koboSpan" id="kobo.1579.1">
     for
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1580.1">
      Structured Query Language
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1581.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1581.2">
     It originates
    </span>
    <a id="_idIndexMarker824">
    </a>
    <span class="koboSpan" id="kobo.1582.1">
     from
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1583.1">
      relational algebra
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1584.1">
     , which is a formal system and theoretical framework for manipulating and querying data stored in relational databases.
    </span>
    <span class="koboSpan" id="kobo.1584.2">
     The most common operations you can perform usually involve filtering on the rows or columns, joining tables, aggregating the results according to some criteria, and so on.
    </span>
    <span class="koboSpan" id="kobo.1584.3">
     To give you an example in English, a query on our imaginary database could be:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1585.1">
      Fetch all users (username, name, surname) whose username starts with “m” and who have at most one phone number
     </span>
    </em>
    <span class="koboSpan" id="kobo.1586.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1586.2">
     In this example, we are querying for a subset of the rows in the database, and are only interested in three of the columns in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1587.1">
      User
     </span>
    </code>
    <span class="koboSpan" id="kobo.1588.1">
     table for the results.
    </span>
    <span class="koboSpan" id="kobo.1588.2">
     We are filtering on users by taking only those whose username starts with the letter
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1589.1">
      m
     </span>
    </em>
    <span class="koboSpan" id="kobo.1590.1">
     , and even further, only those who have at most one phone number.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1591.1">
     Each database comes with its own
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1592.1">
      flavor
     </span>
    </em>
    <span class="koboSpan" id="kobo.1593.1">
     of SQL.
    </span>
    <span class="koboSpan" id="kobo.1593.2">
     They all respect the standard to some extent, but none fully do, and they are all different from one another in some respects.
    </span>
    <span class="koboSpan" id="kobo.1593.3">
     This poses an issue in modern software development.
    </span>
    <span class="koboSpan" id="kobo.1593.4">
     If our application contained raw SQL code, it is quite likely that if we decided to use a different database engine, or maybe a different version of the same engine, we would need to amend the SQL code in our application.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1594.1">
     This can be quite painful, especially since SQL queries can be quite complex.
    </span>
    <span class="koboSpan" id="kobo.1594.2">
     To alleviate this issue, computer scientists have created code that maps objects of a programming language to tables of a relational database.
    </span>
    <span class="koboSpan" id="kobo.1594.3">
     Unsurprisingly, the
    </span>
    <a id="_idIndexMarker825">
    </a>
    <span class="koboSpan" id="kobo.1595.1">
     name of such a tool is
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1596.1">
      Object-Relational Mapping
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1597.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1598.1">
      ORM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1599.1">
     ).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1600.1">
     In modern application development, one would normally start interacting with a database by using an ORM.
    </span>
    <span class="koboSpan" id="kobo.1600.2">
     Should they then find themselves in a situation where they cannot perform a certain query through the ORM, they would then, and only then, resort to using SQL directly.
    </span>
    <span class="koboSpan" id="kobo.1600.3">
     This is a good compromise between having no SQL at all and using no ORM, which means specializing the code that interacts with the database, with the aforementioned disadvantages.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1601.1">
     In this section, we would like to show an example that leverages SQLAlchemy, one of the most popular third-party Python ORMs.
    </span>
    <span class="koboSpan" id="kobo.1601.2">
     You will have to install it into the virtual environment for this chapter.
    </span>
    <span class="koboSpan" id="kobo.1601.3">
     We are going to define two models (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1602.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1603.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1604.1">
      Email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1605.1">
     ), each of
    </span>
    <a id="_idIndexMarker826">
    </a>
    <span class="koboSpan" id="kobo.1606.1">
     which maps to a table, and then we are going to populate the database and perform a few queries on it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1607.1">
     Let us start with the model declarations:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1608.1"># persistence/alchemy_models.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1609.1">from</span></span><span class="koboSpan" id="kobo.1610.1"> sqlalchemy </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1611.1">import</span></span><span class="koboSpan" id="kobo.1612.1"> ForeignKey, String, Integer
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1613.1">from</span></span><span class="koboSpan" id="kobo.1614.1"> sqlalchemy.orm </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1615.1">import</span></span><span class="koboSpan" id="kobo.1616.1"> (
    DeclarativeBase,
    mapped_column,
    relationship,
)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1617.1">
     At the beginning, we import some functions and types.
    </span>
    <span class="koboSpan" id="kobo.1617.2">
     We then proceed to write the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1618.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1619.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1620.1">
      Email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1621.1">
     classes, as well as the mandatory base class for them.
    </span>
    <span class="koboSpan" id="kobo.1621.2">
     Let us see these definitions:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1622.1"># persistence/alchemy_models.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1623.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1624.1">Base</span></span><span class="koboSpan" id="kobo.1625.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1626.1">DeclarativeBase</span></span><span class="koboSpan" id="kobo.1627.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1628.1">pass</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1629.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1630.1">Person</span></span><span class="koboSpan" id="kobo.1631.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1632.1">Base</span></span><span class="koboSpan" id="kobo.1633.1">):
    __tablename__ = "person"
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1634.1">id</span></span><span class="koboSpan" id="kobo.1635.1"> = mapped_column(Integer, primary_key=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1636.1">True</span></span><span class="koboSpan" id="kobo.1637.1">)
    name = mapped_column(String)
    age = mapped_column(Integer)
    emails = relationship(
        "Email",
        back_populates="person",
        order_by="Email.email",
        cascade="</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1638.1">all</span></span><span class="koboSpan" id="kobo.1639.1">, delete-orphan",
    )
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1640.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1641.1">__repr__</span></span><span class="koboSpan" id="kobo.1642.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1643.1">self</span></span><span class="koboSpan" id="kobo.1644.1">):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1645.1">return</span></span><span class="koboSpan" id="kobo.1646.1"> f"{</span><span class="hljs-variable"><span class="koboSpan" id="kobo.1647.1">self</span></span><span class="koboSpan" id="kobo.1648.1">.name}(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1649.1">id</span></span><span class="koboSpan" id="kobo.1650.1">={</span><span class="hljs-variable"><span class="koboSpan" id="kobo.1651.1">self</span></span><span class="koboSpan" id="kobo.1652.1">.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1653.1">id</span></span><span class="koboSpan" id="kobo.1654.1">})"
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1655.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1656.1">Email</span></span><span class="koboSpan" id="kobo.1657.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1658.1">Base</span></span><span class="koboSpan" id="kobo.1659.1">):
    __tablename__ = "email"
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1660.1">id</span></span><span class="koboSpan" id="kobo.1661.1"> = mapped_column(Integer, primary_key=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1662.1">True</span></span><span class="koboSpan" id="kobo.1663.1">)
    email = mapped_column(String)
    person_id = mapped_column(ForeignKey("person.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1664.1">id</span></span><span class="koboSpan" id="kobo.1665.1">"))
    person = relationship("Person", back_populates="emails")
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1666.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1667.1">__str__</span></span><span class="koboSpan" id="kobo.1668.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1669.1">self</span></span><span class="koboSpan" id="kobo.1670.1">):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1671.1">return</span></span> <span class="hljs-variable"><span class="koboSpan" id="kobo.1672.1">self</span></span><span class="koboSpan" id="kobo.1673.1">.email
    __repr__ = __str__
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1674.1">
     Each
    </span>
    <a id="_idIndexMarker827">
    </a>
    <span class="koboSpan" id="kobo.1675.1">
     model inherits from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1676.1">
      Base
     </span>
    </code>
    <span class="koboSpan" id="kobo.1677.1">
     class, which in this example is a simple class that inherits from SQLAlchemy’s
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1678.1">
      DeclarativeBase
     </span>
    </code>
    <span class="koboSpan" id="kobo.1679.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1679.2">
     We define
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1680.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1681.1">
     , which maps to a table called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1682.1">
      "person"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1683.1">
     , and exposes the attributes
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1684.1">
      id
     </span>
    </code>
    <span class="koboSpan" id="kobo.1685.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1686.1">
      name
     </span>
    </code>
    <span class="koboSpan" id="kobo.1687.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1688.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.1689.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1689.2">
     We also declare a relationship with the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1690.1">
      Email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1691.1">
     model, by stating that accessing the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1692.1">
      emails
     </span>
    </code>
    <span class="koboSpan" id="kobo.1693.1">
     attribute will fetch all the entries in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1694.1">
      Email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1695.1">
     table that are related to the particular
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1696.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1697.1">
     instance we are dealing with.
    </span>
    <span class="koboSpan" id="kobo.1697.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1698.1">
      cascade
     </span>
    </code>
    <span class="koboSpan" id="kobo.1699.1">
     option affects how creation and deletion work, but it is a more advanced concept, so we suggest you ignore it for now and maybe investigate more later.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1700.1">
     The last thing we declare is the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1701.1">
      __repr__()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1702.1">
     method, which provides us with the official string representation of an object.
    </span>
    <span class="koboSpan" id="kobo.1702.2">
     This is supposed to be a representation that can be used to completely reconstruct the object, but in this example, we simply use it to provide something as output.
    </span>
    <span class="koboSpan" id="kobo.1702.3">
     Python redirects
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1703.1">
      repr(obj)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1704.1">
     to a call to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1705.1">
      obj.__repr__()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1706.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1707.1">
     We also declare the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1708.1">
      Email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1709.1">
     model, which maps to a table called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1710.1">
      "email"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1711.1">
     and will contain email addresses, and a reference to the person they belong to.
    </span>
    <span class="koboSpan" id="kobo.1711.2">
     You can see the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1712.1">
      person_id
     </span>
    </code>
    <span class="koboSpan" id="kobo.1713.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1714.1">
      person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1715.1">
     attributes are both about setting a relation between the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1716.1">
      Email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1717.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1718.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1719.1">
     classes.
    </span>
    <span class="koboSpan" id="kobo.1719.2">
     Note also how we declare the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1720.1">
      __str__()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1721.1">
     method on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1722.1">
      Email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1723.1">
     , and then assign an alias to it, called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1724.1">
      __repr__()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1725.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1725.2">
     This means that calling either
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1726.1">
      repr()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1727.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1728.1">
      str()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1729.1">
     on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1730.1">
      Email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1731.1">
     objects will ultimately result in calling the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1732.1">
      __str__()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1733.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.1733.2">
     This is quite a common technique in Python, used to avoid duplicating the same code, so we took the opportunity to show it to you here.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1734.1">
     A deeper understanding of this code would require more space than we can afford, so we encourage you to
    </span>
    <a id="_idIndexMarker828">
    </a>
    <span class="koboSpan" id="kobo.1735.1">
     read up on
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1736.1">
      database management systems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1737.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1738.1">
      DBMS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1739.1">
     ), SQL, relational algebra, and SQLAlchemy.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1740.1">
     Now that we have our models, let us use them to persist some data.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1741.1">
     Look at the following example (all the snippets presented here, until indicated otherwise, belong to the file
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1742.1">
      alchemy.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.1743.1">
     in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1744.1">
      persistence
     </span>
    </code>
    <span class="koboSpan" id="kobo.1745.1">
     folder):
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1746.1"># persistence/alchemy.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1747.1">from</span></span><span class="koboSpan" id="kobo.1748.1"> sqlalchemy </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1749.1">import</span></span><span class="koboSpan" id="kobo.1750.1"> create_engine, select, func
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1751.1">from</span></span><span class="koboSpan" id="kobo.1752.1"> sqlalchemy.orm </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1753.1">import</span></span><span class="koboSpan" id="kobo.1754.1"> Session
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1755.1">from</span></span><span class="koboSpan" id="kobo.1756.1"> alchemy_models </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1757.1">import</span></span><span class="koboSpan" id="kobo.1758.1"> Person, Email, Base
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1759.1"># swap these lines to work with an actual DB file</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1760.1"># engine = create_engine('sqlite:///example.db')</span></span><span class="koboSpan" id="kobo.1761.1">
engine = create_engine("sqlite:///:memory:")
Base.metadata.create_all(engine)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1762.1">
     First, we
    </span>
    <a id="_idIndexMarker829">
    </a>
    <span class="koboSpan" id="kobo.1763.1">
     import the functions and classes we need.
    </span>
    <span class="koboSpan" id="kobo.1763.2">
     We then proceed to create an engine for the application, and finally, we instruct SQLAlchemy to create all the tables through the given engine.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1764.1">
      The
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1765.1">
       create_engine()
      </span>
     </code>
     <span class="koboSpan" id="kobo.1766.1">
      function supports a parameter called
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1767.1">
       echo
      </span>
     </code>
     <span class="koboSpan" id="kobo.1768.1">
      , which can be set to
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1769.1">
       True
      </span>
     </code>
     <span class="koboSpan" id="kobo.1770.1">
      ,
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1771.1">
       False
      </span>
     </code>
     <span class="koboSpan" id="kobo.1772.1">
      , or the string
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1773.1">
       "debug"
      </span>
     </code>
     <span class="koboSpan" id="kobo.1774.1">
      , to enable different levels of logging of all statements and the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1775.1">
       repr()
      </span>
     </code>
     <span class="koboSpan" id="kobo.1776.1">
      of their parameters.
     </span>
     <span class="koboSpan" id="kobo.1776.2">
      Please refer to the official SQLAlchemy documentation for further information.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.1777.1">
     In SQLAlchemy, an engine is a core component that serves as the primary interface between Python applications and databases.
    </span>
    <span class="koboSpan" id="kobo.1777.2">
     It manages two crucial aspects of database interactions: connections and SQL statement execution.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1778.1">
     After the imports and creating the engine and tables, we set up a session via a context manager, using the engine we just created.
    </span>
    <span class="koboSpan" id="kobo.1778.2">
     We start by creating two
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1779.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1780.1">
     objects:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1781.1">with</span></span><span class="koboSpan" id="kobo.1782.1"> Session(engine) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1783.1">as</span></span><span class="koboSpan" id="kobo.1784.1"> session:
    anakin = Person(name="Anakin Skywalker", age=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1785.1">32</span></span><span class="koboSpan" id="kobo.1786.1">)
    obione = Person(name="Obi-Wan Kenobi", age=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1787.1">40</span></span><span class="koboSpan" id="kobo.1788.1">)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1789.1">
     We then add email addresses to both objects using two different techniques.
    </span>
    <span class="koboSpan" id="kobo.1789.2">
     One assigns them to a list, and the other one simply appends them:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1790.1">    obione.emails = [
        Email(email="obi1@example.com"),
        Email(email="wanwan@example.com"),
    ]
    anakin.emails.append(Email(email="ani@example.com"))
    anakin.emails.append(Email(email="evil.dart@example.com"))
    anakin.emails.append(Email(email="vader@example.com"))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1791.1">
     We have not touched the database yet.
    </span>
    <span class="koboSpan" id="kobo.1791.2">
     It is only when we use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1792.1">
      session
     </span>
    </code>
    <span class="koboSpan" id="kobo.1793.1">
     object that something actually happens in it:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1794.1">    session.add(anakin)
    session.add(obione)
    session.commit()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1795.1">
     Adding
    </span>
    <a id="_idIndexMarker830">
    </a>
    <span class="koboSpan" id="kobo.1796.1">
     the two
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1797.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1798.1">
     instances is enough to also add their email addresses (this is thanks to the cascading effect).
    </span>
    <span class="koboSpan" id="kobo.1798.2">
     Calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1799.1">
      commit()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1800.1">
     causes SQLAlchemy to commit the transaction and save the data in the database.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1801.1">
     A
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1802.1">
      transaction
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1803.1">
     is
    </span>
    <a id="_idIndexMarker831">
    </a>
    <span class="koboSpan" id="kobo.1804.1">
     an operation that provides something like a sandbox, but in a database context.
    </span>
    <span class="koboSpan" id="kobo.1804.2">
     As long as the transaction hasn’t been committed, we can roll back any modification we have done to the database, and by doing so, revert to the state we were in before starting the transaction itself.
    </span>
    <span class="koboSpan" id="kobo.1804.3">
     SQLAlchemy offers more complex and granular ways to deal with transactions, which you can study in its official documentation, as it is quite an advanced topic.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1805.1">
     We now query for all the people whose name starts with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1806.1">
      Obi
     </span>
    </code>
    <span class="koboSpan" id="kobo.1807.1">
     by using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1808.1">
      like()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1809.1">
     , which hooks to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1810.1">
      LIKE
     </span>
    </code>
    <span class="koboSpan" id="kobo.1811.1">
     operator in SQL:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1812.1">    obione = session.scalar(
        select(Person).where(Person.name.like("Obi%"))
    )
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1813.1">print</span></span><span class="koboSpan" id="kobo.1814.1">(obione, obione.emails)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1815.1">
     We take the first result of that query (we know we only have Obi-Wan anyway) and print it.
    </span>
    <span class="koboSpan" id="kobo.1815.2">
     We then fetch
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1816.1">
      anakin
     </span>
    </code>
    <span class="koboSpan" id="kobo.1817.1">
     by using an exact match on his name, just to show you another way of filtering:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1818.1">    anakin = session.scalar(
        select(Person).where(Person.name == "Anakin Skywalker")
    )
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1819.1">print</span></span><span class="koboSpan" id="kobo.1820.1">(anakin, anakin.emails)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1821.1">
     We then capture Anakin’s ID, and delete the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1822.1">
      anakin
     </span>
    </code>
    <span class="koboSpan" id="kobo.1823.1">
     object from the global frame (this does not delete the entry from the database):
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1824.1">    anakin_id = anakin.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1825.1">id</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1826.1">del</span></span><span class="koboSpan" id="kobo.1827.1"> anakin
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1828.1">
     The reason we do this is because we want to show you how to fetch an object by its ID.
    </span>
    <span class="koboSpan" id="kobo.1828.2">
     To display the full content of the database, we have written a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1829.1">
      display_info()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1830.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1830.2">
     It works by fetching the email addresses first and person objects later, through their relationship with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1831.1">
      Email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1832.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1832.2">
     It also provides a count of all objects per model.
    </span>
    <span class="koboSpan" id="kobo.1832.3">
     In the module, this function is
    </span>
    <a id="_idIndexMarker832">
    </a>
    <span class="koboSpan" id="kobo.1833.1">
     defined before entering the context manager that provides the session:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1834.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1835.1">display_info</span></span><span class="koboSpan" id="kobo.1836.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1837.1">session</span></span><span class="koboSpan" id="kobo.1838.1">):
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1839.1"># get all emails first</span></span><span class="koboSpan" id="kobo.1840.1">
    emails = select(Email)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1841.1"># display results</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.1842.1">print</span></span><span class="koboSpan" id="kobo.1843.1">("All emails:")
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1844.1">for</span></span><span class="koboSpan" id="kobo.1845.1"> email </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1846.1">in</span></span><span class="koboSpan" id="kobo.1847.1"> session.scalars(emails):
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1848.1">print</span></span><span class="koboSpan" id="kobo.1849.1">(f" - {email.person.name} &lt;{email.email}&gt;")
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1850.1"># display how many objects we have in total</span></span><span class="koboSpan" id="kobo.1851.1">
    people = session.scalar(
        select(func.count()).select_from(Person)
    )
    emails = session.scalar(
        select(func.count()).select_from(Email)
    )
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1852.1">print</span></span><span class="koboSpan" id="kobo.1853.1">("Summary:")
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1854.1">print</span></span><span class="koboSpan" id="kobo.1855.1">(f" {people=}, {emails=}")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1856.1">
     We call this function, then we fetch and delete
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1857.1">
      anakin
     </span>
    </code>
    <span class="koboSpan" id="kobo.1858.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1858.2">
     Finally, we display the info again to verify that he has actually disappeared from the database:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1859.1">    display_info(session)
    anakin = session.get(Person, anakin_id)
    session.delete(anakin)
    session.commit()
    display_info(session)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1860.1">
     The output of all these snippets run together is the following (for your convenience, we have separated the output into four blocks, to reflect the four blocks of code that produce that output):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1861.1">$ python alchemy.py
Obi-Wan Kenobi(id=2) [obi1@example.com, wanwan@example.com]
Anakin Skywalker(id=1) [
    ani@example.com, evil.dart@example.com, vader@example.com
]
All emails:
 - Anakin Skywalker &lt;ani@example.com&gt;
 - Anakin Skywalker &lt;evil.dart@example.com&gt;
 - Anakin Skywalker &lt;vader@example.com&gt;
 - Obi-Wan Kenobi &lt;obi1@example.com&gt;
 - Obi-Wan Kenobi &lt;wanwan@example.com&gt;
Summary:
 people=2, emails=5
All emails:
 - Obi-Wan Kenobi &lt;obi1@example.com&gt;
 - Obi-Wan Kenobi &lt;wanwan@example.com&gt;
Summary:
 people=1, emails=2
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1862.1">
     As you can
    </span>
    <a id="_idIndexMarker833">
    </a>
    <span class="koboSpan" id="kobo.1863.1">
     see from the last two blocks, deleting
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1864.1">
      anakin
     </span>
    </code>
    <span class="koboSpan" id="kobo.1865.1">
     has deleted one
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1866.1">
      Person
     </span>
    </code>
    <span class="koboSpan" id="kobo.1867.1">
     object and the three email addresses associated with it.
    </span>
    <span class="koboSpan" id="kobo.1867.2">
     Again, this is because cascading took place when we deleted
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1868.1">
      anakin
     </span>
    </code>
    <span class="koboSpan" id="kobo.1869.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1870.1">
     This concludes our brief introduction to data persistence.
    </span>
    <span class="koboSpan" id="kobo.1870.2">
     It is a vast and, at times, complex domain that we encourage you to explore, learning as much theory as possible.
    </span>
    <span class="koboSpan" id="kobo.1870.3">
     Lack of knowledge or proper understanding, when it comes to database systems, can impact the number of bugs in the system, as well as its performance.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-245">
    <span class="koboSpan" id="kobo.1871.1">
     Configuration files
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1872.1">
     Configuration files
    </span>
    <a id="_idIndexMarker834">
    </a>
    <span class="koboSpan" id="kobo.1873.1">
     are crucial components of many Python applications.
    </span>
    <span class="koboSpan" id="kobo.1873.2">
     They allow developers to separate the main application code from settings and parameters.
    </span>
    <span class="koboSpan" id="kobo.1873.3">
     This separation is helpful for maintaining, managing, and distributing software, especially when an application needs to run in different environments – such as development, production, and testing – with different configurations.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1874.1">
     Configuration files allow:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1875.1">
       Flexibility
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1876.1">
      : Users can change the behavior of an application without modifying its code.
     </span>
     <span class="koboSpan" id="kobo.1876.2">
      This is particularly useful for applications that are deployed across different environments, or require credentials to a database, API keys, and so on.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1877.1">
       Security
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1878.1">
      : Sensitive information, like authentication credentials, API keys, or secret tokens, should
     </span>
     <a id="_idIndexMarker835">
     </a>
     <span class="koboSpan" id="kobo.1879.1">
      be kept out of the source code and managed separately from the codebase.
     </span>
    </li>
   </ul>
   <h2 class="heading-2" id="_idParaDest-246">
    <span class="koboSpan" id="kobo.1880.1">
     Common formats
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1881.1">
     Configuration files can be written in several formats, each of which has its own syntax and features.
    </span>
    <span class="koboSpan" id="kobo.1881.2">
     A few popular ones are
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1882.1">
      INI
     </span>
    </code>
    <span class="koboSpan" id="kobo.1883.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1884.1">
      JSON
     </span>
    </code>
    <span class="koboSpan" id="kobo.1885.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1886.1">
      YAML
     </span>
    </code>
    <span class="koboSpan" id="kobo.1887.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1888.1">
      TOML
     </span>
    </code>
    <span class="koboSpan" id="kobo.1889.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1890.1">
      .env
     </span>
    </code>
    <span class="koboSpan" id="kobo.1891.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1892.1">
     In this short section, we are going to briefly explore the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1893.1">
      INI
     </span>
    </code>
    <span class="koboSpan" id="kobo.1894.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1895.1">
      TOML
     </span>
    </code>
    <span class="koboSpan" id="kobo.1896.1">
     formats.
    </span>
    <span class="koboSpan" id="kobo.1896.2">
     In
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.1897.1">
      Chapter 14
     </span>
    </em>
    <span class="koboSpan" id="kobo.1898.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.1899.1">
      Introduction to API Development
     </span>
    </em>
    <span class="koboSpan" id="kobo.1900.1">
     , we will also use a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1901.1">
      .env
     </span>
    </code>
    <span class="koboSpan" id="kobo.1902.1">
     file.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-247">
    <span class="koboSpan" id="kobo.1903.1">
     The INI configuration format
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1904.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1905.1">
      INI
     </span>
    </code>
    <span class="koboSpan" id="kobo.1906.1">
     format
    </span>
    <a id="_idIndexMarker836">
    </a>
    <span class="koboSpan" id="kobo.1907.1">
     is a simple text file, divided
    </span>
    <a id="_idIndexMarker837">
    </a>
    <span class="koboSpan" id="kobo.1908.1">
     into sections.
    </span>
    <span class="koboSpan" id="kobo.1908.2">
     Each section contains properties expressed in the form of key/value pairs.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1909.1">
     To learn
    </span>
    <a id="_idIndexMarker838">
    </a>
    <span class="koboSpan" id="kobo.1910.1">
     more about this format, please visit
    </span>
    <a href="https://en.wikipedia.org/wiki/INI_file">
     <span class="url">
      <span class="koboSpan" id="kobo.1911.1">
       https://en.wikipedia.org/wiki/INI_file
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1912.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1913.1">
     Let us look at an example INI configuration file:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1914.1"># config_files/config.ini</span></span>
<span class="hljs-section"><span class="koboSpan" id="kobo.1915.1">[owner]</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1916.1">name</span></span><span class="koboSpan" id="kobo.1917.1"> = Fabrizio Romano
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.1918.1">dob</span></span><span class="koboSpan" id="kobo.1919.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1920.1">1975</span></span><span class="koboSpan" id="kobo.1921.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1922.1">12</span></span><span class="koboSpan" id="kobo.1923.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1924.1">29</span></span><span class="koboSpan" id="kobo.1925.1">T11:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1926.1">50</span></span><span class="koboSpan" id="kobo.1927.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1928.1">00</span></span><span class="koboSpan" id="kobo.1929.1">Z
</span><span class="hljs-section"><span class="koboSpan" id="kobo.1930.1">[DEFAULT]</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1931.1">title</span></span><span class="koboSpan" id="kobo.1932.1"> = Config INI example
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.1933.1">host</span></span><span class="koboSpan" id="kobo.1934.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1935.1">192.168</span></span><span class="koboSpan" id="kobo.1936.1">.</span><span class="hljs-number"><span class="koboSpan" id="kobo.1937.1">1.1</span></span>
<span class="hljs-section"><span class="koboSpan" id="kobo.1938.1">[database]</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1939.1">host</span></span><span class="koboSpan" id="kobo.1940.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1941.1">192.168</span></span><span class="koboSpan" id="kobo.1942.1">.</span><span class="hljs-number"><span class="koboSpan" id="kobo.1943.1">1.255</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1944.1">user</span></span><span class="koboSpan" id="kobo.1945.1"> = redis
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.1946.1">password</span></span><span class="koboSpan" id="kobo.1947.1"> = redis-password
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.1948.1">db_range</span></span><span class="koboSpan" id="kobo.1949.1"> = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.1950.1">0</span></span><span class="koboSpan" id="kobo.1951.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1952.1">32</span></span><span class="koboSpan" id="kobo.1953.1">]
</span><span class="hljs-section"><span class="koboSpan" id="kobo.1954.1">[database.primary]</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1955.1">port</span></span><span class="koboSpan" id="kobo.1956.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1957.1">6379</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1958.1">connection_max</span></span><span class="koboSpan" id="kobo.1959.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1960.1">5000</span></span>
<span class="hljs-section"><span class="koboSpan" id="kobo.1961.1">[database.secondary]</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1962.1">port</span></span><span class="koboSpan" id="kobo.1963.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1964.1">6380</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1965.1">connection_max</span></span><span class="koboSpan" id="kobo.1966.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1967.1">4000</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1968.1">
     In the
    </span>
    <a id="_idIndexMarker839">
    </a>
    <span class="koboSpan" id="kobo.1969.1">
     preceding text, there are some sections dedicated to a database connection.
    </span>
    <span class="koboSpan" id="kobo.1969.2">
     Common properties can be found in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1970.1">
      database
     </span>
    </code>
    <span class="koboSpan" id="kobo.1971.1">
     section, whereas specific properties are placed in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1972.1">
      .primary
     </span>
    </code>
    <span class="koboSpan" id="kobo.1973.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1974.1">
      .secondary
     </span>
    </code>
    <span class="koboSpan" id="kobo.1975.1">
     sections, which
    </span>
    <a id="_idIndexMarker840">
    </a>
    <span class="koboSpan" id="kobo.1976.1">
     represent configurations to connect to a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1977.1">
      primary
     </span>
    </em>
    <span class="koboSpan" id="kobo.1978.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1979.1">
      secondary
     </span>
    </em>
    <span class="koboSpan" id="kobo.1980.1">
     database, respectively.
    </span>
    <span class="koboSpan" id="kobo.1980.2">
     There is also an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1981.1">
      owner
     </span>
    </code>
    <span class="koboSpan" id="kobo.1982.1">
     section and a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1983.1">
      DEFAULT
     </span>
    </code>
    <span class="koboSpan" id="kobo.1984.1">
     section.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1985.1">
     To read this
    </span>
    <a id="_idIndexMarker841">
    </a>
    <span class="koboSpan" id="kobo.1986.1">
     configuration in an application, we can use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1987.1">
      configparser
     </span>
    </code>
    <span class="koboSpan" id="kobo.1988.1">
     module from the standard library (
    </span>
    <a href="https://docs.python.org/3/library/configparser.html">
     <span class="url">
      <span class="koboSpan" id="kobo.1989.1">
       https://docs.python.org/3/library/configparser.html
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1990.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1990.2">
     It is straightforward in that it will produce an object similar to a dictionary, with the added bonus that the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1991.1">
      DEFAULT
     </span>
    </code>
    <span class="koboSpan" id="kobo.1992.1">
     section automatically provides values for all other sections.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1993.1">
     Let us see an example session from the Python shell:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1994.1"># config_files/config-ini.txt
&gt;&gt;&gt; import configparser
&gt;&gt;&gt; config = configparser.ConfigParser()
&gt;&gt;&gt; config.read("config.ini")
['config.ini']
&gt;&gt;&gt; config.sections()
['owner', 'database', 'database.primary', 'database.secondary']
&gt;&gt;&gt; config.items("database")
[
    ('title', 'Config INI example'), ('host', '192.168.1.255'),
    ('user', 'redis'), ('password', 'redis-password'),
    ('db_range', '[0, 32]')
]
&gt;&gt;&gt; config["database"]
&lt;Section: database&gt;
&gt;&gt;&gt; dict(config["database"])
{
    'host': '192.168.1.255', 'user': 'redis',
    'password': 'redis-password', 'db_range': '[0, 32]',
    'title': 'Config INI example'
}
&gt;&gt;&gt; config["DEFAULT"]["host"]
'192.168.1.1'
&gt;&gt;&gt; dict(config["database.secondary"])
{
    'port': '6380', 'connection_max': '4000',
    'title': 'Config INI example', 'host': '192.168.1.1'
}
&gt;&gt;&gt; config.getint("database.primary", "port")
6379
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1995.1">
     Notice
    </span>
    <a id="_idIndexMarker842">
    </a>
    <span class="koboSpan" id="kobo.1996.1">
     how we import
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1997.1">
      configparser
     </span>
    </code>
    <span class="koboSpan" id="kobo.1998.1">
     and use it to create a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1999.1">
      config
     </span>
    </code>
    <span class="koboSpan" id="kobo.2000.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.2000.2">
     This object exposes various methods; you can get a list of sections, as well as retrieving any value in it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2001.1">
     Internally,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2002.1">
      configparser
     </span>
    </code>
    <span class="koboSpan" id="kobo.2003.1">
     stores
    </span>
    <a id="_idIndexMarker843">
    </a>
    <span class="koboSpan" id="kobo.2004.1">
     values as strings, so we need to cast them appropriately, if we want to use them as the Python object they represent.
    </span>
    <span class="koboSpan" id="kobo.2004.2">
     There are some methods on the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2005.1">
      ConfigParser
     </span>
    </code>
    <span class="koboSpan" id="kobo.2006.1">
     object, namely
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2007.1">
      getint()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2008.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2009.1">
      getfloat()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2010.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2011.1">
      getboolean()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2012.1">
     , that will retrieve a value and return it cast to the indicated type, but as you can see the list is rather short.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2013.1">
     Notice also how properties from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2014.1">
      DEFAULT
     </span>
    </code>
    <span class="koboSpan" id="kobo.2015.1">
     section are injected in all other sections.
    </span>
    <span class="koboSpan" id="kobo.2015.2">
     Moreover, when a section defines a key that is also present in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2016.1">
      DEFAULT
     </span>
    </code>
    <span class="koboSpan" id="kobo.2017.1">
     section, the value from the original section will not be overwritten by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2018.1">
      DEFAULT
     </span>
    </code>
    <span class="koboSpan" id="kobo.2019.1">
     one.
    </span>
    <span class="koboSpan" id="kobo.2019.2">
     You can see an example of this in the highlighted code, which shows that the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2020.1">
      title
     </span>
    </code>
    <span class="koboSpan" id="kobo.2021.1">
     property is present in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2022.1">
      database
     </span>
    </code>
    <span class="koboSpan" id="kobo.2023.1">
     section, and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2024.1">
      host
     </span>
    </code>
    <span class="koboSpan" id="kobo.2025.1">
     one, which is present in both sections, retains the value
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2026.1">
      '192.168.1.255'
     </span>
    </code>
    <span class="koboSpan" id="kobo.2027.1">
     correctly.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-248">
    <span class="koboSpan" id="kobo.2028.1">
     The TOML configuration format
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.2029.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2030.1">
      TOML
     </span>
    </code>
    <span class="koboSpan" id="kobo.2031.1">
     format
    </span>
    <a id="_idIndexMarker844">
    </a>
    <span class="koboSpan" id="kobo.2032.1">
     is quite popular in Python applications, and it has a richer set of features compared to the INI one.
    </span>
    <span class="koboSpan" id="kobo.2032.2">
     If you wish to learn its
    </span>
    <a id="_idIndexMarker845">
    </a>
    <span class="koboSpan" id="kobo.2033.1">
     syntax, please
    </span>
    <a id="_idIndexMarker846">
    </a>
    <span class="koboSpan" id="kobo.2034.1">
     refer to
    </span>
    <a href="https://toml.io/">
     <span class="url">
      <span class="koboSpan" id="kobo.2035.1">
       https://toml.io/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.2036.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2037.1">
     Here, we are going to see a quick example that follows the previous one.
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2038.1"># config_file/config.toml</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2039.1">title</span></span><span class="koboSpan" id="kobo.2040.1"> = "Config Example"
</span><span class="hljs-section"><span class="koboSpan" id="kobo.2041.1">[owner]</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2042.1">name</span></span><span class="koboSpan" id="kobo.2043.1"> = "Fabrizio Romano"
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.2044.1">dob</span></span><span class="koboSpan" id="kobo.2045.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2046.1">1975</span></span><span class="koboSpan" id="kobo.2047.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.2048.1">12</span></span><span class="koboSpan" id="kobo.2049.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.2050.1">29</span></span><span class="koboSpan" id="kobo.2051.1">T11:</span><span class="hljs-number"><span class="koboSpan" id="kobo.2052.1">50</span></span><span class="koboSpan" id="kobo.2053.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.2054.1">00</span></span><span class="koboSpan" id="kobo.2055.1">Z
</span><span class="hljs-section"><span class="koboSpan" id="kobo.2056.1">[database]</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2057.1">host</span></span><span class="koboSpan" id="kobo.2058.1"> = "</span><span class="hljs-number"><span class="koboSpan" id="kobo.2059.1">192.168</span></span><span class="koboSpan" id="kobo.2060.1">.</span><span class="hljs-number"><span class="koboSpan" id="kobo.2061.1">1.255</span></span><span class="koboSpan" id="kobo.2062.1">"
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.2063.1">user</span></span><span class="koboSpan" id="kobo.2064.1"> = "redis"
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.2065.1">password</span></span><span class="koboSpan" id="kobo.2066.1"> = "redis-password"
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.2067.1">db_range</span></span><span class="koboSpan" id="kobo.2068.1"> = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.2069.1">0</span></span><span class="koboSpan" id="kobo.2070.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2071.1">32</span></span><span class="koboSpan" id="kobo.2072.1">]
</span><span class="hljs-section"><span class="koboSpan" id="kobo.2073.1">[database.primary]</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2074.1">port</span></span><span class="koboSpan" id="kobo.2075.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2076.1">6379</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2077.1">connection_max</span></span><span class="koboSpan" id="kobo.2078.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2079.1">5000</span></span>
<span class="hljs-section"><span class="koboSpan" id="kobo.2080.1">[database.secondary]</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2081.1">port</span></span><span class="koboSpan" id="kobo.2082.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2083.1">6380</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.2084.1">connection_max</span></span><span class="koboSpan" id="kobo.2085.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2086.1">4000</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2087.1">
     This
    </span>
    <a id="_idIndexMarker847">
    </a>
    <span class="koboSpan" id="kobo.2088.1">
     time, we have no
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2089.1">
      DEFAULT
     </span>
    </code>
    <span class="koboSpan" id="kobo.2090.1">
     section, and
    </span>
    <a id="_idIndexMarker848">
    </a>
    <span class="koboSpan" id="kobo.2091.1">
     properties are specified slightly differently, in that strings are surrounded by quotes, while numbers are not.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2092.1">
     We will use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2093.1">
      tomllib
     </span>
    </code>
    <span class="koboSpan" id="kobo.2094.1">
     module
    </span>
    <a id="_idIndexMarker849">
    </a>
    <span class="koboSpan" id="kobo.2095.1">
     from the standard library (
    </span>
    <a href="https://docs.python.org/3/library/tomllib.html">
     <span class="url">
      <span class="koboSpan" id="kobo.2096.1">
       https://docs.python.org/3/library/tomllib.html
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.2097.1">
     ) to read this configuration:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2098.1"># config_files/config-toml.txt
&gt;&gt;&gt; import tomllib
&gt;&gt;&gt; with open("config.toml", "rb") as f:
...     </span><span class="koboSpan" id="kobo.2098.2">config = tomllib.load(f)
...
</span><span class="koboSpan" id="kobo.2098.3">&gt;&gt;&gt; config
{
    'title': 'Config Example',
    'owner': {
        'name': 'Fabrizio Romano',
        'dob': datetime.datetime(
            1975, 12, 29, 11, 50, tzinfo=datetime.timezone.utc
        )
    },
    'database': {
        'host': '192.168.1.255',
        'user': 'redis',
        'password': 'redis-password',
        'db_range': [0, 32],
        'primary': {'port': 6379, 'connection_max': 5000},
        'secondary': {'port': 6380, 'connection_max': 4000}
    }
}
&gt;&gt;&gt; config["title"]
'Config Example'
&gt;&gt;&gt; config["owner"]
{
    'name': 'Fabrizio Romano',
    'dob': datetime.datetime(
        1975, 12, 29, 11, 50, tzinfo=datetime.timezone.utc
    )
}
&gt;&gt;&gt; config["database"]["primary"]
{'port': 6379, 'connection_max': 5000}
&gt;&gt;&gt; config["database"]["db_range"]
[0, 32]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2099.1">
     Notice
    </span>
    <a id="_idIndexMarker850">
    </a>
    <span class="koboSpan" id="kobo.2100.1">
     how, this time, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2101.1">
      config
     </span>
    </code>
    <span class="koboSpan" id="kobo.2102.1">
     object is a dictionary.
    </span>
    <span class="koboSpan" id="kobo.2102.2">
     Because of the way we have specified the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2103.1">
      database.primary
     </span>
    </code>
    <span class="koboSpan" id="kobo.2104.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2105.1">
      database.secondary
     </span>
    </code>
    <span class="koboSpan" id="kobo.2106.1">
     sections,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2107.1">
      tomllib
     </span>
    </code>
    <span class="koboSpan" id="kobo.2108.1">
     has created a nested structure to represent them.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2109.1">
     With TOML, values
    </span>
    <a id="_idIndexMarker851">
    </a>
    <span class="koboSpan" id="kobo.2110.1">
     are correctly cast to Python objects.
    </span>
    <span class="koboSpan" id="kobo.2110.2">
     We have strings, numbers, lists, and even a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2111.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.2112.1">
     object, created from the iso-formatted string representing Fabrizio’s date of birth.
    </span>
    <span class="koboSpan" id="kobo.2112.2">
     On the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2113.1">
      tomllib
     </span>
    </code>
    <span class="koboSpan" id="kobo.2114.1">
     documentation page, you can find a table with all possible conversions.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-249">
    <span class="koboSpan" id="kobo.2115.1">
     Summary
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2116.1">
     In this chapter, we explored working with files and directories.
    </span>
    <span class="koboSpan" id="kobo.2116.2">
     We learned how to read and write on files, and how to do that elegantly by using context managers.
    </span>
    <span class="koboSpan" id="kobo.2116.3">
     We also explored directories: how to list their content, both recursively and not.
    </span>
    <span class="koboSpan" id="kobo.2116.4">
     We also learned about paths, which are the gateway to accessing both files and directories.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2117.1">
     We then briefly saw how to create a ZIP archive and extract its content.
    </span>
    <span class="koboSpan" id="kobo.2117.2">
     The source code of the book also contains an example with a different compression format:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2118.1">
      tar.gz
     </span>
    </code>
    <span class="koboSpan" id="kobo.2119.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2120.1">
     We talked about data interchange formats and explored JSON in some depth.
    </span>
    <span class="koboSpan" id="kobo.2120.2">
     We had some fun writing custom encoders and decoders for specific Python data types.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2121.1">
     Then, we explored I/O, both with in-memory streams and HTTP requests.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2122.1">
     We saw how to persist data using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2123.1">
      pickle
     </span>
    </code>
    <span class="koboSpan" id="kobo.2124.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2125.1">
      shelve
     </span>
    </code>
    <span class="koboSpan" id="kobo.2126.1">
     , and the SQLAlchemy ORM library.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2127.1">
     And finally, we explored two examples of configuration files, using the INI and TOML formats.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2128.1">
     You should now have a good understanding of how to deal with files and data persistence, and we hope you will take the time to explore these topics in much more depth by yourself.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2129.1">
     The next chapter will look at cryptography and tokens.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-250">
    <span class="koboSpan" id="kobo.2130.1">
     Join our community on Discord
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2131.1">
     Join our community’s Discord space for discussions with the authors and other readers:
    </span>
   </p>
   <p class="normal">
    <a href="Chapter_8.xhtml">
     <span class="url">
      <span class="koboSpan" id="kobo.2132.1">
       https://discord.com/invite/uaKmaz7FEC
      </span>
     </span>
    </a>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2133.1">
     <img alt="img" src="../Images/QR_Code119001106417026468.png"/>
    </span>
   </p>
  </div>
 </body></html>