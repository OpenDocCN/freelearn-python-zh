- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous Integration with GitLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The network touches every part of the technology stack; in all the environments
    I have worked in, the network is always a Tier-Zero service. It is a foundation
    service that other services rely on for their services to work. In the minds of
    other engineers, business managers, operators, and support staff, the network
    should just work. It should always be accessible and function correctly—a good
    network is a network that nobody hears about.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as network engineers, we know the network is as complex as any other
    technology stack. Due to its complexity, the constructs that make up a running
    network can be fragile. Sometimes, I look at a network and wonder how it can work
    at all, let alone how it’s been running for months and years without any business
    impact.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the reason we are interested in network automation is to find ways to
    repeat our network-change process reliably and consistently. By using Python scripts
    or the Ansible framework, we can make sure the changes that we make will stay
    consistent and be reliably applied. As we saw in the last chapter, we can use
    Git and GitHub to store components of the process, such as templates, scripts,
    requirements, and files, reliably. The code that makes up the infrastructure is
    version-controlled, collaborated, and accountable for changes. But how do we tie
    all the pieces together? In this chapter, we will look at a popular repository
    that can optimize the network-management pipeline called GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab’s open core is published under an MIT open-source license. The rest is
    source-available, [https://about.gitlab.com/solutions/open-source/.](https://about.gitlab.com/solutions/open-source/.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Challenges with the traditional change management process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to continuous integration and GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab installation and examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration for network engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll begin by looking at the traditional change management process. As any
    battle-tested network engineer could tell you, the traditional change management
    process typically involves much manual labor and human judgment. As we will see,
    it is not consistent and is difficult to streamline.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional change management process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Engineers who have worked in a large network environment know that the impact
    of a network change gone wrong can be big. We can make hundreds of changes without
    any issues, but all it takes is one bad change that can cause the network to harm
    the whole business.
  prefs: []
  type: TYPE_NORMAL
- en: There is no shortage of war stories about network outages causing business pain.
    One of the most visible and large-scale AWS EC2 outages in 2011 was caused by
    a network change that was part of the normal AWS scaling activities in the AWS
    US-East region. The change occurred at 00:47 PDT and caused a brown-out for various
    services for over 12 hours, losing millions of dollars for Amazon. More importantly,
    the reputation of the relatively young service took a serious hit. IT decision-makers
    pointed to the outage as a reason NOT to migrate to the young AWS cloud. It took
    many years to rebuild its reputation. You can read more about the incident report
    at [https://aws.amazon.com/message/65648/](https://aws.amazon.com/message/65648/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the potential impact and complexity, in many environments, the **change-advisory
    board** (**CAB**) process is implemented for networks. The typical CAB process
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The network engineer will design the change and write out the detailed steps
    required for the change. These can include the reason for the change, the devices
    involved, the commands that will be applied or deleted, how to verify the output,
    and the expected outcome for each step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The network engineer is typically required to ask for a technical review from
    a peer first. Depending on the nature of the change, there can be different levels
    of peer review. Simple changes can require a single-peer technical review; more
    complex changes might require a senior designated engineer for approval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAB meeting is generally scheduled for set times with emergency ad hoc meetings
    available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The engineer will present the change to the board. The board will ask the necessary
    questions, assess the impact, and either approve or deny the change request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The change will be carried out, either by the original engineer or another engineer,
    during the scheduled change window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This process sounds reasonable and inclusive but proves to have a few challenges
    in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write-ups are time-consuming**: It typically takes a long time for the design
    engineer to write up the document, and sometimes the writing process takes longer
    than the time to apply the change. This is generally due to the fact that all
    network changes are potentially impactful and we need to document the process
    for both technical and non-technical CAB members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Engineer expertise**: High-level engineer expertise is a limited resource.
    There are different levels of engineering expertise; some are more experienced,
    and they are typically the most sought-after resources. We should reserve their
    time for tackling the most complex network issues, not reviewing basic network
    changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meetings are time-consuming**: It takes a lot of effort to put together meetings
    and have each member show up. What happens if a required approval person is on
    vacation or sick? What if you need the network change to be made prior to the
    scheduled CAB time?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some of the bigger challenges of the human-based CAB process.
    Personally, I hate the CAB process with a passion. I do not dispute the need for
    peer review and prioritization; however, I think we need to minimize the potential
    overhead involved. For the remainder of this chapter, let’s look at a potentially
    suitable replacement pipeline for CAB, and change management in general, that
    has been adopted in the software engineering world.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) in software development is a way to publish
    small changes to the code base quickly, with built-in code tests and validation.
    The key is to classify the changes to be CI-compatible, that is, not overly complex
    and small enough to be applied so that they can be backed out of easily. The tests
    and validation process are built in an automated way to gain a baseline of confidence
    that changes will be applied without breaking the whole system.'
  prefs: []
  type: TYPE_NORMAL
- en: Before CI, changes to software were often made in large batches and often required
    a long validation process (does that sound familiar?). It could be months before
    developers saw their changes in production, received feedback loops, and corrected
    bugs. In short, the CI process aims to shorten the process from idea to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general workflow typically involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first engineer takes a current copy of the code base and works on the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first engineer submits the change to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The repository can notify the necessary parties of a change in the repository
    to a group of engineers who can review the change. They can either approve or
    reject the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CI system can continuously pull the repository for changes, or the repository
    can send a notification to the CI system when changes happen. Either way, the
    CI system will pull the latest version of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CI system will run automated tests to try to catch any breakage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no faults found, the CI system can choose to merge the change into
    the main code and optionally deploy it to the production system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a generalized list of steps. The process can be different for each organization.
    For example, automated tests can be run as soon as the delta code is checked instead
    of after code review. Sometimes, the organization might choose to have a human
    engineer involved for sanity checks in between the steps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will illustrate the instructions to install GitLab on
    an Ubuntu 22.04 LTS system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing GitLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab is a powerful, all-in-one tool to handle the end-to-end DevOps collaboration
    tool. As we will see in a minute, it hosts the code repository and handles the
    code testing, deployment, and verification. It is one of the most popular DevOps
    tools used in the field today.
  prefs: []
  type: TYPE_NORMAL
- en: The company behind the technology, GitLab Inc., had its successful initial public
    offering on NASDAQ (ticket GTLB) in late 2021, [https://techcrunch.com/2021/09/17/inside-gitlabs-ipo-filing/](https://techcrunch.com/2021/09/17/inside-gitlabs-ipo-filing/).
    The company’s success shows the strength of and sustainability of the technology.
  prefs: []
  type: TYPE_NORMAL
- en: We will only need a small set of its features to get up and running with a test
    lab. The objective is to familiarize ourselves with the overall flow of the steps.
    I encourage you to look at the GitLab documentation at [https://docs.gitlab.com/](https://docs.gitlab.com/)
    to get a sense of its features.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18403_15_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: GitLab Documentation'
  prefs: []
  type: TYPE_NORMAL
- en: For our network lab, we will use the same lab topology that we have been using
    for the last few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18403_15_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Lab Topology'
  prefs: []
  type: TYPE_NORMAL
- en: While it is tempting to run GitLab as a Docker image, the GitLab runners (components
    executing the steps) are Docker images themselves, and running Docker-in-Docker
    introduces more complexity in our lab. Therefore, in this chapter, we will install
    GitLab on a VM with the runners running in containers. The installation system
    requirements can be found here, [https://docs.gitlab.com/ee/install/requirements.html](https://docs.gitlab.com/ee/install/requirements.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will install Docker Engine, docker-compose, then the GitLab packages. Let’s
    get Docker ready first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For GitLab, we will install the self-managed GitLab with the official steps:
    [https://docs.gitlab.com/omnibus/index.html#installation-and-configuration-using-omnibus-package](https://docs.gitlab.com/omnibus/index.html#installation-and-configuration-using-omnibus-package).
    Note that the steps require port forwarding to the host on an externally accessible
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the success message once installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18403_15_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: GitLab Installation'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the initial password to log in and then reset it ([https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password](https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be able to see the dashboard under ‘**Menu -> Admin**’ once everything
    is configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18403_15_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: GitLab Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an optional step, we can enable SMTP settings under `/etc/gitlab/gitlab.rb`.
    This would allow us to receive emails for the important messages on GitLab ([https://docs.gitlab.com/omnibus/settings/smtp.html](https://docs.gitlab.com/omnibus/settings/smtp.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_15_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: GitLab SMTP Settings'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk about GitLab runners.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab runners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitLab uses the concept of a runner. A runner is a process that picks up and
    executes **Continuous Integration/Continuous Deployment** (**CI/CD**) jobs for
    GitLab. The runner can be run in a Docker container on the host itself, [https://docs.gitlab.com/runner/install/docker.html](https://docs.gitlab.com/runner/install/docker.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can go ahead and register the runner with the host, [https://docs.gitlab.com/runner/register/index.html#docker](https://docs.gitlab.com/runner/register/index.html#docker),
    under **Admin Area -> Runners -> Register** an instance runner. We will take note
    of the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_15_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: GitLab Runner Registration'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the token to pull and register a runner with a base image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to handle our first job!
  prefs: []
  type: TYPE_NORMAL
- en: First GitLab example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can begin by creating a separate user under **Menu -> Admin Area -> Users**
    (under Overview) and login via that user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B18403_15_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: GitLab Users'
  prefs: []
  type: TYPE_NORMAL
- en: 'To push or pull from repositories, we will also add our SSH key. This can be
    done via the settings section within the user profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_15_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.8: User SSH Key'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create a new project under **Menu -> Projects -> Create New Project**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_15_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.9: Create New Project'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will name this project `chapter15_example1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_15_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.10: New Project Settings'
  prefs: []
  type: TYPE_NORMAL
- en: We can leave the rest of the settings as we see fit. As a precaution, I typically
    leave the project visibility on private, but we can always change that later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_15_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.11: Project Clone URL'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can grab the URL for the project and clone that project on our management
    station:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a special file `.gitlab-ci.yml` that is recognized by GitLab
    as a CI/CD instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will check in, commit, and push the file to our GitLab repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.gitlab-ci.yml` file contains instructions for a GitLab CI/CD pipeline
    in a YAML format. It contains two main sections, stage and job definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing diagram  Description automatically generated](img/B18403_15_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.12: GitLab CI File'
  prefs: []
  type: TYPE_NORMAL
- en: In our file, we defined three stages with the keyword `stages`. In the execution
    section, we define the Docker base image to be pulled, the name of the job to
    be done, the stage it corresponds to, as well as the steps to be executed under
    `script`. There can be optional instructions such as `artifacts` under `build`
    and `when` under `deploy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we move back to the project, we can click on **CI/CD -> Pipelines** to show
    us the status of the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated with medium confidence](img/B18403_15_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.13: CI/CD Pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: There are three circles, each representing a stage.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_15_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.14: Pipeline Output'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can click on the circles and see the container output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18403_15_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.15: Execution Output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember we have optional steps under `build` and `deploy`? The artifacts give
    us something to download:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_15_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.16: Artifacts'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `when` keyword allows us to manually push out the step instead of having
    GitLab automatically execute for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_15_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.17: Manual Push'
  prefs: []
  type: TYPE_NORMAL
- en: Is this awesome, or what? We now have some workers automatically executing jobs
    for us. We can also leverage many of the features of Git for collaboration, such
    as inviting colleagues for code review. Let’s see another example.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab network example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will go ahead and create another project named `chapter15_example2` on the
    GitLab server. On the local machine, we will clone the remote repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we will integrate the Nornir library to see how we can execute
    `show version` on two of the IOSv devices. We will begin by defining the `hosts.yaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then construct the Python script for execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define a `requirements.txt` file to specify the packages to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also define the `.gitlab-ci.yml` file to define the stages and the
    scripts. Notice in the file that we specify another `before_script` step to be
    executed before any of the stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once the files are checked in and pushed to the repository, we can go to the
    CI/CD section to look at the outputs. The steps will take longer this time because
    of the package download time. We can click on the step and examine the execution
    in real time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18403_15_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.18: Nornir CI/CD Step Execution'
  prefs: []
  type: TYPE_NORMAL
- en: We should be able to see the pipeline successfully executed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_15_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.19: CI/CD Result'
  prefs: []
  type: TYPE_NORMAL
- en: Using GitLab CI/CD is a terrific way of automating our network operation steps.
    The pipeline might take longer to set up, but once it is completed, it will save
    us much time and allow us to preserve our energy to focus on more interesting
    work. For more information, check out [https://docs.gitlab.com/ee/ci/](https://docs.gitlab.com/ee/ci/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the traditional change management process and why
    it is not a good fit for today’s rapidly changing environment. The network needs
    to evolve with the business to become more agile and adapt to change quickly and
    reliably.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the concept of continuous integration, in particular, the open-source
    GitLab system. GitLab is a full-featured, expandable, continuous integration system
    widely used in software development. We can adapt the same system for our network
    operations. We saw two examples using the GitLab Git repository and runners to
    execute our operations automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 16*, *Test-Driven Development for Networks*, we will look at test-driven
    development with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Join our book community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2903617220506617062.png)'
  prefs: []
  type: TYPE_IMG
