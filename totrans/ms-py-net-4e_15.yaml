- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Continuous Integration with GitLab
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitLab 进行持续集成
- en: The network touches every part of the technology stack; in all the environments
    I have worked in, the network is always a Tier-Zero service. It is a foundation
    service that other services rely on for their services to work. In the minds of
    other engineers, business managers, operators, and support staff, the network
    should just work. It should always be accessible and function correctly—a good
    network is a network that nobody hears about.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络触及技术栈的每个部分；在我工作过的所有环境中，网络始终是零级服务。它是一个基础服务，其他服务依赖于它来使它们的服务正常工作。在其他工程师、业务经理、操作员和支持人员的心中，网络应该只是正常工作。它应该始终可访问并正确运行——一个好的网络是没有人会注意到的网络。
- en: Of course, as network engineers, we know the network is as complex as any other
    technology stack. Due to its complexity, the constructs that make up a running
    network can be fragile. Sometimes, I look at a network and wonder how it can work
    at all, let alone how it’s been running for months and years without any business
    impact.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，作为网络工程师，我们知道网络与其他技术栈一样复杂。由于其复杂性，构成运行网络的构造可能很脆弱。有时，我看到一个网络，想知道它怎么能正常工作，更不用说它如何在没有业务影响的情况下运行数月甚至数年。
- en: Part of the reason we are interested in network automation is to find ways to
    repeat our network-change process reliably and consistently. By using Python scripts
    or the Ansible framework, we can make sure the changes that we make will stay
    consistent and be reliably applied. As we saw in the last chapter, we can use
    Git and GitHub to store components of the process, such as templates, scripts,
    requirements, and files, reliably. The code that makes up the infrastructure is
    version-controlled, collaborated, and accountable for changes. But how do we tie
    all the pieces together? In this chapter, we will look at a popular repository
    that can optimize the network-management pipeline called GitLab.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对网络自动化感兴趣的部分原因是为了找到可靠且一致地重复我们的网络变更流程的方法。通过使用 Python 脚本或 Ansible 框架，我们可以确保我们做出的变更将保持一致并可靠地应用。正如我们在上一章中看到的，我们可以使用
    Git 和 GitHub 来可靠地存储流程的组件，如模板、脚本、需求和文件。构成基础设施的代码是版本控制的、协作的，并对变更负责。但我们是如何将这些部分联系在一起的呢？在本章中，我们将探讨一个流行的存储库，它可以优化网络管理流程，称为
    GitLab。
- en: GitLab’s open core is published under an MIT open-source license. The rest is
    source-available, [https://about.gitlab.com/solutions/open-source/.](https://about.gitlab.com/solutions/open-source/.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 的开源核心在 MIT 开源许可证下发布。其余的是源代码可用的，[https://about.gitlab.com/solutions/open-source/。（https://about.gitlab.com/solutions/open-source/。）](https://about.gitlab.com/solutions/open-source/。)
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Challenges with the traditional change management process
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统变更管理流程的挑战
- en: An introduction to continuous integration and GitLab
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成和 GitLab 简介
- en: GitLab installation and examples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 安装和示例
- en: GitLab with Python
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 与 Python
- en: Continuous integration for network engineering
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络工程中的持续集成
- en: We’ll begin by looking at the traditional change management process. As any
    battle-tested network engineer could tell you, the traditional change management
    process typically involves much manual labor and human judgment. As we will see,
    it is not consistent and is difficult to streamline.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从传统的变更管理流程开始。正如任何经过实战考验的网络工程师可以告诉你的，传统的变更管理流程通常涉及大量的手工劳动和人工判断。正如我们将看到的，它并不一致，难以简化。
- en: The traditional change management process
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的变更管理流程
- en: Engineers who have worked in a large network environment know that the impact
    of a network change gone wrong can be big. We can make hundreds of changes without
    any issues, but all it takes is one bad change that can cause the network to harm
    the whole business.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型网络环境中工作过的工程师知道，网络变更出错的影响可能很大。我们可以做出数百次变更而没有任何问题，但只需要一次错误的变更就可能导致整个网络对整个业务造成损害。
- en: There is no shortage of war stories about network outages causing business pain.
    One of the most visible and large-scale AWS EC2 outages in 2011 was caused by
    a network change that was part of the normal AWS scaling activities in the AWS
    US-East region. The change occurred at 00:47 PDT and caused a brown-out for various
    services for over 12 hours, losing millions of dollars for Amazon. More importantly,
    the reputation of the relatively young service took a serious hit. IT decision-makers
    pointed to the outage as a reason NOT to migrate to the young AWS cloud. It took
    many years to rebuild its reputation. You can read more about the incident report
    at [https://aws.amazon.com/message/65648/](https://aws.amazon.com/message/65648/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络故障导致商业痛苦的战争故事并不少见。2011年最明显和大规模的AWS EC2故障之一是由AWS US-East区域正常扩展活动的一部分网络变更引起的。该变更发生在00:47
    PDT，导致各种服务停电超过12小时，给亚马逊造成了数百万美元的损失。更重要的是，这个相对年轻的服务声誉受到了严重打击。IT决策者将故障视为不迁移到年轻的AWS云的理由。重建声誉花费了多年时间。您可以在[https://aws.amazon.com/message/65648/](https://aws.amazon.com/message/65648/)了解更多关于事件报告的信息。
- en: 'Due to the potential impact and complexity, in many environments, the **change-advisory
    board** (**CAB**) process is implemented for networks. The typical CAB process
    is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于潜在的影响和复杂性，在许多环境中，网络变更咨询委员会（CAB）流程被实施。典型的CAB流程如下：
- en: The network engineer will design the change and write out the detailed steps
    required for the change. These can include the reason for the change, the devices
    involved, the commands that will be applied or deleted, how to verify the output,
    and the expected outcome for each step.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络工程师将设计变更并详细列出实施变更所需的步骤。这可以包括变更的原因、涉及的设备、将要应用或删除的命令、如何验证输出以及每一步的预期结果。
- en: The network engineer is typically required to ask for a technical review from
    a peer first. Depending on the nature of the change, there can be different levels
    of peer review. Simple changes can require a single-peer technical review; more
    complex changes might require a senior designated engineer for approval.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络工程师通常需要首先向同事请求技术审查。根据变更的性质，可能存在不同级别的同行审查。简单的变更可能只需要单次同行技术审查；更复杂的变更可能需要高级指定工程师的批准。
- en: The CAB meeting is generally scheduled for set times with emergency ad hoc meetings
    available.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAB会议通常安排在固定时间，同时提供紧急的临时会议。
- en: The engineer will present the change to the board. The board will ask the necessary
    questions, assess the impact, and either approve or deny the change request.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工程师将向董事会展示变更。董事会将提出必要的问题，评估影响，并批准或拒绝变更请求。
- en: The change will be carried out, either by the original engineer or another engineer,
    during the scheduled change window.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变更将在计划变更窗口期间由原始工程师或另一位工程师执行。
- en: 'This process sounds reasonable and inclusive but proves to have a few challenges
    in practice:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程听起来合理且包容，但在实践中却证明存在一些挑战：
- en: '**Write-ups are time-consuming**: It typically takes a long time for the design
    engineer to write up the document, and sometimes the writing process takes longer
    than the time to apply the change. This is generally due to the fact that all
    network changes are potentially impactful and we need to document the process
    for both technical and non-technical CAB members.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写文档耗时**：设计工程师编写文档通常需要很长时间，有时写作过程比应用变更的时间还要长。这通常是由于所有网络变更都具有潜在的破坏性，我们需要为技术和非技术CAB成员记录过程。'
- en: '**Engineer expertise**: High-level engineer expertise is a limited resource.
    There are different levels of engineering expertise; some are more experienced,
    and they are typically the most sought-after resources. We should reserve their
    time for tackling the most complex network issues, not reviewing basic network
    changes.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工程师的专业知识**：高级工程师专业知识是一种有限资源。存在不同级别的工程专业知识；有些经验更丰富，通常是需求最迫切的资源。我们应该保留他们的时间来解决最复杂的网络问题，而不是审查基本的网络变更。'
- en: '**Meetings are time-consuming**: It takes a lot of effort to put together meetings
    and have each member show up. What happens if a required approval person is on
    vacation or sick? What if you need the network change to be made prior to the
    scheduled CAB time?'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会议耗时**：组织会议并确保每位成员出席需要大量努力。如果必要的批准人员休假或生病怎么办？如果需要在计划好的CAB时间之前进行网络变更怎么办？'
- en: These are just some of the bigger challenges of the human-based CAB process.
    Personally, I hate the CAB process with a passion. I do not dispute the need for
    peer review and prioritization; however, I think we need to minimize the potential
    overhead involved. For the remainder of this chapter, let’s look at a potentially
    suitable replacement pipeline for CAB, and change management in general, that
    has been adopted in the software engineering world.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是基于人类CAB过程的一些更大挑战。我个人非常讨厌CAB过程。我并不否认同行评审和优先级排序的需要；然而，我认为我们需要最小化涉及到的潜在开销。在本章的剩余部分，让我们看看一个可能适合CAB和一般变更管理的替代管道，该管道已被软件工程界采用。
- en: Introduction to continuous integration
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连续集成简介
- en: '**Continuous Integration** (**CI**) in software development is a way to publish
    small changes to the code base quickly, with built-in code tests and validation.
    The key is to classify the changes to be CI-compatible, that is, not overly complex
    and small enough to be applied so that they can be backed out of easily. The tests
    and validation process are built in an automated way to gain a baseline of confidence
    that changes will be applied without breaking the whole system.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）在软件开发中是一种快速发布代码库小更改的方法，内置代码测试和验证。关键是分类要CI兼容的更改，即不过于复杂，足够小以便可以轻松应用，以便可以轻松回滚。测试和验证过程以自动化的方式构建，以获得一个基线信心，即更改将应用而不会破坏整个系统。'
- en: Before CI, changes to software were often made in large batches and often required
    a long validation process (does that sound familiar?). It could be months before
    developers saw their changes in production, received feedback loops, and corrected
    bugs. In short, the CI process aims to shorten the process from idea to change.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI之前，软件的更改通常是大批量进行的，并且往往需要漫长的验证过程（这听起来熟悉吗？）。开发者可能需要数月才能在生产环境中看到他们的更改，收到反馈循环，并修复错误。简而言之，CI过程旨在缩短从想法到更改的过程。
- en: 'The general workflow typically involves the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通用工作流程包括以下步骤：
- en: The first engineer takes a current copy of the code base and works on the change.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一位工程师获取当前代码库的副本并开始进行更改。
- en: The first engineer submits the change to the repository.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一位工程师将更改提交到仓库。
- en: The repository can notify the necessary parties of a change in the repository
    to a group of engineers who can review the change. They can either approve or
    reject the change.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仓库可以通知一组工程师有关仓库更改的通知，他们可以审查更改。他们可以批准或拒绝更改。
- en: The CI system can continuously pull the repository for changes, or the repository
    can send a notification to the CI system when changes happen. Either way, the
    CI system will pull the latest version of the code.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI系统可以持续拉取仓库以获取更改，或者当发生更改时，仓库可以向CI系统发送通知。无论哪种方式，CI系统都会拉取最新的代码版本。
- en: The CI system will run automated tests to try to catch any breakage.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI系统将运行自动化测试以尝试捕获任何破坏。
- en: If there are no faults found, the CI system can choose to merge the change into
    the main code and optionally deploy it to the production system.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有发现任何故障，CI系统可以选择将更改合并到主代码中，并可选择将其部署到生产系统。
- en: This is a generalized list of steps. The process can be different for each organization.
    For example, automated tests can be run as soon as the delta code is checked instead
    of after code review. Sometimes, the organization might choose to have a human
    engineer involved for sanity checks in between the steps.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用的步骤列表。对于每个组织，过程可能不同。例如，可以在代码审查之后而不是在代码审查后立即运行自动测试。有时，组织可能会选择在步骤之间让人类工程师参与进行合理性检查。
- en: In the next section, we will illustrate the instructions to install GitLab on
    an Ubuntu 22.04 LTS system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将说明如何在Ubuntu 22.04 LTS系统上安装GitLab的说明。
- en: Installing GitLab
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装GitLab
- en: GitLab is a powerful, all-in-one tool to handle the end-to-end DevOps collaboration
    tool. As we will see in a minute, it hosts the code repository and handles the
    code testing, deployment, and verification. It is one of the most popular DevOps
    tools used in the field today.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab是一个功能强大、一应俱全的工具，用于处理端到端DevOps协作工具。正如我们将在下一分钟看到的那样，它托管代码仓库并处理代码测试、部署和验证。它是目前该领域最受欢迎的DevOps工具之一。
- en: The company behind the technology, GitLab Inc., had its successful initial public
    offering on NASDAQ (ticket GTLB) in late 2021, [https://techcrunch.com/2021/09/17/inside-gitlabs-ipo-filing/](https://techcrunch.com/2021/09/17/inside-gitlabs-ipo-filing/).
    The company’s success shows the strength of and sustainability of the technology.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术背后的公司 GitLab Inc. 在 2021 年晚些时候在纳斯达克（股票代码 GTLB）成功进行了首次公开募股，[https://techcrunch.com/2021/09/17/inside-gitlabs-ipo-filing/](https://techcrunch.com/2021/09/17/inside-gitlabs-ipo-filing/)。该公司的成功展示了该技术的强大和可持续性。
- en: We will only need a small set of its features to get up and running with a test
    lab. The objective is to familiarize ourselves with the overall flow of the steps.
    I encourage you to look at the GitLab documentation at [https://docs.gitlab.com/](https://docs.gitlab.com/)
    to get a sense of its features.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要使用其一小部分功能来启动测试实验室。目标是熟悉这些步骤的整体流程。我鼓励您查看 GitLab 文档 [https://docs.gitlab.com/](https://docs.gitlab.com/)，以了解其功能。
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18403_15_01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，团队 描述自动生成](img/B18403_15_01.png)'
- en: 'Figure 15.1: GitLab Documentation'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1：GitLab 文档
- en: For our network lab, we will use the same lab topology that we have been using
    for the last few chapters.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的网络实验室，我们将使用我们在过去几章中一直在使用的相同实验室拓扑。
- en: '![Diagram  Description automatically generated](img/B18403_15_02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图表 描述自动生成](img/B18403_15_02.png)'
- en: 'Figure 15.2: Lab Topology'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2：实验室拓扑
- en: While it is tempting to run GitLab as a Docker image, the GitLab runners (components
    executing the steps) are Docker images themselves, and running Docker-in-Docker
    introduces more complexity in our lab. Therefore, in this chapter, we will install
    GitLab on a VM with the runners running in containers. The installation system
    requirements can be found here, [https://docs.gitlab.com/ee/install/requirements.html](https://docs.gitlab.com/ee/install/requirements.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然运行 GitLab 作为 Docker 镜像很有吸引力，但 GitLab 运行器（执行步骤的组件）本身也是 Docker 镜像，运行 Docker-in-Docker
    在我们的实验室中引入了更多的复杂性。因此，在本章中，我们将在一个虚拟机上安装 GitLab，运行器在容器中运行。安装系统要求可以在以下位置找到，[https://docs.gitlab.com/ee/install/requirements.html](https://docs.gitlab.com/ee/install/requirements.html)。
- en: 'We will install Docker Engine, docker-compose, then the GitLab packages. Let’s
    get Docker ready first:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装 Docker 引擎、docker-compose，然后是 GitLab 软件包。首先让我们准备好 Docker：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For GitLab, we will install the self-managed GitLab with the official steps:
    [https://docs.gitlab.com/omnibus/index.html#installation-and-configuration-using-omnibus-package](https://docs.gitlab.com/omnibus/index.html#installation-and-configuration-using-omnibus-package).
    Note that the steps require port forwarding to the host on an externally accessible
    URL:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 GitLab，我们将按照官方步骤安装自托管的 GitLab：[https://docs.gitlab.com/omnibus/index.html#installation-and-configuration-using-omnibus-package](https://docs.gitlab.com/omnibus/index.html#installation-and-configuration-using-omnibus-package)。请注意，这些步骤需要将端口转发到外部可访问的
    URL 上的主机：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We should see the success message once installed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们应该能看到成功消息：
- en: '![Text  Description automatically generated](img/B18403_15_03.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![文本 描述自动生成](img/B18403_15_03.png)'
- en: 'Figure 15.3: GitLab Installation'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3：GitLab 安装
- en: 'We will use the initial password to log in and then reset it ([https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password](https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password)):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用初始密码登录，然后重置它（[https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password](https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password)）：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We should be able to see the dashboard under ‘**Menu -> Admin**’ once everything
    is configured:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一切配置完成后，我们应该能在“**菜单 -> 管理员**”下看到仪表板：
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18403_15_04.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，团队 描述自动生成](img/B18403_15_04.png)'
- en: 'Figure 15.4: GitLab Dashboard'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4：GitLab 仪表板
- en: 'As an optional step, we can enable SMTP settings under `/etc/gitlab/gitlab.rb`.
    This would allow us to receive emails for the important messages on GitLab ([https://docs.gitlab.com/omnibus/settings/smtp.html](https://docs.gitlab.com/omnibus/settings/smtp.html)):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可选步骤，我们可以在 `/etc/gitlab/gitlab.rb` 下启用 SMTP 设置。这将允许我们接收 GitLab 上重要消息的电子邮件（[https://docs.gitlab.com/omnibus/settings/smtp.html](https://docs.gitlab.com/omnibus/settings/smtp.html)）：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_15_05.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序 描述自动生成](img/B18403_15_05.png)'
- en: 'Figure 15.5: GitLab SMTP Settings'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5：GitLab SMTP 设置
- en: Let’s talk about GitLab runners.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈 GitLab 运行器。
- en: GitLab runners
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab 运行器
- en: 'GitLab uses the concept of a runner. A runner is a process that picks up and
    executes **Continuous Integration/Continuous Deployment** (**CI/CD**) jobs for
    GitLab. The runner can be run in a Docker container on the host itself, [https://docs.gitlab.com/runner/install/docker.html](https://docs.gitlab.com/runner/install/docker.html):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab使用运行者的概念。运行者是一个进程，它从GitLab中提取并执行**持续集成/持续部署**（**CI/CD**）作业。运行者可以在主机上的Docker容器中运行，[https://docs.gitlab.com/runner/install/docker.html](https://docs.gitlab.com/runner/install/docker.html)：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can go ahead and register the runner with the host, [https://docs.gitlab.com/runner/register/index.html#docker](https://docs.gitlab.com/runner/register/index.html#docker),
    under **Admin Area -> Runners -> Register** an instance runner. We will take note
    of the token:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续在**管理区域 -> 运行者 -> 注册**下注册主机运行者，[https://docs.gitlab.com/runner/register/index.html#docker](https://docs.gitlab.com/runner/register/index.html#docker)。我们将注意令牌：
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_15_06.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B18403_15_06.png)'
- en: 'Figure 15.6: GitLab Runner Registration'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：GitLab运行者注册
- en: 'We can then use the token to pull and register a runner with a base image:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用令牌来拉取并注册一个基于镜像的运行者：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are now ready to handle our first job!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好处理我们的第一个作业了！
- en: First GitLab example
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个GitLab示例
- en: 'We can begin by creating a separate user under **Menu -> Admin Area -> Users**
    (under Overview) and login via that user:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从在**菜单 -> 管理区域 -> 用户**（在概览下）下创建一个单独的用户开始，并通过该用户登录：
- en: '![Graphical user interface  Description automatically generated](img/B18403_15_07.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B18403_15_07.png)'
- en: 'Figure 15.7: GitLab Users'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7：GitLab用户
- en: 'To push or pull from repositories, we will also add our SSH key. This can be
    done via the settings section within the user profile:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要从仓库推送或拉取，我们还将添加我们的SSH密钥。这可以通过用户配置文件中的设置部分完成：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_15_08.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B18403_15_08.png)'
- en: 'Figure 15.8: User SSH Key'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：用户SSH密钥
- en: 'We can now create a new project under **Menu -> Projects -> Create New Project**:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在**菜单 -> 项目 -> 创建新项目**下创建一个新项目：
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_15_09.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B18403_15_09.png)'
- en: 'Figure 15.9: Create New Project'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9：创建新项目
- en: 'We will name this project `chapter15_example1`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个项目命名为`chapter15_example1`：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_15_10.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B18403_15_10.png)'
- en: 'Figure 15.10: New Project Settings'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10：新项目设置
- en: We can leave the rest of the settings as we see fit. As a precaution, I typically
    leave the project visibility on private, but we can always change that later.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保留其他设置不变。作为预防措施，我通常将项目可见性设置为私有，但我们可以稍后更改它。
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_15_11.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B18403_15_11.png)'
- en: 'Figure 15.11: Project Clone URL'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11：项目克隆URL
- en: 'We can grab the URL for the project and clone that project on our management
    station:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取项目的URL并在我们的管理站上克隆该项目：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will create a special file `.gitlab-ci.yml` that is recognized by GitLab
    as a CI/CD instruction:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个特殊的文件`.gitlab-ci.yml`，该文件被GitLab识别为CI/CD指令：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will check in, commit, and push the file to our GitLab repository:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将签入、提交并将文件推送到我们的GitLab仓库：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `.gitlab-ci.yml` file contains instructions for a GitLab CI/CD pipeline
    in a YAML format. It contains two main sections, stage and job definition:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`.gitlab-ci.yml` 文件包含用于GitLab CI/CD管道的YAML格式指令。它包含两个主要部分，阶段和作业定义：'
- en: '![A picture containing diagram  Description automatically generated](img/B18403_15_12.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片  自动生成的描述](img/B18403_15_12.png)'
- en: 'Figure 15.12: GitLab CI File'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12：GitLab CI文件
- en: In our file, we defined three stages with the keyword `stages`. In the execution
    section, we define the Docker base image to be pulled, the name of the job to
    be done, the stage it corresponds to, as well as the steps to be executed under
    `script`. There can be optional instructions such as `artifacts` under `build`
    and `when` under `deploy`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文件中，我们使用关键字`stages`定义了三个阶段。在执行部分，我们定义了要拉取的Docker基础镜像、要执行的作业名称、对应的阶段以及`script`下要执行的步骤。在`build`下可以有可选的指令如`artifacts`，在`deploy`下可以有可选的指令如`when`。
- en: 'If we move back to the project, we can click on **CI/CD -> Pipelines** to show
    us the status of the job:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到项目，我们可以点击**CI/CD -> 管道**来显示作业的状态：
- en: '![Table  Description automatically generated with medium confidence](img/B18403_15_13.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成，中等置信度](img/B18403_15_13.png)'
- en: 'Figure 15.13: CI/CD Pipeline'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13：CI/CD管道
- en: There are three circles, each representing a stage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个圆圈，每个代表一个阶段。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_15_14.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](img/B18403_15_14.png)'
- en: 'Figure 15.14: Pipeline Output'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14：管道输出
- en: 'We can click on the circles and see the container output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击圆圈并查看容器输出：
- en: '![Text  Description automatically generated](img/B18403_15_15.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18403_15_15.png)'
- en: 'Figure 15.15: Execution Output'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15：执行输出
- en: 'Remember we have optional steps under `build` and `deploy`? The artifacts give
    us something to download:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在`build`和`deploy`下有可选步骤吗？工件给我们提供了可以下载的内容：
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_15_16.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18403_15_16.png)'
- en: 'Figure 15.16: Artifacts'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16：工件
- en: 'The `when` keyword allows us to manually push out the step instead of having
    GitLab automatically execute for us:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`关键字允许我们手动推送步骤，而不是让GitLab自动为我们执行：'
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_15_17.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18403_15_17.png)'
- en: 'Figure 15.17: Manual Push'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17：手动推送
- en: Is this awesome, or what? We now have some workers automatically executing jobs
    for us. We can also leverage many of the features of Git for collaboration, such
    as inviting colleagues for code review. Let’s see another example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不是很棒？我们现在有一些工人自动为我们执行作业。我们还可以利用Git的许多协作功能，例如邀请同事进行代码审查。让我们看看另一个例子。
- en: GitLab network example
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab网络示例
- en: 'We will go ahead and create another project named `chapter15_example2` on the
    GitLab server. On the local machine, we will clone the remote repository:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在GitLab服务器上创建另一个名为`chapter15_example2`的项目。在本地机器上，我们将克隆远程仓库：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we will integrate the Nornir library to see how we can execute
    `show version` on two of the IOSv devices. We will begin by defining the `hosts.yaml`
    file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将集成Nornir库，看看我们如何在两个IOSv设备上执行`show version`。我们将首先定义`hosts.yaml`文件：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then construct the Python script for execution:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以构建用于执行的Python脚本：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will define a `requirements.txt` file to specify the packages to be installed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个`requirements.txt`文件来指定要安装的包：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will also define the `.gitlab-ci.yml` file to define the stages and the
    scripts. Notice in the file that we specify another `before_script` step to be
    executed before any of the stages:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义`.gitlab-ci.yml`文件来定义阶段和脚本。注意在文件中，我们指定了另一个在所有阶段之前执行的`before_script`步骤：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once the files are checked in and pushed to the repository, we can go to the
    CI/CD section to look at the outputs. The steps will take longer this time because
    of the package download time. We can click on the step and examine the execution
    in real time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被检查并推送到仓库，我们就可以转到CI/CD部分查看输出。这次步骤将因为包下载时间而花费更长的时间。我们可以点击步骤并实时检查执行情况。
- en: '![Text  Description automatically generated](img/B18403_15_18.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18403_15_18.png)'
- en: 'Figure 15.18: Nornir CI/CD Step Execution'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.18：Nornir CI/CD步骤执行
- en: We should be able to see the pipeline successfully executed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够看到管道成功执行。
- en: '![](img/B18403_15_19.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18403_15_19.png)'
- en: 'Figure 15.19: CI/CD Result'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.19：CI/CD结果
- en: Using GitLab CI/CD is a terrific way of automating our network operation steps.
    The pipeline might take longer to set up, but once it is completed, it will save
    us much time and allow us to preserve our energy to focus on more interesting
    work. For more information, check out [https://docs.gitlab.com/ee/ci/](https://docs.gitlab.com/ee/ci/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitLab CI/CD是自动化我们的网络操作步骤的绝佳方式。设置管道可能需要更长的时间，但一旦完成，它将为我们节省大量时间，并允许我们保留精力专注于更有趣的工作。更多信息，请参阅[https://docs.gitlab.com/ee/ci/](https://docs.gitlab.com/ee/ci/)。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined the traditional change management process and why
    it is not a good fit for today’s rapidly changing environment. The network needs
    to evolve with the business to become more agile and adapt to change quickly and
    reliably.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了传统的变革管理流程以及为什么它不适合当今快速变化的环境。网络需要与业务同步发展，以变得更加灵活，并能快速且可靠地适应变化。
- en: We looked at the concept of continuous integration, in particular, the open-source
    GitLab system. GitLab is a full-featured, expandable, continuous integration system
    widely used in software development. We can adapt the same system for our network
    operations. We saw two examples using the GitLab Git repository and runners to
    execute our operations automatically.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了持续集成的概念，特别是开源的GitLab系统。GitLab是一个功能全面、可扩展的持续集成系统，在软件开发中被广泛使用。我们可以将相同的系统应用于我们的网络操作。我们看到了两个使用GitLab
    Git仓库和运行器自动执行我们操作的例子。
- en: In *Chapter 16*, *Test-Driven Development for Networks*, we will look at test-driven
    development with Python.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16章“网络的测试驱动开发”中，我们将探讨使用Python进行测试驱动开发。
- en: Join our book community
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的社区——在这里您可以分享反馈、向作者提问，并了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code2903617220506617062.png)'
