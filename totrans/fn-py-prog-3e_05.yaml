- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: Higher-Order Functions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'A very important feature of the functional programming paradigm is higher-order
    functions. We’ll look at these three varieties of higher-order functions:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程范式的一个非常重要的特性是高阶函数。我们将探讨这三种高阶函数的类型：
- en: Functions that accept functions as one (or more) of their arguments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受函数作为其一个（或多个）参数的函数
- en: Functions that return a function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回函数的函数
- en: Functions that accept a function and return a function, a combination of the
    preceding two features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个函数并返回一个函数的函数，这是前两个特征的组合
- en: We’ll look at the built-in higher-order functions in this chapter. Separate
    from these functions, we’ll look at a few of the library modules that offer higher-order
    functions in later chapters after introducing the concepts here.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中探讨内置的高阶函数。除了这些函数之外，我们将在介绍这些概念之后，在后续章节中探讨几个提供高阶函数的库模块。
- en: Functions that accept functions and create functions include complex callable
    classes as well as function decorators. We’ll defer consideration of decorators
    until [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator Design Techniques](Chapter_12.xhtml#x1-25000012).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接受函数并创建函数的函数包括复杂的可调用类以及函数装饰器。我们将推迟到第12章[《装饰器设计技术》](Chapter_12.xhtml#x1-25000012)讨论装饰器。
- en: 'In this chapter, we’ll look at the following functions:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下函数：
- en: '`max()` and `min()`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max()`和`min()`'
- en: '`map()`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`'
- en: '`filter()`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`'
- en: '`iter()`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iter()`'
- en: '`sorted()`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted()`'
- en: Additionally, we’ll look at the `itemgetter()` function in the `operator` module.
    This function is useful for extracting an item from a sequence.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将探讨`operator`模块中的`itemgetter()`函数。这个函数对于从序列中提取一个元素非常有用。
- en: We’ll also look at lambda forms that we can use to simplify using higher-order
    functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨我们可以用来简化使用高阶函数的lambda表达式。
- en: The `max()` and `min()` functions are reductions; they create a single value
    from a collection. The other functions are mappings. They don’t reduce the input
    to a single value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`和`min()`函数是归约函数；它们从集合中创建一个单一值。其他函数是映射函数。它们不会将输入归约为一个单一值。'
- en: The `max()`, `min()`, and `sorted()` functions have both a default behavior
    as well as a higher-order function behavior. If needed, a function can be provided
    via the `key=` argument. There is a meaningful default behavior for these functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`、`min()`和`sorted()`函数既有默认行为，也有高阶函数行为。如果需要，可以通过`key=`参数提供一个函数。这些函数有有意义的默认行为。'
- en: The `map()` and `filter()` functions take the function as the first positional
    argument. Here, the function is required because there is no default behavior.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`和`filter()`函数将函数作为第一个位置参数。在这里，由于没有默认行为，所以需要函数。'
- en: There are a number of higher-order functions in the `itertools` module. We’ll
    look at this module in [Chapter 8](Chapter_08.xhtml#x1-1700008), [The Itertools
    Module](Chapter_08.xhtml#x1-1700008), and [Chapter 9](Chapter_09.xhtml#x1-1990009),
    [Itertools for Combinatorics – Permutations and Combinations](Chapter_09.xhtml#x1-1990009).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块中有许多高阶函数。我们将在第8章[《itertools模块》](Chapter_08.xhtml#x1-1700008)、第9章[《组合学中的itertools
    – 排列和组合》](Chapter_09.xhtml#x1-1990009)中探讨这个模块。'
- en: Additionally, the `functools` module provides a general-purpose `reduce()` function.
    We’ll look at this in [Chapter 10](Chapter_10.xhtml#x1-21700010), [The Functools
    Module](Chapter_10.xhtml#x1-21700010), because it requires a bit more care to
    use. We need to avoid transforming an inefficient algorithm into a nightmare of
    excessive processing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`functools`模块提供了一个通用的`reduce()`函数。我们将在第10章[《functools模块》](Chapter_10.xhtml#x1-21700010)中探讨这个函数，因为它需要更多的注意来使用。我们需要避免将一个低效的算法转变为过度处理的噩梦。
- en: 5.1 Using max() and min() to find extrema
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1 使用max()和min()查找极值
- en: 'The `max()` and `min()` functions each have a dual life. They are simple functions
    that apply to collections. They are also higher-order functions. We can see their
    default behavior as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`和`min()`函数各有两种生活。它们是应用于集合的简单函数，也是高阶函数。我们可以如下看到它们的默认行为：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Both functions will accept an indefinite number of arguments. The functions
    are designed to also accept a sequence or an iterable as the only argument and
    locate the max (or min) of that iterable. When applied to a mapping collection,
    they will locate the maximum (or minimum) key value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数都将接受一个不确定数量的参数。这些函数设计为也可以接受一个序列或可迭代对象作为唯一参数，并找到该可迭代对象的极大值（或极小值）。当应用于映射集合时，它们将找到最大（或最小）键值。
- en: 'They also do something more sophisticated. Let’s say we have our trip data
    from the examples in [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004).
    We have a function that will generate a sequence of tuples that looks as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还做了更复杂的事情。假设我们有从[第4章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)中的示例中得到的行程数据。我们有一个函数可以生成一系列看起来如下所示的元组序列：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each tuple in this collection has three values: a starting location, an ending
    location, and a distance. The locations are given in latitude and longitude pairs.
    The east latitude is positive; these are points along the US East Coast, about
    76° west. The distances between points are in nautical miles.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合中的每个元组包含三个值：一个起始位置，一个结束位置，以及一个距离。位置以纬度和经度对给出。东经纬度是正数；这些是沿着美国东海岸的点，大约在76°西。点之间的距离以海里为单位。
- en: 'We have three ways of getting the maximum and minimum distances from this sequence
    of values. They are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种方法从这些值序列中获取最大和最小距离。具体如下：
- en: Extract the distance with a generator function. This will give us only the distances,
    as we’ve discarded the other two attributes of each leg. This won’t work out well
    if we have any additional processing requirements based on the latitude or longitude.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器函数提取距离。这将只给我们距离，因为我们已经丢弃了每个部分的另外两个属性。如果我们有任何基于纬度或经度的额外处理需求，这不会很好。
- en: Use the `unwrap(process(wrap()))` pattern. This will give us the legs with the
    longest and shortest distances. From these, we can extract the distance or the
    point as needed.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `unwrap(process(wrap()))` 模式。这将给我们最长和最短距离的路段。从这些路段中，我们可以根据需要提取距离或点。
- en: Use the `max()` and `min()` functions as higher-order functions, inserting a
    function that does the extraction of the important distance values. This will
    also preserve the original objects with all of their attributes.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `max()` 和 `min()` 函数作为高阶函数，插入一个用于提取重要距离值的函数。这将保留所有原始对象及其属性。
- en: 'To provide context, the following script builds the overall trip:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供上下文，以下脚本构建了整个行程：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The resulting `trip` object is a list object, containing the individual legs.
    Each leg is a three-tuple with the starting point, the ending point, and the distance,
    computed with the `haversine()` function. The `leg()` function creates start-end
    pairs from the overall path of points in the original KML file. The `list()` function
    consumes values from the lazy generator to materialize the list of legs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 `trip` 对象是一个列表对象，包含单个路段。每个路段是一个包含起点、终点和距离的三元组，使用 `haversine()` 函数计算得出。`leg()`
    函数从原始KML文件中点的整体路径创建起点-终点对。`list()` 函数从惰性生成器中消耗值，以具体化路段列表。
- en: 'Once we have the `trip` object, we can extract distances and compute the maximum
    and minimum of those distances. The code to do this with a generator function
    looks as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `trip` 对象，我们可以提取距离并计算这些距离的最大值和最小值。使用生成器函数执行此操作的代码如下：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ve used a generator function to extract the relevant item from each leg of
    the trip tuple. We’ve had to repeat the generator expression because the expression
    `dist`` for`` start,`` end,`` dist`` in`` trip` can be consumed only once.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用生成器函数从行程元组的每个部分中提取相关项目。我们必须重复生成器表达式，因为表达式 `dist` for `start`, `end`, `dist`
    in `trip` 只能被消耗一次。
- en: 'Here are the results based on a larger set of data than was shown previously:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是基于比之前展示的数据集更大的数据集的结果：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It may help to refer to [Chapter 2](Chapter_02.xhtml#x1-340002), [Introducing
    Essential Functional Concepts](Chapter_02.xhtml#x1-340002), for examples of the
    wrap-process-unwrap design pattern.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以参考[第2章](Chapter_02.xhtml#x1-340002)，[介绍基本功能概念](Chapter_02.xhtml#x1-340002)，了解wrap-process-unwrap设计模式的示例。
- en: 'The following is a version of the `unwrap(process(wrap()))` pattern applied
    to this data:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将 `unwrap(process(wrap()))` 模式应用于这些数据的一个版本：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use these functions as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些函数如下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The final and most important form uses the higher-order function feature of
    the `max()` and `min()` functions. We’ll define a helper function first and then
    use it to reduce the collection of legs to the desired summaries by executing
    the following code snippet:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后且最重要的形式使用了 `max()` 和 `min()` 函数的高阶函数特性。我们首先定义一个辅助函数，然后使用它通过执行以下代码片段来将腿的集合缩减到所需的摘要：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can use this function as the `key=` argument value to the built-in `max()`
    function. It looks like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此函数用作内置 `max()` 函数的 `key=` 参数值。它看起来像这样：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `by_dist()` function picks apart the three items in each leg tuple and returns
    the distance item. We’ll use this with the `max()` and `min()` functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`by_dist()` 函数将每个腿元组中的三个项目分开，并返回距离项。我们将使用它与 `max()` 和 `min()` 函数一起使用。'
- en: The `max()` and `min()` functions both accept an iteratable and a function as
    arguments. The keyword parameter `key=` is used by many of Python’s higher-order
    functions to provide a function that will be used to extract the necessary key
    value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()` 和 `min()` 函数都接受一个可迭代的和一个函数作为参数。关键字参数 `key=` 被许多 Python 的高阶函数用来提供一个函数，该函数将被用来提取必要的键值。'
- en: 5.1.1 Using Python lambda forms
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1 使用 Python lambda 形式
- en: In many cases, the definition of a helper function seems to require too much
    code. Often, we can digest the `key=` function to a single expression. It can
    seem wasteful to have to write both `def` and `return` statements to wrap a single
    expression.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，辅助函数的定义似乎需要太多的代码。通常，我们可以将 `key=` 函数简化为一个单一的表达式。写两个 `def` 和 `return` 语句来包装一个单一表达式可能看起来有些浪费。
- en: Python offers the lambda form as a way to simplify using higher-order functions.
    A lambda form allows us to define a small, anonymous function. The function’s
    body is limited to a single expression.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了 lambda 形式作为一种简化使用高阶函数的方法。lambda 形式允许我们定义一个小的、匿名函数。函数体仅限于一个表达式。
- en: 'The following is an example of using a simple lambda expression as the `key=`
    function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用简单的 lambda 表达式作为 `key=` 函数的示例：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The lambda we’ve used will be given an item from the sequence; in this case,
    each leg three-tuple will be given to the lambda. The lambda argument variable,
    `leg`, is assigned and the expression, `leg[2]`, is evaluated, plucking the distance
    from the three-tuple.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的 lambda 将会接收到序列中的一个项目；在这种情况下，每个三元组腿将传递给 lambda。lambda 参数变量 `leg` 被分配，表达式
    `leg[2]` 被评估，从三元组中提取距离。
- en: In cases where a lambda is used exactly once, this form is ideal. When reusing
    a lambda, it’s important to avoid copy and paste. In the above example, the lambda
    is repeated, a potential software maintenance nightmare. What’s the alternative?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 lambda 正好使用一次的情况下，这种形式是理想的。当重用 lambda 时，避免复制和粘贴很重要。在上面的例子中，lambda 被重复，这可能导致潜在的软件维护噩梦。那么替代方案是什么？
- en: 'We can assign lambdas to variables, by doing something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这样做将 lambda 分配给变量：`by_dist()` 函数将每个腿元组中的三个项目分开，并返回距离项。我们将使用它与 `max()`
    和 `min()` 函数一起使用。
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each of these lambda forms is a callable object, similar to a defined function.
    They can be used like a function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些 lambda 形式都是一个可调用的对象，类似于定义的函数。它们可以像函数一样使用。
- en: 'The following is an example at the interactive prompt:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在交互提示符中的示例：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here are two reasons for avoiding this technique:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种技术的两个原因如下：
- en: PEP 8, the style guide for Python code, advises against assigning lambda objects
    to variables. See [https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/)
    for more information.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 8，Python 代码的风格指南，建议不要将 lambda 对象分配给变量。有关更多信息，请参阅 [https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/)。
- en: The `operator` module provides a generic item getter, `itemgetter()`. This is
    a higher-order function that returns a function we can use instead of a lambda
    object.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator` 模块提供了一个通用的项获取器，`itemgetter()`。这是一个高阶函数，它返回一个我们可以用来替代 lambda 对象的函数。'
- en: To extend this example, we’ll look at how we get the latitude or longitude value
    of the starting or ending point.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展这个例子，我们将看看如何获取起点或终点的纬度或经度值。
- en: 'The following is a continuation of the interactive session:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个交互会话的延续：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ve imported the `itemgetter()` function from the `operator` module. The value
    returned by this function is a function that will grab the requested item from
    a sequence. In the first part of the example, the `start()` function will extract
    item `0` from a sequence.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已从 `operator` 模块中导入了 `itemgetter()` 函数。该函数返回的值是一个函数，它将从序列中抓取所需的项目。在示例的第一部分，`start()`
    函数将从序列中提取项目 `0`。
- en: The `lat()` and `lon()` functions, similarly, are created by the `itemgetter()`
    function. Note that the complexity of the nested tuples in the data structure
    must be carefully paralleled with the `itemgetter()` functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`lat()` 和 `lon()` 函数是由 `itemgetter()` 函数创建的。请注意，数据结构中嵌套元组的复杂性必须与 `itemgetter()`
    函数仔细对应。
- en: There’s no clear advantage to using lambda objects or `itemgetter()` functions
    as a way to extract fields over defining a `typing.NamedTuple` class or a dataclass.
    Using lambdas (or better, the `itemgetter()` function) does allow the code to
    rely on prefix function notation, which might be easier to read in a functional
    programming context. We can gain a similar advantage by using the `operator.attrgetter`
    function to extract a specific attribute from a `typing.NamedTuple` class or dataclass.
    Using `attrgetter` duplicates a name. For example, a `typing.NamedTuple` class
    with an attribute of `lat` may also use `attrgetter(’lat’)`; this can make it
    slightly harder to locate all references to an attribute when refactoring.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 lambda 对象或 `itemgetter()` 函数作为提取字段的方法，与定义 `typing.NamedTuple` 类或数据类相比，没有明显的优势。使用
    lambda（或者更好的是 `itemgetter()` 函数）确实允许代码依赖于前缀函数符号，这在函数式编程环境中可能更容易阅读。我们可以通过使用 `operator.attrgetter`
    函数从 `typing.NamedTuple` 类或数据类中提取特定属性来获得类似的优势。使用 `attrgetter` 会复制一个名称。例如，具有 `lat`
    属性的 `typing.NamedTuple` 类也可以使用 `attrgetter('lat')`；这可能会在重构时稍微难以找到所有对属性的引用。
- en: 5.1.2 Lambdas and the lambda calculus
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2 Lambda 表达式和 lambda 演算
- en: If Python were a purely functional programming language, it would be necessary
    to explain Church’s lambda calculus, and the technique invented by Haskell Curry
    that we call currying. Python, however, doesn’t stick closely to the lambda calculus.
    Functions are not curried to reduce them to single-argument lambda forms.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Python 是一种纯粹的函数式编程语言，那么就有必要解释 Church 的 lambda 演算，以及 Haskell Curry 发明的我们称之为柯里化的技术。然而，Python
    并没有严格遵循 lambda 演算。函数不会被柯里化以简化为单参数 lambda 形式。
- en: Python lambda forms are not restricted to single-argument functions. They can
    have any number of arguments. They are restricted to a single expression, however.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 lambda 表达式不仅限于单参数函数。它们可以有任意数量的参数。然而，它们被限制为单个表达式。
- en: We can, using the `functools.partial` function, implement currying. We’ll save
    this for [Chapter 10](Chapter_10.xhtml#x1-21700010), [The Functools Module](Chapter_10.xhtml#x1-21700010).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `functools.partial` 函数来实现柯里化。我们将这个内容留到第 10 章[《Functools 模块》](Chapter_10.xhtml#x1-21700010)中讲解。
- en: 5.2 Using the map() function to apply a function to a collection
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2 使用 map() 函数将函数应用于集合
- en: A scalar function maps values from a domain to a range. When we look at the
    `math.sqrt()` function, as an example, we’re looking at a mapping from a float
    value, `x`, to another float value, `y`` =`` sqrt(x)`, such that y² = x. The domain
    is limited to non-negative values for the `math` module. When using the `cmath`
    module, any number can be used, and the results can be complex numbers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 标量函数将域中的值映射到值域中。以 `math.sqrt()` 函数为例，我们正在查看一个从浮点值 `x` 映射到另一个浮点值 `y = sqrt(x)`
    的映射，使得 y² = x。域被限制为 `math` 模块中的非负值。当使用 `cmath` 模块时，任何数字都可以使用，结果可以是复数。
- en: The `map()` function expresses a similar concept; it maps values from one collection
    to create another collection. It assures that the given function is used to map
    each individual item from the domain collection to the range collection—this is
    the ideal way to apply a built-in function to a collection of data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数表达了一个类似的概念；它将一个集合中的值映射到另一个集合中。它确保给定的函数被用来将域集合中的每个单独的项目映射到值集合中——这是将内置函数应用于数据集合的理想方式。'
- en: 'Our first example involves parsing a block of text to get a sequence of numbers.
    Let’s say we have the following chunk of text:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子涉及解析一段文本以获取一系列数字。假设我们有以下文本块：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can restructure this text using the following generator function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下生成器函数重新结构化这段文本：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will split the text into lines. For each line, it will split the line
    into space-delimited words and iterate through each of the resulting strings.
    The results look as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把文本拆分成行。对于每一行，它将行拆分为空格分隔的单词，并遍历每个生成的字符串。结果如下所示：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We still need to apply the `int()` function to each of the string values. This
    is where the `map()` function excels. Take a look at the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要将 `int()` 函数应用于每个字符串值。这正是 `map()` 函数大显身手的地方。看看下面的代码片段：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `map()` function applied the `int()` function to each value in the collection.
    The result is a sequence of numbers instead of a sequence of strings.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数将`int()`函数应用于集合中的每个值。结果是数字序列而不是字符串序列。'
- en: The `map()` function’s results are iterable. The `map()` function can process
    any type of iterable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数的结果是可迭代的。`map()`函数可以处理任何类型的可迭代对象。'
- en: The idea here is that any Python function can be applied to the items of a collection
    using the `map()` function. There are a lot of built-in functions that can be
    used in this map-processing context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的想法是，任何Python函数都可以通过`map()`函数应用于集合中的项。在这个map处理上下文中，有很多内置函数可以使用。
- en: 5.2.1 Working with lambda forms and map()
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1 使用lambda形式和map()
- en: Let’s say we want to convert our trip distances from nautical miles to statute
    miles. We want to multiply each leg’s distance by `6076.12/5280`, which is `1.150780`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将旅行的距离从海里转换为英里。我们想要将每段的距离乘以`6076.12/5280`，即`1.150780`。
- en: 'We’ll rely on a number of `itemgetter` functions to extract data from the data
    structure. We can combine extractions with computation of new values. We can do
    this calculation with the `map()` function as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依赖多个`itemgetter`函数从数据结构中提取数据。我们可以将提取与计算新值相结合。我们可以使用以下方式通过`map()`函数进行此计算：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve defined a lambda that will be applied to each leg in the trip by the `map()`
    function. The lambda will use the `itemgetter` function to separate the start,
    end, and distance values from each leg’s tuple. It will compute a revised distance
    and assemble a new leg tuple from the start, end, and statute mile distances.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个lambda表达式，该表达式将由`map()`函数应用于旅行的每一段。这个lambda表达式将使用`itemgetter`函数从每一段的元组中分离出起点、终点和距离值。它将计算一个修订后的距离，并从起点、终点和英里距离中组装一个新的段元组。
- en: 'This is precisely like the following generator expression:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这正好像以下生成器表达式：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ve done the same processing on each item in the generator expression.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对生成器表达式中的每个项目都进行了相同的处理。
- en: Using the built-in `map()` function or a generator expression will produce identical
    results and have nearly identical performance. The choice of using lambdas, named
    tuples, defined functions, the `operator.itemgetter()` function, or generator
    expressions is entirely a matter of how to make the resulting application program
    succinct and expressive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`map()`函数或生成器表达式将产生相同的结果，并且几乎具有相同的性能。使用lambda、命名元组、定义的函数、`operator.itemgetter()`函数或生成器表达式的选择完全是关于如何使结果应用程序简洁且易于理解。
- en: 5.2.2 Using map() with multiple sequences
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2 使用map()与多个序列
- en: 'Sometimes, we’ll have two collections of data that need to be parallel to each
    other. In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we saw how the `zip()` function can interleave two sequences to create a sequence
    of pairs. In many cases, we’re really trying to do something like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会有两个需要相互并行对齐的数据集合。在[第4章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)中，我们看到了`zip()`函数如何将两个序列交织在一起以创建一对序列。在许多情况下，我们实际上试图做的是以下这样：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’re creating argument tuples from two (or more) parallel iterables and applying
    a function to the argument tuple. This can be awkward because the parameters to
    the given function, `function()`, will be a single two-tuple; the argument values
    will not be applied to each parameter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从两个（或更多）并行可迭代对象中创建参数元组，并将函数应用于参数元组。这可能有些尴尬，因为给定函数`function()`的参数将是一个单一的二元组；参数值将不会应用于每个参数。
- en: 'As a consequence, we can think about using the following technique to decompose
    the tuple into two individual parameters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以考虑使用以下技术将元组分解为两个单独的参数：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we’ve replaced the `map()` function with an equivalent generator expression.
    `for`` x,`` y` decomposes the two-tuples so we can apply them to each parameter
    of the function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用等价的生成器表达式替换了`map()`函数。`for x, y`将二元组分解，以便我们可以将它们应用于函数的每个参数。
- en: There is a better approach that is already available to us. Let’s look at a
    concrete example of the alternate approach.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更好的方法已经可供我们使用。让我们看看这种替代方法的具体例子。
- en: In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we looked at trip data that we extracted from an XML file as a series of waypoints.
    We needed to create legs from this list of waypoints that show the start and end
    of each leg.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)中，我们查看从XML文件中提取的航迹数据，作为一系列航点。我们需要从这个航点列表中创建表示每段起止点的航段。
- en: 'The following is a simplified version that uses the `zip()` function applied
    to two slices of a sequence:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的简化版本使用了应用于序列两个切片的`zip()`函数：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’ve created a sequence of pairs drawn from a single flat list. Each pair will
    have two adjacent values. The `zip()` function stops when the shorter list is
    exhausted. This `zip(x,`` x[1:])` pattern only works for materialized sequences
    and the iterable created by the `range()` function. It won’t work for iterable
    objects because the slicing operation isn’t implemented.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个从单个扁平列表中抽取的成对序列。每一对将包含两个相邻的值。`zip()`函数在较短的列表耗尽时停止。这种`zip(x, x[1:])`模式仅适用于已物化的序列和由`range()`函数创建的可迭代对象。它不适用于可迭代对象，因为切片操作未实现。
- en: 'We created pairs so that we can apply the `haversine()` function to each pair
    to compute the distance between the two points on the path. The following is how
    it looks in one sequence of steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了成对，以便我们可以将`haversine()`函数应用于每一对，以计算路径上两点之间的距离。以下是如何在一系列步骤中看起来：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’ve built a list of waypoints, and labeled this with the `path` variable.
    This is an ordered sequence of latitude-longitude pairs. As we’re going to use
    the `zip(path,`` path[1:])` design pattern, we must have a materialized sequence
    and not an iterable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个航点列表，并用`path`变量标记。这是一个有序的纬度-经度对序列。由于我们将使用`zip(path, path[1:])`设计模式，我们必须有一个已物化的序列，而不是一个可迭代对象。
- en: The results of the `zip()` function will be pairs that have a start and end.
    We want our output to be a triple with the start, end, and distance. The lambda
    we’re using will decompose the original start-end two-tuple and create a new three-tuple
    from the start, end, and distance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数的结果将是具有起始和结束位置的成对元素。我们希望我们的输出是一个包含起始、结束和距离的三元组。我们使用的lambda表达式将分解原始的起始-结束二元组，并从起始、结束和距离创建一个新的三元组。'
- en: 'We can simplify this by using a clever feature of the `map()` function, which
    is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`map()`函数的巧妙特性来简化这一点，如下所示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we’ve provided a lambda object and two iterables to the `map()` function.
    The `map()` function will take the next item from each iterable and apply those
    two values as the arguments to the given function. In this case, the given function
    is a lambda that creates the desired three-tuple from the start, end, and distance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经向`map()`函数提供了一个lambda对象和两个可迭代对象。`map()`函数将从每个可迭代对象中获取下一个项目，并将这两个值作为给定函数的参数。在这种情况下，给定函数是一个lambda，它从起始、结束和距离创建所需的三个元素的三元组。
- en: The formal definition for the `map()` function states that it will do star-map
    processing with an indefinite number of iterables. It will take items from each
    iterable to create a tuple of argument values for the given function. This saves
    us from having to add the `zip` function to combine sequences.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数的正式定义表明它将对不定数量的可迭代对象进行星图处理。它将从每个可迭代对象中获取项目，为给定函数创建一个参数值的元组。这使我们免去了添加`zip`函数来组合序列的需要。'
- en: 5.3 Using the filter() function to pass or reject data
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3 使用filter()函数传递或拒绝数据
- en: The job of the `filter()` function is to use and apply a decision function called
    a predicate to each value in a collection. When the predicate function’s result
    is true, the value is passed; otherwise, the value is rejected. The `itertools`
    module includes `filterfalse()` as a variation on this theme. Refer to [Chapter 8](Chapter_08.xhtml#x1-1700008),
    [The Itertools Module](Chapter_08.xhtml#x1-1700008), to understand the usage of
    the `itertools` module’s `filterfalse()` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数的职责是使用并应用一个称为谓词的决策函数到集合中的每个值。当谓词函数的结果为真时，值被传递；否则，值被拒绝。`itertools`模块包括`filterfalse()`作为这一主题的变体。请参阅[第8章](Chapter_08.xhtml#x1-1700008)，[itertools模块](Chapter_08.xhtml#x1-1700008)，以了解`itertools`模块的`filterfalse()`函数的使用。'
- en: 'We might apply this to our trip data to create a subset of legs that are over
    50 nautical miles long, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能将此应用于我们的航迹数据，以创建超过50海里长的航段子集，如下所示：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The predicate lambda will be `True` for long legs, which will be passed. Short
    legs will be rejected. The output contains the 14 legs that pass this distance
    test.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长腿，谓词lambda将是`True`，将被通过。短腿将被拒绝。输出包含通过这个距离测试的14条腿。
- en: This kind of processing clearly segregates the filter rule `(lambda`` leg:`` dist(leg)`` >=`` 50)`
    from any other processing that creates the trip object or analyzes the long legs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '这种处理明显将filter规则`(lambda leg: dist(leg) >= 50)`与其他任何创建trip对象或分析长腿的处理分离。'
- en: 'For another simple example, look at the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个简单的例子，看看以下代码片段：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We’ve defined a small lambda to check whether a number is a multiple of three
    or a multiple of five. We’ve applied that function to an iterable, `range(10)`.
    The result is an iterable sequence of numbers that are passed by the decision
    rule.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个小的lambda函数来检查一个数是否是3的倍数或5的倍数。我们将该函数应用于可迭代对象`range(10)`。结果是满足决策规则的数字的可迭代序列。
- en: The numbers for which the lambda is `True` are `[0,`` 3,`` 5,`` 6,`` 9]`, so
    these values are passed. As the lambda is `False` for all other numbers, they
    are rejected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于lambda为`True`的数字，它们是`[0, 3, 5, 6, 9]`，因此这些值被通过。由于lambda对于所有其他数字都是`False`，它们被拒绝。
- en: The `_` variable is a special feature of Python’s REPL. It is implicitly set
    to the result of an expression. In the previous example, the `filter(...)` result
    was assigned to `_`. On the next line, `sum(_)` consumed the values from the `filter(...)`
    result.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`_`变量是Python的REPL的一个特殊功能。它隐式地设置为表达式的结果。在上一个例子中，`filter(...)`的结果被分配给`_`。在下一行，`sum(_)`消耗了`filter(...)`的结果。'
- en: This is only available in the REPL, and exists to save us a little bit of typing
    when we’re exploring complex functions interactively.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在REPL中可用，并且存在是为了在我们交互式探索复杂函数时节省我们一些输入。
- en: 'This can also be done with a generator expression by executing the following
    code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过执行以下代码使用生成器表达式来完成：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can formalize this using the following set comprehension notation:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下集合推导表示法来形式化这一点：
- en: '![{x | 0 ≤ x < 10 ∧ (x ≡ 0 mod 3 ∨ x ≡ 0 mod 5)} ](img/file47.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![满足条件 \(x | 0 \leq x < 10 \land (x \equiv 0 \mod 3 \lor x \equiv 0 \mod 5)\)
    的集合](img/file47.jpg)'
- en: This says that we’re building a collection of x values such that x is in `range(10)`
    and `x`` %`` 3`` ==`` 0`` or`` x`` %`` 5`` ==`` 0`. There’s a very elegant symmetry
    between the `filter()` function and formal mathematical set comprehensions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们正在构建一个包含x值的集合，其中x在`range(10)`中，且`x % 3 == 0`或`x % 5 == 0`。`filter()`函数和形式化的数学集合推导之间有一个非常优雅的对称性。
- en: 'We often want to use the `filter()` function with defined functions instead
    of lambda forms. The following is an example of reusing a predicate defined earlier:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望使用定义好的函数而不是lambda形式来使用`filter()`函数。以下是一个重用之前定义的谓词的例子：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we imported a function from another module called `isprimeg()`.
    We then applied this function to a collection of values to pass the prime numbers
    and reject any non-prime numbers from the collection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从一个名为`isprimeg()`的其他模块中导入了一个函数。然后我们将此函数应用于一组值，以通过素数并从集合中拒绝任何非素数。
- en: This can be a remarkably inefficient way to generate a table of prime numbers.
    The superficial simplicity of this is the kind of thing lawyers call an attractive
    nuisance. It looks like it might be fun, but it doesn’t scale well at all. The
    `isprimeg()` function duplicates all of the testing effort for each new value.
    Some kind of cache is essential to provide redoing the testing of primality. A
    better algorithm is the Sieve of Eratosthenes; this algorithm retains the previously
    located prime numbers and uses them to prevent recalculation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一种生成素数表的非常低效的方法。这种表面的简单性是律师所说的吸引人的诱惑。它看起来可能很有趣，但根本无法扩展。`isprimeg()`函数为每个新值重复所有的测试工作。某种缓存对于提供素性测试的重做是必不可少的。一个更好的算法是埃拉托斯特尼筛法；这个算法保留之前找到的素数，并使用它们来防止重新计算。
- en: For more information on primality testing, and this algorithm for finding small
    prime numbers, see [https://primes.utm.edu/prove/prove2_1.html](https://primes.utm.edu/prove/prove2_1.html).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于素性检验的更多信息，以及寻找小素数的此算法，请参阅 [https://primes.utm.edu/prove/prove2_1.html](https://primes.utm.edu/prove/prove2_1.html)。
- en: 5.3.1 Using filter() to identify outliers
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1 使用filter()识别异常值
- en: In the previous chapter, we defined some useful statistical functions to compute
    mean and standard deviation and normalize a value. We can use these functions
    to locate outliers in our trip data. What we can do is apply the `mean()` and
    `stdev()` functions to the distance value in each leg of a trip to get the population
    mean and standard deviation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们定义了一些有用的统计函数来计算平均值和标准差以及归一化一个值。我们可以使用这些函数来定位旅行数据中的异常值。我们可以做的是将`mean()`和`stdev()`函数应用于旅行每一段的距离值，以得到种群的平均值和标准差。
- en: We can then use the `z()` function to compute a normalized value for each leg.
    If the normalized value is more than 3, the data is potentially far from the mean.
    If we reject these outliers, we have a more uniform set of data that’s less likely
    to harbor reporting or measurement errors.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`z()`函数计算每个部分的归一化值。如果归一化值大于3，数据可能远离平均值。如果我们拒绝这些异常值，我们将得到一个更均匀的数据集，这种数据集不太可能包含报告或测量错误。
- en: 'The following is how we can tackle this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何处理这种情况的方法：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We’ve mapped the distance function to each leg in the `trip` collection. The
    `dist()` function is the function created by `itemgetter(2)`. As we’ll do several
    things with the result, we must materialize a `list` object. We can’t rely on
    the iterator, as the first function in this sequence of steps will consume all
    of the iterator’s values. We can then use this extraction to compute population
    statistics μ`_d` and σ`_d` with the mean and standard deviation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将距离函数映射到`trip`集合中的每个部分。`dist()`函数是由`itemgetter(2)`创建的函数。由于我们将对结果进行多项操作，我们必须创建一个`list`对象。我们不能依赖于迭代器，因为在这个步骤序列中的第一个函数将消耗迭代器的所有值。然后我们可以使用这个提取来计算种群统计量μ`_d`和σ`_d`，即平均值和标准差。
- en: Given the mean and standard deviation values, we used the `outlier` lambda to
    filter our data. If the normalized value is too large, the data is an outlier.
    The threshold for ”too far from the mean” can vary based on the kind of distribution.
    For a normal distribution, the probability of a value being within three standard
    deviations from the mean is 0.997.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 给定平均值和标准差值，我们使用了`outlier` lambda来过滤我们的数据。如果归一化值过大，数据就是一个异常值。“远离平均值”的阈值可以根据分布类型而变化。对于正态分布，一个值在平均值三个标准差范围内的概率是0.997。
- en: The result of `list(filter(outlier,`` trip))` is a list of two legs that are
    quite long compared to the rest of the legs in the population. The average distance
    is about 34 nm, with a standard deviation of 24 nm.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`list(filter(outlier, trip))`的结果是一个列表，其中两条腿的长度与种群中其他腿相比非常长。平均距离约为34 nm，标准差为24
    nm。'
- en: We’re able to decompose a fairly complex problem into a number of independent
    functions, each of which can be easily tested in isolation. Our processing is
    a composition of simpler functions. This can lead to succinct, expressive functional
    programming.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够将一个相当复杂的问题分解成若干个独立的函数，每个函数都可以单独轻松测试。我们的处理过程是简单函数的组合。这可以导致简洁、表达力强的函数式编程。
- en: 5.4 The iter() function with a sentinel value
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4 带有哨兵值的iter()函数
- en: The built-in `iter()` function creates an iterator over an object of a collection
    class. The `list`, `dict`, and `set` classes all work with the `iter()` function
    to provide an iterator object for the items in the underlying collection. In most
    cases, we’ll allow the `for` statement to do this implicitly. In a few cases,
    however, we need to create an iterator explicitly. One example of this is to separate
    the head from the tail of a collection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`iter()`函数创建了一个集合类对象的迭代器。`list`、`dict`和`set`类都使用`iter()`函数为底层集合中的项提供一个迭代器对象。在大多数情况下，我们将允许`for`语句隐式地完成这项工作。然而，在少数情况下，我们需要显式地创建一个迭代器。一个例子是将集合的头和尾分开。
- en: 'Other uses of the `iter()` function include building iterators to consume the
    values created by a callable object (for example, a function) until a sentinel
    value is found. This feature is sometimes used with the `read()` method of a file
    to consume items until some end-of-line or end-of-file sentinel value is found.
    An expression such as `iter(file.read,`` ’\n’)` will evaluate the given function
    until the sentinel value, `’\n’`, is found. This must be used carefully: if the
    sentinel is not found, it can continue reading zero-length strings forever.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter()` 函数的其他用途包括构建迭代器以消耗由可调用对象（例如，函数）创建的值，直到找到哨兵值。这个特性有时与文件的 `read()` 方法一起使用，以消耗项目，直到找到某些行尾或文件结束哨兵值。表达式
    `iter(file.read, ''\n'')` 将评估给定的函数，直到找到哨兵值 `''\n''`。这必须谨慎使用：如果未找到哨兵值，它可能会无限期地读取空字符串。'
- en: Providing a callable function to `iter()` can be a bit challenging because the
    function we provide must maintain some state internally. This is generally looked
    at as undesirable in functional programs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `iter()` 提供一个可调用的函数可能有点挑战性，因为我们提供的函数必须内部维护一些状态。这在函数式程序中通常被视为不希望的。
- en: 'However, hidden state is a feature of an open file: each `read()` or `readline()`
    method of a file advances the internal state to the next character or the next
    line.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，隐藏状态是打开文件的一个特性：每个 `read()` 或 `readline()` 方法都会将文件的内部状态推进到下一个字符或下一行。
- en: 'Another example of explicit iteration is the way that a mutable collection
    object’s `pop()` method makes a stateful change to a collection object. The following
    is an example of using the `pop()` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 显式迭代的另一个例子是可变集合对象的 `pop()` 方法如何对集合对象进行状态性的更改。以下是一个使用 `pop()` 方法的示例：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `tail` variable was set to an iterator over the list `[1,`` 2,`` 3,`` None,`` 4,`` 5,`` 6]`
    that will be traversed by the `pop()` function. The default behavior of `pop()`
    is `pop(-1)`; that is, the elements are popped in the reverse order. This makes
    a stateful change to the list object: each time `pop()` is called, the item is
    removed, mutating the list. When the sentinel value is found, the iterator stops
    returning values. If the sentinel is not found, this will break with an `IndexError`
    exception.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail` 变量被设置为对列表 `[1, 2, 3, None, 4, 5, 6]` 的迭代器进行迭代，该迭代器将由 `pop()` 函数遍历。`pop()`
    的默认行为是 `pop(-1)`；也就是说，元素以相反的顺序弹出。这会对列表对象进行状态性更改：每次调用 `pop()` 时，都会移除项目，并修改列表。当找到哨兵值时，迭代器停止返回值。如果未找到哨兵值，这将引发
    `IndexError` 异常。'
- en: This kind of internal state management is something we’d like to avoid. Consequently,
    we won’t try to contrive a use for this feature.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内部状态管理是我们希望避免的。因此，我们不会试图为这个特性编造用途。
- en: 5.5 Using sorted() to put data in order
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5 使用 sorted() 对数据进行排序
- en: When we need to produce results in a defined order, Python gives us two choices.
    We can create a list object and use the `list.sort()` method to put items in an
    order. An alternative is to use the `sorted()` function. This function works with
    any iterable, but it creates a final `list` object as part of the sorting operation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要以定义的顺序产生结果时，Python 给我们提供了两个选择。我们可以创建一个列表对象，并使用 `list.sort()` 方法对项目进行排序。另一种选择是使用
    `sorted()` 函数。这个函数可以与任何可迭代对象一起使用，但在排序操作中它创建了一个最终的 `list` 对象。
- en: The `sorted()` function can be used in two ways. It can be simply applied to
    collections. It can also be used as a higher-order function using the `key=` argument.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()` 函数可以以两种方式使用。它可以简单地应用于集合。它也可以用作高阶函数，使用 `key=` 参数。'
- en: 'Let’s say we have our trip data from the examples in [Chapter 4](Chapter_04.xhtml#x1-740004),
    [Working with Collections](Chapter_04.xhtml#x1-740004). We have a function that
    will generate a sequence of tuples with the starting location, end location, and
    distance for each leg of a trip. The data looks as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有了来自[第 4 章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)的示例中的旅行数据。我们有一个函数，它将生成一系列包含旅行每一段的起始位置、结束位置和距离的元组。数据如下所示：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can see the default behavior of the `sorted()` function using the following
    interaction:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下交互查看 `sorted()` 函数的默认行为：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We used a generator expression `(dist(x)`` for`` x`` in`` trip)` to extract
    the distances from our trip data. The `dist()` function is the function created
    by `itemgetter(2)`. We then sorted this iterable collection of numbers to get
    the distances from 0.17 nm to 129.77 nm.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用生成器表达式 `(dist(x) for x in trip)` 从旅行数据中提取距离。`dist()` 函数是由 `itemgetter(2)`
    创建的函数。然后我们对这个可迭代数字集合进行排序，以获取从 0.17 nm 到 129.77 nm 的距离。
- en: 'If we want to keep the legs and distances together in their original three-tuples,
    we can have the `sorted()` function apply a `key=` function to determine how to
    sort the tuples, as shown in the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在原始的三元组中保留腿和距离，我们可以让`sorted()`函数应用一个`key=`函数来确定如何对元组进行排序，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ve sorted the trip data, using the `dist()` function to extract the distance
    from each tuple. The `dist()` function, shown earlier, is created by the `itemgetter()`
    function as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对旅行数据进行了排序，使用`dist()`函数从每个元组中提取距离。前面展示的`dist()`函数是由`itemgetter()`函数创建的，如下所示：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As an alternative, we can also use a `lambda`` leg:`` leg[2]` to select a specific
    value from a tuple. Providing a name, `dist`, makes it a little more clear which
    item is being selected from the tuple.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '作为替代，我们也可以使用`lambda leg: leg[2]`从元组中选择特定的值。提供一个名称`dist`可以使它更清楚地表明正在从元组中选择哪个项。'
- en: 5.6 Overview of writing higher-order functions
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6 高阶函数编写概述
- en: 'We’ll look at designing our own higher-order functions. We’ll summarize some
    of the process before diving into some more complex kinds of design patterns.
    We’ll start by looking at common data transformations, such as the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨设计我们自己的高阶函数。在深入研究一些更复杂的设计模式之前，我们将总结一些过程。我们将从查看常见的数据转换开始，如下所示：
- en: Wrap objects to create more complex objects
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象包装以创建更复杂的对象
- en: Unwrap complex objects into their components
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将复杂对象解包为其组件
- en: Flatten a structure
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展平一个结构
- en: Structure a flat sequence
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化扁平序列
- en: These patterns can help to visualize ways higher-order functions can be designed
    in Python.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式有助于可视化Python中高阶函数的设计方式。
- en: It can also help to recall that a `Callable` class definition is a function
    that returns a callable object. We’ll look at this as a way to write flexible
    functions into which configuration parameters can be injected.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这也有助于回忆起一个`Callable`类定义是一个返回可调用对象的函数。我们将把它视为一种将配置参数注入灵活函数的方法。
- en: We’ll defer deeper consideration of decorators until [Chapter 12](Chapter_12.xhtml#x1-25000012),
    [Decorator Design Techniques](Chapter_12.xhtml#x1-25000012). A decorator is also
    a higher-order function, but it consumes one function and returns another, making
    it more complex than the examples in this chapter. We’ll start with developing
    highly-customized versions of `map()` and `filter()`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将推迟对装饰器的深入考虑，直到[第12章](Chapter_12.xhtml#x1-25000012)，[装饰器设计技术](Chapter_12.xhtml#x1-25000012)。装饰器也是一个高阶函数，但它消耗一个函数并返回另一个，这使得它比本章中的示例更复杂。我们将从开发高度定制的`map()`和`filter()`版本开始。
- en: 5.7 Writing higher-order mappings and filters
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7 编写高阶映射和过滤器
- en: Python’s two built-in higher-order functions, `map()` and `filter()`, generally
    handle almost everything we might want to throw at them. It’s difficult to optimize
    them in a general way to achieve higher performance. We’ll look at similar functions
    such as `imap()` in [Chapter 14](Chapter_14.xhtml#x1-28300014), [The Multiprocessing,
    Threading, and Concurrent.Futures Modules](Chapter_14.xhtml#x1-28300014).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Python的两个内置高阶函数`map()`和`filter()`通常可以处理我们可能想要投掷给它们的几乎所有内容。在一般情况下很难优化它们以实现更高的性能。我们将在[第14章](Chapter_14.xhtml#x1-28300014)，[多进程、多线程和concurrent.futures模块](Chapter_14.xhtml#x1-28300014)中查看类似函数，如`imap()`。
- en: 'We have three largely equivalent ways to express a mapping. Assume that we
    have some function, `f(x)`, and some collection of objects, `C`. The ways we can
    compute a mapping from the domain value in C to a range value are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种主要等效的方式来表达映射。假设我们有一个函数`f(x)`和一个对象集合`C`。我们可以计算从集合C中的域值到范围值的映射的方法如下：
- en: 'The `map()` function:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`函数：'
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A generator expression:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器表达式：
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A generator function with a `yield` statement:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`yield`语句的生成器函数：
- en: '[PRE36]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This `mymap()` function can be used as an expression with the function to apply
    and the iterable source of data:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`mymap()`函数可以用作一个表达式，其中包含要应用的功能和可迭代的数据源：
- en: '[PRE37]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Similarly, we have three ways to apply a filter function to a collection, all
    of which are equivalent:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们有三种方法可以将过滤器函数应用于集合，它们都是等效的：
- en: 'The `filter()` function:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`函数：'
- en: '[PRE38]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A generator expression:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器表达式：
- en: '[PRE39]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A generator function with a `yield` statement:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`yield`语句的生成器函数：
- en: '[PRE40]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This `myfilter()` function can be used as an expression with the function to
    apply and the iterable source of data:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`myfilter()`函数可以用作一个表达式，其中包含要应用的功能和可迭代的数据源：
- en: '[PRE41]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There are some minor performance differences; often the `map()` and `filter()`
    functions are fastest. More importantly, there are different kinds of extensions
    that fit these mapping and filtering designs, which are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些微小的性能差异；通常`map()`和`filter()`函数是最快的。更重要的是，有不同类型的扩展适合这些映射和过滤设计，如下所示：
- en: If we need to modify the processing, we can create a more sophisticated function,
    `g(x)`, that is applied to each element. This is the most general approach and
    applies to all three designs. This is where the bulk of our functional design
    energy is invested. We may define our new function around the existing `f(x)`,
    or we may find that we need to refactor the original function. In all cases, this
    design effort seems to yield the most benefits.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要修改处理过程，我们可以创建一个更复杂的函数`g(x)`，该函数应用于每个元素。这是最通用的方法，适用于所有三种设计。这是我们功能设计投入的大部分精力所在。我们可以在现有的`f(x)`周围定义我们的新函数，或者我们发现我们需要重构原始函数。在所有情况下，这种设计努力似乎能带来最大的好处。
- en: We can tweak the `for` loop inside the generator expression or generator function.
    One obvious tweak is to combine mapping and filtering into a single operation
    by extending the generator expression with an `if` clause. We can also merge the
    `mymap()` and `myfilter()` functions to combine mapping and filtering. This requires
    some care to be sure the resulting function is not a clutter of features.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以调整生成器表达式或生成器函数内部的`for`循环。一个明显的调整是将映射和过滤合并为一个操作，通过在生成器表达式中扩展一个`if`子句来实现。我们还可以合并`mymap()`和`myfilter()`函数以合并映射和过滤。这需要小心，以确保生成的函数不是功能杂糅。
- en: Profound changes that alter the structure of the data handled by the loop often
    happen as software evolves and matures. We have a number of design patterns, including
    wrapping, unwrapping (or extracting), flattening, and structuring. We’ve looked
    at a few of these techniques in previous chapters.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件的演变和成熟，经常发生改变处理循环中数据结构的深刻变化。我们有许多设计模式，包括包装、解包（或提取）、展平和结构化。我们在前面的章节中查看了一些这些技术。
- en: In the following sections, we’ll look at ways to design our own higher-order
    functions. We’ll start with unwrapping complex data while also applying a mapping
    function. For each example, it’s important to look at where the complexity arises,
    and decide if the resulting code really is succinct and expressive.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨设计我们自己的高阶函数的方法。我们将从在应用映射函数的同时解包复杂数据开始。对于每个示例，重要的是要看看复杂性从何而来，并决定生成的代码是否真的简洁且具有表现力。
- en: 5.7.1 Unwrapping data while mapping
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.1 在映射时解包数据
- en: When we use a construct such as `(f(x)`` for`` x,`` y`` in`` C)`, we use the
    multiple assignment feature of the `for` statement to unwrap a multi-valued tuple
    and then apply a function. The whole expression is a mapping. This is a common
    Python optimization to change the structure and apply a function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用像`(f(x) for x, y in C)`这样的结构时，我们使用`for`语句的多个赋值特性来解包一个多值元组，然后应用一个函数。整个表达式是一个映射。这是Python中常见的优化，用于改变结构并应用函数。
- en: 'We’ll use our trip data from [Chapter 4](Chapter_04.xhtml#x1-740004), [Working
    with Collections](Chapter_04.xhtml#x1-740004). The following is a concrete example
    of unwrapping while mapping:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自[第4章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)的行程数据。以下是一个在映射时解包的具体示例：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This higher-order function would be supported by conversion functions that
    we can apply to our raw data, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个高阶函数将由我们可以应用于原始数据的转换函数支持，如下所示：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These have been defined as lambdas and assigned to variables. Some static analysis
    tools will object to this because PEP-8 frowns on it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些已经被定义为lambda表达式并分配给变量。一些静态分析工具可能会对此提出异议，因为PEP-8不赞成这样做。
- en: 'The following shows how we can extract distance and apply a conversion function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了我们如何提取距离并应用一个转换函数：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As we’re unwrapping, the result will be a sequence of floating-point values.
    The results are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解包的过程中，结果将是一系列浮点值。结果如下：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This `convert()` function is highly specific to our start-end-distance trip
    data structure, as the `for` statement decomposes a specific three-tuple.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`convert()`函数非常特定于我们的起点-终点-距离行程数据结构，因为`for`语句分解了一个特定的三元组。
- en: 'We can build a more general solution for this kind of unwrapping-while-mapping
    design pattern. It suffers from being a bit more complex. First, we need general-purpose
    decomposition functions, as in the following code snippet:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为这种解包-映射设计模式构建一个更通用的解决方案。它稍微复杂一些。首先，我们需要通用分解函数，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We’d like to be able to express `f(sel2(s_e_d))`` for`` s_e_d`` in`` trip`.
    This involves functional composition; we’re combining a function, such as `to_miles()`,
    and a selector, such as `sel2()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够表达`f(sel2(s_e_d))`对于`s_e_d`在`trip`中的情况。这涉及到函数组合；我们正在组合一个函数，例如`to_miles()`，和一个选择器，例如`sel2()`。
- en: 'More descriptive names are often more useful than generic names. We’ll leave
    the renaming as an exercise for the reader. We can express functional composition
    in Python using yet another lambda, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 更具描述性的名称通常比通用名称更有用。我们将把重命名留给读者作为练习。我们可以使用另一个lambda在Python中表达函数组合，如下所示：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This gives us a longer but more specialized version of unwrapping and mapping,
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了一个更长但更专业的解包和映射版本，如下所示：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can compare the higher-order `convert()` function against this generator
    expression. Both apply a number of transformations. The `convert()` function ”conceals”
    a processing detail—the composition of a tuple as start, end, and distance—with
    a `for` statement that decomposes the tuple. This expression exposes this decomposition
    by including the `sel2()` function as part of the definition of a composite function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将高阶`convert()`函数与这个生成器表达式进行比较。两者都应用了一系列转换。`convert()`函数“隐藏”了一个处理细节——将元组作为起始点、结束点和距离的组合——通过一个分解元组的`for`语句。这个表达式通过将`sel2()`函数包含在复合函数定义中，暴露了这种分解。
- en: Neither is ”better” by any measure. They represent two approaches to exposing
    or concealing details. In a specific application development context, the exposure
    (or concealment) might be more desirable.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 两者在任何一个衡量标准上都不是“更好”。它们代表了两种展示或隐藏细节的方法。在特定的应用开发环境中，展示（或隐藏）可能更受欢迎。
- en: The same design principle works to create hybrid filters as well as mappings.
    We’d apply the filter in an `if` clause of the generator expression that was returned.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的设计原则也适用于创建混合过滤器以及映射。我们将在返回的生成器表达式的`if`子句中应用过滤器。
- en: We can combine mapping and filtering to create yet more complex functions. While
    it is appealing to create more complex functions, it isn’t always valuable. A
    complex function might not beat the performance of a nested use of the `map()`
    and `filter()` functions. Generally, we only want to create a more complex function
    if it encapsulates a concept and makes the software easier to understand.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将映射和过滤结合起来创建更复杂的函数。虽然创建更复杂的函数很有吸引力，但并不总是有价值的。一个复杂的函数可能无法超越嵌套使用`map()`和`filter()`函数的性能。通常，我们只想创建更复杂的函数，如果它能封装一个概念并使软件更容易理解。
- en: 5.7.2 Wrapping additional data while mapping
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.2 在映射时包装额外数据
- en: When we use a construct such as `((f(x),`` x)`` for`` x`` in`` C)`, we’ve used
    wrapping to create a multi-valued tuple while also applying a transformational
    mapping. This is a common technique to save derived results by creating larger
    constructs. This has the benefit of avoiding recalculation without the liability
    of complex objects with an internal state change. In this case, the state change
    is structural and very visible.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`((f(x), x) for x in C)`这样的结构时，我们已经使用了包装来创建一个多值元组，同时应用了转换映射。这是一种常见的技巧，通过创建更大的结构来保存派生结果。这有避免重新计算的好处，同时避免了具有内部状态变化的复杂对象的责任。在这种情况下，状态变化是结构性的，并且非常明显。
- en: 'This is part of the example shown in [Chapter 4](Chapter_04.xhtml#x1-740004),
    [Working with Collections](Chapter_04.xhtml#x1-740004), to create the trip data
    from the path of points. The code looks like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容是[第4章](Chapter_04.xhtml#x1-740004)，[使用集合](Chapter_04.xhtml#x1-740004)中展示的示例的一部分，用于从点的路径创建行程数据。代码看起来是这样的：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can revise this slightly to create a higher-order function that separates
    the wrapping from the other functions. We can refactor this design to create a
    function that constructs a new tuple including the original tuple and the distance.
    This function can be defined as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍作修改，创建一个将包装与其他函数分离的高阶函数。我们可以重构这个设计，创建一个构造包含原始元组和距离的新元组的函数。这个函数可以定义如下：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This function will decompose each leg into two variables, `start` and `end`.
    These variables will be `Point` instances, defined as tuples of two float values.
    These will be used with the given `distance()` function to compute the distance
    between the points. The function is a callable that accepts two `Point` objects
    and returns a float result. The result will build a three-tuple that includes
    the original two `Point` objects and also the calculated float result.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将每条腿分解成两个变量，`start` 和 `end`。这些变量将是 `Point` 实例，定义为两个浮点值的元组。这些将用于给定的 `distance()`
    函数来计算两点之间的距离。该函数是一个可调用的对象，接受两个 `Point` 对象并返回一个浮点结果。结果将构建一个包含原始两个 `Point` 对象以及计算出的浮点结果的三个元组。
- en: 'We can then rewrite our trip assignment to apply the `haversine()` function
    to compute distances, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以重新编写我们的行程分配，应用 `haversine()` 函数来计算距离，如下所示：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We’ve replaced a generator expression with a higher-order function, `cons_distance()`.
    The function not only accepts a function as an argument, but it also returns a
    generator expression. In some applications, this larger and more complex processing
    step is a helpful way to elide unecessary details.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一个高阶函数 `cons_distance()` 替换了生成器表达式。该函数不仅接受一个函数作为参数，还返回一个生成器表达式。在某些应用中，这个更大、更复杂的处理步骤是一种省略不必要细节的有帮助的方法。
- en: In [Chapter 10](Chapter_10.xhtml#x1-21700010), [The Functools Module](Chapter_10.xhtml#x1-21700010),
    we’ll show how to use the `partial()` function to set a value for the `R` parameter
    of the `haversine()` function, which changes the units in which the distance is
    calculated.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 10 章](Chapter_10.xhtml#x1-21700010)，[Functools 模块](Chapter_10.xhtml#x1-21700010)
    中，我们将展示如何使用 `partial()` 函数为 `haversine()` 函数的 `R` 参数设置一个值，这改变了距离计算的计量单位。
- en: 5.7.3 Flattening data while mapping
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.3 在映射时扁平化数据
- en: In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we looked at algorithms that flattened a nested tuple-of-tuples structure into
    a single iterable. Our goal at the time was simply to restructure some data without
    doing any real processing. We can create hybrid solutions that combine a function
    with a flattening operation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004) 中，我们研究了将嵌套元组结构扁平化为单个可迭代对象的算法。当时我们的目标仅仅是重新结构化一些数据而不进行任何实际的处理。我们可以创建混合解决方案，将函数与扁平化操作相结合。
- en: 'Let’s assume that we have a block of text that we want to convert to a flat
    sequence of numbers. The text looks as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一段文本，我们想将其转换为扁平的数字序列。文本如下所示：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each line is a block of 10 numbers. We need to unblock the rows to create a
    flat sequence of numbers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行是 10 个数字的一块。我们需要解开行，以创建一个扁平的数字序列。
- en: 'This is done with a two-part generator function, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过一个两部分的生成器函数完成的，如下所示：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will split the text into lines and iterate through each line. It will
    split each line into words and iterate through each word. The output from this
    is a list of strings, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把文本分割成行，并遍历每一行。它将每一行分割成单词，并遍历每个单词。这个输出的结果是字符串列表，如下所示：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There’s an optimization to this, which applies to this specific text. We’ll
    leave that as an exercise for the reader.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的文本，有一个优化，我们将把它留给读者作为练习。
- en: 'To convert the strings to numbers, we must apply a conversion function as well
    as unwind the blocked structure from its original format, using the following
    code snippet:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将字符串转换为数字，我们必须应用一个转换函数，并使用以下代码片段解开从原始格式中阻塞的结构：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This function has a `conversion` argument, which is a function that is applied
    to each value that will be emitted. The values are created by flattening using
    the algorithm shown previously.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个 `conversion` 参数，它是一个应用于将要发出的每个值的函数。这些值是通过使用之前显示的算法进行扁平化创建的。
- en: 'We can use this `numbers_from_rows()` function in the following kind of expression:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下类型的表达式中使用这个 `numbers_from_rows()` 函数：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here we’ve used the built-in `float()` to create a list of floating-point values
    from the block of text.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了内置的 `float()` 函数从文本块中创建一个浮点数值列表。
- en: 'We have many alternatives using mixtures of higher-order functions and generator
    expressions. For example, we might express this as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有许多使用高阶函数和生成器表达式的混合替代方案。例如，我们可能这样表达：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This might help us understand the overall structure of the algorithm. The principle
    is called chunking: we summarize the details of a function with a meaningful name.
    With this summary, the details are abstracted and we can work with the function
    as a small concept in a larger context. While we often use higher-order functions,
    there are times when a generator expression can be clearer.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有助于我们理解算法的整体结构。这个原则被称为分块：我们用一个有意义的名字总结函数的细节。有了这个总结，细节被抽象化，我们可以在更大的上下文中将函数作为一个小的概念来工作。虽然我们经常使用高阶函数，但有时生成器表达式可能更清晰。
- en: 5.7.4 Structuring data while filtering
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.4 在过滤时结构化数据
- en: The previous three examples combined additional processing with mapping. Combining
    processing with filtering doesn’t seem to be quite as expressive as combining
    it with mapping. We’ll look at an example in detail to show that, although it
    is useful, it doesn’t seem to have as compelling a use case as combining mapping
    and processing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个示例将额外的处理与映射相结合。将处理与过滤相结合似乎不如与映射相结合那样具有表现力。我们将详细查看一个示例以表明，尽管它很有用，但它似乎没有与映射和处理相结合那样有说服力的用例。
- en: 'In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we looked at structuring algorithms. We can easily combine a filter with the structuring
    algorithm into a single, complex function. The following is a version of our preferred
    function to group the output from an iterable:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004) 中，我们探讨了结构化算法。我们可以轻松地将过滤与结构化算法组合成一个单一、复杂的函数。以下是我们首选的将可迭代对象的输出分组的功能版本：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will try to assemble a tuple of `n` items taken from an iterable object.
    If there are any items in the tuple, they are yielded as part of the resulting
    iterable. In principle, the function then operates recursively on the remaining
    items from the original iterable. As the recursion has limitations in Python,
    we’ve optimized the tail call structure into an explicit `while` statement.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这将尝试从可迭代对象中组装一个包含 `n` 个项目的元组。如果元组中有任何项目，它们将作为结果可迭代对象的一部分产生。原则上，函数随后递归地对原始可迭代对象中的剩余项目进行操作。由于
    Python 中的递归有限制，我们将尾调用结构优化为显式的 `while` 语句。
- en: 'The results of the `group_by_iter()` function is a sequence of n-tuples. In
    the following example, we’ll create a sequence of numbers using a filter function,
    and then group them into 7-tuples:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_by_iter()` 函数的结果是一个 n-元组的序列。在以下示例中，我们将使用过滤函数创建一个数字序列，然后将它们分组为 7-元组：'
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can merge grouping and filtering into a single function that does both operations
    in a single function body. The modification to `group_by_iter()` looks as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将分组和过滤合并成一个函数，该函数在单个函数体中执行这两个操作。`group_by_iter()` 的修改如下：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We’ve added a single line to the `group_by_iter()` function. This application
    of `filter()` creates a subset. We’ve changed the `while`` row`` :=`` tuple(group(n,`` subset)):`
    line to use the subset instead of the original collection of items.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `group_by_iter()` 函数中添加了一行。这个 `filter()` 函数的应用创建了一个子集。我们将 `while row :=
    tuple(group(n, subset)):` 行改为使用子集而不是原始的项目集合。
- en: This `group_filter_iter()` function applies the filter predicate function to
    the source iterable provided as the `items` parameter. As the filter output is
    itself a non-strict iterable, the subset value isn’t computed in advance; the
    values are created as needed. The bulk of this function is identical to the version
    shown previously.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `group_filter_iter()` 函数将过滤谓词函数应用于作为 `items` 参数提供的源可迭代对象。由于过滤输出本身也是一个非严格可迭代对象，子集值不是预先计算的；值是在需要时创建的。这个函数的大部分内容与之前展示的版本相同。
- en: 'We can slightly simplify the context in which we use this function. We can
    compare the explicit use of `filter()` and this combined function where the `filter()`
    is implicit. The comparison is in the following example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微简化我们使用此函数的上下文。我们可以比较显式使用 `filter()` 和隐式 `filter()` 的组合函数。比较如下示例：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we’ve applied the filter predicate and grouped the results in a single
    function invocation. In the case of the `filter()` function, it’s rarely a clear
    advantage to apply the filter in conjunction with other processing. It seems as
    if a separate, visible `filter()` function is more helpful than a combined function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应用了过滤谓词并在单个函数调用中将结果分组。对于 `filter()` 函数来说，与其他处理相结合应用过滤通常没有明显的优势。似乎一个单独的、可见的
    `filter()` 函数比一个组合函数更有帮助。
- en: 5.8 Building higher-order functions with callables
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8 使用可调用对象构建高阶函数
- en: We can define higher-order functions as callable classes. This builds on the
    idea of writing generator functions; we’ll write callables because we need stateful
    features of Python, like instance variables. In addition to using statements,
    we can also apply a static configuration when creating the higher-order functions.
    The Strategy design pattern, in particular, works very nicely to alter the features
    of callable objects.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将高阶函数定义为可调用类。这建立在编写生成器函数的想法之上；我们将编写可调用对象，因为我们需要 Python 的状态特性，如实例变量。除了使用语句外，我们还可以在创建高阶函数时应用静态配置。特别是策略设计模式非常适合改变可调用对象的功能。
- en: What’s important about a callable class definition is that the class object,
    created by the `class` statement, defines a function that emits a function. Commonly,
    we’ll use a callable object to create a composite function that combines functions
    into something relatively complex.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用类定义的重要之处在于，由 `class` 语句创建的类对象定义了一个发出函数的函数。通常，我们会使用可调用对象来创建一个复合函数，将函数组合成相对复杂的东西。
- en: 'To emphasize this, consider the following class:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调这一点，考虑以下类：
- en: '[PRE62]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This class is used to create a new function that is null aware. When an instance
    of this class is created, a function, `some_func`, is provided. The only restriction
    stated is that `some_func` be `Callable[[Any],`` Any]`. This means the argument
    takes a single argument and results in a single result. The resulting object is
    callable. A single, optional argument is expected. The implementation of the `__call__()`
    method handles the use of `None` objects as an argument. This method has the effect
    of making the resulting object `Callable[[Optional[Any]],`` Optional[Any]]`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类用于创建一个能够处理空值的新的函数。当创建这个类的实例时，提供了一个函数 `some_func`。唯一指定的限制是 `some_func` 必须是
    `Callable[[Any], Any]`。这意味着参数接受一个参数并产生一个结果。结果对象是可调用的。期望一个单一的、可选的参数。`__call__()`
    方法的实现处理了将 `None` 对象作为参数的使用。这个方法的效果是使结果对象成为 `Callable[[Optional[Any]], Any]]`。
- en: For example, evaluating the `NullAware(math.log)` expression will create a new
    function that can be applied to argument values. The `__init__()` method will
    save the given function in the resulting object. This object is a function that
    can then be used to process data.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，评估 `NullAware(math.log)` 表达式将创建一个新的函数，该函数可以应用于参数值。`__init__()` 方法将保存给定的函数到结果对象中。这个对象是一个可以用来处理数据的函数。
- en: 'The common approach is to create the new function and save it for future use
    by assigning it a name, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的做法是创建一个新的函数，并通过给它命名来保存它以供将来使用，如下所示：
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first example creates a new function, and assigns the name `null_log_scale()`.
    The second example creates a null-aware function, `null_round_4`, that uses a
    lambda object as the internal value of the function to apply if the parameter
    is not `None`. We can then use the function in another context. Take a look at
    the following example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例创建了一个新的函数，并将其命名为 `null_log_scale()`。第二个示例创建了一个空值感知函数 `null_round_4`，该函数使用
    lambda 对象作为函数的内部值，如果参数不是 `None`，则应用该函数。然后我们可以在另一个上下文中使用这个函数。请看以下示例：
- en: '[PRE64]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This example’s `__call__()` method relies entirely on expression evaluation.
    It’s an elegant and tidy way to define composite functions built up from lower-level
    component functions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的 `__call__()` 方法完全依赖于表达式评估。这是一种优雅且整洁的方式来定义由底层组件函数构建的复合函数。
- en: 5.8.1 Assuring good functional design
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.1 确保良好的函数式设计
- en: The idea of stateless functional programming requires some care when using Python
    objects. Objects are typically stateful. Indeed, one can argue that the entire
    purpose of object-oriented programming is to encapsulate state change into class
    definitions. Because of this, we find ourselves pulled in opposing directions
    between functional programming and imperative programming when using Python class
    definitions to process collections.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态函数式编程的想法在使用 Python 对象时需要小心。对象通常是具有状态的。确实，有人可以争论，面向对象编程的整个目的就是将状态变化封装到类定义中。正因为如此，当我们使用
    Python 类定义来处理集合时，我们发现自己处于函数式编程和命令式编程之间的对立方向。
- en: The benefit of using a callable object to create a composite function gives
    us slightly simpler syntax when the resulting composite function is used. When
    we start working with iterable mappings or reductions, we have to be aware of
    how and why we introduce stateful objects.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可调用对象创建组合函数的好处是，当使用结果组合函数时，我们可以获得稍微简单的语法。当我们开始处理可迭代映射或归约时，我们必须意识到我们如何以及为什么引入有状态的对象。
- en: 'We’ll turn to a fairly complex function that contains the following features:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将转向一个相当复杂的函数，它具有以下特性：
- en: It applies a filter to a source of items.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对一个项目源应用过滤器。
- en: It applies a mapping to the items which pass the filter.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将对通过过滤器的项目应用映射。
- en: It computes a sum of the mapped values.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它计算映射值的总和。
- en: We can try to define it as a simple higher-order function, but with three separate
    parameter values, it would be cumbersome to use. Instead, we’ll create a callable
    object that is configured by the filter and mapping functions.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试将其定义为一个简单的更高阶函数，但如果有三个独立的参数值，使用起来会显得繁琐。相反，我们将创建一个可调用的对象，该对象由过滤器和映射函数配置。
- en: 'Using objects to configure an object is the Strategy design pattern, used in
    object-oriented programming. Here’s a class definition that requires the filter
    and mapping function in order to create a callable:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象来配置对象是面向对象编程中使用的策略设计模式。以下是一个需要过滤器和映射函数才能创建可调用对象的类定义：
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This class has two slots in each object; this puts a few constraints on our
    ability to use the function as a stateful object. It doesn’t prevent all modifications
    to the resulting object, but it limits us to just two attributes. Attempting to
    add an attribute will result in an exception.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在每个对象中有两个槽位；这在我们将函数用作有状态对象的能力上施加了一些限制。它不会阻止对结果对象的全部修改，但它限制我们只能有两个属性。尝试添加属性将导致异常。
- en: The initialization method, `__init__()`, stows the two function objects, `filter`
    and `func`, in the object’s instance variables. The `__call__()` method returns
    a value based on a generator expression that uses the two internal function definitions.
    The `self.filter()` function is used to pass or reject items. The `self.function()`
    function is used to transform objects that are passed by the `filter()` function.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化方法 `__init__()` 将两个函数对象 `filter` 和 `func` 存储在对象的实例变量中。`__call__()` 方法返回一个基于生成器表达式的值，该表达式使用两个内部函数定义。`self.filter()`
    函数用于通过或拒绝项目。`self.function()` 函数用于转换通过 `filter()` 函数传递的对象。
- en: 'An instance of this class is a function that has two Strategy functions built
    into it. We create an instance as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的实例是一个包含两个策略函数的函数。我们创建实例的方式如下：
- en: '[PRE66]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We’ve built a function named `count_not_none()` that counts the non-`None` values
    in a sequence. It does this by using a lambda to pass non-`None` values and a
    function that uses a constant, 1, instead of the actual values present.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个名为 `count_not_none()` 的函数，该函数计算序列中的非 `None` 值。它是通过使用lambda传递非 `None`
    值和一个使用常数1而不是实际值的函数来完成的。
- en: 'Generally, this `count_not_none()` object will behave like any other Python
    function. We can use the `count_not_None()` function as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个 `count_not_none()` 对象将表现得像任何其他Python函数一样。我们可以如下使用 `count_not_None()` 函数：
- en: '[PRE67]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This shows a technique for using some of Python’s object-oriented programming
    features to create callable objects that are used in a functional approach to
    designing and building software. We can delegate some complexity to creating a
    sophisticated function. Having a single function with multiple features can simplify
    understanding of the context in which the function is used.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了使用Python的一些面向对象编程特性来创建可调用对象的技术，这些对象用于以函数式方法设计和构建软件。我们可以将一些复杂性委托给创建复杂函数。拥有一个具有多个功能的单一函数可以简化对函数使用上下文的理解。
- en: 5.9 Review of some design patterns
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.9 一些设计模式的回顾
- en: The `max()`, `min()`, and `sorted()` functions have a default behavior without
    a `key=` function. They can be customized by providing a function that defines
    how to compute a key from the available data. For many of our examples, the `key=`
    function has been a simple extraction of available data. This isn’t a requirement;
    the `key=` function can do anything.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`、`min()` 和 `sorted()` 函数在没有 `key=` 函数的情况下具有默认行为。可以通过提供一个定义如何从可用数据计算键的函数来自定义它们。在我们的许多示例中，`key=`
    函数已经是一个简单的可用数据的提取。这不是必需的；`key=` 函数可以执行任何操作。'
- en: 'Imagine the following method: `max(trip,`` key=random.randint())`. Generally,
    we try not to have `key=` functions that do something obscure like this.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 想象以下方法：`max(trip, key=random.randint())`。通常，我们尽量避免有像这样做一些神秘操作的`key=`函数。
- en: The use of a `key=` function is a common design pattern. Functions we design
    can easily follow this pattern.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`key=`函数是一种常见的模式。我们设计的函数可以轻松遵循这个模式。
- en: We’ve also looked at the way lambda forms can simplify the application of higher-order
    functions. One significant advantage of using lambda forms is that it follows
    the functional paradigm very closely. When writing more conventional functions,
    we can create imperative programs that might clutter an otherwise succinct and
    expressive functional design.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了lambda形式如何简化更高阶函数的应用。使用lambda形式的一个显著优势是它非常接近函数式范式。当我们编写更传统的函数时，我们可以创建可能会使简洁且富有表现力的函数式设计变得杂乱的命令式程序。
- en: 'We’ve looked at several kinds of higher-order functions that work with a collection
    of values. Throughout the previous chapters, we’ve hinted at several different
    design patterns for higher-order functions that apply to collection objects and
    scalar objects. The following is a broad classification:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了几种与值集合一起工作的更高阶函数。在之前的章节中，我们提到了几种适用于集合对象和标量对象的更高阶函数的设计模式。以下是一种广泛的分类：
- en: 'Return a generator: A higher-order function can return a generator expression.
    We consider the function higher-order because it didn’t return scalar values or
    collections of values. Some of these higher-order functions also accept functions
    as arguments.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回生成器：一个更高阶函数可以返回一个生成器表达式。我们认为这个函数是更高阶的，因为它没有返回标量值或值的集合。其中一些更高阶函数也接受函数作为参数。
- en: 'Act as a generator: Some function examples use the `yield` statement to make
    them first-class generator functions. The value of a generator function is an
    iterable collection of values that are evaluated lazily. We suggest that a generator
    function is essentially indistinguishable from a function that returns a generator
    expression. Both are non-strict. Both can yield a sequence of values. For this
    reason, we’ll also consider generator functions as higher order. Built-in functions,
    such as `map()` and `filter()`, fall into this category.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为生成器：一些函数示例使用`yield`语句使它们成为一等生成器函数。生成器函数的值是一个可迭代的值集合，这些值是按需评估的。我们建议生成器函数本质上与返回生成器表达式的函数不可区分。两者都是非严格的。两者都可以产生一系列值。因此，我们将生成器函数也视为更高阶。内置函数，如`map()`和`filter()`，属于这一类别。
- en: 'Materialize a collection: Some functions must return a materialized collection
    object: list, tuple, set, or mapping. These kinds of functions can be of a higher
    order if they have a function as part of the arguments. Otherwise, they’re ordinary
    functions that happen to work with collections.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现集合：一些函数必须返回一个具体化的集合对象：列表、元组、集合或映射。如果这些函数的参数中包含一个函数，它们可以成为更高阶的函数。否则，它们是普通的函数，碰巧与集合一起工作。
- en: 'Reduce a collection: Some functions work with an iterable to create a scalar
    result. The `len()` and `sum()` functions are examples of this. We can create
    higher-order reductions when we accept a function as an argument. We’ll return
    to this in the next chapter.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少集合：一些函数与可迭代对象一起工作以创建标量结果。`len()`和`sum()`函数就是这样的例子。当我们接受一个函数作为参数时，我们可以创建更高阶的减少。我们将在下一章回到这个问题。
- en: 'Scalar: Some functions act on individual data items. These can be higher-order
    functions if they accept another function as an argument.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量：一些函数作用于单个数据项。如果它们接受另一个函数作为参数，它们可以是更高阶函数。
- en: As we design our own software, we can pick and choose among these established
    design patterns.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设计自己的软件时，我们可以从这些既定的设计模式中选择和挑选。
- en: 5.10 Summary
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.10 概述
- en: 'In this chapter, we have seen two reductions that are higher-order functions:
    `max()` and `min()`. We looked at the two central higher-order functions, `map()`
    and `filter()`. We also looked at `sorted()`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了两个更高阶函数的减少：`max()`和`min()`。我们研究了两个核心更高阶函数`map()`和`filter()`。我们还研究了`sorted()`。
- en: In addition, we looked at how to use a higher-order function to transform the
    structure of data. We can perform several common transformations, including wrapping,
    unwrapping, flattening, and structuring sequences of different kinds.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还研究了如何使用更高阶函数来转换数据结构。我们可以执行几种常见的转换，包括包装、解包、展平和结构化不同类型的序列。
- en: 'We looked at two ways to define our own higher-order functions, which are as
    follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了两种定义我们自己的高阶函数的方法，具体如下：
- en: The `def` statement. Similar to a lambda form that we assign to a variable.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def` 语句。类似于我们分配给变量的lambda形式。'
- en: Defining a callable class as a kind of function that emits composite functions.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可调用的类定义为一种发出复合函数的函数类型。
- en: We can also use decorators to emit composite functions. We’ll return to this
    in [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator Design Techniques](Chapter_12.xhtml#x1-25000012).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用装饰器来发出复合函数。我们将在第12章[装饰器设计技术](Chapter_12.xhtml#x1-25000012)中回到这一点。
- en: In the next chapter, we’ll look at the idea of purely functional iteration via
    recursion. We’ll use Pythonic structures to make several common improvements over
    purely functional techniques. We’ll also look at the associated problem of performing
    reductions from collections to individual values.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨通过递归实现纯函数迭代的概念。我们将使用Pythonic结构在纯函数技术上进行一些常见的改进。我们还将探讨从集合到单个值执行归约的相关问题。
- en: 5.11 Exercises
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.11 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于Packt Publishing在GitHub上提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者可能会注意到GitHub上提供的代码包含了一些练习的部分解决方案。这些作为提示，允许读者探索替代解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases provided in
    the GitHub repository. The reader should replace the book’s example function name
    with their own solution to confirm that it works.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习将需要单元测试用例来确认它们确实解决了问题。这些通常与GitHub仓库中提供的单元测试用例相同。读者应将书籍中的示例函数名称替换为自己的解决方案以确认其工作。
- en: 5.11.1 Classification of state
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.11.1 状态分类
- en: A web application might have a number of servers of various kinds, a database,
    and installed software components. Someone responsible for website reliability
    will want to know when things are running reasonably well. When things are broken,
    they’ll want details.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Web应用可能拥有多种类型的多个服务器、数据库和已安装的软件组件。负责网站可靠性的某人将想知道事情是否运行得相当顺利。当事情出错时，他们需要详细信息。
- en: As part of monitoring, a health application can gather status from the various
    components and summarize the status into an overall ”health” value. The idea is
    to perform a kind of ”reduce” on the status information.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 作为监控的一部分，健康应用程序可以从各种组件收集状态，并将状态汇总为整体的“健康”值。这个想法是对状态信息执行一种“reduce”操作。
- en: 'Each individual service has a status URL that can be pinged for status information.
    The results can take one of these four values:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的服务都有一个可以用于获取状态信息的状态URL。结果可以是以下四种值之一：
- en: No response at all. The service is not working. This is bad.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全没有响应。服务未工作。这是不好的。
- en: A response that is outside a healthy time window. Even if the response is `"working"`,
    the service is degraded.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出健康时间窗口的响应。即使响应是 `"working"`，服务也会降级。
- en: A response of `"not`` working"`. A response of ”not working” is almost as bad
    as no response at all. It indicates a severe problem, but it also means monitoring
    software is working.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"not working"` 的响应。 `"not working"` 的响应几乎与没有响应一样糟糕。它表明存在严重问题，但也意味着监控软件正在工作。'
- en: A response of `"working"`. This is the ideal response.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"working"` 的响应。这是理想的响应。'
- en: 'The status forms a collection of 3-tuples: `("service",`` "status",`` response`` time)`.
    The service is a name, like `"primary`` database"` or `"router"` or any of numerous
    other services that can be part of a distributed web application. The status value
    is a string value of either `"working"` or `"not`` working"`. The response time
    is the number of milliseconds it took to respond. Typical numbers are 10-50.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 状态形式为包含3个元组的集合：`("服务", "状态", "响应时间)`。服务是一个名称，例如 `"primary database"` 或 `"router"`
    或任何可以作为分布式Web应用一部分的众多其他服务。状态值是一个字符串值，可以是 `"working"` 或 `"not working"`。响应时间是响应所需的时间（以毫秒计）。典型数字为10-50。
- en: 'The summary is one of the following values:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要可以是以下值之一：
- en: '`Stopped`: There is one service that is not responding.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stopped`：有一个服务没有响应。'
- en: '`Degraded`: There is one service that has responded with a time that is out
    of the healthy time window of 50 milliseconds or less. Or, there is one service
    that has responded with `"not`` working"`.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Degraded`：有一个服务响应时间超出了50毫秒或更少的健康时间窗口。或者，有一个服务响应了`"not working"`。'
- en: '`Running`: All services are working and responding within the 50 millisecond
    window.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Running`：所有服务都在50毫秒窗口内正常工作并响应。'
- en: 'Two of the possible implementations are as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有两种可能的实现：
- en: Write four filter functions. Apply the filters to the sequence of status values
    and count how many match each filter. Based on the number of matches, decide which
    of the three responses to provide for the overall health of the system.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写四个过滤器函数。将过滤器应用于状态值序列，并计算每个过滤器匹配的数量。根据匹配的数量，决定为系统的整体健康提供哪三个响应。
- en: 'Write a mapping to apply a severity number: 2 for an indication of `Stopped`,
    1 for either of the indications of `Degraded`, or 0 for all other service status
    messages. The maximum value of this vector is the overall health of the system.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个映射来应用严重性数字：2表示`Stopped`的指示，1表示`Degraded`的任一指示，或0表示所有其他服务状态消息。这个向量的最大值是系统的整体健康。
- en: Implement all variations. Compare the resulting code for clarity and expressiveness.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所有变体。比较生成的代码的清晰度和表达性。
- en: 5.11.2 Classification of state, Part II
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.11.2 状态分类，第二部分
- en: In the previous exercise, services were described as reporting a status value
    as a string value of either `"working"` or `"not`` working"`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，服务被描述为报告一个状态值，该值是字符串值`"working"`或`"not working"`。
- en: Before proceeding, either complete the previous exercise, or develop a workable
    design to solve the previous exercise.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，要么完成上一个练习，要么开发一个可行的设计方案来解决上一个练习。
- en: 'Due to technology upgrades, the status values for some services include a third
    value: `"degraded"`. This has the same implication as a slow response from a service.
    This may change the design. It will certainly change the implementation.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于技术升级，某些服务的状态值包括第三个值：`"degraded"`。这具有与服务缓慢响应相同的含义。这可能会改变设计。它肯定会改变实现。
- en: 'Provide an implementation that gracefully handles the idea of additional or
    distinct status messages. The idea is to isolate the status-message checking to
    a function that can be replaced easily. For example, we might start with three
    functions to evaluate status values: `is_stopped()`, `is_degraded()`, and `is_working()`.
    When a change is required, we can write a new version, `is_degraded_2()`, that
    can be used in place of the old `is_degraded()` function.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个实现，优雅地处理额外的或不同的状态消息的概念。想法是将状态消息检查隔离到一个可以轻松替换的函数中。例如，我们可能从三个评估状态值的函数开始：`is_stopped()`、`is_degraded()`和`is_working()`。当需要更改时，我们可以编写一个新的版本，`is_degraded_2()`，它可以替代旧的`is_degraded()`函数。
- en: The objective is to create an application that does not require a change to
    the implementation of any particular function. Instead, new functions are added;
    these new functions will reuse existing functions plus new functions to complete
    the expanded objectives.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是创建一个不需要更改任何特定函数实现的程序。相反，添加新函数；这些新函数将重用现有函数以及新函数来完成扩展的目标。
- en: 5.11.3 Optimizing a file parser
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.11.3 优化文件解析器
- en: 'In [Flattening data while mapping](#x1-1150003), we used the following expression
    to extract a sequence of numbers from text with space separators:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在[映射时展平数据](#x1-1150003)中，我们使用了以下表达式从带有空格分隔符的文本中提取一个数字序列：
- en: '[PRE68]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The definition of the `split()` method includes the `\n` character, which is
    also used by the `splitlines()` method. It seems like this can be optimized to
    use only the `split()` method.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()`方法的定义包括`\n`字符，这个字符也被`splitlines()`方法使用。看起来这可以通过仅使用`split()`方法来优化。'
- en: 'After getting this to work, change the source text in the example to:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在使这个工作后，将示例中的源文本更改为：
- en: '[PRE69]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We can parse this with a single use of the `split()` method. This requires restructuring
    a single, long sequence of values into various rows and columns.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一次`split()`方法来解析这个。这需要将一个单一的长序列值重新组织成多行和多列。
- en: Is this faster than the use of the `splitlines()` and `split()` methods?
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否比使用`splitlines()`和`split()`方法更快？
- en: Join our community Discord space
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
