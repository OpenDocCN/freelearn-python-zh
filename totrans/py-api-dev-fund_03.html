<html><head></head><body>
		<div>
			<div id="_idContainer042" class="Content">
			</div>
		</div>
		<div id="_idContainer043" class="Content">
			<h1 id="_idParaDest-64"><a id="_idTextAnchor086"/>3. Manipulating a Database with SQLAlchemy</h1>
		</div>
		<div id="_idContainer044" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Use the pgAdmin tool to manage a database</li>
				<li class="bullets">Manipulate a database using SQLAlchemy</li>
				<li class="bullets">Create database tables using Flask-Migrate</li>
				<li class="bullets">Persist data into a database</li>
				<li class="bullets">Hash confidential password data</li>
			</ul>
			<p>This chapter covers using SQLAlchemy to access a database, including building a model, encrypting the password, ensuring each email is unique, and then saving the recipe data in the database.</p>
		</div>
		<div id="_idContainer062" class="Content">
			<h2 id="_idParaDest-65"><a id="_idTextAnchor087"/>Introduction</h2>
			<p>In the previous chapter, we were only storing our data in application memory. While it is easy to code that way, the data will be gone once the server restarts. That is obviously not ideal because we would expect the data to be persisted even after a server restart or application migration and suchlike. Therefore, in this chapter, we will talk about persisting data in a database. We will begin by installing the Postgres database on our local machine. Then, we will create a database using pgAdmin and interact with it using the <strong class="keyword">ORM</strong> (<strong class="keyword">Object Relational Mapping</strong>) package, SQLAlchemy. ORM allows us to interact with a database by means of an object instead of an SQL query. After that, we will define the user and recipe models, link them up, and use Flask-Migrate to create the corresponding tables in the database. Once that part is complete, we will go through exercises to understand the utilization of SQLAlchemy in the Python console. Lastly, we will add the resource for users so that new users can be created through an API.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor088"/>Databases</h2>
			<p>You have probably heard of the term database before. It is basically a data storage system. But why do we need a system to store data? Why can't we just store everything in a text file and save that in the folder system? Apparently, a database does more than just storing data. It classifies and organizes data and helps to store it with less redundancy. It also makes data easier to maintain, making it more it secure and consistent. A database is usually managed by a <strong class="keyword">database management system</strong> (<strong class="keyword">DBMS</strong>)</p>
			<h3 id="_idParaDest-67"><a id="_idTextAnchor089"/>Database Management System</h3>
			<p>A DBMS is an application that maneuvers and manages a database. It facilitates communication between the users and the database. Users can create, use, and maintain the database using this application.</p>
			<p>A DBMS is crucial for data security and integrity. Popular database software and DBMSs include PostgreSQL, MySQL, Microsoft SQL Server, MariaDB, and Oracle Database. Most DBMSs use <strong class="keyword">structured query language</strong> (<strong class="keyword">SQL</strong>) to insert and extract data. </p>
			<p>In this book, we will be using PostgreSQL as our backend database system. And we will also use pgAdmin, which is a tool for managing PostgreSQL. PostgreSQL is a powerful, open-source object-relational database management system with a 15-year history. It is well recognized as a result of its stability and data integrity. </p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor090"/>SQL</h2>
			<p><strong class="keyword">SQL</strong> is a language that was specifically invented to manage and maneuver data. It can be classified further into the following types:</p>
			<ul>
				<li><strong class="keyword">Data Query Language</strong> (<strong class="keyword">DQL</strong>) for extracting data. With the syntax like <strong class="inline">SELECT column1, column2 FROM table WHERE conditions</strong>, it can query against the table and extracts data (<strong class="inline">column1, column2</strong>) that satisfies a certain condition.</li>
				<li><strong class="keyword">Data Manipulation Language</strong> (<strong class="keyword">DML</strong>) for manipulating data. It includes statements such as <strong class="inline">INSERT</strong>, <strong class="inline">UPDATE</strong>, and <strong class="inline">DELETE</strong>.</li>
				<li><strong class="keyword">Data Control Language</strong> (<strong class="keyword">DCL</strong>) for controlling data access.</li>
			</ul>
			<p>Although we have introduced a number of different languages here, the good thing is that we don't need to learn all of them. In fact, we are not going to query our database using SQL. We will just need to code in Python, and the ORM package will convert our Python code to SQL behind the scenes. It's a whole lot easier to work with databases nowadays.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor091"/>ORM</h2>
			<p><strong class="keyword">Object Relational Mapping</strong> (<strong class="keyword">ORM</strong>) is a programming technique that allows the developer to map objects in the programming language to the data model in a database. There is no longer any need to use SQL to interact with a database. The benefit of this is that developers can code in their own programming language and it will work on different types of databases.</p>
			<p>The mapping works along the following lines:</p>
			<ul>
				<li>Class in Python = the table schema in the database</li>
				<li>Attributes in a class = fields in the table schema</li>
				<li>Objects = rows of data in the table</li>
			</ul>
			<p>SQLAlchemy is the most popular ORM in the Python community. <a id="_idTextAnchor092"/>Next, let's delves further by attempting to create a database.</p>
			<h3 id="_idParaDest-70">Exercise 18: Setting Up a Smilecook Database<a id="_idTextAnchor093"/></h3>
			<p>Most applications nowadays require a database to store and manage data. Our application, Smilecook, is no exception. It is a recipe-sharing platform and is open to the public. Obviously, it will have to store the user data and recipe data. In this exercise, we will create the database administrator and set up the database for our Smilecook application:</p>
			<ol>
				<li>To start with, we will create a role. A role is simply a concept that PostgreSQL uses to manage access. We can consider that as a user here. <em class="italics">Right-click</em> on <strong class="bold">PostgreSQL 11</strong> under <strong class="bold">Servers</strong>, select <strong class="bold">Create</strong>, and then <strong class="bold">Login/Group Role…</strong>:<div id="_idContainer045" class="IMG---Figure"><img src="image/C15309_03_01.jpg" alt="Figure 3.1: Selecting Login/Group Role…&#13;&#10;"/></div><h6>Figure 3.1: Selecting Login/Group Role…</h6></li>
				<li>Fill in the login name, which will be used later for connecting to the database:<div id="_idContainer046" class="IMG---Figure"><img src="image/C15309_03_02.jpg" alt="Figure 3.2: Filling in the login name&#13;&#10;"/></div><h6>Figure 3.2: Filling in the login name</h6></li>
				<li>Then, select <strong class="bold">Definition</strong> and set the password. Click <strong class="bold">Save</strong>:<div id="_idContainer047" class="IMG---Figure"><img src="image/C15309_03_03.jpg" alt="Figure 3.3: Setting the password&#13;&#10;"/></div><h6>Figure 3.3: Setting the password</h6></li>
				<li>Now, go to <strong class="bold">Privileges</strong>, and select <strong class="bold">Yes</strong> for <strong class="bold">Can login?</strong>. This will allow us to log in to the database using this account:<div id="_idContainer048" class="IMG---Figure"><img src="image/C15309_03_04.jpg" alt="Figure 3.4: Logging in to the database using the account created&#13;&#10;"/></div><h6>Fig<a id="_idTextAnchor094"/>ure 3.4: Logging in to the database using the account created</h6></li>
				<li><em class="italics">Right-click</em> on <strong class="bold">Databases</strong>, and create a database from there:<div id="_idContainer049" class="IMG---Figure"><img src="image/C15309_03_05.jpg" alt="Figure 3.5: Creating the database&#13;&#10;"/></div><h6>Fig<a id="_idTextAnchor095"/>ure 3.5: Creating the database</h6></li>
				<li>Name the database <strong class="inline">smilecook</strong>, and set the role that we have just created to <strong class="bold">Owner</strong>. Click <strong class="bold">Save</strong>:<div id="_idContainer050" class="IMG---Figure"><img src="image/C15309_03_06.jpg" alt="Figure 3.6: Naming the database and setting the role&#13;&#10;"/></div></li>
			</ol>
			<h6>Figur<a id="_idTextAnchor096"/>e 3.6: Naming the database and setting the role</h6>
			<p>Now we have created the Smilecook database, but it is empty at the moment. In the next exercise, we will use Flask-SQLAlchemy and Flask-Migrate to create our database tables. You will notice that there is no SQL query involved.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor097"/>Defining Our Models</h2>
			<p>Before we go into the implementation, we need to first define and understand the fields that we will be working with. We will cover two essential models: <strong class="bold">User</strong> and <strong class="bold">Recipe</strong>. Models are like schemas in the database. A model is a class and can be instantiated. It contains attributes that correspond to fields in database schemas.</p>
			<p><strong class="bold">The user model</strong></p>
			<p>The user model will be mapped to the user table in the database. The fields and methods we defined for our user model are as follows:</p>
			<ul>
				<li><strong class="inline">id</strong>: The identity of a user.</li>
				<li><strong class="inline">username</strong>: The username of the user. The maximum length allowed is 80 characters. It can't be null and is a unique field.</li>
				<li><strong class="inline">email</strong>: The user's email. The maximum length allowed is 200. It can't be blank and is a unique field.</li>
				<li><strong class="inline">password</strong>: The user's password. The maximum length allowed is 200.</li>
				<li><strong class="inline">is_active</strong>: This is to indicate whether the account is activated by email. It is a Boolean field with a default value of <strong class="inline">False</strong>.</li>
				<li><strong class="inline">recipes</strong>: This doesn't create a field in the database table. This is just to define the relationship with the recipe model. So, subsequently, we can get all recipes using <strong class="inline">user.recipes</strong>.</li>
				<li><strong class="inline">created_at</strong>: The creation time of the user.</li>
				<li><strong class="inline">updated_at</strong>: The last update time of the user.</li>
			</ul>
			<p>We are also going to define three methods in the user model:</p>
			<ul>
				<li><strong class="inline">get_by_username</strong>: This method is used for searching the user by username.</li>
				<li><strong class="inline">get_by_email</strong>: This method is used for searching the user by email.</li>
				<li><strong class="inline">save</strong>: This is to persist the data to the database.</li>
			</ul>
			<p><strong class="bold">The recipe model</strong></p>
			<p>The recipe model will be mapped to the user table in the database. The fields we defined for our recipe model are as follows:</p>
			<ul>
				<li><strong class="inline">id</strong>: The identity of a recipe.</li>
				<li><strong class="inline">name</strong>: The name of the recipe. The maximum length allowed is 100 characters. It can't be null.</li>
				<li><strong class="inline">description</strong>: The description of the recipe. The maximum length allowed is 200. </li>
				<li><strong class="inline">num_of_servings</strong>: The number of servings. This needs to be an integer.</li>
				<li><strong class="inline">cook_time</strong>: The cooking time in minutes. This field only accepts an integer. </li>
				<li><strong class="inline">directions</strong>: The directions of the recipe. This can have a maximum length of 1,000.</li>
				<li><strong class="inline">is_publish</strong>: This is to indicate whether the recipe has been published. It is set to <strong class="inline">False</strong> by default.</li>
				<li><strong class="inline">created_at</strong>: The creation time of the recipe.</li>
				<li><strong class="inline">updated_at</strong>: The last update time of the recipe.</li>
			</ul>
			<p>With the model designs in our mind, we are now ready to use these models in our next exercise. Before that, let's also just briefly understand some of the key packages that we will be using. These are as follows:</p>
			<ul>
				<li>Flask-SQLAlchemy: This is a very popular ORM package that allows us to access objects rather than database tables for data. With ORM, we do not need to rely on SQL anymore.</li>
				<li>Flask-Migrate: This is a package for database migration; it works on top of Alembic.</li>
				<li>Psycopg2-binary: This is the adapter for the Postgres database.</li>
				<li>Passlib: This is a password hashing library for Python.</li>
			</ul>
			<h3 id="_idParaDest-72"><a id="_idTextAnchor098"/>Exercise 19: Installing Packages and Defining Models </h3>
			<p>This exercise is designed to install the necessary packages and define the user and recipe models. The u<a id="_idTextAnchor099"/>ser and recipe models are going to be Python classes; there will not be any SQL coding in this exercise. We want to show you how we can interact with the database by simply coding in Python: </p>
			<ol>
				<li value="1">We will add the required packages in the <strong class="inline">requirements.txt</strong> file. If you remember, by putting the package name and version in <strong class="inline">requirements.txt</strong>, we can install them in the Python virtual environment by using a single <strong class="inline">pip</strong> command:<p class="snippet">Flask-SQLAlchemy==2.4.0</p><p class="snippet">Flask-Migrate==2.5.2</p><p class="snippet">psycopg2-binary==2.8.3</p><p class="snippet">passlib==1.7.1</p></li>
				<li>We ca<a id="_idTextAnchor100"/>n run the following <strong class="inline">pip install</strong> command to install the necessary packages:<p class="snippet">pip install -r requirements.txt</p><p>The installation result will be shown onscreen:</p><p class="snippet">Installing collected packages: SQLAlchemy, Flask-SQLAlchemy, alembic, Flask-Migrate, psycopg2-binary, passlib</p><p class="snippet">  Running setup.py install for SQLAlchemy ... done</p><p class="snippet">  Running setup.py install for alembic ... done</p><p class="snippet">Successfully installed Flask-Migrate-2.5.2 Flask-SQLAlchemy-2.4.0 SQLAlchemy-1.3.6 alembic-1.0.11 passlib-1.7.1 psycopg2-binary-2.8.3</p></li>
				<li>Create<a id="_idTextAnchor101"/> a <strong class="inline">Config.py</strong> file and type in the following code:<p class="snippet">class Config:</p><p class="snippet">    DEBUG = True</p><p class="snippet">    SQLALCHEMY_DATABASE_URI = 'postgresql+psycopg2://{your_name}:{your_password}@localhost/{db_name}</p><p class="snippet">    SQLALCHEMY_TRACK_MODIFICATIONS = False</p><p>We can<a id="_idTextAnchor102"/> set <strong class="inline">DEBUG = True</strong> here for debugging purposes. As regards <strong class="inline">SQLALCHEMY_DATABASE_URI</strong>, this is the path of the database. Please replace the username and password with the one we created for the <strong class="bold">Role</strong> in <strong class="inline">pgAdmin</strong>. Also, replace the database name as well.</p></li>
				<li>Now, create <strong class="inline">extensions.py</strong> under the Smilecook project and type in the following code:<p class="snippet">from flask_sqlalchemy import SQLAlchemy</p><p class="snippet">db = SQLAlchemy()</p></li>
				<li>Create<a id="_idTextAnchor103"/> <strong class="inline">user.py</strong> under the folder models and type in the following code:<p class="snippet">from extensions import db</p><p class="snippet">class User(db.Model):</p><p class="snippet">    __tablename__ = 'user'</p><p class="snippet">    id = db.Column(db.Integer, primary_key=True)</p><p class="snippet">    username = db.Column(db.String(80), nullable=False, unique=True)</p><p class="snippet">    email = db.Column(db.String(200), nullable=False, unique=True)</p><p class="snippet">    password = db.Column(db.String(200))</p><p class="snippet">    is_active = db.Column(db.Boolean(), default=False)</p><p class="snippet">    created_at = db.Column(db.DateTime(), nullable=False, server_default=db.func.now())</p><p class="snippet">    updated_at = db.Column(db.DateTime(), nullable=False, server_default=db.func.now(), onupdate=db.func.now())</p><p class="snippet">    recipes = db.relationship('Recipe', backref='user')</p><p class="snippet">    @classmethod</p><p class="snippet">    def get_by_username(cls, username):</p><p class="snippet">        return cls.query.filter_by(username=username).first()</p><p class="snippet">    @classmethod</p><p class="snippet">    def get_by_email(cls, email):</p><p class="snippet">        return cls.query.filter_by(email=email).first()</p><p class="snippet">    </p><p class="snippet">    def save(self):</p><p class="snippet">        db.session.add(self)</p><p class="snippet">        db.session.commit()</p></li>
				<li>Repla<a id="_idTextAnchor104"/><a id="_idTextAnchor105"/><a id="_idTextAnchor106"/>c<a id="_idTextAnchor107"/>e  <strong class="inline">recipe.py</strong> with the following code. We are adding the import <strong class="inline">db</strong> statement here and have also modified the <strong class="inline">Recipe</strong> class. The code related to <strong class="inline">recipe_list</strong> is still valid here, so we are retaining that part of the code: <p class="snippet">from extensions import db</p><p class="snippet">recipe_list = []</p><p class="snippet">def get_last_id():</p><p class="snippet">    if recipe_list:</p><p class="snippet">        last_recipe = recipe_list[-1]</p><p class="snippet">    else:</p><p class="snippet">        return 1</p><p class="snippet">    return last_recipe.id + 1</p><p class="snippet">class Recipe(db.Model):</p><p class="snippet">    __tablename__ = 'recipe'</p><p class="snippet">    id = db.Column(db.Integer, primary_key=True)</p><p class="snippet">    name = db.Column(db.String(100), nullable=False)</p><p class="snippet">    description = db.Column(db.String(200))</p><p class="snippet">    num_of_servings = db.Column(db.Integer)</p><p class="snippet">    cook_time = db.Column(db.Integer)</p><p class="snippet">    directions = db.Column(db.String(1000))</p><p class="snippet">    is_publish = db.Column(db.Boolean(), default=False)</p><p class="snippet">    created_at = db.Column(db.DateTime(), nullable=False, server_default=db.func.now())</p><p class="snippet">    updated_at = db.Column(db.DateTime(), nullable=False, server_default=db.func.now(), onupdate=db.func.now())</p><p class="snippet">    user_id = db.Column(db.Integer(), db.ForeignKey("user.id"))</p></li>
				<li>Now, <a id="_idTextAnchor108"/>r<a id="_idTextAnchor109"/>ewrite <strong class="inline">app.py</strong> with the following code. We are structuring our code in a more proper way, making it more readable and maintainable. First, import the required packages at the beginning of the code file. <h4>Note</h4><p class="callout">You're also importing the user model because SQLAlchemy needs the user model to create the corresponding table in the database.</p><p>For the recipe model, we don't need to include this here because that has already been done in <strong class="inline">resources.recipe</strong>, and we are already importing <strong class="inline">resources.recipe</strong> here: </p><p class="snippet">from flask import Flask</p><p class="snippet">from flask_migrate import Migrate</p><p class="snippet">from flask_restful import Api</p><p class="snippet">from config import Config</p><p class="snippet">from extensions import db</p><p class="snippet">from models.user import User</p><p class="snippet">from resources.recipe import RecipeListResource, RecipeResource, RecipePublishResource</p></li>
				<li>Use the <strong class="inline">create_app()</strong> function to create the Flask app. This will invoke <strong class="inline">register_extensions(app)</strong> to initialize SQLAlchemy and set up Flask-Migrate. It will then invoke <strong class="inline">register_resources(app)</strong> to set up resource routing:<p class="snippet">def create_app():</p><p class="snippet">    app = Flask(__name__)</p><p class="snippet">    app.config.from_object(Config)</p><p class="snippet">    register_extensions(app)</p><p class="snippet">    register_resources(app)</p><p class="snippet">    return app</p><p class="snippet">def register_extensions(app):</p><p class="snippet">    db.init_app(app)</p><p class="snippet">    migrate = Migrate(app, db)</p><p class="snippet">def register_resources(app):</p><p class="snippet">    api = Api(app)</p><p class="snippet">    api.add_resource(RecipeListResource, '/recipes')</p><p class="snippet">    api.add_resource(RecipeResource, '/recipes/&lt;int:recipe_id&gt;')</p><p class="snippet">    api.add_resource(RecipePublishResource, '/recipes/&lt;int:recipe_id&gt;/publish')</p></li>
				<li>Finally, use <strong class="inline">app = create_app()</strong> to create the Flask app, and use <strong class="inline">app.run()</strong> to start the application:<p class="snippet">if __name__ == '__main__':</p><p class="snippet">    app = create_app()</p><p class="snippet">    app.run()</p></li>
				<li>Save <strong class="inline">app.py</strong> and <em class="italics">right-click</em> on it to run the application. Flask will then be started up and run on the localhost (<strong class="bold">127.0.0.1</strong>) on port 5000:</li>
			</ol>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/C15309_03_07.jpg" alt="Figure 3.7: Flask started on localhost&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 3.7: Flask started on localhost</h6>
			<p>We have<a id="_idTextAnchor110"/> successfully installed the necessary ORM-related packages, and defined the user and recipe models. Having first installed the packages, we ran the installation in our virtual environment. We created <strong class="inline">config.py</strong>, <strong class="inline">extensions.py</strong>, and <strong class="inline">user.py</strong> files and replaced <strong class="inline">app.py</strong>. Finally, we restructured our Flask app and saw how well it runs.</p>
			<h3 id="_idParaDest-73"><a id="_idTextAnchor111"/>Exercise 20: Using Flask-Migrate to Build a Database Upgrade Script</h3>
			<p>Having successfully understood how to work with our two main models, user and recipe, we have now built the perfect foundation. The next step is execution. We will use Flask-Migrate to build a script to create the user and recipe tables:</p>
			<ol>
				<li value="1">Use the<a id="_idTextAnchor112"/> following command in the Terminal to initialize our database. This will create a migration repository: <p class="snippet">flask db init</p><p>You should see the following onscreen:</p><p class="snippet">Creating directory /Python-API-Development-Fundamentals/smilecook/migrations ... done</p><p class="snippet">Creating directory /Python-API-Development-Fundamentals/smilecook/migrations/versions ... done</p><p class="snippet">Generating /Python-API-Development-Fundamentals/smilecook/migrations/script.py.mako ... done</p><p class="snippet">Generating /Python-API-Development-Fundamentals/smilecook/migrations/env.py ... done</p><p class="snippet">Generating /Python-API-Development-Fundamentals/smilecook/migrations/README ... done</p><p class="snippet">Generating /Python-API-Development-Fundamentals/smilecook/migrations/alembic.ini ... done</p><p class="snippet">Please edit configuration/connection/logging settings in '/Python-API-Development-</p><p class="snippet">Fundamentals/smilecook/migrations/alembic.ini' before proceeding.</p><p>You should now see the following new files in PyCharm:</p><div id="_idContainer052" class="IMG---Figure"><img src="image/C15309_03_08.jpg" alt="Figure 3.8: New folders in PyCharm&#13;&#10;"/></div><h6>Figure<a id="_idTextAnchor113"/> <a id="_idTextAnchor114"/>3.8: New folders in PyCharm</h6></li>
				<li>Now, run the <strong class="inline">flask db migrate</strong> command to create the database and tables. There is no need for us to use SQL here:<p class="snippet">flask db migrate</p><p>Flask-Migrate detected two objects (<strong class="inline">user</strong> and <strong class="inline">recipe</strong>) and created two corresponding tables for them: </p><p class="snippet">INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</p><p class="snippet">INFO  [alembic.runtime.migration] Will assume transactional DDL.</p><p class="snippet">INFO  [alembic.autogenerate.compare] Detected added table 'user'</p><p class="snippet">INFO  [alembic.autogenerate.compare] Detected added table 'recipe'</p><p class="snippet">  Generating /Python-API-Development-Fundamentals/smilecook/migrations/versions/a6d248ab7b23_.py ... done</p></li>
				<li>Now, please check <strong class="inline">/migrations/versions/a6d248ab7b23_.py</strong> under the <strong class="inline">versions</strong> folder. This file is created by Flask-Migrate. Note that you may get a different revision ID here. Please review the file before you run the flask <strong class="inline">db</strong> upgrade command. That's because, sometimes, it may not detect every change you make to your models:<p class="snippet">"""empty message</p><p class="snippet">Revision ID: a6d248ab7b23</p><p class="snippet">Revises: </p><p class="snippet">Create Date: 2019-07-22 16:10:41.644737</p><p class="snippet">"""</p><p class="snippet">from alembic import op</p><p class="snippet">import sqlalchemy as sa</p><p class="snippet"># revision identifiers, used by Alembic.</p><p class="snippet">revision = 'a6d248ab7b23'</p><p class="snippet">down_revision = None</p><p class="snippet">branch_labels = None</p><p class="snippet">depends_on = None</p><p class="snippet">def upgrade():</p><p class="snippet">    # ### commands auto generated by Alembic - please adjust! ###</p><p class="snippet">    op.create_table('user',</p><p class="snippet">    sa.Column('id', sa.Integer(), nullable=False),</p><p class="snippet">    sa.Column('username', sa.String(length=80), nullable=False),</p><p class="snippet">    sa.Column('email', sa.String(length=200), nullable=False),</p><p class="snippet">    sa.Column('password', sa.String(), nullable=True),</p><p class="snippet">    sa.Column('is_active', sa.Boolean(), nullable=True),</p><p class="snippet">    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),</p><p class="snippet">    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),</p><p class="snippet">    sa.PrimaryKeyConstraint('id'),</p><p class="snippet">    sa.UniqueConstraint('email')</p><p class="snippet">    )</p><p class="snippet">    op.create_table('recipe',</p><p class="snippet">    sa.Column('id', sa.Integer(), nullable=False),</p><p class="snippet">    sa.Column('name', sa.String(length=100), nullable=False),</p><p class="snippet">    sa.Column('description', sa.String(length=500), nullable=True),</p><p class="snippet">    sa.Column('num_of_servings', sa.Integer(), nullable=True),</p><p class="snippet">    sa.Column('cook_time', sa.Integer(), nullable=True),</p><p class="snippet">    sa.Column('directions', sa.String(), nullable=True),</p><p class="snippet">    sa.Column('is_publish', sa.Boolean(), nullable=True),</p><p class="snippet">    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),</p><p class="snippet">    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),</p><p class="snippet">    sa.Column('user_id', sa.Integer(), nullable=True),</p><p class="snippet">    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),</p><p class="snippet">    sa.PrimaryKeyConstraint('id')</p><p class="snippet">    )</p><p class="snippet">    # ### end Alembic commands ###</p><p class="snippet">def downgrade():</p><p class="snippet">    # ### commands auto generated by Alembic - please adjust! ###</p><p class="snippet">    op.drop_table('recipe')</p><p class="snippet">    op.drop_table('user')</p><p class="snippet">    # ### end Alembic commands ###</p><p>There are two functions in this autogenerated file; one is upgraded, and this is to add the new recipe and user to the table, while the other one is downgraded, which is to go back to the previous version.</p></li>
				<li>We will <a id="_idTextAnchor115"/>then execute the <strong class="inline">flask db upgrade</strong> command, which will upgrade our database to conform with the latest specification in our models:<p class="snippet">flask db upgrade</p><p>This command will invoke <strong class="inline">upgrade()</strong> to upgrade the database:</p><p class="snippet">INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</p><p class="snippet">INFO  [alembic.runtime.migration] Will assume transactional DDL.</p><p class="snippet">INFO  [alembic.runtime.migration] Running upgrade  -&gt; a6d248ab7b23, empty message</p><h4>Note</h4><p class="callout">In the future, whenever we need to upgrade the database, we can just call <strong class="inline">flask db migrate</strong> and <strong class="inline">flask db upgrade</strong>. </p></li>
				<li>Check t<a id="_idTextAnchor116"/>h<a id="_idTextAnchor117"/>e database tables in <strong class="inline">pgAdmin</strong>. Now, we can see whether the tables have been created in the database. Go to <strong class="bold">smilecook</strong> &gt;&gt; <strong class="bold">Schemas</strong> &gt;&gt; <strong class="bold">Tables to verify</strong>:<div id="_idContainer053" class="IMG---Figure"><img src="image/C15309_03_09.jpg" alt="Figure 3.9: Checking the database tables&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure <a id="_idTextAnchor118"/>3.9: Checking the database tables</h6>
			<p>If you see the recipe and user tables in our <strong class="bold">Smilecook</strong> database, this means you have successfully created them in Python without any SQL. Isn't that cool?!</p>
			<p>Next, we will try our hand at database insertion. Let's look at the following exercise.</p>
			<h3 id="_idParaDest-74">Exercise <a id="_idTextAnchor119"/>21: Applying Database Insertion</h3>
			<p>This exercise is designed for us to test database insertion. We will first create a user, and then create two recipes under that user:</p>
			<ol>
				<li value="1">Import mo<a id="_idTextAnchor120"/>dules in the Python console. Open the Python console at the bottom of PyCharm and type in the following code to import the necessary classes:<p class="snippet">from app import *</p><p class="snippet">from models.user import User</p><p class="snippet">from models.recipe import Recipe</p><p class="snippet">app = create_app()</p></li>
				<li>Create ou<a id="_idTextAnchor121"/>r first <strong class="inline">user</strong> object and save that to the database by typing in the following code in the Python console:<p class="snippet">user = User(username='jack', email='jack@gmail.com', password='WkQa')</p><p class="snippet">db.session.add(user)</p><p class="snippet">db.session.commit()</p></li>
				<li>Now, check the <strong class="inline">user</strong> details. Please note that the ID of the user has already been assigned to <strong class="inline">1</strong>:<p class="snippet">&gt;&gt;&gt;user.username</p><p class="snippet">'jack'</p><p class="snippet">&gt;&gt;&gt;user.id</p><p class="snippet">1</p><p class="snippet">&gt;&gt;&gt;user.email</p><p class="snippet">'jack@gmail.com'</p></li>
				<li>Since the user is persisted in the database, we will verify that there:<div id="_idContainer054" class="IMG---Figure"><img src="image/C15309_03_10.jpg" alt="Figure 3.10: Verifying the user in the database&#13;&#10;"/></div><h6>Figure 3.10: Verifying the user in the database</h6></li>
				<li>We can see a record there in the <strong class="inline">user</strong> table:</li>
				<li><div id="_idContainer055" class="IMG---Figure"><img src="image/C15309_03_11.jpg" alt="Figure 3.11: Record in the user table&#13;&#10;"/></div><h6>Figure 3.11: Record in the user table</h6></li>
				<li>Next, we wi<a id="_idTextAnchor122"/>ll create two recipes using the following code. One thing to note is that the <strong class="inline">user_id</strong> attribute of the recipe is set to <strong class="inline">user.id</strong>. This is to indicate that the recipe was created by the user <strong class="inline">Jack</strong>:<p class="snippet">pizza = Recipe(name='Cheese Pizza', description='This is a lovely cheese pizza recipe', num_of_servings=2, cook_time=30, directions='This is how you make it', user_id=user.id)</p><p class="snippet">db.session.add(pizza)</p><p class="snippet">db.session.commit()</p><p class="snippet">pasta = Recipe(name='Tomato Pasta', description='This is a lovely tomato pasta recipe', num_of_servings=3, cook_time=20, directions='This is how you make it', user_id=user.id)</p><p class="snippet">db.session.add(pasta)</p><p class="snippet">db.session.commit()</p></li>
				<li>We will then check whether the two recipes have been created in the database:<div id="_idContainer056" class="IMG---Figure"><img src="image/C15309_03_12.jpg" alt="Figure 3.12: Checking whether the two recipes have been created&#13;&#10;"/></div><h6>Figure 3.12: Checking whether the two recipes have been created</h6></li>
				<li>We will search for the user with the username <strong class="inline">jack</strong> in the database and get all the recipes created by that user in their object attribute, <strong class="inline">recipes</strong>:<p class="snippet">&gt;&gt;&gt; user = User.query.filter_by(username='jack').first()</p><p class="snippet">&gt;&gt;&gt; user.recipes</p><p>We will get a list of two recipes:</p><p class="snippet">[&lt;Recipe 1&gt;, &lt;Recipe 2&gt;]</p></li>
				<li>We can display the details of the recipes using the <strong class="inline">for</strong> loop. We get the recipe name using <strong class="inline">recipe.name</strong>, while we get the user's name using <strong class="inline">recipe.user.username</strong>:<p class="snippet">&gt;&gt;&gt; for recipe in user.recipes:</p><p class="snippet">    print('{} recipe made by {} can serve {} people.'.format(recipe.name, recipe.user.username, recipe.num_of_servings))</p><p>You should see the following result on the screen:</p><p class="snippet">Cheese Pizza recipe made by jack can serve 2 people.</p><p class="snippet">Tomato Pasta recipe made by jack can serve 3 people.</p></li>
			</ol>
			<p>You have jus<a id="_idTextAnchor123"/>t learned how to command your application using the Python console. You have just created the user and recipe models and saved them in the database. The entire process is SQL-free, as you can see. Let's do an activity to reinforce your knowledge.</p>
			<h3 id="_idParaDest-75"><a id="_idTextAnchor124"/>Activity 5: Creating a User and a Recipe</h3>
			<p>In this activity, we will test our APIs by running a few more test cases. We want to create a new user, <strong class="inline">Peter</strong>, and create two recipes under him in the database. Let's see if you know how to write the code for that in the Python interactive console:</p>
			<ol>
				<li value="1">Import the <strong class="inline">User</strong> and <strong class="inline">Recipe</strong> classes and create the Flask app using the Python console.</li>
				<li>Create a new user, <strong class="inline">Peter</strong>.</li>
				<li>Create two recipes and assign <strong class="inline">Peter</strong> as the author.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 302.</p></li>
			</ol>
			<p>If you can see that the data has successfully been created in the database, congratulations – you already know how to use Python console to interact with the database! Next, we will implement a user registration feature.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor125"/>Password Hashing</h2>
			<p>Hashing is a one-way mathematical function. It requires little computing power to convert a plaintext string to its hash value (hashes). However, it will require a huge amount of computing power to retrieve the original string from the hash value (it's almost impossible). Therefore, we call it a one-way function:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/C15309_03_13.jpg" alt="Figure 3.13: Workings of the hash function&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 3.13: Workings of the hash function</h6>
			<p>With this property, a hash function is perfect for a hashing password. We will hash the user's password into hashes before we save it to the database so that it is unrecognizable and irreversible. And next time, when the user logs in, what the platform does is to convert the input the password to its hash value, and then compare that with the hash value stored in the database. That way, we can perform a password comparison without leaking the sensitive password information to others.</p>
			<h3 id="_idParaDest-77"><a id="_idTextAnchor126"/>Exercise 22: Implement the User Registration Feature and Hash the User's Password</h3>
			<p>In this exercise, we will work on the user registration feature. We will also implement two functions for hashing the user's password: </p>
			<ol>
				<li value="1">Create <strong class="inline">utils.py</strong> under the application project folder and type in the following code. The code is to hash the password. We do not want to store plaintext passwords in our database on account of security concerns. Therefore, we will use the <strong class="inline">passlib</strong> modules for hashing. We defined two methods here:<p class="snippet">from passlib.hash import pbkdf2_sha256</p><p class="snippet">def hash_password(password):</p><p class="snippet">    return pbkdf2_sha256.hash(password)</p><p class="snippet">def check_password(password, hashed):</p><p class="snippet">    return pbkdf2_sha256.verify(password, hashed)</p><p>The <strong class="inline">hash_pass<a id="_idTextAnchor127"/>word(password)</strong> function is for password hashing and <strong class="inline">check_password(password, hashed)</strong> is for user authentication. It hashes the user-input password and compares that with the one we saved in the database.</p></li>
				<li>Create <strong class="inline">user.py</strong> in the <strong class="inline">resources</strong> folder, and then type in the following code. We will first import the necessary modules and implement the <strong class="inline">Post</strong> method in <strong class="inline">UserListResource</strong>:<p class="snippet">from flask import request</p><p class="snippet">from flask_restful import Resource</p><p class="snippet">from http import HTTPStatus</p><p class="snippet">from utils import hash_password</p><p class="snippet">from models.user import User</p><p class="snippet">class UserListResource(Resource):</p><p class="snippet">    def post(self):</p><p class="snippet">        json_data = request.get_json()</p><p class="snippet">        username = json_data.get('username')</p><p class="snippet">        email = json_data.get('email')</p><p class="snippet">        non_hash_password = json_data.get('password')</p><p>When there is a client request hitting <strong class="inline">http://localhost/users</strong> with the HTTP <strong class="inline">POST</strong> method, the application will get the JSON formatted data in the request. There should be a username, email, and password. </p></li>
				<li>Check whether the user already exists in the database by means of <strong class="inline">User.get_by_user(username)</strong>. If such an entry is found, that means the user has already registered and we will simply return an error message. We will also perform the same check on <strong class="inline">email</strong> as well:<p class="snippet">        if User.get_by_username(username):</p><p class="snippet">            return {'message': 'username already used'}, HTTPStatus.BAD_REQUEST</p><p class="snippet">        if User.get_by_email(email):</p><p class="snippet">            return {'message': 'email already used'}, HTTPStatus.BAD_REQUEST</p></li>
				<li>Once all the <a id="_idTextAnchor128"/>validations are passed, go ahead and create the user in the database. The password will be hashed, and the user object will be created. The user object will then be saved to the database using <strong class="inline">user.save()</strong>. Finally, the user details are returned in JSON format, with an <strong class="inline">HTTP</strong> status code of <strong class="inline">201</strong>:<p class="snippet">    password = hash_password(non_hash_password)</p><p class="snippet">        user = User(</p><p class="snippet">            username=username,</p><p class="snippet">            email=email,</p><p class="snippet">            password=password</p><p class="snippet">        )</p><p class="snippet">        user.save()</p><p class="snippet">        data = {</p><p class="snippet">            'id': user.id,</p><p class="snippet">            'username': user.username,</p><p class="snippet">            'email': user.email</p><p class="snippet">        }</p><p class="snippet">        return data, HTTPStatus.CREATED</p></li>
				<li>Add user resource routing to <strong class="inline">app.py</strong>:<p class="snippet">from extensions import db</p><p class="snippet">from resources.user import UserListResource</p><p class="snippet">from resources.recipe import RecipeListResource, RecipeResource, RecipePublishResource</p><p class="snippet">def register_resources(app):</p><p class="snippet">    api = Api(app)</p><p class="snippet">    api.add_resource(UserListResource, '/users')</p><p class="snippet">    api.add_resource(RecipeListResource, '/recipes')</p><p>Replace <strong class="inline">from models.user import User</strong> in <strong class="inline">app.py</strong> with <strong class="inline">from resources.user import UserListResource</strong>. The user model is already imported in <strong class="inline">resources.user</strong>, so there is no need to reimport that again. Please add <strong class="inline">api.add_resource(UserListResource, '/users')</strong> to the code as well.</p><p>Run the application. Flask will then be started up and run on localhost (<strong class="inline">127.0.0.1</strong>) on port <strong class="inline">5000</strong>: </p><div id="_idContainer058" class="IMG---Figure"><img src="image/C15309_03_07.jpg" alt="Figure 3.14: Flask started on localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 3.14: Flask started on localhost</h6>
			<p>So, we have just finished the password hashing exercise. From now on, whenever there is a new user registered in our Smilecook application, their password will be hashed and stored safely in the database. Let's test and see whether that is the case in our next exercise. </p>
			<h4>Note</h4>
			<p class="callout">The reason why<a id="_idTextAnchor129"/> we are not discussing the recipe resource here is that there will be an author ID in the recipe. The author ID will be a foreign key that links to the user model. We will talk about the user login function in our next chapter. Only after that can we get the user ID and finish the recipe resource.</p>
			<h3 id="_idParaDest-78"><a id="_idTextAnchor130"/>Exercise 23: Testing the Application in Postman</h3>
			<p>In this exercise, we are going to test the application in Postman. We will first register a user account and make sure the user data is stored in the database. We also need to verify that the password is hashed. Having created a user, now let's test our API endpoint here:</p>
			<ol>
				<li value="1">Click on the <strong class="bold">Collections</strong> tab in Postman.</li>
				<li>Create a new collection, and name it <strong class="inline">User</strong>.</li>
				<li>Create a new <a id="_idTextAnchor131"/>request, <strong class="inline">UserList</strong>, under that collection. You can do this by clicking on the <strong class="bold">...</strong> next to the <strong class="inline">User</strong> collection. </li>
				<li>Edit the <strong class="bold">UserList</strong> request, and then set the HTTP method to <strong class="inline">POST</strong>.</li>
				<li>Type in <strong class="inline">http://localhost:5000/users</strong> in the URL field.</li>
				<li>Go to the <strong class="bold">Body</strong> Tab, select <strong class="bold">raw</strong> as the datatype, and then select <strong class="bold">JSON (application/json)</strong> as the data format.</li>
				<li>Insert the following user details and then save.:<p class="snippet">{</p><p class="snippet">    "username": "jack",</p><p class="snippet">    "email": "jack@gmail.com",</p><p class="snippet">    "password": "WkQa"</p><p class="snippet">}</p></li>
				<li>Click <strong class="bold">Send</strong>. The result can be seen in the following screenshot:<div id="_idContainer059" class="IMG---Figure"><img src="image/C15309_03_15.jpg" alt="Figure 3.15: Creating a user with an existing username&#13;&#10;"/></div><h6>Figure 3.15: Creating a user with an existing username</h6><p>You will then see the following data returned; the HTTP status is <strong class="bold">400 BAD REQUEST</strong>. We can also see the error message in the <strong class="bold">Body</strong> field showing that the username has been registered.</p></li>
				<li>Create another <a id="_idTextAnchor132"/>user with the details shown in the following code:<p class="snippet">{</p><p class="snippet">    "username": "ray",</p><p class="snippet">    "email": "ray@gmail.com",</p><p class="snippet">    "password": "WkQa"</p><p class="snippet">}</p><p>The result can be seen in the following screenshot:</p><div id="_idContainer060" class="IMG---Figure"><img src="image/C15309_03_16.jpg" alt="Figure 3.16: Creating another user&#13;&#10;"/></div><h6>Figure 3.16: Creating another user</h6><p>Now, the second account has been successfully created.</p></li>
				<li>Check the data i<a id="_idTextAnchor133"/>n the database as follows:<div id="_idContainer061" class="IMG---Figure"><img src="image/C15309_03_17.jpg" alt="Figure 3.17: Checking the data in the database&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 3.17: Checking the data in the database</h6>
			<p>Now, we can see a new user record created in the database table. And you can see that the password is hashed.</p>
			<p>By doing this testing exercise, we can be assured that our user registration workflow is functioning well. And, most importantly, user passwords are kept as the hash value in the database. That is a much safer way to store a password, as even the database administrator can't see it.</p>
			<h3 id="_idParaDest-79"><a id="_idTextAnchor134"/>Activity 6: Upgrading and Downgrading a Database</h3>
			<ol>
				<li value="1">In this activity, we will upgrade and downgrade our database to simulate a scenario where we need to add an attribute under the <strong class="inline">user</strong> class, but later we change our mind and need to remove it. The following are the high-level steps that we need to perform in order to complete this activity:</li>
				<li>Add a new attribute to the <strong class="inline">user</strong> class. This attribute should be called <strong class="inline">bio</strong> and will be a string that represents information about the user.</li>
				<li>Run the <strong class="inline">flask db migrate</strong> command to create the database and tables.</li>
				<li>Now, check <strong class="inline">/migrations/versions/6971bd62ec60_.py</strong> under the <strong class="inline">versions</strong> folder. This file is created by Flask-Migrate.</li>
				<li>Execute the <strong class="inline">flask db upgrade</strong> command to upgrade our database to conform with the latest specification in our models.</li>
				<li>Check whether the new field is created in the database. </li>
				<li>Run the <strong class="inline">downgrade</strong> command to remove the new field.</li>
				<li>Check whether the field has been removed.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 303.</p></li>
			</ol>
			<p>If you see that the new field has been removed, that means you have successfully downgraded the database in Python without writing any SQL. And don't forget to delete the user model's bio attribute in models/user.py, also delete the script that we created which is <strong class="inline">a6d248ab7b23.py</strong> in migrations/versions folder. You have just learned a very useful skill that you will probably need frequently in the future. One tip for you is that you should back up your database prior to any database schema update. This is to ensure the data won't get lost.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor135"/>Summary</h2>
			<p>In this chapter, we built the Postgres database locally and learned how to use the pgAdmin tool to manage it. Then, through the SQLAlchemy module, we developed an object library to manipulate the database. This is much easier than using SQL syntax directly. And, as long as we define the relationship between models, we can easily get the information we want. This results in higher code readability, fewer lines of code, and the elimination of repetitive SQL. We then use Flask-Migrate to build all the data tables. Then, when we migrate the database in the future, we simply need two commands – <strong class="inline">flask db migrate</strong> and <strong class="inline">flask db upgrade</strong>; it's simple and easy. Although Flask-Migrate can help us to set up and migrate a database more easily, in a production environment, performing this kind of migration still requires extra due diligence. We should always back up the database to safeguard our precious data.</p>
			<p>During development, we should frequently test our code to make sure it is behaving as expected. We shouldn't wait till the end to perform big-bang testing. We can unit test our functions and API endpoints, once they are complete. Using the Python console to perform this kind of simple test is recommended. Iteratively testing our application can also foster the best programming practice. This forces us to think about how we can structure our code in an elegant manner and avoid technical debt accumulation.</p>
			<p>Finally, we created an API for user registration. In the next chapter, we will work on user login and recipe creation for authenticated users.</p>
		</div>
	</body></html>