<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-64"><a id="_idTextAnchor086"/>3. Manipulating a Database with SQLAlchemy</h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Use the pgAdmin tool to manage a database</li>
				<li class="bullets">Manipulate a database using SQLAlchemy</li>
				<li class="bullets">Create database tables using Flask-Migrate</li>
				<li class="bullets">Persist data into a database</li>
				<li class="bullets">Hash confidential password data</li>
			</ul>
			<p>This chapter covers using SQLAlchemy to access a database, including building a model, encrypting the password, ensuring each email is unique, and then saving the recipe data in the database.</p>
		</div>
		<div><h2 id="_idParaDest-65"><a id="_idTextAnchor087"/>Introduction</h2>
			<p>In the previous chapter, we were only storing our data in application memory. While it is easy to code that way, the data will be gone once the server restarts. That is obviously not ideal because we would expect the data to be persisted even after a server restart or application migration and suchlike. Therefore, in this chapter, we will talk about persisting data in a database. We will begin by installing the Postgres database on our local machine. Then, we will create a database using pgAdmin and interact with it using the <strong class="keyword">ORM</strong> (<strong class="keyword">Object Relational Mapping</strong>) package, SQLAlchemy. ORM allows us to interact with a database by means of an object instead of an SQL query. After that, we will define the user and recipe models, link them up, and use Flask-Migrate to create the corresponding tables in the database. Once that part is complete, we will go through exercises to understand the utilization of SQLAlchemy in the Python console. Lastly, we will add the resource for users so that new users can be created through an API.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor088"/>Databases</h2>
			<p>You have probably heard of the term database before. It is basically a data storage system. But why do we need a system to store data? Why can't we just store everything in a text file and save that in the folder system? Apparently, a database does more than just storing data. It classifies and organizes data and helps to store it with less redundancy. It also makes data easier to maintain, making it more it secure and consistent. A database is usually managed by a <strong class="keyword">database management system</strong> (<strong class="keyword">DBMS</strong>)</p>
			<h3 id="_idParaDest-67"><a id="_idTextAnchor089"/>Database Management System</h3>
			<p>A DBMS is an application that maneuvers and manages a database. It facilitates communication between the users and the database. Users can create, use, and maintain the database using this application.</p>
			<p>A DBMS is crucial for data security and integrity. Popular database software and DBMSs include PostgreSQL, MySQL, Microsoft SQL Server, MariaDB, and Oracle Database. Most DBMSs use <strong class="keyword">structured query language</strong> (<strong class="keyword">SQL</strong>) to insert and extract data. </p>
			<p>In this book, we will be using PostgreSQL as our backend database system. And we will also use pgAdmin, which is a tool for managing PostgreSQL. PostgreSQL is a powerful, open-source object-relational database management system with a 15-year history. It is well recognized as a result of its stability and data integrity. </p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor090"/>SQL</h2>
			<p><strong class="keyword">SQL</strong> is a language that was specifically invented to manage and maneuver data. It can be classified further into the following types:</p>
			<ul>
				<li><code>SELECT column1, column2 FROM table WHERE conditions</code>, it can query against the table and extracts data (<code>column1, column2</code>) that satisfies a certain condition.</li>
				<li><code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>.</li>
				<li><strong class="keyword">Data Control Language</strong> (<strong class="keyword">DCL</strong>) for controlling data access.</li>
			</ul>
			<p>Although we have introduced a number of different languages here, the good thing is that we don't need to learn all of them. In fact, we are not going to query our database using SQL. We will just need to code in Python, and the ORM package will convert our Python code to SQL behind the scenes. It's a whole lot easier to work with databases nowadays.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor091"/>ORM</h2>
			<p><strong class="keyword">Object Relational Mapping</strong> (<strong class="keyword">ORM</strong>) is a programming technique that allows the developer to map objects in the programming language to the data model in a database. There is no longer any need to use SQL to interact with a database. The benefit of this is that developers can code in their own programming language and it will work on different types of databases.</p>
			<p>The mapping works along the following lines:</p>
			<ul>
				<li>Class in Python = the table schema in the database</li>
				<li>Attributes in a class = fields in the table schema</li>
				<li>Objects = rows of data in the table</li>
			</ul>
			<p>SQLAlchemy is the most popular ORM in the Python community. <a id="_idTextAnchor092"/>Next, let's delves further by attempting to create a database.</p>
			<h3 id="_idParaDest-70">Exercise 18: Setting Up a Smilecook Database<a id="_idTextAnchor093"/></h3>
			<p>Most applications nowadays require a database to store and manage data. Our application, Smilecook, is no exception. It is a recipe-sharing platform and is open to the public. Obviously, it will have to store the user data and recipe data. In this exercise, we will create the database administrator and set up the database for our Smilecook application:</p>
			<ol>
				<li>To start with, we will create a role. A role is simply a concept that PostgreSQL uses to manage access. We can consider that as a user here. <em class="italics">Right-click</em> on <strong class="bold">PostgreSQL 11</strong> under <strong class="bold">Servers</strong>, select <strong class="bold">Create</strong>, and then <strong class="bold">Login/Group Role…</strong>:<div><img src="img/C15309_03_01.jpg" alt="Figure 3.1: Selecting Login/Group Role…&#13;&#10;"/></div><h6>Figure 3.1: Selecting Login/Group Role…</h6></li>
				<li>Fill in the login name, which will be used later for connecting to the database:<div><img src="img/C15309_03_02.jpg" alt="Figure 3.2: Filling in the login name&#13;&#10;"/></div><h6>Figure 3.2: Filling in the login name</h6></li>
				<li>Then, select <strong class="bold">Definition</strong> and set the password. Click <strong class="bold">Save</strong>:<div><img src="img/C15309_03_03.jpg" alt="Figure 3.3: Setting the password&#13;&#10;"/></div><h6>Figure 3.3: Setting the password</h6></li>
				<li>Now, go to <strong class="bold">Privileges</strong>, and select <strong class="bold">Yes</strong> for <strong class="bold">Can login?</strong>. This will allow us to log in to the database using this account:<div><img src="img/C15309_03_04.jpg" alt="Figure 3.4: Logging in to the database using the account created&#13;&#10;"/></div><h6>Fig<a id="_idTextAnchor094"/>ure 3.4: Logging in to the database using the account created</h6></li>
				<li><em class="italics">Right-click</em> on <strong class="bold">Databases</strong>, and create a database from there:<div><img src="img/C15309_03_05.jpg" alt="Figure 3.5: Creating the database&#13;&#10;"/></div><h6>Fig<a id="_idTextAnchor095"/>ure 3.5: Creating the database</h6></li>
				<li>Name the database <code>smilecook</code>, and set the role that we have just created to <strong class="bold">Owner</strong>. Click <strong class="bold">Save</strong>:<div><img src="img/C15309_03_06.jpg" alt="Figure 3.6: Naming the database and setting the role&#13;&#10;"/></div></li>
			</ol>
			<h6>Figur<a id="_idTextAnchor096"/>e 3.6: Naming the database and setting the role</h6>
			<p>Now we have created the Smilecook database, but it is empty at the moment. In the next exercise, we will use Flask-SQLAlchemy and Flask-Migrate to create our database tables. You will notice that there is no SQL query involved.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor097"/>Defining Our Models</h2>
			<p>Before we go into the implementation, we need to first define and understand the fields that we will be working with. We will cover two essential models: <strong class="bold">User</strong> and <strong class="bold">Recipe</strong>. Models are like schemas in the database. A model is a class and can be instantiated. It contains attributes that correspond to fields in database schemas.</p>
			<p><strong class="bold">The user model</strong></p>
			<p>The user model will be mapped to the user table in the database. The fields and methods we defined for our user model are as follows:</p>
			<ul>
				<li><code>id</code>: The identity of a user.</li>
				<li><code>username</code>: The username of the user. The maximum length allowed is 80 characters. It can't be null and is a unique field.</li>
				<li><code>email</code>: The user's email. The maximum length allowed is 200. It can't be blank and is a unique field.</li>
				<li><code>password</code>: The user's password. The maximum length allowed is 200.</li>
				<li><code>is_active</code>: This is to indicate whether the account is activated by email. It is a Boolean field with a default value of <code>False</code>.</li>
				<li><code>recipes</code>: This doesn't create a field in the database table. This is just to define the relationship with the recipe model. So, subsequently, we can get all recipes using <code>user.recipes</code>.</li>
				<li><code>created_at</code>: The creation time of the user.</li>
				<li><code>updated_at</code>: The last update time of the user.</li>
			</ul>
			<p>We are also going to define three methods in the user model:</p>
			<ul>
				<li><code>get_by_username</code>: This method is used for searching the user by username.</li>
				<li><code>get_by_email</code>: This method is used for searching the user by email.</li>
				<li><code>save</code>: This is to persist the data to the database.</li>
			</ul>
			<p><strong class="bold">The recipe model</strong></p>
			<p>The recipe model will be mapped to the user table in the database. The fields we defined for our recipe model are as follows:</p>
			<ul>
				<li><code>id</code>: The identity of a recipe.</li>
				<li><code>name</code>: The name of the recipe. The maximum length allowed is 100 characters. It can't be null.</li>
				<li><code>description</code>: The description of the recipe. The maximum length allowed is 200. </li>
				<li><code>num_of_servings</code>: The number of servings. This needs to be an integer.</li>
				<li><code>cook_time</code>: The cooking time in minutes. This field only accepts an integer. </li>
				<li><code>directions</code>: The directions of the recipe. This can have a maximum length of 1,000.</li>
				<li><code>is_publish</code>: This is to indicate whether the recipe has been published. It is set to <code>False</code> by default.</li>
				<li><code>created_at</code>: The creation time of the recipe.</li>
				<li><code>updated_at</code>: The last update time of the recipe.</li>
			</ul>
			<p>With the model designs in our mind, we are now ready to use these models in our next exercise. Before that, let's also just briefly understand some of the key packages that we will be using. These are as follows:</p>
			<ul>
				<li>Flask-SQLAlchemy: This is a very popular ORM package that allows us to access objects rather than database tables for data. With ORM, we do not need to rely on SQL anymore.</li>
				<li>Flask-Migrate: This is a package for database migration; it works on top of Alembic.</li>
				<li>Psycopg2-binary: This is the adapter for the Postgres database.</li>
				<li>Passlib: This is a password hashing library for Python.</li>
			</ul>
			<h3 id="_idParaDest-72"><a id="_idTextAnchor098"/>Exercise 19: Installing Packages and Defining Models </h3>
			<p>This exercise is designed to install the necessary packages and define the user and recipe models. The u<a id="_idTextAnchor099"/>ser and recipe models are going to be Python classes; there will not be any SQL coding in this exercise. We want to show you how we can interact with the database by simply coding in Python: </p>
			<ol>
				<li value="1">We will add the required packages in the <code>requirements.txt</code> file. If you remember, by putting the package name and version in <code>requirements.txt</code>, we can install them in the Python virtual environment by using a single <code>pip</code> command:<pre>Flask-SQLAlchemy==2.4.0
Flask-Migrate==2.5.2
psycopg2-binary==2.8.3
passlib==1.7.1</pre></li>
				<li>We ca<a id="_idTextAnchor100"/>n run the following <code>pip install</code> command to install the necessary packages:<pre>pip install -r requirements.txt</pre><p>The installation result will be shown onscreen:</p><pre>Installing collected packages: SQLAlchemy, Flask-SQLAlchemy, alembic, Flask-Migrate, psycopg2-binary, passlib
  Running setup.py install for SQLAlchemy ... done
  Running setup.py install for alembic ... done
Successfully installed Flask-Migrate-2.5.2 Flask-SQLAlchemy-2.4.0 SQLAlchemy-1.3.6 alembic-1.0.11 passlib-1.7.1 psycopg2-binary-2.8.3</pre></li>
				<li>Create<a id="_idTextAnchor101"/> a <code>Config.py</code> file and type in the following code:<pre>class Config:
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = 'postgresql+psycopg2://{your_name}:{your_password}@localhost/{db_name}
    SQLALCHEMY_TRACK_MODIFICATIONS = False</pre><p>We can<a id="_idTextAnchor102"/> set <code>DEBUG = True</code> here for debugging purposes. As regards <code>SQLALCHEMY_DATABASE_URI</code>, this is the path of the database. Please replace the username and password with the one we created for the <code>pgAdmin</code>. Also, replace the database name as well.</p></li>
				<li>Now, create <code>extensions.py</code> under the Smilecook project and type in the following code:<pre>from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()</pre></li>
				<li>Create<a id="_idTextAnchor103"/> <code>user.py</code> under the folder models and type in the following code:<pre>from extensions import db
class User(db.Model):
    __tablename__ = 'user'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), nullable=False, unique=True)
    email = db.Column(db.String(200), nullable=False, unique=True)
    password = db.Column(db.String(200))
    is_active = db.Column(db.Boolean(), default=False)
    created_at = db.Column(db.DateTime(), nullable=False, server_default=db.func.now())
    updated_at = db.Column(db.DateTime(), nullable=False, server_default=db.func.now(), onupdate=db.func.now())
    recipes = db.relationship('Recipe', backref='user')
    @classmethod
    def get_by_username(cls, username):
        return cls.query.filter_by(username=username).first()
    @classmethod
    def get_by_email(cls, email):
        return cls.query.filter_by(email=email).first()
    
    def save(self):
        db.session.add(self)
        db.session.commit()</pre></li>
				<li>Repla<a id="_idTextAnchor104"/><a id="_idTextAnchor105"/><a id="_idTextAnchor106"/>c<a id="_idTextAnchor107"/>e  <code>recipe.py</code> with the following code. We are adding the import <code>db</code> statement here and have also modified the <code>Recipe</code> class. The code related to <code>recipe_list</code> is still valid here, so we are retaining that part of the code: <pre>from extensions import db
recipe_list = []
def get_last_id():
    if recipe_list:
        last_recipe = recipe_list[-1]
    else:
        return 1
    return last_recipe.id + 1
class Recipe(db.Model):
    __tablename__ = 'recipe'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.String(200))
    num_of_servings = db.Column(db.Integer)
    cook_time = db.Column(db.Integer)
    directions = db.Column(db.String(1000))
    is_publish = db.Column(db.Boolean(), default=False)
    created_at = db.Column(db.DateTime(), nullable=False, server_default=db.func.now())
    updated_at = db.Column(db.DateTime(), nullable=False, server_default=db.func.now(), onupdate=db.func.now())
    user_id = db.Column(db.Integer(), db.ForeignKey("user.id"))</pre></li>
				<li>Now, <a id="_idTextAnchor108"/>r<a id="_idTextAnchor109"/>ewrite <code>app.py</code> with the following code. We are structuring our code in a more proper way, making it more readable and maintainable. First, import the required packages at the beginning of the code file. <h4>Note</h4><pre>from flask import Flask
from flask_migrate import Migrate
from flask_restful import Api
from config import Config
from extensions import db
from models.user import User
from resources.recipe import RecipeListResource, RecipeResource, RecipePublishResource</pre></li>
				<li>Use the <code>create_app()</code> function to create the Flask app. This will invoke <code>register_extensions(app)</code> to initialize SQLAlchemy and set up Flask-Migrate. It will then invoke <code>register_resources(app)</code> to set up resource routing:<pre>def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)
    register_extensions(app)
    register_resources(app)
    return app
def register_extensions(app):
    db.init_app(app)
    migrate = Migrate(app, db)
def register_resources(app):
    api = Api(app)
    api.add_resource(RecipeListResource, '/recipes')
    api.add_resource(RecipeResource, '/recipes/&lt;int:recipe_id&gt;')
    api.add_resource(RecipePublishResource, '/recipes/&lt;int:recipe_id&gt;/publish')</pre></li>
				<li>Finally, use <code>app = create_app()</code> to create the Flask app, and use <code>app.run()</code> to start the application:<pre>if __name__ == '__main__':
    app = create_app()
    app.run()</pre></li>
				<li>Save <code>app.py</code> and <em class="italics">right-click</em> on it to run the application. Flask will then be started up and run on the localhost (<strong class="bold">127.0.0.1</strong>) on port 5000:</li>
			</ol>
			<div><div><img src="img/C15309_03_07.jpg" alt="Figure 3.7: Flask started on localhost&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 3.7: Flask started on localhost</h6>
			<p>We have<a id="_idTextAnchor110"/> successfully installed the necessary ORM-related packages, and defined the user and recipe models. Having first installed the packages, we ran the installation in our virtual environment. We created <code>config.py</code>, <code>extensions.py</code>, and <code>user.py</code> files and replaced <code>app.py</code>. Finally, we restructured our Flask app and saw how well it runs.</p>
			<h3 id="_idParaDest-73"><a id="_idTextAnchor111"/>Exercise 20: Using Flask-Migrate to Build a Database Upgrade Script</h3>
			<p>Having successfully understood how to work with our two main models, user and recipe, we have now built the perfect foundation. The next step is execution. We will use Flask-Migrate to build a script to create the user and recipe tables:</p>
			<ol>
				<li value="1">Use the<a id="_idTextAnchor112"/> following command in the Terminal to initialize our database. This will create a migration repository: <pre>flask db init</pre><p>You should see the following onscreen:</p><pre>Creating directory /Python-API-Development-Fundamentals/smilecook/migrations ... done
Creating directory /Python-API-Development-Fundamentals/smilecook/migrations/versions ... done
Generating /Python-API-Development-Fundamentals/smilecook/migrations/script.py.mako ... done
Generating /Python-API-Development-Fundamentals/smilecook/migrations/env.py ... done
Generating /Python-API-Development-Fundamentals/smilecook/migrations/README ... done
Generating /Python-API-Development-Fundamentals/smilecook/migrations/alembic.ini ... done
Please edit configuration/connection/logging settings in '/Python-API-Development-
Fundamentals/smilecook/migrations/alembic.ini' before proceeding.</pre><p>You should now see the following new files in PyCharm:</p><div><img src="img/C15309_03_08.jpg" alt="Figure 3.8: New folders in PyCharm&#13;&#10;"/></div><h6>Figure<a id="_idTextAnchor113"/> <a id="_idTextAnchor114"/>3.8: New folders in PyCharm</h6></li>
				<li>Now, run the <code>flask db migrate</code> command to create the database and tables. There is no need for us to use SQL here:<pre>flask db migrate</pre><p>Flask-Migrate detected two objects (<code>user</code> and <code>recipe</code>) and created two corresponding tables for them: </p><pre>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'user'
INFO  [alembic.autogenerate.compare] Detected added table 'recipe'
  Generating /Python-API-Development-Fundamentals/smilecook/migrations/versions/a6d248ab7b23_.py ... done</pre></li>
				<li>Now, please check <code>/migrations/versions/a6d248ab7b23_.py</code> under the <code>versions</code> folder. This file is created by Flask-Migrate. Note that you may get a different revision ID here. Please review the file before you run the flask <code>db</code> upgrade command. That's because, sometimes, it may not detect every change you make to your models:<pre>"""empty message
Revision ID: a6d248ab7b23
Revises: 
Create Date: 2019-07-22 16:10:41.644737
"""
from alembic import op
import sqlalchemy as sa
# revision identifiers, used by Alembic.
revision = 'a6d248ab7b23'
down_revision = None
branch_labels = None
depends_on = None
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('user',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(length=80), nullable=False),
    sa.Column('email', sa.String(length=200), nullable=False),
    sa.Column('password', sa.String(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email')
    )
    op.create_table('recipe',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.String(length=500), nullable=True),
    sa.Column('num_of_servings', sa.Integer(), nullable=True),
    sa.Column('cook_time', sa.Integer(), nullable=True),
    sa.Column('directions', sa.String(), nullable=True),
    sa.Column('is_publish', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###
def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('recipe')
    op.drop_table('user')
    # ### end Alembic commands ###</pre><p>There are two functions in this autogenerated file; one is upgraded, and this is to add the new recipe and user to the table, while the other one is downgraded, which is to go back to the previous version.</p></li>
				<li>We will <a id="_idTextAnchor115"/>then execute the <code>flask db upgrade</code> command, which will upgrade our database to conform with the latest specification in our models:<pre>flask db upgrade</pre><p>This command will invoke <code>upgrade()</code> to upgrade the database:</p><pre>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -&gt; a6d248ab7b23, empty message</pre><h4>Note</h4><p class="callout">In the future, whenever we need to upgrade the database, we can just call <code>flask db migrate</code> and <code>flask db upgrade</code>. </p></li>
				<li>Check t<a id="_idTextAnchor116"/>h<a id="_idTextAnchor117"/>e database tables in <code>pgAdmin</code>. Now, we can see whether the tables have been created in the database. Go to <strong class="bold">smilecook</strong> &gt;&gt; <strong class="bold">Schemas</strong> &gt;&gt; <strong class="bold">Tables to verify</strong>:<div><img src="img/C15309_03_09.jpg" alt="Figure 3.9: Checking the database tables&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure <a id="_idTextAnchor118"/>3.9: Checking the database tables</h6>
			<p>If you see the recipe and user tables in our <strong class="bold">Smilecook</strong> database, this means you have successfully created them in Python without any SQL. Isn't that cool?!</p>
			<p>Next, we will try our hand at database insertion. Let's look at the following exercise.</p>
			<h3 id="_idParaDest-74">Exercise <a id="_idTextAnchor119"/>21: Applying Database Insertion</h3>
			<p>This exercise is designed for us to test database insertion. We will first create a user, and then create two recipes under that user:</p>
			<ol>
				<li value="1">Import mo<a id="_idTextAnchor120"/>dules in the Python console. Open the Python console at the bottom of PyCharm and type in the following code to import the necessary classes:<pre>from app import *
from models.user import User
from models.recipe import Recipe
app = create_app()</pre></li>
				<li>Create ou<a id="_idTextAnchor121"/>r first <code>user</code> object and save that to the database by typing in the following code in the Python console:<pre>user = User(username='jack', email='jack@gmail.com', password='WkQa')
db.session.add(user)
db.session.commit()</pre></li>
				<li>Now, check the <code>user</code> details. Please note that the ID of the user has already been assigned to <code>1</code>:<pre>&gt;&gt;&gt;user.username
'jack'
&gt;&gt;&gt;user.id
1
&gt;&gt;&gt;user.email
'jack@gmail.com'</pre></li>
				<li>Since the user is persisted in the database, we will verify that there:<div><img src="img/C15309_03_10.jpg" alt="Figure 3.10: Verifying the user in the database&#13;&#10;"/></div><h6>Figure 3.10: Verifying the user in the database</h6></li>
				<li>We can see a record there in the <code>user</code> table:</li>
				<li><div><img src="img/C15309_03_11.jpg" alt="Figure 3.11: Record in the user table&#13;&#10;"/></div><h6>Figure 3.11: Record in the user table</h6></li>
				<li>Next, we wi<a id="_idTextAnchor122"/>ll create two recipes using the following code. One thing to note is that the <code>user_id</code> attribute of the recipe is set to <code>user.id</code>. This is to indicate that the recipe was created by the user <code>Jack</code>:<pre>pizza = Recipe(name='Cheese Pizza', description='This is a lovely cheese pizza recipe', num_of_servings=2, cook_time=30, directions='This is how you make it', user_id=user.id)
db.session.add(pizza)
db.session.commit()
pasta = Recipe(name='Tomato Pasta', description='This is a lovely tomato pasta recipe', num_of_servings=3, cook_time=20, directions='This is how you make it', user_id=user.id)
db.session.add(pasta)
db.session.commit()</pre></li>
				<li>We will then check whether the two recipes have been created in the database:<div><img src="img/C15309_03_12.jpg" alt="Figure 3.12: Checking whether the two recipes have been created&#13;&#10;"/></div><h6>Figure 3.12: Checking whether the two recipes have been created</h6></li>
				<li>We will search for the user with the username <code>jack</code> in the database and get all the recipes created by that user in their object attribute, <code>recipes</code>:<pre>&gt;&gt;&gt; user = User.query.filter_by(username='jack').first()
&gt;&gt;&gt; user.recipes</pre><p>We will get a list of two recipes:</p><pre>[&lt;Recipe 1&gt;, &lt;Recipe 2&gt;]</pre></li>
				<li>We can display the details of the recipes using the <code>for</code> loop. We get the recipe name using <code>recipe.name</code>, while we get the user's name using <code>recipe.user.username</code>:<pre>&gt;&gt;&gt; for recipe in user.recipes:
    print('{} recipe made by {} can serve {} people.'.format(recipe.name, recipe.user.username, recipe.num_of_servings))</pre><p>You should see the following result on the screen:</p><pre>Cheese Pizza recipe made by jack can serve 2 people.
Tomato Pasta recipe made by jack can serve 3 people.</pre></li>
			</ol>
			<p>You have jus<a id="_idTextAnchor123"/>t learned how to command your application using the Python console. You have just created the user and recipe models and saved them in the database. The entire process is SQL-free, as you can see. Let's do an activity to reinforce your knowledge.</p>
			<h3 id="_idParaDest-75"><a id="_idTextAnchor124"/>Activity 5: Creating a User and a Recipe</h3>
			<p>In this activity, we will test our APIs by running a few more test cases. We want to create a new user, <code>Peter</code>, and create two recipes under him in the database. Let's see if you know how to write the code for that in the Python interactive console:</p>
			<ol>
				<li value="1">Import the <code>User</code> and <code>Recipe</code> classes and create the Flask app using the Python console.</li>
				<li>Create a new user, <code>Peter</code>.</li>
				<li>Create two recipes and assign <code>Peter</code> as the author.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 302.</p></li>
			</ol>
			<p>If you can see that the data has successfully been created in the database, congratulations – you already know how to use Python console to interact with the database! Next, we will implement a user registration feature.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor125"/>Password Hashing</h2>
			<p>Hashing is a one-way mathematical function. It requires little computing power to convert a plaintext string to its hash value (hashes). However, it will require a huge amount of computing power to retrieve the original string from the hash value (it's almost impossible). Therefore, we call it a one-way function:</p>
			<div><div><img src="img/C15309_03_13.jpg" alt="Figure 3.13: Workings of the hash function&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 3.13: Workings of the hash function</h6>
			<p>With this property, a hash function is perfect for a hashing password. We will hash the user's password into hashes before we save it to the database so that it is unrecognizable and irreversible. And next time, when the user logs in, what the platform does is to convert the input the password to its hash value, and then compare that with the hash value stored in the database. That way, we can perform a password comparison without leaking the sensitive password information to others.</p>
			<h3 id="_idParaDest-77"><a id="_idTextAnchor126"/>Exercise 22: Implement the User Registration Feature and Hash the User's Password</h3>
			<p>In this exercise, we will work on the user registration feature. We will also implement two functions for hashing the user's password: </p>
			<ol>
				<li value="1">Create <code>utils.py</code> under the application project folder and type in the following code. The code is to hash the password. We do not want to store plaintext passwords in our database on account of security concerns. Therefore, we will use the <code>passlib</code> modules for hashing. We defined two methods here:<pre>from passlib.hash import pbkdf2_sha256
def hash_password(password):
    return pbkdf2_sha256.hash(password)
def check_password(password, hashed):
    return pbkdf2_sha256.verify(password, hashed)</pre><p>The <code>hash_pass<a id="_idTextAnchor127"/>word(password)</code> function is for password hashing and <code>check_password(password, hashed)</code> is for user authentication. It hashes the user-input password and compares that with the one we saved in the database.</p></li>
				<li>Create <code>user.py</code> in the <code>resources</code> folder, and then type in the following code. We will first import the necessary modules and implement the <code>Post</code> method in <code>UserListResource</code>:<pre>from flask import request
from flask_restful import Resource
from http import HTTPStatus
from utils import hash_password
from models.user import User
class UserListResource(Resource):
    def post(self):
        json_data = request.get_json()
        username = json_data.get('username')
        email = json_data.get('email')
        non_hash_password = json_data.get('password')</pre><p>When there is a client request hitting <code>http://localhost/users</code> with the HTTP <code>POST</code> method, the application will get the JSON formatted data in the request. There should be a username, email, and password. </p></li>
				<li>Check whether the user already exists in the database by means of <code>User.get_by_user(username)</code>. If such an entry is found, that means the user has already registered and we will simply return an error message. We will also perform the same check on <code>email</code> as well:<pre>        if User.get_by_username(username):
            return {'message': 'username already used'}, HTTPStatus.BAD_REQUEST
        if User.get_by_email(email):
            return {'message': 'email already used'}, HTTPStatus.BAD_REQUEST</pre></li>
				<li>Once all the <a id="_idTextAnchor128"/>validations are passed, go ahead and create the user in the database. The password will be hashed, and the user object will be created. The user object will then be saved to the database using <code>user.save()</code>. Finally, the user details are returned in JSON format, with an <code>HTTP</code> status code of <code>201</code>:<pre>    password = hash_password(non_hash_password)
        user = User(
            username=username,
            email=email,
            password=password
        )
        user.save()
        data = {
            'id': user.id,
            'username': user.username,
            'email': user.email
        }
        return data, HTTPStatus.CREATED</pre></li>
				<li>Add user resource routing to <code>app.py</code>:<pre>from extensions import db
from resources.user import UserListResource
from resources.recipe import RecipeListResource, RecipeResource, RecipePublishResource
def register_resources(app):
    api = Api(app)
    api.add_resource(UserListResource, '/users')
    api.add_resource(RecipeListResource, '/recipes')</pre><p>Replace <code>from models.user import User</code> in <code>app.py</code> with <code>from resources.user import UserListResource</code>. The user model is already imported in <code>resources.user</code>, so there is no need to reimport that again. Please add <code>api.add_resource(UserListResource, '/users')</code> to the code as well.</p><p>Run the application. Flask will then be started up and run on localhost (<code>127.0.0.1</code>) on port <code>5000</code>: </p><div><img src="img/C15309_03_07.jpg" alt="Figure 3.14: Flask started on localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 3.14: Flask started on localhost</h6>
			<p>So, we have just finished the password hashing exercise. From now on, whenever there is a new user registered in our Smilecook application, their password will be hashed and stored safely in the database. Let's test and see whether that is the case in our next exercise. </p>
			<h4>Note</h4>
			<p class="callout">The reason why<a id="_idTextAnchor129"/> we are not discussing the recipe resource here is that there will be an author ID in the recipe. The author ID will be a foreign key that links to the user model. We will talk about the user login function in our next chapter. Only after that can we get the user ID and finish the recipe resource.</p>
			<h3 id="_idParaDest-78"><a id="_idTextAnchor130"/>Exercise 23: Testing the Application in Postman</h3>
			<p>In this exercise, we are going to test the application in Postman. We will first register a user account and make sure the user data is stored in the database. We also need to verify that the password is hashed. Having created a user, now let's test our API endpoint here:</p>
			<ol>
				<li value="1">Click on the <strong class="bold">Collections</strong> tab in Postman.</li>
				<li>Create a new collection, and name it <code>User</code>.</li>
				<li>Create a new <a id="_idTextAnchor131"/>request, <code>UserList</code>, under that collection. You can do this by clicking on the <code>User</code> collection. </li>
				<li>Edit the <code>POST</code>.</li>
				<li>Type in <code>http://localhost:5000/users</code> in the URL field.</li>
				<li>Go to the <strong class="bold">Body</strong> Tab, select <strong class="bold">raw</strong> as the datatype, and then select <strong class="bold">JSON (application/json)</strong> as the data format.</li>
				<li>Insert the following user details and then save.:<pre>{
    "username": "jack",
    "email": "jack@gmail.com",
    "password": "WkQa"
}</pre></li>
				<li>Click <strong class="bold">Send</strong>. The result can be seen in the following screenshot:<div><img src="img/C15309_03_15.jpg" alt="Figure 3.15: Creating a user with an existing username&#13;&#10;"/></div><h6>Figure 3.15: Creating a user with an existing username</h6><p>You will then see the following data returned; the HTTP status is <strong class="bold">400 BAD REQUEST</strong>. We can also see the error message in the <strong class="bold">Body</strong> field showing that the username has been registered.</p></li>
				<li>Create another <a id="_idTextAnchor132"/>user with the details shown in the following code:<pre>{
    "username": "ray",
    "email": "ray@gmail.com",
    "password": "WkQa"
}</pre><p>The result can be seen in the following screenshot:</p><div><img src="img/C15309_03_16.jpg" alt="Figure 3.16: Creating another user&#13;&#10;"/></div><h6>Figure 3.16: Creating another user</h6><p>Now, the second account has been successfully created.</p></li>
				<li>Check the data i<a id="_idTextAnchor133"/>n the database as follows:<div><img src="img/C15309_03_17.jpg" alt="Figure 3.17: Checking the data in the database&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 3.17: Checking the data in the database</h6>
			<p>Now, we can see a new user record created in the database table. And you can see that the password is hashed.</p>
			<p>By doing this testing exercise, we can be assured that our user registration workflow is functioning well. And, most importantly, user passwords are kept as the hash value in the database. That is a much safer way to store a password, as even the database administrator can't see it.</p>
			<h3 id="_idParaDest-79"><a id="_idTextAnchor134"/>Activity 6: Upgrading and Downgrading a Database</h3>
			<ol>
				<li value="1">In this activity, we will upgrade and downgrade our database to simulate a scenario where we need to add an attribute under the <code>user</code> class, but later we change our mind and need to remove it. The following are the high-level steps that we need to perform in order to complete this activity:</li>
				<li>Add a new attribute to the <code>user</code> class. This attribute should be called <code>bio</code> and will be a string that represents information about the user.</li>
				<li>Run the <code>flask db migrate</code> command to create the database and tables.</li>
				<li>Now, check <code>/migrations/versions/6971bd62ec60_.py</code> under the <code>versions</code> folder. This file is created by Flask-Migrate.</li>
				<li>Execute the <code>flask db upgrade</code> command to upgrade our database to conform with the latest specification in our models.</li>
				<li>Check whether the new field is created in the database. </li>
				<li>Run the <code>downgrade</code> command to remove the new field.</li>
				<li>Check whether the field has been removed.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 303.</p></li>
			</ol>
			<p>If you see that the new field has been removed, that means you have successfully downgraded the database in Python without writing any SQL. And don't forget to delete the user model's bio attribute in models/user.py, also delete the script that we created which is <code>a6d248ab7b23.py</code> in migrations/versions folder. You have just learned a very useful skill that you will probably need frequently in the future. One tip for you is that you should back up your database prior to any database schema update. This is to ensure the data won't get lost.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor135"/>Summary</h2>
			<p>In this chapter, we built the Postgres database locally and learned how to use the pgAdmin tool to manage it. Then, through the SQLAlchemy module, we developed an object library to manipulate the database. This is much easier than using SQL syntax directly. And, as long as we define the relationship between models, we can easily get the information we want. This results in higher code readability, fewer lines of code, and the elimination of repetitive SQL. We then use Flask-Migrate to build all the data tables. Then, when we migrate the database in the future, we simply need two commands – <code>flask db migrate</code> and <code>flask db upgrade</code>; it's simple and easy. Although Flask-Migrate can help us to set up and migrate a database more easily, in a production environment, performing this kind of migration still requires extra due diligence. We should always back up the database to safeguard our precious data.</p>
			<p>During development, we should frequently test our code to make sure it is behaving as expected. We shouldn't wait till the end to perform big-bang testing. We can unit test our functions and API endpoints, once they are complete. Using the Python console to perform this kind of simple test is recommended. Iteratively testing our application can also foster the best programming practice. This forces us to think about how we can structure our code in an elegant manner and avoid technical debt accumulation.</p>
			<p>Finally, we created an API for user registration. In the next chapter, we will work on user login and recipe creation for authenticated users.</p>
		</div>
	</body></html>