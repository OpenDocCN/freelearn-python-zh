<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Tasklist I: Persistence</h1></div></div></div><div><blockquote class="blockquote"><p>In the previous chapter, we learned how to deliver content to the user. This content consisted of HTML markup to structure the information together with a number of JavaScript libraries and code to create a user interface.</p></blockquote></div><div><blockquote class="blockquote"><p>We noted that this was not a full-fledged web application yet; it lacked the functionality to store information on the server and there was no way to identify different users or any way to authenticate them. In this chapter, we will address both these issues when we design a simple tasklist application.</p></blockquote></div><div><blockquote class="blockquote"><p>This tasklist application will be able to serve multiple users and store the list of tasks for each user on the server.</p></blockquote></div><p>Specifically, we will look at:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to design a tasklist application</li><li class="listitem" style="list-style-type: disc">How to implement a logon screen</li><li class="listitem" style="list-style-type: disc">What a session is and how this allows us to work with different users at the same time</li><li class="listitem" style="list-style-type: disc">How to interact with the server and add or delete tasks</li><li class="listitem" style="list-style-type: disc">How to make entering dates attractive and simple with jQuery UI's datapicker widget</li><li class="listitem" style="list-style-type: disc">How to style button elements and provide tooltips and inline labels to input elements</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec01"/>Designing a tasklist application</h1></div></div></div><p>Designing an application should start with a clear idea of what is expected. Not only to determine what is technically required, but almost as important, to define clear boundaries so that we don't lose time on things that are just nice to have. Nice to have features are something to be added if there is time left in the project.<a id="id115" class="indexterm"/>
</p><p>So let's draw up a shortlist of the relevant features of our tasklist application. Some of these may seem obvious, but as we will see, these have a direct impact on some implementation choices that we have to make, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The application will be used by multiple users<a id="id117" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Task lists should be stored indefinitely</li><li class="listitem" style="list-style-type: disc">A task list may contain an unlimited number of tasks but the user interface is designed for optimal performance for up to 25 tasks or so</li><li class="listitem" style="list-style-type: disc">Tasks may be added, deleted, and marked as done</li></ul></div><p>Although this list isn't exhaustive, it has some important implications.</p><p>The fact that the tasklist application will be used by more than one user means that we have to identify and authorize people who want to use it. In other words, we will need some sort of logon screen and a way to check people against some sort of password database. Because we do not want to burden the user with identifying himself/herself each and every time a task list is refreshed or altered, we need some way of implementing the concept of a<strong> session</strong>.<a id="id118" class="indexterm"/>
</p><p>Web applications use the stateless HTTP protocol. This means, from the server's point of view, every request is a single, unrelated event, and no information is retained at the server. This obviously presents us with a problem if we want to perform a set of related actions. The solution is to ask the web browser to send a small piece of information along with every request it makes to the application after the application has identified the user.<a id="id119" class="indexterm"/>
</p><p>This might be accomplished in a number of ways. The server may add an extra parameter to all links inside any web page it generates, commonly referred to as a<strong> session id</strong>, or use the even more general concept of a<strong> cookie</strong>.<a id="id120" class="indexterm"/>
</p><p>Once the server asks the web browser to store a cookie, this cookie is sent with every following request to the same website. The advantage of cookies is that common web application frameworks (like CherryPy) are already equipped to deal with them and implementing sessions with cookies is much simpler than designing the application to alter all hyperlinks it generates to include a proper session ID. The disadvantage might be that people may block their browser from storing cookies because some websites use them to track their clicking behavior.<a id="id121" class="indexterm"/>
</p><p>We let the simplicity of implementation prevail and opt for cookies. If users want to block cookies this is not much of a problem as most browsers also have the option to selectively allow cookies from designated websites.</p><p>The following image illustrates the way CherryPy manages sessions with the help of cookies:<a id="id122" class="indexterm"/>
</p><div><img src="img/3746OS_03_01.jpg" width="346" alt="Designing a tasklist application"/></div><p>It starts when the client (the web browser) sends a request to CherryPy. Upon receiving the request, the first check is to see if the web browser has sent along a cookie with a session ID. If it didn't, a new session idea is generated. Also, if there was a cookie with a session ID, if this ID is no longer valid (because it has expired, for example, or is a remnant from a very old interaction and doesn't exist in the current cache of session IDs) CherryPy also generates a new session ID.<a id="id123" class="indexterm"/>
</p><p>At this point, no persistent information is stored if this is a new session, but if it's an existing session there might be persistent data available. If there is, CherryPy creates a<code class="literal"> Session</code> object and initializes it with the available persistent data. If not, it creates an empty<code class="literal"> Session</code> object. This object is available as a global variable<code class="literal"> cherrypy.session</code>.<a id="id124" class="indexterm"/>
</p><p>The next step for CherryPy is to pass control to the function that will handle the request. This handler has access to the<code class="literal"> Session</code> object and may change it, for example, by storing additional information for later reuse. (Note that the<code class="literal"> Session</code> object acts like a dictionary so you can simply associate values with keys with<code class="literal"> cherrypy.session['key']=value</code>. The only restriction to the keys and values is that they must be serializable if the persistent storage is on disk).<a id="id125" class="indexterm"/>
</p><p>Then before returning the results generated by the handler, CherryPy checks if the<code class="literal"> Session</code> object has changed. If (and only if) it has, are the contents of the<code class="literal"> Session</code> object saved to a more permanent storage.<a id="id126" class="indexterm"/>
</p><p>Finally, the response is returned accompanied by a cookie with the session ID.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec02"/>Time for action creating a logon screen</h1></div></div></div><p>Our first task is to create a small application that does little more than present the user with a logon screen. It will be the starting point of our tasklist application and many others as well.<a id="id127" class="indexterm"/>
</p><p>The code for this example as well as most other examples in this book is available from the Packt website. If you have not downloaded it yet, this might be a good time to do so.</p><p>Enter the following pieces of code and save it in a file called<code class="literal"> logonapp.py</code> in the same directory as the other files distributed with this chapter (<a class="link" href="ch03.html" title="Chapter 3. Tasklist I: Persistence">Chapter 3</a> in the sample code):<a id="id128" class="indexterm"/>
</p><p>
<strong>Chapter3/logonapp.py</strong>
</p><div><pre class="programlisting">
import cherrypy
import logon
class Root(object):
logon = logon.Logon(path="/logon",
					authenticated="/",
					not_authenticated="/goaway")
@cherrypy.expose
def index(self):
		username=logon.checkauth('/logon')
		return '''
	&lt;html&gt;&lt;body&gt;
	&lt;p&gt;Hello user &lt;b&gt;%s&lt;/b&gt;&lt;/p&gt;
	&lt;/body&gt;&lt;/html&gt;'''%username
@cherrypy.expose
def goaway(self):
		return '''
	&lt;html&gt;
	&lt;body&gt;&lt;h1&gt;Not authenticated, please go away.&lt;/h1&gt;
	&lt;/body&gt;&lt;/html&gt;'''
@cherrypy.expose<strong>
def somepage(self):</strong>
		username=logon.checkauth('/logon',returntopage=True)
		return '''&lt;html&gt; 
				  &lt;body&gt;&lt;h1&gt;This is some page.&lt;/h1&gt; 
				  &lt;/body&gt; 
				  &lt;/html&gt;'''
if __name__ == "__main__":
	import os.path
	current_dir = os.path.dirname(os.path.abspath(__file__))
	cherrypy.quickstart(Root(),config={
			'/': {'tools.sessions.on': True }
			}
			)
</pre></div><p>If you now run<code class="literal"> logonapp.py</code>, a very simple application is available on port 8080. It presents the user with a logon screen when the top level page<code class="literal"> http://localhost:8080/</code> is accessed. An example is shown in the following illustration:<a id="id129" class="indexterm"/>
</p><div><img src="img/3746_3_003.jpg" width="139" alt="Time for action creating a logon screen"/></div><p>If a correct username/password combination is entered, a welcome message is shown. If an unknown username or wrong password is entered, the user is redirected to<code class="literal"> http://localhost:8080/goaway</code>.<a id="id130" class="indexterm"/>
</p><p>The<code class="literal"> somepage()</code> method (highlighted) returns a page with (presumably) some useful content. If the user is not yet authenticated, the logon screen is shown and upon entering the correct credentials, the user is directed back to<code class="literal"> http://localhost:8080/somepage</code>.</p><p>The complete tree of web pages within the logon sample application and the possible paths the user may pick through is shown next:</p><div><img src="img/3746OS_03_02.jpg" width="256" alt="Time for action creating a logon screen"/></div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Logon + session ID vs. HTTP basic authentication</p></div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>You may wonder why we choose not to reuse CherryPy's bundled<code class="literal"> auth_basic</code> tool that offers basic authentication (for more information on this tool, see<a class="ulink" href="http://www.cherrypy.org/wiki/BuiltinTools#tools.auth_basic)"> http://www.cherrypy.org/wiki/BuiltinTools#tools.auth_basic)</a>. If all we wanted was to check whether a user is allowed access to a single page, this would be a good choice. The basic authentication is sufficient to authenticate a user, but has no concept of a session. This means we lack a way to store data that needs to be accessible when we process subsequent requests by the same user. The<code class="literal"> sessions</code> tool we use here does provide this additional functionality.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec01"/>What just happened?</h2></div></div></div><p>Part of the magic of<code class="literal"> logonapp.py</code> is achieved by enabling the 'sessions' tool in CherryPy. This is what is done by passing the<code class="literal"> tools.sessions.on</code> key with<code class="literal"> True</code> as a value to the configuration dictionary for the<code class="literal"> quickstart()</code> function.</p><p>However, most of the hard work in<code class="literal"> logonapp.py</code> is actually performed by the module<code class="literal"> logon:</code>
</p><p>
<strong>Chapter3/logon.py</strong>
</p><div><pre class="programlisting">
import cherrypy
import urllib.parse<strong>
def checkauth(logonurl="/", returntopage=False):</strong>
	returnpage=''
if returntopage:
	returnpage='?returnpage='
			+ cherrypy.request.script_name
			+ cherrypy.request.path_info
auth = cherrypy.session.get('authenticated',None)
if auth == None :
	raise cherrypy.HTTPRedirect(logonurl+returnpage)
return auth<strong>
class Logon:</strong>
	base_page = '''
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script type="text/javascript" src="img/jquery.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="img/jquery-ui.js" &gt;&lt;/script&gt;
&lt;style type="text/css" title="currentStyle"&gt;
	@import "/jquerytheme.css";
	@import "/static/css/logon.css";
&lt;/style&gt;
&lt;/head&gt;
&lt;body id="logonscreen"&gt;
&lt;div id="content"&gt;
%s
&lt;/div&gt;
&lt;script type="text/javascript"&gt;$("button").button({icons: {primary: 'ui-icon-power'}})&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
	logon_screen = base_page % '''
&lt;form class="login" action="%s/logon" method="GET"&gt;
&lt;fieldset&gt;
&lt;label for="username"&gt;Username&lt;/label&gt;
&lt;input id="username" type="text" name="username" /&gt;
&lt;script type="text/javascript"&gt;$("#username").focus()&lt;/script&gt;
&lt;label for="password"&gt;Password&lt;/label&gt;
&lt;input id="password" type="password" name="password" /&gt;
&lt;input type="hidden" name="returnpage" value="%s" /&gt;
&lt;button type="submit" class="login-button" value="Log in"&gt;
Log in
&lt;/button&gt;
&lt;/fieldset&gt;
&lt;/form&gt;
'''
	not_authenticated =
		base_page % '''&lt;h1&gt;Login or password not correct&lt;/h1&gt;'''<strong>
def __init__(self, path="/logon",
					authenticated="/", not_authenticated="/"):</strong>
	self.path=path
	self.authenticated=authenticated
	self.not_authenticated=not_authenticated
@staticmethod<strong>
def checkpass(username,password):</strong>
	if username=='user' and password=='secret': return True
	return False
@cherrypy.expose<strong>
def index(self,returnpage=''):
</strong>
	return Logon.logon_screen % (
				self.path,urllib.parse.quote(returnpage))
@cherrypy.expose<strong>
def logon(self,username,password,returnpage=''):</strong>
	returnpage = urllib.parse.unquote(returnpage)
	if Logon.checkpass(username,password):
		cherrypy.session['authenticated']=username
		if returnpage != '':
			raise cherrypy.InternalRedirect(returnpage)
		else:
			raise cherrypy.InternalRedirect(
								self.authenticated)
	raise cherrypy.InternalRedirect(self.not_authenticated)
@cherrypy.expose<strong>
def logoff(self,logoff):</strong>
	cherrypy.lib.sessions.expire()
	cherrypy.session['authenticated']=None
	raise cherrypy.InternalRedirect(self.not_authenticated)
</pre></div><p>The logon module implements a utility function<code class="literal"> checkauth()</code> (highlighted). This function is designed to be called from anywhere inside a CherryPy application. If the user is already authenticated, it will return the username; otherwise it will redirect the user to a URL that should present the user with a logon screen. If the<code class="literal"> returnpage</code> parameter is true, this URL is augmented with an extra parameter<code class="literal"> returnpage</code> containing the URL of the page that invoked<code class="literal"> checkauth()</code>. The logon page (or rather the handler implementing it) should be designed to redirect the user to the URL in this parameter if the authentication is successful.</p><p>As we have seen, typical use for the<code class="literal"> checkauth()</code> function would be to call it from every page handler that serves content that requires authentication.</p><p>
<code class="literal">checkauth()</code> itself does just two things: First it determines the page to return to (if necessary) by concatenating the<code class="literal"> script_name</code> and<code class="literal"> path_info</code> attributes from the<code class="literal"> cherrypy.request</code> object that CherryPy makes available. The first one contains the path where a CherryPy tree is mounted, the last one contains the path within that tree. Together they form the complete path to the handler that invoked this<code class="literal"> checkauth()</code> function.<a id="id133" class="indexterm"/>
</p><p>The second thing that<code class="literal"> checkauth()</code> does is it determines whether<code class="literal"> cherrypy.session</code> (a dictionary like Session object) contains an<code class="literal"> authenticated</code> key. If it does, it returns the associated value, if not, it redirects to the logon page.</p><p>The<code class="literal"> cherrypy.session</code> variable is a<code class="literal"> cherrypy.lib.sessions.Session</code> object available to each request. It acts like a dictionary and initially it is devoid of any keys. When a value is assigned to the first new key, a persistent object is created that is associated with the session ID and upon finishing a request, the<code class="literal"> Session</code> object is stored and its session ID is passed as the value of a<code class="literal"> session_id</code> cookie in the response headers. If a subsequent request contains a request header with a<code class="literal"> session_id</code> cookie, a<code class="literal"> Session</code> object with the corresponding session ID is retrieved from storage, making any saved key/value pairs available again.</p><p>The default storage scheme is to keep data in memory. This is fast and simple but has the disadvantage that restarting the CherryPy server will discard this data, effectively expiring all sessions. This might be ok for short-lived sessions, but if you need a more persistent solution, it is possible to store the session information as files (by setting the<code class="literal"> tools.sessions.storage_type</code> configuration key to<code class="literal"> "file")</code> or even to a database backend. For more about sessions, see CherryPy's online documentation on the subject at<a class="ulink" href="http://cherrypy.org/wiki/CherryPySessions"> http://cherrypy.org/wiki/CherryPySessions</a>.</p><p>The various steps in the communication between the client and the server during a session are shown in the following illustration:</p><div><img src="img/3746OS_03_04.jpg" width="196" alt="What just happened?"/></div><p>The bulk of the<code class="literal"> logon</code> module is provided by the<code class="literal"> Logon</code> class. It implements several methods (these methods are highlighted in the code listed on the previous pages as well):<a id="id134" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">__init__()</code> will initialize a<code class="literal"> Logon</code> instance to hold the path to the point where this<code class="literal"> Logon</code> instance is mounted on the tree of handlers, together with the default URLs to redirect to successful and unsuccessful authentication.</li><li class="listitem" style="list-style-type: disc"><code class="literal">checkpass()</code> is a static function that takes a username and a password and returns<code class="literal"> True</code> if these are a matching pair. It is designed to be overridden by a more suitable definition.</li></ul></div><p>
<code class="literal">Logon</code> also exposes three handler methods to the CherryPy engine:<a id="id135" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">index()</code> is a method that will serve the actual logon screen</li><li class="listitem" style="list-style-type: disc"><code class="literal">logon()</code> is passed the username and password when the user clicks on the logon button</li><li class="listitem" style="list-style-type: disc"><code class="literal">logoff()</code> will expire a session, causing subsequent calls to<code class="literal"> checkauth()</code> to redirect the user to the logon screen</li></ul></div><p>The<code class="literal"> Logon</code> class also contains a number of class variables to hold the HTML presented by the<code class="literal"> index()</code> method. Let's look at the methods in detail.<a id="id136" class="indexterm"/>
</p><div><h3 class="title"><a id="note07"/>Note</h3><p>And what about security? The<code class="literal"> Logon</code> class we design here has no facilities to prevent people from eavesdropping if they have access to the wire that transports the HTTP traffic. This is because we transmit the passwords unencrypted. We may implement some sort of encryption scheme ourselves, but if your design requires some form of protection, it is probably better and easier to communicate over a secure HTTPS channel. CherryPy may be configured to use HTTPS instead of HTTP. More on it can be found at:<a class="ulink" href="http://cherrypy.org/wiki/ServerObject"> http://cherrypy.org/wiki/ServerObject</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec02"/>Pop quiz session IDs</h2></div></div></div><div><ol class="orderedlist"><li class="listitem">If the client sends a new session ID again and again, wouldn't that fill up all storage on the server eventually?</li><li class="listitem">If the client has cookies disabled, what happens to the generation of session IDs?<p>a. The server will stop generating new session IDs, returning the same ID repeatedly</p><p>b. The server will stop returning new session IDs</p><p>c. The server will keep generating and returning new session IDs</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec03"/>Serving a logon screen</h2></div></div></div><p>The<code class="literal"> index()</code> method serves the HTML to present the user with a logon screen. At its core, this HTML is a<code class="literal">&lt;form&gt;</code> element with three<code class="literal">&lt;input&gt;</code> elements: a regular text input where the user may enter his/her username, a password input (that will hide the characters that are entered in this field), and an<code class="literal">&lt;input&gt;</code> element that has a<code class="literal"> hidden</code> attribute. The<code class="literal">&lt;form&gt;</code> element has an<code class="literal"> action</code> attribute that holds the URL of the script that will process the variables in the form when the user clicks the logon button. This URL is constructed to point to the<code class="literal"> logon()</code> method of our<code class="literal"> Logon</code> class by appending<code class="literal"> /logon</code> to the path that the<code class="literal"> Logon</code> instance was mounted on in the CherryPy tree.<a id="id137" class="indexterm"/>
</p><p>The<code class="literal">&lt;input&gt;</code> element we marked as hidden is initialized to hold the URL that the user will be redirected to when<code class="literal"> logon()</code> authenticates the user successfully.</p><p>The form that makes up the logon screen also contains a tiny piece of JavaScript:</p><div><pre class="programlisting">
$("#username").focus()
</pre></div><p>It uses jQuery to select the input element that will receive the username and gives it focus. By placing the cursor in this field, we save the user the effort of pointing and clicking on the username field first before the username can be entered. Now he can start typing right away. Note that this code snippet is not placed near the end of the document, but right after the<code class="literal">&lt;input&gt;</code> element to ensure execution as soon as the<code class="literal">&lt;input&gt;</code> element is defined. The logon page is so small that this might be irrelevant, but on slow loading pages, key presses might be misdirected if we waited to shift the focus until the whole page had loaded.<a id="id138" class="indexterm"/>
</p><div><h3 class="title"><a id="note08"/>Note</h3><p>Be aware that the logon form we construct here has a<code class="literal">&lt;form&gt;</code> element with an<code class="literal"> action="GET</code>" attribute. This works fine, but has a disadvantage: parameters passed with a<code class="literal"> GET</code> method are appended to the URL and may end up in the log files of the server. This is convenient when debugging, but you might not want that for a production environment, as this might leave passwords exposed. The<code class="literal"> action</code> attribute can be changed to<code class="literal"> POST</code> though without any change to the Python code handling the request as CherryPy takes care of the details. Parameters passed to a<code class="literal"> POST</code> method are not logged, so a<code class="literal"> POST</code> method might be better suited to a password verification request.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec04"/>Setting up a session</h2></div></div></div><p>The<code class="literal"> logon()</code> method is passed the contents of all the<code class="literal">&lt;input&gt;</code> elements in the form as parameters. The<code class="literal"> username</code> and<code class="literal"> password</code> parameters are passed to the<code class="literal"> checkpass()</code> method and if the user's credentials are right, we establish a session by associating the username with the authenticated key in our session storage with<code class="literal"> cherrypy.session['authenticated']=username</code>.<a id="id139" class="indexterm"/>
</p><p>This will have the effect that every response sent to the browser will contain a cookie with a session ID and any subsequent request to CherryPy that contains this cookie again will cause the handler for that request to have access to this same session storage.</p><p>After successful authentication,<code class="literal"> logon()</code> redirects the user to the return page if one was passed to it or to the default page passed to it upon initialization of the<code class="literal"> Logon</code> instance. If authentication fails, the user is redirected to a non-authorized page.<a id="id140" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec05"/>Expiring a session</h2></div></div></div><p>The<code class="literal"> logoff()</code> method is provided to offer a possibility to actively expire a session. By default, a session expires after 60 minutes, but the user might want to sign off explicitly, either to make sure that no one sneaks behind his keyboard and continues in his name or to log on as a different persona. Therefore, you will find, in most applications, a discrete logoff button, often positioned in the upper-right corner. This button (or just a link) must point to the URL that is handled by the<code class="literal"> logoff()</code> method and will cause the session to be invalidated immediately by removing all session data.<a id="id141" class="indexterm"/>
</p><p>Note that we have to take special precautions to prevent the browser from caching the response from the<code class="literal"> logoff()</code> method, otherwise it may simply redisplay the response from the last time the logoff button was pressed without actually causing<code class="literal"> logoff()</code> to be called. Because<code class="literal"> logoff()</code> always raises an<code class="literal"> InternalRedirect</code> exception, the actual response comes from a different source. This source, for example, the<code class="literal"> goaway()</code> method in the<code class="literal"> Root</code> class must be configured to return the correct response headers in order to prevent the web browser from caching the result. This is accomplished by configuring the<code class="literal"> goaway()</code> method in<code class="literal"> logonapp.py</code> with CherryPy's expires tool like the following:</p><p>
<strong>Chapter3/logonapp.py</strong>
</p><div><pre class="programlisting">
@cherrypy.expose
	def goaway(self):
			return '''
&lt;html&gt;&lt;body&gt;
&lt;h1&gt;Not authenticated, please go away.&lt;/h1&gt;
&lt;/body&gt;&lt;/html&gt;
'''<strong>
	goaway._cp_config = {
		'tools.expires.on':True,
		'tools.expires.secs':0,
		'tools.expires.force':True}</strong>
</pre></div><p>The highlighted line is where we configure the handler (the<code class="literal"> goaway()</code> method) to set expiration headers in the response by assigning a configuration dictionary to the<code class="literal"> _cp_config</code> variable.</p><div><h3 class="title"><a id="note09"/>Note</h3><p>Assigning to a variable that is part of a function might seem odd, but functions and methods in Python are just objects and any object may have variables. New variables might be assigned to an object even after its definition. Upon calling a handler, CherryPy checks if that handler has a<code class="literal"> _cp_config</code> variable and acts accordingly. Note that the<code class="literal"> @cherrypy.expose</code> decorator also merely sets the<code class="literal"> expose</code> variable on the handler to<code class="literal"> true</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec06"/>Have a go hero adding a logon screen to the spreadsheet application</h2></div></div></div><p>In the previous chapter, we had created an application that serves a spreadsheet. If you wanted to serve this spreadsheet only to authenticated users, what would we have to change to use the logon module presented in the previous section?<a id="id142" class="indexterm"/>
</p><p>Hint: You need to do three things, one involves mounting an instance of the<code class="literal"> Logon</code> class on the CherryPy tree, the other is changing the handler that serves the spreadsheet to check for authentication, and finally you need to enable sessions.</p><p>An example implementation is available as<code class="literal"> spreadsheet3.py</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec07"/>Designing a task list</h2></div></div></div><p>Now that we have looked at ways to authenticate the users, let's look at the implementation of the task list itself.<a id="id143" class="indexterm"/>
</p><p>A task list would be unusable if its contents evaporated once the browser was closed. We therefore need some way to persistently store these task lists. We could use a database and many of the example applications in this book do use a database to store data. For this application, we will opt to use the filesystem as a storage medium, simply storing tasks as files containing information about a task, with separate directories for each user. If we dealt with huge amounts of users or very long task lists, the performance of such an implementation probably wouldn't suffice, but by using simple files for storage, we won't have to design a database schema which saves us quite some time.<a id="id144" class="indexterm"/>
</p><p>By limiting ourselves to fairly short task lists, our user interface may be kept relatively simple as there will be no need for pagination or searching. This doesn't mean the user interface shouldn't be easy to use! We will incorporate jQuery UI's<strong> datepicker</strong> widget to assist the user with choosing dates and will add tooltips to user interface components to provide a shallow learning curve of our task list application.<a id="id145" class="indexterm"/>
</p><p>The final requirements more or less define what we understand a task to be and what we are supposed to do with it: A task has a description and a due date and because it can be marked as done, it should be able to store that fact as well. Furthermore, we limit this application to adding and deleting tasks. We explicitly do not provide any way to alter a task, except for marking it as done.<a id="id146" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec03"/>Time for action running tasklist.py</h1></div></div></div><p>Let's first have a look at what the application looks like:<a id="id147" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Start up<code class="literal"> tasklist.py</code> from the code directory of this chapter.</li><li class="listitem">Point your browser to<code class="literal"> http://localhost:8080</code>.</li><li class="listitem">In the logon screen, enter<strong> user</strong> as the username and<strong> secret</strong> as the password.</li><li class="listitem">You are now presented with a rather stark looking and empty task list:<div><img src="img/3746_3_005.jpg" height="51" alt="Time for action running tasklist.py"/></div></li></ol></div><p>You should be able to add a new task by entering a date and a description in the input boxes and pressing the add button. Entering a date is facilitated by jQuery UI's datepicker widget that will pop up once you click the input field for the date, as shown in the following screenshot:</p><div><img src="img/3746_3_006.jpg" height="139" alt="Time for action running tasklist.py"/></div><p>Once you have added one or more tasks, you can now either delete those tasks by clicking the button with the little trash can icon or mark it as done by clicking the button with the check icon. Tasks marked as done have a slightly different background color depending on the chosen theme. If you mark a task as done, its completion date will be today. You can select a different date by clicking on the completion date of a task (displayed as<strong> None</strong> for an unfinished task). It will present you with yet another datepicker, after which the selected date will be stored as the completion date once the done button is clicked. The following screenshot gives an impression of a task list with numerous items:<a id="id148" class="indexterm"/>
</p><div><img src="img/3746_3_007.jpg" height="87" alt="Time for action running tasklist.py"/></div><p>There is some hidden magic that might not be immediately obvious. First of all, all the tasks are sorted according to their<strong> Due date</strong>. This is done on the client-side with the help of some JavaScript and a jQuery plugin, as we will see in the section on JavaScript. Also accomplished with some JavaScript are the tooltips. Both hovering tooltips on every button and the inline help text inside the<code class="literal">&lt;input&gt;</code> elements are added with the same script. We will examine this in depth.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec08"/>What just happened?</h2></div></div></div><p>
<code class="literal">tasklist.py</code> is rather straightforward as it delegates most work to two modules: the<code class="literal"> logon</code> module that we encountered in the previous sections and a<code class="literal"> task</code> module that deals with displaying and manipulating task lists.</p><p>The highlighted line in the following code shows the core of the application. It starts up CherryPy with a suitable configuration. Note that we enabled the sessions tool, so that we can actually use the<code class="literal"> logon</code> module. Also, we construct the path to jQuery UI's theme stylesheet in such a way that it depends on the<code class="literal"> theme</code> variable to make changing the application's theme simple (second highlight).</p><p>The instance of the<code class="literal"> Root</code> class that we pass to<code class="literal"> quickstart()</code> creates a simple tree:</p><div><pre class="programlisting">/
/logon
/logon/logon
/logon/logoff
/task
/task/add
/task/mark
</pre></div><p>The top level URL<code class="literal"> /</code> returns the same content as<code class="literal"> /login</code> by calling the<code class="literal"> index()</code> method of the<code class="literal"> Logon</code> instance. We could have used an<code class="literal"> InternalRedirect</code> exception, but this is just as simple. The paths starting with<code class="literal"> /task</code> are all handled by an instance of the<code class="literal"> Task</code> class:<a id="id149" class="indexterm"/>
</p><p>
<strong>Chapter3/tasklist.py</strong>
</p><div><pre class="programlisting">
import cherrypy
import os.path
import logon
import task
current_dir = os.path.dirname(os.path.abspath(__file__))
theme = "smoothness"
class Root(object):
	task = task.Task(logoffpath="/logon/logoff")
	logon = logon.Logon(path="/logon",
				authenticated="/task",
				not_authenticated="/")
	@cherrypy.expose
	def index(self):
			return Root.logon.index()
if __name__ == "__main__":<strong>
cherrypy.quickstart(Root(),config={</strong>
	'/':
	{ 'log.access_file':os.path.join(current_dir,"access.log"),
	'log.screen': False,
	'tools.sessions.on': True
	},
	'/static':
	{ 'tools.staticdir.on':True,
	'tools.staticdir.dir':os.path.join(current_dir,"static")
	},
	'/jquery.js':
	{ 'tools.staticfile.on':True,
	'tools.staticfile.filename':os.path.join(current_dir,
	"static","jquery","jquery-1.4.2.js")
	},
	'/jquery-ui.js':
	{ 'tools.staticfile.on':True,
	'tools.staticfile.filename':os.path.join(current_dir,
	"static","jquery","jquery-ui-1.8.1.custom.min.js")
	},
	'/jquerytheme.css':
	{ 'tools.staticfile.on':True,
	'tools.staticfile.filename':os.path.join(current_dir,
	"static","jquery","css",theme,"jquery-ui-1.8.4.custom.css")
	},
	'/images':
	{ 'tools.staticdir.on':True,<strong>
	'tools.staticdir.dir':os.path.join(current_dir,
	"static","jquery","css",theme,"images")</strong>
	}
})
</pre></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec04"/>Python: the task module</h1></div></div></div><p>The<code class="literal"> task</code> module is implemented in the file<code class="literal"> task.py</code>. Let's look at the parts that make up this file.<a id="id151" class="indexterm"/>
</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec05"/>Time for action implementing the task module</h1></div></div></div><p>Have a look at the Python code in<code class="literal"> task.py:</code>
<a id="id152" class="indexterm"/>
</p><p>
<strong>Chapter3/task.py</strong>
</p><div><pre class="programlisting">import cherrypy
import json
import os
import os.path
import glob
from configparser import RawConfigParser as configparser
from uuid import uuid4 as uuid
from datetime import date
import logon
</pre></div><p>This first part illustrates Python's "batteries included" philosophy nicely: besides the<code class="literal"> cherrypy</code> module and our own<code class="literal"> logon</code> module, we need quite a bit of specific functionality. For example, to generate unique identifiers, we use the<code class="literal"> uuid</code> module and to manipulate dates, we use the<code class="literal"> datetime</code> module. All of this functionality is already bundled with Python, saving us an enormous amount of development time. The next part is the definition of the basic HTML structure that will hold our task list:<a id="id153" class="indexterm"/>
</p><p>
<strong>Chapter3/task.py</strong>
</p><div><pre class="programlisting">
base_page = '''
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script type="text/javascript" src="img/jquery.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="img/jquery-ui.js" &gt;&lt;/script&gt;
&lt;style type="text/css" title="currentStyle"&gt;<strong>
	@import "/static/css/tasklist.css";</strong>
	@import "/jquerytheme.css";
&lt;/style&gt;<strong>
&lt;script type="text/javascript" src="img/sort.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="img/tooltip.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="img/tasklist.js" &gt;&lt;/script&gt;</strong>
&lt;/head&gt;
&lt;body id="%s"&gt;
&lt;div id="content"&gt;
%s
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
</pre></div><p>Again the structure is simple, but besides the themed stylesheet needed by jQuery UI (and reused by the elements we add to the page), we need an additional stylesheet specific to our task list application. It defines specific layout properties for the elements that make up our task list (first highlight). The highlighted<code class="literal">&lt;script&gt;</code> elements show that besides the jQuery and jQuery UI libraries, we need some additional libraries. Each of them deserves some explanation.<a id="id154" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec09"/>What just happened?</h2></div></div></div><p>The first JavaScript library is<code class="literal"> sort.js,</code> a code snippet from James Padolsey (http://james.padolsey.com/tag/plugins/) that provides us with a plugin that allows us to sort HTML elements. We need this to present the list of tasks sorted by their due date.</p><p>The second is<code class="literal"> tooltip.js</code> that combines a number of techniques from various sources to implement tooltips for our buttons and inline labels for our<code class="literal">&lt;input&gt;</code> elements. There are a number of tooltip plugins available for jQuery, but writing our own provides us with some valuable insights so we will examine this file in depth in a later section.</p><p>The last one is<code class="literal"> tasklist.js</code>. It employs all the JavaScript libraries and plugins to actually style and sort the elements in the task list.</p><p>The next part of<code class="literal"> task.py</code> determines the directory we're running the application from. We will need this bit of information because we store individual tasks as files located relative to this directory. The<code class="literal"> gettaskdir()</code> function takes care of determining the exact path for a given username (highlighted). It also creates the<code class="literal"> taskdir</code> directory and a sub directory with a name equal to username, if these do not yet exist with the<code class="literal"> os.makedirs()</code> function (notice the final 's' in the function name: this one will create all intermediate directories as well if they do not yet exist):</p><p>
<strong>Chapter3/task.py</strong>
</p><div><pre class="programlisting">
current_dir = os.path.dirname(os.path.abspath(__file__))<strong>
def gettaskdir(username):</strong>
	taskdir = os.path.join(current_dir,'taskdir',username)
	# fails if name exists but is a file instead of a directory
	if not os.path.exists(taskdir):
			os.makedirs(taskdir)
	return taskdir
</pre></div><p>The<code class="literal"> Task</code> class is where the handlers are defined that CherryPy may use to show and manipulate the task list. The<code class="literal"> __init__()</code> method stores a path to a location that provides the user with a possibility to end a session. This path is used by other methods to create a suitable logoff button.<a id="id155" class="indexterm"/>
</p><p>The<code class="literal"> index()</code> method will present the user with an overview of all his/her tasks plus an extra line where a new task can be defined. As we have seen, each task is adorned with buttons to delete a task or mark it as done. The first thing we do is check whether the user is authenticated by calling the<code class="literal"> checkauth()</code> function from our<code class="literal"> logon</code> module (highlighted). If this call returns, we have a valid username, and with that username, we figure out where to store the tasks for this user.</p><p>Once we know this directory, we use the<code class="literal"> glob()</code> function from the Python<code class="literal"> glob</code> module to retrieve a list of files with a<code class="literal"> .task</code> extension. We store that list in the<code class="literal"> tasklist</code> variable:</p><p>
<strong>Chapter3/task.py</strong>
</p><div><pre class="programlisting">
class Task(object):
def __init__(self,logoffpath="/logoff"):
	self.logoffpath=logoffpath
@cherrypy.expose
def index(self):<strong>
	username = logon.checkauth()</strong>
	taskdir = gettaskdir(username)
	tasklist = glob.glob(os.path.join(taskdir,'*.task'))
</pre></div><p>Next, we create a<code class="literal"> tasks</code> variable that will hold a list of strings that we will construct when we iterate over the list of tasks. It is initialized with some elements that together form the header of our task list. It contains, for example, a small form with a logoff button and the headers for the columns above the list of tasks. The next step is to iterate over all files that represent a task (highlighted) and create a form with suitable content together with delete and done buttons.</p><p>Each<code class="literal"> .task</code> file is structured in a way that is consistent with Microsoft Windows<code class="literal"> .ini</code> files. Such files can be manipulated with Python's<code class="literal"> configparser</code> module. The<code class="literal"> .task</code> file is structured as a single<code class="literal"> [task]</code> section with three possible keys. This is an example of the format:</p><div><pre class="programlisting">
[task]
description = something
duedate = 2010-08-26
completed = 2010-08-25
</pre></div><p>When we initialize a<code class="literal"> configparser</code> object, we pass it a dictionary with default values in case any of these keys is missing. The<code class="literal"> configparser</code> will read a file when we pass an open file descriptor to its<code class="literal"> readfp()</code> method. The value associated with any key in a given section may then be retrieved with the<code class="literal"> get()</code> method that will take a section and a key as parameters. If the key is missing, it supplies the default if that was provided upon initialization. The second highlighted line shows how this is used to retrieve the values for the<code class="literal"> description</code> key.</p><p>Next, we construct a form for each<code class="literal"> .task</code> file. It contains read-only<code class="literal">&lt;input&gt;</code> elements to display the<strong> Due date, Description</strong>, and the completion date plus buttons to delete the task or mark it as done. When these buttons are clicked the contents of the form are passed to the<code class="literal"> /task/mark</code> URL (handled by the<code class="literal"> mark()</code> method). The method needs to know which file to update. Therefore, it is passed a hidden value: the basename of the file. That is, the filename without any leading directories and stripped of its<code class="literal"> .task</code> extension:</p><p>
<strong>Chapter3/task.py</strong>
</p><div><pre class="programlisting">
				tasks = [
'''
&lt;div class="header"&gt;
Tasklist for user &lt;span class="highlight"&gt;%s&lt;/span&gt;
	&lt;form class="logoff" action="%s" method="GET"&gt;
		&lt;button type="submit" name="logoffurl"
				class="logoff-button" value="/"&gt;Log off
		&lt;/button&gt;
	&lt;/form&gt;
&lt;/div&gt;
'''%(username,self.logoffpath),
'''
&lt;div class="taskheader"&gt;
	&lt;div class="left"&gt;Due date&lt;/div&gt;
	&lt;div class="middle"&gt;Description&lt;/div&gt;
	&lt;div class="right"&gt;Completed&lt;/div&gt;
&lt;/div&gt;
''','&lt;div id="items" class="ui-widget-content"&gt;']<strong>
		for filename in tasklist:</strong>
			d = configparser(
			defaults={'description':'',
					'duedate':'',
					'completed':None})
			id = os.path.splitext(os.path.basename(filename))[0]
			d.readfp(open(filename))<strong>
			description = d.get('task','description')</strong>
			duedate = d.get('task','duedate')
			completed = d.get('task','completed')
			tasks.append(
'''
&lt;form class="%s" action="mark" method="GET"&gt;
	&lt;input type="text" class="duedate left"
			name="duedate" value="%s" readonly="readonly" /&gt;
	&lt;input type="text" class="description middle"
			name="description" value="%s" readonly="readonly" /&gt;
	&lt;input type="text" class="completed right editable-date tooltip"
			title="click to select a date, then click done"
			name="completed" value="%s" /&gt;
	&lt;input type="hidden" name="id" value="%s" /&gt;
	&lt;button type="submit" class="done-button"
			name="done" value="Done" &gt;Done
	&lt;/button&gt;
	&lt;button type="submit" class="del-button"
			name="delete" value="Del" &gt;Del
	&lt;/button&gt;
&lt;/form&gt;
'''%('notdone' if completed==None else 'done',
	duedate,description,completed,id))
		tasks.append(
'''
&lt;form class="add" action="add" method="GET"&gt;
	&lt;input type="text" class="duedate left editable-date tooltip"
			name="duedate" title="click to select a date" /&gt;
	&lt;input type="text" class="description middle tooltip"
			title="click to enter a description" name="description"/&gt;
	&lt;button type="submit" class="add-button"
			name="add" value="Add" &gt;Add
	&lt;/button&gt;
&lt;/form&gt;
&lt;/div&gt;
''')
		return base_page%('itemlist',"".join(tasks))
</pre></div><p>Finally, we append one extra form with the same type of input fields for<strong> Due date</strong> and<strong> Description</strong> but this time, not marked as read-only. This form has a single button that will submit the contents to the<code class="literal"> /task/add</code> URL. These will be handled by the<code class="literal"> add()</code> method. The actual content returned by the<code class="literal"> index()</code> method consists of all these generated lines joined together and embedded in the HTML of the<code class="literal"> base_page</code> variable.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec10"/>Adding new tasks</h2></div></div></div><p>New tasks are created by the<code class="literal"> add()</code> method. Besides the value of the add button (which is not relevant), it will take a<code class="literal"> description</code> and a<code class="literal"> duedate</code> as parameters. To prevent accidents, it first checks if the user is authenticated, and if so, it determines what the<code class="literal"> taskdir</code> for this user is.<a id="id156" class="indexterm"/>
</p><p>We are adding a new task so we want to create a new file in this directory. To guarantee that it has a unique name, we construct this filename from the path to this directory and a globally unique ID object provided by Python's<code class="literal"> uuid()</code> function from the<code class="literal"> uuid</code> module. The<code class="literal"> .hex()</code> method of a<code class="literal"> uuid</code> object returns the ID as a long string of hexadecimal numbers that we may use as a valid filename. To make the file recognizable to us as a task file, we append the<code class="literal"> .task</code> extension (highlighted).</p><p>Because we want our file to be readable by a<code class="literal"> configparser</code> object, we will create it with a<code class="literal"> configparser</code> object to which we add a<code class="literal"> task</code> section with the<code class="literal"> add_section()</code> method and<code class="literal"> description</code> and<code class="literal"> duedate</code> keys with the<code class="literal"> set()</code> method. Then we open a file for writing and use the open file handle to this file within a context manager (the<code class="literal"> with</code> clause), thereby ensuring that if anything goes wrong when accessing this file, it will be closed and we will proceed to redirect the user to that list of tasks again. Note that we use a relative URL consisting of a single dot to get us the index page. Because the<code class="literal"> add()</code> method handles a URL like<code class="literal"> /task/add</code> redirecting to '.' (the single dot), will mean the user is redirected to<code class="literal"> /task/</code>, which is handled by the<code class="literal"> index()</code> method:</p><p>
<strong>Chapter3/task.py</strong>
</p><div><pre class="programlisting">
@cherrypy.expose
def add(self,add,description,duedate):
	username = logon.checkauth()
	taskdir = gettaskdir(username)<strong>
	filename = os.path.join(taskdir,uuid().hex+'.task')</strong>
	d=configparser()
	d.add_section('task')
	d.set('task','description',description)
	d.set('task','duedate',duedate)
	with open(filename,"w") as file:
		d.write(file)
	raise cherrypy.InternalRedirect(".")
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Deleting a task</h2></div></div></div><p>Deleting or marking a task as done are both handled by the<code class="literal"> mark()</code> method. Besides an ID (the basename of an existing<code class="literal"> .task</code> file), it takes<code class="literal"> duedate, description</code>, and<code class="literal"> completed</code> parameters. It also takes optional<code class="literal"> done</code> and<code class="literal"> delete</code> parameters, which are set depending on whether the done or delete buttons are clicked respectively.<a id="id157" class="indexterm"/>
</p><p>Again, the first actions are to establish whether the user is authenticated and what the corresponding task directory is. With this information, we can construct the filename we will act on. We take care to check the validity of the<code class="literal"> id</code> argument. We expect it to be a string of hexadecimal characters only and one way to verify this is to convert it using the<code class="literal"> int()</code> function with 16 as the base argument. This way, we prevent malicious users from passing a file path to another user's directory. Even though it is unlikely that a 32 character random string can be guessed, it never hurts to be careful.</p><p>The next step is to see if we are acting on a click on the done button (highlighted in the following code). If we are, we read the file with a<code class="literal"> configparser</code> object and update its<code class="literal"> completed</code> key.</p><p>The<code class="literal"> completed</code> key is either the date that we were passed as the<code class="literal"> completed</code> parameter or the current date if that parameter was either empty or<code class="literal"> None</code>. Once we have updated the<code class="literal"> configparser</code> object, we write it back again to the file with the<code class="literal"> write()</code> method.</p><p>Another possibility is that we are acting on a click on the delete button; in that case, the<code class="literal"> delete</code> parameter is set. If so, we simply delete the file with the<code class="literal"> unlink()</code> function from Python's<code class="literal"> os</code> module:</p><p>
<strong>Chapter3/task.py</strong>
</p><div><pre class="programlisting">
@cherrypy.expose
def mark(self,id,duedate,description,
			completed,done=None,delete=None):
	username = logon.checkauth()
	taskdir = gettaskdir(username)
	try:
			int(id,16)
	except ValueError:
			raise cherrypy.InternalRedirect(self.logoffpath)
	filename = os.path.join(taskdir,id+'.task')<strong>
if done=="Done":</strong>
			d=configparser()
			with open(filename,"r") as file:
				d.readfp(file)
			if completed == "" or completed == "None":
				completed = date.today().isoformat()
			d.set('task','completed',completed)
			with open(filename,"w") as file:
				d.write(file)
elif delete=="Del":
			os.unlink(filename)
raise cherrypy.InternalRedirect(".")
</pre></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec06"/>JavaScript: tasklist.js</h1></div></div></div><p>The buttons we present the end user need to be configured to respond to clicks in an appropriate manner and it would be nice if these buttons showed some intuitive icons as well. This is what we will take care of in<code class="literal"> tasklist.js</code>.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec07"/>Time for action styling the buttons</h1></div></div></div><p>The work done by<code class="literal"> tasklist.js</code> is mainly concerned with styling the<code class="literal">&lt;button&gt;</code> elements and adding tooltips and inline labels to<code class="literal">&lt;input&gt;</code> elements. The results so far are shown in the following screenshot:</p><div><img src="img/3746_3_009.jpg" height="146" alt="Time for action styling the buttons"/></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec12"/>What just happened?</h2></div></div></div><p>As can be seen in the first line of<code class="literal"> tasklist.js</code> (code starts on the next page), the work to be done is scheduled after loading the complete document by passing it to jQuery's<code class="literal"> $(document).ready()</code> function.</p><p>The first step is to add to any element with a<code class="literal"> header</code> class the<code class="literal"> ui-widget</code> and<code class="literal"> ui-widget-header</code> classes as well. This will cause these elements to be styled in a way that is consistent with the chosen theme.</p><p>Then we configure the add button (or rather any element with the<code class="literal"> add-button</code> class) as a jQuery UI button widget. The option object passed to it will configure it to show no text, but just a single icon depicting a thick plus sign. We also add an extra function to the click handler of the button that checks any element marked with the<code class="literal"> inline-label</code> class to see if its contents are identical to the contents of its title attribute. If that is the case, we set the contents to the empty string, as this indicates that the user hasn't filled in anything in this element and we do not want to store the text of the inline label as the content of our new task (more about this in the section on tooltips). Note that we do nothing to prevent propagation of the click event, so if this button is of the<code class="literal"> submit</code> type (and our add button is) the<code class="literal"> submit</code> action will still be performed.</p><p>All elements with the<code class="literal"> del-button</code> class (highlighted) are then styled with an icon of a trash can. The buttons also receive an extra click handler that will remove the disabled attribute from their siblings (the input fields in the same form) to make sure the submit action will receive the contents even from fields that are marked as disabled.</p><p>Next, the other<code class="literal">&lt;button&gt;</code> elements are adorned with an appropriate icon and to any text or password<code class="literal">&lt;input&gt;</code> element we add a<code class="literal"> textinput</code> class to mark it for the tooltip library.</p><p>In the second highlighted line, we encounter jQuery UI's datepicker widget. The datepicker widget greatly simplifies entering dates for the user and is now more or less a staple item in any web application or website that asks the user to enter a date. jQuery UI's datepicker is very straightforward to use, yet comes with a host of configuration options (all of them documented at<a class="ulink" href="http://jqueryui.com/demos/datepicker/)"> http://jqueryui.com/demos/datepicker/)</a>.</p><p>We use the<code class="literal"> dateFormat</code> option to configure the datepicker to store dates as YYYY-MM-DD. Datepicker has a number of predefined formats and this one happens to be an international standard as well as a suitable format to sort dates in a simple way. We also configure the datepicker to call a function when the user closes the datepicker. This function removes any<code class="literal"> inline-label</code> class, preventing the newly entered date to appear in the colors associated with any inline label (as we see later, when we look at<code class="literal"> tasklist.css</code>, we style the colors of any element with an<code class="literal"> inline-label</code> class in a distinct way).</p><p>Earlier, we indicated that we wanted to present the list of tasks ordered by their due date. We therefore apply the<code class="literal"> sort()</code> plugin from<code class="literal"> sort.js</code> to all<code class="literal">&lt;input&gt;</code> elements with a<code class="literal"> duedate</code> class.<code class="literal"> sort()</code> takes two arguments. The first one is a comparison function that is passed two elements to compare. In our case, that will be<code class="literal">&lt;input&gt;</code> elements that contain a date in the YYYY-MM-DD format, so we can simply compare the values of these elements as text and return plus or minus one. The second argument is a function that takes no arguments and should return the element to be sorted. The input element with the due date is available as the<code class="literal"> this</code> variable within this function and we use it to return the parent of the input element. This parent will be the<code class="literal">&lt;form&gt;</code> element that encloses it and because we represent each task as a form, we want those forms to be sorted, not just the<code class="literal">&lt;input&gt;</code> elements inside these forms.</p><p>The last set of actions in<code class="literal"> tasklist.js</code> adds a<code class="literal"> disabled</code> attribute to any<code class="literal">&lt;input&gt;</code> element within an element that has a<code class="literal"> done</code> class and disables any done button. This will ensure that tasks marked as done cannot be altered:</p><p>
<strong>Chapter3/tasklist.js</strong>
</p><div><pre class="programlisting">
$(document).ready(function(){
	$(".header").addClass("ui-widget ui-widget-header");
	$(".add-button").button(
		{icons:{primary: 'ui-icon-plusthick' },
		text:false}).click(function(){
		$(".inline-label").each(function() {
				if($(this).val() === $(this).attr('title')) {
					$(this).val('');
				};
	})
});<strong>
$(".del-button").button(
</strong>
	{icons:{primary: 'ui-icon-trash' },
	text:false}).click(function(){
		$(this).siblings("input").removeAttr("disabled");
});
$(".done-button").button( {icons: {primary:'ui-icon-check'},
							text:false});
$(".logoff-button").button({icons: {primary:'ui-icon-closethick'},
							text:false});
$(".login-button").button( {icons: {primary:'ui-icon-play'},
							text:false});
$(":text").addClass("textinput");
$(":password").addClass("textinput");<strong>
$( ".editable-date" ).datepicker({</strong>
		dateFormat: $.datepicker.ISO_8601,
		onClose: function(dateText,datePicker){
		if(dateText != ''){$(this).removeClass("inline-label");}}
	});
$("#items form input.duedate").sort(
		function(a,b){return $(a).val() &gt; $(b).val() ? 1 : -1;},
		function(){ return this.parentNode; }).addClass(
												"just-sorted");
$(".done .done-button").button( "option", "disabled", true );
$(".done input").attr("disabled","disabled");
});
</pre></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec08"/>JavaScript: tooltip.js</h1></div></div></div><p>
<code class="literal">tooltip.js</code> is a bit of a misnomer as its most interesting part is not about tooltips but inline labels. Inline labels are a way to convey helpful information not by means of a hovering tooltip, but by putting text inside text input elements. This text then disappears when the user clicks the input field and starts typing. There are many implementations to be found on the web, but the most clear and concise one I found is from<a class="ulink" href="http://trevordavis.net/blog/tutorial/jquery-inline-form-labels/"> http://trevordavis.net/blog/tutorial/jquery-inline-form-labels/</a>.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec09"/>Time for action implementing inline labels</h1></div></div></div><p>Take a look again at the screenshot of the list of tasks:<a id="id158" class="indexterm"/>
</p><div><img src="img/3746_3_011.jpg" height="143" alt="Time for action implementing inline labels"/></div><p>The highlighted parts show what we mean by inline labels. The input fields display some helpful text to indicate their use and when we click such a field, this text will disappear and we can enter our own text. If we abort the input by clicking outside the input field when we have not yet entered any text, the inline label is shown again.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec13"/>What just happened?</h2></div></div></div><p>
<code class="literal">tooltip.js</code> shows a number of important concepts: First how to apply a function to each member of a selection (highlighted). In this case, we apply the function to all<code class="literal">&lt;input&gt;</code> elements that have a<code class="literal"> title</code> attribute. Within the function passed to the<code class="literal"> each()</code> method, the selected<code class="literal">&lt;input&gt;</code> element is available in the<code class="literal"> this</code> variable. If the content of an<code class="literal">&lt;input&gt;</code> element is completely empty, we change its content to that of the<code class="literal"> title</code> attribute and add the class<code class="literal"> inline-label</code> to the<code class="literal">&lt;input&gt;</code> element. That way, we can style the text of an inline label differently than the regular input text if we like, for example, a bit lighter to make it stand out less.<a id="id159" class="indexterm"/>
</p><p>The second concept shown is binding to the<strong> focus</strong> and<strong> blur</strong> events. When the user clicks an<code class="literal">&lt;input&gt;</code> element or uses the<em> Tab</em> key to navigate to it, it gains focus. We can act upon this event by passing a function to the<code class="literal"> focus()</code> method. In this function, the<code class="literal">&lt;input&gt;</code> element that gains focus is again available in the<code class="literal"> this</code> variable and we check if the content of this<code class="literal">&lt;input&gt;</code> element is equal to the content of its<code class="literal"> title</code> attribute. If this is true, the user hasn't yet changed the content, so we empty this element by assigning an empty string to it (highlighted).</p><p>The same line shows another important concept in jQuery, that of<strong> chaining</strong>. Most jQuery methods (like<code class="literal"> val()</code> in this example) return the selection they act upon, allowing additional methods to be applied to the same selection. Here we apply<code class="literal"> removeClass()</code> to remove the<code class="literal"> inline-label</code> class to show the text the user is typing in the regular font and color for this<code class="literal">&lt;input&gt;</code> element.<a id="id160" class="indexterm"/>
</p><p>We also act on losing focus (commonly referred to as<em> blurring)</em>, for example, when the user clicks outside the<code class="literal">&lt;input&gt;</code> element or uses the<em> Tab</em> key to navigate to another element. We therefore pass a function to the<code class="literal"> blur()</code> method. This function checks whether the content of the<code class="literal">&lt;input&gt;</code> element is empty. If so, then the user hasn't entered anything and we insert the content of the<code class="literal"> title</code> attribute again and mark the element with an<code class="literal"> inline-label</code> class.</p><p>
<strong>Chapter3/tooltip.js</strong>
</p><div><pre class="programlisting">
$(document).ready(function() {<strong>
	$('input[title]').each(function() {</strong>
		if($(this).val() === '') {
			$(this).val($(this).attr('title'));
			$(this).addClass('inline-label');
		}
		$(this).focus(function() {
			if($(this).val() === $(this).attr('title')) {<strong>
					$(this).val('').removeClass('inline-label');</strong>
			}
		});
		$(this).blur(function() {
			if($(this).val() === '') {
				$(this).val($(this).attr('title'));
				$(this).addClass('inline-label');
			}
		});
	});
});
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec14"/>CSS: tasklist.css</h2></div></div></div><p>Without some additional styling to tweak the layout, our tasklist application would look a bit disheveled, as seen before.</p><p>Our main challenges are aligning all columns and moving all buttons consistently to the right. All elements in our HTML markup that make up the columns are marked with a class to indicate that they belong in the left, middle, or right column. All we have to do to align these columns is to set their width based on their class (highlighted).</p><p>The largest part of the rest of<code class="literal"> tasklist.css</code> is concerned with either floating elements to the right (like buttons) or to the left (containers, like the<code class="literal">&lt;div&gt;</code> element with the<code class="literal"> id</code> attribute<code class="literal"> content)</code>. Most containers are not only floated to the left, but also explicitly set to a width of 100 percent to make sure they fill the element they are contained in themselves. This is not always necessary to position them correctly, but if we do not take care, the background color of the enclosing element might show if an element doesn't fill its enclosing element:</p><p>
<strong>Chapter3/tasklist.css</strong>
</p><div><pre class="programlisting">
input[type="text"] {
	font-size:1.1em;
	margin:0;
	border:0;
	padding:0;}<strong>
.left, .right { width: 8em; }
.middle { width: 20em;}</strong>
form {
	float:left;
	border:0;
margin:0;
padding:0;
	clear:both;
	width:100%; }
form.logoff{
float:right;
	border:0;
margin:0;
padding:0;
	clear:both;
width:auto;
	font-size:0.5em;}
#items { float:left; clear:both; width:100%; }
.header { width:100%; }
.taskheader, .header, #content{ float:left; clear:both;}
.taskheader div { float:left; font-size:1.1em; font-weight:bold;}
.logoff-button, .done-button, .del-button, .add-button { float:right;}
.done-button, .add-button, .del-button { width: 6em; height: 1.1em; }
#content { min-width:900px;}
</pre></div><p>Note that our stylesheet only deals with measurements and font sizes. Any coloring is applied by the chosen jQuery UI theme. With the styles applied, the application looks a fair bit tidier:</p><div><img src="img/3746_3_010.jpg" height="68" alt="CSS: tasklist.css"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Pop quiz styling screen elements</h2></div></div></div><div><ol class="orderedlist"><li class="listitem">In<code class="literal"> tasklist.js</code>, we explicitly configured all buttons to show just an icon without any text. But what if we wanted to show both an icon and some text, what would we do?</li><li class="listitem">If we didn't set the width of the form that makes up a task explicitly to 100 percent, what would the biggest disadvantage be?</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Have a go hero changing the date format of a datepicker</h2></div></div></div><p>To display the date as ISO 8701 (or YYYY-MM-DD) isn't everybody's idea of a readable date format. For many people, the default mm/dd/yy is far more readable. How would you change<code class="literal"> tasklist.js</code> to display the tasks with this default date format? Hint: it isn't enough to leave out the<code class="literal"> dateFormat</code> option when calling the<code class="literal"> datepicker()</code> plugin, you also need to change the comparator function to sort the tasks in a suitable manner.<a id="id161" class="indexterm"/>
</p><p>For the impatient or curious readers: a sample implementation is available as<code class="literal"> tasklist2.js</code> (start up<code class="literal"> tasklist2.py</code> to see the effect).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Have a go hero serving a task list from a different URL</h2></div></div></div><p>One way to measure how reusable a piece of code is, is by using it in a situation that you did not yet have in mind when you designed it. Of course, that doesn't mean our task module should be able to function as a control application for an automobile construction plant, but what if we would like it to be part of a larger suite of applications served from the same root? Would we have to change anything?<a id="id162" class="indexterm"/>
</p><p>Say we want to serve the tasklist application from the URL<a class="ulink" href="http:///apps/task"> /apps/task</a> instead of<a class="ulink" href="http:///task"> /task</a>, what would we have to change?</p><p>Hint: In CherryPy, you can create a tree of URLs by assigning object instances to class variables of the object instance that is passed to the<code class="literal"> quickstart()</code> method.</p><p>A possible implementation can be found in<code class="literal"> tasklistapp.py</code>.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec10"/>Summary</h1></div></div></div><p>We have learned a lot in this chapter about session management and storing persistent information on the server. Specifically, we saw how to design a tasklist application and implement a logon screen. What a session is and how this allows us to work with different users at the same time and how to interact with the server, and add or delete tasks. We also learned how to make entering dates attractive and simple with jQuery UI's datepicker widget and how to style button elements and provide tooltips and inline labels to input elements.</p><p>Now that you know a little bit more about storing data on the server, you might wonder if storing information in plain files on the server filesystem is the most convenient solution. In many cases, it isn't and a database might be more suitable which is the topic of the next chapter.</p></div></div>
</body></html>