<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Performance – Identifying Bottlenecks</h1></div></div></div><p>So far, you have learned various ways to make the application robust and accommodating for new features. Now, let's discuss techniques to improve the application performance. This broad topic is split into a series of three chapters—this is the first one in this series. It will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic ways to clock the application runtime</li><li class="listitem" style="list-style-type: disc">How to identify the runtime performance bottlenecks by profiling the code</li><li class="listitem" style="list-style-type: disc">Basic memory profiling with the <code class="literal">memory_profiler</code> package</li><li class="listitem" style="list-style-type: disc"><strong>Big O</strong> notation for the computational complexity</li></ul></div><p>To understand these concepts better, we will develop an interesting game scenario called <em>Gold Hunt</em>. You will soon realize that the application runs very slow when you increase the input data size. This chapter will elaborate on techniques to pinpoint such problems.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Overview of three performance chapters</h1></div></div></div><p>Before we dive into the main discussion, let's first understand how the chapters on performance improvement are organized. As mentioned earlier, this discussion is split into a series of three interlinked chapters.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec128"/>More focus on the runtime performance</h2></div></div></div><p>The<a id="id531" class="indexterm"/> term performance improvement can mean several things. One can be talking about improving the runtime (CPU usage), making the application memory efficient, reducing the network consumption, or a combination of these. In this book, we will primarily focus on the runtime performance improvement. We will also discuss the memory consumption aspect, but the discussion will be limited to the <strong>memory profiling</strong>
<a id="id532" class="indexterm"/> technique and the use of generator expressions.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec129"/>The first performance chapter</h2></div></div></div><p>You are reading the first chapter in this series. It does some preparatory work to improve the application performance. This preparation involves measuring the runtime, identifying pieces of the code that cause the performance bottlenecks, understanding the big O notation, and so on.</p><div><img src="img/B05034_07_19.jpg" alt="The first performance chapter"/></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>Of course! We will develop the earlier mentioned <strong>Gold Hunt scenario</strong>, and then identify the performance bottlenecks in the code. The next two chapters will use this groundwork to gradually improve the application performance.</em>
</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec130"/>The second performance chapter</h2></div></div></div><p>The next chapter is all about learning various performance improvement techniques. The first half aims at improving the application runtime for the <em>Gold Hunt</em> application. The second half teaches several tricks to optimize the code. The chapter covers some built-in modules designed for high performance and memory efficiency. It also talks about list comprehension, generator expressions, choice of data structures, algorithmic changes, and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec131"/>The third performance chapter</h2></div></div></div><p>The last chapter in this series will briefly talk about the <strong>NumPy</strong> package<a id="id533" class="indexterm"/> and <strong>parallelization</strong>
<a id="id534" class="indexterm"/> using the <code class="literal">multiprocessing</code> module in Python. We will use these techniques to drastically improve the runtime performance of the application.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec132"/>Sneak peek at the upcoming application speedup</h2></div></div></div><p>Here is a preview of how the <em>Gold Hunt</em> program will evolve from a turtle to a rabbit. The following figure shows 	the approximate runtime after each major step of performance improvement. By the time we complete <a class="link" href="ch09.html" title="Chapter 9. Improving Performance – Part Two, NumPy and Parallelization">Chapter 9</a>, <em>Improving Performance – Part two, NumPy and Parallelization</em>, the application runtime will be brought down to approximately 14 seconds from an initial value of nearly 106 seconds.</p><div><img src="img/B05034_07_20.jpg" alt="Sneak peek at the upcoming application speedup"/></div><p>No need to spend any time trying to understand the elements presented in this chart; things will become clear once you read all three chapters on performance. For now, all you need to know is that we will learn some techniques to drastically improve the application runtime in the upcoming chapters.</p><div><div><h3 class="title"><a id="tip69"/>Tip</h3><p>
<strong>Caution</strong>
</p><p>The chapters on performance will show some examples of inefficient code. Running these examples can consume a lot of compute resources. Instead of using the problem size illustrated in these chapters, you should choose an appropriate data size depending on what your machine can handle.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Scenario – The Gold Hunt</h1></div></div></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>You recently introduced</em>
<a id="id535" class="indexterm"/>
<em> a new scenario in the game—to meet the expenses of his army, Sir Foo is out on a mission to collect gold from a recently acquired territory. The scenario starts with Sir Foo arriving at a place full of gold coins, jewelry, and so on. There are a couple of problems though. Firstly, the gold is scattered all over the field. Secondly, Sir Foo doesn't have time to collect all the gold on the field.</em>
</p>
</td></tr></tbody></table></div><div><img src="img/B05034_07_22.jpg" alt="Scenario – The Gold Hunt"/></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>What you see behind Sir Foo is an imaginary <strong>gold field</strong>. Sir Foo will enter from the left side and travel across the field. He will only collect the coins lying along his path and <strong>ignore all the remaining gold</strong> scattered across the field.</em>
</p>
</td></tr></tbody></table></div><p>Let's represent this gold field <a id="id536" class="indexterm"/>as a circle with a radius of nearly 10 miles (diameter of 20 miles), and center located at coordinates <em>x = 0</em> and <em>y = 0</em>, as shown in the following screenshot:</p><div><img src="img/B05034_07_01.jpg" alt="Scenario – The Gold Hunt"/></div><p>Observe the following screenshot. The <em>dotted line</em> (the diameter of the field) shows the path that Sir Foo traverses on his way out. During this 20 mile journey, he stops at 10 <em>equally spaced points</em>. In other words, these points are 2 miles apart, represented by the centers of the small "search circles". For each stop, he collects the gold within a search circle. The total collected gold is the sum of the coins<a id="id537" class="indexterm"/> inside each of those 10 tiny circles. Let's not worry about the gold lying outside of these search circles. </p><p>Assume that the remaining gold on the field is irrelevant for the problem we are solving.</p><div><img src="img/B05034_07_02.jpg" alt="Scenario – The Gold Hunt"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec133"/>High-level algorithm</h2></div></div></div><p>With the preceding screenshot as <a id="id538" class="indexterm"/>a reference, let's write the high-level algorithm. We will keep it simple. The task is to collect the gold coins found inside each of the small circles in this image (recall that these circles are referred to as <em>search circles</em>). We will call the radius of each of these circles a <em>search radius</em>. In the present scenario, the search radius is 1 mile, or let's simply call it 1 unit:</p><div><ol class="orderedlist arabic"><li class="listitem">Randomly create points representing the gold coins inside a gold field. The gold field is represented by a large circle with a radius of 10 units and center at <em>(x = 0, y = 0)</em>. Each gold coin is represented with a <em>(x,y)</em> location.</li><li class="listitem">Start with the leftmost search circle, the center of which represents Sir Foo's current location. The coin hunt is constrained within this search circle.</li><li class="listitem">For each search circle:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get Sir Foo's current location coordinates.</li><li class="listitem" style="list-style-type: disc">Find the distance between each gold coin on the field and Sir Foo's location, the center of a search circle.</li><li class="listitem" style="list-style-type: disc">Collect all the coins with distance less than the <em>search radius</em>. These are the coins lying inside the perimeter of the current search circle.</li><li class="listitem" style="list-style-type: disc">Advance Sir Foo to the center of the next search circle.</li><li class="listitem" style="list-style-type: disc">Repeat the preceding steps until you reach the rightmost circle.</li></ul></div></li><li class="listitem">Report the total number of collected gold coins.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec134"/>Reviewing the initial code</h2></div></div></div><p>Let's review the code <a id="id539" class="indexterm"/>next (it can also be found in the supporting code bundle, just look for the <code class="literal">goldhunt_inefficient.py</code> file). Here is a new <code class="literal">GoldHunt</code> class:</p><div><img src="img/B05034_07_03.jpg" alt="Reviewing the initial code"/></div><p>The <code class="literal">play</code> method of this <a id="id540" class="indexterm"/>class contains the main logic, as shown in the following screenshot:</p><div><img src="img/B05034_07_21.jpg" alt="Reviewing the initial code"/></div><p>Let's review the code in the preceding screenshots:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The input arguments for the <code class="literal">play </code>method, <code class="literal">field_coins</code> and <code class="literal">field_radius</code>, set the number of coins and the radius of the circular gold field, respectively. These are optional arguments with default values, as shown in the <code class="literal">__init__</code> method. The third optional argument, <code class="literal">search_radius</code>, helps define the radius of the smaller search<a id="id541" class="indexterm"/> circles.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">x_ref</code> and <code class="literal">y_ref</code> variables represent the <em>center</em> of the current search circle. We simplified the problem by assuming a constant <code class="literal">y_ref</code> of <code class="literal">0.0</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">play</code> method starts by generating random points representing the scattered gold coins. The <code class="literal">generate_random_points</code> function returns two Python lists containing the <code class="literal">x</code> and <code class="literal">y</code> coordinates of all the coins on the field.</li><li class="listitem" style="list-style-type: disc">In a <code class="literal">while</code> loop, the <code class="literal">total_collected_coins</code> list stores the coordinates of coins inside the <em>search circles</em>, starting with the leftmost one.</li><li class="listitem" style="list-style-type: disc">The actual search operation is performed by the <code class="literal">find_coins</code> method.</li></ul></div><p>Next, let's review the <code class="literal">GoldHunt.find_coins</code> method:</p><div><img src="img/B05034_07_04.jpg" alt="Reviewing the initial code"/></div><p>This method loops over all the points (gold coins) on the field and for each point, it computes its distance from the center of the search circle. With this distance, we can determine whether or not the given gold coin lies inside the perimeter of the search circle. This is shown schematically in the following diagram. The <code class="literal">(x_ref, y_ref)</code> coordinates represent the center of the search circle. The <code class="literal">(x, y)</code> parameters are the coordinates of any gold coin on the field.</p><div><img src="img/B05034_07_05.jpg" alt="Reviewing the initial code"/></div><p>In this diagram, the<a id="id542" class="indexterm"/> distance between a point and the center is represented by <strong>dist</strong>. It shows two representative points (or coins). The first one with a <em>check mark</em> next to it lies inside the circle, whereas the other one with a <em>cross mark</em> is outside. Only the point lying inside the circle is collected. The method returns a <code class="literal">collected_coins</code> list that contains the location tuples <code class="literal">(x,y)</code> of all such points.</p><p>Let's review the function that creates random points on the field:</p><div><img src="img/B05034_07_06.jpg" alt="Reviewing the initial code"/></div><p>You should be able to understand this code fragment fairly easily if you have a basic math background. Here is how it works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Consider a point with radius <code class="literal">r</code> and an angle <code class="literal">theta</code>.</li><li class="listitem" style="list-style-type: disc">The Cartesian coordinates of this point are <em>x = r*cos(theta)</em> and <em>y = r*sin(theta)</em>.</li><li class="listitem" style="list-style-type: disc">The built-in function, <code class="literal">random.uniform</code>, is used to randomly vary <code class="literal">r</code> between <code class="literal">0.0</code> (the field center) and <code class="literal">ref_radius</code> (the field radius). Note that the <code class="literal">import</code> statements are not shown. For that, refer to <code class="literal">goldhunt_inefficient.py</code>.</li><li class="listitem" style="list-style-type: disc">Similarly, the <code class="literal">theta</code> angle<a id="id543" class="indexterm"/> is randomly varied between <code class="literal">0.0</code> and <code class="literal">2*math.pi</code> (360 degrees).</li></ul></div><div><div><h3 class="title"><a id="tip70"/>Tip</h3><p>
<strong>Plotting the points</strong>
</p><p>You can visualize the generated random distribution of gold coins using <a id="id544" class="indexterm"/>
<strong>matplotlib</strong>, a Python plotting library. We won't discuss the plotting techniques here. Check out their website (<a class="ulink" href="http://matplotlib.org">http://matplotlib.org</a>) that hosts a number of tutorials and installation instructions. Python distributions, such as Anaconda, come preinstalled with matplotlib. You can also use the plotting function, <code class="literal">plot_points</code>, provided in the <code class="literal">goldhunt_inefficient.py</code> file.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec135"/>Running the code</h2></div></div></div><p>The main execution<a id="id545" class="indexterm"/> code is as follows:</p><div><pre class="programlisting">if __name__ == '__main__': 
    game = GoldHunt() 
    game.play()</pre></div><p>This code uses the default arguments to instantiate <code class="literal">GoldHunt</code>. With the default arguments, the code should run smoothly and finish within a few seconds. The actual time will vary depending on your machine configuration, available RAM, and so on. You can add some informative <code class="literal">print</code> statements to see how the game is progressing. Here is a sample output using the default arguments:</p><div><pre class="programlisting">
<strong>[user@hostname ch7]$ python goldhunt_inefficient.py </strong>
<strong>Circle# 1, center:(-9.0, 0.0), coins: 55 </strong>
<strong>Circle# 2, center:(-7.0, 0.0), coins: 37 </strong>
<strong>Circle# 3, center:(-5.0, 0.0), coins: 54 </strong>
<strong>Circle# 4, center:(-3.0, 0.0), coins: 47 </strong>
<strong>Circle# 5, center:(-1.0, 0.0), coins: 53 </strong>
<strong>Circle# 6, center:(1.0, 0.0), coins: 60 </strong>
<strong>Circle# 7, center:(3.0, 0.0), coins: 44 </strong>
<strong>Circle# 8, center:(5.0, 0.0), coins: 50 </strong>
<strong>Circle# 9, center:(7.0, 0.0), coins: 51 </strong>
<strong>Circle# 10, center:(9.0, 0.0), coins: 51 </strong>
<strong>Total_collected_coins = 502</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec62"/>The problem</h1></div></div></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>In the game scenario, you allowed the users to tweak certain parameters. For example, the users can control the <strong>total number of coins</strong> on the field or modify the <strong>radius of the search circle</strong>. Unknowingly, you opened a new can of worms. For a large input size, the program runs very slow. For example, one variant of the game, <strong>The Great Dwarf of the Foo mountain</strong>, is performing the gold hunt. Let's hear what he has to say:</em>
</p>
</td></tr></tbody></table></div><div><img src="img/B05034_07_07.jpg" alt="The problem"/></div><p>If you<a id="id546" class="indexterm"/> change <code class="literal">field_coins</code> from <code class="literal">5000</code> to <code class="literal">1000000</code> and set <code class="literal">search_radius</code> to <code class="literal">0.1</code>, the application will take quite a bit of time to finish. Here is the updated main execution code with these new parameters:</p><div><pre class="programlisting">if __name__ == '__main__': 
    game = GoldHunt(field_coins=1000000, search_radius=0.1) 
    game.play() </pre></div><p>If you increase the coins further or make the search radius even smaller, it will severely affect the application runtime.</p><div><div><h3 class="title"><a id="tip71"/>Tip</h3><p>
<strong>Warning!</strong>
</p><p>If you run the following code, depending on your machine configuration, it can slow down your machine, take longer time to finish, and in some cases (a machine with an average configuration) the computer can stop responding. If you are unsure, it is better not to run it! It is presented here just as an example. If you really want to, then do it at your own risk!</p></div></div><p>For example, it can <a id="id547" class="indexterm"/>take several seconds or minutes to complete this operation. What can we do here to improve the performance? Before jumping to that, let's first review some techniques to identify the bottlenecks.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Identifying the bottlenecks</h1></div></div></div><p>In the previous section, we <a id="id548" class="indexterm"/>saw how a different choice of input<a id="id549" class="indexterm"/> parameters degrades the application runtime. Now, we need some way to accurately measure the execution time and find out the performance bottlenecks or the time consuming blocks of the code.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec136"/>Measuring the execution time</h2></div></div></div><p>Let's start by monitoring the time<a id="id550" class="indexterm"/> taken by the application. To do this, we will use Python's built-in <code class="literal">time</code> module. The <code class="literal">time.perf_counter</code> function is a performance counter that returns a clock with the highest available resolution. This function can be used to determine the time interval or the system-wide time difference between the two consecutive calls to the function.</p><div><div><h3 class="title"><a id="tip72"/>Tip</h3><p>The <code class="literal">time.perf_counter</code> function is available in Python versions 3.3 onwards. If you have an older version of Python (for example, version 2.7), use <code class="literal">time.clock()</code> instead. On Unix, <code class="literal">time.clock()</code> returns a floating point number within seconds that represents the processor time. On Windows, it returns the elapsed wall-clock time within seconds after the first call to the function.</p></div></div><p>The original file, <code class="literal">goldhunt_inefficient.py</code>, already has the following code:</p><div><pre class="programlisting">import time

if __name__ == '__main__': 
    start = time.perf_counter() 
    game = GoldHunt() 
    game.play() 
    end = time.perf_counter() 
    print("Total time interval:", end - start)</pre></div><p>At the beginning of the file, we import the <code class="literal">time</code> module. The <code class="literal">start</code> variable marks the beginning of the performance counter, and the <code class="literal">end</code> variable represents its second consecutive call. In between, we will run the main execution code. The difference between the two values of the counter can be used as an indicator for the runtime of the application. Similarly, you can insert these <a id="id551" class="indexterm"/>calls elsewhere in the code to monitor individual code fragments.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec137"/>Measuring the runtime of small code snippets</h2></div></div></div><p>The built-in <code class="literal">timeit</code> module is <a id="id552" class="indexterm"/>a useful tool for quickly checking the execution time of a small code fragment. It can be used from the command line or imported and called inside the code. Here is one way to use this functionality using the command-line interface:</p><div><pre class="programlisting">
<strong>$ python -m timeit "x = 100*100" </strong>
<strong>100000000 loops, best of 3: 0.0155 usec per loop</strong>
</pre></div><p>The <code class="literal">-m</code> option allows running the <code class="literal">timeit</code> module from the command line. In the preceding example, it measures the execution time for the <code class="literal">x = 100*100</code> statement.</p><p>Let's review the output of this execution. The <code class="literal">100000000 loops</code> in the output indicates how many times the code is executed by <code class="literal">timeit</code>. It reports the best of three timings. In this example, the best time taken is <code class="literal">0.0155</code> microseconds for a single execution. You can also tweak the number of times the code is run by using the <code class="literal">--number</code> argument, as shown in the following code snippet. Here, the code is run only <code class="literal">10</code> times:</p><div><pre class="programlisting">
<strong>$ python -m timeit --number=10  "x = 100*100" </strong>
<strong>10 loops, best of 3: 0.0838 usec per loop </strong>
</pre></div><p>Internally, <code class="literal">timeit</code> <a id="id553" class="indexterm"/>uses <code class="literal">time.perf_counter</code> to measure the time taken. This is the default implementation since Python version 3.3. For further details, check out the documentation (<a class="ulink" href="https://docs.python.org/3/library/timeit.html">https://docs.python.org/3/library/timeit.html</a>).</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec138"/>Code profiling</h2></div></div></div><p>The performance measurement <a id="id554" class="indexterm"/>techniques that we have seen so far work quite well, especially when you want to run benchmarks for the application. However, it is often cumbersome to implement these timers throughout your project to get a full execution profile. This is where the code profiling helps. It is a technique that analyzes a program while it is running and gathers some important statistics. For example, it reports the duration and frequency of various function calls within that program. This information can be used to identify the performance bottlenecks in the code.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec59"/>The cProfile module</h3></div></div></div><p>Let's see how to use <code class="literal">cProfile</code>, Python's <a id="id555" class="indexterm"/>built-in module for code profiling. For illustration purposes, we will use the <code class="literal">profile_ex.py</code> file from the supporting code bundle. It has three simple functions that do some trivial tasks, as shown in the following screenshot:</p><div><img src="img/B05034_07_08.jpg" alt="The cProfile module"/></div><p>The <code class="literal">cProfile</code> command can either be run from the command prompt or by importing it inside the module to be tested. Here is the output when run from the Command Prompt:</p><div><img src="img/B05034_07_09.jpg" alt="The cProfile module"/></div><div><div><h3 class="title"><a id="note22"/>Note</h3><p>The<strong> IPython</strong> interactive shell<a id="id556" class="indexterm"/> also provides a convenient magic command called <code class="literal">%prun</code>. With this, you can quickly profile a Python statement. For more <a id="id557" class="indexterm"/>information, check out <a class="ulink" href="https://ipython.org/ipython-doc/3/interactive/magics.html">https://ipython.org/ipython-doc/3/interactive/magics.html</a>.</p></div></div><p>Let's understand the output of this run:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first line of the <a id="id558" class="indexterm"/>output shows the total number of function calls monitored. A majority of these are due to <code class="literal">for loop</code> inside <code class="literal">test_2</code>. For each iteration, it calls the <code class="literal">append</code> function of the Python <code class="literal">list</code> datatype.</li><li class="listitem" style="list-style-type: disc">On the same output line, it also reports the number of <code class="literal">primitive calls</code>. These are the function calls that do not involve <a id="id559" class="indexterm"/><strong>recursion</strong>. The <code class="literal">test_3</code> function shows an example of recursion. To understand this better, run the code by printing the value of the input argument <code class="literal">condition</code>. In this case, there is only one recursive function call.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">ncalls</code> column indicates the number of function calls. If you add them up, the total number of calls becomes <code class="literal">10007</code>, same as the ones reported on the first line of the output. Notice that for <code class="literal">test_3</code>, it reports the function calls as <code class="literal">2/1</code>. It means that the function was called twice but one of the calls was recursive.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">tottime</code> column indicates the total time spent in a given function.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">percall</code> column records the quotient of the <code class="literal">totcall/ncalls</code> division.</li><li class="listitem" style="list-style-type: disc">The time spent inside a particular function, including its sub-functions, is reported by <code class="literal">cumtime</code> (the cumulative time).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">percall</code> column reports the <code class="literal">cumtime</code>/<code class="literal">primitive calls</code> quotient.</li><li class="listitem" style="list-style-type: disc">The last column is, essentially, the data related to the functions. It includes the built-in function calls, such as the <code class="literal">append</code> method of the Python <code class="literal">list</code>, and so on.</li></ul></div><p>By default, the output is sorted <a id="id560" class="indexterm"/>by <code class="literal">standard name</code>. To understand the bottlenecks, this sorting order is not quite useful. Instead, you can sort by cumulative time, number of function calls, and so on. This is accomplished using the command-line option, <code class="literal">-s</code>. For a complete list of available <a id="id561" class="indexterm"/>sorting options, refer to <a class="ulink" href="https://docs.python.org/3/library/profile.html">https://docs.python.org/3/library/profile.html</a>. </p><p>The following screenshot shows the output sorted by <code class="literal">tottime</code>. Observe that it spends the most time in the <code class="literal">test_2</code> function.</p><div><img src="img/B05034_07_10.jpg" alt="The cProfile module"/></div><p>Now that we know how to use <code class="literal">cProfile</code>, let's use it to analyze the <em>Gold Hunt</em> problem. Run the original <code class="literal">goldhunt_inefficient.py</code> file with all the default options, as follows:</p><div><pre class="programlisting">
<strong>$ python -m cProfile goldhunt_inefficient.py </strong>
</pre></div><p>It prints a lot of information in the terminal window as there are several of the internal function calls involved. Optionally, you can redirect <code class="literal">stdout</code> to a text file. To effectively analyze this data, Python provides a built-in module called <code class="literal">pstats</code>. Let's see how to use it in the following section.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec60"/>The pstats module</h3></div></div></div><p>The <code class="literal">pstats</code> module<a id="id562" class="indexterm"/> can be used to further process the profiling data generated by <code class="literal">cProfile</code>. It gives you greater control over creating your reports as compared to the limited options provided by <code class="literal">cProfile</code>. The analysis of the data generated by <code class="literal">cProfile</code> is done using the <code class="literal">pstats.Stats</code> class. To make the <code class="literal">cProfile</code> output usable by <code class="literal">pstats</code>, we will need to write it to a file using the command-line option, <code class="literal">-o</code>, as follows:</p><div><pre class="programlisting">
<strong>$ python -m cProfile -o profile_output goldhunt_inefficient.py </strong>
</pre></div><p>The <code class="literal">profile_output</code> file, thus generated, is not human readable. While we can go on and feed this file to <code class="literal">pstats.Stats</code>, it is better to automate the whole process by stitching together these two utilities. Here is a simplified code that does this:</p><div><img src="img/B05034_07_11.jpg" alt="The pstats module"/></div><div><div><h3 class="title"><a id="tip73"/>Tip</h3><p>
<strong>Warning</strong>
</p><p>This is a simplified example without any error checks! For example, the code does not check if the output file already exists. To make the code robust, add such checks and the <code class="literal">try…except</code> clauses wherever appropriate.</p></div></div><p>This code is also available as <code class="literal">profiling_goldhunt.py</code> in the supporting code bundle for this chapter. Let's quickly review what this code does:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The main execution code shows a way to run <code class="literal">cProfile</code> using its <code class="literal">run</code> method. The first argument to <code class="literal">run</code> is the function (or statement) to be monitored, whereas the second argument is the filename where the profiling output is stored.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">view_stats</code> function is where we use the functionality from <code class="literal">pstats</code>. This function takes the generated profiling output (<code class="literal">filname</code>) as the first argument. It is used while creating an instance of <code class="literal">pstats.Stats</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">strip_dirs</code> method of the <code class="literal">Stats</code> class is used to remove all leading path information strings from filenames. This reduces the clutter in the final output by just displaying the name of the file.</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">print_stats</code> <a id="id563" class="indexterm"/>method, we can impose some restrictions in the final output. In this example, it looks for the <code class="literal">goldhunt</code> string in the rightmost columns and displays the matching row, ignoring all others. Put in another way, it limits the information related to the function calls inside <code class="literal">goldhunt_inefficient.py</code>.</li></ul></div><div><div><h3 class="title"><a id="note23"/>Note</h3><p>The <code class="literal">pstats.Stats</code> class<a id="id564" class="indexterm"/> provides several other useful features. For example, the <code class="literal">print_callees</code> method prints a list of all the functions that were called by the function being monitored. For further details, check out the Python documentation (<a class="ulink" href="https://docs.python.org/3/library/profile.html#pstats.Stats">https://docs.python.org/3/library/profile.html#pstats.Stats</a>).</p></div></div><p>This code can be run from the command prompt, as follows (it has a dependency on <code class="literal">goldhunt_inefficient.py</code> so put it in the same directory as this file):</p><div><pre class="programlisting">
<strong>$ python profiling_goldhunt.py</strong>
</pre></div><p>Here is the sample output of this run (only the output pertaining to the statistics is shown):</p><div><img src="img/B05034_07_12.jpg" alt="The pstats module"/></div><p>This is significantly less output and <a id="id565" class="indexterm"/>is restricted to the function calls from the program we wish to monitor. As indicated in the output, only <code class="literal">5</code> out of <code class="literal">19</code> function calls are listed. The list is sorted by the total internal time taken to execute the functions. The two functions, <code class="literal">find_coins</code> and <code class="literal">generate_random_points</code>, top the chart! Their order may vary depending on the values we choose for the <code class="literal">field_coins</code> and <code class="literal">search_radius</code> variables. But essentially, the code profiling has helped us identify the most time consuming code in our application.</p><div><img src="img/B05034_07_13.jpg" alt="The pstats module"/></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>Good question! It will certainly help if we can peep inside the function and see the line-by-line profiling output. Luckily, there is a tool that enables exactly this. Let's review it next.</em>
</p>
</td></tr></tbody></table></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec61"/>The line_profiler package</h3></div></div></div><p>The <code class="literal">line_profiler</code> package<a id="id566" class="indexterm"/> is a third-party Python package that can be installed using <code class="literal">pip</code>:</p><div><pre class="programlisting">
<strong>$ pip install line_profiler</strong>
</pre></div><p>This package can be used to monitor the performance of a function, line by line. When you install the package, it also creates an executable <code class="literal">kernprof</code>.</p><p>On Linux, this executable is created at the same location as your Python executable. For example, on Linux, if Python is available as <code class="literal">/usr/bin/python</code>, this executable is created as <code class="literal">/usr/bin/kernprof</code> (or look for the <code class="literal">kernprof.py</code> script). On Windows OS, it should be created at the same location as <code class="literal">pip.exe</code>. Refer to <a class="link" href="ch01.html" title="Chapter 1. Developing Simple Applications">Chapter 1</a>, <em>Developing Simple Applications</em> for the <code class="literal">pip.exe</code> path.</p><div><div><h3 class="title"><a id="tip74"/>Tip</h3><p>On Windows OS, if you encounter any error, such as <strong>error: Unable to find vcvarsall.bat</strong>, you will probably need to use<a id="id567" class="indexterm"/> Visual C++ Express. Check out <a class="ulink" href="https://www.visualstudio.com/en-US/products/visual-studio-express-vs">https://www.visualstudio.com/en-US/products/visual-studio-express-vs</a> for more information.</p></div></div><p>Using this tool requires trivial changes to the code. All you need to do is add a <code class="literal">@profile</code> decorator above the function or method name, as shown in the following screenshot:</p><div><img src="img/B05034_07_14.jpg" alt="The line_profiler package"/></div><p>Then, run the tool using the <code class="literal">kernprof</code> command as follows:</p><div><pre class="programlisting">
<strong>$ kernprof -v -l goldhunt_inefficient.py</strong>
</pre></div><p>The <code class="literal">-v</code> or <code class="literal">--view</code> option displays the results of the profile output in the terminal window. The profiler also creates an output file, <code class="literal">goldhunt_inefficient.py.lprof</code>. The <code class="literal">-l</code> or <code class="literal">--line-by-line</code> option uses the line-by-line profiler from the <code class="literal">line_profiler</code> module.</p><div><div><h3 class="title"><a id="tip75"/>Tip</h3><p>Be sure to remove the decorator <code class="literal">@profile</code> when you are not profiling the application using the <code class="literal">line_profiler</code>. In other words, remove it while running the application, as:</p><div><pre class="programlisting">
<strong>$ python goldhunt_inefficient.py</strong>
</pre></div><p>Otherwise, it will raise a <code class="literal">NameError</code> exception.</p></div></div><p>The <code class="literal">line_profiler</code> output for the <code class="literal">find_coins</code> method is shown below.</p><p>As you can see, quite a<a id="id568" class="indexterm"/> bit of time is spent computing the distance between the points (gold coins) and the center of the search circle.</p><div><img src="img/B05034_07_15.jpg" alt="The line_profiler package"/></div><p>Similarly, if you see the output for the <code class="literal">generate_random_point</code> function, the majority of the time is spent while creating a random combination of the <code class="literal">theta</code> angle and the <code class="literal">r</code> radius, which is used to define a point (a gold coin).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Memory profiling</h1></div></div></div><p>The profiling techniques we have covered so <a id="id569" class="indexterm"/>far aim at finding the runtime bottlenecks. Let's briefly discuss memory profiling, another important aspect of profiling.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec139"/>The memory_profiler package</h2></div></div></div><p>For memory profiling, we will use a popular <a id="id570" class="indexterm"/>Python package called <code class="literal">memory_profiler</code>. It can be installed using <code class="literal">pip</code>. Here is how to install it on Linux from the command line:</p><div><pre class="programlisting">
<strong>$ pip install memory_profiler</strong>
</pre></div><p>The documentation highly recommends installing the <code class="literal">psutils</code> module. It also suggests that, in order for <code class="literal">memory_profiler</code> to work on Windows OS, you will need the <code class="literal">psutil</code> module. The <code class="literal">psutil</code> module can be installed using <code class="literal">pip</code>, as follows:</p><div><pre class="programlisting">
<strong>$ pip install psutil </strong>
</pre></div><div><div><h3 class="title"><a id="tip77"/>Tip</h3><p>For more information<a id="id571" class="indexterm"/> on <code class="literal">memory_profiler</code>, check out the following page: <a class="ulink" href="https://pypi.python.org/pypi/memory_profiler">https://pypi.python.org/pypi/memory_profiler</a>.</p></div></div><p>Just like <code class="literal">line_profiler</code>, the <code class="literal">memory_profiler</code> package uses the <code class="literal">@profile</code> decorator above the function name. Let's add the decorator <code class="literal">@profile</code> just above the <code class="literal">generate_random_points</code> function, and then run the memory profiler on the <code class="literal">goldhunt_inefficient.py</code> file. The command to run this is as follows:</p><div><pre class="programlisting">
<strong>$ python -m memory_profiler goldhunt_inefficient.py</strong>
</pre></div><p>Here is the output of the memory profiler. It reports the line-by-line memory consumption. Note that the profiler prints the whole function, including the docstrings. For ease of illustration, part of the docstring is not shown.</p><div><img src="img/B05034_07_16.jpg" alt="The memory_profiler package"/></div><p>The line number in the code is shown in the first column. The second column, <code class="literal">Mem Usage</code>, tells us how much memory the Python interpreter consumes after executing that line number. The unit of the memory is <a id="id572" class="indexterm"/>
<strong>mebibyte</strong> (<strong>MiB</strong>).The third column, <code class="literal">Increment</code>, gives the memory difference between the current line and the previous line. If the memory is released by the current line of code, then the <code class="literal">Increment</code> column shows a negative number. The last column shows the actual line of code. As can be seen from the <code class="literal">Increment</code> column, the memory is mainly consumed in the <code class="literal">for</code> loop. We will use the memory profiler in the next chapter to compare the memory efficiency of a <strong>generator expression</strong>
<a id="id573" class="indexterm"/> and a<a id="id574" class="indexterm"/> <strong>list comprehension</strong>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Algorithm efficiency and complexity</h1></div></div></div><p>An algorithm is a set of instructions to solve a particular problem. In this context, an algorithm can be a function or even a simple operation that adds two numbers. Let's understand two related terms: algorithm efficiency and algorithm complexity.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec140"/>Algorithm efficiency</h2></div></div></div><p>Algorithm efficiency<a id="id575" class="indexterm"/> indicates the computation resources consumed by an algorithm. Typically, the lower the resource consumption, the better the efficiency. The computational resources can mean several things. One can be talking about the runtime (CPU usage), the memory consumption (RAM or hard disk) or the network consumption, or a combination of these. </p><p>The application requirement determines which resource takes precedence over the others. For example, in a web application, the network usage can be more important than the disk space. For a scientific application, you might have all the memory you need but the runtime can be a pain in the neck, and so on. In this book, we will limit our discussion to the runtime efficiency only.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec141"/>Algorithm complexity</h2></div></div></div><p>Suppose you have a program (an algorithm) that<a id="id576" class="indexterm"/> processes some data in five minutes. If you increase the size of the data, how much time will the program need? The answer lies in the algorithm complexity. It tells us how well the algorithm will scale if you increase the size of the problem. In other words, the computational complexity influences the performance of the algorithm. In the next section, you will learn how to represent the computational complexity.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Big O notation</h1></div></div></div><p>In simple terms, the big O or <a id="id577" class="indexterm"/>big Oh notation is a way to represent the computational complexity of an algorithm. Here, the O is the letter <em>O</em>, as in <em>order</em>, and not the number zero. The big O indicates an upper bound or the worst-case scenario of the complexity of an algorithm (details to follow in the next section). This concept can be better explained with an example. Let's take a look at the following code:</p><div><pre class="programlisting">num = 100 
x = []
for i in range(num): 
    x.append(i)</pre></div><p>Let's call this trivial code fragment an algorithm. It is a simple operation that appends a number to the <code class="literal">list</code> inside a <code class="literal">for</code> loop. Here, <code class="literal">num</code> represents the size of the input used by the algorithm. If you increase <code class="literal">num</code>, the algorithm will have to do more work inside the <code class="literal">for</code> loop. Increase it further, and the poor algorithm will have to do even more work. Thus, the time taken by the algorithm depends on the value of <code class="literal">num</code> and can be expressed as a growth function, <em>f(n)</em>. Here,<em> n</em> represents the size of the input that corresponds to <code class="literal">num</code> in this example.</p><div><div><h3 class="title"><a id="tip78"/>Tip</h3><p>Making sense so far? You can also test this by measuring the execution time. To see a real difference, choose a larger value of <code class="literal">num</code>.</p></div></div><p>In this algorithm, the <a id="id578" class="indexterm"/>most time consuming piece is the <code class="literal">for</code> loop, and it will determine the overall runtime of the algorithm. Inside the <code class="literal">for</code> loop, each call to <code class="literal">x.append(i)</code> takes constant time, <em>t</em>, to finish. For a large value of <code class="literal">num</code>, the total time taken by the loop will be approximately <em>num*(t)</em>. Thus, the runtime efficiency of the whole algorithm relative to <code class="literal">num</code> is linear. In terms of the big O notation, this particular algorithm is said to have <em>O(n)</em> complexity.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec142"/>Big O complexity classes</h2></div></div></div><p>Let's review some <a id="id579" class="indexterm"/>big O complexity classes. The following chart annotates various complexity classes and shows how <em>f(n)</em> influences the running time of algorithms:</p><div><img src="img/B05034_07_17.jpg" alt="Big O complexity classes"/></div><p>On the <em>y</em> axis, we have the <em>f(n)</em> function, and the <em>x</em> axis represents the input size, <em>n</em> (the <code class="literal">num</code> variable in the previous discussion). The plot compares some common functions that represent the time <a id="id580" class="indexterm"/>complexity of algorithms.</p><p>It should be noted that the big O representation does not include the constants. So, even if two algorithms share the same big O complexity, they can clock a very different runtime performance. The circle marker in the plot shows a typical crossover point between two complexity functions. In this example, this is between <em>O(n)</em> and <em>O(n log n)</em>. As noted earlier, the individual algorithms representing these complexity functions will have different constant multipliers (not reflected in the big O notation). Tweaking those multipliers can change where this crossover happens.</p><p>Let's briefly review these notations now.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec62"/>O(1) – constant time</h3></div></div></div><p>Regardless of the value of the input size, the time taken by the algorithm remains constant. Getting the length of a Python list (<code class="literal">len(x)</code>, where <code class="literal">x</code> is the list) or the <code class="literal">append</code> list operation we saw <a id="id581" class="indexterm"/>earlier, are a few examples of <em>O(1)</em> complexity.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec63"/>O(log n) – logarithmic</h3></div></div></div><p>The time required by the<a id="id582" class="indexterm"/> algorithm is proportional to the logarithm of the input size. One of the examples of logarithmic complexity is a <a id="id583" class="indexterm"/>
<strong>binary search algorithm</strong>. It starts with inspecting the middle element of a sorted array. If the value being searched is lower than the middle element, the entire upper half, including this middle element, is eliminated from the search. We can do this because it is a<a id="id584" class="indexterm"/> <strong>sorted array</strong>. This process is repeated for the remaining half and it continues until we find the desired value.</p><p>Confused? Let's see what Fairy is up to these days…</p><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>Fairy has lost her enchanted locket in a room full of treasure chests. These boxes are numbered 1 to 100 and are arranged in increasing order. In other words, the boxes are sorted and the locket is placed in one of them. She is trying to find it with the help of her magical wand. The wand knows that the locket is in, for instance, box number 82, but it won't give a straight answer! It expects her to ask the right questions.</em>
</p>
<p>
<em>She is standing exactly in the middle of the room and in front of box 50. Towards her left, she sees numbers 1 to 49; and towards the right, numbers 51 to 100, in that order.</em>
</p>
<p>
<em>She asks her wand, is the locket in box 50? The wand says "no". She further asks, is the number greater than 50 or less than 50? The wand answers "greater than 50".</em>
</p>
<p>
<em>With this answer, she ignores the boxes on the left side (1-49), including box 50, and stands in the middle of the group, to her right (51-100). Now, she has box 75 in front of her. She repeats the questions with box 75 as the reference. Each time, half of the remaining chests are eliminated. The search operation goes on until she finds her locket in box 82.</em>
</p>
</td></tr></tbody></table></div><p>This is the binary search in a nutshell. You can find more <a id="id585" class="indexterm"/>information on Wikipedia (<a class="ulink" href="https://en.wikipedia.org/wiki/Binary_search_algorithm">https://en.wikipedia.org/wiki/Binary_search_algorithm</a>). In the worst case scenario, the time complexity of this search is <em>O(log n)</em>. Another way to look at the logarithmic complexity is as follows. For an exponential increase in the size of the problem <em>n</em>, the time taken by the algorithm increases linearly. As can be seen in the earlier chart, the <em>O(log n)</em> time complexity is better compared to the <em>O(n)</em> (linear-time) complexity, but not as good as <em>O(1)</em>.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec64"/>O(n) – Linear time</h3></div></div></div><p>We already saw an example<a id="id586" class="indexterm"/> where a <code class="literal">for</code> loop makes the algorithm of the <em>O(n)</em> complexity. Finding a min or max element in a Python list and copying a list or a dictionary are some other examples of this complexity.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec65"/>O(n log n) – Log linear</h3></div></div></div><p>An example of a log linear time<a id="id587" class="indexterm"/> complexity is a <a id="id588" class="indexterm"/>
<strong>quicksort algorithm</strong>. Let's call Fairy one more time to get a better idea of the working of this algorithm.</p><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>Fairy enters another treasure room and finds it extremely disorganized. The treasure chests are randomly scattered everywhere in the room. Not liking this, she decides to sort the chests in an increasing order of their value (or price). Initially, the chests are randomly placed, like this:</em>
</p>
<p>
<em>[5 3 2 4 9 7 8 8 ]</em>
</p>
<p>
<em>Here, the number represents the value of each chest. Fairy starts picking a pivot chest, say with a value tag of 5. She then rearranges the chests into three sections: (i) The ones with a value lower than 5 are on the left side of the pivot, (ii) the pivotal chest 5, (iii) and the values greater than 5 are on the right side. This is shown below:</em>
</p>
<p>
<em>[3 2 4   5   9 7 8 8 ]</em>
</p>
<p>
<em>Next, with 5 fixed to its position, she repeats the preceding procedure to the items on the left and right sides of 5. For example, consider only the left side of 5:</em>
</p>
<p>
<em>[3 2 4]</em>
</p>
<p>
<em>The fairy chooses number 3 as a new pivot and arranges the values to the left and right of 3, as shown earlier. This rearrangement results in:</em>
</p>
<p>
<em>[2 3 4]</em>
</p>
<p>
<em>The process goes on until all the chests are sorted in the increasing order of the valuables, as shown below:</em>
</p>
<p>
<em>[2 3 4 5 7 8 8 9]</em>
</p>
</td></tr></tbody></table></div><p>This is the basic quicksort operation and has the complexity of <em>O(n log n)</em>. As shown in the earlier chart, for a higher value of <em>n</em>, the <em>O(n log n)</em> complexity is expensive compared to <em>O(n)</em>, but it is much <a id="id589" class="indexterm"/>better than the quadratic complexity.</p><div><div><h3 class="title"><a id="tip79"/>Tip</h3><p>It should be noted that <em>O(n log n)</em> is the <strong>average-case</strong> complexity<a id="id590" class="indexterm"/> of the quicksort algorithm. Refer to the section, <em>Upper bound (worst-case) of the complexity</em>, of this chapter to learn about average-case and worst-case complexities.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec66"/>O(n<sup>2</sup>) – Quadratic</h3></div></div></div><p>This represents the quadratic<a id="id591" class="indexterm"/> runtime complexity. The time required to run the program grows as square of the size of the input to the algorithm. Let's extend the previous example to understand this further:</p><div><pre class="programlisting">num = 100 
x = [] 
for i in range(num): 
    for j in range(num): 
        x.append(i) </pre></div><p>It is a nested <code class="literal">for</code> loop. Let <em>t</em> be the time it takes to append an element to the list. As mentioned earlier, a single append operation is of <em>O(1)</em> complexity. The inner <code class="literal">for</code> loop will take approximately <em>n*t</em> (or <em>num*t</em>) to execute. Since we have an outer <code class="literal">for</code> loop, the total time complexity becomes <em>n*(n*t)</em>. A classic example of this complexity is a <strong>bubble sort algorithm</strong>
<a id="id592" class="indexterm"/> (<a class="ulink" href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a>). This algorithm sorts a list in an iterative manner, and it repeatedly swaps the adjacent elements of the list if these elements are placed in a wrong order.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec67"/>O(n<sup>3</sup>) – cubic</h3></div></div></div><p>This is a cubic complexity, which<a id="id593" class="indexterm"/> is worse than the quadratic complexity. A small increase in the problem size will result in a big increase in the runtime. Adding another outer <code class="literal">for</code> loop in the illustration on quadratic complexity will make it <em>O(n<strong>3</strong>)</em>.</p><div><div><h3 class="title"><a id="tip80"/>Tip</h3><p>This is only a partial list of complexity<a id="id594" class="indexterm"/> classes. There are many more. For further information, check out <a class="ulink" href="https://en.wikipedia.org/wiki/Big_O_notation">https://en.wikipedia.org/wiki/Big_O_notation</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec68"/>Upper bound of the complexity</h3></div></div></div><p>Let's revisit the <a id="id595" class="indexterm"/>statement we made earlier: "Big O notation indicates an upper bound or the worst-case scenario of the complexity of an algorithm". Quite a mouthful? An explanation is in order. We will reuse the illustration used in the discussion on the <em>O(n<sup>2</sup>)</em> complexity:</p><div><pre class="programlisting">num = 100 
x = [] 
for i in range(num): 
    for j in range(num): 
        x.append(i) </pre></div><p>We already saw that a single <code class="literal">x.append(i)</code> operation is <em>O(1)</em>, the inner loop is <em>O(N)</em>, and the full nested <code class="literal">for</code> loop has the time complexity of <em>O(n<sup>2</sup>)</em>. Then why do we say that the complexity of the algorithm as a whole is <em>O(n<sup>2</sup>)</em>?</p><p>If you look at the earlier chart that compared various complexities, <em>O(n<sup>2</sup>)</em> is the costliest among these three complexities and thus the most significant part of it. In other words, the algorithm complexity cannot get worse than <em>O(n<sup>2</sup>)</em>. Now, read the earlier statement on upper bounds one more time. The big O notation represents the worst-case scenario of the complexity of the algorithm. This is the reason why the big O complexity class for this algorithm is represented as <em>O(n<sup>2</sup>)</em>.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>
<strong>Average-case time complexity:</strong>
</p><p>Most of the time, an <a id="id596" class="indexterm"/>algorithm is analyzed by measuring its worst-case complexity. However, there are some problems where it makes practical sense to measure the<a id="id597" class="indexterm"/> <strong>average-case time complexity</strong>. Here, the amount of time taken to run the algorithm is averaged over all possible inputs. The quicksort algorithm we saw earlier is a classic example where average-case complexity is useful. It determines the real (or practical) efficiency of the algorithm. The average-case time complexity of this algorithm is <em>O(n log n),</em> whereas the worst-case <a id="id598" class="indexterm"/>complexity is <em>O(n<sup>2</sup>)</em>. For more information, check out <a class="ulink" href="https://en.wikipedia.org/wiki/Average-case_complexity">https://en.wikipedia.org/wiki/Average-case_complexity</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec69"/>Complexity for common data structures and algorithms</h3></div></div></div><p>The following table summarizes the time complexity of a few frequently performed operations on some Python data structures. This is not an exhaustive list, for that, see the Python wiki (<a class="ulink" href="https://wiki.python.org/moin/TimeComplexity">https://wiki.python.org/moin/TimeComplexity</a>). It documents the time complexity of several other operations on these data structures.</p><div><img src="img/B05034_07_23.jpg" alt="Complexity for common data structures and algorithms"/></div><p>The following table summarizes the time complexity of some common algorithms along with the Python functions that implement them. Note that the functions listed are from the NumPy library. Although the next chapter will introduce you to NumPy, we won't specifically talk about these functions in this book.</p><div><img src="img/B05034_07_24.jpg" alt="Complexity for common data structures and algorithms"/></div><p>The first algorithm listed in the preceding table is a binary search algorithm. This was already illustrated when we talked about the <em>O(log n)</em> or logarithmic complexity. The <code class="literal">numpy.searchsorted</code> function uses binary search to find array indices where the elements need to be inserted to maintain order. The remaining algorithms in this table are a few common sorting algorithms that put elements in a list in a specific order. We already talked about quicksort. To learn more about the<a id="id599" class="indexterm"/> other algorithms, refer to <a class="ulink" href="https://en.wikipedia.org/wiki/Sorting_algorithm">https://en.wikipedia.org/wiki/Sorting_algorithm</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec70"/>Wrapping up the big O discussion</h3></div></div></div><p>Let's summarize what you learned about the big O notation so far:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Big O enables us to compare different algorithms in terms of their time (or space) complexity. This helps us choose the right algorithm (if possible) or determine the strategy to implement changes that speed things up.</li><li class="listitem" style="list-style-type: disc">It gives us the growth rate of an algorithm, but it will not give us the absolute value of the runtime. For example, some algorithm A takes 10 minutes to execute. On the same machine, algorithm B takes 200 minutes to execute, and guess what—both algorithms have the same complexity, say <em>O(n)</em>. Although they have different execution times, they have one thing in common, the time taken linearly increases with their problem size.</li></ul></div><div><img src="img/B05034_07_18.jpg" alt="Wrapping up the big O discussion"/></div><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>Glad you brought that up! The big O notation indicates the worst-case scenario of an algorithm, and it rules other (less costly) complexity classes present in that algorithm. In other words, the worst-case complexity drives the performance of that algorithm.</em>
</p>
</td></tr></tbody></table></div><p>It is good to be aware of the complexity, especially when the problem size is large. For a very small problem, it may or may not make a huge difference. A good practice is to analyze the existing algorithm for the performance bottlenecks, and then see if it is worth revamping the algorithm for speedup. Weigh in the factors, such as the time you spend on changing the algorithm and its impact on the quality (bugs and testing) versus the long term benefit of the speedup accomplished. In a nutshell, choose the strategy that best fits your needs.</p><p>It is also worth noting that sometimes you have to live with an algorithm with a certain complexity class. But that is not the end of the road. You can still implement techniques to speedup the code without changing its order of complexity. The performance improvement obtained will depend on the problem in hand. For example, you can parallelize the code or compute some parameters in advance to achieve speedup. Later in this book, we will cover basics of parallelization in Python.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Summary</h1></div></div></div><p>This chapter was the first one in the series of three chapters based on performance. It laid the ground work to improve application performance. We learned how to record the runtime using the <code class="literal">time</code> module. We also saw how the <code class="literal">timeit</code> module can be used to measure the performance of small pieces of code. We took a practical problem where an application ran fine when working with a small input, but, as the input grew larger, it slowed down considerably. With this example, we learned how to identify the bottlenecks using <code class="literal">cProfile</code> and display the results using <code class="literal">pstats</code>.</p><p>We saw how the <code class="literal">line_profiler</code> module can help locate the time consuming statements inside a function. While most of the discussion was focused on the runtime performance, we briefly covered the <code class="literal">memory_profiler</code> module. This module enabled line-by-line analysis of memory consumption for the given functions. Finally, we learned about the big O notation that represents the computational complexity of an algorithm.</p><p>Now that we have identified the performance bottlenecks, let's move on to the next chapter to improve the application performance.</p></div></body></html>