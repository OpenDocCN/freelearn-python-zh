<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Performance &#x2013; Identifying Bottlenecks"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Performance – Identifying Bottlenecks</h1></div></div></div><p>So far, you have learned various ways to make the application robust and accommodating for new features. Now, let's discuss techniques to improve the application performance. This broad topic is split into a series of three chapters—this is the first one in this series. It will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic ways to clock the application runtime</li><li class="listitem" style="list-style-type: disc">How to identify the runtime performance bottlenecks by profiling the code</li><li class="listitem" style="list-style-type: disc">Basic memory profiling with the <code class="literal">memory_profiler</code> package</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Big O</strong></span> notation for the computational complexity</li></ul></div><p>To understand these concepts better, we will develop an interesting game scenario called <span class="emphasis"><em>Gold Hunt</em></span>. You will soon realize that the application runs very slow when you increase the input data size. This chapter will elaborate on techniques to pinpoint such problems.</p><div class="section" title="Overview of three performance chapters"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Overview of three performance chapters</h1></div></div></div><p>Before we dive into the main discussion, let's first understand how the chapters on performance improvement are organized. As mentioned earlier, this discussion is split into a series of three interlinked chapters.</p><div class="section" title="More focus on the runtime performance"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec128"/>More focus on the runtime performance</h2></div></div></div><p>The<a id="id531" class="indexterm"/> term performance improvement can mean several things. One can be talking about improving the runtime (CPU usage), making the application memory efficient, reducing the network consumption, or a combination of these. In this book, we will primarily focus on the runtime performance improvement. We will also discuss the memory consumption aspect, but the discussion will be limited to the <span class="strong"><strong>memory profiling</strong></span>
<a id="id532" class="indexterm"/> technique and the use of generator expressions.</p></div><div class="section" title="The first performance chapter"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec129"/>The first performance chapter</h2></div></div></div><p>You are reading the first chapter in this series. It does some preparatory work to improve the application performance. This preparation involves measuring the runtime, identifying pieces of the code that cause the performance bottlenecks, understanding the big O notation, and so on.</p><div class="mediaobject"><img src="graphics/B05034_07_19.jpg" alt="The first performance chapter"/></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>Of course! We will develop the earlier mentioned <span class="strong"><strong>Gold Hunt scenario</strong></span>, and then identify the performance bottlenecks in the code. The next two chapters will use this groundwork to gradually improve the application performance.</em></span>
</p>
</td></tr></tbody></table></div></div><div class="section" title="The second performance chapter"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec130"/>The second performance chapter</h2></div></div></div><p>The next chapter is all about learning various performance improvement techniques. The first half aims at improving the application runtime for the <span class="emphasis"><em>Gold Hunt</em></span> application. The second half teaches several tricks to optimize the code. The chapter covers some built-in modules designed for high performance and memory efficiency. It also talks about list comprehension, generator expressions, choice of data structures, algorithmic changes, and so on.</p></div><div class="section" title="The third performance chapter"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec131"/>The third performance chapter</h2></div></div></div><p>The last chapter in this series will briefly talk about the <span class="strong"><strong>NumPy</strong></span> package<a id="id533" class="indexterm"/> and <span class="strong"><strong>parallelization</strong></span>
<a id="id534" class="indexterm"/> using the <code class="literal">multiprocessing</code> module in Python. We will use these techniques to drastically improve the runtime performance of the application.</p></div><div class="section" title="Sneak peek at the upcoming application speedup"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec132"/>Sneak peek at the upcoming application speedup</h2></div></div></div><p>Here is a preview of how the <span class="emphasis"><em>Gold Hunt</em></span> program will evolve from a turtle to a rabbit. The following figure shows 	the approximate runtime after each major step of performance improvement. By the time we complete <a class="link" href="ch09.html" title="Chapter 9. Improving Performance – Part Two, NumPy and Parallelization">Chapter 9</a>, <span class="emphasis"><em>Improving Performance – Part two, NumPy and Parallelization</em></span>, the application runtime will be brought down to approximately 14 seconds from an initial value of nearly 106 seconds.</p><div class="mediaobject"><img src="graphics/B05034_07_20.jpg" alt="Sneak peek at the upcoming application speedup"/></div><p>No need to spend any time trying to understand the elements presented in this chart; things will become clear once you read all three chapters on performance. For now, all you need to know is that we will learn some techniques to drastically improve the application runtime in the upcoming chapters.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip69"/>Tip</h3><p>
<span class="strong"><strong>Caution</strong></span>
</p><p>The chapters on performance will show some examples of inefficient code. Running these examples can consume a lot of compute resources. Instead of using the problem size illustrated in these chapters, you should choose an appropriate data size depending on what your machine can handle.</p></div></div></div></div></div>
<div class="section" title="Scenario &#x2013; The Gold Hunt"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Scenario – The Gold Hunt</h1></div></div></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>You recently introduced</em></span>
<a id="id535" class="indexterm"/>
<span class="emphasis"><em> a new scenario in the game—to meet the expenses of his army, Sir Foo is out on a mission to collect gold from a recently acquired territory. The scenario starts with Sir Foo arriving at a place full of gold coins, jewelry, and so on. There are a couple of problems though. Firstly, the gold is scattered all over the field. Secondly, Sir Foo doesn't have time to collect all the gold on the field.</em></span>
</p>
</td></tr></tbody></table></div><div class="mediaobject"><img src="graphics/B05034_07_22.jpg" alt="Scenario – The Gold Hunt"/></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>What you see behind Sir Foo is an imaginary <span class="strong"><strong>gold field</strong></span>. Sir Foo will enter from the left side and travel across the field. He will only collect the coins lying along his path and <span class="strong"><strong>ignore all the remaining gold</strong></span> scattered across the field.</em></span>
</p>
</td></tr></tbody></table></div><p>Let's represent this gold field <a id="id536" class="indexterm"/>as a circle with a radius of nearly 10 miles (diameter of 20 miles), and center located at coordinates <span class="emphasis"><em>x = 0</em></span> and <span class="emphasis"><em>y = 0</em></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B05034_07_01.jpg" alt="Scenario – The Gold Hunt"/></div><p>Observe the following screenshot. The <span class="emphasis"><em>dotted line</em></span> (the diameter of the field) shows the path that Sir Foo traverses on his way out. During this 20 mile journey, he stops at 10 <span class="emphasis"><em>equally spaced points</em></span>. In other words, these points are 2 miles apart, represented by the centers of the small "search circles". For each stop, he collects the gold within a search circle. The total collected gold is the sum of the coins<a id="id537" class="indexterm"/> inside each of those 10 tiny circles. Let's not worry about the gold lying outside of these search circles. </p><p>Assume that the remaining gold on the field is irrelevant for the problem we are solving.</p><div class="mediaobject"><img src="graphics/B05034_07_02.jpg" alt="Scenario – The Gold Hunt"/></div><div class="section" title="High-level algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec133"/>High-level algorithm</h2></div></div></div><p>With the preceding screenshot as <a id="id538" class="indexterm"/>a reference, let's write the high-level algorithm. We will keep it simple. The task is to collect the gold coins found inside each of the small circles in this image (recall that these circles are referred to as <span class="emphasis"><em>search circles</em></span>). We will call the radius of each of these circles a <span class="emphasis"><em>search radius</em></span>. In the present scenario, the search radius is 1 mile, or let's simply call it 1 unit:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Randomly create points representing the gold coins inside a gold field. The gold field is represented by a large circle with a radius of 10 units and center at <span class="emphasis"><em>(x = 0, y = 0)</em></span>. Each gold coin is represented with a <span class="emphasis"><em>(x,y)</em></span> location.</li><li class="listitem">Start with the leftmost search circle, the center of which represents Sir Foo's current location. The coin hunt is constrained within this search circle.</li><li class="listitem">For each search circle:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get Sir Foo's current location coordinates.</li><li class="listitem" style="list-style-type: disc">Find the distance between each gold coin on the field and Sir Foo's location, the center of a search circle.</li><li class="listitem" style="list-style-type: disc">Collect all the coins with distance less than the <span class="emphasis"><em>search radius</em></span>. These are the coins lying inside the perimeter of the current search circle.</li><li class="listitem" style="list-style-type: disc">Advance Sir Foo to the center of the next search circle.</li><li class="listitem" style="list-style-type: disc">Repeat the preceding steps until you reach the rightmost circle.</li></ul></div></li><li class="listitem">Report the total number of collected gold coins.</li></ol></div></div><div class="section" title="Reviewing the initial code"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec134"/>Reviewing the initial code</h2></div></div></div><p>Let's review the code <a id="id539" class="indexterm"/>next (it can also be found in the supporting code bundle, just look for the <code class="literal">goldhunt_inefficient.py</code> file). Here is a new <code class="literal">GoldHunt</code> class:</p><div class="mediaobject"><img src="graphics/B05034_07_03.jpg" alt="Reviewing the initial code"/></div><p>The <code class="literal">play</code> method of this <a id="id540" class="indexterm"/>class contains the main logic, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B05034_07_21.jpg" alt="Reviewing the initial code"/></div><p>Let's review the code in the preceding screenshots:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The input arguments for the <code class="literal">play </code>method, <code class="literal">field_coins</code> and <code class="literal">field_radius</code>, set the number of coins and the radius of the circular gold field, respectively. These are optional arguments with default values, as shown in the <code class="literal">__init__</code> method. The third optional argument, <code class="literal">search_radius</code>, helps define the radius of the smaller search<a id="id541" class="indexterm"/> circles.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">x_ref</code> and <code class="literal">y_ref</code> variables represent the <span class="emphasis"><em>center</em></span> of the current search circle. We simplified the problem by assuming a constant <code class="literal">y_ref</code> of <code class="literal">0.0</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">play</code> method starts by generating random points representing the scattered gold coins. The <code class="literal">generate_random_points</code> function returns two Python lists containing the <code class="literal">x</code> and <code class="literal">y</code> coordinates of all the coins on the field.</li><li class="listitem" style="list-style-type: disc">In a <code class="literal">while</code> loop, the <code class="literal">total_collected_coins</code> list stores the coordinates of coins inside the <span class="emphasis"><em>search circles</em></span>, starting with the leftmost one.</li><li class="listitem" style="list-style-type: disc">The actual search operation is performed by the <code class="literal">find_coins</code> method.</li></ul></div><p>Next, let's review the <code class="literal">GoldHunt.find_coins</code> method:</p><div class="mediaobject"><img src="graphics/B05034_07_04.jpg" alt="Reviewing the initial code"/></div><p>This method loops over all the points (gold coins) on the field and for each point, it computes its distance from the center of the search circle. With this distance, we can determine whether or not the given gold coin lies inside the perimeter of the search circle. This is shown schematically in the following diagram. The <code class="literal">(x_ref, y_ref)</code> coordinates represent the center of the search circle. The <code class="literal">(x, y)</code> parameters are the coordinates of any gold coin on the field.</p><div class="mediaobject"><img src="graphics/B05034_07_05.jpg" alt="Reviewing the initial code"/></div><p>In this diagram, the<a id="id542" class="indexterm"/> distance between a point and the center is represented by <span class="strong"><strong>dist</strong></span>. It shows two representative points (or coins). The first one with a <span class="emphasis"><em>check mark</em></span> next to it lies inside the circle, whereas the other one with a <span class="emphasis"><em>cross mark</em></span> is outside. Only the point lying inside the circle is collected. The method returns a <code class="literal">collected_coins</code> list that contains the location tuples <code class="literal">(x,y)</code> of all such points.</p><p>Let's review the function that creates random points on the field:</p><div class="mediaobject"><img src="graphics/B05034_07_06.jpg" alt="Reviewing the initial code"/></div><p>You should be able to understand this code fragment fairly easily if you have a basic math background. Here is how it works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Consider a point with radius <code class="literal">r</code> and an angle <code class="literal">theta</code>.</li><li class="listitem" style="list-style-type: disc">The Cartesian coordinates of this point are <span class="emphasis"><em>x = r*cos(theta)</em></span> and <span class="emphasis"><em>y = r*sin(theta)</em></span>.</li><li class="listitem" style="list-style-type: disc">The built-in function, <code class="literal">random.uniform</code>, is used to randomly vary <code class="literal">r</code> between <code class="literal">0.0</code> (the field center) and <code class="literal">ref_radius</code> (the field radius). Note that the <code class="literal">import</code> statements are not shown. For that, refer to <code class="literal">goldhunt_inefficient.py</code>.</li><li class="listitem" style="list-style-type: disc">Similarly, the <code class="literal">theta</code> angle<a id="id543" class="indexterm"/> is randomly varied between <code class="literal">0.0</code> and <code class="literal">2*math.pi</code> (360 degrees).</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip70"/>Tip</h3><p>
<span class="strong"><strong>Plotting the points</strong></span>
</p><p>You can visualize the generated random distribution of gold coins using <a id="id544" class="indexterm"/>
<span class="strong"><strong>matplotlib</strong></span>, a Python plotting library. We won't discuss the plotting techniques here. Check out their website (<a class="ulink" href="http://matplotlib.org">http://matplotlib.org</a>) that hosts a number of tutorials and installation instructions. Python distributions, such as Anaconda, come preinstalled with matplotlib. You can also use the plotting function, <code class="literal">plot_points</code>, provided in the <code class="literal">goldhunt_inefficient.py</code> file.</p></div></div></div><div class="section" title="Running the code"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec135"/>Running the code</h2></div></div></div><p>The main execution<a id="id545" class="indexterm"/> code is as follows:</p><div class="informalexample"><pre class="programlisting">if __name__ == '__main__': 
    game = GoldHunt() 
    game.play()</pre></div><p>This code uses the default arguments to instantiate <code class="literal">GoldHunt</code>. With the default arguments, the code should run smoothly and finish within a few seconds. The actual time will vary depending on your machine configuration, available RAM, and so on. You can add some informative <code class="literal">print</code> statements to see how the game is progressing. Here is a sample output using the default arguments:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[user@hostname ch7]$ python goldhunt_inefficient.py </strong></span>
<span class="strong"><strong>Circle# 1, center:(-9.0, 0.0), coins: 55 </strong></span>
<span class="strong"><strong>Circle# 2, center:(-7.0, 0.0), coins: 37 </strong></span>
<span class="strong"><strong>Circle# 3, center:(-5.0, 0.0), coins: 54 </strong></span>
<span class="strong"><strong>Circle# 4, center:(-3.0, 0.0), coins: 47 </strong></span>
<span class="strong"><strong>Circle# 5, center:(-1.0, 0.0), coins: 53 </strong></span>
<span class="strong"><strong>Circle# 6, center:(1.0, 0.0), coins: 60 </strong></span>
<span class="strong"><strong>Circle# 7, center:(3.0, 0.0), coins: 44 </strong></span>
<span class="strong"><strong>Circle# 8, center:(5.0, 0.0), coins: 50 </strong></span>
<span class="strong"><strong>Circle# 9, center:(7.0, 0.0), coins: 51 </strong></span>
<span class="strong"><strong>Circle# 10, center:(9.0, 0.0), coins: 51 </strong></span>
<span class="strong"><strong>Total_collected_coins = 502</strong></span>
</pre></div></div></div>
<div class="section" title="The problem"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>The problem</h1></div></div></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>In the game scenario, you allowed the users to tweak certain parameters. For example, the users can control the <span class="strong"><strong>total number of coins</strong></span> on the field or modify the <span class="strong"><strong>radius of the search circle</strong></span>. Unknowingly, you opened a new can of worms. For a large input size, the program runs very slow. For example, one variant of the game, <span class="strong"><strong>The Great Dwarf of the Foo mountain</strong></span>, is performing the gold hunt. Let's hear what he has to say:</em></span>
</p>
</td></tr></tbody></table></div><div class="mediaobject"><img src="graphics/B05034_07_07.jpg" alt="The problem"/></div><p>If you<a id="id546" class="indexterm"/> change <code class="literal">field_coins</code> from <code class="literal">5000</code> to <code class="literal">1000000</code> and set <code class="literal">search_radius</code> to <code class="literal">0.1</code>, the application will take quite a bit of time to finish. Here is the updated main execution code with these new parameters:</p><div class="informalexample"><pre class="programlisting">if __name__ == '__main__': 
    game = GoldHunt(field_coins=1000000, search_radius=0.1) 
    game.play() </pre></div><p>If you increase the coins further or make the search radius even smaller, it will severely affect the application runtime.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip71"/>Tip</h3><p>
<span class="strong"><strong>Warning!</strong></span>
</p><p>If you run the following code, depending on your machine configuration, it can slow down your machine, take longer time to finish, and in some cases (a machine with an average configuration) the computer can stop responding. If you are unsure, it is better not to run it! It is presented here just as an example. If you really want to, then do it at your own risk!</p></div></div><p>For example, it can <a id="id547" class="indexterm"/>take several seconds or minutes to complete this operation. What can we do here to improve the performance? Before jumping to that, let's first review some techniques to identify the bottlenecks.</p></div>
<div class="section" title="Identifying the bottlenecks"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Identifying the bottlenecks</h1></div></div></div><p>In the previous section, we <a id="id548" class="indexterm"/>saw how a different choice of input<a id="id549" class="indexterm"/> parameters degrades the application runtime. Now, we need some way to accurately measure the execution time and find out the performance bottlenecks or the time consuming blocks of the code.</p><div class="section" title="Measuring the execution time"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec136"/>Measuring the execution time</h2></div></div></div><p>Let's start by monitoring the time<a id="id550" class="indexterm"/> taken by the application. To do this, we will use Python's built-in <code class="literal">time</code> module. The <code class="literal">time.perf_counter</code> function is a performance counter that returns a clock with the highest available resolution. This function can be used to determine the time interval or the system-wide time difference between the two consecutive calls to the function.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip72"/>Tip</h3><p>The <code class="literal">time.perf_counter</code> function is available in Python versions 3.3 onwards. If you have an older version of Python (for example, version 2.7), use <code class="literal">time.clock()</code> instead. On Unix, <code class="literal">time.clock()</code> returns a floating point number within seconds that represents the processor time. On Windows, it returns the elapsed wall-clock time within seconds after the first call to the function.</p></div></div><p>The original file, <code class="literal">goldhunt_inefficient.py</code>, already has the following code:</p><div class="informalexample"><pre class="programlisting">import time

if __name__ == '__main__': 
    start = time.perf_counter() 
    game = GoldHunt() 
    game.play() 
    end = time.perf_counter() 
    print("Total time interval:", end - start)</pre></div><p>At the beginning of the file, we import the <code class="literal">time</code> module. The <code class="literal">start</code> variable marks the beginning of the performance counter, and the <code class="literal">end</code> variable represents its second consecutive call. In between, we will run the main execution code. The difference between the two values of the counter can be used as an indicator for the runtime of the application. Similarly, you can insert these <a id="id551" class="indexterm"/>calls elsewhere in the code to monitor individual code fragments.</p></div><div class="section" title="Measuring the runtime of small code snippets"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec137"/>Measuring the runtime of small code snippets</h2></div></div></div><p>The built-in <code class="literal">timeit</code> module is <a id="id552" class="indexterm"/>a useful tool for quickly checking the execution time of a small code fragment. It can be used from the command line or imported and called inside the code. Here is one way to use this functionality using the command-line interface:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m timeit "x = 100*100" </strong></span>
<span class="strong"><strong>100000000 loops, best of 3: 0.0155 usec per loop</strong></span>
</pre></div><p>The <code class="literal">-m</code> option allows running the <code class="literal">timeit</code> module from the command line. In the preceding example, it measures the execution time for the <code class="literal">x = 100*100</code> statement.</p><p>Let's review the output of this execution. The <code class="literal">100000000 loops</code> in the output indicates how many times the code is executed by <code class="literal">timeit</code>. It reports the best of three timings. In this example, the best time taken is <code class="literal">0.0155</code> microseconds for a single execution. You can also tweak the number of times the code is run by using the <code class="literal">--number</code> argument, as shown in the following code snippet. Here, the code is run only <code class="literal">10</code> times:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m timeit --number=10  "x = 100*100" </strong></span>
<span class="strong"><strong>10 loops, best of 3: 0.0838 usec per loop </strong></span>
</pre></div><p>Internally, <code class="literal">timeit</code> <a id="id553" class="indexterm"/>uses <code class="literal">time.perf_counter</code> to measure the time taken. This is the default implementation since Python version 3.3. For further details, check out the documentation (<a class="ulink" href="https://docs.python.org/3/library/timeit.html">https://docs.python.org/3/library/timeit.html</a>).</p></div><div class="section" title="Code profiling"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec138"/>Code profiling</h2></div></div></div><p>The performance measurement <a id="id554" class="indexterm"/>techniques that we have seen so far work quite well, especially when you want to run benchmarks for the application. However, it is often cumbersome to implement these timers throughout your project to get a full execution profile. This is where the code profiling helps. It is a technique that analyzes a program while it is running and gathers some important statistics. For example, it reports the duration and frequency of various function calls within that program. This information can be used to identify the performance bottlenecks in the code.</p><div class="section" title="The cProfile module"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec59"/>The cProfile module</h3></div></div></div><p>Let's see how to use <code class="literal">cProfile</code>, Python's <a id="id555" class="indexterm"/>built-in module for code profiling. For illustration purposes, we will use the <code class="literal">profile_ex.py</code> file from the supporting code bundle. It has three simple functions that do some trivial tasks, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B05034_07_08.jpg" alt="The cProfile module"/></div><p>The <code class="literal">cProfile</code> command can either be run from the command prompt or by importing it inside the module to be tested. Here is the output when run from the Command Prompt:</p><div class="mediaobject"><img src="graphics/B05034_07_09.jpg" alt="The cProfile module"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>The<span class="strong"><strong> IPython</strong></span> interactive shell<a id="id556" class="indexterm"/> also provides a convenient magic command called <code class="literal">%prun</code>. With this, you can quickly profile a Python statement. For more <a id="id557" class="indexterm"/>information, check out <a class="ulink" href="https://ipython.org/ipython-doc/3/interactive/magics.html">https://ipython.org/ipython-doc/3/interactive/magics.html</a>.</p></div></div><p>Let's understand the output of this run:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first line of the <a id="id558" class="indexterm"/>output shows the total number of function calls monitored. A majority of these are due to <code class="literal">for loop</code> inside <code class="literal">test_2</code>. For each iteration, it calls the <code class="literal">append</code> function of the Python <code class="literal">list</code> datatype.</li><li class="listitem" style="list-style-type: disc">On the same output line, it also reports the number of <code class="literal">primitive calls</code>. These are the function calls that do not involve <a id="id559" class="indexterm"/><span class="strong"><strong>recursion</strong></span>. The <code class="literal">test_3</code> function shows an example of recursion. To understand this better, run the code by printing the value of the input argument <code class="literal">condition</code>. In this case, there is only one recursive function call.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">ncalls</code> column indicates the number of function calls. If you add them up, the total number of calls becomes <code class="literal">10007</code>, same as the ones reported on the first line of the output. Notice that for <code class="literal">test_3</code>, it reports the function calls as <code class="literal">2/1</code>. It means that the function was called twice but one of the calls was recursive.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">tottime</code> column indicates the total time spent in a given function.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">percall</code> column records the quotient of the <code class="literal">totcall/ncalls</code> division.</li><li class="listitem" style="list-style-type: disc">The time spent inside a particular function, including its sub-functions, is reported by <code class="literal">cumtime</code> (the cumulative time).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">percall</code> column reports the <code class="literal">cumtime</code>/<code class="literal">primitive calls</code> quotient.</li><li class="listitem" style="list-style-type: disc">The last column is, essentially, the data related to the functions. It includes the built-in function calls, such as the <code class="literal">append</code> method of the Python <code class="literal">list</code>, and so on.</li></ul></div><p>By default, the output is sorted <a id="id560" class="indexterm"/>by <code class="literal">standard name</code>. To understand the bottlenecks, this sorting order is not quite useful. Instead, you can sort by cumulative time, number of function calls, and so on. This is accomplished using the command-line option, <code class="literal">-s</code>. For a complete list of available <a id="id561" class="indexterm"/>sorting options, refer to <a class="ulink" href="https://docs.python.org/3/library/profile.html">https://docs.python.org/3/library/profile.html</a>. </p><p>The following screenshot shows the output sorted by <code class="literal">tottime</code>. Observe that it spends the most time in the <code class="literal">test_2</code> function.</p><div class="mediaobject"><img src="graphics/B05034_07_10.jpg" alt="The cProfile module"/></div><p>Now that we know how to use <code class="literal">cProfile</code>, let's use it to analyze the <span class="emphasis"><em>Gold Hunt</em></span> problem. Run the original <code class="literal">goldhunt_inefficient.py</code> file with all the default options, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m cProfile goldhunt_inefficient.py </strong></span>
</pre></div><p>It prints a lot of information in the terminal window as there are several of the internal function calls involved. Optionally, you can redirect <code class="literal">stdout</code> to a text file. To effectively analyze this data, Python provides a built-in module called <code class="literal">pstats</code>. Let's see how to use it in the following section.</p></div><div class="section" title="The pstats module"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec60"/>The pstats module</h3></div></div></div><p>The <code class="literal">pstats</code> module<a id="id562" class="indexterm"/> can be used to further process the profiling data generated by <code class="literal">cProfile</code>. It gives you greater control over creating your reports as compared to the limited options provided by <code class="literal">cProfile</code>. The analysis of the data generated by <code class="literal">cProfile</code> is done using the <code class="literal">pstats.Stats</code> class. To make the <code class="literal">cProfile</code> output usable by <code class="literal">pstats</code>, we will need to write it to a file using the command-line option, <code class="literal">-o</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m cProfile -o profile_output goldhunt_inefficient.py </strong></span>
</pre></div><p>The <code class="literal">profile_output</code> file, thus generated, is not human readable. While we can go on and feed this file to <code class="literal">pstats.Stats</code>, it is better to automate the whole process by stitching together these two utilities. Here is a simplified code that does this:</p><div class="mediaobject"><img src="graphics/B05034_07_11.jpg" alt="The pstats module"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip73"/>Tip</h3><p>
<span class="strong"><strong>Warning</strong></span>
</p><p>This is a simplified example without any error checks! For example, the code does not check if the output file already exists. To make the code robust, add such checks and the <code class="literal">try…except</code> clauses wherever appropriate.</p></div></div><p>This code is also available as <code class="literal">profiling_goldhunt.py</code> in the supporting code bundle for this chapter. Let's quickly review what this code does:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The main execution code shows a way to run <code class="literal">cProfile</code> using its <code class="literal">run</code> method. The first argument to <code class="literal">run</code> is the function (or statement) to be monitored, whereas the second argument is the filename where the profiling output is stored.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">view_stats</code> function is where we use the functionality from <code class="literal">pstats</code>. This function takes the generated profiling output (<code class="literal">filname</code>) as the first argument. It is used while creating an instance of <code class="literal">pstats.Stats</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">strip_dirs</code> method of the <code class="literal">Stats</code> class is used to remove all leading path information strings from filenames. This reduces the clutter in the final output by just displaying the name of the file.</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">print_stats</code> <a id="id563" class="indexterm"/>method, we can impose some restrictions in the final output. In this example, it looks for the <code class="literal">goldhunt</code> string in the rightmost columns and displays the matching row, ignoring all others. Put in another way, it limits the information related to the function calls inside <code class="literal">goldhunt_inefficient.py</code>.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>The <code class="literal">pstats.Stats</code> class<a id="id564" class="indexterm"/> provides several other useful features. For example, the <code class="literal">print_callees</code> method prints a list of all the functions that were called by the function being monitored. For further details, check out the Python documentation (<a class="ulink" href="https://docs.python.org/3/library/profile.html#pstats.Stats">https://docs.python.org/3/library/profile.html#pstats.Stats</a>).</p></div></div><p>This code can be run from the command prompt, as follows (it has a dependency on <code class="literal">goldhunt_inefficient.py</code> so put it in the same directory as this file):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python profiling_goldhunt.py</strong></span>
</pre></div><p>Here is the sample output of this run (only the output pertaining to the statistics is shown):</p><div class="mediaobject"><img src="graphics/B05034_07_12.jpg" alt="The pstats module"/></div><p>This is significantly less output and <a id="id565" class="indexterm"/>is restricted to the function calls from the program we wish to monitor. As indicated in the output, only <code class="literal">5</code> out of <code class="literal">19</code> function calls are listed. The list is sorted by the total internal time taken to execute the functions. The two functions, <code class="literal">find_coins</code> and <code class="literal">generate_random_points</code>, top the chart! Their order may vary depending on the values we choose for the <code class="literal">field_coins</code> and <code class="literal">search_radius</code> variables. But essentially, the code profiling has helped us identify the most time consuming code in our application.</p><div class="mediaobject"><img src="graphics/B05034_07_13.jpg" alt="The pstats module"/></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>Good question! It will certainly help if we can peep inside the function and see the line-by-line profiling output. Luckily, there is a tool that enables exactly this. Let's review it next.</em></span>
</p>
</td></tr></tbody></table></div></div><div class="section" title="The line_profiler package"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec61"/>The line_profiler package</h3></div></div></div><p>The <code class="literal">line_profiler</code> package<a id="id566" class="indexterm"/> is a third-party Python package that can be installed using <code class="literal">pip</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install line_profiler</strong></span>
</pre></div><p>This package can be used to monitor the performance of a function, line by line. When you install the package, it also creates an executable <code class="literal">kernprof</code>.</p><p>On Linux, this executable is created at the same location as your Python executable. For example, on Linux, if Python is available as <code class="literal">/usr/bin/python</code>, this executable is created as <code class="literal">/usr/bin/kernprof</code> (or look for the <code class="literal">kernprof.py</code> script). On Windows OS, it should be created at the same location as <code class="literal">pip.exe</code>. Refer to <a class="link" href="ch01.html" title="Chapter 1. Developing Simple Applications">Chapter 1</a>, <span class="emphasis"><em>Developing Simple Applications</em></span> for the <code class="literal">pip.exe</code> path.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip74"/>Tip</h3><p>On Windows OS, if you encounter any error, such as <span class="strong"><strong>error: Unable to find vcvarsall.bat</strong></span>, you will probably need to use<a id="id567" class="indexterm"/> Visual C++ Express. Check out <a class="ulink" href="https://www.visualstudio.com/en-US/products/visual-studio-express-vs">https://www.visualstudio.com/en-US/products/visual-studio-express-vs</a> for more information.</p></div></div><p>Using this tool requires trivial changes to the code. All you need to do is add a <code class="literal">@profile</code> decorator above the function or method name, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B05034_07_14.jpg" alt="The line_profiler package"/></div><p>Then, run the tool using the <code class="literal">kernprof</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ kernprof -v -l goldhunt_inefficient.py</strong></span>
</pre></div><p>The <code class="literal">-v</code> or <code class="literal">--view</code> option displays the results of the profile output in the terminal window. The profiler also creates an output file, <code class="literal">goldhunt_inefficient.py.lprof</code>. The <code class="literal">-l</code> or <code class="literal">--line-by-line</code> option uses the line-by-line profiler from the <code class="literal">line_profiler</code> module.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip75"/>Tip</h3><p>Be sure to remove the decorator <code class="literal">@profile</code> when you are not profiling the application using the <code class="literal">line_profiler</code>. In other words, remove it while running the application, as:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python goldhunt_inefficient.py</strong></span>
</pre></div><p>Otherwise, it will raise a <code class="literal">NameError</code> exception.</p></div></div><p>The <code class="literal">line_profiler</code> output for the <code class="literal">find_coins</code> method is shown below.</p><p>As you can see, quite a<a id="id568" class="indexterm"/> bit of time is spent computing the distance between the points (gold coins) and the center of the search circle.</p><div class="mediaobject"><img src="graphics/B05034_07_15.jpg" alt="The line_profiler package"/></div><p>Similarly, if you see the output for the <code class="literal">generate_random_point</code> function, the majority of the time is spent while creating a random combination of the <code class="literal">theta</code> angle and the <code class="literal">r</code> radius, which is used to define a point (a gold coin).</p></div></div></div>
<div class="section" title="Memory profiling"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Memory profiling</h1></div></div></div><p>The profiling techniques we have covered so <a id="id569" class="indexterm"/>far aim at finding the runtime bottlenecks. Let's briefly discuss memory profiling, another important aspect of profiling.</p><div class="section" title="The memory_profiler package"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec139"/>The memory_profiler package</h2></div></div></div><p>For memory profiling, we will use a popular <a id="id570" class="indexterm"/>Python package called <code class="literal">memory_profiler</code>. It can be installed using <code class="literal">pip</code>. Here is how to install it on Linux from the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install memory_profiler</strong></span>
</pre></div><p>The documentation highly recommends installing the <code class="literal">psutils</code> module. It also suggests that, in order for <code class="literal">memory_profiler</code> to work on Windows OS, you will need the <code class="literal">psutil</code> module. The <code class="literal">psutil</code> module can be installed using <code class="literal">pip</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install psutil </strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip77"/>Tip</h3><p>For more information<a id="id571" class="indexterm"/> on <code class="literal">memory_profiler</code>, check out the following page: <a class="ulink" href="https://pypi.python.org/pypi/memory_profiler">https://pypi.python.org/pypi/memory_profiler</a>.</p></div></div><p>Just like <code class="literal">line_profiler</code>, the <code class="literal">memory_profiler</code> package uses the <code class="literal">@profile</code> decorator above the function name. Let's add the decorator <code class="literal">@profile</code> just above the <code class="literal">generate_random_points</code> function, and then run the memory profiler on the <code class="literal">goldhunt_inefficient.py</code> file. The command to run this is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m memory_profiler goldhunt_inefficient.py</strong></span>
</pre></div><p>Here is the output of the memory profiler. It reports the line-by-line memory consumption. Note that the profiler prints the whole function, including the docstrings. For ease of illustration, part of the docstring is not shown.</p><div class="mediaobject"><img src="graphics/B05034_07_16.jpg" alt="The memory_profiler package"/></div><p>The line number in the code is shown in the first column. The second column, <code class="literal">Mem Usage</code>, tells us how much memory the Python interpreter consumes after executing that line number. The unit of the memory is <a id="id572" class="indexterm"/>
<span class="strong"><strong>mebibyte</strong></span> (<span class="strong"><strong>MiB</strong></span>).The third column, <code class="literal">Increment</code>, gives the memory difference between the current line and the previous line. If the memory is released by the current line of code, then the <code class="literal">Increment</code> column shows a negative number. The last column shows the actual line of code. As can be seen from the <code class="literal">Increment</code> column, the memory is mainly consumed in the <code class="literal">for</code> loop. We will use the memory profiler in the next chapter to compare the memory efficiency of a <span class="strong"><strong>generator expression</strong></span>
<a id="id573" class="indexterm"/> and a<a id="id574" class="indexterm"/> <span class="strong"><strong>list comprehension</strong></span>.</p></div></div>
<div class="section" title="Algorithm efficiency and complexity"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Algorithm efficiency and complexity</h1></div></div></div><p>An algorithm is a set of instructions to solve a particular problem. In this context, an algorithm can be a function or even a simple operation that adds two numbers. Let's understand two related terms: algorithm efficiency and algorithm complexity.</p><div class="section" title="Algorithm efficiency"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec140"/>Algorithm efficiency</h2></div></div></div><p>Algorithm efficiency<a id="id575" class="indexterm"/> indicates the computation resources consumed by an algorithm. Typically, the lower the resource consumption, the better the efficiency. The computational resources can mean several things. One can be talking about the runtime (CPU usage), the memory consumption (RAM or hard disk) or the network consumption, or a combination of these. </p><p>The application requirement determines which resource takes precedence over the others. For example, in a web application, the network usage can be more important than the disk space. For a scientific application, you might have all the memory you need but the runtime can be a pain in the neck, and so on. In this book, we will limit our discussion to the runtime efficiency only.</p></div><div class="section" title="Algorithm complexity"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec141"/>Algorithm complexity</h2></div></div></div><p>Suppose you have a program (an algorithm) that<a id="id576" class="indexterm"/> processes some data in five minutes. If you increase the size of the data, how much time will the program need? The answer lies in the algorithm complexity. It tells us how well the algorithm will scale if you increase the size of the problem. In other words, the computational complexity influences the performance of the algorithm. In the next section, you will learn how to represent the computational complexity.</p></div></div>
<div class="section" title="Big O notation"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Big O notation</h1></div></div></div><p>In simple terms, the big O or <a id="id577" class="indexterm"/>big Oh notation is a way to represent the computational complexity of an algorithm. Here, the O is the letter <span class="emphasis"><em>O</em></span>, as in <span class="emphasis"><em>order</em></span>, and not the number zero. The big O indicates an upper bound or the worst-case scenario of the complexity of an algorithm (details to follow in the next section). This concept can be better explained with an example. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">num = 100 
x = []
for i in range(num): 
    x.append(i)</pre></div><p>Let's call this trivial code fragment an algorithm. It is a simple operation that appends a number to the <code class="literal">list</code> inside a <code class="literal">for</code> loop. Here, <code class="literal">num</code> represents the size of the input used by the algorithm. If you increase <code class="literal">num</code>, the algorithm will have to do more work inside the <code class="literal">for</code> loop. Increase it further, and the poor algorithm will have to do even more work. Thus, the time taken by the algorithm depends on the value of <code class="literal">num</code> and can be expressed as a growth function, <span class="emphasis"><em>f(n)</em></span>. Here,<span class="emphasis"><em> n</em></span> represents the size of the input that corresponds to <code class="literal">num</code> in this example.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip78"/>Tip</h3><p>Making sense so far? You can also test this by measuring the execution time. To see a real difference, choose a larger value of <code class="literal">num</code>.</p></div></div><p>In this algorithm, the <a id="id578" class="indexterm"/>most time consuming piece is the <code class="literal">for</code> loop, and it will determine the overall runtime of the algorithm. Inside the <code class="literal">for</code> loop, each call to <code class="literal">x.append(i)</code> takes constant time, <span class="emphasis"><em>t</em></span>, to finish. For a large value of <code class="literal">num</code>, the total time taken by the loop will be approximately <span class="emphasis"><em>num*(t)</em></span>. Thus, the runtime efficiency of the whole algorithm relative to <code class="literal">num</code> is linear. In terms of the big O notation, this particular algorithm is said to have <span class="emphasis"><em>O(n)</em></span> complexity.</p><div class="section" title="Big O complexity classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec142"/>Big O complexity classes</h2></div></div></div><p>Let's review some <a id="id579" class="indexterm"/>big O complexity classes. The following chart annotates various complexity classes and shows how <span class="emphasis"><em>f(n)</em></span> influences the running time of algorithms:</p><div class="mediaobject"><img src="graphics/B05034_07_17.jpg" alt="Big O complexity classes"/></div><p>On the <span class="emphasis"><em>y</em></span> axis, we have the <span class="emphasis"><em>f(n)</em></span> function, and the <span class="emphasis"><em>x</em></span> axis represents the input size, <span class="emphasis"><em>n</em></span> (the <code class="literal">num</code> variable in the previous discussion). The plot compares some common functions that represent the time <a id="id580" class="indexterm"/>complexity of algorithms.</p><p>It should be noted that the big O representation does not include the constants. So, even if two algorithms share the same big O complexity, they can clock a very different runtime performance. The circle marker in the plot shows a typical crossover point between two complexity functions. In this example, this is between <span class="emphasis"><em>O(n)</em></span> and <span class="emphasis"><em>O(n log n)</em></span>. As noted earlier, the individual algorithms representing these complexity functions will have different constant multipliers (not reflected in the big O notation). Tweaking those multipliers can change where this crossover happens.</p><p>Let's briefly review these notations now.</p><div class="section" title="O(1) – constant time"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec62"/>O(1) – constant time</h3></div></div></div><p>Regardless of the value of the input size, the time taken by the algorithm remains constant. Getting the length of a Python list (<code class="literal">len(x)</code>, where <code class="literal">x</code> is the list) or the <code class="literal">append</code> list operation we saw <a id="id581" class="indexterm"/>earlier, are a few examples of <span class="emphasis"><em>O(1)</em></span> complexity.</p></div><div class="section" title="O(log n) – logarithmic"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec63"/>O(log n) – logarithmic</h3></div></div></div><p>The time required by the<a id="id582" class="indexterm"/> algorithm is proportional to the logarithm of the input size. One of the examples of logarithmic complexity is a <a id="id583" class="indexterm"/>
<span class="strong"><strong>binary search algorithm</strong></span>. It starts with inspecting the middle element of a sorted array. If the value being searched is lower than the middle element, the entire upper half, including this middle element, is eliminated from the search. We can do this because it is a<a id="id584" class="indexterm"/> <span class="strong"><strong>sorted array</strong></span>. This process is repeated for the remaining half and it continues until we find the desired value.</p><p>Confused? Let's see what Fairy is up to these days…</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>Fairy has lost her enchanted locket in a room full of treasure chests. These boxes are numbered 1 to 100 and are arranged in increasing order. In other words, the boxes are sorted and the locket is placed in one of them. She is trying to find it with the help of her magical wand. The wand knows that the locket is in, for instance, box number 82, but it won't give a straight answer! It expects her to ask the right questions.</em></span>
</p>
<p>
<span class="emphasis"><em>She is standing exactly in the middle of the room and in front of box 50. Towards her left, she sees numbers 1 to 49; and towards the right, numbers 51 to 100, in that order.</em></span>
</p>
<p>
<span class="emphasis"><em>She asks her wand, is the locket in box 50? The wand says "no". She further asks, is the number greater than 50 or less than 50? The wand answers "greater than 50".</em></span>
</p>
<p>
<span class="emphasis"><em>With this answer, she ignores the boxes on the left side (1-49), including box 50, and stands in the middle of the group, to her right (51-100). Now, she has box 75 in front of her. She repeats the questions with box 75 as the reference. Each time, half of the remaining chests are eliminated. The search operation goes on until she finds her locket in box 82.</em></span>
</p>
</td></tr></tbody></table></div><p>This is the binary search in a nutshell. You can find more <a id="id585" class="indexterm"/>information on Wikipedia (<a class="ulink" href="https://en.wikipedia.org/wiki/Binary_search_algorithm">https://en.wikipedia.org/wiki/Binary_search_algorithm</a>). In the worst case scenario, the time complexity of this search is <span class="emphasis"><em>O(log n)</em></span>. Another way to look at the logarithmic complexity is as follows. For an exponential increase in the size of the problem <span class="emphasis"><em>n</em></span>, the time taken by the algorithm increases linearly. As can be seen in the earlier chart, the <span class="emphasis"><em>O(log n)</em></span> time complexity is better compared to the <span class="emphasis"><em>O(n)</em></span> (linear-time) complexity, but not as good as <span class="emphasis"><em>O(1)</em></span>.</p></div><div class="section" title="O(n) – Linear time"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec64"/>O(n) – Linear time</h3></div></div></div><p>We already saw an example<a id="id586" class="indexterm"/> where a <code class="literal">for</code> loop makes the algorithm of the <span class="emphasis"><em>O(n)</em></span> complexity. Finding a min or max element in a Python list and copying a list or a dictionary are some other examples of this complexity.</p></div><div class="section" title="O(n log n) – Log linear"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec65"/>O(n log n) – Log linear</h3></div></div></div><p>An example of a log linear time<a id="id587" class="indexterm"/> complexity is a <a id="id588" class="indexterm"/>
<span class="strong"><strong>quicksort algorithm</strong></span>. Let's call Fairy one more time to get a better idea of the working of this algorithm.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>Fairy enters another treasure room and finds it extremely disorganized. The treasure chests are randomly scattered everywhere in the room. Not liking this, she decides to sort the chests in an increasing order of their value (or price). Initially, the chests are randomly placed, like this:</em></span>
</p>
<p>
<span class="emphasis"><em>[5 3 2 4 9 7 8 8 ]</em></span>
</p>
<p>
<span class="emphasis"><em>Here, the number represents the value of each chest. Fairy starts picking a pivot chest, say with a value tag of 5. She then rearranges the chests into three sections: (i) The ones with a value lower than 5 are on the left side of the pivot, (ii) the pivotal chest 5, (iii) and the values greater than 5 are on the right side. This is shown below:</em></span>
</p>
<p>
<span class="emphasis"><em>[3 2 4   5   9 7 8 8 ]</em></span>
</p>
<p>
<span class="emphasis"><em>Next, with 5 fixed to its position, she repeats the preceding procedure to the items on the left and right sides of 5. For example, consider only the left side of 5:</em></span>
</p>
<p>
<span class="emphasis"><em>[3 2 4]</em></span>
</p>
<p>
<span class="emphasis"><em>The fairy chooses number 3 as a new pivot and arranges the values to the left and right of 3, as shown earlier. This rearrangement results in:</em></span>
</p>
<p>
<span class="emphasis"><em>[2 3 4]</em></span>
</p>
<p>
<span class="emphasis"><em>The process goes on until all the chests are sorted in the increasing order of the valuables, as shown below:</em></span>
</p>
<p>
<span class="emphasis"><em>[2 3 4 5 7 8 8 9]</em></span>
</p>
</td></tr></tbody></table></div><p>This is the basic quicksort operation and has the complexity of <span class="emphasis"><em>O(n log n)</em></span>. As shown in the earlier chart, for a higher value of <span class="emphasis"><em>n</em></span>, the <span class="emphasis"><em>O(n log n)</em></span> complexity is expensive compared to <span class="emphasis"><em>O(n)</em></span>, but it is much <a id="id589" class="indexterm"/>better than the quadratic complexity.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip79"/>Tip</h3><p>It should be noted that <span class="emphasis"><em>O(n log n)</em></span> is the <span class="strong"><strong>average-case</strong></span> complexity<a id="id590" class="indexterm"/> of the quicksort algorithm. Refer to the section, <span class="emphasis"><em>Upper bound (worst-case) of the complexity</em></span>, of this chapter to learn about average-case and worst-case complexities.</p></div></div></div><div class="section" title="O(n2) – Quadratic"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec66"/>O(n<sup>2</sup>) – Quadratic</h3></div></div></div><p>This represents the quadratic<a id="id591" class="indexterm"/> runtime complexity. The time required to run the program grows as square of the size of the input to the algorithm. Let's extend the previous example to understand this further:</p><div class="informalexample"><pre class="programlisting">num = 100 
x = [] 
for i in range(num): 
    for j in range(num): 
        x.append(i) </pre></div><p>It is a nested <code class="literal">for</code> loop. Let <span class="emphasis"><em>t</em></span> be the time it takes to append an element to the list. As mentioned earlier, a single append operation is of <span class="emphasis"><em>O(1)</em></span> complexity. The inner <code class="literal">for</code> loop will take approximately <span class="emphasis"><em>n*t</em></span> (or <span class="emphasis"><em>num*t</em></span>) to execute. Since we have an outer <code class="literal">for</code> loop, the total time complexity becomes <span class="emphasis"><em>n*(n*t)</em></span>. A classic example of this complexity is a <span class="strong"><strong>bubble sort algorithm</strong></span>
<a id="id592" class="indexterm"/> (<a class="ulink" href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a>). This algorithm sorts a list in an iterative manner, and it repeatedly swaps the adjacent elements of the list if these elements are placed in a wrong order.</p></div><div class="section" title="O(n3) – cubic"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec67"/>O(n<sup>3</sup>) – cubic</h3></div></div></div><p>This is a cubic complexity, which<a id="id593" class="indexterm"/> is worse than the quadratic complexity. A small increase in the problem size will result in a big increase in the runtime. Adding another outer <code class="literal">for</code> loop in the illustration on quadratic complexity will make it <span class="emphasis"><em>O(n<span class="strong"><strong>3</strong></span>)</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip80"/>Tip</h3><p>This is only a partial list of complexity<a id="id594" class="indexterm"/> classes. There are many more. For further information, check out <a class="ulink" href="https://en.wikipedia.org/wiki/Big_O_notation">https://en.wikipedia.org/wiki/Big_O_notation</a>.</p></div></div></div><div class="section" title="Upper bound of the complexity"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec68"/>Upper bound of the complexity</h3></div></div></div><p>Let's revisit the <a id="id595" class="indexterm"/>statement we made earlier: "Big O notation indicates an upper bound or the worst-case scenario of the complexity of an algorithm". Quite a mouthful? An explanation is in order. We will reuse the illustration used in the discussion on the <span class="emphasis"><em>O(n<sup>2</sup>)</em></span> complexity:</p><div class="informalexample"><pre class="programlisting">num = 100 
x = [] 
for i in range(num): 
    for j in range(num): 
        x.append(i) </pre></div><p>We already saw that a single <code class="literal">x.append(i)</code> operation is <span class="emphasis"><em>O(1)</em></span>, the inner loop is <span class="emphasis"><em>O(N)</em></span>, and the full nested <code class="literal">for</code> loop has the time complexity of <span class="emphasis"><em>O(n<sup>2</sup>)</em></span>. Then why do we say that the complexity of the algorithm as a whole is <span class="emphasis"><em>O(n<sup>2</sup>)</em></span>?</p><p>If you look at the earlier chart that compared various complexities, <span class="emphasis"><em>O(n<sup>2</sup>)</em></span> is the costliest among these three complexities and thus the most significant part of it. In other words, the algorithm complexity cannot get worse than <span class="emphasis"><em>O(n<sup>2</sup>)</em></span>. Now, read the earlier statement on upper bounds one more time. The big O notation represents the worst-case scenario of the complexity of the algorithm. This is the reason why the big O complexity class for this algorithm is represented as <span class="emphasis"><em>O(n<sup>2</sup>)</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>
<span class="strong"><strong>Average-case time complexity:</strong></span>
</p><p>Most of the time, an <a id="id596" class="indexterm"/>algorithm is analyzed by measuring its worst-case complexity. However, there are some problems where it makes practical sense to measure the<a id="id597" class="indexterm"/> <span class="strong"><strong>average-case time complexity</strong></span>. Here, the amount of time taken to run the algorithm is averaged over all possible inputs. The quicksort algorithm we saw earlier is a classic example where average-case complexity is useful. It determines the real (or practical) efficiency of the algorithm. The average-case time complexity of this algorithm is <span class="emphasis"><em>O(n log n),</em></span> whereas the worst-case <a id="id598" class="indexterm"/>complexity is <span class="emphasis"><em>O(n<sup>2</sup>)</em></span>. For more information, check out <a class="ulink" href="https://en.wikipedia.org/wiki/Average-case_complexity">https://en.wikipedia.org/wiki/Average-case_complexity</a>.</p></div></div></div><div class="section" title="Complexity for common data structures and algorithms"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec69"/>Complexity for common data structures and algorithms</h3></div></div></div><p>The following table summarizes the time complexity of a few frequently performed operations on some Python data structures. This is not an exhaustive list, for that, see the Python wiki (<a class="ulink" href="https://wiki.python.org/moin/TimeComplexity">https://wiki.python.org/moin/TimeComplexity</a>). It documents the time complexity of several other operations on these data structures.</p><div class="mediaobject"><img src="graphics/B05034_07_23.jpg" alt="Complexity for common data structures and algorithms"/></div><p>The following table summarizes the time complexity of some common algorithms along with the Python functions that implement them. Note that the functions listed are from the NumPy library. Although the next chapter will introduce you to NumPy, we won't specifically talk about these functions in this book.</p><div class="mediaobject"><img src="graphics/B05034_07_24.jpg" alt="Complexity for common data structures and algorithms"/></div><p>The first algorithm listed in the preceding table is a binary search algorithm. This was already illustrated when we talked about the <span class="emphasis"><em>O(log n)</em></span> or logarithmic complexity. The <code class="literal">numpy.searchsorted</code> function uses binary search to find array indices where the elements need to be inserted to maintain order. The remaining algorithms in this table are a few common sorting algorithms that put elements in a list in a specific order. We already talked about quicksort. To learn more about the<a id="id599" class="indexterm"/> other algorithms, refer to <a class="ulink" href="https://en.wikipedia.org/wiki/Sorting_algorithm">https://en.wikipedia.org/wiki/Sorting_algorithm</a>.</p></div><div class="section" title="Wrapping up the big O discussion"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec70"/>Wrapping up the big O discussion</h3></div></div></div><p>Let's summarize what you learned about the big O notation so far:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Big O enables us to compare different algorithms in terms of their time (or space) complexity. This helps us choose the right algorithm (if possible) or determine the strategy to implement changes that speed things up.</li><li class="listitem" style="list-style-type: disc">It gives us the growth rate of an algorithm, but it will not give us the absolute value of the runtime. For example, some algorithm A takes 10 minutes to execute. On the same machine, algorithm B takes 200 minutes to execute, and guess what—both algorithms have the same complexity, say <span class="emphasis"><em>O(n)</em></span>. Although they have different execution times, they have one thing in common, the time taken linearly increases with their problem size.</li></ul></div><div class="mediaobject"><img src="graphics/B05034_07_18.jpg" alt="Wrapping up the big O discussion"/></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>Glad you brought that up! The big O notation indicates the worst-case scenario of an algorithm, and it rules other (less costly) complexity classes present in that algorithm. In other words, the worst-case complexity drives the performance of that algorithm.</em></span>
</p>
</td></tr></tbody></table></div><p>It is good to be aware of the complexity, especially when the problem size is large. For a very small problem, it may or may not make a huge difference. A good practice is to analyze the existing algorithm for the performance bottlenecks, and then see if it is worth revamping the algorithm for speedup. Weigh in the factors, such as the time you spend on changing the algorithm and its impact on the quality (bugs and testing) versus the long term benefit of the speedup accomplished. In a nutshell, choose the strategy that best fits your needs.</p><p>It is also worth noting that sometimes you have to live with an algorithm with a certain complexity class. But that is not the end of the road. You can still implement techniques to speedup the code without changing its order of complexity. The performance improvement obtained will depend on the problem in hand. For example, you can parallelize the code or compute some parameters in advance to achieve speedup. Later in this book, we will cover basics of parallelization in Python.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Summary</h1></div></div></div><p>This chapter was the first one in the series of three chapters based on performance. It laid the ground work to improve application performance. We learned how to record the runtime using the <code class="literal">time</code> module. We also saw how the <code class="literal">timeit</code> module can be used to measure the performance of small pieces of code. We took a practical problem where an application ran fine when working with a small input, but, as the input grew larger, it slowed down considerably. With this example, we learned how to identify the bottlenecks using <code class="literal">cProfile</code> and display the results using <code class="literal">pstats</code>.</p><p>We saw how the <code class="literal">line_profiler</code> module can help locate the time consuming statements inside a function. While most of the discussion was focused on the runtime performance, we briefly covered the <code class="literal">memory_profiler</code> module. This module enabled line-by-line analysis of memory consumption for the given functions. Finally, we learned about the big O notation that represents the computational complexity of an algorithm.</p><p>Now that we have identified the performance bottlenecks, let's move on to the next chapter to improve the application performance.</p></div></body></html>