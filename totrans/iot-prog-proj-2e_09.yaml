- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding LoRa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explore the world of **LoRa** (short for **Long Range**),
    a key technology in IoT communication. LoRa is known for transmitting data over
    extensive distances with minimal power. We will explore its practical applications
    in areas such as agriculture, where it enables efficient management of large-scale
    sensor networks, and urban settings, where it assists in smart city initiatives
    such as street lighting control.
  prefs: []
  type: TYPE_NORMAL
- en: We will also investigate the **radio frequency spectrum** and understand how
    different frequencies are allocated for various wireless communications, allowing
    us to better comprehend the operational range of LoRa technology. By studying
    the frequency spectrum, we can identify which frequency bands are most suitable
    for LoRa transmissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our focus then shifts to the practical aspect: building a LoRa sensory transmitter
    and LoRa receiver using a Raspberry Pi Pico and Pico W, respectively. We’ll start
    with assembling the transmitter circuit by integrating an RFM95W LoRa module,
    a DHT22 temperature sensor, and a Raspberry Pi Pico. We will then house these
    components in a custom 3D-printed case. We’ll emphasize using the standard Raspberry
    Pi Pico for its efficiency in tasks that don’t require Wi-Fi, benefiting from
    its lower power consumption and reduced firmware overhead.'
  prefs: []
  type: TYPE_NORMAL
- en: For the receiver, we use a Raspberry Pi Pico W, focusing on its Wi-Fi capabilities
    for future developments. We’ll construct a custom case for the receiver, as with
    the transmitter, but with an LED for status indication.
  prefs: []
  type: TYPE_NORMAL
- en: The development process includes setting up CircuitPython, installing necessary
    libraries, and writing the code for both the transmitter and receiver. CircuitPython
    is an open-source derivative of MicroPython, developed by Adafruit, designed to
    simplify coding for microcontrollers. In our code, we’ll use a delay between transmissions
    to adhere to European duty-cycle limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will test our application outdoors, demonstrating LoRa’s impressive
    range capabilities as compared with the limited range of Wi-Fi.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring LoRa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a LoRa sensory transmitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a LoRa receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the requirements for completing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Python programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x Raspberry Pi Pico WH (with headers) for development (may add headers to
    a Raspberry Pi Pico W instead)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x Pico GPIO expander for development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x Raspberry Pi Pico (for LoRa sensory transmitter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x Raspberry Pi Pico W (for LoRa receiver)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x RFM95W LoRa modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x DHT22 temperature and humidity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x LED (any color)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 220 Ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 x M3 10 mm bolts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 x M2 5 mm screws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x M5 20 mm bolts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x M5 nuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot glue gun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 3D printer or 3D printer service to print custom cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build files for custom cases may be found in our GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code and build files for this chapter may be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter9](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter9)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring LoRa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LoRa is a wireless communication technology known for its ability to transmit
    data over long distances while consuming very little power. It has become increasingly
    significant in the field of IoT due to its efficiency and reliability in various
    environments. Originating as a solution for extending the range of wireless communications,
    LoRa technology has evolved to play a pivotal role in connecting a wide array
    of IoT devices.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will look at the practical uses of LoRa before
    we explore the frequency spectrum and how it relates to LoRa.
  prefs: []
  type: TYPE_NORMAL
- en: Practical uses for LoRa technology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LoRa technology is instrumental in areas such as agriculture, enabling farmers
    to deploy sensory networks for monitoring soil moisture, temperature, and other
    vital parameters over large areas, enhancing crop management and resource efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: '**LoRa nodes** offer a cost-effective solution for modernizing agricultural
    practices, contrasting with costlier alternatives such as **Long Term Evolution**
    (**LTE**)-based systems or extensive wired sensor networks. While LTE supports
    more data-intensive applications, its higher power requirements and operational
    costs can be prohibitive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 9**.1*, we see an AI-generated image of LoRa nodes used to measure
    soil and weather conditions for a modern farm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Modern farm using LoRa technology](img/B21282_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Modern farm using LoRa technology
  prefs: []
  type: TYPE_NORMAL
- en: 'In urban environments, LoRa may be used to manage smart city applications such
    as street lighting. In *Figure 9**.2*, we see a smart light post used in an urban
    environment. In this setting, control of the light is determined by a central
    office with a LoRa message sent to the light post to turn it on or off or control
    its brightness:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Smart light post using LoRa messages for control](img/B21282_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Smart light post using LoRa messages for control
  prefs: []
  type: TYPE_NORMAL
- en: This method of control is beneficial as it allows for remote management of lighting
    based on real-time data and needs, such as adjusting brightness according to traffic
    conditions or time of day.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the application of LoRa communication technology, let’s
    examine the radio frequency spectrum it uses, focusing on how different frequencies
    cater to various application needs and scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating the radio frequency spectrum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The radio frequency spectrum is used for various wireless communications, including
    television broadcasting, mobile data, satellite, and IoT technologies such as
    LoRa. Frequencies are allocated for specific uses to avoid interference and optimize
    communication efficiency. **Ultra high frequency** (**UHF**) bands, for example,
    are commonly used for television broadcasting, mobile phones, and Wi-Fi. Each
    frequency band has unique characteristics such as propagation range and penetration
    ability, making them suitable for specific applications.
  prefs: []
  type: TYPE_NORMAL
- en: In general, lower frequencies, characterized by their longer wavelengths, can
    travel greater distances and are more effective at penetrating obstacles compared
    to higher frequencies. Conversely, higher frequencies, while having shorter wavelengths,
    possess the ability to carry more data due to their larger bandwidth. These characteristics
    are crucial in determining the suitable frequency band for different types of
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common example of the effectiveness of the penetration of low frequencies
    is how we often hear the bass, or lower frequencies, from music playing loudly
    inside a club when we are outside, but not higher frequencies, as lower frequencies
    are better at penetrating the walls of the club. This ability to penetrate through
    objects makes lower frequencies especially useful for communications that need
    to cover larger areas or pass through obstructions. For instance, lower frequency
    bands such as those used in AM radio can cover vast geographical areas, while
    higher frequencies, despite offering more bandwidth, have a shorter range and
    are more suited to urban settings with **Line-Of-Sight** (**LOS**) communication.
    Higher frequencies are desirable for technologies such as cell phone communication
    because they can carry more data, providing greater capacity for voice and data
    transmission. In *Figure 9**.3*, we see an illustration of the frequency spectrum
    used for wireless communications and associated technologies that operate in specific
    ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The frequency spectrum for wireless communications](img/B21282_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The frequency spectrum for wireless communications
  prefs: []
  type: TYPE_NORMAL
- en: LoRa operates in the unlicensed frequency range of 867-869 MHz in Europe, 902-928
    MHz in North America, and 915-928 MHz in Australia (*Figure 9**.4*). These frequencies
    are chosen for their balance of range and penetration, ideal for the low-power,
    long-range communication that LoRa enables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specific frequency bands can vary within the ranges shown in *Figure 9**.4*
    based on national regulations. We should always check local regulations to ensure
    compliance with the specific frequencies allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – LoRa frequencies based on location](img/B21282_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – LoRa frequencies based on location
  prefs: []
  type: TYPE_NORMAL
- en: The use of unlicensed bands comes with regulatory limitations to ensure fair
    usage and minimize interference. In Europe, the 868 MHz band is subject to a duty-cycle
    limitation of 1%, restricting transmission time. In North America, the 915 MHz
    band has dwell-time restrictions, limiting the occupancy time of a signal on a
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: These limitations encourage efficient spectrum use and innovative communication
    protocol development, as seen in LoRa’s effectiveness within these frameworks.
    We will consider these limitations when we start writing LoRa code in the upcoming
    section, *Building a LoRa* *sensory transmitter*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of the frequency spectrum and LoRa’s
    position within it, let’s explore the **Spreading Factor** (**SF**), a key parameter
    in LoRa that impacts the network’s range, data rate, and power efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the LoRa SF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LoRa employs **Chirp Spread Spectrum** (**CSS**) technology, where signals vary
    in frequency over time to encode data. This technique boosts signal reliability
    and minimizes power consumption, making it ideal for IoT devices that operate
    over extended periods. The use of a broad frequency range in LoRa enables devices
    to maintain connectivity over long distances while consuming less power. In this
    process, data transmission involves changing the signal’s frequency across a wide
    spectrum, significantly enhancing its resistance to interference and noise.
  prefs: []
  type: TYPE_NORMAL
- en: Complementing this, LoRa’s SF, a key parameter in LoRa communication, ranges
    from `SF7` to `SF12`. The SF determines the duration of each symbol (data packet)
    transmission, essentially balancing transmission range and data rate. Higher SFs,
    such as `SF12`, extend the range but reduce the data rate, making them suitable
    for long-distance communication. In contrast, lower SFs such as `SF7` offer faster
    data rates over shorter distances. This flexibility allows LoRa to cater to a
    wide array of use cases, from densely populated urban areas in smart cities to
    remote areas requiring long-range monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 9**.5*, we see the SF illustrated in an agricultural setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – SF illustrated in an agricultural setting](img/B21282_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – SF illustrated in an agricultural setting
  prefs: []
  type: TYPE_NORMAL
- en: The range increases with the SF number, but higher SFs also require more power
    due to extended transmission times. For effective communication, it’s essential
    that both the sender and receiver are configured with the same SF.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored LoRa communication technology, let’s incorporate what
    we’ve learned into the Raspberry Pi Pico and Pico W.
  prefs: []
  type: TYPE_NORMAL
- en: Using LoRa with the Raspberry Pi Pico and Pico W
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we will develop both a LoRa sensory transmitter and a LoRa
    receiver. Our LoRa sensory transmitter will utilize the Raspberry Pi Pico, a DHT22
    temperature sensor, and an RFM95W LoRa module. Our LoRa receiver will use a Raspberry
    Pi Pico W, an LED, and an RFM95W LoRa module. We may see our application outlined
    in *Figure 9**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – LoRa sensory transmitter and LoRa receiver](img/B21282_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – LoRa sensory transmitter and LoRa receiver
  prefs: []
  type: TYPE_NORMAL
- en: We will begin creating our application by building a LoRa sensory transmitter.
    We will start with wiring up an RFM95W LoRa module to a Raspberry Pi Pico before
    we move on to installing the temperature sensor in a test circuit. Finally, we
    will install the components into a custom 3D-printed case.
  prefs: []
  type: TYPE_NORMAL
- en: Building a LoRa sensory transmitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a LoRa sensory transmitter with a temperature
    sensor using a Raspberry Pi Pico, an RFM95W LoRa module, and a DHT22 temperature
    sensor. Our goal is to create a device that reads temperature and humidity data
    from a DHT22 temperature sensor and transmits this information using the RFM95W
    LoRa module. We will use the Raspberry Pi Pico and not Pico W for our design,
    although we could just as easily swap out the Pico for the Pico W.
  prefs: []
  type: TYPE_NORMAL
- en: For building and testing our circuit, we will use a Raspberry Pi Pico WH installed
    on a Pico GPIO expander. Using a Pico WH allows us to build and test circuits
    for both Pico and Pico W applications. We will use Pico W for the receiver part
    of our application and not the Pico WH due to size constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of using a standard Pico over a Pico W
  prefs: []
  type: TYPE_NORMAL
- en: Besides its cost advantage, the Raspberry Pi Pico offers benefits over the Raspberry
    Pi Pico W for our LoRa sensory transmitter. The standard Pico, known for its lower
    power consumption, is well-suited for tasks that don’t require Wi-Fi. Its simpler
    design leads to reduced firmware overhead, allowing the device to focus its resources
    on specific tasks rather than managing Wi-Fi connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also build a custom case to house our components. This case will not only
    offer protection but will also ensure organized wiring and enhance the overall
    durability and portability of our LoRa sensory transmitter. We will start off
    by adding wires to the RFM95W LoRa module and wiring it up to our Raspberry Pi
    Pico WH for development. We will later replace the Pico WH with a Pico as we install
    our components into a custom case.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing our circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RFM95W is a compact LoRa module favored for its long-range capabilities
    and low power consumption. Designed for sub-GHz frequency operation, it’s well-suited
    for applications that demand efficient, long-distance wireless communication.
    Despite its small size, the RFM95W excels in covering greater distances than conventional
    wireless technologies, making it particularly effective in open environments.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by soldering jumper wires onto the RFM95W.
  prefs: []
  type: TYPE_NORMAL
- en: Adding wires to the RFM95W
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Measuring only 16 mm by 16 mm, the RFM95W module is tiny. Care must be taken
    when soldering the jumper wires to the holes of the RFM95W. This is not a soldering
    job for someone first learning to solder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 1* of *Figure 9**.7*, we see the RFM95W prior to adding our jumper
    wires. The type of jumper wires we add depends on the breadboarding option we
    choose. For example, in this case, we are adding female jumper wires (*Step 2*
    of *Figure 9**.7*) as we will be using a GPIO expander for our Raspberry Pi Pico
    WH:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Adding wires to the RFM95W](img/B21282_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Adding wires to the RFM95W
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – RFM95W pins for wiring](img/B21282_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – RFM95W pins for wiring
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not need to solder wires to every terminal of the RFM95W. In *Figure
    9**.8*, we outline the terminals that we require jumper wires for and the length
    of wire needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Our table illustrates that the length of the wire used for our antenna differs
    based on the specific frequency model of the RFM95W LoRa module we choose. To
    account for this variation, we’ve designed different versions of our custom case
    to accommodate each model.
  prefs: []
  type: TYPE_NORMAL
- en: Each case version incorporates a straight antenna wire enclosure, effectively
    creating a built-in antenna specifically tailored for the respective frequency.
    This aspect of the design is particularly appealing for those of us who have encountered
    issues with low-cost antennas that don’t accurately match their labeled frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: Adafruit RFM95W LoRa Radio Transceiver Breakout
  prefs: []
  type: TYPE_NORMAL
- en: For those of us who wish to work with a LoRa board that is larger than the standard
    RFM95W, the Adafruit RFM95W LoRa Radio Transceiver Breakout is a great option.
    Unlike our RFM95W, this board is breadboard-friendly, using header pins.
  prefs: []
  type: TYPE_NORMAL
- en: To reinforce the soldered connections of the jumpers on our RFM95W, we can apply
    glue from a hot glue gun, as detailed in *Step 3* of *Figure 9**.7*. We use these
    jumpers to plug the module into the Raspberry Pi Pico WH GPIO expander for initial
    testing and prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling our circuit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the jumper wires soldered to our RFM95W model, we may now construct our
    circuit on a Raspberry Pi Pico GPIO expander. *Figure 9**.9* illustrates a wiring
    diagram for the Raspberry Pi Pico, Raspberry Pi Pico WH, and the RFM95W LoRa module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Wiring the RFM95W module to the Raspberry Pi Pico](img/B21282_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Wiring the RFM95W module to the Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our circuit, we add a DHT22 temperature sensor to our circuit using
    the wiring diagram in *Figure 9**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Wiring up a DHT22 to the Raspberry Pi Pico (WH)](img/B21282_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Wiring up a DHT22 to the Raspberry Pi Pico (WH)
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 9**.11* (*A*), we get a practical view of our circuit layout using
    a Raspberry Pi Pico with a GPIO expander (before the DHT22 is added). In our example,
    we’re utilizing a Raspberry Pi Pico WH and the GPIO expander for circuit construction
    and testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Raspberry Pi Pico WH with GPIO expander and RFM95W LoRa module](img/B21282_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Raspberry Pi Pico WH with GPIO expander and RFM95W LoRa module
  prefs: []
  type: TYPE_NORMAL
- en: We can see a table with the wire connections in *Figure 9**.11* (*B*) and what
    our Raspberry Pi Pico and RFM95W will look like wired together in the case in
    *Figure* *9**.11* (*C*).
  prefs: []
  type: TYPE_NORMAL
- en: With our circuit wired up, we are now ready to write our code to send temperature
    and humidity data through LoRa. We will use Thonny as our development environment
    and the CircuitPython firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our application, we will use **CircuitPython** over **MicroPython** due
    to several key differences between these Python implementations. CircuitPython,
    a derivative of MicroPython developed by Adafruit, offers a more streamlined experience
    for specific use cases, particularly with its comprehensive library support.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our development by installing the CircuitPython firmware onto
    our Raspberry Pi Pico WH.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up CircuitPython and sensor libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We develop our application for the Raspberry Pi Pico (WH) using the Thonny IDE,
    a tool that’s compatible with various development environments such as Raspberry
    Pi, Windows, Linux, and macOS. For our example, we are using Thonny on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of setting up the Raspberry Pi Pico (WH), the installation of CircuitPython
    via Thonny is a straightforward process, like how we would install MicroPython.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install CircuitPython on our Raspberry Pi Pico (WH), we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If Thonny is not available on our operating system, we visit the Thonny website
    and download an appropriate version ([https://thonny.org](https://thonny.org)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then launch Thonny using the appropriate method for our operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While holding the *BOOTSEL* button on the Pico (WH), the small white button
    near the USB port, we insert it into an available USB port and disregard any pop-up
    windows that may appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9\. 12 – BOOTSEL button as shown on a Pico WH (Pico similar)](img/B21282_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9\. 12 – BOOTSEL button as shown on a Pico WH (Pico similar)
  prefs: []
  type: TYPE_NORMAL
- en: 'We then click on the interpreter information at the bottom right-hand side
    of the screen and select **Install CircuitPython…**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Install CircuitPython… option](img/B21282_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Install CircuitPython… option
  prefs: []
  type: TYPE_NORMAL
- en: 'For `RPI-RP2 (D:)`). In our example, we select the **Raspberry Pi • Pico /
    Pico H** CircuitPython variant and the latest version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Installing MicroPython on the Raspberry Pi Pico W](img/B21282_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Installing MicroPython on the Raspberry Pi Pico W
  prefs: []
  type: TYPE_NORMAL
- en: Even though we are developing on a Pico WH, we treat it as a Pico for development
    purposes. We click on the **Install** button and then the **Close** button once
    the installation has completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To have Thonny configured to run the CircuitPython interpreter on our Pico
    (WH), we select it from the bottom right-hand side of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Selecting the CircuitPython interpreter](img/B21282_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Selecting the CircuitPython interpreter
  prefs: []
  type: TYPE_NORMAL
- en: 'We confirm that Thonny is using the CircuitPython interpreter on our Raspberry
    Pi Pico (WH) by checking the **Shell**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – CircuitPython prompt in Thonny](img/B21282_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – CircuitPython prompt in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: With CircuitPython installed, we are now ready to install the libraries we need
    for our code. This involves downloading the package from the Adafruit website
    and copying over the library files we need to our Raspberry Pi Pico (WH).
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a web browser, we navigate to the following URL: [https://circuitpython.org/libraries](https://circuitpython.org/libraries).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we are using CircuitPython 8, we download the `adafruit-circuitpython-bundle-8.x-mpy-20231205.zip`
    ZIP file and unzip it to a location on our computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The two files we are interested in are `adafruit_rfm9x.mpy` and `adafruit_dht.mpy`,
    both of which may be found in the `lib` folder in the unzipped directory. These
    files are library files for our RFM95W and DHT22 sensors respectively. To install
    these libraries onto our Raspberry Pi Pico (WH) from Thonny, we locate them in
    the **Files** section and right-click to get the following dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Uploading a library file to the Raspberry Pi Pico (WH)](img/B21282_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Uploading a library file to the Raspberry Pi Pico (WH)
  prefs: []
  type: TYPE_NORMAL
- en: 'We must ensure that we upload these libraries to the `lib` folder on our Pico
    (WH) and not the root directory. This would involve double-clicking on the `lib`
    folder under the **CircuitPython device** section in Thonny to open it. After
    uploading the libraries to the Pico (WH), the file structure on our Pico (WH)
    should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Pico file structure after uploading libraries](img/B21282_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Pico file structure after uploading libraries
  prefs: []
  type: TYPE_NORMAL
- en: With our circuit built and CircuitPython and the libraries installed, it is
    time to write our code. As we will see, we do not require a great amount of code
    to send temperature and humidity data through LoRa.
  prefs: []
  type: TYPE_NORMAL
- en: Creating LoRa transmission code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To comply with different regulatory standards, we’ll use a delay for our LoRa
    transmissions. While Europe’s 1% duty-cycle limit allows for a 99-second delay
    between messages, we’ll extend this to 120 seconds, due to the stable nature of
    temperature and humidity data. This will result in a duty cycle of approximately
    0.83%.
  prefs: []
  type: TYPE_NORMAL
- en: Although North America’s regulations focus on dwell time, the period a transmitter
    occupies a frequency channel rather than a duty cycle, we’re adopting this duty-cycle
    approach for uniformity. We will use the 915 MHz frequency version of the RFM95W
    for our application as the author is based in North America.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write our LoRa transmission code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico (WH) to a USB port and launch Thonny. We may
    use our Raspberry Pi or another operating system for this. In our example, we
    are using Thonny on Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the CircuitPython environment on our Pico (WH) by selecting
    it from the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new tab, we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`time`, `board`, `busio`, `digitalio`, `adafruit_rfm9x` (for LoRa communication),
    and `adafruit_dht` (for the DHT22 sensor).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**We then set up SPI communication**: We configure SPI with specific GPIO pins
    (GP18, GP19, GP16) for the RFM95W LoRa module.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**We initialize Chip Select (CS) and Reset (RST) pins**: We set up digital
    I/O for CS (GP17) and RST (GP14) pins.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**We then create an RFM95W LoRa object**: We initialize the RFM9x object for
    LoRa communication at 915.0 MHz. This value should be set based on local regulations.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**We initialize the DHT22 sensor**: We set up the DHT22 temperature and humidity
    sensor on GPIO 4 (GP4).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**We then print a status message**: We indicate that temperature and humidity
    data will be sent every 120 seconds.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**We continuously send data**: In an infinite loop, we read temperature and
    humidity from the DHT22 sensor, format the data, and send it over LoRa. If a read
    error occurs, we print an error message.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**We then delay between transmissions**: We wait for 120 seconds before sending
    the next set of data.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To save the file, we click on **File** | **Save as...** from the drop-down
    menu. This will open the following dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Saving a file to our Raspberry Pi Pico (WH)](img/B21282_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Saving a file to our Raspberry Pi Pico (WH)
  prefs: []
  type: TYPE_NORMAL
- en: In this dialog, we are given the option to choose where to store our file. To
    save it on our Raspberry Pi Pico (WH), we click on the corresponding button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then give the file the name `code.py` and click `code.py` is special because
    the system automatically executes this file upon startup or reset, making it the
    default script that runs when the device powers up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What SF are we using?
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we don’t explicitly set the SF, so the `adafruit_rfm9x` library’s
    default is used. Typically, this is an SF of `7`. Since we’re using the default
    SF for both `transmit` and `receive` nodes, there’s no need to focus on this setting
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: To run our code, we click on the green run button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Shell**, we’ll see a notification confirming the creation of a LoRa
    message containing temperature and humidity data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.20 – LoRa message notification](img/B21282_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – LoRa message notification
  prefs: []
  type: TYPE_NORMAL
- en: To recap, we have just created a LoRa sensory transmitter that sends temperature
    and humidity sensory data wirelessly. In the absence of errors, it’s reasonable
    to assume successful transmission of our LoRa message. However, without a LoRa
    receiver, we can’t confirm this. We’ll address this by building one in the next
    section. Before constructing the receiver, we’ll first house our components in
    a custom 3D-printed case.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the components in a custom case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing our practice from previous projects, we’ll install our components
    in a custom case. This approach allows convenient placement of our LoRa sensory
    transmitter wherever it’s needed. We can see the custom case for our LoRa sensory
    transmitter displayed in *Figure 9**.21*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of our custom case accommodates the DHT22 sensor, allowing it to
    extend from the front for accurate temperature and humidity readings. The antenna,
    a straight wire soldered to the RFM95W module, is housed in a protruding section
    attached to the base plate of the case. An antenna cover specifically designed
    for this purpose completes the enclosure, protecting and isolating the antenna.
    The 915 MHz version of the custom case is displayed in *Figure 9**.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Custom case used for our LoRa transmitter node](img/B21282_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Custom case used for our LoRa transmitter node
  prefs: []
  type: TYPE_NORMAL
- en: Our custom case is designed with a versatile GoPro-style hook at the back, enabling
    compatibility with various stands we’ve constructed in earlier chapters of the
    book. This feature allows for easy and flexible mounting of our LoRa sensory transmitter.
  prefs: []
  type: TYPE_NORMAL
- en: The micro-USB port on the Raspberry Pi Pico is exposed, allowing us to provide
    power to our device. We may also use this port to program our Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: Using power banks for our Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: We can power our node remotely using a standard cell phone power bank. However,
    it’s important to select a power bank that doesn’t automatically shut off due
    to low power draw, as the Raspberry Pi Pico has minimal power requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We will start the construction of our custom case by identifying the parts.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the parts of our custom LoRa case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our custom case features 3D-printed parts that screw together. We may see the
    parts and major components displayed in *Figure 9**.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Parts for custom case](img/B21282_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Parts for custom case
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down each part:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raspberry Pi Pico (*A* in *Figure 9**.22*): We use the header-less version
    of the Raspberry Pi Pico due to space constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backplate (*B* in *Figure 9**.22*): The backplate secures both the Raspberry
    Pi Pico and the RFM95W LoRa module. The length of the extension for the antenna
    is based on the frequency model used. In this example, we see the 915 MHz model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Antenna cover (*C* in *Figure 9**.22*): The antenna cover is used to enclose
    the wire antenna with the back plate (*B*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Front shell (*D* in *Figure 9**.22*): The front shell holds the DHT22 sensor
    and encloses the back plate (*B*) to complete the case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DHT22 temperature and humidity sensor (*E* in *Figure 9**.22*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFM95W LoRa module (*F* in *Figure 9**.22*): The version shown is the 915 MHz
    model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hook (*G* in *Figure 9**.22*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x M3 10 mm bolts (not shown).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 x M2 5 mm screws (not shown).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the parts identified, it is now time to assemble our custom case.
  prefs: []
  type: TYPE_NORMAL
- en: Building the custom LoRa case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build the custom case, we follow the steps shown in *Figure 9**.23* and
    outlined next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Steps to build custom case](img/B21282_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – Steps to build custom case
  prefs: []
  type: TYPE_NORMAL
- en: We start by securing the hook (*G* in *Figure 9**.22*) to the back plate (*B*
    in *Figure 9**.22*) using either epoxy glue or two M2 5 mm screws (*Figure 9**.23*,
    *Step 1*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the wiring diagrams from *Figures 9.9* and *9.10*, we solder the wires
    from the RFM95W and DHT11 sensors to the Raspberry Pi Pico.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using four M2 5 mm screws, we secure the Raspberry Pi Pico (*A* in *Figure 9**.22*)
    to the back plate (*B* in *Figure 9**.22*) such that the USB port is facing down
    and pointing toward the bottom of the back plate or away from the antenna (*Figure
    9**.23*, *Step 2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a hot glue gun, we secure the DHT22 (*E* in *Figure 9**.22*) to the front
    shell (*D* in *Figure 9**.22*). Alternatively, two M3 5 mm bolts may be used depending
    on the holes present on the DHT22 (*Figure 9**.23*, *Step 3*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We friction fit the RFM95W (*F* in *Figure 9**.22*) to the back plate (*B* in
    *Figure 9**.22*) such that the antenna wire sits next to the wire slot on the
    back plate and extends through (*Figure 9**.23*, *Step 3*). If the RFM95W does
    not stay in place, glue from a hot glue gun may be used to secure it in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using two M3 10 mm, bolts we secure the back plate to the front shell (*Figure
    9**.23*, *Step 4*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We secure the antenna cover (*C* in *Figure 9**.22*) to the front of the back
    plate using two M2 5 mm screws.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we used a separate Raspberry Pi Pico WH for writing our coding, we’ll need
    to install CircuitPython, the necessary libraries, and our code onto the new Pico.
    Testing the code with Thonny is advisable to check for any issues that might arise
    during the installation of components into the custom case.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our LoRa sensory transmitter is ready, we’ll proceed to construct a
    LoRa receiver. This device will be responsible for receiving sensory information
    from the transmitter. We’ll keep the receiver design simple, with its primary
    function being to acknowledge the receipt of LoRa messages. For this purpose,
    an LED will suffice to indicate the status.
  prefs: []
  type: TYPE_NORMAL
- en: Building a LoRa receiver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Figure 9**.6*, we see a LoRa receiver processing messages from our LoRa
    sensory transmitter. Our receiver design is straightforward, requiring only an
    LED to acknowledge received messages. We’re utilizing a Raspberry Pi Pico W for
    the receiver as we plan to leverage its Wi-Fi capabilities in the next chapter
    and publish sensory data to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover the steps to install CircuitPython or the required libraries
    onto the Pico W of the LoRa receiver as we covered these steps already for the
    LoRa sensory transmitter, and we merely need to do the same for the receiver.
    We should use the Pico W version of CircuitPython for this part of the project
    as we will implement Wi-Fi functionality in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we won’t detail the construction of the custom case for the LoRa receiver
    as it mirrors the transmitter’s process. The key variation is fitting an LED with
    a resistor and LED holder in place of the DHT22 sensor in the front shell. The
    steps for installing an LED were previously outlined in *Figures 6.22* and *6.23*
    of [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on the code for the LoRa receiver and highlight
    the results of an outdoor test of both the LoRa sensory transmitter and the LoRa
    receiver.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a wiring diagram of the LED with a resistor to our Raspberry
    Pi Pico W.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring an LED to the Raspberry Pi Pico W
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our LoRa receiver, we require an LED to use for acknowledging LoRa messages.
    Based on what we have learned so far in this book, we could easily enhance our
    LoRa receiver with a more robust visualization such as an OLED screen. As we aim
    to focus only on acknowledging a LoRa signal, we will stick with a simple LED.
    We may monitor LoRa messages from the Shell in Thonny while running our LoRa receiver
    in that environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Raspberry Pi Pico W, 220 Ohm resistor, and LED](img/B21282_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – Raspberry Pi Pico W, 220 Ohm resistor, and LED
  prefs: []
  type: TYPE_NORMAL
- en: To connect an LED to our Raspberry Pi Pico W, we solder a 220 Ohm resistor to
    the anode of an LED. We then connect the resistor to the GP5 port on the Pico.
    For ground, we connect the cathode of the LED to any GND pin on the Pico W (*Figure
    9**.24*).
  prefs: []
  type: TYPE_NORMAL
- en: With the 220 Ohm resistor and LED connected to our Pico W, we then connect an
    RMM95W LoRa module to our Pico W using the steps from the previous section, *Building
    a LoRa* *sensory transmitter*.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to start writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating code to receive LoRa messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our LoRa receiver code uses the Adafruit `adafruit_rfm9x` library to listen
    for LoRa messages. Upon receipt, it prints the message to the Shell in Thonny
    and flashes the LED twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write our LoRa receiver code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use
    our Raspberry Pi or another operating system for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the CircuitPython environment on our Pico W by selecting it
    from the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new tab, we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We start by importing the necessary libraries: `time`, `board`, `busio`, `digitalio`,
    and `adafruit_rfm9x` for LoRa communication.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then set up SPI communication by configuring SPI using GPIO pins GP18 (SCK),
    GP19 (MOSI), and GP16 (MISO).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We initialize CS and RST pins by setting up GP17 for CS and GP14 for RST.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create an RFM95W LoRa object and initialize the object for 915.0 MHz communication.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We initialize an LED on GP5.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then print a status message indicating that the device is listening for LoRa
    messages.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a function to flash the LED so that we may flash the LED a specified
    number of times with a set duration.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In a continuous loop, we listen for LoRa messages, checking for incoming LoRa
    packets, printing any received message, and flashing the LED twice for 0.5 seconds
    each upon receiving a packet.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To save the file, we click on **File** | **Save as...** from the drop-down menu.
    This will open the **Where to save** **to?** dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this dialog, we are given the option to choose where to store our file. To
    save it on our Raspberry Pi Pico W, we click on the corresponding button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then give the file the name `code.py` and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run our code, we click on the green run button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is not already running, we power up and run the LoRa sensory transmitter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Shell, we’ll see a notification confirming the receipt of a LoRa message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.25 – Receiving LoRa messages](img/B21282_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – Receiving LoRa messages
  prefs: []
  type: TYPE_NORMAL
- en: We should also observe our LED flashes twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With a positive result, we not only confirm that our LoRa receiver is working
    properly but our LoRa sensory transmitter as well. To take full advantage of our
    application, we need to use our transmitter and receiver outside. To do this,
    we should install our LoRa receiver in its own custom case. As mentioned, we follow
    the same steps outlined for the LoRa sensory transmitter substituting the LED
    with a resistor and the LED holder with a DHT22 temperature sensor.
  prefs: []
  type: TYPE_NORMAL
- en: With both the LoRa sensory transmitter and LoRa, it is time to take our application
    outdoors.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LoRa communication is known for its ability to cover long distances, a feature
    that sets it apart in the field of wireless communication technologies. While
    typical LoRa transmissions range from a few kilometers in urban settings to over
    10 kilometers in rural areas, the technology has demonstrated far greater potential
    under optimal conditions. A world record was established with a LoRa transmission
    reaching 766 kilometers (476 miles) using just 25 mW of transmission power. This
    record highlights LoRa’s exceptional long-range capabilities, especially when
    conditions are favorable and the setup is optimized for maximum reach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 9**.26*, we observe the results of testing our application over
    a modest distance of 160 meters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Testing our LoRa sensory transmitter and LoRa receiver at a
    distance of 160 meters](img/B21282_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – Testing our LoRa sensory transmitter and LoRa receiver at a distance
    of 160 meters
  prefs: []
  type: TYPE_NORMAL
- en: Alternative testing methods
  prefs: []
  type: TYPE_NORMAL
- en: We may also test our application by applying heat from a source such as a hair
    dryer, or we may even place our LoRa transmitter in a fridge and observe the results.
  prefs: []
  type: TYPE_NORMAL
- en: This distance, while modest for LoRa, is significant when considering applications
    such as farm monitoring, where sensors can be spread over large areas, far beyond
    the reach of traditional Wi-Fi networks, which are typically constrained to about
    50 meters indoors and less than 100 meters in open spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored LoRa technology, an important component in IoT
    communication. We started by discussing LoRa’s ability to transmit data over long
    distances with low power use, emphasizing its importance in wireless technology.
    We looked at its applications in agriculture, where it improves sensory network
    management for crop management, and in urban settings for smart city initiatives
    such as street lighting control.
  prefs: []
  type: TYPE_NORMAL
- en: We then examined the technical aspects of LoRa within the radio frequency spectrum.
    This includes understanding how frequencies are allocated for wireless communications,
    which is important for identifying the right frequency bands for LoRa transmissions.
  prefs: []
  type: TYPE_NORMAL
- en: For our hands-on sections, we built a LoRa sensory transmitter and LoRa receiver
    using Raspberry Pi Pico and Pico W respectively. This involved constructing a
    transmitter with a LoRa module and temperature sensor and a LoRa receiver using
    a simple LED acknowledgment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take things further as we connect our LoRa receiver
    to the internet and use this to control a new version of the analog-metered weather
    indicator we created in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048).
  prefs: []
  type: TYPE_NORMAL
