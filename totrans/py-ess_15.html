<html><head></head><body><div class="chapter" title="Chapter&#xA0;15.&#xA0;Next Steps"><div class="titlepage"><div><div><h1 class="title"><a id="ch15"/>Chapter 15. Next Steps</h1></div></div></div><p>After studying the Python basics, what's next? Each developer's journey will vary, based on the general architecture of the application that they're going to build. In this chapter, we'll look at four kinds of Python applications. We'll look at <a class="indexterm" id="id711"/>
<span class="strong"><strong>command-line interface</strong></span> (<span class="strong"><strong>CLI</strong></span>) applications in some depth. We'll look briefly at <a class="indexterm" id="id712"/>
<span class="strong"><strong>graphical user interface</strong></span> (<span class="strong"><strong>GUI</strong></span>) applications. There are a number of graphics libraries and a number of frameworks that we might use for this; it's difficult to address all of the alternatives.</p><p>Web server applications often involve a sophisticated web framework that handles the standardized overheads. Our Python code will plug into this framework. As with GUI applications, there are several commonly used frameworks. We'll look quickly at a few common features of web frameworks. We'll also look at the big data context as epitomized by the Hadoop server's streaming interface.</p><p>This isn't intended to be complete or even representative. Python is used in many different ways.</p><div class="section" title="Leveraging the standard library"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec125"/>Leveraging the standard library</h1></div></div></div><p>When <a class="indexterm" id="id713"/>implementing Python solutions, it's helpful to scan the standard library for relevant modules. The library is large, making it somewhat intimidating at first. We can, however, focus our search.</p><p>We can break the <span class="emphasis"><em>Python Standard Library</em></span> document into three portions. The first five chapters are general reference material that all Python programmers need to understand. The next 20 chapters, plus chapters 28 and 32, describe modules that we might incorporate into a wide variety of applications. The remaining chapters are less useful; they're more focused on Python internals and ways in which to extend the language itself.</p><p>The name and the summary of a module in the library table of contents may not provide enough information to see all of the ways in which a module might be used. The <code class="literal">bisect</code> module, for example, can be extended to create a fast dictionary that retains its keys in a defined order. This isn't obvious without careful reading of the description of the module.</p><p>Some <a class="indexterm" id="id714"/>of the library modules have relatively small, easy-to-understand implementations. For larger modules and packages, there are often pieces that can be lifted out of context and reused widely. As an example, consider an application that uses <code class="literal">http.client</code> to make REST web services requests. We often need functions from the <code class="literal">urllib.parse</code> module to encode a query string or properly quote parts of the URL. It's common to see a long list of imports at the front of Python applications.</p></div></div>
<div class="section" title="Leveraging PyPI &#x2013; the Python Package Index"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec126"/>Leveraging PyPI – the Python Package Index</h1></div></div></div><p>After <a class="indexterm" id="id715"/>scanning the library, the next place to look for additional Python packages is<a class="indexterm" id="id716"/> the <a class="indexterm" id="id717"/>
<span class="strong"><strong>Python Package Index</strong></span> (<span class="strong"><strong>PyPI</strong></span>) at <a class="ulink" href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a>. There are thousands of packages listed here, with varying degrees of support and quality.</p><p>As we noted in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, Python 3.4 also installs two scripts to help us add packages, <code class="literal">pip</code> and <code class="literal">easy_install</code>. These search PyPI for the requested package. Most packages can be found by using their name; the tools locate the appropriate release for the platform and Python version.</p><p>We've mentioned a few external libraries in other chapters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">nose</code> for <a class="indexterm" id="id718"/>writing tests, see <a class="ulink" href="https://pypi.python.org/pypi/nose/1.3.6">https://pypi.python.org/pypi/nose/1.3.6</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">docutils</code> for<a class="indexterm" id="id719"/> writing documentation, see <a class="ulink" href="https://pypi.python.org/pypi/docutils/0.12">https://pypi.python.org/pypi/docutils/0.12</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">Sphinx</code> for <a class="indexterm" id="id720"/>writing complex documentation, see <a class="ulink" href="https://pypi.python.org/pypi/Sphinx/1.3.1">https://pypi.python.org/pypi/Sphinx/1.3.1</a></li></ul></div><p>Additionally, there are bundles of packages available: we might install Anaconda, NumPy, or SciPy, each of which includes a number of other packages in one tidy distribution. See <a class="ulink" href="http://continuum.io/downloads">http://continuum.io/downloads</a>, <a class="ulink" href="http://www.numpy.org">http://www.numpy.org</a>, or <a class="ulink" href="http://www.scipy.org">http://www.scipy.org</a>.</p><p>In some cases, we may have Python configurations that are incompatible with each other. For example, we may have to work in two environments, one using the older Beautiful Soup 3 with the other using the newer version 4. Refer to <a class="ulink" href="https://pypi.python.org/pypi/beautifulsoup4/4.3.2">https://pypi.python.org/pypi/beautifulsoup4/4.3.2</a>. To simplify this switch, we can use the <code class="literal">virtualenv</code> tool to create isolated Python environments with their own complex trees of interdependent modules. See <a class="ulink" href="https://virtualenv.pypa.io/en/latest/">https://virtualenv.pypa.io/en/latest/</a>.</p><p>The Python ecosystem is large and sophisticated. There's no good reason to invent a solution in a <a class="indexterm" id="id721"/>vacuum. It's often best to locate the appropriate components or partial solutions, then download and extend them.</p></div>
<div class="section" title="Types of applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec127"/>Types of applications</h1></div></div></div><p>We'll<a class="indexterm" id="id722"/> look at four types of Python applications. These are neither the most common nor the most popular kinds of Python applications; they were selected more or less randomly based on the author's narrow experience. Python is used widely, and any attempt to summarize all of the various places where Python is used runs the risk of misleading rather than informing.</p><p>We'll look at CLI applications for two reasons. Firstly, they can be relatively simple, relying on fewer additional packages or frameworks than other kinds of applications. Secondly, more complex applications will often be launched from a CLI main script. For these reasons, the CLI features seem to be fundamental to most uses of Python.</p><p>We'll look at GUI applications because they are popular on the desktop. The difficulty here is that there are many GUI frameworks available for Python software development. Here's one list: <a class="ulink" href="https://wiki.python.org/moin/GuiProgramming">https://wiki.python.org/moin/GuiProgramming</a>. We'll focus on the <code class="literal">turtle</code> package because it's simple and built-in.</p><p>We'll look at web applications because Python is used with frameworks such as Django or Flask (among many others) to build high-volume websites. Here's a list of<a class="indexterm" id="id723"/> Python web frameworks: <a class="ulink" href="https://wiki.python.org/moin/WebFrameworks">https://wiki.python.org/moin/WebFrameworks</a>. We'll focus on Flask because it's relatively simple.</p><p>We'll also look at how Python can be used with Hadoop streaming to perform data analytics. Rather than download and install Apache Hadoop, we'll touch on how we build and test pipelined map-reduce processing on our desktop.</p></div>
<div class="section" title="Building CLI applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec128"/>Building CLI applications</h1></div></div></div><p>Our <a class="indexterm" id="id724"/>focus from <a class="indexterm" id="id725"/>the initial script example in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, was on using CLI scripting to learn Python <a class="indexterm" id="id726"/>basics. CLI applications have a number of common features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They often read from the standard input file, write to a standard output file, and produce logs or errors in the standard error file. The OS assures us that these files are always available. Python provides them as <code class="literal">sys.stdin</code>, <code class="literal">sys.stdout</code>, and <code class="literal">sys.stderr</code>. Furthermore, functions such as <code class="literal">input()</code> and <code class="literal">print()</code> use these files by default.</li><li class="listitem" style="list-style-type: disc">They often use environment variables for configuration. These values are available through <code class="literal">os.environ</code>.</li><li class="listitem" style="list-style-type: disc">They may also<a class="indexterm" id="id727"/> rely on shell features, like expanding <code class="literal">~</code> into a user's home directory, something done by <code class="literal">os.path.expanduser()</code>.</li><li class="listitem" style="list-style-type: disc">They often parse command-line arguments. While the variable <code class="literal">sys.argv</code> has the argument strings, these are awkward to work with directly. We'll use the <code class="literal">argparse</code> module to define the argument patterns, parse the strings, and create an object with the relevant argument values.</li></ul></div><p>These <a class="indexterm" id="id728"/>basic features cover many programming alternatives. A web server, for example, can be thought of as a CLI program that runs forever, servicing requests that come from a specific port number. A GUI application might start from the command line, but then open windows to permit user interaction.</p><div class="section" title="Getting command-line arguments with argparse"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec103"/>Getting command-line arguments with argparse</h2></div></div></div><p>We'll<a class="indexterm" id="id729"/> create a parser to use the command-line arguments, using the <code class="literal">argparse</code> module. Once configured, we can use that parser to create a small namespace object which has all of the argument values that were provided on the command line, or has default values. Our application can use this object to control its behavior.</p><p>Generally, we want to isolate command-line handling from the rest of our application. Here's a function that handles parsing, and then uses the parsed options to invoke another function to do the real work:</p><div class="informalexample"><pre class="programlisting">logger= logging.getLogger(__name__)
def main():
    parser= argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose",
        action="store_const", const=logging.DEBUG, default=logging.INFO)
    parser.add_argument("c", type=float)
    options= parser.parse_args()

    logging.getLogger().setLevel(options.verbose)
    logger.debug("Converting '{0!r}'".format(options.c))
    convert(options.c)</pre></div><p>We've built an <code class="literal">ArgumentParser</code> method using all of the default parameters. We could have identified the program name, provided a summary of usage, or have had anything else displayed when someone uses the <code class="literal">-h</code> option to get help. We omitted these extra bits of documentation to keep the example small.</p><p>We've defined two arguments for this application: an optional argument and a positional argument. The optional argument, <code class="literal">-v</code> or <code class="literal">--verbose</code>, stores a constant value in the resulting collection of options. The name of this attribute is the long name of the argument, <code class="literal">verbose</code>. The constant provided is <code class="literal">logging.DEBUG</code>; the default value if the option isn't present is <code class="literal">logging.INFO</code>.</p><p>The <a class="indexterm" id="id730"/>positional argument, <code class="literal">c</code>, accepts one command-line argument after all of the options have been parsed. The value for <code class="literal">nargs</code> can be omitted; it can be <code class="literal">'*'</code> to collect all arguments. We've provided a requirement that the input value is converted by the <code class="literal">float()</code> function, which means that non-numeric values will be rejected with an error during argument parsing. This will be set as the <code class="literal">c</code> attribute of the resulting object.</p><p>When we evaluate the <code class="literal">parse_args()</code> method, the defined arguments are used to parse the command-line values in <code class="literal">sys.argv</code>. The <code class="literal">options</code> object will have the resulting values or defaults.</p><p>In the second part of <code class="literal">main()</code>, we've used the <code class="literal">options</code> object to set the logging level for the root logger using the <code class="literal">verbose</code> argument value. We've then used a global <code class="literal">logger</code> object to dump the single positional argument value that will be assigned to the <code class="literal">c</code> attribute of the <code class="literal">options</code> object.</p><p>Finally, we've evaluated our application function with the input argument value; the parser assigned this to the <code class="literal">options.c</code> variable. The function which does the real work is designed to be entirely separate from the command-line interface that is used to invoke it. The function accepts a floating-point value and prints a result to a standard output. It can leverage the module global <code class="literal">logger</code> object.</p><p>Our goal in designing a CLI application is to completely separate the useful work from all interface considerations. This allows us to import the function which does the real work, and build larger or more complex applications from individual pieces. It generally means that the command-line arguments are transformed into ordinary function arguments or class constructor arguments.</p></div><div class="section" title="Using the cmd module for interactive applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec104"/>Using the cmd module for interactive applications</h2></div></div></div><p>Some<a class="indexterm" id="id731"/> CLI applications require user interaction. The <code class="literal">sftp</code> command, for example, can be used from the command line to exchange files with a server. We can create similar interactive applications using Python's <code class="literal">cmd</code> module.</p><p>To build a more complex interactive application, we can create a class which extends the <code class="literal">cmd.Cmd</code> class. Each method in this class that has a name starting with <code class="literal">do_</code> defines an interactive command. For example, if we define a method <code class="literal">do_get()</code>, this means that our application now has an interactive <code class="literal">get</code> command.</p><p>Any subsequent text after the user's input of <code class="literal">get</code> will be provided as an argument to the <code class="literal">do_get()</code> method. The <code class="literal">do_get()</code> function is then responsible for any further parsing and processing of the text after the command.</p><p>We can <a class="indexterm" id="id732"/>create an instance of this class, and call that inherited <code class="literal">cmdloop()</code> method to have a working interactive application. This allows us to deploy a working, interactive application very quickly and simply. While we're limited to a character-mode, command-line interface, we can easily add features without much extra work.</p></div></div>
<div class="section" title="Building GUI applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec129"/>Building GUI applications</h1></div></div></div><p>We can <a class="indexterm" id="id733"/>differentiate between applications which merely work with graphics and applications which are deeply interactive. In the<a class="indexterm" id="id734"/> first case, we might have a command-line application which creates or modifies image files. In the second case, we'll define an application which responds to input events. These interactive applications create an event loop which accepts mouse clicks, screen gestures, keyboard characters, and other events, and responds to those events. In some respects, the only unique feature of a GUI program is the wide variety of events it responds to.</p><p>The <code class="literal">tkinter</code> module<a class="indexterm" id="id735"/> is an interface between Python and the <a class="indexterm" id="id736"/>
<span class="strong"><strong>Tk</strong></span> user interface widget toolkit. This module helps us build richly interactive applications. When we use Python's built-in IDLE editor, we're using an application that was built with <code class="literal">tkinter</code>. The <code class="literal">tkinter</code> module documentation includes background information on the <a class="indexterm" id="id737"/>
<span class="strong"><strong>Tk</strong></span> widgets.</p><p>The <code class="literal">turtle</code> module <a class="indexterm" id="id738"/>also depends on the underlying <a class="indexterm" id="id739"/>
<span class="strong"><strong>Tk</strong></span> graphics. This module also allows us to build simple interactive applications. The turtle idea comes from the Logo programming language, in which graphic commands are used to animate a "turtle" which traverses the drawing space. The <code class="literal">turtle</code> model provides a very handy specification for certain types of graphics. For example, drawing a rotated rectangle can involve a rather complex calculation involving sine and cosine to determine the final locations of the four corners. Alternatively, we can direct the turtle to use commands such as <code class="literal">forward(w)</code>, <code class="literal">forward(l)</code>, and <code class="literal">right(90)</code> to draw a rectangle of the size <span class="emphasis"><em>w</em></span> × <span class="emphasis"><em>l</em></span> from any starting position and any initial rotation.</p><p>In order to make it easy to learn Python, the <code class="literal">turtle</code> module provides some essential classes that implement a <code class="literal">Screen</code> and a <code class="literal">Turtle</code>. The module also includes a rich collection of functions that implicitly work with a singleton <code class="literal">Turtle</code> and <code class="literal">Screen</code> object, eliminating any need to set up the graphics environment. For beginners, this function-only environment is a language of simple verbs that can be used to learn the foundations of programming.</p><p>Simple programs look like this:</p><div class="informalexample"><pre class="programlisting">from turtle import *

def on_screen():
    x, y = pos()
    w, h = screensize()
    return -w &lt;= x &lt; w and -h &lt;= y &lt; h

def spiral(angle, incr, size=10):
    while on_screen():
        right(angle)
        forward(size)
        size *= incr</pre></div><p>We've <a class="indexterm" id="id740"/>used <code class="literal">from turtle import *</code> to introduce all of the individual functions. This is the common setup for beginners.</p><p>We've defined a <a class="indexterm" id="id741"/>function, <code class="literal">on_screen()</code>, which compares the turtle's position, given by the <code class="literal">pos()</code> function, with the overall size of the screen, given by the <code class="literal">screensize()</code> function. Our function uses a simple logical expression to determine if the current turtle position is still within the display boundaries.</p><p>For people learning to program, the implementation details of the <code class="literal">pos()</code> and <code class="literal">screensize()</code> functions may not be that helpful. More advanced programmers may want to know that the <code class="literal">pos()</code> function uses the <code class="literal">Turtle.pos()</code> method of a singleton, global <code class="literal">Turtle</code> instance. Similarly, the <code class="literal">screensize()</code> function uses the <code class="literal">Screen.screensize()</code> method of a singleton, global <code class="literal">Screen</code> instance.</p><p>The function <code class="literal">spiral()</code> will draw a spiral-like shape using three parameters that define the line segments that comprise the spiral. This function relies on the <code class="literal">right()</code> and <code class="literal">forward()</code> functions from the <code class="literal">turtle</code> package to set the turtle's orientation and then draw a line segment. While the calculation of the end point of the segment drawn by <code class="literal">forward()</code> may involve a bit of trigonometry, a new programmer is able to learn the basics of iteration without struggling with sine or cosine.</p><p>Here's how we can use this function:</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    speed(10)
    spiral(size=10, incr=1.05, angle = 67)
    done()</pre></div><p>As part of the initialization, we've set the turtle speed to 10, which is fast. For people struggling with loops or conditions, a slower speed can help them follow their code as they watch the turtle. We've evaluated the <code class="literal">spiral()</code> function with a set of argument values.</p><p>The <code class="literal">done()</code> function will start a GUI event processing loop that will wait for user interaction. We've started the loop <span class="emphasis"><em>after</em></span> the interesting part of the drawing because the only expected event is the closing of the graphics window. When the window is closed by the user, the <code class="literal">done()</code> function will also finish. Our script can then end normally.</p><p>If we're going to <a class="indexterm" id="id742"/>build more complex interactive applications, there's a proper <code class="literal">mainloop()</code> function which we can use. This captures events so that our programs can respond to those events.</p><p>The Logo language—and the related <code class="literal">turtle</code> package—allow a novice programmer to learn the <a class="indexterm" id="id743"/>essentials of programming without having to master too many details at one time. The <code class="literal">turtle</code> package isn't designed to produce the same kinds of sophisticated technical graphics as a package such as <a class="indexterm" id="id744"/>
<span class="strong"><strong>matplotlib</strong></span> or <a class="indexterm" id="id745"/>
<span class="strong"><strong>Pillow.</strong></span>
</p><div class="section" title="Using more sophisticated packages"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec105"/>Using more sophisticated packages</h2></div></div></div><p>We<a class="indexterm" id="id746"/> can create complex image-processing applications using the Pillow library. This package allows us to create thumbnails of large images, convert image formats, and verify that a file actually contains encoded image data. We can also use this package to create simple scientific graphics showing two-dimensional plots of data points. This package isn't designed to build a complete GUI since it doesn't handle input events for us. For more information, see <a class="ulink" href="https://pypi.python.org/pypi/Pillow/2.8.1">https://pypi.python.org/pypi/Pillow/2.8.1</a>.</p><p>For mathematical, scientific, and statistical work, the matplotlib package is widely used. This includes very sophisticated tools for creating essential data plots in two and three dimensions. This package is bundled with SciPy and Anaconda. For more information, see <a class="ulink" href="http://matplotlib.org">http://matplotlib.org</a>.</p><p>There are several more generalized graphical frameworks. One that's often used to learn more about Python is the <a class="indexterm" id="id747"/>
<span class="strong"><strong>Pygame</strong></span> framework. This has a large number of components which include tools for graphics as well as sound and image processing. The Pygame package includes a number of graphics drivers and is capable of smooth animation with a large<a class="indexterm" id="id748"/> number of moving objects. See <a class="ulink" href="http://www.pygame.org/news.html">http://www.pygame.org/news.html</a>.</p></div></div>
<div class="section" title="Building web applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec130"/>Building web applications</h1></div></div></div><p>Web applications <a class="indexterm" id="id749"/>involve a great deal of processing, which is best described as boilerplate. The essential handling of the HTTP protocol, for example, is often standardized, with libraries that handle it gracefully. The details of parsing request headers and mapping a URL path to a specific resource <a class="indexterm" id="id750"/>don't need to be reinvented.</p><p>There is, however, a profound distinction between simply handling the HTTP protocol and mapping a URL to an application-specific resource. These two layers drive the definition of the <a class="indexterm" id="id751"/>
<span class="strong"><strong>Web Services Gateway Interface</strong></span> (<span class="strong"><strong>WSGI</strong></span>) design and the <code class="literal">wsgi</code> module is in the standard library. For more information, see <a class="indexterm" id="id752"/>
<span class="strong"><strong>Python Enhancement Proposal</strong></span> (<span class="strong"><strong>PEP</strong></span>) 3333, <a class="ulink" href="https://www.python.org/dev/peps/pep-3333/">https://www.python.org/dev/peps/pep-3333/</a>.</p><p>The idea <a class="indexterm" id="id753"/>behind WSGI is that all web services should adhere to a single, minimum standard for handling the details of HTTP requests and responses. This standard allows a complex web server to include a variety of Python tools and frameworks that are fitted together using WSGI to ensure that components interconnect properly. The mapping of URLs to resources must be handled in the context of this standard.</p><p>A <code class="literal">mod_wsgi</code> module<a class="indexterm" id="id754"/> can be plugged into an Apache HTTPD server. This module will pass requests and responses between the Apache frontend and backend Python instances. With a little bit of planning, we can be sure that static content—graphics, style sheets, JavaScript libraries, and so on—are handled by the frontend web server. The dynamic content—HTML pages, XML, or JSON documents—are handled by our Python application.</p><p>For more information on<a class="indexterm" id="id755"/> <code class="literal">mod_wsgi</code>, see <a class="ulink" href="http://www.modwsgi.org/">http://www.modwsgi.org/</a>.</p><div class="section" title="Using a web framework"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec106"/>Using a web framework</h2></div></div></div><p>Web applications in<a class="indexterm" id="id756"/> this context are generally built using a framework that parses URLs and invokes a Python function to return the resource located by the URL. While this is clearly the minimum required to create a web server, there are often a large number of additional features that we'd like to have.</p><p>Authentication and authorization, for example, are features we often need and would prefer not to have to implement. It's much nicer to work with a framework that allows us to add OAuth client code. A website that uses cookies will also benefit from having session management features that integrate seamlessly.</p><p>Many websites offer RESTful web services. Sometimes these services are thin wrappers around database access. When the database is relational, we often want an<a class="indexterm" id="id757"/> <span class="strong"><strong>Object Relational Mapper</strong></span> (<span class="strong"><strong>ORM</strong></span>) layer that allows us to expose more complete objects through the RESTful service. This, too, is a good option for a web server framework.</p><p>There are two broad approaches to providing web services in Python: kits and parts. The kits approach is epitomized by packages such as Django which offer just about everything that could possibly be required in a unified collection of modules and packages. See <a class="ulink" href="https://www.djangoproject.com">https://www.djangoproject.com</a>.</p><p>The parts approach can be seen in projects such as Flask. This is called a <span class="strong"><strong>microframework</strong></span> <a class="indexterm" id="id758"/>because it does relatively little. A Flask server focuses on URL routing, making<a class="indexterm" id="id759"/> it ideal for building RESTful services. It may include session management, allowing it to be used for HTML sites. It cooperates well with other projects such as Jinja2, WTForms, SQLAlchemy, OAuth authentication modules, and many other modules. For more information, see <a class="ulink" href="http://flask.pocoo.org/docs/0.10/">http://flask.pocoo.org/docs/0.10/</a>.</p></div><div class="section" title="Building a RESTful web service with Flask"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec107"/>Building a RESTful web service with Flask</h2></div></div></div><p>We'll <a class="indexterm" id="id760"/>demonstrate a very simple web service. We'll use the <a class="indexterm" id="id761"/>algorithm shown earlier in the turtle example, with some minor modifications, to create a dynamic graphic download. To make it easier to create a downloadable file, we'll discard the simplistic turtle graphics package and use the Pillow package to create the image file. Many websites use Pillow to validate uploaded images and create thumbnails. It's an essential part of any site that uses images.</p><p>For more information on <a class="indexterm" id="id762"/>Pillow, see <a class="ulink" href="https://pypi.python.org/pypi/Pillow/2.8.1">https://pypi.python.org/pypi/Pillow/2.8.1</a>.</p><p>A web service must provide a resource in response to an HTTP request. A simple Flask-powered site will have an overall application object and a number of routes which map URLs (and possibly method names) to functions.</p><p>Here's a simple example:</p><div class="informalexample"><pre class="programlisting">from flask import Flask, request
from PIL import Image, ImageDraw, ImageColor
import tempfile

spiral_app = Flask(__name__)

@spiral_app.route('/image/&lt;spec&gt;', methods=('GET',))
def image(spec):
    spec_uq= urllib.parse.unquote_plus(spec)
    spec_dict = urllib.parse.parse_qs(spec_uq)
    spiral_app.logger.info( 'image spec {0!r}'.format(spec_dict) )
    try:
        angle= float(spec_dict['angle'][0])
        incr= float(spec_dict['incr'][0])
        size= int(spec_dict['size'][0])
    except Exception as e:
        return make_response('URL {0} is invalid'.format(spec), 403)

    # Working dir should be under Apache Home.
    _, temp_name = tempfile.mkstemp('.png')

    im = Image.new('RGB', (400, 300), color=ImageColor.getrgb('white'))
    pen= Pen(im)
    spiral(pen, angle=angle, incr=incr, size=size)
    im.save(temp_name, format='png')

    # Should redirect so that Apache serves the image.
    spiral_app.logger.debug( 'image file {0!r}'.format(temp_name) )
    with open(temp_name, 'rb' ) as image_file:
        data = image_file.read()
    return (data, 200, {'Content-Type':'image/png'})</pre></div><p>This example<a class="indexterm" id="id763"/> shows three central features of Flask applications. This script defines a <code class="literal">Flask</code> instance. We've based the instance on the filename, which will be <code class="literal">"__main__"</code> for a main script, but will have the module name for an imported script. We've assigned that <code class="literal">Flask</code> container to a variable, <code class="literal">spiral_app</code>, for use throughout the module file.</p><p>A more <a class="indexterm" id="id764"/>complex Flask application may have a number of individual view functions in a package of submodules. Each of these will depend on the global Flask application.</p><p>Our image resource is created by the <code class="literal">image()</code> function. We provided a <code class="literal">route</code> decorator for this function that shows the URL path and the methods that work with this resource. There are a large number of methods defined for the HTTP protocol. Many RESTful web services focus on POST, GET, PUT, and DELETE because these match the idea of the <span class="strong"><strong>Create, Retrieve, Update, and Delete</strong></span> (<span class="strong"><strong>CRUD</strong></span>) rules<a class="indexterm" id="id765"/> commonly used to summarize database operations.</p><p>We've broken down the <code class="literal">image()</code> function into four separate pieces. First, we need to parse the URL. The <code class="literal">route</code> includes a placeholder, <code class="literal">&lt;spec&gt;</code>, which Flask parses and provides as a parameter to the function. This will be the URL-encoded parameter to describe the spiral. It might look like this:</p><div class="informalexample"><pre class="programlisting">http://127.0.0.1:5000/image/size=10&amp;angle=65.0&amp;incr=1.05</pre></div><p>Once we've decoded the specification, we'll have a special multi-valued dictionary. This looks as if the input came from an HTML form. The structure will be a mapping from form field names to a list of values for each field. The object looks like this:</p><div class="informalexample"><pre class="programlisting">{'size': ['10'], 'angle': ['65.0'], 'incr': ['1.05']}</pre></div><p>The <code class="literal">image()</code> function only uses one value from each item; each input must be converted to numeric values. We've collected all of the potential exceptions into a single <code class="literal">except</code> clause, obscuring the details of any incorrect input. We use the Flask <code class="literal">make_response()</code> function to build a response with an error message and a status code of 403 ("Forbidden"). A more sophisticated function would use the <span class="strong"><strong>Accept</strong></span> header<a class="indexterm" id="id766"/> to formulate a response as JSON or XML, depending on the client's stated preference. We've left it as the default MIME type of text/plain.</p><p>The image is saved <a class="indexterm" id="id767"/>into a temporary file, created with the <code class="literal">tempfile.mkstemp()</code> function. In this case, we're going to save that temporary file from the Flask application. For a low-volume website, this is acceptable. For a higher-volume website, a Python application should never handle downloads. The file should be created in a directory where the Apache HTTPD server can download the image instead of a Python application.</p><p>The image <a class="indexterm" id="id768"/>construction uses a few Pillow-defined objects to define the drawing space. A customized class defines a <code class="literal">Pen</code> instance which parallels the <code class="literal">turtle.Turtle</code> class. Once the image has been constructed, it's saved with the given filename. Note that the Pillow package can save files in a wide variety of formats; we've used <code class="literal">.png</code> in this example.</p><p>The final section downloads the file. The comment notes that a high-volume website would redirect to a URL from which Apache would download the image file. This frees up the Flask server to handle another request.</p><p>Note that the local namespace in this function will have two copies of the image. The <code class="literal">im</code> variable will hold the entire, detailed image. The <code class="literal">data</code> variable will hold the compressed filesystem version of the image document. We could use <code class="literal">del im</code> to remove the image object; however, it is generally better to decompose this into two functions so that namespaces handle object removal for us.</p><p>We can run a demonstration version of this service with the following script:</p><div class="informalexample"><pre class="programlisting">if __name__ == '__main__':
    spiral_app.run(debug=True)</pre></div><p>This allows us to work with a running web server on our desktop. We can then experiment with different implementation alternatives.</p><p>What's important about this example is that we can—very quickly—have a service running in our desktop environment. We can then explore and experiment with the user experience very easily. For example, since the image will be embedded in an HTML page, we want to design and debug the HTML, CSS, and JavaScript for that page. This whole development process is made easier when we have a simple, easily-tweaked web server.</p></div></div>
<div class="section" title="Plugging into a MapReduce framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec131"/>Plugging into a MapReduce framework</h1></div></div></div><p>For <a class="indexterm" id="id769"/>background on the Apache Hadoop server, see <a class="ulink" href="https://hadoop.apache.org">https://hadoop.apache.org</a>. Here's the summary:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>The Apache Hadoop software library is a framework that allows for the distributed processing of large datasets across clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines, each offering local computation and storage.</em></span></p></blockquote></div><p>One part<a class="indexterm" id="id770"/> of the Hadoop distributed processing is the MapReduce module. This module allows us to decompose analysis of data into two complementary operations: map and reduce. These operations are distributed around the Hadoop cluster to be run concurrently. A map operation processes all of the rows of datasets that are scattered around the cluster. The outputs from map operations are then fed to reduce operations to be summarized.</p><p>The Hadoop streaming interface can be used by Python programmers. This involves a Hadoop "wrapper" that will present the data to a Python mapper program as the standard input file. The standard output from a mapper must be tab-delimited key-value pairs. These are sent to the reduce programs, again as standard input. For more information on packages that help Python programmers use Hadoop, see <a class="ulink" href="http://blog.cloudera.com/blog/2013/01/a-guide-to-python-frameworks-for-hadoop/">http://blog.cloudera.com/blog/2013/01/a-guide-to-python-frameworks-for-hadoop/</a>.</p><p>One common example of MapReduce operations is creating a concordance of words found in books. The mapping operation will transform a giant text file into sequences of words found in the text file. The reduce operation will count the occurrences of each word, resulting in a final summary of words and their popularity. (For more information on how important this can be, visit the<a class="indexterm" id="id771"/> NLTK website: <a class="ulink" href="http://www.nltk.org">http://www.nltk.org</a>.)</p><p>Practical problems may involve multiple mappings and multiple reductions. In many cases, the mappings will often seem trivial: they'll extract a key and a value from each row of source data. Rather than study Hadoop too much, we'll show how we can write and test mappers and reducers on our desktop.</p><p>Our goal is to have two programs, <code class="literal">map.py</code> and <code class="literal">reduce.py</code>, that can be combined into a stream like this:</p><div class="informalexample"><pre class="programlisting">cat some_file.dat | python3 map.py | sort | python3 reduce.py</pre></div><p>This approach will simulate Hadoop streaming by supplying data to our <code class="literal">map.py</code> program and our <code class="literal">reduce.py</code> program. This will serve as a simple integration test for our map and reduce processing. For Windows, we would use the <code class="literal">type</code> command instead of the Linux <code class="literal">cat</code> program.</p><p>Let's look at some raw climate data from the US National Ocean and Atmospheric Administration's National Climatic Data Center. Refer to <a class="ulink" href="http://www.ncdc.noaa.gov/cdo-web/">http://www.ncdc.noaa.gov/cdo-web/</a> for climate data online. We can request files with details such as snowfall for a given time period.</p><p>Our question is "Which months have snowfall at the Richmond, VA, airport?" The snowfall data <a class="indexterm" id="id772"/>attribute is named <code class="literal">TSNW</code>. It's in units of one-tenth of an inch, so our mapper needs to convert it to <code class="literal">Decimal</code> inches to be more useful.</p><p>We can write a map script that looks like this:</p><div class="informalexample"><pre class="programlisting">import csv
import sys
import datetime
from decimal import Decimal
if __name__ == "__main__":
    rdr = csv.DictReader(sys.stdin)
    wtr = csv.writer(sys.stdout, delimiter='\t', lineterminator='\n')
    for row in rdr:
        date = datetime.datetime.strptime(row['DATE'], "%Y%m%d").date()
        if row['TSNW'] in ('0', '-9999', '9999'):
            continue # Zero or equipment error: reject
        wtr.writerow( [date.month, Decimal(row['TSNW'])/10] )</pre></div><p>Because our input is in more or less standard CSV notation—with a heading—we can use a <code class="literal">csv.DictReader</code> object to parse the input. Each row of data is a <code class="literal">dict</code> object with keys defined by the first line of the CSV file. The output is more specialized: with Hadoop it must be a tab-delimited key and value, terminated with a newline character.</p><p>For each input dictionary object, we'll convert the date from text to a proper Python date so that we can reliably extract the month. We could do this by using <code class="literal">row['DATE'][4:6]</code>, but that seems opaque. The mapper includes a filter to reject months that have no snow, or have a domain-specific null value (9999 or -9999) instead of a measurement.</p><p>The output is a key and a value. Our key is the reported month; the value is the snowfall converted from one-tenth inch to inch measurements. We've used the <code class="literal">Decimal</code> class to avoid introducing floating-point approximations.</p><p>The reduce operation uses a <code class="literal">Counter</code> object to summarize the results produced by the mapper. For this example, the reduce looks like this:</p><div class="informalexample"><pre class="programlisting">import csv
import sys
from collections import Counter
from decimal import Decimal
if __name__ == "__main__":
    rdr= csv.DictReader(
        sys.stdin, fieldnames=("month","snowfall"),
        delimiter='\t', lineterminator='\n')
    counts = Counter()
    for line in rdr:
        counts[line['month']] += Decimal(line['snowfall'])
    print( counts )</pre></div><p>The reduce reader matches the mapper's writer: they both use a delimiter of a tab and a line terminator of the newline character. This follows Hadoop's requirements for the data that flows from mappers to reducers. We've also created a <code class="literal">Counter</code> object to store our snowfall data.</p><p>For each line<a class="indexterm" id="id773"/> of input, we extract the inches of snowfall and accumulate those in the <code class="literal">Counter</code> object with a key of the month number. The final result will show the inches of snow for each month in the greater Richmond metropolitan area.</p><p>We can easily test and experiment with this on our desktop. We can execute a pipeline of mapper, sort, and reducer using either a shell script or perhaps a little wrapper program like this:</p><div class="informalexample"><pre class="programlisting">import subprocess
dataset = "526212.csv"
command = """cat {dataset} | python3 -m Chapter_15.map | sort |
    python3 -m Chapter_15.reduce"""
command = command.format_map(locals())
result= subprocess.check_output(command, shell=True)
for line in result.splitlines():
      print( line.decode("ASCII") )</pre></div><p>We've created a command that will work on Mac OS X or Linux, and substituted a filename into that command. For Windows we can use <code class="literal">type</code> instead of <code class="literal">cat</code>; the Python program might be named <code class="literal">python</code> instead of <code class="literal">python3</code>. Otherwise, the shell pipeline should work fine in Windows.</p><p>We've used the <code class="literal">subprocess.check_output()</code> function to run this shell command and collect the output. This is a quick way to experiment with our Hadoop programs while avoiding the delays associated with using a busy Hadoop cluster.</p><p>This approach works well as long as we stick to elements of the libraries that are properly installed in the Hadoop environment. In some cases, our cluster might have Anaconda installed, giving us access to a wide variety of packages. When we want to use our own package—one that's not installed throughout the cluster—we'll need to provide the additional module to the Hadoop streaming command to be sure that our additional modules are downloaded to each node in the cluster, along with our mapper and reducer.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec132"/>Summary</h1></div></div></div><p>In this chapter, we've looked at several kinds of Python applications. While Python is used widely, we've picked a few areas of focus. We've looked at CLI applications capable of processing large volumes of data. The command-line interface is also present in other kinds of applications, making this a fundamental part of any program.</p><p>We've looked at GUI programs, using only the built-in <code class="literal">turtle</code> module. The GUI frameworks that are widely used involve downloads, installation, and more sophisticated programming that we could not illustrate in a single chapter. There are several popular choices; there's no consensus on a "best" package for GUI applications. Making a choice is difficult.</p><p>We've also looked at web applications, using the Flask module. This is also a separate download. In many cases, there are a number of related downloads that will become part of a web application. We might include Jinja2, WTForms, OAuth, SQLAlchemy, and Pillow, to expand the web server's libraries.</p><p>We've also looked at how we might leverage desktop Python to develop Hadoop applications. Rather than download and install Hadoop, we can create a processing pipeline that follows the Hadoop approach. We can write mappers and reducers using only desktop tools, allowing us to create reliable unit tests. This gives us the confidence that we'll get the expected results when running our applications on the Hadoop cluster with a complete set of data.</p><p>This isn't all, of course. Python can be used inside another application as the language for automating that application. A program can embed a Python interpreter which interacts with the overall application. For more information, see <a class="ulink" href="https://docs.python.org/2/extending/embedding.html">https://docs.python.org/2/extending/embedding.html</a>.</p><p>We can imagine the universe of Python applications as a large body of water filled with islands, archipelagos, inlets, and estuaries. Chesapeake Bay on the US East Coast is an example. We've tried to show the principal features of this bay: the headlands, points, shallows, and coastlines. We've avoided the effects of currents, weather, and tides, so that we can focus on the essential features of the bay. Pragmatic navigation along a specific route requires more study of the area of interest: detailed navigation charts, pilot guides, and local knowledge from other mariners.</p><p>It's important to consider the extent of the Python universe. The distance to a destination can appear daunting. Our objective has been to show some principal waypoints that can help break a long voyage into shorter legs. If we isolate the legs of a long journey, we can solve each of them separately and build a larger solution from the pieces.</p></div></body></html>