<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Working with Web Services – XML-RPC, SOAP, and REST</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Querying a local XML-RPC server</li><li class="listitem" style="list-style-type: disc">Writing a multithreaded, multicall XML-RPC server</li><li class="listitem" style="list-style-type: disc">Running an XML-RPC server with a basic HTTP authentication</li><li class="listitem" style="list-style-type: disc">Collecting some photo information from Flickr using REST</li><li class="listitem" style="list-style-type: disc">Searching for SOAP methods from an Amazon S3 web service</li><li class="listitem" style="list-style-type: disc">Searching Google for custom information</li><li class="listitem" style="list-style-type: disc">Searching Amazon for books through product search API</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Introduction</h1></div></div></div><p>This chapter presents some interesting Python recipes on web services using three different approaches, namely, <strong>XML Remote Procedure Call</strong> (<strong>XML-RPC</strong>), <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>), and <strong>Representational State Transfer</strong> (<strong>REST</strong>). The idea behind the web services is to enable an interaction between two software components over the Web through a carefully designed protocol. The interface is machine readable. Various protocols are used to facilitate the web services.</p><p>Here, we bring examples from<a id="id495" class="indexterm"/> three commonly used protocols. XML-RPC uses HTTP as the transport medium, and communication is done using XML contents. A server that implements XML-RPC waits for a call from a suitable client. The client calls that server to execute remote procedures with different parameters. XML-RPC is simpler and comes with a minimum security in mind. On the other hand, SOAP has a rich set of protocols for enhanced remote procedure calls. REST is an architectural style to facilitate web services. It operates with HTTP request methods, namely, <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, and <code class="literal">DELETE</code>. This chapter presents the practical use of these web services protocols and styles to achieve some common tasks.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Querying a local XML-RPC server</h1></div></div></div><p>If you do a lot of web programming, it's most likely that you will come across this task: to get some information<a id="id496" class="indexterm"/> from a website that runs an XML-RPC service. Before we go into the depth of an XML-RPC service, let's launch an XML-RPC server and talk to it first.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec164"/>Getting ready</h2></div></div></div><p>In this recipe, we will use the Python Supervisor program that is widely used to launch and manage a bunch of executable programs. Supervisor can be run as a background daemon and can monitor child processes and restart if they die suddenly. We can install Supervisor by simply running the following command:</p><div><pre class="programlisting">
<strong>$pip install supervisor</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec165"/>How to do it...</h2></div></div></div><p>We need to create a configuration file for Supervisor. A sample configuration is given in this recipe. In this example, we define the Unix HTTP server socket and a few other parameters. Note the <code class="literal">rpcinterface:supervisor</code> section where <code class="literal">rpcinterface_factory</code> is defined to communicate with clients.</p><p>Using Supervisor, we configure a simple server program in the <code class="literal">program:8_2_multithreaded_multicall_xmlrpc_server.py</code> section by specifying the command and some other parameters.</p><p>Listing 8.1a gives the code for a minimal Supervisor configuration, as shown:</p><div><pre class="programlisting">[unix_http_server]
file=/tmp/supervisor.sock   ; (the path to the socket file)
chmod=0700                 ; socket file mode (default 0700)

[supervisord]
logfile=/tmp/supervisord.log 
loglevel=info                
pidfile=/tmp/supervisord.pid 
nodaemon=true               

[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[program:8_2_multithreaded_multicall_xmlrpc_server.py]
command=python 8_2_multithreaded_multicall_xmlrpc_server.py ; the 
program (relative uses PATH, can take args)
process_name=%(program_name)s ; process_name expr (default 
%(program_name)s)</pre></div><p>If you create the preceding Supervisor configuration file in your favorite editor, you can run Supervisor by simply calling it.</p><p>Now, we can code an XML-RPC client<a id="id497" class="indexterm"/> that can act as a Supervisor proxy and give us the information about the running processes.</p><p>Listing 8.1b gives the code for querying a local XML-RPC server, as shown:</p><div><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 8
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
import supervisor.xmlrpc
import xmlrpclib

def query_supervisr(sock):
    transport = supervisor.xmlrpc.SupervisorTransport(None, None,
                'unix://%s' %sock)
    proxy = xmlrpclib.ServerProxy('http://127.0.0.1',
            transport=transport)
    print "Getting info about all running processes via Supervisord..."
    print proxy.supervisor.getAllProcessInfo()

if __name__ == '__main__':
    query_supervisr(sock='/tmp/supervisor.sock')</pre></div><p>If you run the Supervisor daemon, it will show the output similar to the following:</p><div><pre class="programlisting">
<strong>chapter8$ supervisord</strong>
<strong>2013-09-27 16:40:56,861 INFO RPC interface 'supervisor' initialized</strong>
<strong>2013-09-27 16:40:56,861 CRIT Server 'unix_http_server' running </strong>
<strong>without any HTTP authentication checking</strong>
<strong>2013-09-27 16:40:56,861 INFO supervisord started with pid 27436</strong>
<strong>2013-09-27 16:40:57,864 INFO spawned: </strong>
<strong>'8_2_multithreaded_multicall_xmlrpc_server.py' with pid 27439</strong>
<strong>2013-09-27 16:40:58,940 INFO success: </strong>
<strong>8_2_multithreaded_multicall_xmlrpc_server.py entered RUNNING state, </strong>
<strong>process has stayed up for &gt; than 1 seconds (startsecs)</strong>
</pre></div><p>Note that our child process, <code class="literal">8_2_multithreaded_multicall_xmlrpc_server.py</code>, has been launched.</p><p>Now, if you run the client code, it will query the XML-RPC server interface of Supervisor and list the running processes, as shown:</p><div><pre class="programlisting">
<strong>$ python 8_1_query_xmlrpc_server.py </strong>
<strong>Getting info about all running processes via Supervisord...</strong>
<strong>[{'now': 1380296807, 'group': </strong>
<strong>'8_2_multithreaded_multicall_xmlrpc_server.py', 'description': 'pid </strong>
<strong>27439, uptime 0:05:50', 'pid': 27439, 'stderr_logfile': </strong>
<strong>'/tmp/8_2_multithreaded_multicall_xmlrpc_server.py-stderr---</strong>
<strong>supervisor-i_VmKz.log', 'stop': 0, 'statename': 'RUNNING', 'start': </strong>
<strong>1380296457, 'state': 20, 'stdout_logfile': </strong>
<strong>'/tmp/8_2_multithreaded_multicall_xmlrpc_server.py-stdout---</strong>
<strong>supervisor-eMuJqk.log', 'logfile': </strong>
<strong>'/tmp/8_2_multithreaded_multicall_xmlrpc_server.py-stdout---</strong>
<strong>supervisor-eMuJqk.log', 'exitstatus': 0, 'spawnerr': '', 'name': </strong>
<strong>'8_2_multithreaded_multicall_xmlrpc_server.py'}]</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec166"/>How it works...</h2></div></div></div><p>This recipe relies on running the<a id="id498" class="indexterm"/> Supervisor daemon (configured with <code class="literal">rpcinterface</code>) in the background. Supervisor launches another XML-RPC server, as follows: <code class="literal">8_2_multithreaded_multicall_xmlrpc_server.py</code>.</p><p>The client code has a <code class="literal">query_supervisr()</code>method<a id="id499" class="indexterm"/>, which takes an argument for the Supervisor socket. In this method, an instance of <code class="literal">SupervisorTransport</code> is created with the Unix socket path. Then, an XML-RPC server proxy is created by instantiating the <code class="literal">ServerProxy()</code> class<a id="id500" class="indexterm"/> of <code class="literal">xmlrpclib</code> by passing the server address and previously created <code class="literal">transport</code>.</p><p>The XML-RPC server proxy then calls the Supervisor's <code class="literal">getAllProcessInfo()</code> method<a id="id501" class="indexterm"/>, which prints the process information of the child process. This process includes <code class="literal">pid</code>, <code class="literal">statename</code>, <code class="literal">description</code>, and so on.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec78"/>Writing a multithreaded multicall XML-RPC server</h1></div></div></div><p>You can make your XML-RPC server accept multiple calls simultaneously. This means that multiple function <a id="id502" class="indexterm"/>calls can return a single result. In addition to this, if your server is multithreaded, then you can execute more code after the server is launched in a single thread. The program's main thread will not be blocked in this manner.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec167"/>How to do it...</h2></div></div></div><p>We can create a <code class="literal">ServerThread</code> class inheriting from the <code class="literal">threading.Thread</code> class and wrap a <code class="literal">SimpleXMLRPCServer</code> instance in an <a id="id503" class="indexterm"/>attribute of this class. This can be set up to accept multiple calls.</p><p>Then, we can create two functions: one launches the multithreaded, multicall XML-RPC server and the other creates a client to that server.</p><p>Listing 8.2 gives the code for<a id="id504" class="indexterm"/> writing a multithreaded, multicall XML-RPC server, as shown:</p><div><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 8
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import xmlrpclib
import threading

from SimpleXMLRPCServer import SimpleXMLRPCServer

# some trivial functions
def add(x,y):
  return x+y

def subtract(x, y):
  return x-y

def multiply(x, y):
  return x*y

def divide(x, y):
  return x/y


class ServerThread(threading.Thread):
  def __init__(self, server_addr):
    threading.Thread.__init__(self)
    self.server = SimpleXMLRPCServer(server_addr)
    self.server.register_multicall_functions()
    self.server.register_function(add, 'add')
    self.server.register_function(subtract, 'subtract')
    self.server.register_function(multiply, 'multiply')
    self.server.register_function(divide, 'divide')

  def run(self):
    self.server.serve_forever()
  
def run_server(host, port):
  # server code
  server_addr = (host, port)
  server = ServerThread(server_addr)
  server.start() # The server is now running
  print "Server thread started. Testing the server..."

def run_client(host, port):
  # client code
  proxy = xmlrpclib.ServerProxy("http://%s:%s/" %(host, port))
  multicall = xmlrpclib.MultiCall(proxy)
  multicall.add(7,3)
  multicall.subtract(7,3)
  multicall.multiply(7,3)
  multicall.divide(7,3)
  result = multicall()
  print "7+3=%d, 7-3=%d, 7*3=%d, 7/3=%d" % tuple(result)

if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Multithreaded 
multicall XMLRPC Server/Proxy')
  parser.add_argument('--host', action="store", dest="host", 
default='localhost')
  parser.add_argument('--port', action="store", dest="port", 
default=8000, type=int)
  # parse arguments
  given_args = parser.parse_args()
  host, port =  given_args.host, given_args.port
  run_server(host, port)
  run_client(host, port)</pre></div><p>If you run this script, you<a id="id505" class="indexterm"/> will see the output similar to the following:</p><div><pre class="programlisting">
<strong>$ python 8_2_multithreaded_multicall_xmlrpc_server.py --port=8000</strong>
<strong>Server thread started. Testing the server...</strong>
<strong>localhost - - [25/Sep/2013 17:38:32] "POST / HTTP/1.1" 200 -</strong>
<strong>7+3=10, 7-3=4, 7*3=21, 7/3=2 </strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec168"/>How it works...</h2></div></div></div><p>In this recipe, we have created a <code class="literal">ServerThread</code> subclass inheriting from the Python threading library's <code class="literal">Thread</code> class. This subclass initializes a server attribute that creates an instance of the <code class="literal">SimpleXMLRPC</code> server. The XML-RPC server address can be given via the command-line input. In order to enable the multicall function, we called the <code class="literal">register_multicall_functions()</code> method<a id="id506" class="indexterm"/> on the server instance.</p><p>Then, four trivial functions are registered with this XML-RPC server: <code class="literal">add()</code>, <code class="literal">subtract()</code>, <code class="literal">multiply()</code>, and <code class="literal">divide()</code>. These functions do exactly the same operation as their names suggest.</p><p>In order to launch<a id="id507" class="indexterm"/> the server, we pass a host and port to the <code class="literal">run_server()</code> function<a id="id508" class="indexterm"/>. A server instance is created using the <code class="literal">ServerThread</code> class discussed earlier. The <code class="literal">start()</code> method of this server instance launches the XML-RPC server.</p><p>On the client side, the <code class="literal">run_client()</code> function<a id="id509" class="indexterm"/> accepts the same host and port arguments from the command line. It then creates a proxy instance of the XML-RPC server discussed earlier by calling the <code class="literal">ServerProxy()</code> class<a id="id510" class="indexterm"/> from <code class="literal">xmlrpclib</code>. This proxy instance is then passed onto the <code class="literal">MultiCall</code> class instance, <code class="literal">multicall</code>. Now, the preceding four trivial RPC methods can be run, for example, <code class="literal">add</code>, <code class="literal">subtract</code>, <code class="literal">multiply</code>, and <code class="literal">divide</code>. Finally, we can get the result via a single call, for example, <code class="literal">multicall()</code>. The result tuple is then printed in a single line.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Running an XML-RPC server with a basic HTTP authentication</h1></div></div></div><p>Sometimes, you may need to implement authentication with an XML-RPC server. This recipe presents an example <a id="id511" class="indexterm"/>of a basic HTTP authentication<a id="id512" class="indexterm"/> with an XML-RPC server.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec169"/>How to do it...</h2></div></div></div><p>We can create a subclass of <code class="literal">SimpleXMLRPCServer</code> and override its request handler so that when a request comes, it is verified against a given login credentials.</p><p>Listing 8.3a gives the code for running an XML-RPC server with a basic HTTP authentication, as shown:</p><div><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 8
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import xmlrpclib
from base64 import b64decode
from SimpleXMLRPCServer  import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler


class SecureXMLRPCServer(SimpleXMLRPCServer):

  def __init__(self, host, port, username, password, *args, 
**kargs):
    self.username = username
    self.password = password
    # authenticate method is called from inner class
    class VerifyingRequestHandler(SimpleXMLRPCRequestHandler):
      # method to override
      def parse_request(request):
        if\ SimpleXMLRPCRequestHandler.parse_request(request):
        # authenticate
          if self.authenticate(request.headers):
        return True
          else:
            # if authentication fails return 401
              request.send_error(401, 'Authentication\ failed 
ZZZ')
            return False
          # initialize
         SimpleXMLRPCServer.__init__(self, (host, port), 
requestHandler=VerifyingRequestHandler, *args, **kargs)

  def authenticate(self, headers):
    headers = headers.get('Authorization').split()
    basic, encoded = headers[0], headers[1]
    if basic != 'Basic':
      print 'Only basic authentication supported'
    return False
    secret = b64decode(encoded).split(':')
    username, password = secret[0], secret[1]
  return True if (username == self.username and password == 
self.password) else False
  

def run_server(host, port, username, password):
  server = SecureXMLRPCServer(host, port, username, password)
  # simple test function
  def echo(msg):
    """Reply client in  upper case """
    reply = msg.upper()
    print "Client said: %s. So we echo that in uppercase: %s" 
%(msg, reply)
  return reply
  server.register_function(echo, 'echo')
  print "Running a HTTP auth enabled XMLRPC server on %s:%s..." 
%(host, port)
  server.serve_forever()


if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Multithreaded 
multicall XMLRPC Server/Proxy')
  parser.add_argument('--host', action="store", dest="host", 
default='localhost')
  parser.add_argument('--port', action="store", dest="port", default=8000, type=int)
  parser.add_argument('--username', action="store", 
dest="username", default='user')
  parser.add_argument('--password', action="store", 
dest="password", default='pass')
  # parse arguments
  given_args = parser.parse_args()
  host, port =  given_args.host, given_args.port
  username, password = given_args.username, given_args.password
  run_server(host, port, username, password)</pre></div><p>If this server is run,<a id="id513" class="indexterm"/> then the following<a id="id514" class="indexterm"/> output can be seen by default:</p><div><pre class="programlisting">
<strong>$ python 8_3a_xmlrpc_server_with_http_auth.py </strong>
<strong>Running a HTTP auth enabled XMLRPC server on localhost:8000...</strong>
<strong>Client said: hello server.... So we echo that in uppercase: HELLO </strong>
<strong>SERVER...</strong>
<strong>localhost - - [27/Sep/2013 12:08:57] "POST /RPC2 HTTP/1.1" 200 -</strong>
</pre></div><p>Now, let us create a simple client proxy and use the same login credentials as used with the server.</p><p>Listing 8.3b gives the code for the XML-RPC Client, as shown:</p><div><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 8
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import xmlrpclib

def run_client(host, port, username, password):
  server = xmlrpclib.ServerProxy('http://%s:%s@%s:%s' %(username, 
password, host, port, ))
  msg = "hello server..."
  print "Sending message to server: %s  " %msg
  print "Got reply: %s" %server.echo(msg)

if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Multithreaded 
multicall XMLRPC Server/Proxy')
  parser.add_argument('--host', action="store", dest="host", 
default='localhost')
  parser.add_argument('--port', action="store", dest="port", 
default=8000, type=int)
  parser.add_argument('--username', action="store", 
dest="username", default='user')
  parser.add_argument('--password', action="store", 
dest="password", default='pass')
  # parse arguments
  given_args = parser.parse_args()
  host, port =  given_args.host, given_args.port
  username, password = given_args.username, given_args.password
  run_client(host, port, username, password)</pre></div><p>If you run the <a id="id515" class="indexterm"/>client, then it shows<a id="id516" class="indexterm"/> the following output:</p><div><pre class="programlisting">
<strong>$ python 8_3b_xmprpc_client.py </strong>
<strong>Sending message to server: hello server...  </strong>
<strong>Got reply: HELLO SERVER...</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec170"/>How it works...</h2></div></div></div><p>In the server script, the <code class="literal">SecureXMLRPCServer</code> subclass is created by inheriting from <code class="literal">SimpleXMLRPCServer</code>. In this subclass' initialization code, we created the <code class="literal">VerifyingRequestHandler</code> class<a id="id517" class="indexterm"/> that actually intercepts the request and does the basic authentication using the <a id="id518" class="indexterm"/>
<code class="literal">authenticate()</code> method.</p><p>In the <code class="literal">authenticate()</code> method, the HTTP request is passed as an argument. This method checks the presence of the value of <code class="literal">Authorization</code>. If its value is set to <code class="literal">Basic</code>, it then decodes the encoded password with the <code class="literal">b64decode()</code> function<a id="id519" class="indexterm"/> from the <code class="literal">base64</code> standard module. After extracting the username and password, it then checks that with the server's given credentials set up initially.</p><p>In the <code class="literal">run_server()</code> function, a simple <code class="literal">echo()</code> subfunction is<a id="id520" class="indexterm"/> defined and registered with the <code class="literal">SecureXMLRPCServer</code> instance.</p><p>In the client <a id="id521" class="indexterm"/>script, <code class="literal">run_client()</code> simply takes the server address and login credentials and passes them to the <code class="literal">ServerProxy()</code> instance. It then sends a single line message via the <code class="literal">echo()</code> method.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec80"/>Collecting some photo information from Flickr using REST</h1></div></div></div><p>Many Internet websites provide<a id="id522" class="indexterm"/> a web services interface through their REST APIs. <strong>Flickr</strong>, a famous photo sharing website, has a REST interface.<a id="id523" class="indexterm"/> Let's try to <a id="id524" class="indexterm"/>gather some photo information to build a specialized database or other photo-related application.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec171"/>How to do it...</h2></div></div></div><p>We need the REST URLs for making the HTTP requests. For simplicity's sake, the URLs are hard coded in this recipe. We can use the third-party <code class="literal">requests</code> module to make the REST requests. It has the convenient <code class="literal">get()</code>, <code class="literal">post()</code>, <code class="literal">put()</code>, and <code class="literal">delete()</code> methods.</p><p>In order to talk to Flickr web services, you need to register yourself and get a secret API key. This API key can be placed in a <code class="literal">local_settings.py</code> file or supplied via the command line.</p><p>Listing 8.4 gives the code for collecting some photo information from Flickr using REST, as shown:</p><div><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 8
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import json
import requests

try:
    from local_settings import flickr_apikey
except ImportError:
    pass

def collect_photo_info(api_key, tag, max_count):
    """Collects some interesting info about some photos from Flickr.com for a given tag """
    photo_collection = []
    url =  "http://api.flickr.com/services/rest/?method=flickr.photos.search&amp;tags=%s&amp;format=json&amp;nojsoncallback=1&amp;api_key=%s" %(tag, api_key)
    resp = requests.get(url)
    results = resp.json()
    count  = 0
    for p in results['photos']['photo']:
        if count &gt;= max_count:
            return photo_collection
        print 'Processing photo: "%s"' % p['title']
        photo = {}
        url = "http://api.flickr.com/services/rest/?method=flickr.photos.getInfo&amp;photo_id=" + p['id'] + "&amp;format=json&amp;nojsoncallback=1&amp;api_key=" + api_key
        info = requests.get(url).json()
        photo["flickrid"] = p['id']
        photo["title"] = info['photo']['title']['_content']
        photo["description"] = info['photo']['description']['_content']
        photo["page_url"] = info['photo']['urls']['url'][0]['_content']
    
        photo["farm"] = info['photo']['farm']
        photo["server"] = info['photo']['server']
        photo["secret"] = info['photo']['secret']
    
        # comments
        numcomments = int(info['photo']['comments']['_content'])
        if numcomments:
            #print "   Now reading comments (%d)..." % numcomments
            url = "http://api.flickr.com/services/rest/?method=flickr.photos.comments.getList&amp;photo_id=" + p['id'] + "&amp;format=json&amp;nojsoncallback=1&amp;api_key=" + api_key
            comments = requests.get(url).json()
            photo["comment"] = []
            for c in comments['comments']['comment']:
                comment = {}
                comment["body"] = c['_content']
                comment["authorid"] = c['author']
                comment["authorname"] = c['authorname']
                photo["comment"].append(comment)
        photo_collection.append(photo)
        count = count + 1
    return photo_collection     


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Get photo info from Flickr')
    parser.add_argument('--api-key', action="store", dest="api_key", default=flickr_apikey)
    parser.add_argument('--tag', action="store", dest="tag", default='Python')
    parser.add_argument('--max-count', action="store", dest="max_count", default=3, type=int)
    # parse arguments
    given_args = parser.parse_args()
    api_key, tag, max_count =  given_args.api_key, given_args.tag, given_args.max_count
    photo_info = collect_photo_info(api_key, tag, max_count)
    for photo in photo_info:
        for k,v in photo.iteritems():
            if k == "title":
                print "Showing photo info...."  
            elif k == "comment":
                "\tPhoto got %s comments." %len(v)
            else:
                print "\t%s =&gt; %s" %(k,v) </pre></div><p>You can run this recipe<a id="id525" class="indexterm"/> with your<a id="id526" class="indexterm"/> Flickr API key either by placing<a id="id527" class="indexterm"/> it in a <code class="literal">local_settings.py</code> file or supplying it from the command line (via the <code class="literal">--api-key</code> argument). In addition to the API key, a search tag and maximum count of the result arguments can be supplied. By default, this recipe will search for the <code class="literal">Python</code> tag and restrict the result to three entries, as shown in the following output:</p><div><pre class="programlisting">
<strong>$ python 8_4_get_flickr_photo_info.py </strong>
<strong>Processing photo: "legolas"</strong>
<strong>Processing photo: ""The Dance of the Hunger of Kaa""</strong>
<strong>Processing photo: "Rocky"</strong>
<strong>    description =&gt; Stimson Python</strong>
<strong>Showiing photo info....</strong>
<strong>    farm =&gt; 8</strong>
<strong>    server =&gt; 7402</strong>
<strong>    secret =&gt; 6cbae671b5</strong>
<strong>    flickrid =&gt; 10054626824</strong>
<strong>    page_url =&gt; http://www.flickr.com/photos/102763809@N03/10054626824/</strong>
<strong>    description =&gt; &amp;quot; 'Good. Begins now the dance--the Dance of the Hunger of Kaa. Sit still and watch.'</strong>

<strong>He turned twice or thrice in a big circle, weaving his head from right to left. </strong>
<strong>Then he began making loops and figures of eight with his body, and soft, oozy triangles that melted into squares and five-sided figures, and coiled mounds, never resting, never hurrying, and never stopping his low humming song. It grew darker and darker, till at last the dragging, shifting coils disappeared, but they could hear the rustle of the scales.&amp;quot;</strong>
<strong>(From &amp;quot;Kaa's Hunting&amp;quot; in &amp;quot;The Jungle Book&amp;quot; (1893) by Rudyard Kipling)</strong>

<strong>These old abandoned temples built around the 12th century belong to the abandoned city which inspired Kipling's Jungle Book.</strong>
<strong>They are rising at the top of a mountain which dominates the jungle at 811 meters above sea level in the centre of the jungle of Bandhavgarh located in the Indian state Madhya Pradesh.</strong>
<strong>Baghel King Vikramaditya Singh abandoned Bandhavgarh fort in 1617 when Rewa, at a distance of 130 km was established as a capital. </strong>
<strong>Abandonment allowed wildlife development in this region.</strong>
<strong>When Baghel Kings became aware of it, he declared Bandhavgarh as their hunting preserve and strictly prohibited tree cutting and wildlife hunting...</strong>

<strong>Join the photographer at &lt;a href="http://www.facebook.com/laurent.goldstein.photography" rel="nofollow"&gt;www.facebook.com/laurent.goldstein.photography&lt;/a&gt;</strong>

<strong>© All photographs are copyrighted and all rights reserved.</strong>
<strong>Please do not use any photographs without permission (even for private use).</strong>
<strong>The use of any work without consent of the artist is PROHIBITED and will lead automatically to consequences.</strong>
<strong>Showiing photo info....</strong>
<strong>    farm =&gt; 6</strong>
<strong>    server =&gt; 5462</strong>
<strong>    secret =&gt; 6f9c0e7f83</strong>
<strong>    flickrid =&gt; 10051136944</strong>
<strong>    page_url =&gt; http://www.flickr.com/photos/designldg/10051136944/</strong>
<strong>    description =&gt; Ball Python</strong>
<strong>Showiing photo info....</strong>
<strong>    farm =&gt; 4</strong>
<strong>    server =&gt; 3744</strong>
<strong>    secret =&gt; 529840767f</strong>
<strong>    flickrid =&gt; 10046353675</strong>
<strong>    page_url =&gt; </strong>
<strong>http://www.flickr.com/photos/megzzdollphotos/10046353675/</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec172"/>How it works...</h2></div></div></div><p>This recipe<a id="id528" class="indexterm"/> demonstrates how to interact <a id="id529" class="indexterm"/>with Flickr using its REST APIs.<a id="id530" class="indexterm"/> In this example, the <code class="literal">collect_photo_info()</code> tag takes three parameters: Flickr API key, a search tag, and the desired number of search results.</p><p>We construct the first URL to search for photos. Note that in this URL, the value of the method parameter is<code class="literal"> flickr.photos.search</code> and the desired result format is JSON.</p><p>The results of the first <code class="literal">get()</code> call are stored in the <code class="literal">resp</code> variable and then converted to the JSON format by calling the <code class="literal">json()</code> method on <code class="literal">resp</code>. Now, the JSON data is read in a loop looking into the <code class="literal">['photos']['photo']</code> iterator. A <code class="literal">photo_collection</code> list is created to return the result after organizing the information. In this list, each photo information is represented by a dictionary. The keys of this dictionary are populated by extracting information from the earlier JSON response and another <code class="literal">GET</code> request to get the information regarding the specific photo.</p><p>Note that to get the comments about a photo, we need to make another <code class="literal">get()</code> request and gather comment information from the <code class="literal">['comments']['comment']</code> elements of the returned JSON. Finally, these comments are appended to a list and attached to the photo dictionary entry.</p><p>In the main function, we extract the <code class="literal">photo_collection</code> dictionary and print some useful information about each photo.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec81"/>Searching for SOAP methods from an Amazon S3 web service</h1></div></div></div><p>If you need to interact with a server that implements web services in Simple Object Access Procedure (SOAP), then<a id="id531" class="indexterm"/> this recipe can help<a id="id532" class="indexterm"/> to get a starting point.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec173"/>Getting ready</h2></div></div></div><p>We can use the third-party <code class="literal">SOAPpy</code> library for this task. This can be installed by running the following command:</p><div><pre class="programlisting">
<strong>$pip install SOAPpy</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec174"/>How to do it...</h2></div></div></div><p>We create a proxy instance and introspect the server methods before we can call them.</p><p>In this recipe, let's interact with an Amazon S3 storage service. We have got a test URL for the web services API. An API key is necessary to do this simple task.</p><p>Listing 8.5 gives the code for searching for SOAP methods from an Amazon S3 web service, as shown:</p><div><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 8
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import SOAPpy

TEST_URL = 'http://s3.amazonaws.com/ec2-downloads/2009-04-04.ec2.wsdl'

def list_soap_methods(url):
    proxy = SOAPpy.WSDL.Proxy(url)
    print '%d methods in WSDL:' % len(proxy.methods) + '\n'
    for key in proxy.methods.keys():
 "Key Details:"
        for k,v in proxy.methods[key].__dict__.iteritems():
            print "%s ==&gt; %s" %(k,v)
 

if __name__ == '__main__':
    list_soap_methods(TEST_URL)</pre></div><p>If you run this script, it will print the total number of available methods that support web services definition language (WSDL) and the details of one arbitrary method, as shown:</p><div><pre class="programlisting">
<strong>$ python 8_5_search_amazonaws_with_SOAP.py </strong>
<strong>/home/faruq/env/lib/python2.7/site-packages/wstools/XMLSchema.py:1280: UserWarning: annotation is </strong>
<strong>ignored</strong>
<strong>  warnings.warn('annotation is ignored')</strong>
<strong>43 methods in WSDL:</strong>

<strong>Key Name: ReleaseAddress</strong>
<strong>Key Details:</strong>
<strong>    encodingStyle ==&gt; None</strong>
<strong>    style ==&gt; document</strong>
<strong>    methodName ==&gt; ReleaseAddress</strong>
<strong>    retval ==&gt; None</strong>
<strong>    soapAction ==&gt; ReleaseAddress</strong>
<strong>    namespace ==&gt; None</strong>
<strong>    use ==&gt; literal</strong>
<strong>    location ==&gt; https://ec2.amazonaws.com/</strong>
<strong>    inparams ==&gt; [&lt;wstools.WSDLTools.ParameterInfo instance at </strong>
<strong>0x8fb9d0c&gt;]</strong>
<strong>    outheaders ==&gt; []</strong>
<strong>    inheaders ==&gt; []</strong>
<strong>    transport ==&gt; http://schemas.xmlsoap.org/soap/http</strong>
<strong>    outparams ==&gt; [&lt;wstools.WSDLTools.ParameterInfo instance at </strong>
<strong>0x8fb9d2c&gt;]</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec175"/>How it works...</h2></div></div></div><p>This script defines a<a id="id533" class="indexterm"/> method called <code class="literal">list_soap_methods()</code> <a id="id534" class="indexterm"/>that takes a URL and constructs a SOAP proxy object by calling the <code class="literal">WSDL.Proxy()</code> method<a id="id535" class="indexterm"/> of <code class="literal">SOAPpy</code>. The available SOAP methods are available<a id="id536" class="indexterm"/> under this proxy's method attribute.</p><p>An iteration over the proxy's method keys are done to introspect the method keys. A <code class="literal">for</code> loop just prints the details of a single SOAP method, that is, the name of the key and details about it.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec82"/>Searching Google for custom information</h1></div></div></div><p>Searching Google for getting information <a id="id537" class="indexterm"/>about something <a id="id538" class="indexterm"/>seems to be an everyday activity for many people. Let's try to search Google for some information.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec176"/>Getting ready</h2></div></div></div><p>This recipe uses a third-party Python library, <code class="literal">requests</code>, which can be installed via <code class="literal">pip</code>, as shown in the following command:</p><div><pre class="programlisting">
<strong>$ pip install SOAPpy</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec177"/>How to do it...</h2></div></div></div><p>Google has sophisticated APIs to conduct a search. However, they require you to register and get the API keys by following a specific way. For simplicity's sake, let us use Google's old plain <strong>Asynchronous JavaScript</strong> (<strong>AJAX</strong>) API<a id="id539" class="indexterm"/> to search for some information about Python books.</p><p>Listing 8.6 gives the code for searching Google for custom information, as shown:</p><div><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 8
# This program is optimized for Python 2.7.# It may run on any other version with/without modifications.
import argparse
import json
import urllib
import requests

BASE_URL = 'http://ajax.googleapis.com/ajax/services/search/web?v=1.0' 

def get_search_url(query):
  return "%s&amp;%s" %(BASE_URL, query)

def search_info(tag):
  query = urllib.urlencode({'q': tag})
  url = get_search_url(query)
  response = requests.get(url)
  results = response.json()
  
  data = results['responseData']
  print 'Found total results: %s' % 
data['cursor']['estimatedResultCount']
  hits = data['results']
  print 'Found top %d hits:' % len(hits)
  for h in hits: 
    print ' ', h['url']
    print 'More results available from %s' % 
data['cursor']['moreResultsUrl']


if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Search info from 
Google')
  parser.add_argument('--tag', action="store", dest="tag", 
default='Python books')
  # parse arguments
  given_args = parser.parse_args()
  search_info(given_args.tag)</pre></div><p>If you run this script by specifying a search query in the <code class="literal">--tag</code> argument, then it will search Google and print <a id="id540" class="indexterm"/>a total results count and the top four hits pages, as shown:</p><div><pre class="programlisting">
<strong>$ python 8_6_search_products_from_Google.py </strong>
<strong>Found total results: 12300000</strong>
<strong>Found top 4 hits:</strong>
<strong>  https://wiki.python.org/moin/PythonBooks</strong>
<strong>  http://www.amazon.com/Python-Languages-Tools-Programming-</strong>
<strong>Books/b%3Fie%3DUTF8%26node%3D285856</strong>
<strong>  http://pythonbooks.revolunet.com/</strong>
<strong>  http://readwrite.com/2011/03/25/python-is-an-increasingly-popu</strong>
<strong>More results available from </strong>
<strong>http://www.google.com/search?oe=utf8&amp;ie=utf8&amp;source=uds&amp;start=0&amp;hl=en</strong>
<strong>&amp;q=Python+books</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec178"/>How it works...</h2></div></div></div><p>In this recipe, we<a id="id541" class="indexterm"/> defined a short function, <code class="literal">get_search_url()</code>,<a id="id542" class="indexterm"/> which constructs the search URL from a <code class="literal">BASE_URL</code> constant and the target query.</p><p>The main search function, <code class="literal">search_info()</code>,<a id="id543" class="indexterm"/> takes the search tag and constructs the query. The <code class="literal">requests</code> library is used to make the <code class="literal">get()</code> call. The returned response is then turned into JSON data.</p><p>The search results are extracted from the JSON data by accessing the value of the <code class="literal">'responseData'</code> key. The estimated results and hits are then extracted by accessing the relevant keys of the result data. The first four hit URLs are then printed on the screen.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec83"/>Searching Amazon for books through product search API</h1></div></div></div><p>If you like to search for products<a id="id544" class="indexterm"/> on Amazon and include some of them in your website or application, this recipe can help you to do that. We can<a id="id545" class="indexterm"/> see how to search Amazon for books.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec179"/>Getting ready</h2></div></div></div><p>This recipe depends on the third-party Python library, <code class="literal">bottlenose</code>. You can install this library using <code class="literal">pip</code>, as shown in the following command:</p><div><pre class="programlisting">
<strong>$ pip install  bottlenose</strong>
</pre></div><p>First, you need to place your Amazon account's access key, secret key, and affiliate ID into <code class="literal">local_settings.py</code>. A sample settings file is provided with the book code. You can also edit this script and place it here as well.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec180"/>How to do it...</h2></div></div></div><p>We can use the <code class="literal">bottlenose</code> library that implements the Amazon's product search APIs.</p><p>Listing 8.7 gives the code for searching Amazon for books through product search APIs, as shown:</p><div><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 8
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import bottlenose
from xml.dom import minidom as xml

try:
  from local_settings import amazon_account
except ImportError:
  pass 

ACCESS_KEY = amazon_account['access_key'] 
SECRET_KEY = amazon_account['secret_key'] 
AFFILIATE_ID = amazon_account['affiliate_id'] 


def search_for_books(tag, index):
  """Search Amazon for Books """
  amazon = bottlenose.Amazon(ACCESS_KEY, SECRET_KEY, AFFILIATE_ID)
  results = amazon.ItemSearch(
    SearchIndex = index,
    Sort = "relevancerank",
    Keywords = tag
  )
  parsed_result = xml.parseString(results)

  all_items = []
  attrs = ['Title','Author', 'URL']

  for item in parsed_result.getElementsByTagName('Item'):
    parse_item = {}

  for attr in attrs:
    parse_item[attr] = ""
    try:
      parse_item[attr] = 
item.getElementsByTagName(attr)[0].childNodes[0].data
    except:
      pass
    all_items.append(parse_item)
  return all_items

if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Search info from 
Amazon')
  parser.add_argument('--tag', action="store", dest="tag", 
default='Python')
  parser.add_argument('--index', action="store", dest="index", 
default='Books')
  # parse arguments
  given_args = parser.parse_args()
  books = search_for_books(given_args.tag, given_args.index)    
  
  for book in books:
    for k,v in book.iteritems():
      print "%s: %s" %(k,v)
      print "-" * 80</pre></div><p>If you run this recipe with a <a id="id546" class="indexterm"/>search tag and index, you can see some results similar to the following output:</p><div><pre class="programlisting">
<strong>$ python 8_7_search_amazon_for_books.py --tag=Python --index=Books</strong>
<strong>URL: http://www.amazon.com/Python-In-Day-Basics-Coding/dp/tech-data/1490475575%3FSubscriptionId%3DAKIAIPPW3IK76PBRLWBA%26tag%3D7052-6929-7878%26linkCode%3Dxm2%26camp%3D2025%26creative%3D386001%26creativeASIN%3D1490475575</strong>
<strong>Author: Richard Wagstaff</strong>
<strong>Title: Python In A Day: Learn The Basics, Learn It Quick, Start Coding Fast (In A Day Books) (Volume 1)</strong>
<strong>--------------------------------------------------------------------------------</strong>
<strong>URL: http://www.amazon.com/Learning-Python-Mark-Lutz/dp/tech-data/1449355730%3FSubscriptionId%3DAKIAIPPW3IK76PBRLWBA%26tag%3D7052-6929-7878%26linkCode%3Dxm2%26camp%3D2025%26creative%3D386001%26creativeASIN%3D1449355730</strong>
<strong>Author: Mark Lutz</strong>
<strong>Title: Learning Python</strong>
<strong>--------------------------------------------------------------------------------</strong>
<strong>URL: http://www.amazon.com/Python-Programming-Introduction-Computer-Science/dp/tech-data/1590282418%3FSubscriptionId%3DAKIAIPPW3IK76PBRLWBA%26tag%3D7052-6929-7878%26linkCode%3Dxm2%26camp%3D2025%26creative%3D386001%26creativeASIN%3D1590282418</strong>
<strong>Author: John Zelle</strong>
<strong>Title: Python Programming: An Introduction to Computer Science 2nd Edition</strong>
<strong>---------------------------------------------------------------------</strong>
<strong>-----------</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec181"/>How it works...</h2></div></div></div><p>This recipe uses <a id="id547" class="indexterm"/>the third-party <code class="literal">bottlenose</code> library's <code class="literal">Amazon()</code> class<a id="id548" class="indexterm"/> to create an object for searching Amazon through the product search API. This is done by the top-level <code class="literal">search_for_books()</code> function<a id="id549" class="indexterm"/>. The <code class="literal">ItemSearch()</code> method<a id="id550" class="indexterm"/> of this object is invoked with passing values to the <code class="literal">SearchIndex</code> and <code class="literal">Keywords</code> keys. It uses the <code class="literal">relevancerank</code> method to sort the search results.</p><p>The search results are processed using the <code class="literal">xml</code> module's <code class="literal">minidom</code> interface, which has a useful <code class="literal">parseString()</code> method<a id="id551" class="indexterm"/>. It returns the parsed XML tree-like data structure. The <code class="literal">getElementsByTagName()</code> method<a id="id552" class="indexterm"/> on this data structure helps to find the item's information. The item attributes are then looked up and placed in a dictionary of parsed items. Finally, all the<a id="id553" class="indexterm"/> parsed items are <a id="id554" class="indexterm"/>appended in a <code class="literal">all_items()</code>list and returned to the user.</p></div></div></div>
</body></html>