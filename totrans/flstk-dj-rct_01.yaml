- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Django Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Django** is one of the most famous backend frameworks written in Python and
    is often used to build simple or complex web applications. As for **React**, it’s
    one of the most widely used JavaScript libraries to create reactive and powerful
    user interfaces. In this chapter, we’ll focus on Django first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll briefly explain **software development** and, in particular,
    **backend development** in the context of what we’ll be building: a social network
    web application with Django and React. We’ll also talk about the most common tools
    used for backend development in **Python** – here in Django. Then, we will create
    a Django project and explain the most important parts of a Django project. After
    that, we’ll connect **PostgreSQL** to the Django project.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand concepts such as software development,
    frontend development, and backend development. You’ll also learn how to create
    a project in Django and start a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of software development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding backend development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Django?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the work environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of software development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software development is a complex process full of many steps and many components.
    These components ensure that conceiving, specifying, designing, programming, documenting,
    and testing an application, a framework, or software is respected and well applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, the software is made of the following two components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **backend**: This represents what the user can’t see; it’s composed of
    the business logic and data manipulation from a database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **frontend**: This represents the interface provided to the user to interact
    with the whole application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term frontend refers to the elements of a site or application that users
    see onscreen and with which they will interact. For example, all internet users
    will see a combination of HTML, CSS, and JavaScript on a website. It is these
    frontend programming languages that will be interpreted by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the frontend consists of HTML, CSS, JavaScript, and jQuery (or other
    UI libraries or frameworks) used to replicate a design. The design is created
    by the web designer who will create graphic models with dedicated tools, such
    as Photoshop or Figma.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll focus on web development. Web development is the part of software
    development focused on building websites and web applications, and the notion
    of web development relies on a client-server architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The client-server architecture represents an environment in which applications
    running on a client machine can communicate with other applications installed
    on a server machine, which provides services or data from a database.
  prefs: []
  type: TYPE_NORMAL
- en: On the web, the client will simply be a browser used to request a page or a
    resource from a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple diagram demonstrating this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Client-server architecture](img/Figure_1.1_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Client-server architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a better understanding of software development, particularly
    web development, let’s move on to a component of it: backend development.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding backend development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backend development handles the behind-the-scenes of modern applications. Most
    of the time, it’s made of code that connects to the database, manages user connections,
    and also powers web applications or the **API**.
  prefs: []
  type: TYPE_NORMAL
- en: The focus of backend development code is more on the business logic. It primarily
    focuses on how an application works and the functionality and logic powering the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s talk about a web application built to manage books. Let’s
    suppose that the application is connected to an SQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever language is used to build the application and the structure, here
    are some requirements that represent the business logic and that primarily depend
    on the backend rather than the frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding a book (only for admin)**: This supposes that the client (frontend)
    should be able to make a request to an API powered using whatever language is
    built for the backend, containing the data needed to create a new entry in the
    database that represents a book. This action is only available to admins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Listing all books**: This supposes that the client should also be able to
    make a request to the API, and this API should send as a response a list of all
    the books in JSON/XML format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just by taking a look at these two requirements, we can quickly understand that
    the frontend will just be the interface through which to request these actions.
    However, the backend will (taking the first requirement as an example) make sure
    that the incoming request is possible (checking for permissions such as whether
    the user making the request is really an admin) and that the data in the request
    is valid – only after that can data be safely registered in the database. Backend
    developers use programming languages such as Python, PHP, and Ruby to set up and
    configure the server. These tools will allow them to store, process, and modify
    information. To make these programming languages even more practical, developers
    will improve them with frameworks such as Symfony, Ruby on Rails, CakePHP, or
    CodeIgniter. These tools will make development faster and more secure. They must
    then ensure that these tools are always up to date and facilitate the maintenance
    required.
  prefs: []
  type: TYPE_NORMAL
- en: A backend developer is therefore responsible for creating and managing all the
    elements invisible to the end user. It is therefore they who are responsible for
    all the functionalities of the site or the application. They are also responsible
    for creating the database which will allow, among other things, the information
    provided by users to be retained. For example, the backend developer will use
    the databases to find the usernames and passwords that customers have used to
    connect. It is possible to train for this profession by training in web development
    or even training in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Responsibilities of backend developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The backend is typically made of three major parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server**: A machine or an application (NGINX) that receives requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application**: A running application on the server that receives the requests,
    validates these requests, and sends an appropriate response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: Used to store data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, the responsibilities of backend programmers could easily involve writing
    APIs, writing code to interact with a database, creating modules or libraries,
    also working on business data and architecture, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'They also have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate and communicate with frontend developers to transfer data efficiently
    to the client side of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborate with quality assurance engineers to optimize the server-side processes
    and also pass some security checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize the application when the number of requests or users scales as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze the requirements of the project and create a simple structure to handle
    bugs and errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Propose efficient solutions for cloud hosting but also build CI/CD pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The backend architecture actually helps build one of the most common interfaces
    for consuming data in the software industry: an **Application Programming Interface**
    (**API**). Let’s learn more about the term.'
  prefs: []
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we’ll primarily be building an API – so, what is an API?
  prefs: []
  type: TYPE_NORMAL
- en: 'Before answering this question, just remember that most of the internet is
    powered by **Representational State Transfer** (**REST**) or **RESTful APIs**.
    An API simplifies the way data is exchanged between applications or machines.
    It consists mainly of two components:'
  prefs: []
  type: TYPE_NORMAL
- en: The technical specification, which describes the data exchange options between
    the parties, with the specification made in the form of a request for data delivery
    protocols and data processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The software interface (the programming code), which is written to the specification
    that represents it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if the client side of your application is written in JavaScript
    and the server side is written in PHP, you’ll need to create a web API with PHP
    (as data comes from the database), which will help you write the rules and routes
    that will be used to access data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web APIs are relatively common and there are different specifications and protocols.
    The goal of API specification is to standardize—because of different programming
    languages and different **Operating Systems** (**OSs**)—exchanges between two
    or more web services. For example, you’ll find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote Procedure Call** (**RPC**): A protocol that can be used by a program
    to request a service from a program on another computer on a network that it does
    not need to know the details of. This is sometimes called a function or subroutine
    call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Object Access Protocol** (**SOAP**): An XML-based communication protocol
    that allows applications to exchange information with each other over HTTP. It
    therefore allows access to web services and the interoperability of applications
    across the web. SOAP is a simple and lightweight protocol that relies entirely
    on established standards such as HTTP and XML. It is portable and therefore independent
    of any OS and type of computer. SOAP is a non-proprietary specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**REST/RESTful**: A style of architecture for building applications (web, intranet,
    or web service). This is a set of conventions and best practices to be observed,
    not a technology in its own right. The REST architecture uses the original specifications
    of the HTTP protocol, rather than reinventing an overlay (as SOAP or XML-RPC do,
    for example):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 1**: The URL is a resource identifier'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2**: HTTP verbs are identifiers of operations'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 3**: HTTP responses are representations of resources'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 4**: Links are relations between resources'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 5**: A parameter is an authentication token'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we’ll be building REST APIs using Django and **Django REST**,
    so let’s get to know REST a bit better.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding REST APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST is usually the way to go when developers want to build an API. REST is
    a simple alternative to SOAP and RPC, as it makes it easier to write the logic
    to access resources; resources here are represented by a unique URL available
    with one request to this URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'RESTful APIs use HTTP requests (or methods) to interact with resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: The most commonly used method in APIs and websites. This method is used
    to retrieve data from a server at a specified resource. This resource is an endpoint
    returning an object or a list of objects in JSON or XML most of the time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: The `POST` method is a basic method for requesting information processing
    from the server. These requests are supposed to bring mechanisms specific to the
    server into play and cause communications with other modules, or even other servers,
    to process said data. Therefore, it is quite likely that two identical `POST`
    requests will receive different or even semantically opposite responses. The data
    to be processed is specified in the body of the request. The document designated
    by the request via the page is the resource that must process the data and generate
    the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: The `HEAD` method is used to query the header of the response, without
    the file being sent to you immediately. This is useful, for example, if large
    files need to be transferred: thanks to the `HEAD` request, the client can be
    informed of the size of the file first and only then decide whether to receive
    the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: This is a diagnostic method, which returns a message that is useful
    primarily for debugging and the like. This message basically indicates, surprisingly,
    which HTTP methods are active on the web server. In reality, it’s rarely used
    for legitimate purposes these days, but it does give potential attackers a bit
    of help – it can be seen as a shortcut to finding another hole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` and `PUT`: These methods are supposed to allow a document to be uploaded
    (to the server) or deleted without going through an **File Transfer Protocol**
    (**FTP**) server or the like. Obviously, this can cause file replacements, and
    therefore very large security breaches on a server. Therefore, most web servers
    require a special configuration with a resource or a document responsible for
    processing these requests. The document referred to by the request is the one
    to be replaced (or created), and the content of the document is in the body of
    the request. In theory, URL parameters and the fragment identifier should be prohibited
    or ignored by the server. In practice, they are generally transmitted to the resource
    responsible for processing the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: The `PATCH` method of an HTTP request applies partial changes to a
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRACE`: The `TRACE` method can be used to trace the path that an HTTP request
    takes to the server and then to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONNECT`: This method is supposed to be used to request the use of the server
    as a proxy. Not all servers necessarily implement them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One interesting benefit is that RESTful systems support different data formats,
    such as plain text, HTML, YAML, JSON, and XML.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, in this book, we’ll be building REST APIs using Django
    and Django REST.
  prefs: []
  type: TYPE_NORMAL
- en: What is Django?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django is an advanced web framework that was first released in 2005\. It is
    written in Python and makes use of the **Model-View-Controller** (**MVC**) architectural
    pattern. This pattern is commonly defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: Corresponds to all the data-related logic. It’s deeply connected
    to the database, as it provides the shape of the data but also methods and functions
    for **Create, Read, Update, and Delete** (**CRUD**) operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: Handles the UI logic of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: Represents a layer between the model and view. Most of the
    time, controllers interpret the incoming requests from the view, manipulate the
    data provided by the model component, and interact with the view again to render
    the final output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Django, this will be referred to as the **Model-View-Template** (**MVT**)
    architecture with the template corresponding to the view and the view here represented
    by the controller. Here’s a simple representation of the MVT architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – MVT architecture](img/Figure_1.2_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – MVT architecture
  prefs: []
  type: TYPE_NORMAL
- en: Django is a web framework that adopts the *Batteries included* approach. When
    developing a custom web application, Django provides the tools required to speed
    up the development process. It provides code and tools for common operations such
    as database manipulation, HTML templates, URL routing, session management, and
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Django allows developers to build all kinds of web applications (social networks,
    news sites, and wikis) with all the necessary basics, such as application security,
    made available from the start to allow developers to fully concentrate on most
    of their projects. Django provides protection against commons attacks – cross-site
    scripting, SQL injection, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll also be using **Django REST Framework** (**DRF**). It’s the most
    mature, testable, well-documented, and easily extendable framework, which will
    help create powerful RESTful APIs when coupled with Django. The combination of
    Django and the DRF is used by large companies such as Instagram, Mozilla, and
    even Pinterest.
  prefs: []
  type: TYPE_NORMAL
- en: When this framework is coupled with Django, the view will be replaced by routes
    or endpoints. We’ll discuss this concept later in the book – but why build an
    API with Django?
  prefs: []
  type: TYPE_NORMAL
- en: It’s true that traditional Django supports client languages such as HTML, CSS,
    and JavaScript. This helps build user interfaces that are served by the server
    and the performance is always impressive.
  prefs: []
  type: TYPE_NORMAL
- en: However, what if you have many machines that’ll access resources on the Django
    server? It’s true that if these machines are running applications based on JavaScript,
    we can always use the traditional Django way.
  prefs: []
  type: TYPE_NORMAL
- en: What if it’s a mobile application? What if it’s a service written with PHP?
  prefs: []
  type: TYPE_NORMAL
- en: That’s where an API can really be useful. You can have as many machines as you
    want requesting data from your API without issue, irrespective of the technology
    or the language used to build the applications that these machines are running.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea about what Django is, let’s set up the working environment
    and create our first server in Django.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the work environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting to work with Django, we must make sure you have a great environment,
    whatever OS you are using right now.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, make sure you have the latest version of Python installed. For
    this book, we’ll be working with Python 3.10.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a Windows machine, go to the official download page at [https://www.python.org/downloads/](https://www.python.org/downloads/)
    and download the relevant version.
  prefs: []
  type: TYPE_NORMAL
- en: For Linux users, you can download it using the default repository package download
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have Python installed, we have to ensure that we have `virtualenv`
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following for Windows users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done, we can now create a virtual environment – but why?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of environments when developing with Python: the global
    environment and the local environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just enter `pip` install requests randomly in the terminal, the package
    will be installed and can be accessed globally: this means accessed anywhere on
    your machine. Sometimes, you want to isolate the working environment to avoid
    version conflicts. For example, globally you may be working with Python 3.5, which
    supports Django 2.x versions. However, for this project, you want to use Python
    3.10 and the latest version of Django – here, 4.0\. Creating a `virtualenv` environment
    helps you with that.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have `virutalenv` installed, we can create and activate the `virtualenv`
    environment – but before that, create a directory called `django-api`. We’ll be
    building the Python project here.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following for Unix or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These preceding commands will create the `venv` directory containing the installed
    Python packages and the necessary configuration to access these packages when
    the virtual environment is activated. The next step is to activate the virtual
    environment. This will help us install the packages we need to start working on.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following for Unix or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Great! Next, let’s install the Django package.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to install packages in Python. You can easily just run `pip`
    `install package_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can write the package name with the version in a text file.
    I’ll go with the latter but feel free to use whatever version works for you.
  prefs: []
  type: TYPE_NORMAL
- en: Just understand that there can be some changes between the version and it can
    affect your project. For more similarities with what we’ll be using here, you
    can also use the latter option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great – let’s create a file named `requirements.txt` at the root of the `django-api`
    directory and add the Django package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now, run `pip install -r requirements.txt` to install Django.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure everything is working, we’ll quickly create a simple project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sample project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new project, we’ll use the `django-admin` command. It comes with
    options we can use to create projects in Django:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget to add the `.` dot at the end of this command. This will actually
    generate all the files in the current directory instead of creating another directory
    to put all the files in.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should have a structure of a file such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – File structure](img/Figure_1.3_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – File structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting the server, let’s run the migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have a similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Migrations are just a way to propagate changes made to the model in the database
    schema. As Django also comes with some models (such as the `User` model you can
    use for authentication), we need to apply these migrations. When we write our
    own models, we’ll also be creating migrations files and migrating them. Django
    has **object-relational mapping** (**ORM**) that automatically handles the interaction
    with the database for you.
  prefs: []
  type: TYPE_NORMAL
- en: Learning SQL and writing your own queries is quite difficult and demanding when
    you are new to it. It takes a long time and is quite off-putting. Fortunately,
    Django provides a system to take advantage of the benefits of an SQL database
    without having to write even a single SQL query!
  prefs: []
  type: TYPE_NORMAL
- en: This type of system is called ORM. Behind this somewhat barbaric-sounding name
    hides a simple and very useful operation. When you create a model in your Django
    application, the framework will automatically create a suitable table in the database
    that will save the data relating to the model.
  prefs: []
  type: TYPE_NORMAL
- en: No need to write SQL commands here – we’ll just write code in Python that will
    be directly translated into SQL. `python manage.py migrate` will then apply these
    changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run `python manage.py runserver`. You’ll see a similar output, and you’ll
    also have your server running at [https://localhost:8000](https://localhost:8000).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just hit this URL in your browser and you will see something such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Welcome page of the Django running server](img/Figure_1.4_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Welcome page of the Django running server
  prefs: []
  type: TYPE_NORMAL
- en: Great – we’ve just installed Django and started a Django server. Let’s talk
    about the structure of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Discussing the sample project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last part, we’ve briefly talked about how to create a `virtualenv` environment
    with Python. We’ve also created a Django project and made it run.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk quickly about the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed some files and directories in the `django-api` directory.
    Well, let’s quickly talk about these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`manage.py`: This is a utility provided by Django for many different needs.
    It’ll help you create projects and applications, run migrations, start a server,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CoreRoot`: This is the name of the project we’ve created with the `django-admin`
    command. It contains files such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urls.py`: This contains all the URLs that will be used to access resources
    in the project:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`wsgi.py`: This file is basically used for deployment but also as the default
    development environment in Django.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asgi.py`: Django also supports running asynchronous codes as an ASGI application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`settings.py`: This contains all the configurations for your Django projects.
    You can find `SECRET_KEY`, the `INSTALLED_APPS` list, `ALLOWED_HOST`, and so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you are familiar with the structure of a Django project, let’s see
    how to configure the project to connect to a database.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django, by default, uses **sqlite3** as a database, which is an in-process library
    that implements a fast self-contained, zero-configuration, serverless, transactional
    SQL database engine. It’s very compact and easy to use and set up. It’s ideal
    if you are looking to quickly save data or for testing. However, it comes with
    some disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, there are no multi-user capabilities, which means that it comes
    with a lack of granular access control and some security capabilities. This is
    due to the fact that SQLite reads and writes directly to an ordinary disk file.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in our project, after running the migrations, you’ll notice the
    creation of a new file, `db.sqlite3`. Well, this is our database actually.
  prefs: []
  type: TYPE_NORMAL
- en: We will be replacing it with a more powerful SMDB called **Postgres**.
  prefs: []
  type: TYPE_NORMAL
- en: Postgres configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PostgreSQL is one of the world’s most advanced enterprise-class open source
    database management systems, developed and maintained by the PostgreSQL global
    development group. It’s a powerful and highly extensible object-relational SQL
    database system that comes with interesting features such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: User-defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-user capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the features you will be looking for in a database, mostly when working
    in a development or production environment.
  prefs: []
  type: TYPE_NORMAL
- en: According to your OS, you can download Postgres versions at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
    In this book, we are working with PostgreSQL 14.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it’s done, we’ll install a PostgreSQL adapter for Python, **psycopg**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t forget to add this to the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Great – now that we have the adapter installed, let’s quickly create the database
    we’ll use for this project.
  prefs: []
  type: TYPE_NORMAL
- en: For that, we need to connect as a Postgres user in the terminal and then access
    the `psql` terminal. In that terminal, we can enter SQL commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux users, you can log in as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then, enter `psql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great – let’s create the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect to the database, we need `USER` with a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s always a good habit to use strong passwords. You can generate strong passwords
    at https://passwordsgenerator.net/ – and the next step is to grant access to our
    database to the new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are nearly done. We also need to make sure this user can create a database.
    This will be helpful when we can run tests. To run tests, Django will configure
    a full environment but will also use a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With that, we are done with the creation of the database. Let’s connect this
    database to our Django project.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connecting the database to Django requires some configurations. Then, we have
    to open the `settings.py` file, look for a database configuration, and then modify
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `settings.py` file, you’ll find a similar line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Great – as you can see, the project is still running on the SQLite3 engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove this content and replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We’ve just modified the database engine but also filled in information such
    as the name of the database, the user, the password, the host, and the port.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ENGINE` key for the MySQL database varies. Besides that, there are a few
    additional keys, such as `USER`, `PASSWORD`, `HOST`, and `PORT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NAME`: This key stores the name of your MySQL database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USER`: This key stores the username of the MySQL account to which the MySQL
    database will be connected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PASSWORD`: This key stores the password for this MySQL account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HOST`: This key stores the IP address at which your MySQL database is hosted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PORT`: This key stores the port number on which your MySQL database is hosted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The configuration is done. Let’s run the migrations and see whether everything
    works okay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a similar output in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Great! We’ve just configured Django with PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Installing an HTTP request client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing an API as a backend developer, it’s a good habit to have an
    API client to test your API and make sure it behaves as you needed. API clients
    are packages, or libraries to send HTTP requests to an API. A great majority supports
    features such as SSL checking, authentication, and header modification. In this
    book, we’ll be working with Insomnia. It’s lightweight and simple to use and customize.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download a version of Insomnia that suits your OS, go to the following page:
    [https://insomnia.rest/download](https://insomnia.rest/download).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the world of backend development to clarify the
    roles and responsibilities of a backend developer. We also talked about APIs,
    mostly REST APIs, which will be built in this book. We’ve also had a brief introduction
    to Django, the MVT architecture used by the framework, and connected a PostgreSQL
    database to the Django project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig deeper into Django by creating our first models,
    tests, and endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a REST API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Django?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to create a Django project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are migrations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a virtual environment in Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
