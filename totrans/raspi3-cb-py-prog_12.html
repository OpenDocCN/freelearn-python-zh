<html><head></head><body><div><h1 class="header-title">Building Robots</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Building a Rover-Pi robot with forward driving motors</li>
<li>Using advanced motor control</li>
<li>Building a six-legged Pi-Bug robot</li>
<li>Controlling servos directly with ServoBlaster</li>
<li>Avoiding objects and obstacles</li>
<li>Getting a sense of direction</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>A little computer with a "brain the size of a planet" (to quote Douglas Adams, the author of <em>Hitchhiker's Guide to the Galaxy</em>) would be perfect as the brain of your own robotic creation. In reality, the Raspberry Pi probably provides far more processing power than a little robot or rover needs; however, its small size, excellent connectivity, and fairly low-power requirements mean that it is ideally suited.</p>
<p>This chapter will focus on exploring the various ways we can combine motors or servos to produce robotic movement, use sensors to gather information, and allow our creation to act upon it.</p>
<p>Be sure to check out the <em>Appendix,</em> <em>Hardware and Software List</em>; it lists all of the items used in this chapter and the places you can obtain them from.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Building a Rover-Pi robot with forward driving motors</h1>
                
            
            
                
<p>Creating robots does not need to be an expensive hobby. A small, rover-type robot can be constructed using household items for the chassis (the base everything is attached to), and a couple of small driving motors can be used to move it.</p>
<p>A Rover-Pi robot is a small, buggy-type robot that has two wheels and a skid or caster at the front to allow it to turn. One such robot is shown in the following image:</p>
<div><img src="img/bafe4de4-9f36-4a25-ad0e-a4a59bc345d0.png" style="width:21.33em;height:16.25em;" width="1000" height="761"/></div>
<p>A home-built Rover-Pi robot</p>
<p>While it may not be in the same league as a Mars exploration rover, as you will see, there is plenty for you to experiment with.</p>
<p>You can also purchase one of many inexpensive robot kits that contain most of what you need in a single package (see the <em>There's more...</em> section at the end of this example).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The rover that we will build will need to contain the elements shown in the following diagram:</p>
<div><img src="img/95cd43ca-57d0-4cb8-9f58-cd4b7627a6d1.png" style="width:24.25em;height:19.92em;" width="516" height="426"/></div>
<p>The separate parts of the Rover-Pi robot</p>
<p>The elements are discussed in detail as follows:</p>
<ul>
<li><strong>Chassis</strong>: This example uses a modified, battery-operated push nightlight (although any suitable platform can be used). Remember that the larger and heavier your robot is, the more powerful the driving motors will need to be to move it. Alternatively, you can use one of the chassis kits listed in the <em>There's more...</em> section. A suitable push nightlight is shown in the following photo:</li>
</ul>
<div><img src="img/8c391727-19e1-4f95-a1cb-2c22e2b11a3f.png" style="width:18.42em;height:16.75em;" width="1000" height="909"/></div>
<p>This push nightlight forms the basic chassis of a Rover-Pi robot</p>
<ul>
<li><strong>Front skid or caster</strong>: This can be as simple as a large paper clip (76 mm/3 inches) bent into shape, or a small caster wheel. A skid works best when it is on a smooth surface, but it may get stuck on the carpet. A caster wheel works well on all surfaces, but sometimes, it can have problems turning.</li>
<li><strong>Wheels, motors,</strong> <strong>and gears</strong>: The wheel movement of the Rover-Pi robot is a combination of the motor, gears, and wheels. The gears are helpful, as they allow a fast-spinning motor to turn the wheels at a slower speed and more force (torque); this will allow for better control of our robot. A unit that combines the wheels, motors, and gears in a single unit is shown in the following photo:</li>
</ul>
<div><img src="img/c889b0cd-b66c-4320-9c4f-30e407900480.png" style="width:26.67em;height:17.17em;" width="1000" height="641"/></div>
<p>These wheels, with built-in geared motors, are ideal for small rovers</p>
<ul>
<li><strong>Battery/power source</strong>: The Rover-Pi robot will be powered using four AA batteries, fitted into the bay of the chassis. Alternatively, a standard battery holder can be used, or even a long wire connected to a suitable power supply. It is recommended that you power the motors from a supply independent from the Raspberry Pi. This will help to avoid a situation in which the Raspberry Pi suddenly loses power when driving the motors, which require a big jump in current to move. Alternatively, you can power the Raspberry Pi with the batteries using a 5V regulator. The following image shows a chassis with four AA batteries:</li>
</ul>
<div><img src="img/e267b815-edb5-4a07-9fce-c463c4fb6e0f.png" style="width:20.25em;height:19.08em;" width="1000" height="942"/></div>
<p>Four AA batteries provide a power source to drive the wheels</p>
<ul>
<li><strong>Motor driver/controller</strong>: Motors will require a voltage and current greater than the GPIO can handle. Therefore, we will use a <strong>Darlington array module</strong> (which uses a <strong>ULN2003</strong> chip). See the <em>There's more...</em> section at the end of this example for more details on how this particular module works. The following photo shows a Darlington array module:</li>
</ul>
<div><img src="img/89b8f536-48c5-4789-82e6-843f383a4908.png" style="width:23.42em;height:18.75em;" width="1000" height="801"/></div>
<p>This Darlington array module, available at http://www.dx.com, can be used to drive small motors</p>
<ul>
<li><strong>Small cable ties or wire ties</strong>: This will allow us to attach items, such as a motor or a controller, to the chassis. The following photo shows the use of cable ties:</li>
</ul>
<div><img src="img/cbabca2d-a3d8-4ac5-a6a1-fdcf4b410098.png" style="width:23.33em;height:16.17em;" width="1000" height="696"/></div>
<p>We use cable ties to secure the motors and wheels to the chassis</p>
<ul>
<li><strong>The Raspberry Pi connection</strong>: The easiest setup is to attach the control wires to the Raspberry Pi using long cables, so that you can easily control your robot directly using an attached screen and keyboard. Later, you can consider mounting the Raspberry Pi on the robot and controlling it remotely (or even autonomously, if you include sensors and intelligence to make sense of them).</li>
</ul>
<p>In this chapter, we will use the <kbd>wiringpi2</kbd> Python library to control the GPIO; see <a href="18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml" target="_blank">Chapter 10</a>, <em>Sensing and Displaying Real-World Data</em>, for details on how to install it using a Python package manager (<kbd>pip</kbd>).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Perform the following steps to create a small Rover-Pi robot:</p>
<ol>
<li>At the front of the chassis, you will need to mount the skid by bending the<br/>
paperclip/wire into a V shape. Attach the paperclip/wire to the front of the chassis by drilling small holes on either side, threading cable ties through the holes around the wire, and pulling tightly to secure. The fitted wire skid should look similar to the one shown in the following photo:</li>
</ol>
<div><img src="img/15f491a6-7324-409e-bd1f-8c1b5bd4ba56.png" style="width:18.58em;height:18.25em;" width="970" height="956"/></div>
<p>Wire skid fitted to the front of the Rover-Pi robot</p>
<ol start="2">
<li>Before you mount the wheels, you need to work out the approximate center of gravity of the chassis (do this with the batteries fitted in the chassis, as they will affect the balance). Get a feel of where the center is by trying to balance the unit on two fingers on either side and finding out how far forward or backward the chassis tilts. For my unit, this was about 1 cm (approximately one-third of an inch) back from the center. You should aim to place the wheel axles slightly behind this so that the rover will rest slightly forward on the skid. Mark the location of the wheels on the chassis.</li>
<li>Drill three holes on each side to mount the wheels using the cable ties. If the cable ties aren't long enough, you can join two together by pulling the end of one through the end of the other (only pull through far enough for the tie to grip so that it extends the tie). The following diagram shows how you can use the cable ties:</li>
</ol>
<div><img src="img/865c1168-1f2a-4f4c-824f-fd9670b66fab.png" style="width:17.08em;height:9.33em;" width="1317" height="721"/></div>
<p>Securely fix the motors to the chassis</p>
<ol start="4">
<li>Next, test the motors by inserting the batteries into the unit; then, disconnect the wires that originally connected to the bulb, and touch them to the motor contacts. Determine which connection on the motor should be positive and which should be negative for the motor to move the robot forward (the top of the wheel should move forward when the robot is facing forwards). Connect red and black wires to the motor (on mine, black equals negative at the top of the motor, and red equals positive at the bottom), ensuring that the wires are long enough to reach anywhere on the chassis (around 14 cm, that is, approximately 5.5 inches, is enough for the nightlight).</li>
</ol>
<p style="padding-left: 60px">The Rover-Pi robot components should be wired up as shown in the following diagram:</p>
<div><img src="img/656be4cb-1881-424a-a309-1648d435aa04.png" style="width:24.67em;height:13.33em;" width="692" height="374"/></div>
<p>The wiring layout of the Rover-Pi robot</p>
<p>To make the connections, perform the following steps:</p>
<ol>
<li>Connect the black wires of the motors to the <strong>OUT 1</strong> (left) and <strong>OUT 2</strong> (right) output of the Darlington module, and connect the red wires to the last pin (the COM connection).</li>
<li>Next, connect the battery wires to the <strong>GND</strong>/<strong>V-</strong> and <strong>V+</strong> connections at the bottom of the module.</li>
<li>Finally, connect the <strong>GND</strong> from the GPIO connector (<strong>Pin 6</strong>) to the same <strong>GND</strong> connection.</li>
<li>Test the motor control by connecting 3.3V (GPIO <strong>Pin 1</strong>) to <strong>IN1</strong> or <strong>IN2,</strong> to simulate a GPIO output. When you're happy, connect GPIO <strong>Pin 16</strong> to <strong>IN1</strong> (for left) and GPIO <strong>Pin 18</strong> to <strong>IN2</strong> (for right).</li>
</ol>
<p>The wiring should now match the details given in the following table:</p>
<table class="table">
<thead>
<tr>
<td>
<p><strong>Raspberry Pi GPIO</strong></p>
</td>
<td>
<p><strong>Darlington module</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>Pin 16: Left</p>
</td>
<td>
<p>IN1</p>
</td>
</tr>
<tr>
<td>
<p>Pin 18: Right</p>
</td>
<td>
<p>IN2</p>
</td>
</tr>
<tr>
<td>
<p>Pin 6: GND</p>
</td>
<td>
<p>GND/V- (marked with -)</p>
</td>
</tr>
<tr>
<td>
<p><strong>Motor 4 x AA battery Darlington module</strong></p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Positive side of battery</p>
</td>
<td>
<p>V+ (marked with +)</p>
</td>
</tr>
<tr>
<td>
<p>Negative side of battery</p>
</td>
<td>
<p>GND/V- (marked with -)</p>
</td>
</tr>
<tr>
<td>
<p><strong>Motors</strong></p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Left motor: black wire</p>
</td>
<td>
<p>OUT 1 (top pin in white socket)</p>
</td>
</tr>
<tr>
<td>
<p>Right motor: black wire</p>
</td>
<td>
<p>OUT 2 (second pin in white socket)</p>
</td>
</tr>
<tr>
<td>
<p>Both motors: red wires</p>
</td>
<td>
<p>COM (last pin in white socket)</p>
</td>
</tr>
</tbody>
</table>
<div><p> </p>
<p>Use the following <kbd>rover_drivefwd.py</kbd> script to test the control:</p>
<pre>#!/usr/bin/env python3 
#rover_drivefwd.py 
#HARDWARE SETUP 
# GPIO 
# 2[==X====LR====]26[=======]40 
# 1[=============]25[=======]39 
import time 
import wiringpi2 
ON=1;OFF=0 
IN=0;OUT=1 
STEP=0.5 
PINS=[16,18] # PINS=[L-motor,R-motor] 
FWD=[ON,ON] 
RIGHT=[ON,OFF] 
LEFT=[OFF,ON] 
DEBUG=True 
 
class motor: 
  # Constructor 
  def __init__(self,pins=PINS,steptime=STEP): 
    self.pins = pins 
    self.steptime=steptime 
    self.GPIOsetup() 
 
  def GPIOsetup(self): 
    wiringpi2.wiringPiSetupPhys() 
    for gpio in self.pins: 
      wiringpi2.pinMode(gpio,OUT) 
 
  def off(self): 
    for gpio in self.pins: 
      wiringpi2.digitalWrite(gpio,OFF) 
 
  def drive(self,drive,step=STEP): 
    for idx,gpio in enumerate(self.pins): 
      wiringpi2.digitalWrite(gpio,drive[idx]) 
      if(DEBUG):print("%s:%s"%(gpio,drive[idx])) 
    time.sleep(step) 
    self.off() 
 
  def cmd(self,char,step=STEP): 
    if char == 'f': 
      self.drive(FWD,step) 
    elif char == 'r': 
      self.drive(RIGHT,step) 
    elif char == 'l': 
      self.drive(LEFT,step) 
    elif char == '#': 
      time.sleep(step) 
 
def main(): 
  import os 
  if "CMD" in os.environ: 
    CMD=os.environ["CMD"] 
    INPUT=False 
    print("CMD="+CMD) 
  else: 
    INPUT=True 
  roverPi=motor() 
  if INPUT: 
    print("Enter CMDs [f,r,l,#]:") 
    CMD=input() 
  for idx,char in enumerate(CMD.lower()): 
    if(DEBUG):print("Step %s of %s: %s"%(idx+1,len(CMD),char)) 
    roverPi.cmd(char) 
 
if __name__=='__main__': 
  try: 
    main() 
  finally: 
    print ("Finish") 
#End </pre>
<p>Remember that <kbd>wiringpi2</kbd> should be installed before running the scripts in this chapter (see <a href="18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml" target="_blank">Chapter 10</a><em>, Sensing and Displaying Real-World Data</em>).</p>
<p>Run the previous code using the following command:</p>
<pre><strong>sudo python3 rover_drivefwd.py</strong> </pre>
<p>The script will prompt you with the following message:</p>
<pre><strong>Enter CMDs [f,r,l,#]:</strong>  </pre>
<p>You can enter a series of commands to follow; for example:</p>
<pre><strong>ffrr#ff#llff</strong>  </pre>
<p>The preceding command will instruct the Rover-Pi robot to perform a series of movements: forward (<kbd>f</kbd>), right (<kbd>r</kbd>), pause (<kbd>#</kbd>), and left (<kbd>l</kbd>).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Once you have built the robot and wired up the wheels to the motor controller, you can work out how to control it.</p>
<p>Start by importing <kbd>time</kbd> (which will allow you to put pauses in the motor control) and <kbd>wiringpi2</kbd> (to allow control of the GPIO pins). Use <kbd>wiringpi2</kbd> here, since it makes it much easier to make use of I/O expanders and other I<sup>2</sup>C devices, if you want to later on.</p>
<p>Define values to use for setting the pins <kbd>ON</kbd>/<kbd>OFF</kbd>, for the direction <kbd>IN</kbd>/<kbd>OUT</kbd>, as well as the duration of each motor <kbd>STEP</kbd>. Also, define which <kbd>PINS</kbd> are wired to the motor controls, and our movements, <kbd>FWD</kbd>, <kbd>RIGHT</kbd>, and <kbd>LEFT</kbd>. The movement is defined in such a way that by switching both motors <kbd>ON</kbd>, you will move forward, and by switching just one motor <kbd>ON</kbd>, you will turn. By setting these values at the start of the file using variables, our code is easier to maintain and understand.</p>
<p>We define a <kbd>motor</kbd> class that will allow us to reuse it in other code, or easily swap it with alternative <kbd>motor</kbd> classes so that we can use other hardware if we want to. We set the default pins we are using and our <kbd>steptime</kbd> value (the <kbd>steptime</kbd> object defines how long we drive the motor(s) for in each step). However, both can still be specified when initializing the object, if desired.</p>
<p>Next, we call <kbd>GPIOsetup()</kbd>; it selects the physical pin numbering mode (so we can refer to the pins as they are located on the board). We also set all of the pins we are using to output.</p>
<p>Finally, for the <kbd>motor</kbd> class, we define the following three functions:</p>
<ul>
<li>The first function we define (called <kbd>off()</kbd>) will allow us to switch off the motors, so we cycle through the pins list and set each GPIO pin to low (and therefore switch the motors off).</li>
<li>The <kbd>drive()</kbd> function allows us to provide a list of drive actions (a combination of <kbd>ON</kbd> and <kbd>OFF</kbd> for each of the GPIO pins). Again, we cycle through each of the pins and set them to the corresponding drive action, wait for the step time, and then switch the motors off using the <kbd>off()</kbd> function.</li>
<li>The last function we define (called <kbd>cmd()</kbd>) simply allows us to send <kbd>char</kbd> (a single character) and use it to select the set of drive actions we want to use (<kbd>FWD</kbd>, <kbd>RIGHT</kbd> or <kbd>LEFT</kbd>, or wait (<kbd>#</kbd>)).</li>
</ul>
<p>For testing, <kbd>main()</kbd> allows us to specify a list of actions that need to be performed from the command line using the following command:</p>
<pre><strong>sudo CMD=f#lrr##fff python3 rover_drivefwd.py</strong>
  </pre>
<p>Using <kbd>os.environ</kbd> (by importing the <kbd>os</kbd> module so we can use it), we can check for <kbd>CMD</kbd> in the command and use it as our list of drive actions. If no <kbd>CMD</kbd> command has been provided, we can use the <kbd>input()</kbd> function to directly prompt for a list of drive actions. To use the <kbd>motor</kbd> class, we set <kbd>roverPi=motor()</kbd>; this allows us to call the <kbd>cmd()</kbd> function (of the motor class) with each character from the list of drive actions.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Your robot should be limited only by your own creativity. There are lots of suitable chassis options, other motors, wheels, and ways to control and drive the wheels. You should experiment and test things to determine which combinations work best together. That is all part of the fun!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Darlington array circuits</h1>
                
            
            
                
<p>Darlington transistors are a low-cost way to drive high powered devices, such as motors, or even relays. They consist of two transistors arranged in a series, where one feeds the other (allowing the gain in the current to be multiplied). That is, if the first transistor has a gain of 20, and the second one also has a gain of 20, together, they will provide an overall gain of 400.</p>
<p>This means that 1 mA on the base pin (1) in the following diagram will allow you to drive up to 400 mA through the Darlington transistor. The Darlington transistor's electrical symbol is shown in the following diagram:</p>
<div><img src="img/191e59cf-7f88-477c-8a19-aea25cd5e912.png" style="width:17.17em;height:18.75em;" width="458" height="501"/></div>
<p>The electrical symbol for a Darlington transistor shows how two transistors are packaged together</p>
<p>The ULN2003 chip is used in the previous module and provides seven NPN Darlington transistors (an eight-way version, ULN2803, is also available if more output is required or to use with two stepper motors). The following diagram shows how a Darlington array can be used to drive motors:</p>
<div><img src="img/d26fc7b8-0679-423e-950f-92f6079a2ada.png" style="width:33.17em;height:19.42em;" width="482" height="282"/></div>
<p>A Darlington array being used to drive two small motors</p>
<p>Each output from the chip can supply a maximum of 500 mA at up to 50V (enough to power most small motors). However, with extended use, the chip may overheat, so a heat sink is recommended when driving larger motors. An internal diode, connected across each Darlington for protection, is built into the chip. This is needed because when the motor moves without being driven (this can occur due to the natural momentum of the motor), it will act like a generator. A reverse voltage called <strong>back EMF</strong> is created, which would destroy the transistor if it wasn't dissipated back through the diode.</p>
<p>One disadvantage of the chip is that the positive supply voltage must always be connected to the common pin (COM), so each output is only able to sink current. That is, it will only drive the motor in one direction, with the positive voltage on COM and the negative voltage on the OUT pins. Therefore, we will need a different solution if we wish to drive our Rover-Pi robot in different directions (see the next example in the <em>Using advanced motor control</em> recipe).</p>
<p>These chips can also be used to drive certain types of stepper motors. One of the modules from <a href="http://www.dx.com">http://www.dx.com</a> includes a stepper motor as a part of the kit. Although the gearing is for very slow movement, at around 12 seconds per rotation (too slow for a rover), it is still interesting to use (for a clock, perhaps).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Transistor and relay circuits</h1>
                
            
            
                
<p>Relays are able to handle much more highly powered motors, since they are mechanical switches controlled by an electromagnetic coil that physically moves the contacts together. However, they require a reasonable amount of current to be turned on – usually more than 3.3V. To switch even small relays, we need around 60 mA at 5V (more than is available from the GPIO), so we will still need to use some additional components to switch it.</p>
<p>We can use the Darlington array (as used previously) or a small transistor (any small transistor, such as the 2N2222, will be fine) to provide the current and voltage required to switch it. The following circuit will allow us to do that:</p>
<div><img src="img/d0503f39-881f-4f37-9084-64bbdc8a4bde.png" style="width:21.25em;height:26.17em;" width="287" height="353"/></div>
<p>The transistor and relay circuit used to drive external circuits</p>
<p>Much like a motor, a relay can also generate EMF spikes, so a protection diode is needed to avoid any reverse voltage on the transistor.</p>
<p>This is a very useful circuit, not just for driving motors, but for any external circuit; the physical switch allows it to be independent and electrically isolated from the Raspberry Pi controlling it.</p>
<p>As long as the relay is rated correctly, you can drive DC or AC devices through it.</p>
<p>You can use some relays to control items powered by the mains. However, this should be done only with extreme caution and proper electrical training. Electricity from the mains can kill or cause serious harm.</p>
<p>PiBorg has a ready-made module named the <strong>PicoBorg</strong> that will allow the switching of up to four relays. It uses devices called <strong>metal-oxide-semiconductor field-effect transistor</strong> (<strong>MOSFETs</strong>), which are essentially high-power versions of transistors that function with the same principle as discussed previously.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Tethered or untethered robots</h1>
                
            
            
                
<p>An important choice when designing your own Rover-Pi robot is to decide if you want to make it fully self-contained, or if you are happy to have a tether (a long control/power cable connected to the Rover-Pi). Using a tether, you can keep the weight of the Rover-Pi robot down, which means the small motors will be able to move the unit with ease. This will allow you to keep the Raspberry Pi separate from the main unit so that it can remain connected to a screen and keyboard for easy programming and debugging. The main disadvantage is that you will need a long, umbilical-like connection to your Rover-Pi robot (with a wire for each control signal) that may impede its movement. However, as we will see later, you may only need three or four wires to provide all of the control you need (see the <em>Using I/O expanders</em> section in the next recipe).</p>
<p>If you intend to mount the Raspberry Pi directly on the Rover-Pi robot, you will need a suitable power supply, such as a phone charger battery pack. If the battery pack has two USB ports, then you may be able to use it as a power source to drive both the Raspberry Pi and the motors. The unit must be able to maintain the supplies independently, as any power spike caused by driving the motors could reset the Raspberry Pi.</p>
<p>Remember that if the Raspberry Pi is now attached to the robot, you will need a means to control it. This could be a USB Wi-Fi dongle that allows a remote connection via SSH (and so on), or a wireless keyboard (that uses RF/Bluetooth), or even the GPIO D-Pad from <a href="7cf87b89-8982-4d64-852c-ddfcbf742be5.xhtml" target="_blank">Chapter 9</a><em>,</em> <em>Using Python to Drive Hardware</em>, which can be used for direct control.</p>
<p>However, the more you mount on the chassis, the harder the motors will need to work to move. You may find that stronger motors are required, rather than the little ones used here. A Rover-Pi robot powered by a USB battery pack is shown in the following photo:</p>
<div><img src="img/cd3e2b82-820b-4567-8188-4dfbf9c5f28b.png" style="width:27.75em;height:33.42em;" width="831" height="1000"/></div>
<p>A battery-powered Raspberry Rover-Pi robot being controlled via Wi-Fi (cable management is optional)</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Rover kits</h1>
                
            
            
                
<p>If you don't fancy making your own chassis, there are also a number of pre-made rover chassis available. They are as follows:</p>
<ul>
<li>2WD Magician Robot Chassis from <a href="https://www.sparkfun.com/">https://www.sparkfun.com/</a></li>
<li>4-Motor Smart Car Chassis from <a href="http://www.dx.com/" target="_blank">http://www.dx.com/</a> <a href="http://www.dx.com/" target="_blank"/></li>
<li>2-Wheel Smart Car Model from <a href="http://www.dx.com/" target="_blank">http://www.dx.com/</a><a href="http://www.dx.com/" target="_blank"/></li>
</ul>
<div><img src="img/9b82efda-c4a1-4664-b20b-89df3bd606cc.png" style="width:23.08em;height:35.00em;" width="657" height="1000"/></div>
<p>The TiddlyBot shows how multiple components can be integrated together within a single platform, as shown in my modified version</p>
<p>A particularly nice robot setup is the TiddlyBot (from <a href="http://www.PiBot.org">http://www.PiBot.org</a>), which combines multiple sensors, continuous servos, an onboard battery pack, and the Raspberry Pi camera. An SD card is set up so the TiddlyBot acts as a Wi-Fi hotspot, hosting a simple drag and drop programming platform with a remote control interface.</p>
<p>This shows how simple components such as the ones described in this chapter can be combined into a complete system:</p>
<div><img src="img/30dba40d-cbf7-40e9-8848-52235a04ab63.png" width="952" height="392"/></div>
<p>The TiddlyBot GUI provides a cross-platform drag and drop interface, as well as Python support</p>
<p>Be sure to check out the <em>Appendix,</em> <em>Hardware and Software List</em>; it lists all of the items used in this chapter and the places you can obtain them from.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using advanced motor control</h1>
                
            
            
                
<p>The previous driving circuits are not suitable for driving motors in more than one direction (as they only switch the motor on or off). However, using a circuit named an H-bridge, you can switch and control the motor's direction, too.</p>
<p>The switch combinations are shown in the following diagram:</p>
<div><img src="img/881f7600-1cd8-424b-825b-c7ba093b61ae.png" style="width:34.17em;height:27.50em;" width="853" height="686"/></div>
<p>The direction of the motor can be controlled by different switch combinations</p>
<p>Using a different combination of switching, we can change the direction of the motor by switching the positive and negative supply to the motor (<strong>SW1</strong> and <strong>SW4</strong> activate the motor, and <strong>SW2</strong> and <strong>SW3</strong> reverse the motor). However, not only do we need four switching devices for each motor, but since the ULN2X03 devices and PiBorg's PicoBorg module can only sink current, equivalent devices would be required to source current (to make up the top section of switches).</p>
<p>Fortunately, there are purpose-built H-bridge chips, such as L298N, that contain the previous circuit inside them to provide a powerful and convenient way to control motors.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We shall replace the previous Darlington array module with the H-bridge motor controller shown in the following image:</p>
<div><img src="img/f87ecfb3-c480-432a-960c-98b82371d5b5.png" style="width:28.83em;height:25.50em;" width="930" height="822"/></div>
<p>The H-bridge motor controller allows for directional control of motors</p>
<p>The datasheet of L298N is available at <a href="http://www.st.com/resource/en/datasheet/l298.pdf">http://www.st.com/resource/en/datasheet/l298.pdf</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The unit will need to be wired as follows (this will be similar for other H-bridge type controllers, but check with the relevant datasheet if unsure).</p>
<p>The following table shows how the motors and motor power supply connect to the H-bridge controller module:</p>
<table>
<tbody>
<tr>
<td colspan="7">
<p><strong>The motor side of the module – connecting to the battery and motors</strong></p>
</td>
</tr>
<tr>
<td colspan="2">
<p><strong>Motor A</strong></p>
</td>
<td>
<p><strong>VMS</strong></p>
</td>
<td>
<p><strong>GND</strong></p>
</td>
<td>
<p><strong>5V OUT</strong></p>
</td>
<td colspan="2">
<p><strong>Motor B</strong></p>
</td>
</tr>
<tr>
<td>
<p>Left motor red wire</p>
</td>
<td>
<p>Left motor black wire</p>
</td>
<td>
<p>Battery positive</p>
</td>
<td>
<p>Battery GND</p>
</td>
<td>
<p>None</p>
</td>
<td>
<p>Right motor red wire</p>
</td>
<td>
<p>Right motor black wire</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The following table shows how the H-bridge controller module connects to the Raspberry Pi:</p>
<table>
<tbody>
<tr>
<td colspan="8">
<p><strong>Control side of the module – connecting to the Raspberry Pi GPIO header</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>ENA</strong></p>
</td>
<td>
<p><strong>IN1</strong></p>
</td>
<td>
<p><strong>IN2</strong></p>
</td>
<td>
<p><strong>IN3</strong></p>
</td>
<td>
<p><strong>IN4</strong></p>
</td>
<td>
<p><strong>ENB</strong></p>
</td>
<td>
<p><strong>GND</strong></p>
</td>
<td>
<p><strong>5V</strong></p>
</td>
</tr>
<tr>
<td>
<p>None</p>
</td>
<td>
<p>Pin 15</p>
</td>
<td>
<p>Pin 16</p>
</td>
<td>
<p>Pin 18</p>
</td>
<td>
<p>Pin 22</p>
</td>
<td>
<p>None</p>
</td>
<td>
<p>Pin 6</p>
</td>
<td>
<p>None</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="packt_figure">It is recommended that you keep the pull-up resistor jumpers on (UR1-UR4) and allow the motor supply to power the onboard voltage regulator, which will in turn power the L298N controller (jumper 5V_EN). The onboard regulator (the 78M05 device) can supply up to 500 mA, enough for the L298N controller plus any additional circuits, such as an I/O expander (see the <em>There's more...</em> section for more information). Both the ENA and ENB pins should be disconnected (the motor output will stay enabled by default).</p>
<p>You will need to make the following changes to the previous <kbd>rover_drivefwd.py</kbd> script (you can save it as <kbd>rover_drive.py</kbd>).</p>
<p>At the top of the file, redefine <kbd>PINS</kbd>, as follows:</p>
<pre>PINS=[15,16,18,22]   # PINS=[L_FWD,L_BWD,R_FWD,R_BWD] </pre>
<p>And update the control patterns, as follows:</p>
<pre>FWD=[ON,OFF,ON,OFF] 
BWD=[OFF,ON,OFF,ON] 
RIGHT=[OFF,ON,ON,OFF] 
LEFT=[ON,OFF,OFF,ON] </pre>
<p>Next, we need to add the backwards command to <kbd>cmd()</kbd>, as follows:</p>
<pre>  def cmd(self,char,step=STEP): 
    if char == 'f': 
      self.drive(FWD,step) 
    elif char == 'b': 
      self.drive(BWD,step) 
    elif char == 'r': 
      self.drive(RIGHT,step) 
    elif char == 'l': 
      self.drive(LEFT,step) 
    elif char == '#': 
      time.sleep(step) </pre>
<p>Finally, we can update the prompt that we have within the <kbd>main()</kbd> function to include <kbd>b</kbd> (backwards) as an option, as follows:</p>
<pre>print("Enter CMDs [f,b,r,l,#]:") </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The H-bridge motor controller recreates the previous switching circuit with additional circuitry to ensure that the electronic switches cannot create a short circuit (by not allowing <strong>SW1</strong> and <strong>SW3</strong> or <strong>SW2</strong> and <strong>SW4</strong> to be enabled at the same time).</p>
<p>The H-bridge motor controller's switching circuit is shown in the following diagram:</p>
<div><img src="img/af7d428f-5369-4292-87cd-9f650af08322.png" style="width:33.75em;height:26.83em;" width="879" height="696"/></div>
<p>An approximation of the H-bridge switching circuit (in motor off state)</p>
<p>The input (<strong>IN1</strong> and <strong>IN2</strong>) will produce the following action on the motors:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>IN1</strong></p>
<p><strong>IN2</strong></p>
</td>
<td>
<p><strong>0</strong></p>
</td>
<td>
<p><strong>1</strong></p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>Motor off</p>
</td>
<td>
<p>Motor backwards</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>Motor forwards</p>
</td>
<td>
<p>Motor off</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As we did in the previous recipe, we can move forward by driving both motors forward; however, now we can drive them both backwards (to move backwards), as well as in opposite directions (allowing us to turn the Rover-Pi robot on the spot).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We can achieve finer control of the motors using a <strong>pulse width modulated</strong> (<strong>PWM</strong>) signal and expand the available input/output using an I/O expander.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Motor speed control using PWM control</h1>
                
            
            
                
<p>Currently, the Rover-Pi robot motors are controlled by being switched on and off; however, if the robot is moving too fast (for example, if you have fitted bigger motors or used higher gearing), we can make use of the <strong>ENA</strong> and <strong>ENB</strong> input on the controller. If these are set low, the motor output is disabled, and if set high, it is enabled again. Therefore, by driving them with a PWM signal, we can control the speed of the motors. We could even set slightly different PWM rates (if required) to compensate for any differences in the motors/wheels or surface to drive them at slightly different speeds, as shown in the following diagram:</p>
<div><img src="img/8e07deb5-6fa5-4f0e-9758-fd94920bc0d4.png" style="width:27.58em;height:13.08em;" width="1132" height="537"/></div>
<p>A PWM signal controls the ratio of the ON and OFF times</p>
<p>A PWM signal is a digital on/off signal that has different amounts of <strong>ON</strong> time compared to <strong>OFF</strong> time. A motor driven with a 50:50, <kbd>ON:OFF</kbd> signal would drive a motor with half the power of an ON signal at 100 percent, and would therefore run more slowly. Using different ratios, we can drive the motors at different speeds.</p>
<p>We can use the hardware PWM of the Raspberry Pi (GPIO pin 12 can use the PWM driver).</p>
<p>The PWM driver normally provides one of the audio channels of the analog audio output. Sometimes, this generates interference; therefore, it is suggested that you disconnect any devices connected to the analog audio socket.</p>
<p>The hardware PWM function is enabled in <kbd>wiringpi2</kbd> by setting the pin mode to <kbd>2</kbd> (which is the value of <kbd>PWM</kbd>) and specifying the on time (represented as <kbd>ON_TIME</kbd>) as follows:</p>
<pre>PWM_PIN=12; PWM=2; ON_TIME=512  #0-1024 Off-On 
 
  def GPIOsetup(self): 
    wiringpi2.wiringPiSetupPhys() 
    wiringpi2.pinMode(PWM_PIN,PWM) 
    wiringpi2.pwmWrite(PWM_PIN,ON_TIME) 
    for gpio in self.pins: 
      wiringpi2.pinMode(gpio,OUT) </pre>
<p>However, this is only suitable for joint PWM motor control (as it is connected to both ENA and ENB), since there is only the one available hardware PWM output.</p>
<p>Another alternative is to use the software PWM function of <kbd>wiringpi2</kbd>. This creates a crude PWM signal using software; depending on your requirements, this may be acceptable. The code for generating a software PWM signal on GPIO Pin 7 and GPIO Pin 11 is as follows:</p>
<pre>PWM_PIN_ENA=7;PWM_PIN_ENA=11;RANGE=100 #0-100 (100Hz Max) 
ON_TIME1=20; ON_TIME2=75 #0-100 
ON_TIME1=20  #0-100 
  def GPIOsetup(self): 
    wiringpi2.wiringPiSetupPhys() 
    wiringpi2.softPwmCreate(PWM_PIN_ENA,ON_TIME1,RANGE) 
    wiringpi2.softPwmCreate(PWM_PIN_ENB,ON_TIME2,RANGE) 
    for gpio in self.pins: 
      wiringpi2.pinMode(gpio,OUT) </pre>
<p>The previous code sets both pins to 100 Hz, with GPIO Pin 7 set to an on time of 2 ms (and an off time of 8 ms) and GPIO Pin 11 set to 7.5 ms/2.5 ms.</p>
<p>To adjust the PWM timings, use <kbd>wiringpi2.softPwmWrite(PWM_PIN_ENA,ON_TIME2)</kbd>.</p>
<p>The accuracy of the PWM signal may be interrupted by other system processes, but it can control a small micro servo, even if it's slightly jittery.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using I/O expanders</h1>
                
            
            
                
<p>As we saw previously (in <a href="18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml" target="_blank">Chapter 10</a><em>, Sensing and Displaying Real-World Data</em>), <kbd>wiringpi2</kbd> allows us to easily adjust our code to make use of I/O expanders using I<sup>2</sup>C. In this case, it can be useful to add additional circuits, such as sensors and LED status indicators, and perhaps even displays and control buttons, to assist with debugging and controlling the Rover-Pi robot as you develop it.</p>
<p>It can be particularly helpful if you intend to use it as a tethered device, since you will only require three wires to connect back to the Raspberry Pi (I<sup>2</sup>C Data GPIO Pin 3, I<sup>2</sup>C Clock GPIO Pin 5, and Ground GPIO Pin 6), with I<sup>2</sup>C VCC being provided by the motor controller 5V output.</p>
<p>As shown in the earlier example, add defines for the I<sup>2</sup>C address and pin base, as follows:</p>
<pre>IO_ADDR=0x20 
AF_BASE=100 </pre>
<p>Then, in <kbd>gpiosetup()</kbd>, set up the MCP23017 device using the following code:</p>
<pre>wiringpi2.mcp23017Setup(AF_BASE,IO_ADDR) </pre>
<p>Ensure that any pin references you make are numbered 100-115 (to refer to the I/O expander pins A0-7 and B0-7) with <kbd>AF_BASE</kbd> added (which is the pin offset for the I/O expander).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Building a six-legged Pi-Bug robot</h1>
                
            
            
                
<p>Controlling motors is very useful for creating vehicle-like robots, but creating more naturally behaving robot components (such as servos) can provide excellent results. There are many creative designs of insect-like robots, or even biped designs (with humanoid-like legs) that use servos to provide natural joint movements. The design in this example uses three servos, but these principles and concepts can be easily applied to far more complex designs, to control legs/arms that use multiple servos. The Pi-Bug robot is shown in the following photo:</p>
<div><img src="img/ed9160f7-9a28-49f7-aa44-7570e062ab06.png" style="width:32.67em;height:14.33em;" width="771" height="339"/></div>
<p>The six-legged Pi-Bug robot uses a servo driver to control three servos to scuttle around</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need the following hardware:</p>
<ul>
<li><strong>A PWM driver module</strong>: A driver module, such as the Adafruit 16-Channel 12-bit PWM/Servo Driver, will be needed. This uses a PCA9685 device; see the datasheet at <a href="http://www.adafruit.com/datasheets/PCA9685.pdf">http://www.adafruit.com/datasheets/PCA9685.pdf</a> for details.</li>
<li><strong>Three micro servos</strong>: The MG90S 9g Metal Gear Servos provide a reasonable amount of torque at a low cost.</li>
<li><strong>A heavy gauge wire</strong>: This will form the legs; three giant paper clips (76 mm/3 inches) are ideal for this.</li>
<li><strong>A light gauge wire/cable ties</strong>: These will be used to connect the legs to the servos and to mount the servos to the main board.</li>
<li><strong>A small section of plywood or fiberboard</strong>: Holes can be drilled into this, and the servos can be mounted on it.</li>
</ul>
<p>You will need to have <kbd>wiringpi2</kbd> installed to control the PWM module, and it will be useful to install the I<sup>2</sup>C tools for debugging. See <a href="18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml" target="_blank">Chapter 10</a><em>,</em> <em>Sensing and Displaying Real-World Data</em>, for details on how to install <kbd>wiringpi2</kbd> and the I<sup>2</sup>C tools. The I<sup>2</sup>C connections are shown in the following diagram:</p>
<div><img src="img/cbaa7e3f-bce7-4e6e-9416-ea11985823d6.png" style="width:32.75em;height:7.92em;" width="1424" height="348"/></div>
<p>I<sup>2</sup>C connections on the Raspberry Pi GPIO header</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The Pi-Bug robot uses three servos, one on either side and one in the middle. Mount each servo by drilling a hole on either side of the servo body, looping a wire or cable ties through it, and pulling to hold the servo tightly.</p>
<p>Bend the paper clip wire into a suitable shape to form the Pi-Bug robot's legs, and add a small kink that will allow you to wire the legs securely to the servo arms. It is recommended that you run the program first, with the Pi-Bug robot set to the home position <kbd>h</kbd>, before you screw the servo arms in place. This will ensure that the legs are located in the middle.</p>
<p>The following diagram shows the components on the Pi-Bug robot:</p>
<div><img src="img/685df7fb-978b-4972-a039-6687ed5887af.png" style="width:27.92em;height:18.08em;" width="1241" height="804"/></div>
<p>The layout of components on the Pi-Bug robot</p>
<p>Create the following <kbd>servoAdafruit.py</kbd> script to control the servos:</p>
<pre>#!/usr/bin/env python3 
#servoAdafruit.py 
import wiringpi2 
import time 
 
#PWM Registers 
MODE1=0x00 
PRESCALE=0xFE 
LED0_ON_L=0x06 
LED0_ON_H=0x07 
LED0_OFF_L=0x08 
LED0_OFF_H=0x09 
 
PWMHZ=50 
PWMADR=0x40 
 
 
class servo: 
  # Constructor 
  def __init__(self,pwmFreq=PWMHZ,addr=PWMADR): 
    self.i2c = wiringpi2.I2C() 
    self.devPWM=self.i2c.setup(addr) 
    self.GPIOsetup(pwmFreq,addr) 
 
  def GPIOsetup(self,pwmFreq,addr): 
    self.i2c.read(self.devPWM) 
    self.pwmInit(pwmFreq) 
 
  def pwmInit(self,pwmFreq): 
    prescale = 25000000.0 / 4096.0   # 25MHz / 12-bit 
    prescale /= float(pwmFreq) 
    prescale = prescale - 0.5 #-1 then +0.5 to round to 
                              # nearest value 
    prescale = int(prescale) 
    self.i2c.writeReg8(self.devPWM,MODE1,0x00) #RESET 
    mode=self.i2c.read(self.devPWM) 
    self.i2c.writeReg8(self.devPWM,MODE1, 
                       (mode &amp; 0x7F)|0x10) #SLEEP 
    self.i2c.writeReg8(self.devPWM,PRESCALE,prescale) 
    self.i2c.writeReg8(self.devPWM,MODE1,mode) #restore mode 
    time.sleep(0.005) 
    self.i2c.writeReg8(self.devPWM,MODE1,mode|0x80) #restart 
 
  def setPWM(self,channel, on, off): 
    on=int(on) 
    off=int(off) 
    self.i2c.writeReg8(self.devPWM, 
                       LED0_ON_L+4*channel,on &amp; 0xFF) 
    self.i2c.writeReg8(self.devPWM,LED0_ON_H+4*channel,on&gt;&gt;8) 
    self.i2c.writeReg8(self.devPWM, 
                       LED0_OFF_L+4*channel,off &amp; 0xFF) 
    self.i2c.writeReg8(self.devPWM,LED0_OFF_H+4*channel,off&gt;&gt;8) 
 
def main(): 
  servoMin = 205  # Min pulse 1ms 204.8 (50Hz) 
  servoMax = 410  # Max pulse 2ms 409.6 (50Hz) 
  myServo=servo() 
  myServo.setPWM(0,0,servoMin) 
  time.sleep(2) 
  myServo.setPWM(0,0,servoMax) 
   
if __name__=='__main__': 
  try: 
    main() 
  finally: 
    print ("Finish") 
#End </pre>
<p>Create the following <kbd>bug_drive.py</kbd> script to control the Pi-Bug robot:</p>
<pre>#!/usr/bin/env python3 
#bug_drive.py 
import time 
import servoAdafruit as servoCon 
 
servoMin = 205  # Min pulse 1000us 204.8 (50Hz) 
servoMax = 410  # Max pulse 2000us 409.6 (50Hz) 
 
servoL=0; servoM=1; servoR=2 
TILT=10 
MOVE=30 
MID=((servoMax-servoMin)/2)+servoMin 
CW=MID+MOVE; ACW=MID-MOVE 
TR=MID+TILT; TL=MID-TILT 
FWD=[TL,ACW,ACW,TR,CW,CW]#[midL,fwd,fwd,midR,bwd,bwd] 
BWD=[TR,ACW,ACW,TL,CW,CW]#[midR,fwd,fwd,midL,bwd,bwd] 
LEFT=[TR,ACW,CW,TL,CW,ACW]#[midR,fwd,bwd,midL,bwd,fwd] 
RIGHT=[TL,ACW,CW,TR,CW,ACW]#[midL,fwd,bwd,midR,bwd,fwd] 
HOME=[MID,MID,MID,MID,MID,MID] 
PINS=[servoM,servoL,servoR,servoM,servoL,servoR]     
STEP=0.2 
global DEBUG 
DEBUG=False 
 
class motor: 
  # Constructor 
  def __init__(self,pins=PINS,steptime=STEP): 
    self.pins = pins 
    self.steptime=steptime 
    self.theServo=servoCon.servo() 
 
  def off(self): 
    #Home position 
    self.drive(HOME,step) 
 
  def drive(self,drive,step=STEP): 
    for idx,servo in enumerate(self.pins): 
      if(drive[idx]==servoM): 
        time.sleep(step) 
      self.theServo.setPWM(servo,0,drive[idx]) 
      if(drive[idx]==servoM): 
        time.sleep(step) 
      if(DEBUG):print("%s:%s"%(gpio,drive[idx])) 
 
  def cmd(self,char,step=STEP): 
    if char == 'f': 
      self.drive(FWD,step) 
    elif char == 'b': 
      self.drive(BWD,step) 
    elif char == 'r': 
      self.drive(RIGHT,step) 
    elif char == 'l': 
      self.drive(LEFT,step) 
    elif char == 'h': 
      self.drive(HOME,step) 
    elif char == '#': 
      time.sleep(step) 
 
def main(): 
  import os 
  DEBUG=True 
  if "CMD" in os.environ: 
    CMD=os.environ["CMD"] 
    INPUT=False 
    print("CMD="+CMD) 
  else: 
    INPUT=True 
  bugPi=motor() 
  if INPUT: 
    print("Enter CMDs [f,b,r,l,h,#]:") 
    CMD=input() 
  for idx,char in enumerate(CMD.lower()): 
    if(DEBUG):print("Step %s of %s: %s"%(idx+1,len(CMD),char)) 
    bugPi.cmd(char) 
   
if __name__ == '__main__': 
  try: 
    main() 
  except KeyboardInterrupt: 
    print ("Finish") 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We explain the previous script functions by exploring how the servos are controlled using a PWM. Next, we will see how the servo class provides the methods to control the PCA9685 device. Finally, we will look at how the movements of the three servos combine to produce forward and turning motions for the Pi-Bug robot itself.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Controlling the servos</h1>
                
            
            
                
<p>To control the servos used for the Pi-Bug robot, we require a special control signal that will determine the angle that the servo is required to move to. We will send the servo a PWM signal, where the duration of the on time will allow us to control the angle of the servo arm (and thereby, allow us to control the Pi-Bug robot's legs). The following diagram shows how a PWM signal can be used to control the angle of the servo:</p>
<div><img src="img/9a9a4381-b5a5-4511-b506-a25d11c08280.png" style="width:27.33em;height:12.58em;" width="1072" height="493"/></div>
<p>The angle of the servo is controlled by the duration of the up time of the PWM signal</p>
<p>Most servos will have an angular range of approximately 180 degrees and a mid-position of 90 degrees. A PWM frequency of 50 Hz will have a period of 20 ms, and the mid-position of 90 degrees typically corresponds to an <strong>Up Time</strong> of 1.5 ms, with a range of +/- 0.5 ms to 0.4 ms for near 0 degrees and near 180 degrees. Each type of servo will be slightly different, but you should be able to adjust the code to suit if required. The following diagram shows how you can control the servo angle using different PWM Up Times:</p>
<div><img src="img/eb6c51ea-bcd6-4172-bc8e-cbc08088dc50.png" style="width:28.42em;height:12.75em;" width="936" height="420"/></div>
<p>The servo angle is controlled by sending a PWM Up Time between 1 ms and 2 ms</p>
<p>Another type of servo is called a <strong>continuous servo</strong> (not used here). It allows you to control the rotation speed instead of the angle, and will rotate at a constant speed depending on the PWM signal that has been applied. Both servo types have internal feedback loops that will continuously drive the servo until the required angle or speed is reached.</p>
<p>Although it is theoretically possible to generate these signals using software, you will find that any tiny interruption by other processes on the system will interfere with the signal timing; this, in turn, will produce an erratic response from the servo. This is why we use a hardware PWM controller, which only needs to be set with a specific up and down time, to then automatically generate the required signal for us.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The servo class</h1>
                
            
            
                
<p>The servo code is based on the PWM driver that Adafruit uses for their module; however, it is not Python 3 friendly, so we need to create our own version. We will use <kbd>wiringpi2</kbd> I<sup>2</sup>C driver to initialize and control the I<sup>2</sup>C PWM controller. We define the registers that we will need to use (see the datasheet for the PCA9685 device), as well as its default bus address, <kbd>0x40</kbd> (PWMADR), and a PWM frequency of 50 Hz (PWMHZ).</p>
<p>Within our servo class, we initialize the I<sup>2</sup>C driver in <kbd>wiringpi2</kbd> and set up our <kbd>devPWM</kbd> device on the bus. Next, we initialize the PWM device itself (using <kbd>pwmInit()</kbd>). We have to calculate the <strong>prescaler</strong> required for the device to convert the onboard 25 MHz clock to a 50 Hz signal to generate the PWM frequency we need; we will use the following formula:</p>
<div><img src="img/104d3ec4-d744-42af-a7a2-12c2173d007c.png" style="width:16.92em;height:3.92em;" width="715" height="169"/></div>
<p>The prescale register value sets the PWM frequency using a 12-bit value to scale the 25 MHz clock</p>
<p>The prescale value is loaded into the device, and a device reset is triggered to enable it.</p>
<p>Next, we create a function to allow the PWM <kbd>ON</kbd> and <kbd>OFF</kbd> times to be controlled. The <kbd>ON</kbd> and <kbd>OFF</kbd> times are 12-bit values (0-4096), so each value is split into upper and lower bytes (8-bits each) that need to be loaded into two registers. For the <kbd>L</kbd> (low) registers, we mask off the upper 8 bits using <kbd>&amp;0xFF</kbd>, and for the <kbd>H</kbd> (high) registers, we shift down by 8 bits to provide the higher 8 bits. Each PWM channel will have two registers for the on time and two for the off time, so we can multiply the addresses of the first PWM channel registers by 4 and the channel number to get the addresses of any of the others.</p>
<p>To test our <kbd>servo</kbd> class, we define the minimum and maximum ranges of the servos, which we calculate as follows:</p>
<ul>
<li>The PWM frequency of 50 Hz has a 20 ms period (<em>T=1/f</em>)</li>
<li>The ON/OFF times range from 0-4,096 (so 0 ms to 20 ms)</li>
</ul>
<p>Now, we can calculate the control values for 0 degrees (1 ms) and 180 degrees (2 ms)<br/>
as follows:</p>
<ul>
<li>1 ms (servo min) is equal to 4,096/20 ms, which is 204.8</li>
<li>2 ms (servo max) is equal to 4,096/10 ms, which is 409.6</li>
</ul>
<p>We round the values to the nearest whole number.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Learning to walk</h1>
                
            
            
                
<p>The Pi-Bug robot uses a common design that allows three servos to be used to create a small, six-legged robot. The servos at the two ends provide forward and backward movement, while the servo in the middle provides the control. The following photo shows the mounted servos:</p>
<div><img src="img/85460822-6d89-418f-88f8-769d2b59e31b.png" style="width:32.25em;height:19.67em;" width="1000" height="609"/></div>
<p>The servos are mounted upside-down on the underside of the board</p>
<p>The following table assumes that the left and right servos are mounted upside-down on the underside of the board, with the middle servo fitted vertically. You will have to adjust the code if mounted differently.</p>
<p>The following table shows the servo movements used to walk forward:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Direction</strong></p>
</td>
<td>
<p><strong>Middle (servoM)</strong></p>
</td>
<td>
<p><strong>Left (servoL)</strong></p>
</td>
<td>
<p><strong>Right (servoR)</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>home</strong></p>
</td>
<td>
<p><kbd>MID</kbd>/Middle</p>
</td>
<td>
<p><kbd>MID</kbd>/Middle</p>
</td>
<td>
<p><kbd>MID</kbd>/Middle</p>
</td>
</tr>
<tr>
<td>
<p><strong>fwdStep1</strong></p>
</td>
<td>
<p><kbd>TR</kbd>/Right side up</p>
</td>
<td>
<p><kbd>ACW</kbd>/Legs forward</p>
</td>
<td>
<p><kbd>ACW</kbd>/Legs backward</p>
</td>
</tr>
<tr>
<td>
<p><strong>fwdStep2</strong></p>
</td>
<td>
<p><kbd>TL</kbd>/Left side up</p>
</td>
<td>
<p><kbd>CW</kbd>/Legs backward</p>
</td>
<td>
<p><kbd>CW</kbd>/Legs forward</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The following diagram shows how the movement makes the Pi-Bug robot step forward:</p>
<div><img src="img/f9edd774-480d-49bf-86ca-5eda4224fddd.png" style="width:37.17em;height:16.42em;" width="909" height="403"/></div>
<p>The Pi-Bug robot moving forward</p>
<p>While it may seem a little confusing at first, when you see the robot moving, it should make more sense.</p>
<p>For the first forward step, we move the middle servo (<kbd>servoM</kbd>) clockwise so that the left side of the Pi-Bug robot is lifted off the ground by the movement of the remaining middle leg. We can then move the left servo (<kbd>servoL</kbd>) to move the legs on the left side forward (ready for movement later; they are not touching the ground at this point). Now, by moving the right servo (<kbd>servoR</kbd>), we can move the legs on the right backwards (allowing the Pi-Bug robot to be pushed forward on that side).</p>
<p>The second forward step is the same, except that we use the middle servo (<kbd>servoM</kbd>) to lift the right side off the ground. Again, we move the legs that are off the ground forward (ready for next time) and then move the legs on the other side backward (allowing that side of the Pi-Bug robot to move forward). By repeating the forward steps, the Pi-Bug robot will move forward; or, by swapping the sides that are being lifted up by the middle servo (<kbd>servoM</kbd>), it will move backward. The result is a rather bug-like scuttle!</p>
<p>To make the Pi-Bug robot turn, we perform a similar action, except that just like the advanced motor control for the Rover-Pi robot, we move one side of the robot forward and the other side backward. The following table shows the servo movements used to turn right:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Direction</strong></p>
</td>
<td>
<p><strong>Middle (servoM)</strong></p>
</td>
<td>
<p><strong>Left (servoL)</strong></p>
</td>
<td>
<p><strong>Right (servoR)</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>home</strong></p>
</td>
<td>
<p><kbd>MID</kbd>/Middle</p>
</td>
<td>
<p><kbd>MID</kbd>/Middle</p>
</td>
<td>
<p><kbd>MID</kbd>/Middle</p>
</td>
</tr>
<tr>
<td>
<p><strong>rightStep1</strong></p>
</td>
<td>
<p><kbd>TL</kbd>/Left side up</p>
</td>
<td>
<p><kbd>CW</kbd>/Legs backward</p>
</td>
<td>
<p><kbd>ACW</kbd>/Legs backward</p>
</td>
</tr>
<tr>
<td>
<p><strong>rightStep2</strong></p>
</td>
<td>
<p><kbd>TR</kbd>/Right side up</p>
</td>
<td>
<p><kbd>ACW</kbd>/Legs forward</p>
</td>
<td>
<p><kbd>CW</kbd>/Legs forward</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The steps to turn the Pi-Bug robot to the right are shown in the following diagram:</p>
<div><img src="img/a64bb9a8-0b80-4333-a2d9-2badd060b548.png" style="width:35.25em;height:16.33em;" width="1570" height="729"/></div>
<p>The Pi-Bug robot making a right turn</p>
<p>To turn right, we lift the left side of the Pi-Bug robot off the ground, but this time, we move the legs on both sides backward. This allows the right side of the Pi-Bug robot to move forward. The second half of the step lifts the right side off the ground, and we move the legs forward (which will push the left side of the Pi-Bug robot backward). In this manner, the bug will turn as it steps; again, just by swapping the sides that are being lifted, we can change the direction that the Pi-Bug robot will turn in.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The Pi-Bug code for walking</h1>
                
            
            
                
<p>The code for the Pi-Bug robot has been designed to provide the same interface as the Rover-Pi robot so that they can be interchanged easily. You should notice that each class consists of the same four functions (<kbd>__init__()</kbd>, <kbd>off()</kbd>, <kbd>drive()</kbd>, and <kbd>cmd()</kbd>). The <kbd>__init__()</kbd> function defines the set of pins we will control, the <kbd>steptime</kbd> value of the walking action (this time, the gap between movements), and the previously defined servo module.</p>
<p>Once again, we have an <kbd>off()</kbd> function that provides a function that can be called to set the servos in their middle positions (which is very useful for when you need to fit the legs in position, as described previously in the home position). The <kbd>off()</kbd> function uses the <kbd>drive()</kbd> function to set each servo to the <kbd>MID</kbd> position. The <kbd>MID</kbd> value is halfway between <kbd>servoMin</kbd> and <kbd>servoMax</kbd> (1.5 ms to give a position of 90 degrees).</p>
<p>The <kbd>drive()</kbd> function is just like the previous motor control version; it cycles through each of the actions required for each servo, as defined in the various movement patterns (<kbd>FWD</kbd>, <kbd>BWD</kbd>, <kbd>LEFT</kbd>, and <kbd>RIGHT</kbd>) we discussed previously. However, to reproduce the required pattern of movement, we cycle through each servo twice, while inserting a small delay whenever we move the middle servo (<kbd>servoM</kbd>). This allows time for the servo to move and provide the necessary tilt to lift the other legs off the ground before allowing them to move.</p>
<p>We define each of the servo commands as a <strong>clockwise</strong> (<strong>CW</strong>) or <strong>anticlockwise/counterclockwise</strong> (<strong>ACW</strong>) movement of the servo arm. Since the servos are mounted upside down, an ACW (CW, if viewed from above) movement of the left servo (<kbd>servoL</kbd>) will bring the legs forwards, while the same direction of movement on the right servo (<kbd>servoR</kbd>) will move the legs backward (which is fwdStep1 in the previous diagram). In this way, each of the patterns can be defined.</p>
<p>Once again, we provide a test function using the following command that allows a list of instructions to either be defined from the command line or directly entered at the prompt:</p>
<pre><strong>sudo CMD=fffll##rr##bb##h python3 bug_drive.py</strong>  </pre>
<p>This includes the addition of <kbd>h</kbd> to return to the <kbd>home</kbd> position, if desired.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Controlling servos directly with ServoBlaster</h1>
                
            
            
                
<p>The previous recipe demonstrated using a dedicated servo controller to handle the control of the servos used by the Pi-Bug. This has the advantage that any disturbances in the processing taking place on the Raspberry Pi do not cause interference with the delicate servo control (since the controller will continue to send the correct signals).</p>
<p>However, the Raspberry Pi is also capable of direct servo control. To achieve this, we will make use of Richard Hurst's ServoBlaster, which is a multiple servo driver.</p>
<p>In this recipe, we will control four servos attached to the MeArm, a simple laser-cut robot arm; however, you can choose to fit servos to whatever device you like:</p>
<div><img src="img/5b56d39c-96aa-4889-b22d-c05a890fe6c0.png" style="width:22.83em;height:27.83em;" width="818" height="1000"/></div>
<p>The MeArm is a simple robot arm powered by four miniature servos</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Most common servos will have three wires and a three pin connector, as follows:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Black/Brown</strong></p>
</td>
<td>
<p><strong>Red</strong></p>
</td>
<td>
<p><strong>Orange/White/Yellow/Blue</strong></p>
</td>
</tr>
<tr>
<td>
<p>Ground</p>
</td>
<td>
<p>Positive supply (typically 5V for small servos)</p>
</td>
<td>
<p>Signal</p>
</td>
</tr>
</tbody>
</table>
<p>While it is usually possible to power the servos directly from the Raspberry Pi 5V pins on the GPIO header, they can draw a significant amount of current when moving. Unless you have a very good power supply, this can cause the Raspberry Pi to reset unexpectedly, risking corrupting the SD card. Therefore, it is recommended that you power them separately; for example, with an additional USB power supply and cable connected to the ground and positive supply.</p>
<p>By default, the servos can be wired as follows:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Servo</strong></p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>7</p>
</td>
<td>
<p>All GND</p>
</td>
<td>
<p>All Power</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p><strong>Raspberry Pi</strong></p>
<p><strong>GPIO Pin</strong></p>
</td>
<td colspan="9">
<p> </p>
</td>
<td>
<p> </p>
</td>
</tr>
<tr>
<td>
<p>7</p>
</td>
<td>
<p>11</p>
</td>
<td>
<p>12</p>
</td>
<td>
<p>13</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>16</p>
</td>
<td>
<p>19</p>
</td>
<td>
<p>22</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>No Connect</p>
</td>
</tr>
<tr>
<td>
<p><strong>5V Power Supply</strong></p>
</td>
<td colspan="8">
<p> </p>
</td>
<td>
<p>GND</p>
</td>
<td>
<p>+5V</p>
</td>
</tr>
</tbody>
</table>
<p><br/>
We will assume that we are controlling four servos (0, 1, 2, and 3) that will be fitted to the MeArm or a similar device later:</p>
<div><img src="img/70d2d538-68f3-415d-a1a3-98da85d94d5e.jpg" width="100" height="69"/></div>
<p>To install ServoBlaster, start by downloading the source files from the Git repository:</p>
<pre><strong>cd ~</strong>
<strong>wget https://github.com/richardghirst/PiBits/archive/master.zip</strong>  </pre>
<p>Unzip and open the <kbd>matplotlib-master</kbd> folder, as follows:</p>
<pre><strong>unzip master.zip</strong>
<strong>rm master.zip</strong>
<strong>cd PiBits-master/ServoBlaster/user</strong>  </pre>
<p>We will use the user space daemon (which is located in the user directory) that is called <kbd>servod</kbd>. Before we can use it, we should compile it with this command:</p>
<pre><strong>make servod</strong>  </pre>
<p>There should be no errors, showing the following text:</p>
<pre><strong>gcc -Wall -g -O2 -o servod servod.c mailbox.c -lm</strong>  </pre>
<p>For usage information, use the following command:</p>
<pre><strong>./servod --help</strong>  </pre>
<p>Now we can test a servo; first, start the <kbd>servod</kbd> daemon (with a timeout of 2,000 ms to switch the servo off after it has moved):</p>
<pre><strong>sudo servod --idle-timeout=2000</strong>  </pre>
<p>You can move the servo's position to 0% of the servo's range:</p>
<pre><strong>echo 0=0% &gt; /dev/servoblaster</strong>  </pre>
<p>Now, update the servo to 50%, causing the servo to rotate to 90 degrees (servo mid-point):</p>
<pre><strong>echo 0=50% &gt; /dev/servoblaster</strong>  </pre>
<p>As recommended by the MeArm build instructions, the servos should be connected and calibrated before building the arm, to ensure that each servo is able to move the arm in its correct range. This is done by ensuring that each servo is powered up and commanded to its mid-point position (50%/90 degrees), and the servo-arm is fitted at the expected orientation:</p>
<div><img src="img/a72d289d-55cb-4a78-b14c-5ebf7f2e81f0.png" style="width:36.58em;height:9.25em;" width="1260" height="318"/></div>
<p>Each of the servos should be calibrated in the correct position before you fit them on the MeArm</p>
<p>You can now set each of the MeArm servos (0, 1, 2, and 3) to their mid-points (by commanding each, in turn, to 50%) before building and fitting them to a completed arm.</p>
<p>The servos could be used to control a wide range of alternative devices other than the MeArm, but your servos will probably need to be calibrated in a similar manner:</p>
<div><img src="img/234797d3-42ad-4871-b5b1-69bbaa211114.png" style="width:20.83em;height:24.83em;" width="1000" height="1190"/></div>
<p>The precision control of servos means they can be used for a variety of applications, for example, controlling simulated hands</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the following <kbd>servo_control.py</kbd> script:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/env python3 
#servo_control.py 
import curses 
import os 
#HARDWARE SETUP 
# GPIO    
# 2[=VX==2=======]26[=======]40 
# 1[===013=======]25[=======]39 
# V=5V X=Gnd 
# Servo 0=Turn 1=Shoulder 2=Elbow 3=Claw 
name=["Turn","Shoulder","Elbow","Claw"] 
CAL=[90,90,90,90] 
MIN=[0,60,40,60]; MAX=[180,165,180,180] 
POS=list(CAL) 
KEY_CMD=[ord('c'),ord('x')] 
#Keys to rotate counter-clockwise 
KEY_LESS={ord('d'):0,ord('s'):1,ord('j'):2,ord('k'):3} 
#Keys to rotate clockwise 
KEY_MORE={ord('a'):0,ord('w'):1,ord('l'):2,ord('i'):3} 
 
STEP=5; LESS=-STEP; MORE=STEP #Define control steps 
DEG2MS=1.5/180.0; OFFSET=1 #mseconds 
IDLE=2000 #Timeout servo after command 
SERVOD="/home/pi/PiBits-mater/ServoBlaster/user/servod" #Location of servod 
DEBUG=True 
text="Use a-d, w-s, j-l and i-k to control the MeArm. c=Cal x=eXit" 
 
def initialize(): 
  cmd=("sudo %s --idle-timeout=%s"%(SERVOD, IDLE)) 
  os.system(cmd) 
 
def limitServo(servo,value): 
  global text 
  if value &gt; MAX[servo]: 
    text=("Max %s position %s:%s"%(name[servo],servo,POS[servo])) 
    return MAX[servo] 
  elif value &lt; MIN[servo]: 
    text=("Min %s position %s:%s"%(name[servo],servo,POS[servo])) 
    return MIN[servo] 
  else: 
    return value 
 
def updateServo(servo,change): 
  global text 
  POS[servo]=limitServo(servo,POS[servo]+change) 
  setServo(servo,POS[servo]) 
  text=str(POS) 
 
def setServo(servo,position): 
  ms=OFFSET+(position*DEG2MS) 
  os.system("echo %d=%dus &gt; /dev/servoblaster" %(servo, ms/1000)) 
 
def calibrate(): 
  global text 
  text="Calibrate 90deg" 
  for i,value in enumerate(CAL): 
    POS[i]=value 
    setServo(i,value) 
 
def main(term): 
  term.nodelay(1) 
  term.addstr(text) 
  term.refresh() 
  while True: 
    term.move(1,0) 
    c = term.getch() 
    if c != -1: 
      if c in KEY_MORE: 
        updateServo(KEY_MORE[c],MORE) 
      elif c in KEY_LESS: 
        updateServo(KEY_LESS[c],LESS) 
      elif c in KEY_CMD: 
        if c == ord('c'): 
          calibrate() 
        elif c == ord('x'): 
          exit() 
      if DEBUG:term.addstr(text+"   ") 
 
if __name__=='__main__': 
  initialize() 
  curses.wrapper(main) 
#End </pre>
<ol start="2">
<li>Run the script:</li>
</ol>
<pre style="padding-left: 60px"><strong>python3 servo_control.py</strong>
  </pre>
<ol start="3">
<li>You can control the servos fitted to the MeArm (or whatever you are using) as prompted:</li>
</ol>
<pre style="padding-left: 60px">Use a-d, w-s, j-l and i-k to control the MeArm. c=Cal x=eXit </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The script starts by importing the <kbd>curses</kbd> and <kbd>os</kbd> modules. A standard Python <kbd>input()</kbd> command would require the <em>Enter</em> key to be pressed after each key press before we could act upon it. However, as we will see shortly, the <kbd>curses</kbd> module simply allows us to scan for keyboard presses and respond to them immediately. We use the <kbd>os</kbd> module to call the ServoBlaster commands, as we would via the Terminal.</p>
<p>First, we define our setup, such as the servo mappings, calibration positions, min/max ranges, our control keys, and the <kbd>STEP</kbd> size in degrees for each control command. We also define our parameters for our requested angle (in degrees) to target PWM signal up time (in milliseconds) calculation.</p>
<p>For these particular servos, an up time of 1 ms is equal to 0 degrees and 2.5 ms is 180 degrees, so we have an offset (<kbd>OFFSET</kbd>) of 1 ms and a scale (<kbd>DEG2MS</kbd>) of 180 degrees/1.5 ms.</p>
<p>Therefore, our required up time (in milliseconds) can be calculated as <em>OFFSET + (degrees*DEG2MS)</em>. Finally, we define the <kbd>SERVOD</kbd> command line and servo <kbd>IDLE</kbd> timeout to initialize the ServoBlaster user daemon. Within <kbd>initialize ()</kbd>, we use <kbd>os.system()</kbd> to start the <kbd>servod</kbd> daemon, as we did before.</p>
<p>In order to detect key presses, we call the <kbd>main()</kbd> function of the script from <kbd>curses.wrapper()</kbd>, allowing <kbd>term</kbd> to control the terminal input and output. We use <kbd>term.nodelay(1)</kbd> so that when we do check for any key presses (using <kbd>term.getch()</kbd>), execution will continue normally. We use <kbd>term.addstr(text)</kbd> to show the user the control keys and then update the display via <kbd>term.refresh()</kbd>. The remaining script checks the terminal for key presses and the result assigned to <kbd>c</kbd>. If no key was pressed, then <kbd>term.getch()</kbd> returns <kbd>-1</kbd>; otherwise, the ASCII equivalent value is returned, and we can check for it in each of the dictionaries we defined for control keys. We will use <kbd>KEY_MORE</kbd> and <kbd>KEY_LESS</kbd> to change the servo positions, and <kbd>KEY_CMD</kbd> (<kbd>c</kbd> or <kbd>x</kbd>) to allow us to set all the servos to their calibrated position or to exit cleanly. Finally, we display any useful debugging information (if <kbd>DEBUG</kbd> is set to <kbd>True</kbd>) using <kbd>term.addstr()</kbd>, and ensure that it is displayed at (1,0) in the terminal (one line down from the top).</p>
<p>For normal control, the position of the servos will be controlled using the <kbd>updateServo()</kbd> function, which adjusts the current position (stored in the POS array) by the required change (either <kbd>+STEP</kbd> or <kbd>-STEP</kbd>). We ensure the new position is within the MAX/MIN limits defined, and report if we've hit them. The servo is then instructed to move to the required position using <kbd>setServo()</kbd>, specifying the needed PWM up time in micro seconds.</p>
<p>The last function, <kbd>calibrate()</kbd>, called when <em>C</em> is pressed, simply sets each of the servos to the angle defined in the <kbd>CAL</kbd> array (using <kbd>setServo()</kbd>) and ensures that the current position is kept up to date.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using an infrared remote control with your Raspberry Pi</h1>
                
            
            
                
<p>It is often useful to control robots remotely. An easy way to add additional input is to make<br/>
use of an <strong>infrared</strong> (<strong>IR</strong>) receiver and a standard remote control. Fortunately, the receiver is<br/>
well supported.</p>
<p>We will use a module called <kbd>lirc</kbd> to capture and decode IR signals from a standard<br/>
remote control.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>LIRC supports many types of IR detectors, such as Energenie's PiMote IR board; however, since we only need to receive IR signals, we can use a simple (TSOP38238) IR detector:</p>
<div><img src="img/0bc8bc96-656d-4a9d-914b-e1acf33f9e95.png" style="width:36.33em;height:14.58em;" width="858" height="344"/></div>
<p>The three pins of the TSOP38238 IR receiver can fit directly onto the Raspberry Pi header</p>
<p>Install the following packages using the <kbd>apt-get</kbd> command:</p>
<pre><strong>sudo apt-get install lirc lirc-x</strong>  </pre>
<p>Add the following to <kbd>/boot/config.txt</kbd>. This will enable the driver and define the pin the receiver is fitted on (BCM GPIO24):</p>
<pre><strong>dtoverlay=lirc-rpi,gpio_in_pin=23</strong>  </pre>
<p>Perform a restart of the Raspberry Pi so that the configuration takes effect:</p>
<pre><strong>sudo reboot</strong>  </pre>
<p>We should now find that the IR device is located at <kbd>/dev/lirc0</kbd>. We can observe the output of the receiver if we point a remote control at it and press some buttons after using the following command (use <em>Ctrl</em> + <em>Z</em> to exit):</p>
<pre><strong>mode2 -d /dev/lirco0</strong>    </pre>
<p>The <kbd>lirc0</kbd> resource may report as busy:
<p><kbd>mode2: could not open /dev/lirc0</kbd></p>
<p><kbd>mode2: default_init(): Device or resource busy</kbd></p>
Then we will need to stop the <kbd>lirc</kbd> service:<br/>
<kbd>sudo /etc/init.d/lirc stop</kbd><br/>
<br/>
It will give the following response:<br/>
<kbd>[ ok ] Stopping lirc (via systemctl): lirc.service</kbd><br/>
<br/>
When you are ready, you can start the service again:<br/>
<kbd>sudo /etc/init.d/lirc start</kbd><br/>
<br/>
This will give the following response:<br/>
<kbd>[ ok ] Starting lirc (via systemctl): lirc.service</kbd></p>
<p>You will see output similar to the following (if not, ensure that you have connected the receiver connected to the correct pins on the Raspberry Pi GPIO):</p>
<pre><strong>space 16300</strong>
<strong>pulse 95</strong>
<strong>space 28794</strong>
<strong>pulse 80</strong>
<strong>space 19395</strong>
<strong>pulse 83</strong>
<strong>...etc...</strong> </pre>
<p>Now that we know our device is working, we can configure it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The global LIRC configurations are stored in <kbd>/etc/lirc</kbd>. We are interested in the following files:</p>
<ul>
<li><kbd>hardware.conf</kbd>: Defines where our IR sensor is installed and the overall setting for our sensor.</li>
<li><kbd>lircd.conf</kbd>: The remote control configuration file; this contains the recorded outputs for your remote control's keys and maps them to specific key symbols. You can often obtain pre-recorded files from <a href="http://lirc.sourceforge.net/remotes/" target="_blank">lirc.sourceforge.net/remotes</a>, or you can record a custom one, as shown next.</li>
<li><kbd>lircrc</kbd>: This file provides mapping of each of the key symbols to specific commands or keyboard mappings.</li>
</ul>
<p>All of the LIRC configurations stored in <kbd>/etc/lirc</kbd> are available for all users; however, if required, different configurations can be defined for each user by placing them in specific home folders (for example, <kbd>/home/pi/.config/</kbd>), allowing the defaults to be overridden.</p>
<p>There are three steps to setting up the sensor, one for each of the LIRC configuration files:</p>
<ol>
<li>First, ensure that <kbd>hardware.conf</kbd> is set up. For our sensor, we must ensure that the following is set:</li>
</ol>
<pre style="padding-left: 60px">LIRCD_ARGS="--uinput" 
DRIVER="default" 
DEVICE="/dev/lirc0" 
MODULES="lirc_rpi" </pre>
<ol start="2">
<li>Next, obtain a <kbd>lircd.conf</kbd> file; or, if you do not have one for your remote, we can generate it. The following process will now take you through detecting each of the individual keys on the remote. For the purpose of this recipe, we only need to map eight keys (to control the four servos from the previous recipe).</li>
</ol>
<p> </p>
<ol start="3">
<li>If you want map additional keys, use the following command to find out the full list of valid key symbols:</li>
</ol>
<pre style="padding-left: 60px"><strong>irrecord --list-namespace</strong>  </pre>
<table class="table">
<tbody>
<tr>
<td>
<p><kbd>KEY_UP</kbd></p>
</td>
<td>
<p><kbd>KEY_RIGHT</kbd></p>
</td>
<td>
<p><kbd>KEY_VOLUMEUP</kbd></p>
</td>
<td>
<p><kbd>KEY_CHANNELUP</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>KEY_DOWN</kbd></p>
</td>
<td>
<p><kbd>KEY_LEFT</kbd></p>
</td>
<td>
<p><kbd>KEY_VOLUMEDOWN</kbd></p>
</td>
<td>
<p><kbd>KEY_CHANNELDOWN</kbd></p>
</td>
</tr>
</tbody>
</table>
<div><img src="img/c9c935d6-a742-43f6-b81e-875aa5beef9e.png" style="width:22.00em;height:21.08em;" width="1000" height="960"/></div>
<p>We can use the volume, channel, and direction buttons on this Goodman's remote as our MeArm controller</p>
<p>First, we will need to stop the <kbd>lirc</kbd> service, which, if it was running, would be using the <kbd>/dev/lirc0</kbd> device:</p>
<pre><strong>sudo /etc/init.d/lirc stop</strong>  </pre>
<p>Next, start the capture process using the following commands:</p>
<pre><strong>irrecord -d /dev/lirc0 ~/lircd.conf</strong>  </pre>
<div><img src="img/783e39cf-b484-4d0a-949d-287aa984310b.png" style="width:39.92em;height:31.17em;" width="749" height="585"/></div>
<p>Record each button on the remote using the irrecord tool</p>
<p>Now that we have captured the required keys, we ensure that the name of the remote is set (by default, it will be set to the name of the <kbd>lirc.conf</kbd> file when the buttons are captured):</p>
<pre><strong>nano ~/lircd.conf</strong>  </pre>
<p>Set the name of the remote in the file; for example, <kbd>Goodmans</kbd>:</p>
<pre><strong>...</strong>
<strong>begin remote</strong>
  <strong>name  Goodmans</strong>
  <strong>bits           16 </strong>
<strong>...</strong>  </pre>
<p>Finally, we can replace the configuration in the <kbd>/etc/lirc</kbd> folder:</p>
<pre><strong>sudo cp ~/lircd.conf /etc/lirc/lirc.conf</strong>  </pre>
<p>We can confirm the key symbols that are mapped to the remote using the <kbd>irw</kbd> program, as follows:<br/>
<br/>
<kbd>irw</kbd></p>
<p>This will report the details of the key pressed and the remote control as defined:</p>
<pre>0000000000fe7a85 00 KEY_UP Goodmans 
0000000000fe7a85 01 KEY_UP Goodmans 
0000000000fe6a95 00 KEY_DOWN Goodmans 
0000000000fe6a95 01 KEY_DOWN Goodmans 
... </pre>
<p>Now, we can map the keys to specific commands; in this case, we will map them to the keys we used for controlling the MeArm servos. Create a new <kbd>/etc/lirc/lircrc</kbd> file:</p>
<pre><strong>sudo nano /etc/lirc/lircrc</strong>  </pre>
<p>Replace it with the following content:</p>
<pre>begin 
  prog=irxevent 
  button=KEY_UP 
  config=Key w CurrentWindow 
end 
begin 
  prog=irxevent 
  button=KEY_DOWN 
  config=Key s CurrentWindow 
end 
begin 
  prog=irxevent 
  button=KEY_LEFT 
  config=Key a CurrentWindow 
end 
begin 
  prog=irxevent 
  button=KEY_RIGHT 
  config=Key d CurrentWindow 
end 
begin 
  prog=irxevent 
  button=KEY_VOLUMEUP 
  config=Key i CurrentWindow 
end 
begin 
  prog=irxevent 
  button=KEY_VOLUMEDOWN 
  config=Key k CurrentWindow 
end 
begin 
  prog=irxevent 
  button=KEY_CHANNELUP 
  config=Key l CurrentWindow 
end 
begin 
  prog=irxevent 
  button=KEY_CHANNELDOWN 
  config=Key j CurrentWindow 
end </pre>
<p>To apply the configuration, you may need to restart the service (or, if that doesn't work, try restarting the Raspberry Pi):</p>
<pre><strong>sudo /etc/init.d/lirc restart</strong>  </pre>
<p>When we run the <kbd>servo_control.py</kbd> script in the previous recipe, the remote should control the arm directly.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>LIRC supports several helper programs, of which <kbd>irxevent</kbd> is just one:</p>
<table>
<tbody>
<tr>
<td rowspan="2">
<p><kbd>remote</kbd></p>
</td>
<td>
<p>By default, LIRC supports some simple controls; for example:</p>
<p style="padding-left: 30px"><kbd>  prog=remote</kbd></p>
<p style="padding-left: 30px"><kbd>  button=KEY_UP</kbd></p>
<p style="padding-left: 30px"><kbd>  config=UP</kbd></p>
<p>This will provide simple cursor control from a remote (UP, DOWN, LEFT, RIGHT, and also ENTER) that are perfect for simple menu control.</p>
</td>
</tr>
<tr>
<td>
<p><a href="http://www.lirc.org/html/configure.html#lircrc_format">http://www.lirc.org/html/configure.html#lircrc_format</a></p>
</td>
</tr>
<tr>
<td rowspan="2">
<p><kbd>irxevent</kbd></p>
</td>
<td>
<p>Emulates button clicks and key presses within X applications. You can specify that the key event occurs in the <kbd>CurrentWindow</kbd> or in a specific window by name, that is, <kbd>leafpad</kbd>. This only works if you are running from the graphical desktop environment (or using X forwarding).</p>
</td>
</tr>
<tr>
<td>
<p><a href="http://www.lirc.org/html/irxevent.html">http://www.lirc.org/html/irxevent.html</a></p>
</td>
</tr>
<tr>
<td rowspan="2">
<p><kbd>irpty</kbd></p>
</td>
<td>
<p>Converts infrared remote commands into keystrokes for controlling a particular program:</p>
<p style="padding-left: 30px"><kbd>  rog=irpty</kbd></p>
<p style="padding-left: 30px"><kbd>  button=KEY_EXIT</kbd></p>
<p style="padding-left: 30px"><kbd>  config=x</kbd></p>
<p>Start it by specifying the <kbd>lircrc</kbd> configuration and program you want to control:</p>
<p><kbd>irpty /etc/lirc/lircrc -- leafpad</kbd></p>
</td>
</tr>
<tr>
<td>
<p><a href="http://www.lirc.org/html/irpty.html">http://www.lirc.org/html/irpty.html</a></p>
</td>
</tr>
<tr>
<td rowspan="2">
<p><kbd>irexec</kbd></p>
</td>
<td>
<p>Allows commands to be run directly from the remote control:</p>
<p style="padding-left: 30px">  <kbd>prog=irexec</kbd></p>
<p style="padding-left: 30px"><kbd>  button=KEY_POWER</kbd></p>
<p style="padding-left: 30px"><kbd>  config=sudo halt #Power Down</kbd></p>
</td>
</tr>
<tr>
<td>
<p><a href="http://www.lirc.org/html/irexec.html">http://www.lirc.org/html/irexec.html</a></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>You can test any part of the <kbd>lircrc</kbd> file by using <kbd>ircat</kbd> with the required <kbd>prog</kbd>:</p>
<pre><strong>ircat irxevent</strong>  </pre>
<p>The preceding command will report the following:</p>
<pre><strong>Key k CurrentWindow</strong>
<strong>Key i CurrentWindow</strong>  </pre>
<p>Finally, if you have a suitable IR Transmitter LED attached (including a protective resistor/switching transistor), you can also use LIRC to send infrared signals from the Raspberry Pi. For this, you can use the <kbd>irsend</kbd> command, for example:</p>
<pre><strong>irsend SEND_ONCE Goodmans KEY_PROGRAMUP</strong> </pre>
<p>The IR output channel is enabled within the <kbd>/boot/config.txt</kbd> file (assuming connected to GPIO Pin 19):</p>
<pre><strong>dtoverlay=lirc-rpi,gpio_in_pin=24,gpio_out_pin=19</strong>  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Avoiding objects and obstacles</h1>
                
            
            
                
<p>To avoid obstacles, you can place sensors around the robot's perimeter to activate whenever an object is encountered. Depending on how you want your robot to behave, one avoidance strategy is to just reverse any action last taken (with an additional turn for forward/backward actions) that caused one of the sensors to be activated.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need some micro switches to be triggered when there is an impact with objects. Depending on the type you have, you need to place enough switches to detect any object around the outside (if required, you can use an additional length of wire to extend the reach of the switch). Shown in the following photo are two possible sensors that will cause the switch to activate when the spring or the metal arm hits an object. You need to determine which contacts of the switch open or close the circuit (this will depend on the device):</p>
<div><img src="img/6c4ecd33-151e-4c9f-a299-4f13e54fd0b2.png" style="width:27.67em;height:10.00em;" width="1999" height="723"/></div>
<p>Small micro switches can be used as collision sensors</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Connect the switches to the GPIO using a method similar to the one we used in <a href="7cf87b89-8982-4d64-852c-ddfcbf742be5.xhtml" target="_blank">Chapter 9</a><em>, Using Python to Drive Hardware</em>, for the D-Pad controller. A circuit diagram of the switches is as follows:</p>
<div><img src="img/3d949ca7-470c-4300-8e42-02432a483bdc.png" style="width:23.83em;height:28.75em;" width="1000" height="1212"/></div>
<p>The switches should include current limiting resistors (1K ohm is ideal)</p>
<p>How you connect to the Raspberry Pi's GPIO will depend on how your motor/servo drive is wired up. For example, a Rover-Pi robot with an H-bridge motor controller can be wired up as follows:</p>
<table class="table">
<tbody>
<tr>
<td colspan="8">
<p><strong>Control side of the module – connecting to the Raspberry Pi GPIO header</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>ENA</strong></p>
</td>
<td>
<p><strong>IN1</strong></p>
</td>
<td>
<p><strong>IN2</strong></p>
</td>
<td>
<p><strong>IN3</strong></p>
</td>
<td>
<p><strong>IN4</strong></p>
</td>
<td>
<p><strong>ENB</strong></p>
</td>
<td>
<p><strong>GND</strong></p>
</td>
<td>
<p><strong>5V</strong></p>
</td>
</tr>
<tr>
<td>
<p>None</p>
</td>
<td>
<p>Pin 15</p>
</td>
<td>
<p>Pin 16</p>
</td>
<td>
<p>Pin 18</p>
</td>
<td>
<p>Pin 22</p>
</td>
<td>
<p>None</p>
</td>
<td>
<p>Pin 6</p>
</td>
<td>
<p>None</p>
</td>
</tr>
</tbody>
</table>
<p>Four additional proximity/collision sensors can be connected to the Raspberry Pi GPIO<br/>
as follows:</p>
<table class="table">
<tbody>
<tr>
<td colspan="8">
<p><strong>Proximity/collision sensors – connecting to the Raspberry Pi GPIO header</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>R_FWD</strong></p>
</td>
<td>
<p><strong>L_FWD</strong></p>
</td>
<td>
<p><strong>R_BWD</strong></p>
</td>
<td>
<p><strong>L_BWD</strong></p>
</td>
<td>
<p><strong>GND</strong></p>
</td>
</tr>
<tr>
<td>
<p>Pin 7</p>
</td>
<td>
<p>Pin 11</p>
</td>
<td>
<p>Pin 12</p>
</td>
<td>
<p>Pin 13</p>
</td>
<td>
<p>Pin 6</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>If you wired it differently, you can adjust the pin numbers within the code, as required. If you require additional pins, then any of the multipurpose pins, such as RS232 RX/TX (pins 8 and 10) or the SPI/I<sup>2</sup>C, can be used as normal GPIO pins, too; just set them as input or output, as normal. Normally, we just avoid using them, as they are often more useful for expansion and other things, so it is sometimes useful to keep them available.</p>
<p>You can even use a single GPIO pin for all your sensors if you are just using the following example code, since the action is the same, regardless of which sensor is triggered. However, by wiring each one separately, you can adjust your strategy based on where the obstacle is around the robot or provide additional debug information about which sensor has been triggered.</p>
<p>Create the following <kbd>avoidance.py</kbd> script:</p>
<pre>#!/usr/bin/env python3 
#avoidance.py 
import rover_drive as drive 
import wiringpi2 
import time 
 
opCmds={'f':'bl','b':'fr','r':'ll','l':'rr','#':'#'} 
PINS=[7,11,12,13]   # PINS=[L_FWD,L_BWD,R_FWD,R_BWD] 
ON=1;OFF=0 
IN=0;OUT=1 
PULL_UP=2;PULL_DOWN=1 
 
class sensor: 
  # Constructor 
  def __init__(self,pins=PINS): 
    self.pins = pins 
    self.GPIOsetup() 
 
  def GPIOsetup(self): 
    wiringpi2.wiringPiSetupPhys() 
    for gpio in self.pins: 
      wiringpi2.pinMode(gpio,IN) 
      wiringpi2.pullUpDnControl(gpio,PULL_UP)     
 
  def checkSensor(self): 
    hit = False 
    for gpio in self.pins: 
      if wiringpi2.digitalRead(gpio)==False: 
        hit = True 
    return hit 
 
def main(): 
  myBot=drive.motor() 
  mySensors=sensor() 
  while(True): 
    print("Enter CMDs [f,b,r,l,#]:") 
    CMD=input() 
    for idx,char in enumerate(CMD.lower()): 
      print("Step %s of %s: %s"%(idx+1,len(CMD),char)) 
      myBot.cmd(char,step=0.01)#small steps 
      hit = mySensors.checkSensor() 
      if hit: 
        print("We hit something on move: %s Go: %s"%(char, 
                                              opCmds[char])) 
        for charcmd in opCmds[char]: 
          myBot.cmd(charcmd,step=0.02)#larger step 
 
if __name__ == '__main__': 
  try: 
    main() 
  except KeyboardInterrupt: 
    print ("Finish") 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We import <kbd>rover_drive</kbd> to control the robot (if we are using a Pi-Bug robot, <kbd>bug_drive</kbd> can be used) and <kbd>wiringpi2</kbd> so that we can use the GPIO to read the sensors (defined as <kbd>PINS</kbd>). We define <kbd>opCmds</kbd>, which uses a Python dictionary to allocate new commands in response to the original command (using <kbd>opCmds[char]</kbd>, where <kbd>char</kbd> is the original command).</p>
<p>We create a new class called <kbd>sensor</kbd> and set up each of the switches as GPIO input (each with an internal pull-ups set). Now, whenever we make a movement (as earlier, from the list of requested commands in the <kbd>main()</kbd> function), we check to see if any of the switches have been triggered (by calling <kbd>mySensor.checkSensor()</kbd>).</p>
<p>If a switch was tripped, we stop the current movement, and then move in the opposite direction. However, if we are moving forward when one of the sensors is triggered, we move backward, and then turn. This allows the robot to gradually turn away from the object that is blocking its path and continue its movement in another direction. Similarly, if we are moving backwards and a sensor is triggered, we move forward, and then turn. By combining simple object avoidance with directional information, the robot can be commanded to navigate around as desired.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are also ways to detect objects that are near the robot without actually making physical contact with them. One such way is to use ultrasonic sensors, commonly used for vehicle reversing/parking sensors.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Ultrasonic reversing sensors</h1>
                
            
            
                
<p>Ultrasonic sensors provide an excellent way to measure the distance of the robot from obstacles (providing a measurement of between 2 cm and 20 cm) and are available at most electrical hobby stores (see the <em>Appendix,</em> <em>Hardware and Software List</em>). The ultrasonic module functions by sending a short burst of ultrasonic pulses and then measures the time it takes for the receiver to detect the echo. The module then produces a pulse on the echo output that is equal to the time measured. This time is equal to the distance traveled divided by the speed of sound (340.29 m/sec or 34,029 cm/s), which is the distance from the sensor to the object and back again. An ultrasonic module is shown in the following photo:</p>
<div><img src="img/5d02e95d-f125-4da5-ab66-252cec0fd22c.png" style="width:24.83em;height:14.83em;" width="802" height="480"/></div>
<p>The HC-SR04 ultrasonic sensor module</p>
<p>The sensor requires 5V to power it; it has an input that will receive the trigger pulse and an output that the echo pulse will be sent on. While the module works with a 3.3V trigger pulse, it responds with a 5V signal on the echo line; so, it requires some extra resistors to protect the Raspberry Pi's GPIO.</p>
<p>The following circuit diagram shows the connection of the sensor output:</p>
<div><img src="img/01c01599-3614-410a-994b-7fb5289a8149.png" style="width:28.67em;height:27.33em;" width="964" height="920"/></div>
<p>The sensor echo output must be connected to the Raspberry Pi via a potential divider</p>
<p>The resistors <strong>R<sub>t</sub></strong> and <strong>R<sub>b</sub></strong> create a potential divider; the aim is to drop the echo voltage from 5V to around 3V (but not less than 2.5V). Use the following equation from <a href="18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml" target="_blank">Chapter 10</a><em>,</em> <em>Sensing and Displaying Real-World Data</em>, to obtain the output voltage:</p>
<div><img src="img/f410e1fe-d1d4-41e6-80a1-babfe64aa7ab.png" style="width:13.83em;height:4.17em;" width="582" height="177"/></div>
<p>The output voltage (Vout) of the potential divider is calculated using this equation</p>
<p>This means that we should aim for an <strong>R<sub>t</sub></strong> to <strong>R<sub>b</sub></strong> ratio of 2:3 to give 3V (and not lower than 1:1, which would give 2.5V); that is, <strong>R<sub>t</sub></strong> equals 2K ohm and <strong>R<sub>b</sub></strong> equals 3K ohm, or 330 ohm and 470 ohm will be fine.</p>
<p>If you have a voltage meter, you can check it (with everything else disconnected). Connect the top of the potential divider to GPIO Pin 2 (5V) and the bottom to GPIO Pin 6 (GND), and measure the voltage from the middle (it should be around 3V).</p>
<p>Create the following <kbd>sonic.py</kbd> script:</p>
<pre>#!/usr/bin/python3 
#sonic.py 
import wiringpi2 
import time 
import datetime 
 
ON=1;OFF=0; IN=0;OUT=1 
TRIGGER=15; ECHO=7 
PULSE=0.00001 #10us pulse 
 
SPEEDOFSOUND=34029 #34029 cm/s 
 
def gpiosetup(): 
  wiringpi2.wiringPiSetupPhys() 
  wiringpi2.pinMode(TRIGGER,OUT) 
  wiringpi2.pinMode(ECHO,IN) 
  wiringpi2.digitalWrite(TRIGGER,OFF) 
  time.sleep(0.5) 
 
def pulse(): 
  wiringpi2.digitalWrite(TRIGGER,ON) 
  time.sleep(PULSE) 
  wiringpi2.digitalWrite(TRIGGER,OFF) 
  starttime=time.time() 
  stop=starttime 
  start=starttime 
  while wiringpi2.digitalRead(ECHO)==0 and start&lt;starttime+2: 
    start=time.time() 
  while wiringpi2.digitalRead(ECHO)==1 and stop&lt;starttime+2: 
    stop=time.time() 
  delta=stop-start 
  print("Start:%f Stop:%f Delta:%f"%(start,stop,delta)) 
  distance=delta*SPEEDOFSOUND 
  return distance/2.0 
   
def main(): 
  global run 
  gpiosetup() 
  while(True): 
    print("Sample") 
    print("Distance:%.1f"%pulse()) 
    time.sleep(2) 
     
if __name__ == '__main__': 
  try: 
    main() 
  except KeyboardInterrupt: 
    print ("Finish") 
#End </pre>
<p>First, we define the <kbd>TRIGGER</kbd> and <kbd>ECHO</kbd> pins, the length of the trigger pulse, and also the speed of sound (340.29 m/s). The <kbd>TRIGGER</kbd> pin is set as an output, and the <kbd>ECHO</kbd> as an input (we will not need a pull-up or pull-down resistor, since the module already has one).</p>
<p>The <kbd>pulse()</kbd> function will send a short trigger pulse (10 microseconds); then it will time the duration of the echo pulse. We then calculate the total distance traveled by dividing the duration by the speed of sound (the distance to the object is just half of this value).</p>
<p>Unfortunately, the sensor can get confused with certain types of objects; it will either detect echoes that bounce off a nearby object before being reflected back, or not pick up narrow items, such as chair legs. However, combined with localized collision sensors, the ultrasonic sensor can aid with the general navigation and avoidance of the larger objects.</p>
<p>An improvement to this setup would be to mount the sonic sensor on top of a servo, thereby allowing you to make a sensor sweep of the robot's surroundings. By making multiple sweeps, taking distance measurements, and tracking the angle of the servo, you could build an internal map of the robot's surroundings.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting a sense of direction</h1>
                
            
            
                
<p>In order to navigate your robot around the environment, you will need to keep track of which way your robot is facing. You can estimate the angle that your robot turns at by measuring the angle that it turned at in a fixed time period. For wheeled robots, you can also measure the rotation of each wheel using a rotary encoder (a device that provides a count of the wheel's rotations). However, as you make the robot take multiple turns, the direction the robot is facing becomes more and more uncertain, as differences in the surfaces and the grip of the wheels or legs cause differences in the angles that the robot is turning at.</p>
<p>Fortunately, we can use an electronic version of a compass; it allows us to determine the direction that the robot is facing by providing an angle from magnetic north. If we know which direction the robot is facing, we can receive commands requesting a particular angle and ensure that the robot moves towards it. This allows the robot to perform controlled movements and navigate as required.</p>
<p>When given a target angle, we can determine which direction we need to turn towards, until we reach it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need a magnetometer device, such as PiBorg's <strong>XLoBorg</strong> module (which is a<br/>
combined I<sup>2</sup>C magnetometer and accelerometer). In this example, we will only focus on the magnetometer (the smaller chip on the left) output. The XLoBorg module is shown in the following photo:</p>
<div><img src="img/fad81355-fd55-4cb3-986b-220373177798.png" style="width:36.00em;height:15.83em;" width="1000" height="440"/></div>
<p>The PiBorg XLoBorg module contains a three-axis magnetometer and accelerometer</p>
<p>This device can be used with both types of robot, and the angle information received from the module can be used to determine which direction the robot needs to move in.</p>
<p>The module is designed to connect directly to the GPIO header, which will block all the remaining pins. So, in order to use other GPIO devices, a GPIO splitter (such as the PiBorg <strong>TriBorg</strong>) can be used. Alternatively, you can use Dupont female to male patch wires to connect just the I<sup>2</sup>C pins. The connections to be made are shown in the following table:</p>
<div><img src="img/98584627-1d19-42db-a142-07ed4d9f1039.png" style="width:35.33em;height:7.33em;" width="1188" height="251"/></div>
<p>Connections to manually wire the XLoBorg module to the Raspberry Pi (using standard I<sup>2</sup>C connections)</p>
<p>When viewed from the underside, the PiBorg XLoBorg pins are mirrored compared to the Raspberry Pi GPIO header.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create a Python 3-friendly version of the XLoBorg library (<kbd>XLoBorg3.py</kbd>) using <kbd>wiringpi2</kbd>, as follows:</p>
<pre>#!/usr/bin/env python3 
#XLoBorg3.py 
import wiringpi2 
import struct 
import time 
 
def readBlockData(bus,device,register,words): 
  magData=[] 
  for i in range(words): 
    magData.append(bus.readReg16(device,register+i)) 
  return magData 
 
class compass: 
  def __init__(self): 
    addr = 0x0E #compass 
    self.i2c = wiringpi2.I2C() 
    self.devMAG=self.i2c.setup(addr) 
    self.initCompass() 
 
  def initCompass(self): 
    # Acquisition mode 
    register = 0x11   # CTRL_REG2 
    data  = (1 &lt;&lt; 7)  # Reset before each acquisition 
    data |= (1 &lt;&lt; 5)  # Raw mode, do not apply user offsets 
    data |= (0 &lt;&lt; 5)  # Disable reset cycle 
    self.i2c.writeReg8(self.devMAG,register,data) 
    # System operation 
    register = 0x10   # CTRL_REG1 
    data  = (0 &lt;&lt; 5)  # Output data rate 
                      # (10 Hz when paired with 128 oversample) 
    data |= (3 &lt;&lt; 3)  # Oversample of 128 
    data |= (0 &lt;&lt; 2)  # Disable fast read 
    data |= (0 &lt;&lt; 1)  # Continuous measurement 
    data |= (1 &lt;&lt; 0)  # Active mode 
    self.i2c.writeReg8(self.devMAG,register,data) 
 
  def readCompassRaw(self): 
    #x, y, z = readCompassRaw() 
    self.i2c.write(self.devMAG,0x00) 
    [status, xh, xl, yh, yl, 
      zh, zl, who, sm, oxh, oxl, 
      oyh, oyl, ozh, ozl, 
      temp, c1, c2] = readBlockData(self.i2c,self.devMAG, 0, 18) 
    # Convert from unsigned to correctly signed values 
    bytes = struct.pack('BBBBBB', xl, xh, yl, yh, zl, zh) 
    x, y, z = struct.unpack('hhh', bytes) 
    return x, y, z 
 
if __name__ == '__main__': 
  myCompass=compass() 
  try: 
    while True: 
      # Read the MAG Data 
      mx, my, mz = myCompass.readCompassRaw() 
      print ("mX = %+06d, mY = %+06d, mZ = %+06d" % (mx, my, mz)) 
      time.sleep(0.1) 
  except KeyboardInterrupt: 
    print("Finished") 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The script is based on the XLoBorg library available for the XLoBorg module, except that we use WiringPi2, which is Python 3-friendly, to perform the I<sup>2</sup>C actions. Just like our motor/servo drivers, we also define it as a class, so that we can drop it into our code and easily replace it with alternative devices if required.</p>
<p>We import <kbd>wiringpi2</kbd>, <kbd>time</kbd>, and a library called <kbd>struct</kbd> (which allows us to quickly unpack a block of data read from the device into separate items).</p>
<p>We create the <kbd>compass</kbd> class, which will include the <kbd>__init__()</kbd>, <kbd>initCompass()</kbd>, and <kbd>readCompassRaw()</kbd> functions. The <kbd>readCompassRaw()</kbd> function is the equivalent of the standard XLoBorg <kbd>ReadCompassRaw()</kbd> function provided by their library.</p>
<p>The <kbd>__init__()</kbd> function sets up the I<sup>2</sup>C bus with <kbd>wiringpi2</kbd> and registers the <kbd>degMAG</kbd> device on the bus address <kbd>0x0E</kbd>. The <kbd>initCompass()</kbd> function sets the <kbd>CTRL_REG1</kbd> and <kbd>CTRL_REG2</kbd> registers of the device with the settings required to quickly get raw readings from the device.</p>
<p>More details on the MAG3110 registers are available at <a href="http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf">http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf</a>.</p>
<p>The <kbd>readCompassRaw()</kbd> function reads the data registers of the device in a single block (using the custom function <kbd>readBlockData()</kbd>). It reads all of the 18 registers of the device (<kbd>0x00</kbd> through to <kbd>0x11</kbd>). The sensor readings we need are contained within the registers <kbd>0x01</kbd> to <kbd>0x06</kbd>, which contain the <em>x</em>, <em>y</em>, and <em>z</em> readings, split into upper and lower bytes (8-bit values). The <kbd>struct.pack()</kbd> and <kbd>struct.unpack()</kbd> functions provide an easy way to package them together and re-split them as separate words (16-bit values).</p>
<p>We can test our script by creating a <kbd>myCompass</kbd> object from the <kbd>compass</kbd> class and reading the sensor values using <kbd>myCompass.readCompassRaw()</kbd>. You will see the raw <em>x</em>, <em>y</em>, and <em>z</em> values from the device, just as you would from the standard XLoBorg library.</p>
<p>As you will find, these values aren't of much use on their own, since they are uncalibrated<br/>
and only give you RAW readings from the magnetometer. What we need is a far more useful angle, relative to magnetic north (see the following <em>There's more...</em> section for details on how to do this).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>So far, the basic library allows us to see the strength of the magnetic field on each of the three axes around the sensor (up/down, left/right, and forward/backward). While we can see that these values will change as we move the sensor around, this is not enough to steer our robot. First, we need to calibrate the sensor, and then determine the direction of the robot from the readings of the <em>x</em> and <em>y</em> axes.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Calibrating the compass</h1>
                
            
            
                
<p>The compass needs to be calibrated in order to report values that are centered and equalized. This is needed because there are magnetic fields all around; by calibrating the sensor, we can cancel out the effect of any localized fields.</p>
<p>By measuring the readings of the compass on all axes, we can determine the minimum<br/>
and maximum values for each axis. This will allow us to calculate the mid-point of the readings, and also the scaling, so that each axis will read the same value whenever it is facing the same way.</p>
<p>Add the following code at the top of the file (after the <kbd>import</kbd> statements):</p>
<pre>CAL=100 #take CAL samples </pre>
<p>Add the following code to <kbd>__init__(self)</kbd> of the <kbd>compass</kbd> class:</p>
<pre>    self.offset,self.scaling=self.calibrateCompass() 
    if DEBUG:print("offset:%s scaling:%s"%(str(self.offset), 
                                           str(self.scaling))) </pre>
<p>Add a new function named <kbd>calibrateCompass()</kbd> within the <kbd>compass</kbd> class, as follows:</p>
<pre>  def calibrateCompass(self,samples=CAL): 
    MAXS16=32768 
    SCALE=1000.0 
    avg=[0,0,0] 
    min=[MAXS16,MAXS16,MAXS16];max=[-MAXS16,-MAXS16,-MAXS16] 
    print("Rotate sensor around axis (start in 5 sec)") 
    time.sleep(5) 
    for calibrate in range(samples): 
      for idx,value in enumerate(self.readCompassRaw()): 
        avg[idx]+=value 
        avg[idx]/=2 
        if(value&gt;max[idx]): 
          max[idx]=value 
        if(value&lt;min[idx]): 
          min[idx]=value 
      time.sleep(0.1) 
      if DEBUG:print("#%d min=[%+06d,%+06d,%+06d]" 
                     %(calibrate,min[0],min[1],min[2]) 
                     +" avg[%+06d,%+06d,%+06d]" 
                     %(avg[0],avg[1],avg[2]) 
                     +" max=[%+06d,%+06d,%+06d]" 
                     %(max[0],max[1],max[2])) 
    offset=[] 
    scaling=[] 
    for idx, value in enumerate(min): 
      magRange=max[idx]-min[idx] 
      offset.append((magRange/2)+min[idx]) 
      scaling.append(SCALE/magRange) 
    return offset,scaling </pre>
<p>Add another new function named <kbd>readCompass()</kbd> in the <kbd>compass</kbd> class, as follows:</p>
<pre>  def readCompass(self): 
    raw = self.readCompassRaw() 
    if DEBUG:print("mX = %+06d, mY = %+06d, mZ = %+06d" 
                   % (raw[0],raw[1],raw[2])) 
    read=[] 
    for idx,value in enumerate(raw): 
      adj=value-self.offset[idx] 
      read.append(adj*self.scaling[idx]) 
    return read </pre>
<p>If you look closely at the readings (if you use <kbd>readCompass()</kbd>), you will now find that all of the readings have the same range and are centered around the same values.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Calculating the compass bearing</h1>
                
            
            
                
<p>The XLoBorg library only provides access to the RAW values of the MAG3110 device, which provides a measure of how strong the magnetic field on each of the axes is. To determine the direction of the sensor, we can use the readings from the <em>x</em> and <em>y</em> axes (assuming that we have mounted and calibrated the sensor horizontally). The readings of the <em>x</em> and <em>y</em> axes are proportional to the magnetic field in each direction around the sensor, as shown in the following diagram:</p>
<div><img src="img/75844b13-7dc2-475d-8bfb-219ae254be4b.png" style="width:32.42em;height:15.42em;" width="992" height="471"/></div>
<p>The magnetometer measures the strength of the magnetic field on each axis</p>
<p>The angle at which we turned away from the north can be calculated with the formula shown in the following diagram:</p>
<div><img src="img/2b819cd7-6306-41ea-bb1b-a6e88bb69683.png" style="width:26.42em;height:13.75em;" width="1314" height="685"/></div>
<p>The angle we are pointing towards (that is relative to magnetic north) can be calculated using the measurements <em>Rx</em> and <em>Ry</em></p>
<p>We can now obtain the <kbd>compass</kbd> angle by adding the <kbd>readCompassAngle()</kbd> function to our <kbd>compass</kbd> class, as follows:</p>
<pre>  def readCompassAngle(self,cal=True): 
    if cal==True: 
      read = self.readCompass() 
    else: 
      read = self.readCompassRaw() 
    angle = math.atan2 (read[1],read[0]) # cal angle in radians 
    if (angle &lt; 0): 
      angle += (2 * math.pi) # ensure positive 
    angle = (angle * 360)/(2*math.pi); #report in degrees 
    return angle </pre>
<p>We also need to add the following <kbd>import</kbd> with the other <kbd>import</kbd> statements:</p>
<pre>import math </pre>
<p>We use the math function, <kbd>math.atan2()</kbd>, to calculate our angle (<kbd>atan2</kbd> will return with the angle relative to the <em>x</em> axis of the coordinates <kbd>read[1]</kbd> and <kbd>read[2]</kbd> – the angle we want). The angle is in radians, which means that one full turn is defined as 2Pi, rather than 360 degrees. We convert it back to degrees by multiplying it by 360 and dividing by 2Pi. Since we wish to have our angle between the range of 0 to 360 degrees (rather than -180 to 180 degrees), we must ensure that it is positive by adding the equivalent of a full circle (2Pi) to any negative values.</p>
<p>With the sensor calibrated and the angle calculated, we should now have the proper compass bearing to use on our robot. To compare, you can see the result of using the uncalibrated value in our calculation by calling the function with <kbd>readCompassAngle (cal=False)</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Saving the calibration</h1>
                
            
            
                
<p>Having calibrated the sensor once in its current position, it would be inconvenient to have to calibrate it each and every time that you ran the robot. Therefore, you can add the following code to your library to automatically save your calibration and read it from a file the next time you run your robot. To create a new calibration, either delete or rename <kbd>mag.cal</kbd> (which is created in the same folder as your script), or create your <kbd>compass</kbd> object <kbd>compass(newCal=True)</kbd>.</p>
<p>Add the following code near the top of the file (after the <kbd>imports</kbd> statements):</p>
<pre>FILENAME="mag.cal" </pre>
<p>Change <kbd>__init__(self)</kbd> to <kbd>__init__(self,newCal=False)</kbd>.</p>
<p>Also, consider the following line:</p>
<pre>self.offset,self.scaling=self.calibrateCompass() </pre>
<p>Change the previous line to the following line:</p>
<pre>self.offset,self.scaling=self.readCal(newCal) </pre>
<p>Add <kbd>readCal()</kbd> to the <kbd>compass</kbd> class, as follows:</p>
<pre>  def readCal(self,newCal=False,filename=FILENAME): 
    if newCal==False: 
      try: 
        with open(FILENAME,'r') as magCalFile: 
          line=magCalFile.readline() 
          offset=line.split() 
          line=magCalFile.readline() 
          scaling=line.split() 
          if len(offset)==0 or len(scaling)==0: 
            raise ValueError() 
          else: 
            offset=list(map(float, offset)) 
            scaling=list(map(float, scaling)) 
      except (OSError,IOError,TypeError,ValueError) as e: 
        print("No Cal Data") 
        newCal=True 
        pass 
    if newCal==True: 
      print("Perform New Calibration") 
      offset,scaling=self.calibrateCompass() 
      self.writeCal(offset,scaling) 
    return offset,scaling </pre>
<p>Add <kbd>writeCal()</kbd> to the <kbd>compass</kbd> class, as follows:</p>
<pre>  def writeCal(self,offset,scaling): 
      if DEBUG:print("Write Calibration") 
      if DEBUG:print("offset:"+str(offset)) 
      if DEBUG:print("scaling:"+str(scaling)) 
      with open(FILENAME,'w') as magCalFile: 
        for value in offset: 
          magCalFile.write(str(value)+" ") 
        magCalFile.write("n") 
        for value in scaling: 
          magCalFile.write(str(value)+" ") 
        magCalFile.write("n") </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Driving the robot using the compass</h1>
                
            
            
                
<p>Now, all that remains for us to do is use the compass bearing to steer our robot to the desired angle.</p>
<p>Create the following <kbd>compassDrive.py</kbd> script:</p>
<pre>#!/usr/bin/env python3 
#compassDrive.py 
import XLoBorg3 as XLoBorg 
import rover_drive as drive 
import time 
 
MARGIN=10 #turn until within 10degs 
LEFT="l"; RIGHT="r"; DONE="#" 
 
def calDir(target, current, margin=MARGIN): 
  target=target%360 
  current=current%360 
  delta=(target-current)%360 
  print("Target=%f Current=%f Delta=%f"%(target,current,delta)) 
   
  if delta &lt;= margin: 
    CMD=DONE 
  else: 
    if delta&gt;180: 
      CMD=LEFT 
    else: 
      CMD=RIGHT 
  return CMD 
 
def main(): 
  myCompass=XLoBorg.compass() 
  myBot=drive.motor() 
  while(True): 
    print("Enter target angle:") 
    ANGLE=input() 
    try: 
      angleTarget=float(ANGLE) 
      CMD=LEFT 
      while (CMD!=DONE): 
        angleCompass=myCompass.readCompassAngle() 
        CMD=calDir(angleTarget,angleCompass) 
        print("CMD: %s"%CMD) 
        time.sleep(1) 
        myBot.cmd(CMD) 
      print("Angle Reached!") 
    except ValueError: 
      print("Enter valid angle!") 
      pass 
 
if __name__ == '__main__': 
  try: 
    main() 
  except KeyboardInterrupt: 
    print ("Finish") 
#End </pre>
<p>We import the modules that we previously created: <kbd>XLoBorg3</kbd>, <kbd>rover_drive</kbd> (for the Rover-Pi robot, or the alternative <kbd>bug_drive</kbd>, as required), and <kbd>time</kbd>. Next, we create a function that will return <kbd>LEFT</kbd>, <kbd>RIGHT</kbd>, or <kbd>DONE</kbd>, based on the given target angle (requested by the user) and the current angle (read from the <kbd>compass</kbd> class). If the compass angle is within 180 degrees less than the target angle, then we turn <kbd>LEFT</kbd>. Similarly, if it is within 180 degrees, we turn <kbd>RIGHT</kbd>. Finally, if the compass angle is within the margin (+10 degrees/-10 degrees), then we are <kbd>DONE</kbd>. By using <kbd>angle%360</kbd> (which gives us the remainder from dividing the angle by 360), we ensure the angles are all 0-360 (that is, -90 becomes 270).</p>
<p>For the <kbd>main()</kbd> function, we create <kbd>myCompass</kbd> (an <kbd>XLoBorg.compass</kbd> object) and <kbd>myBot</kbd> (a <kbd>drive.motor()</kbd> object); these allow us to determine the direction we are facing in, and provide us with a way to drive in the desired direction. Within the <kbd>main</kbd> loop, we prompt for a target angle, find the current angle that our robot is facing at, and then continue to turn towards the required angle until we reach it (or reach somewhere near enough to that angle).</p>


            

            
        
    </div>



  </body></html>