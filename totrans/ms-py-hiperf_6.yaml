- en: Chapter 6. Generic Optimization Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the never-ending road to mastering optimization, we started by covering
    some tips and tricks in [Chapter 4](ch04.html "Chapter 4. Optimize Everything"),
    *Optimize Everything*. In [Chapter 5](ch05.html "Chapter 5. Multithreading versus
    Multiprocessing"), *Multithreading versus Multiprocessing*, we went over two major
    optimization strategies: multithreading and multiprocessing. We saw how they help
    us and when to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will deal with one of the many implementations of the Python language
    (CPython). This implies that there are other alternatives to CPython. In this
    chapter, we''ll cover two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover PyPy, an alternative to the standard Python interpreter we've been
    using throughout the book. This one is written in Python and has some benefits
    over the standard version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will talk about Cython, an optimizing static compiler, which will allow us
    to write Python code and tap into the power of C and C++ easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both alternatives will provide developers with the opportunity to run code in
    a more optimized fashion, depending, of course, on the characteristics of that
    code. For each option, we'll look into what exactly they are, how to install them,
    and some example code on how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: PyPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like CPython is the standard implementation of the Python specifications
    and is written in C (of course), PyPy is an alternative implementation of Python,
    both for version 2.x and 3.x. It tries to mimic the behavior of the language that
    is written in RPython, a limited version of Python with static types.
  prefs: []
  type: TYPE_NORMAL
- en: The PyPy project ([http://pypy.org/](http://pypy.org/)) is a continuation of
    another, older project called Psycho, which was a JIT compiler for Python, written
    in C. It worked great on 32-bit Intel processors, but it was never updated. Its
    latest stable release was in 2007, so it is now deprecated. PyPy took over in
    2007 with its 1.0 release. Although it was initially considered a research project,
    it grew over the years. Finally, in 2010, version 1.4 was released. With this
    version, there was an increase in confidence that systems written in PyPy were
    production ready and compatible with Python 2.5.
  prefs: []
  type: TYPE_NORMAL
- en: The latest stable version of PyPy, released in June 2014, is version 2.5, which,
    in turn, is compatible with Python 2.7\. There is also a beta release of PyPy3,
    which is, as expected, a version of PyPy that is compatible with Python 3.x.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we will go over PyPy as a viable way of optimization for our scripts
    is due to these features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: One of the main features of PyPy is its speed boost over regular
    Python. This is due to the in-built **Just-in-time** (**JIT**) compiler. It provides
    flexibility over statically compiled code, since it can adapt to the current platform
    (processor type, OS version, and so on) during execution time. On the other hand,
    a statically compiled program would need one executable or every single combination
    of cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory**: Memory-consuming scripts will consume much less memory when executed
    using PyPy than with regular CPython.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sandboxing**: PyPy provides a sandboxing environment where every call to
    an external C library is stubbed. These calls communicate with an external process
    that handles the actual policy. Although this feature is promising, it is still
    only a prototype and needs more work to become useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stackless**: PyPy also provides a somewhat equivalent set of language features
    to the ones provided by Stackless Python ([http://www.stackless.com/](http://www.stackless.com/)).
    Some may even consider it a more powerful and flexible version than the latter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing PyPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to install PyPy into your system:'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the binary files directly from their page ([http://pypy.org/download.html#default-with-a-jit-compiler](http://pypy.org/download.html#default-with-a-jit-compiler)).
    Just make sure you download the right file, according to the OS indication next
    to the link on their website. Otherwise, there is a good chance it won't work
    on your system:![Installing PyPy](img/B02088_06_08.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you''re using a Linux distribution or OS X, you can check whether its official
    package repository contains the PyPy package. Normally, systems such as Ubuntu,
    Debian, Homebrew, MacPorts, Fedora, Gentoo, and Arch tend to have it already.
    For Ubuntu, you can use the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, another option is to download the source code and compile it yourself.
    This might be a harder task than downloading the binaries. However, if done correctly,
    it would assure you that the resulting installation is fully compatible with your
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Be warned though, compiling from source might sound like an easy task, but
    it will take a considerable amount of time. On an i7 with 8 GB of RAM, the entire
    process took about an hour, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Installing PyPy](img/B02088_06_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: A Just-in-time compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is one of the main features provided by PyPy. It's the main reason for
    its superior speed results compared to regular Python (CPython).
  prefs: []
  type: TYPE_NORMAL
- en: According to PyPy's official site, the performance might vary depending on the
    task, but on average, this compiler claims to be seven times faster than CPython.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, with standard compiled programs, we translate the entire source code
    into machine code before we even execute it the first time. Otherwise, we won't
    be able to try it. This is the standard set of steps that normally compiled programs
    go through (preprocessing and translation of the source code, and finally, assembling
    and linking).
  prefs: []
  type: TYPE_NORMAL
- en: 'JIT means that the compilation of our code will take place during execution
    time instead of before it. What normally happens is that the code is translated
    in a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the original source code is translated into an intermediate language.
    For some languages, such as Java, it is called bytecode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After we have the bytecode, we start compiling it and translating it into machine
    code, but only when we need it. One of the peculiarities of JIT compilers is that
    they only compile the code that needs to be run, and not everything at once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step is what differentiates this type of implementation from other
    interpreted languages, such as CPython, when the bytecode is interpreted instead
    of being compiled. Additionally, JIT compilers normally cache compiled code so
    that the next time it is needed, the overhead of compilation will be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this in mind, it is clear that for a program to take real advantage
    of a JIT compiler, it needs to run for at least a few seconds so that the instruction
    caching can take effect. Otherwise, the effect might be the opposite of what is
    intended, since the overhead of the compilation will be the only real-time difference
    that the developer will notice.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of using a JIT compiler is that the program being
    executed is able to optimize the machine code for the specific system it is running
    on (including CPU, OS, and so on). Thus, it provides a level of flexibility that
    is completely out of scope for static compiled (and even interpreted) programs.
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the sandboxing feature of PyPy is still considered as a prototype,
    we'll cover its basics internal workings to understand the potential it provides.
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxing consists of providing a safe environment where untrusted Python code
    can run without any fear of causing harm to the host system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is achieved in PyPy in particular through a two-process model:'
  prefs: []
  type: TYPE_NORMAL
- en: On one side, we have a customized version of PyPy compiled specifically to function
    in the sandbox mode. In particular, this means that any library or system call
    (I/O for instance) gets marshaled into `stdout` waiting for a marshaled response
    back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the other hand, we have a container process, which could be running using
    PyPy or CPython. This process will take care of answering the library and system
    calls from the internal PyPy process:![Sandboxing](img/B02088_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding diagram shows the entire process where a piece of Python code
    that is executed in the sandbox mode is doing an external library call.
  prefs: []
  type: TYPE_NORMAL
- en: The container process is the one that decides what type of virtualization it
    provides. For instance, the inner process could be creating file handlers, which,
    in reality, are being faked by the container process. The process acts as a layer
    between the real OS and the sandboxed process.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the mechanics explained earlier are very different from sandboxing
    at the language level. The entire set of instructions is available to the developer.
    Thus, you achieve a very transparent and secure system with code that could very
    well run on a standard system and on a secured one.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for the JIT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like we already discussed, the JIT from PyPy is what sets it apart from CPython's
    implementation. It is this same feature that makes it so fast when running Python
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Just using PyPy directly on our unchanged Python code, we'll most likely get
    better results. However, we should take into account some guidelines if we want
    to optimize our code even further.
  prefs: []
  type: TYPE_NORMAL
- en: Think of functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JIT works by analyzing which functions are "hotter" (get executed more times)
    than others. Thus, we're better off structuring our code into functions, specifically
    for functions that will be executed repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a quick example. The following code will show the time difference
    between doing the same calculation directly inline versus having it encapsulated
    inside a function and dealing with the added time relating to the function lookup
    and the function call itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code is very simple, but you can still see how the second output shows that
    it is the faster implementation. Regular old CPython will work the opposite way,
    since there is no real-time optimization of the code. The second approach will
    yield slightly worse results because of the overhead of the function lookup and
    function call code. However, PyPy and its JIT prove once again that if you want
    to optimize your code for them, you need to stop thinking the old way.
  prefs: []
  type: TYPE_NORMAL
- en: '![Think of functions](img/B02088_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The results from the preceding screenshot show what we''ve been discussing
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: PyPy runs the same code considerably faster than CPython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JIT is optimizing our code in real time while CPython isn't
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using cStringIO to concatenate strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is not a small optimization, with respect to both code changes and achieved
    optimization. We've already covered the fact that for Python, strings are immutable
    objects. So, if we want to concatenate a large number of strings into a single
    one, we would be better off doing it with another structure instead of the string
    itself, since that would yield the worst performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of PyPy, it still holds true. However, instead of using lists as
    the best option, we'll use the `cStringIO` module ([http://pymotw.com/2/StringIO/](http://pymotw.com/2/StringIO/)),
    which, as we'll see, provides the best results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that because of the nature of PyPy, mentioning `cStringIO` instead of
    `StringIO` might be confusing, since we''re referencing a C standard library instead
    of a pure Python one. This is correct and valid, since some of the C standard
    libraries common to CPython also work correctly on PyPy. In our case, the following
    code will calculate the time needed to perform the same concatenation operation
    in three different ways (using simple strings, using the `cStringIO` library,
    and finally, using lists):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Out of the three alternatives, `StringIO` is the best one in PyPy. It is much
    better than simple string concatenation, and even slightly better than using lists.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the same code through CPython, we will get different results. Thus,
    the best solution is still using lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![Consider using cStringIO to concatenate strings](img/B02088_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot corroborates this. Note how with PyPy, the first approach
    is especially bad performance-wise.
  prefs: []
  type: TYPE_NORMAL
- en: Actions that disable the JIT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although not directly an optimization, there are some specific methods that
    will disable the effectiveness of the JIT if we use them. So, it's important to
    know about these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three methods from the `sys` module disable the JIT (according
    to the current version of PyPy; this could, of course, change in the future):'
  prefs: []
  type: TYPE_NORMAL
- en: '`_getframe`: This method returns a frame object from the `callstack`. It even
    accepts an optional depth parameter that returns frame objects back from the `callstack`.
    The performance penalty is quite big, so its use is recommended only when it is
    absolutely needed, such as when developing a debugger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exc_info`: This method returns a tuple of three elements that provide information
    about the exception being handled. These elements are `type`, `value`, and `traceback`.
    They are explained here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This is the type of the exception being handled'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This gets the exception parameter'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traceback`: This gets the `traceback` object, which encapsulates a `callstack`
    object the moment the exception was thrown'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Settrace`: This method sets the tracing function, which allows you to trace
    Python code from within Python. As mentioned earlier, its use is not recommended
    unless it is absolutely necessary, since it needs to disable the JIT in order
    to work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a final example for this topic, let's take a look at the code from the `great_circle`
    function (explained later). The great circle calculation consists of finding the
    distance between two points on the earth's surface.
  prefs: []
  type: TYPE_NORMAL
- en: The script will do a `for` loop of 5 million iterations. In particular, it calls
    the same function over and over (5 million times to be precise). This scenario
    is less than ideal for the CPython interpreter, since it will complete the function
    lookup that many times.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, on the other hand and as we''ve already mentioned, calling the same
    function over time allows for PyPy''s JIT to start optimizing that call. This
    basically means that in our case, the code is already somewhat optimized for PyPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be further optimized following the same principle we
    just mentioned. We can remove one line from the `great_circle` function into a
    separate function, optimizing that execution even further, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see how we moved the `acos` calculation into a separate function, since
    it was the most expensive line in the entire function (there is a total of six
    trig functions being called there). By moving that line into another function,
    we allowed the JIT to take care of optimizing its calls.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, due to that simple change and the fact that we're using PyPy instead
    of regular Python, we have an execution time of 0.5 seconds. If, on the other
    hand, we were to run that same code using regular CPython, we would get a time
    of 4.5 seconds (on my current machine), which is considerably slower.
  prefs: []
  type: TYPE_NORMAL
- en: Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although technically, Cython ([http://cython.org/](http://cython.org/)) is not
    exactly an alternative to using the standard CPython interpreter, it will let
    us write Python code and compile it into C (something CPython doesn't do).
  prefs: []
  type: TYPE_NORMAL
- en: You'll see that Cython could be considered a transpiler, which simply means
    it's a piece of software meant to translate source code from one language into
    another. There are other similar products out there, such as CoffeeScript and
    Dart. Both are very different languages, and both are translated into JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, Cython translates a super set of Python (an extended version of
    the language) into optimized C/C++ code. Then, it''s compiled into a Python extension
    module. This, in turn, allows the developer to:'
  prefs: []
  type: TYPE_NORMAL
- en: Write Python code that calls back and forth C or C++ code natively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tune Python code into C-level performance using static-type declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static typing is the key feature that allows this transpiler to generate optimized
    C code, thus letting Cython move out of the dynamic nature of Python into a more
    static, yet faster, territory (sometimes, even by several orders of magnitude).
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, makes the Python code more verbose, which, in turn, might hurt
    other aspects such as maintainability and readability. So, normally, using static
    typing is not recommended unless there is some kind of proof that clearly shows
    that adding it will indeed generate a faster running code.
  prefs: []
  type: TYPE_NORMAL
- en: All C types are available for developers to use. Cython is prepared to automatically
    perform type conversion on assignment. In the special case of Python's arbitrary
    long integers, when casting to C's integers, a Python overflow error will be raised
    if an overflow does happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the same example written in pure Python and the Cython
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python version | Cython version |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The main difference in both codes is highlighted. It is only the definition
    of the types of every variable, both the parameters received by both functions,
    and the local variables used. With this alone, Cython can generate an optimized
    C version of the code on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Cython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of ways to install Cython into your system. However, for
    every case, the common requirement is to have a C compiler previously installed.
    We will not go over the steps required for this, because the instructions might
    vary from system to system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the C compiler is installed, in order to get Cython, you can perform these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the latest release from their website ([http://cython.org](http://cython.org)),
    unpack the tarball file, enter the directory, and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have the setup tools installed in your system, you can run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you''re already using one of the following development environments, it''s
    quite likely that Cython is already installed in your system. However, you can
    use the earlier steps to update your current version as well:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Anaconda
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enthought Canopy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PythonXY
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sage
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Cython module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cython is able to compile our code into C modules, which we can later import
    into our main code. In order to do this, you need to carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, a `.pyx` file needs to be compiled (or translated) into a `.c` file by
    Cython. These are the source code files, basically Python code with some extensions
    added by Cython. We'll see some examples in a bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `.c` file will, in turn, be compiled into a `.so` library by the C compiler.
    This library can later be imported by Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are several ways in which we can compile the code, as explained earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can create a `distutils` setup file. Distutils is a module that facilitates
    the creation of other modules, so we can use it to generate our custom C-compiled
    ones.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can run the `cython` command line to create a `.c` file from the `.pyx` one.
    Then, use the C compiler to manually compile the C code into the library.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, another option would be to use the `pyximport` module and import the
    `.pyx` files as if they were `.py` files.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate the preceding points, let''s look at an example using the `distutils`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it! The preceding code that is to be exported should be inside the `.pyx`
    file. The `setup.py` file will normally be the same. It will call the `setup`
    function with different variations of the parameters. Finally, it will call the
    `test.py` file, which imports our compiled library and makes use of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To effectively compile the code, you can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the output from the preceding command. You can
    see how it doesn''t just translate (cythonize) the code, but also compiles the
    library using the C compiler installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Cython module](img/B02088_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding example shows a very simple module. However, normally, for more
    complex cases, a Cython module is comprised of two types of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition files**: These have a `.pxd` extension and contain C declarations
    of names that need to be available to other Cython modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementation files**: These have a `.pyx` extension and contain the actual
    implementation of the functions declared on the `.pxd` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Definition files normally contain C type declarations, external C functions
    or variable declarations, and declarations of C functions defined in the module.
    They cannot contain the implementation of any C or Python function, nor can they
    contain the definition of any `Python` class or any executable lines.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, an implementation file can have almost any kind of Cython
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical two-file module example taken from Cython''s official documentation
    ([http://docs.cython.org/src/userguide/sharing_declarations.html](http://docs.cython.org/src/userguide/sharing_declarations.html));
    it shows how to import `.pxd` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By default, when `cimport` is executed, it will look for a file called `modulename.pxd`
    in the search path. Whenever the definition file changes, each file importing
    it will need to be recompiled. Luckily, for us, the `Cythin.Build.cythonize` utility
    will take care of that.
  prefs: []
  type: TYPE_NORMAL
- en: Calling C functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like regular Python, Cython allows the developer to directly interface
    with C by calling functions compiled in external libraries. To import these libraries,
    the procedure is similar to the standard Python procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `cimport` statement is used in implementation or definition files in order
    to gain access to names declared in other files. Its syntax is exactly the same
    as standard Python's `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you also need to access the definition of some types defined in a library,
    you would need the header file (`.h` file). For these cases, with Cython it is
    not as simple as referencing the file. You''ll also need to redeclare the types
    and structures you will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example performs the following actions for Cython:'
  prefs: []
  type: TYPE_NORMAL
- en: It lets Cython know how to place a `#include` statement in the generated C code,
    referencing the library we're including
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It prevents Cython from generating any C code for the declarations inside the
    block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It treats all declarations inside the block as if they were made with `cdef
    extern`, which, in turn, means those declarations are defined elsewhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this syntax is required because Cython does not, at any moment, read
    the content of the header file. So, you still need to redeclare the content for
    it. As a caveat, you technically only need to redeclare the part that you'll use,
    leaving out anything that's not directly needed by your code. For instance, if
    you had a big structure declared in your header file with a lot of members, you
    could redeclare it with only the members you'd need. This would work since during
    compiling time, the C compiler would use the original code with the full version
    of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Solving naming conflicts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An interesting problem arises when names from the imported functions are the
    same as the ones from your functions.
  prefs: []
  type: TYPE_NORMAL
- en: Say, you have your `myHeader.h` file that defines the `print_with_colors` function,
    and you need to wrap it in some Python function that you also want to call `print_with_colors`;
    Cython provides a way for you to work around this and keep the names as you want
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add `extern` C function declarations into a Cython declaration file
    (`.pxd` file) and then `cimport` it into your Cython code file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also avoid renaming the function and use the name of the declaration
    file as a prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both alternatives are valid, and the decision of using one over the other is
    completely up to the developer. For more information on this subject, head to:
    [http://docs.cython.org/src/userguide/external_C_code.html](http://docs.cython.org/src/userguide/external_C_code.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, Cython allows the developer to define the type of a variable
    or the return type of a function. In both cases, the keyword used for this is
    `cdef`. Typing is actually optional, since Cython will try to optimize the Python
    code by turning it into C. That being said, defining the static types where they're
    needed will certainly help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at a very basic example of a piece of code in Python and how
    the same code executes in its three versions: pure Python, compiled by Cython
    without typing, and finally, compiled and using typing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python | Cython |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the fact that we're declaring the `for` loop variable as a C integer.
    Cython will turn this loop into an optimized C `for` loop, which will be one of
    the major improvements to this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will set up a main file that will import that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will execute our script like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following interesting results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pure Python version | Compiled without typing | Compiled with typing |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0.792 seconds | 0.694 seconds | 0.043 seconds |'
  prefs: []
  type: TYPE_TB
- en: Even though the non-optimized version of the code is faster than the pure Python
    one, we only see the real power of Cython when we start declaring the types.
  prefs: []
  type: TYPE_NORMAL
- en: Defining types during function definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two different types of functions that can be defined in Cython:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard Python functions**: These are normal functions that are exactly
    like the ones declared in pure Python code. To do this, you need the standard
    `cdef` keyword, and these functions will receive Python objects as parameters
    and also return Python objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C functions**: These are the optimized versions of the standard functions.
    They take either Python objects or C values as parameters and can also return
    both. To define these, you need the special `cdef` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either type of function can be called from within a Cython module. However (and
    this is a very important difference), if you want to call your functions from
    within your Python code, you either need to make sure the function is declared
    as standard or you need to use the special `cpdef` keyword. This keyword will
    create a wrapper object for the function. So, when the function is called from
    within Cython, it'll use the C function, and when called from within Python code,
    it'll use the Python version.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with C types for the parameters of the function, an automatic conversion
    will be done (if possible) from the Python object to the C value. This is only
    currently possible for numeric types, `strings`, and `struct` types. If you attempt
    to use any other type, it will result in a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following simple example illustrates the difference between both modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the return type or the type of parameter is left undefined, then it will
    be assumed to be a Python object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, C functions that don't return a Python object have no way to report
    Python exceptions to its caller. So, when an error occurs, a warning message is
    printed and the exception is ignored. This is, of course, far from ideal. Luckily,
    for us, there is a way around this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `except` keyword during function definition. This keyword specifies
    that whenever an exception occurs inside the function, a specific value will be
    returned. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding code, whenever an exception occurs, `-1` will be returned.
    It is important that you don't manually return the exception value from your function.
    This is especially relevant if you define `False` to be your exception value because
    any `False` value will do here.
  prefs: []
  type: TYPE_NORMAL
- en: 'For cases where any possible return value is a valid return value, then there
    is an alternate notation that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `?` sign sets `-1` as a possible exception value. When returned, Cython
    will call `PyErr_Occurred()` to make sure that it is really an error and not just
    a normal return action.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more variation of the `except` keyword, which makes sure to call
    `PyErr_Occurred()` after every return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The only real use of the preceding notation is for functions returning `void`
    that need to propagate errors. This is because in these special cases, there is
    no value to check; otherwise, there is no real use case for it.
  prefs: []
  type: TYPE_NORMAL
- en: A Cython example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the same example we used for PyPy. It shows us
    how to improve the performance of a script. The code will again do the same calculation
    5 million times: from math, import `PI`, `acos`, `cos`, and `sin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will test it by running the function 5,000,000 times with the following
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Again, as I've already mentioned earlier, if we run this script using the time
    command-line utility from Linux with the CPython interpreter, we will see that
    the resulting execution takes around 4.5 seconds to run (in my current system).
    Your numbers will most likely be different.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of going to the profiler, like we did in earlier chapters, we'll go
    directly to Cython now. We'll implement some of the improvements we've been discussing
    into a Cython module that we can import from our test script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our first try at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, all we did was give a C type to all the
    variables and parameters we're using in our code. This alone took the execution
    time from 4.5 seconds down to 3\. We shaved off 1.5 seconds, but we can probably
    do better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code is still using a Python library `math.` Since Cython allows us to
    mix Python and C libraries, it comes in handy when we''re in a hurry. It takes
    care of the conversions for us, but as we can see here, not without a cost. Let''s
    now try to remove the dependency of that Python library and call upon C''s `math.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After removing all references to the math Python library and working directly
    with C's `math.h` file, we went from the 3.5 seconds in our previously optimized
    code to an amazing 0.95 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: When to define a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example might seem obvious and simple to optimize. However, for
    bigger scripts, redeclaring every variable as a C variable and importing all C
    libraries instead of Python ones (whenever possible) is not always the best way
    to go.
  prefs: []
  type: TYPE_NORMAL
- en: Going about it this way will lead to readability and maintainability issues.
    It will also hurt the inherent flexibility of Python code. It could, in fact,
    even end up hurting the performance by adding unnecessary type checks and conversions.
    So, there must be a way to determine the best places to add types and switch libraries.
    This way is using Cython. Cython comes with the ability to annotate your source
    code and show you, very graphically, how each line of code can be translated into
    C code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `-a` attribute in Cython, you can generate an HTML file that will
    highlight your code with yellow. The more yellow a line is, the more C-API interactions
    are required to translate that piece of code into C. White lines (lines without
    any color) are directly translated into C. Let''s look at how our original code
    is rendered under this new tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the HTML file generated from the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When to define a type](img/B02088_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can clearly see that most of our code needs at least a few interactions
    with the C-API in order to be translated into C (only line 4 is completely white).
    It is important to understand that our aim should be to get as many lines to white
    as possible. The lines with a **+** sign indicate that they can be clicked, and
    the C code generated will be displayed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When to define a type](img/B02088_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, by looking at our results, we can see that the lighter yellow lines are
    the simple assignments (lines 5, 7, 8, and 9). They can be easily fixed by doing
    what we initially did: declare those variables as C variables instead of letting
    them be Python objects, which would require us to convert code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing the conversion, we will get something like the next screenshot. This
    screenshot shows the resulting report from analyzing the `great_circle_cy_v1.pyx`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When to define a type](img/B02088_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Much better! Now, those lines are fully white, except line 7, which is still
    light yellow. This is, of course, because that line is actually referencing the
    `math.pi` object. We could fix it simply by initializing the `pi` variable with
    a fixed value of `PI`. However, we still have the big yellow block, that is, lines
    12 and 13\. This is also due to our usage of the `math` library. So, after we
    get rid of it, we will get the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When to define a type](img/B02088_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows the final code we presented earlier. Almost
    all of our code is directly translatable to C, and we got a good performance out
    of it. Now, we still have two yellow lines: 6 and 18.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t do much about line 6 because that function is the Python function
    we need to execute. If we were to declare it with `cdef`, we would not have access
    to it. However, again, line 18 is not completely white. This is because `great_circle`
    is a Python function and the returned value is a Python object, which needs to
    be wrapped and translated into a C value. If we click on it, we can see the generated
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When to define a type](img/B02088_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The only way we can fix this is by declaring our function with `cpdef`, which
    will create a wrapper for it. However, it will also let us declare the return
    type. So, we''re no longer returning a Python object. Instead, we''re returning
    a `double` value, and the resulting code and annotated screenshot is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When to define a type](img/B02088_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see how the C code generated for the returned statement got simplified
    with this latest change. The performance got a small boost as well, since we went
    from 0.95 seconds down to 0.8 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to our analysis of the code, we were able to go one step further and
    optimize it a bit more. This technique is a good way to check your progress when
    optimizing code for Cython. This technique provides a visual and simple indicator
    of the complexity of the optimized code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in this particular case, the results obtained from going the Cython
    route for this optimization are not as good as the ones obtained using PyPy earlier
    in this chapter (0.8 seconds with Cython versus 0.5 seconds with PyPy).
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything we've seen so far seems to indicate that Cython is a perfectly viable
    option to our performance needs. However, the truth is that Cython is not yet
    100 percent compatible with the Python syntax. Sadly, there are some limitations
    that we need to take into consideration before deciding to use this tool for our
    performance enhancement needs. From the current list of public bugs on the project,
    we can gather the list of current limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Generator expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These expressions are currently the ones that suffer the most, since they have
    several issues in the current version of Cython. These issues are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using iterables inside the generator expression causes a problem since there
    are issues with the evaluation scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, related to iterables inside a generator, Cython appears to be evaluating
    them inside the generator's body. On the other hand, CPython does it outside,
    before creating the actual generator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators in Cpython have attributes that allow for introspection. Cython is
    still not fully up to date when it comes to supporting those attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison of char* literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current implementation of Cython performs comparsons of byte literals based
    on the pointers used, instead of the actual value of the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will not always print `True`. It will depend on the pointer
    used to store the first string instead of depending on the actual string value.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples as function arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although only a Python 2 feature, the language allows for the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: However, the preceding code is not even correctly parsed by Cython. This particular
    feature is flagged as probably "not fixable" in the future of Cython, since Python
    3.x has removed it as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the Cython team is expecting to fix most of the limitations mentioned
    earlier by the time they release version 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: Stack frames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, Cython is generating fake tracebacks as part of its exception propagation
    mechanics. They're not filling in `locals` and `co_code` values. In order to do
    this properly, they would have to generate the stack frames on function call time,
    incurring in a potential performance penalty. So, it is unclear whether they will
    fix this in the future or not.
  prefs: []
  type: TYPE_NORMAL
- en: How to choose the right option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we've gone over two different alternatives to radically optimize
    our code. However, how do we know which one is the right one? Or even better,
    which one is the best one?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to both those questions is the same: *there is no single best or
    right one*. Whether one of the options is better or worse depends entirely on
    one or more of these aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: The actual use case you're trying to optimize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The familiarity of the developer with either Python or C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of readability of your optimized code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of time at hand to perform the optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to go with Cython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the situations when you should go with Cython:'
  prefs: []
  type: TYPE_NORMAL
- en: '**You''re familiar with C code**: It''s not like you''ll be coding in C, but
    you will be using principles that are common to C, such as static types, and C
    libraries, such as `math.h`. So, being familiar with the language and its internals
    will definitely be helpful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Losing Python''s readability is not a problem**: The code you''ll write for
    Cython is not fully Python, so part of its readability will be lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full support of the Python language is needed**: Even though Cython is not
    Python, it is more an extension than a subset of the language. So, if you need
    full compatibility with the language, Cython might be the right choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to go with PyPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the situations when you should go with PyPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**You''re not dealing with an execute once script**: PyPy''s JIT optimization
    is great if your script is a long running program, with loops that can be optimized,
    but if instead, the script you''re trying to improve will run once and be done,
    then PyPy is actually slower than the original CPython.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full support of third-party libraries is not required**: Even though PyPy
    is compatible with Python 2.7.x, it is not fully compatible with its external
    libraries, especially if they''re C libraries. So, depending on your code, PyPy
    might not really be an option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You need your code to be compatible with CPython**: If you need your code
    to run for both implementations (PyPy and CPython), then the Cython alternative
    is completely out of the question. PyPy becomes the only option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered two alternatives to the standard Python implementation.
    One is PyPy, which consists of a version of Python and is implemented in RPython.
    It has a JIT compiler in charge of optimizing the code during execution time.
    The other one is Cython, which is basically a transpiler of Python code into C
    code. We saw how each of them worked, how to install them, and how our code needed
    to be changed in order to gain benefits from using them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we went over a few points on how and when to choose one over the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll focus on a very specific use case for Python: number
    crunching. The topic is very common in the Python community, since the language
    is very often used for scientific purposes. We''ll cover three options that will
    help us write code faster: Numba, Parakeet, and pandas.'
  prefs: []
  type: TYPE_NORMAL
