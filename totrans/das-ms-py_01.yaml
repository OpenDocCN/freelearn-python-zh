- en: Python Primer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 入门
- en: 'In this chapter, we will be covering the basic syntax of Python, its built-in
    data structures, functions, classes, its standard library, and the new features
    in the latest versions of Python. If you need to get up to speed on the language,
    this is where we''ll do that. We''ll walk through, step by step, covering the
    following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Python 的基本语法、其内置数据结构、函数、类、其标准库以及 Python 最新版本的新特性。如果您需要快速掌握这门语言，这里就是我们要去的地方。我们将逐步进行，涵盖以下主题：
- en: Python basic syntax and block structure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 基本语法和块结构
- en: Built-in data structures and comprehensions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据结构和推导式
- en: First-class functions and classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首等函数和类
- en: Extensive standard library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富的标准库
- en: What's new in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的新特性
- en: Python basic syntax and block structure
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 基本语法和块结构
- en: This section primarily provides a basic understanding of the Python language
    constructs. If you feel you already have a solid grasp of Python, feel free to
    skip ahead.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要提供对 Python 语言结构的初步理解。如果您觉得自己已经对 Python 有了一个坚实的掌握，请随时跳过。
- en: Let's get down to the nuts and bolts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到细节。
- en: 'A Python program is written as source code in one or more `.py` files and consists
    of statements and expressions as shown in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Python 程序以源代码的形式编写在一个或多个 `.py` 文件中，并包含如下截图所示的语句和表达式：
- en: '![](img/067b6eb4-6fe8-44d3-afea-3b49b2ee5a09.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/067b6eb4-6fe8-44d3-afea-3b49b2ee5a09.jpg)'
- en: Both statements and expressions tell Python to do something. The difference
    is that expressions can be combined to form more complex expressions, while statements
    can be combined with expressions, but not with other statements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 语句和表达式都告诉 Python 做某事。区别在于表达式可以组合成更复杂的表达式，而语句可以与表达式组合，但不能与其他语句组合。
- en: 'For example, a statement looks like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个语句看起来是这样的：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An expression looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表达式看起来是这样的：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python source code files are executed from top to bottom as soon as they're
    loaded by the Python runtime. This means that for simple programs, we could just
    write a series of statements in a `.py` file and then tell Python to run them.
    In the preceding example, the `if` and `else` parts are statements or a single
    statement with two parts, if you prefer to think of it that way. Everything else
    is an expression. For more complex programs, we need a more structured approach.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python 源代码文件在 Python 运行时加载后从上到下执行。这意味着对于简单的程序，我们只需在 `.py` 文件中编写一系列语句，然后告诉 Python
    运行它们。在先前的例子中，`if` 和 `else` 部分是语句或两个部分的单一语句，如果你愿意这样想的话。其余的都是表达式。对于更复杂的程序，我们需要更结构化的方法。
- en: Like most programming languages, Python lets us create functions and classes
    in order to organize our code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言一样，Python 允许我们创建函数和类来组织我们的代码。
- en: If you don't know what functions or classes are, you could think of functions
    as miniature programs that can be used as building blocks for larger programs
    and classes as combinations of functions and data to create new kinds of data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道函数或类是什么，可以将函数视为可以作为更大程序构建块的微型程序，而类则是函数和数据组合以创建新类型数据的组合。
- en: Basic building blocks
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本构建块
- en: 'To organize our code, we can divide it into four basic building blocks. We''ll
    discuss each of these separately for understanding their role and importance in
    the Python code. These are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织我们的代码，我们可以将其分为四个基本构建块。我们将分别讨论这些构建块，以了解它们在 Python 代码中的作用和重要性。以下是这些构建块：
- en: Functions
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Variables
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Expressions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式
- en: Classes
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Functions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'We''ll start with a brief look at functions. Functions are created using a
    `def` statement, which is a statement using the `def` keyword as its identifying
    component. As I said earlier, Python executes the statements in a `.py` file,
    starting from the top, as shown in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简要了解函数开始。函数是通过使用 `def` 语句创建的，这是一个使用 `def` 关键字作为其标识组件的语句。正如我之前所说的，Python
    从 `.py` 文件顶部开始执行语句，如下面的截图所示：
- en: '![](img/5dcdfd70-0e62-4fe1-8fb6-0cf72aab81a5.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dcdfd70-0e62-4fe1-8fb6-0cf72aab81a5.jpg)'
- en: 'When Python executes a `def` statement, it creates a function as a result.
    This means that the code that runs before the `def` statement does not see the
    function because it doesn''t exist yet. The part of the `def` line inside parentheses
    is called the **parameter list**:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 执行一个 `def` 语句时，它创建一个函数作为结果。这意味着在 `def` 语句之前运行的代码看不到该函数，因为它还不存在。`def`
    行中括号内的部分称为**参数列表**：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The parameter list is a list of internal names for data values that are given
    to the function as the input. Outside the function, these values might have different
    names or no names at all, but inside, they'll be stored in these variables.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表是作为输入传递给函数的数据值的内部名称列表。在函数外部，这些值可能具有不同的名称或根本没有名称，但在内部，它们将存储在这些变量中。
- en: 'The indented block of code immediately after the `def` line is called the **function
    body**, and you could think of it as the source code of the function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`def`行之后立即缩进的代码块被称为**函数体**，你可以将其视为函数的源代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows the output of the preceding example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面示例的输出：
- en: '![](img/924168dc-9aa4-40b2-b94f-56974235eb75.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/924168dc-9aa4-40b2-b94f-56974235eb75.jpg)'
- en: The code inside the function body is an exception to the rule about running
    Python code from the top to the bottom of the file. This code is stored away and
    then executed later, when we tell the function to run.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体内的代码是关于从文件顶部到底部运行Python代码的规则的例外。这段代码被存储起来，然后在告诉函数运行时执行。
- en: Like the code in a file, the code in a function runs from top to bottom, one
    statement or expression at a time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件中的代码一样，函数中的代码从上到下逐行或逐个语句或表达式运行。
- en: If you're more familiar with C++ or Java, you may be wondering where the function
    *parameter types* and *return types* are. In Python, the data type is inherent
    in each data value, so the runtime always knows what type of data we're working
    with and whether what we're trying to do is a valid operation for that data type.
    Thus, for the most part, we don't need explicit data types.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更熟悉C++或Java，你可能想知道函数的*参数类型*和*返回类型*在哪里。在Python中，数据类型是每个数据值固有的，因此运行时始终知道我们正在处理哪种类型的数据，以及我们尝试执行的操作是否对该数据类型是有效的操作。因此，在大多数情况下，我们不需要显式的数据类型。
- en: 'Python programmers sometimes talk about *duck typing*, which is a reference
    to the following saying:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员有时会谈论*鸭子类型*，这是对以下说法的引用：
- en: If it quacks like a duck, it's probably a duck.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它像鸭子一样叫，它可能就是一只鸭子。
- en: What they mean by this saying is that if the operations we're trying to perform
    on a data value work, it doesn't really matter if it's precisely the kind of data
    we expected. It's probably close enough. If they don't work, Python will tell
    us what went wrong and where, which is often more useful to know than the kind
    of information that can be determined by comparing data types alone.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 他们所说的意思是，如果我们试图对一个数据值执行的操作是有效的，那么它是否正好是我们预期的数据类型并不重要。它可能足够接近。如果它们不起作用，Python会告诉我们出了什么问题以及在哪里，这通常比仅通过比较数据类型所能确定的信息更有用。
- en: For situations where we want or need to specify data types, we can use function
    annotations and the standard library typing module.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要或需要指定数据类型的情况，我们可以使用函数注解和标准库的`typing`模块。
- en: Function decorators, which we'll discuss in later chapters, can provide a convenient
    way of enforcing these annotations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中讨论的函数装饰器可以提供一种方便的方式来强制执行这些注解。
- en: Variables
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: The second major building block of a Python program is called a **variable**.
    A variable is pretty much just a box for storing a data value. The variable has
    a name and we can use that name to access the data stored in the variable or to
    replace the data with a new value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序的第二大构建块被称为**变量**。变量基本上就是一个用于存储数据值的盒子。变量有一个名称，我们可以使用该名称来访问变量中存储的数据或用新值替换数据。
- en: 'The function parameters in the previous examples were variables, as was `area`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，函数参数是变量，`area`也是如此：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To set the data stored in a variable, we use an *assignment* statement. An assignment
    is a statement, so remember this means that it can't be combined with any other
    statement. It gets a line of source code all for itself and the expressions that
    are part of it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置存储在变量中的数据，我们使用*赋值*语句。赋值是一个语句，所以请记住这意味着它不能与其他任何语句组合。它获得一行源代码，以及它包含的表达式。
- en: 'An assignment statement consists of the variable''s name on the left-hand side
    of an equal to symbol and the value we want to store in the variable on the right-hand
    side, as shown in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句由等号左侧的变量名和右侧我们想要存储在变量中的值组成，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the variable didn't already exist, it will be created. Irrespective of whether
    the variable existed before or not, the value is stored in the variable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量之前不存在，它将被创建。无论变量之前是否存在，值都将存储在变量中。
- en: Variables that are created inside a function are only visible inside that function
    and each time the function runs they're created a new.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部创建的变量只在该函数内部可见，并且每次函数运行时都会创建一个新的。
- en: 'The following code provides an example of this in action:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了一个实际应用的例子：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last line of the preceding example demonstrates that the variable created
    inside the function does not exist for code outside the function, as shown in
    the following output of the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例的最后一条语句表明，在函数内部创建的变量对于函数外部的代码是不存在的，如下面的代码输出所示：
- en: '![](img/4988408e-1651-47ae-b81f-749466233ce3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4988408e-1651-47ae-b81f-749466233ce3.jpg)'
- en: This code example also shows what happens when we try to ask Python to do something
    impossible. It tells us what we did wrong and gives us the information about where
    the problem occurred and how we got there.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例还展示了当我们试图让Python做不可能的事情时会发生什么。它告诉我们我们做错了什么，并提供了有关问题发生位置和如何到达那里的信息。
- en: Expressions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: The third major building block of Python programs is **expressions**. We've
    seen expressions in every example so far because it's nearly impossible to do
    anything in Python without using expressions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序的主要组成部分的第三个是**表达式**。到目前为止，我们在每个例子中都看到了表达式，因为几乎不可能在Python中不使用表达式就做任何事情。
- en: 'Expressions consist of data values and operations to perform on those data
    values. The very simple expressions are a single data value and with no operations,
    for example, a single number. More complex expressions involve at least one operation
    and probably more data values as well, for example, adding two numbers or calculating
    the area, as shown in the following code example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式由数据值和在这些数据值上执行的操作组成。非常简单的表达式是一个单一的数据值，没有任何操作，例如，一个单独的数字。更复杂的表达式至少包含一个操作，可能还有更多的数据值，例如，将两个数字相加或计算面积，如下面的代码示例所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All expressions produce a resulting data value of some sort; for example, adding
    two numbers produces the sum as another number, while concatenating two text strings
    produces the concatenation as another text string. Using a `name` variable to
    look up the stored value is an expression, so is running a function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的表达式都会产生某种类型的结果数据值；例如，将两个数字相加会产生另一个数字作为和，而将两个文本字符串连接起来会产生另一个文本字符串作为连接。使用`name`变量来查找存储的值是一个表达式，运行一个函数也是如此。
- en: If the function doesn't explicitly return a value, the result is a special value
    called **none**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数没有明确返回一个值，结果将是一个特殊值，称为**none**。
- en: Anywhere we need a value, we can use any expression that produces the needed
    value. It doesn't matter whether the expression is a simple number, such as `55`,
    a variable name, a complex combination of values and operators, a function call,
    or any other expression. At least, it doesn't matter as far as the final result
    is concerned. Some expressions take less time to execute than others, so speed
    can be a factor.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们需要值的地方，我们可以使用任何产生所需值的表达式。无论是简单的数字，如`55`，变量名，值的复杂组合和运算符，函数调用，还是任何其他表达式，这都不重要。至少，从最终结果的角度来看，这并不重要。某些表达式比其他表达式执行时间短，所以速度可能是一个因素。
- en: Classes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: The final fundamental building block we're going to discuss in this section
    is **classes**. The word class is a synonym for category or type; in this case,
    it is referring to data values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论的最后一种基本构建块是**类**。类这个词是类别或类型的同义词；在这种情况下，它指的是数据值。
- en: 'A class defines a new kind of data value by describing a set of internal data
    and operations for that type of data value. This is done primarily by defining
    a group of functions that make up the class. A special function called `__init__`
    is used to set up the internal data for a new data value of this type, and the
    rest of the functions define the operations on an existing data value of this
    type:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 类通过描述该类型数据值的内部数据和操作来定义一种新的数据值。这主要是通过定义一组构成类的函数来完成的。一个特殊函数`__init__`用于设置新数据值的内部数据，其余的函数定义了该类型现有数据值的操作：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All the functions of a class receive a parameter called `self`**,** as shown
    in the preceding code example for classes. This parameter is the data value being
    operated on. That's different from C++ or Java because while those languages do
    basically the same thing, the parameter is implicit instead of being an explicit
    part of the function's parameter list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Class functions, including `__init__`, should store and retrieve data from `self`
    when they want to manipulate the data value that they're connected to.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Classes support **inheritance** and **multiple inheritance**, but we won't go
    into that in detail at this point in the book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we created a new data type called `Frood` and then
    made two separate data values of that type. Then, we used the `anniversary` function
    that we created as part of the class to modify each of them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the code example for classes is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/783c34d1-b6f0-4cae-9265-9bf3547af707.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: The two instances maintain their internal variables with different values, as
    shown in the preceding output.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Flow control statements
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has several flow control statements that will be familiar to people
    who know another language in the C family. For example, Python has loops and `if`,
    `elif`, and `else` branches (shown in the following code example):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Python also has a `for` loop statement, but it''s not like the `for` loops
    in C, C++, or Java. Instead of counting through numbers, the `for` loop iterates
    through the values. If we actually want to count through numbers with a `for`
    loop, that''s easily done using a `range` iterator, as shown in the following
    screenshot in the output of the preceding code example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a27e13ed-6d95-4a21-8b95-023b866dd4ee.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Before we wrap-up this section, there's one last thing I should comment on and
    that's Python's views on **indentation** to signify the block structure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most other programming languages have explicit symbols that indicate the beginning
    of a block and the end of a block. However, it''s a common practice in all of
    those languages to indent blocks so that humans find the code easier to read.
    In fact, failure to do so is often taken as a sign that a programmer is an amateur.
    This means that the block structure in most languages is actually represented
    in two different ways: the symbols and the indentation. By incorporating indentation
    into syntax without the need for explicit symbols, Python both removes this duplication
    and ensures that the code is readable.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: With that, we've come to the end of this section. In the next section, we'll
    look at some of Python's built-in data structures and the data processing syntax.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Python's built-in data structures and comprehensions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's take a look at the core data structure types of Python. These aren't
    the only data structures available, of course, because it's fairly easy to create
    data structures using classes. However, these data structures are built right
    into the heart of Python and they're highly efficient, so it's a good idea to
    be very familiar with them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看Python的核心数据结构类型。当然，这些并不是唯一可用的数据结构，因为使用类创建数据结构相对容易。然而，这些数据结构直接构建在Python的核心中，并且效率很高，因此熟悉它们是个好主意。
- en: The first thing to understand is that data structures are themselves data values
    similar to a filing cabinet-they're one thing that contains many things. Like
    any other data value, they can be stored in a variable or used as part of an expression.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要理解的是，数据结构本身也是类似文件柜的数据值——它们是包含许多事物的一个东西。像任何其他数据值一样，它们可以被存储在变量中或用作表达式的一部分。
- en: Dictionaries
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: The first data structure we're going to look at is Python's dictionary. A dictionary
    consists of any number of key-value pairs. The key can be used to get or set the
    value or remove the pair from the dictionary entirely.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的第一个数据结构是Python的字典。字典由任意数量的键值对组成。键可以用来获取或设置值，或者从字典中完全删除这个键值对。
- en: Similar data structures in other languages are sometimes called maps or hash
    tables.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言中的类似数据结构有时被称为映射或哈希表。
- en: 'There are several ways to create a dictionary in Python. The simplest is to
    use a dictionary expression, which is just a pair of curly brackets surrounding
    the key-value pairs we want in the dictionary. Each key-value pair is marked with
    a colon between the key and value, and each pair is separated by a comma, as shown
    in the following code example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建字典有几种方法。最简单的是使用字典表达式，它就是一对花括号，包围着我们想要在字典中包含的键值对。每个键值对由键和值之间的冒号标记，每个键值对由逗号分隔，如下面的代码示例所示：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When this expression runs, the result is a dictionary object containing the
    keys and their values. We can also use the `dict` class to create dictionary objects:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个表达式运行时，结果是包含键及其值的字典对象。我们也可以使用`dict`类来创建字典对象：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we don''t want to use the special syntax to access one of the stored values
    in a dictionary, we use a lookup expression. This means that we place square brackets
    containing the key we want to look up after an expression that gives us the dictionary.
    Usually, this means, the name of the variable containing the dictionary, an open
    square bracket, a sub-expression that gives us the key, and then a closing square
    bracket:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想使用特殊语法来访问字典中存储的某个值，我们可以使用查找表达式。这意味着我们在给出字典的表达式之后放置一对方括号，包含我们想要查找的键。通常情况下，这意味着包含字典的变量的名称，一个开方括号，一个给出键的子表达式，然后是一个闭方括号：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also use the `dict.get` function if we prefer not to use the special
    syntax:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更喜欢不使用特殊语法，我们也可以使用`dict.get`函数：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: List
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'The next data type we''re going to look at is a **list**, which can be created
    with the list expression. A list expression is just a pair of square brackets
    surrounding the data values we want to store in the list, with each value separated
    by a comma. It is not necessary that each of the values be of the same type. The
    code example for a list is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要探讨的数据类型是**列表**，它可以通过列表表达式来创建。列表表达式就是一对方括号，包围着我们想要存储在列表中的数据值，每个值之间用逗号分隔。并不要求每个值必须是同一类型。以下是一个列表的代码示例：
- en: '![](img/25a29cea-8d84-4e12-87ba-d33ffd4dc885.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25a29cea-8d84-4e12-87ba-d33ffd4dc885.jpg)'
- en: In the preceding example, they're strings, but they could be numbers, or a list,
    or any other kind of data mixed together. We can use a lookup expression to retrieve
    data values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，它们是字符串，但它们可以是数字，或者是一个列表，或者任何其他类型的数据混合在一起。我们可以使用查找表达式来检索数据值。
- en: Unlike with a dictionary though, the keys for a list are integers. That's because
    instead of associating key values with data values, a list just stores its data
    values in order. The key for the very first item in the list is `0`. The key for
    the next item is `1`, and so on. We can also use negative integers for the key.
    We still get a data value out, but it's counted from the end of the list instead
    of the beginning, with the item at `-1` being the last item in the list.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `list.append` function to add a new item at the end of the list
    or its `insert` function to add a new item anywhere as shown in the following
    code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3875dba-1cb1-4b47-920e-b9d307709016.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: The list will automatically grow to be large enough to hold all of the data
    we put into it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Tuple
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next data structure we'll look at is the **tuple**. A tuple expression is
    any sequence of value expressions separated by commas if it happens in the place
    where the language wasn't already expecting to see a comma.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s common and smart to put parentheses around most tuple expressions
    because it avoids ambiguity. The code example for tuple is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd6bfea8-97a4-4663-bf58-26bf56e0c024.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Like a list, data values can be retrieved from a tuple using numbers. However,
    we can't add more data to a tuple, and we cannot replace one data value with another.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Why would we want a data structure like that?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, there are several reasons. We can list them as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: First, because they are constant, tuples make good dictionary keys or set members,
    but we'll get to that in a while.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, they fill a different conceptual role than lists. We tend to expect
    every member of a list to be the same type, such as a list of names or a list
    of ages. Lists are sort of like columns of a database in that way. We tend to
    expect tuples to contain different types of data in each element, but we expect
    them to be related to each other, such as a name in the first element and an age
    in the second. To continue our analogy, tuples are something like rows in a database.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, tuples tend to be slightly more efficient for the computer to work with,
    both in terms of time and memory usage. So, in optimization situations, they are
    preferable to lists when they are sufficient for the task.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final data structure we''ll look at is the **set**. A set is a collection
    of data values without keys; like a list, but in no particular order, like a dictionary.
    We can create a set using a set expression, which is a pair of curly brackets
    around comma-separated values, as shown in the following code example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55d3fdd7-9a69-439f-8b40-7b2c1500e436.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: 'Locating a specific value in a set is fast, as is adding or removing a value,
    as shown in the following example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2662ba78-fa47-437c-ae0b-6f2077265660.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Each value can only be in the set once. Sets support a bunch of mathematical
    operations, such as union and intersection, and are generally more useful than
    might be obvious at first, though we can't really prove that here in this section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值只能出现在集合中一次。集合支持一系列数学运算，如并集和交集，并且通常比一开始看起来更有用，尽管我们在这里的章节中无法真正证明这一点。
- en: Comprehension
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推导式
- en: Python has a special kind of expression called a **comprehension**. Comprehensions
    are variations of the special syntax for creating dictionaries, lists, and sets.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一种特殊的表达式，称为**推导式**。推导式是创建字典、列表和集合的特殊语法的变体。
- en: 'Let''s look at some examples. Here we see a list comprehension:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子。这里我们看到一个列表推导式：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What this expression does is that it creates a new list containing the uppercase
    versions of the words in the old list.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的作用是创建一个新列表，包含旧列表中单词的大写版本。
- en: 'The first part after the opening square bracket is an `x.upper()` expression.
    This expression describes how to derive a member of the new list from a member
    of the old list. After that is the `for` keyword, then the name of the `x` variable
    we used in the first expression to represent the values from the old list. Then,
    the keyword is followed by the `example_list` expression that gives us the old
    list and the closing square bracket. The code output is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 开方括号后的第一部分是一个`x.upper()`表达式。这个表达式描述了如何从旧列表的成员推导出新列表的成员。之后是`for`关键字，然后是我们在第一个表达式中使用的`x`变量的名称。然后，关键字后面跟着`example_list`表达式，它给出了旧列表，最后是闭方括号。代码输出如下：
- en: '![](img/5ee9358c-def4-4fc5-b9b1-e2d5e04bc9bf.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ee9358c-def4-4fc5-b9b1-e2d5e04bc9bf.jpg)'
- en: 'The dictionary and set comprehensions are very similar. If we want to use both
    the key and the value of an existing dictionary in a comprehension, we need to
    use the `dict.items` function, and dictionary comprehensions need to specify both
    the key and value separated by a colon, as shown in this example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 字典和集合推导式非常相似。如果我们想在推导式中使用现有字典的键和值，我们需要使用`dict.items`函数，并且字典推导式需要指定键和值，用冒号分隔，如本例所示：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As shown in the following screenshot, notice that the resulting data type depends
    on what sort of comprehension we used, not on what sort of data structure we used
    as the source of data:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，请注意，结果数据类型取决于我们使用了哪种推导式，而不是我们使用了哪种数据结构作为数据源：
- en: '![](img/99820c3d-5e46-48d2-8d4f-260dde7ab93c.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99820c3d-5e46-48d2-8d4f-260dde7ab93c.jpg)'
- en: We can use a list comprehension to create a list of data pulled from the values
    of a dictionary, for example, or, as we did here, we can use the set comprehension
    to create a set.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表推导式从字典的值创建数据列表，例如，或者，就像我们在这里做的那样，我们可以使用集合推导式创建集合。
- en: 'Tuples are slightly different, but only slightly. A tuple comprehension would
    look exactly like a different syntactic element called a **generator expression**.
    The code example for tuple comprehension is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 元组略有不同，但只是略有不同。元组推导式看起来就像一个名为**生成器表达式**的不同语法元素。元组推导式的代码示例如下：
- en: '![](img/08c1aa39-8f1e-46a7-9abf-96adfcd3fc7f.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08c1aa39-8f1e-46a7-9abf-96adfcd3fc7f.jpg)'
- en: Python's designers hate ambiguity; so instead, if we want the equivalent of
    a tuple comprehension, we pass a generator expression to a tuple constructor.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python的设计者讨厌歧义；因此，如果我们想要元组推导式的等效物，我们就将生成器表达式传递给元组构造函数。
- en: That's it for this quick introduction to Python's built-in data structures.
    In the next section, we're going to look at some useful, but possibly surprising,
    traits of functions and classes that are significantly different from C, C++,
    or Java.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本快速介绍Python内置数据结构的全部内容。在下一节中，我们将探讨函数和类的一些有用但可能令人惊讶的特性，这些特性与C、C++或Java有显著不同。
- en: First-class functions and classes
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一等函数和类
- en: In Python, functions and classes are first-class objects. The phrase **first-class
    object** is a fancy way of saying that the data values can be accessed, modified,
    stored, and otherwise manipulated by the program they are a part of. In Python,
    a function is just as much a data value as a text string is. The same goes for
    classes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数和类是一等对象。短语**一等对象**是一种说法，意味着数据值可以被程序访问、修改、存储和在其他方面被操作。在Python中，函数就像文本字符串一样，是一个数据值。类也是如此。
- en: 'When a function definition statement is executed, it stores the resulting function
    in a variable with the name that was specified in the `def` statement, as shown
    in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数定义语句被执行时，它会将生成的函数存储在一个变量中，该变量的名称是在 `def` 语句中指定的，如下面的截图所示：
- en: '![](img/b33d1602-663d-4bd9-933b-a7f1ce1c3d7d.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b33d1602-663d-4bd9-933b-a7f1ce1c3d7d.jpg)'
- en: This variable isn't special; it's just like any other variable holding the value.
    This means that we can use it in expressions, assign the value to other values,
    or even store a different value in place of the original function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量并不特殊；它就像任何其他持有值的变量一样。这意味着我们可以在表达式中使用它，将值赋给其他值，或者甚至用不同的值替换原始函数。
- en: 'The function value itself contains quite a few attribute variables, which we
    can access. More usefully, most of the time, we can add attributes to a `function`
    object, allowing us to store custom information about a function as part of the
    function and access that information later, as shown in the following code example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数值本身包含相当多的属性变量，我们可以访问它们。更有用的情况是，大多数时候，我们可以向 `function` 对象添加属性，这样我们就可以将有关函数的定制信息作为函数的一部分存储，并在以后访问这些信息，如下面的代码示例所示：
- en: '![](img/8cb869f9-a052-405b-ac2a-f69cdf18561c.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cb869f9-a052-405b-ac2a-f69cdf18561c.jpg)'
- en: 'One common task that first-class functions make easy is assigning handlers
    to events. To bind the **handler** function to an event in Python, we just pass
    the `function` object as a parameter when we call the **binding** function, as
    shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首类函数使一个常见任务变得简单，那就是为事件分配处理程序。要在 Python 中将 **handler** 函数绑定到事件，我们只需在调用 **binding**
    函数时将 `function` 对象作为参数传递，如下所示：
- en: '![](img/119f3862-e411-4f9e-9d33-defdf78c7151.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/119f3862-e411-4f9e-9d33-defdf78c7151.jpg)'
- en: That's a significant improvement over the hoops that C++ or Java imposes on
    us to do something similar. As function definition statements, class definition
    statements create a class object and store it in a variable. This can be confusing
    at first. Classes describe the type of object, how can they be objects themselves?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这比 C++ 或 Java 强加给我们的类似操作要灵活得多。作为函数定义语句，类定义语句创建一个类对象并将其存储在一个变量中。这可能会让人一开始感到困惑。类描述了对象的类型，它们怎么能是对象本身呢？
- en: Think of it this way-a blueprint for a house describes the type of building,
    but the blueprint is still a thing in its own, right? It's the same with class
    objects. This means that like function objects, class objects can be stored in
    variables, and otherwise, be treated as data values. Most interestingly, they
    could be used as parameters to function calls.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下——一栋房子的蓝图描述了建筑类型，但蓝图本身仍然是一个东西，对吧？类对象也是这样。这意味着，就像函数对象一样，类对象可以被存储在变量中，并且可以像数据值一样被处理。最有趣的是，它们可以用作函数调用的参数。
- en: The defaultdict class
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`defaultdict` 类'
- en: 'As an example of why that''s interesting, consider this-Python''s standard
    library contains a data structure class called `defaultdict`, which is like a
    dictionary except, when we try to look up a key that isn''t already in the dictionary.
    It creates a new value and adds it to the dictionary, before returning it to the
    code that tried the lookup, as shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为为什么这有趣的例子，考虑一下——Python 的标准库包含一个名为 `defaultdict` 的数据结构类，它就像字典一样，但是当我们尝试查找字典中尚未存在的键时，它会创建一个新的值并将其添加到字典中，然后再将其返回给尝试查找的代码，如下所示：
- en: '![](img/13e6933f-ae86-49da-9b0e-890eb946d6d7.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13e6933f-ae86-49da-9b0e-890eb946d6d7.jpg)'
- en: How does the `defaultdict` class know how to create the default value?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict` 类是如何知道如何创建默认值的？'
- en: The `defaultdict` class knows because we gave it `class` as a parameter when
    we created the `defaultdict` class. Thus, if we want a dictionary of list, we
    can give the `defaultdict` class the list class, as its *how to make a default*
    parameter. As an aside, `defaultdict` can also work with a function, as its *how
    to make a default* parameter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict` 类之所以知道如何操作，是因为我们在创建 `defaultdict` 类时给它传递了 `class` 作为参数。因此，如果我们想要一个列表的字典，我们可以给
    `defaultdict` 类传递列表类，作为其 *如何设置默认值* 参数。顺便提一下，`defaultdict` 也可以与函数一起工作，作为其 *如何设置默认值*
    参数。'
- en: The `defaultdict` class actually doesn't care what that parameter is, as long
    as the object we passed can create a new object whenever the `defaultdict` class
    needs a new default. This is an example of the duck typing we mentioned in the
    previous section. It doesn't matter whether the parameter is a function, a class,
    or anything else, so long as it behaves properly. If it doesn't behave properly,
    we'll be told what went wrong and where.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed a little while ago that we could add attributes to function objects,
    which is often handy. We could do something similar with classes, with one big
    difference- attributes that we add to functions are only visible to the code that
    has access to that function object, which usually doesn't include the code of
    the function itself, but attributes that we add to class objects are visible to
    any code that has access to the class object or to an object of the type described
    by the class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if we add an attribute to a class, the functions defined in
    that class will be able to access that attribute through the `self` parameter,
    as shown in the following code example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80d56e37-df87-4c9f-8d8a-fd99f5a9cfec.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: We need to be careful when adding attributes to classes because if we accidentally
    overwrite one of the class' attributes, we could break the class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: We have a greater ability to manipulate classes than functions. So, we need
    to use that ability more thoughtfully. Also, notice that, in this example, one
    of the attributes we added to the class is a function, which then proceeded to
    work exactly as if it had been defined as a part of the class from the beginning.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a short tour of some of the highlights of Python's standard
    library.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The standard library
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The library of code that comes pre-installed with Python is extensive, so we're
    not going into the details. The goal here is to come away with an understanding
    of the breadth of quality tools we have available, so if we need them in the future
    then we know where to look. Thus, we're going to just briefly touch on many useful
    things. You can find the official documentation on the standard library at [https://docs.python.org/3/library/index.html](https://docs.python.org/3/library/index.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Different types of packages
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The index page contains a list of the different packages available to you in
    Python's standard library. Let's briefly run through them in order.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: First of all, there is the `Collections` package, which contains even more data
    structures: [https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The `Collections` package contains the `defaultdict` class that we spoke about
    in the previous section. The `Collections` package also contains an `OrderedDict`
    parameter that remembers the order in which the items were inserted and gives
    them back in the same order when we iterate over it. A `deque` class is a variation
    on tuples that uses names to access the element and a `PseudoDict` parameter that
    provides a composite view of several other dictionaries.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few other data structures in there as well. One common data structure
    missing from the collections package is a `PriorityQueue` parameter, but that''s
    just because it has its own package called `heapq`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/heapq.html](https://docs.python.org/3/library/heapq.html)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Python's `PriorityQueue` operations are implemented as functions that work with
    built-in lists to add and remove items according to the **heap** property.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Storing and retrieving data is an extremely common need for programs and the
    `pickle` package makes it easy:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `pickle` package are classes and functions that facilitate transforming
    arbitrary Python data into a sequence of bytes that can be stored in a file, sent
    across the network, or whatever you need. The `pickle` package also has the tools
    to reverse the process and transform those bytes back into fully-fledged Python
    data objects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the vein of storing data, the `sqlite3` package provides complete
    access to the SQLite database manager, allowing us to take advantage of a complete
    transactional relational database:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/sqlite.html](https://docs.python.org/3/library/sqlite.html)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Third-party packages to access other database systems follow pretty much the
    same interface, so it's easy to make the switch to a different database later,
    if needed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The `json` package is also relevant to data handling. It parses or generates
    the de facto standard **Internet Data Exchange** (**IDX**) format:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The `json` package is smart, so it handles **JSON** (**JavaScript Object Notation**)
    objects, arrays, strings, numbers, null values, and so on, in a sensible way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapping them onto the proper Python datatypes, the `base64` package encodes
    bytes into base64, or decodes base64 into bytes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/base64.html](https://docs.python.org/3/library/base64.html)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: There are several other similar packages for `binhex`, `uu` code, and so on,
    as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The `html` and `xml` packages provide all sorts of utilities for dealing with
    the major internet markup languages, including parsers and the document object
    model:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/html.html](https://docs.python.org/3/library/html.html)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The `urllib` package provides us with convenient ways to retrieve data from
    URLs or to send data to them:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/urllib.html](https://docs.python.org/3/library/urllib.html)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In particular, the `urllib.request.url` open function is extremely useful.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The `itertools` and `functools` packages provide an assortment of utilities
    having to do with functional programming paradigms:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In particular, the `functools` package allows for us to create partially applied
    functions and the `itertools` package lets us concatenate iterators.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enum` package contains support for creating and using named enumerations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/enum.html](https://docs.python.org/3/library/enum.html)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Each enumeration is a distinct data type, like a class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pathlib` package contains classes and functions that provide a cross-platform
    abstraction of file and file path operations:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'The `inspect` package is interesting and quite useful. It provides us with
    functions that can be used to gather information about data objects, particularly
    about functions and classes. If we want to know the names of functions, parameters,
    or we want to access an object''s documentation, or any number of things along
    those lines, the `inspect` package will get us there:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/inspect.html](https://docs.python.org/3/library/pathlib.html)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The packages we just looked at are by no means the complete list of what's available
    in the standard library, but hopefully they give some idea of the depth and breadth
    of what we get just by installing Python. Taking a look through the library documentation
    on [https://www.python.org/](https://www.python.org/) is highly recommended for
    people who want to get the most out of Python. There are some particularly useful
    packages that we didn't mention at all. That's because there are whole other sections
    devoted to them later in the book.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: So, that brings us to the end of our overview of the standard library.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: What's new in modern Python
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to take a look at a few of the changes that have
    occurred in the latest releases of Python, specifically we will look at these:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The syntactic changes
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The changes in the packages
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other changes
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The changes in the syntactic
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since version 3.5, Python has three new groups of syntactic editions. The first
    of these groups is the introduction of keywords for describing **coroutines**.
    Python already supported coroutines, but the keywords make things clear and sometimes
    simpler. We'll be discussing coroutines in depth in a later chapter, so we won't
    go into this any further now.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The second piece of the new syntax is the introduction of the `@` symbol as
    an infix binary operator. This means that placing an `@` symbol between two sub-expressions
    is now a valid Python expression, just like placing a `+` symbol between the sub-expressions
    would be as shown in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15be46b7-377f-4fb8-ab72-939d11c66e92.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: However, since no built-in data type supports the `@` symbol operator yet, we
    won't be finding much use for it in this book. The intended semantic meaning of
    the `@` symbol is that it should represent matrix multiplication and it was added
    to improve support for an interoperability between third-party packages that implement
    matrixes and matrix operations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The third piece of new syntax is an expansion of Python's pre-existing syntax
    for using lists and dictionaries to provide the parameter values when invoking
    a function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Before, it was possible to put an asterisk (`*`) before a list of values to
    indicate that those values should be assigned to the parameters in the same order
    that they appeared in the list. Here is the code example for a single asterisk:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57af75ea-b85c-44ac-b107-4d526e15d7d8.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, `*` before two values was used to indicate that the values in a
    dictionary with text string keys should be assigned to the function''s parameters
    by name, as shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9924a66c-e6a8-4940-bb05-d1c3c703961d.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: The new syntax is just that we can now use more than one list or dictionary
    in this way, and that we can use the same asterisk and double asterisk syntax
    for constructing tuples, lists, dictionaries, and sets.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier that while Python attaches data types to data values rather
    than variables, it is possible to use function annotations to describe the expected
    types of function parameters' return values.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Changes in packages
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python now includes a package called `typing` in the standard library that contains
    classes and functions supporting the usage of type hints.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Python also includes a package called `zipapp` in the standard library.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'For `typing` visit the following website:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/typing.html](https://docs.python.org/3/library/typing.html)
    For `zipapp`, visit this website:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/zipapp.html](https://docs.python.org/3/library/zipapp.html)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The `zipapp` package makes it easy to construct `.pyz` files. A `.pyz` file
    is an archive file containing Python code and arbitrary read-only data, which
    the Python runtime is able to execute as a self-contained program. Once a program
    is debugged and ready for distribution, packaging it into a `.pyz` file is a simple
    and smart way to hand it to the users.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Other changes in Python packages
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some low-level improvements have been made in Python since version 3.5, such
    as faster reading of `filesystem` directories, automatic retrying of interrupted
    operating system calls, and a `math.isclose` function for checking whether two
    numbers are approximately equal.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: There are also a bunch of more minor additions that improve things throughout
    the standard library, all backwards compatible with earlier Python 3 versions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In the rare cases where something is added that breaks backwards compatibility,
    it's not enabled by default. For such a change, if we want to use it, we'd have
    to specifically mark our code as supporting the change. Those changes will not
    become standard until two versions later, so a breaking change in Python 3.5 would
    not become the default until Python version 3.7, with Python 3.5 and 3.6 issuing
    warnings when they encounter code that depends on the changing feature.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.5, there was only one such change-a small and smart alteration in
    the iteration protocol. It shouldn't have any effect on code that works properly,
    but technically it's a change in the interface and so it gets the full wait two
    versions treatment.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: If you want more detail about any of these changes I've mentioned, or if you
    ever want to find out what's changed between versions of Python, the documentation
    on [https://docs.python.org/3/](https://docs.python.org/3/) always contains a **what's
    new** document that goes into some detail about new features and provides links
    to the full documentation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'For details on the Python 3.6 what''s new document, visit the following link:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/whatsnew/3.6.html](https://docs.python.org/3/whatsnew/3.6.html)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: I always look forward to reading the what's new document for each release of
    Python, to find out what new toys I've just been handed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: So, we've now taken a high-level view of the Python standard library, introducing
    us to some of the more useful items it contains. That brings us to the end of
    our Python primer.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some fundamentals of the Python programming language.
    We have seen how to create and access those data structures, and how to use comprehensions
    to create and transform data structures based on existing ones.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: We looked briefly at what it means for Python to have first-class functions
    and classes, and how that can affect the possibilities open to us as programmers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: We briefly talked about some of the high points of the Python standard library.
    We also quickly covered the syntax, basic assumptions, and fundamental tools of
    the Python programming language.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to see how to set up a Python programming environment
    for us to work in for the remainder of the course and learn a bit about how to
    integrate third-party code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
