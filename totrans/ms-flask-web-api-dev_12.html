<html><head></head><body>
		<div id="_idContainer144">
			<h1 id="_idParaDest-315" class="chapter-number"><a id="_idTextAnchor322"/><st c="0">12</st></h1>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor323"/><st c="3">Integrating Flask with Other Tools and Frameworks</st></h1>
			<p><st c="53">Flask’s flexibility, seamlessness, and pluggability provide ease for building various applications, from simple form-based counseling systems to Docker-based applications. </st><em class="italic"><st c="226">Chapters 1</st></em><st c="236"> to </st><em class="italic"><st c="240">10</st></em><st c="242"> have showcased its minimalistic but powerful framework with several extension modules and libraries providing support, fast solutions, and clean coding for web and </st><span class="No-Break"><st c="407">API applications.</st></span></p>
			<p><st c="424">Although Flask is not favored to handle large enterprise solutions like Django can, it can serve as a middleware or component to many enterprise-grade systems and can even be a good solution for building microservices. </st><st c="644">The superb flexibility of Flask makes it an ideal inclusion to the recipes of many software infrastructures of many </st><span class="No-Break"><st c="760">business processes.</st></span></p>
			<p><st c="779">To give a clear picture as to where to place Flask in the list of popular Python frameworks, the goal of this last chapter is to highlight the feasibility of having a backend Flask implementation for mobile and frontend applications, a solution to a microservice architecture, and an implementation to many modern requirements such as creating and running queries and CRUD transactions </st><span class="No-Break"><st c="1166">through GraphQL.</st></span></p>
			<p><st c="1182">These are the topics covered in </st><span class="No-Break"><st c="1215">this chapter:</st></span></p>
			<ul>
				<li><st c="1228">Implementing microservice applications involving FastAPI, Django, </st><span class="No-Break"><st c="1295">and Tornado</st></span></li>
				<li><st c="1306">Implementing </st><span class="No-Break"><st c="1320">Flask instrumentation</st></span></li>
				<li><st c="1341">Applying OpenAPI 3.x specification </st><span class="No-Break"><st c="1377">with Swagger</st></span></li>
				<li><st c="1389">Providing REST services to a Flutter </st><span class="No-Break"><st c="1427">mobile application</st></span></li>
				<li><st c="1445">Consuming REST endpoints with a </st><span class="No-Break"><st c="1478">React application</st></span></li>
				<li><st c="1495">Building a </st><span class="No-Break"><st c="1507">GraphQL application</st></span></li>
			</ul>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor324"/><st c="1526">Technical requirements</st></h1>
			<p><st c="1549">This chapter uses an </st><em class="italic"><st c="1571">Online Library Management System</st></em><st c="1603"> to expound on building a microservice application that incorporates </st><a id="_idIndexMarker1130"/><st c="1672">FastAPI, Django, and Flask sub-applications with Tornado as the facade application and the server. </st><st c="1771">The sub-applications are mounted using different URL prefixes. </st><st c="1834">Here are the services offered by each of the </st><span class="No-Break"><st c="1879">mounted applications:</st></span></p>
			<ul>
				<li><st c="1900">Django sub-module – managing student </st><span class="No-Break"><st c="1938">book borrowers</st></span></li>
				<li><st c="1952">Flask sub-module – managing faculty </st><span class="No-Break"><st c="1989">book browsers</st></span></li>
				<li><st c="2002">FastAPI sub-module – managing feedback and complaints </st><span class="No-Break"><st c="2057">from borrowers</st></span></li>
				<li><st c="2071">Flask main application – the </st><span class="No-Break"><st c="2101">core transactions</st></span></li>
				<li><st c="2118">Tornado application – the </st><span class="No-Break"><st c="2145">facade application</st></span></li>
			</ul>
			<p><span class="No-Break"><em class="italic"><st c="2163">Figure 12</st></em></span><em class="italic"><st c="2173">.1</st></em><st c="2175"> shows the flow of transactions of these </st><span class="No-Break"><st c="2216">mounted applications.</st></span></p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B19383_12_001.jpg" alt="Figure 12.1 – Combined Django, Flask, FastAPI, and Tornado applications"/><st c="2237"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="2346">Figure 12.1 – Combined Django, Flask, FastAPI, and Tornado applications</st></p>
			<p><st c="2417">The sub-modules</st><a id="_idIndexMarker1131"/><st c="2433"> use </st><strong class="bold"><st c="2438">SQLAlchemy</st></strong><st c="2448"> as the ORM, while the Flask main application uses the</st><a id="_idIndexMarker1132"/><st c="2502"> standard </st><strong class="bold"><st c="2512">Peewee</st></strong><st c="2518"> ORM. </st><st c="2524">All the projects of this chapter are uploaded </st><span class="No-Break"><st c="2570">at </st></span><a href="https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch12"><span class="No-Break"><st c="2573">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch12</st></span></a><span class="No-Break"><st c="2654">.</st></span></p>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor325"/><st c="2655">Implementing microservice applications involving FastAPI, Django, and Tornado</st></h1>
			<p><st c="2733">Flask 3.x provides a </st><strong class="source-inline"><st c="2755">DispatcherMiddleware</st></strong><st c="2775"> class from </st><em class="italic"><st c="2787">Werkzeug</st></em><st c="2795"> that combines isolated and </st><a id="_idIndexMarker1133"/><st c="2823">valid WSGI-based applications to form a complete and larger system. </st><st c="2891">These combined applications can be all Flask or different WSGI-based applications such as Django, each with a unique URL prefix. </st><span class="No-Break"><em class="italic"><st c="3020">Figure 12</st></em></span><em class="italic"><st c="3029">.2</st></em><st c="3031"> shows the directory structure of our </st><span class="No-Break"><st c="3069">combined projects:</st></span></p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B19383_12_002.jpg" alt="Figure 12.2 – Django, FastAPI, Flask, and Tornado in one project structure"/><st c="3087"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="3313">Figure 12.2 – Django, FastAPI, Flask, and Tornado in one project structure</st></p>
			<p><st c="3387">All views, repositories, services, models, and configuration files of the main Flask application are in the </st><strong class="source-inline"><st c="3496">modules</st></strong><st c="3503"> folder. </st><st c="3512">On the other hand, all the application files of the FastAPI app are in the </st><strong class="source-inline"><st c="3587">modules_fastapi</st></strong><st c="3602"> folder, all components of the Django app are in the </st><strong class="source-inline"><st c="3655">modules_django</st></strong><st c="3669"> folder, all Tornado API handlers are in </st><strong class="source-inline"><st c="3710">modules_tornado</st></strong><st c="3725">, and all GraphQL components are in the </st><span class="No-Break"><strong class="source-inline"><st c="3765">modules_sub_flask</st></strong></span><span class="No-Break"><st c="3782"> directory.</st></span></p>
			<p><st c="3793">When it </st><a id="_idIndexMarker1134"/><st c="3802">comes to their respective module scripts, the FastAPI </st><strong class="source-inline"><st c="3856">app</st></strong><st c="3859"> instance is in </st><strong class="source-inline"><st c="3875">main_fastapi.py</st></strong><st c="3890">, the Flask sub-module’s </st><strong class="source-inline"><st c="3915">app</st></strong><st c="3918"> instance is in </st><strong class="source-inline"><st c="3934">main_sub_flask.py</st></strong><st c="3951">, and the Flask main module’s </st><strong class="source-inline"><st c="3981">app</st></strong><st c="3984"> instance together with the Tornado server is </st><span class="No-Break"><st c="4030">in </st></span><span class="No-Break"><strong class="source-inline"><st c="4033">main.py</st></strong></span><span class="No-Break"><st c="4040">.</st></span></p>
			<p><st c="4041">Now, let us discuss how all these sub-applications can run together using one </st><span class="No-Break"><st c="4120">Tornado server.</st></span></p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor326"/><st c="4135">Adding the Flask sub-application</st></h2>
			<p><strong class="source-inline"><st c="4168">DispatcherMiddleware</st></strong><st c="4189"> requires</st><a id="_idIndexMarker1135"/><st c="4198"> a Flask </st><strong class="source-inline"><st c="4207">app</st></strong><st c="4210"> instance to its first parameter and a dictionary containing the mounts of sub-applications, where the </st><em class="italic"><st c="4313">key</st></em><st c="4316"> is the URL pattern mapped to their corresponding WSGI </st><strong class="source-inline"><st c="4371">app</st></strong><st c="4374"> instance. </st><st c="4385">Mounting Flask sub-applications to a main Flask application is straightforward. </st><st c="4465">The following snippets show how to mount the </st><strong class="source-inline"><st c="4510">flask_sub_app</st></strong><st c="4523"> instance of the Flask sub-application to the core Flask </st><span class="No-Break"><strong class="source-inline"><st c="4580">app</st></strong></span><span class="No-Break"><st c="4583"> instance:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="4593">(main_sub_flask.py)</st></strong><st c="4613">
from modules_sub_flask import create_app_sub
from flask_cors import CORS
… … … … … …
flask_sub_app = create_app_sub("../config_dev_sub.toml")
CORS(flask_sub_app)
</st><strong class="bold"><st c="4776">(main.py)</st></strong>
<strong class="bold"><st c="4785">from werkzeug.middleware.dispatcher import DispatcherMiddleware</st></strong>
<strong class="bold"><st c="4849">from main_sub_flask import flask_sub_app</st></strong><st c="4890">
… … … … … …
from modules import create_app
app = create_app('../config_dev.toml')
… … … … … …
final_app = </st><strong class="bold"><st c="4996">DispatcherMiddleware</st></strong><st c="5016">(</st><strong class="bold"><st c="5018">app</st></strong><st c="5021">, {
    '/fastapi': ASGIMiddleware(fast_app),
    '/django': django_app,
    </st><strong class="bold"><st c="5086">'/flask': flask_sub_app</st></strong><st c="5109">
})</st></pre>			<p><st c="5112">The Flask sub-application</st><a id="_idIndexMarker1136"/><st c="5138"> must have its dedicated module script (e.g., </st><strong class="source-inline"><st c="5184">main_flask_sub.py</st></strong><st c="5201">) for its </st><strong class="source-inline"><st c="5212">flask_sub_app</st></strong><st c="5225"> instantiation. </st><strong class="source-inline"><st c="5241">main.py</st></strong><st c="5248"> must import the </st><strong class="source-inline"><st c="5265">flask_sub_app</st></strong><st c="5278"> instance from a dedicated module rather than creating it in </st><strong class="source-inline"><st c="5339">main.py</st></strong><st c="5346"> for traceability, easy debugging, and code-clean reasons. </st><st c="5405">Combining Flask apps to form a larger unit does not need additional configurations, unlike adding a FastAPI application to the main context. </st><st c="5546">How do we register FastAPI applications </st><span class="No-Break"><st c="5586">to </st></span><span class="No-Break"><strong class="source-inline"><st c="5589">DispatcherMiddleware</st></strong></span><span class="No-Break"><st c="5609">?</st></span></p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor327"/><st c="5610">Adding the FastAPI sub-application</st></h2>
			<p><st c="5644">Not all ASGI-based applications are </st><a id="_idIndexMarker1137"/><st c="5681">compatible with Flask’s context and can be part of the </st><strong class="source-inline"><st c="5736">DispatcherMiddleware</st></strong><st c="5756"> mounts. </st><st c="5765">For FastAPI, the workaround is to convert the </st><strong class="source-inline"><st c="5811">app</st></strong><st c="5814"> instance to WSGI at runtime using </st><strong class="source-inline"><st c="5849">ASGIMiddleware</st></strong><st c="5863"> from the </st><strong class="source-inline"><st c="5873">a2wsgi</st></strong><st c="5879"> module. </st><st c="5888">To utilize the ASGI-to-WSGI converter, first install </st><strong class="source-inline"><st c="5941">a2wsgi</st></strong><st c="5947"> using the following </st><span class="No-Break"><strong class="source-inline"><st c="5968">pip</st></strong></span><span class="No-Break"><st c="5971"> command:</st></span></p>
			<pre class="console"><st c="5980">
pip install a2wsgi</st></pre>			<p><strong class="source-inline"><st c="5999">ASGIMiddleware</st></strong><st c="6014"> does not depend on many external modules, so the conversion is straightforward from its built-in mechanisms. </st><st c="6124">It will not consume more memory for its conversion. </st><st c="6176">But, if the FastAPI application has several background tasks to perform, the utility class has a constructor parameter, </st><strong class="source-inline"><st c="6296">wait_time</st></strong><st c="6305">, to set an allowable time duration for every background task to finish running before finishing a request. </st><st c="6413">Moreover, its constructor has a </st><strong class="source-inline"><st c="6445">loop</st></strong><st c="6449"> parameter to allow setting another event loop in case the core platform needs a different type of event loop. </st><st c="6560">Now, the following </st><strong class="source-inline"><st c="6579">main.py</st></strong><st c="6586"> snippet shows how to add our FastAPI </st><strong class="source-inline"><st c="6624">app</st></strong><st c="6627"> instance to the </st><span class="No-Break"><st c="6644">mounted applications:</st></span></p>
			<pre class="source-code"><st c="6665">
(main_fastapi.py)
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from modules_fastapi.api import faculty
fast_app = FastAPI()
fast_app.include_router(faculty.router, prefix='/ch12')
fast_app.add_middleware(
    CORSMiddleware, allow_origins=['*'],
    allow_credentials=True, allow_methods=['*'], allow_headers=['*'])
(main.py)
from main_fastapi import fast_app
from a2wsgi import ASGIMiddleware
… … … … … …
final_app = DispatcherMiddleware(app, {
    </st><strong class="bold"><st c="7138">'/fastapi': ASGIMiddleware(fast_app),</st></strong><st c="7175">
    '/django': django_app,
    '/flask': flask_sub_app
})</st></pre>			<p><st c="7225">The </st><strong class="source-inline"><st c="7230">a2wsgi</st></strong><st c="7236"> module </st><a id="_idIndexMarker1138"/><st c="7244">works perfectly with FastAPI applications. </st><st c="7287">Not all ASGI-based applications can undergo seamless conversions with </st><strong class="source-inline"><st c="7357">a2wsgi</st></strong><st c="7363"> like </st><span class="No-Break"><st c="7369">FastAPI apps.</st></span></p>
			<p><st c="7382">Let us now add our Django sub-module to our </st><span class="No-Break"><st c="7427">mounted applications.</st></span></p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor328"/><st c="7448">Adding the Django sub-application</st></h2>
			<p><st c="7482">Django</st><a id="_idIndexMarker1139"/><st c="7489"> is a pure WSGI framework but can run on ASGI servers with additional configurations. </st><st c="7575">Unlike in FastAPI, adding a Django application to the mounts requires several steps, which include the </st><a id="_idIndexMarker1140"/><st c="7678">following procedures in the </st><strong class="source-inline"><st c="7706">main.py</st></strong><st c="7713"> module and Django </st><span class="No-Break"><st c="7732">admin’s </st></span><span class="No-Break"><strong class="source-inline"><st c="7740">settings.py</st></strong></span><span class="No-Break"><st c="7751">:</st></span></p>
			<ol>
				<li><st c="7753">Since </st><strong class="source-inline"><st c="7759">module_django</st></strong><st c="7772"> is not the main project folder, import the </st><strong class="source-inline"><st c="7816">os</st></strong><st c="7818"> module and set the default value of the </st><strong class="source-inline"><st c="7859">DJANGO_SETTINGS_MODULE</st></strong><st c="7881"> environment variable </st><span class="No-Break"><st c="7903">to </st></span><span class="No-Break"><strong class="source-inline"><st c="7906">modules_django.modules_django.settings</st></strong></span><span class="No-Break"><st c="7944">:</st></span><pre class="source-code"><st c="7946">
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'modules_django.modules_django.settings')</st></pre><p class="list-inset"><st c="8036">This setting defines the location of </st><strong class="source-inline"><st c="8074">settings.py</st></strong><st c="8085"> of the Django admin folder. </st><st c="8114">Failure to adjust this setting will lead to the following </st><span class="No-Break"><st c="8172">runtime error:</st></span></p><pre class="source-code"><strong class="bold"><st c="8186">attributeerror: module 'modules django.modules django.settings' has no attribute 'logging_config'</st></strong></pre></li>				<li><st c="8284">Specifying the package name of </st><strong class="source-inline"><st c="8316">settings.py</st></strong><st c="8327"> with the Django directory name requires adjusting some package names in the Django project. </st><st c="8420">Among the modifications is the change of </st><strong class="source-inline"><st c="8461">ROOT_URLCONF</st></strong><st c="8473"> in </st><strong class="source-inline"><st c="8477">settings.py</st></strong><st c="8488"> from </st><strong class="source-inline"><st c="8494">'modules_django.urls'</st></strong> <span class="No-Break"><st c="8515">to </st></span><span class="No-Break"><strong class="source-inline"><st c="8519">'modules_django.modules_django.urls'</st></strong></span><span class="No-Break"><st c="8555">.</st></span></li>
				<li><st c="8556">Registering a Django application to the </st><strong class="source-inline"><st c="8597">INSTALLED_APPS</st></strong><st c="8611"> settings must include the Django </st><span class="No-Break"><st c="8645">project name:</st></span><pre class="source-code"><st c="8658">
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'corsheaders',
    </st><strong class="bold"><st c="8873">'modules_django.olms'</st></strong><st c="8894">
]</st></pre></li>				<li><st c="8896">Also, include the Django project folder in defining the Django application object </st><span class="No-Break"><st c="8978">in </st></span><span class="No-Break"><strong class="source-inline"><st c="8981">settings.py</st></strong></span><span class="No-Break"><st c="8992">:</st></span><pre class="source-code"><st c="8994">
WSGI_APPLICATION = '</st><strong class="bold"><st c="9015">modules_django</st></strong><st c="9030">.wsgi.application'</st></pre></li>				<li><st c="9048">Anywhere</st><a id="_idIndexMarker1141"/><st c="9057"> inside the application (e.g., </st><strong class="source-inline"><st c="9088">modules_django.olms</st></strong><st c="9107">), import all the custom components with the project folder included. </st><st c="9178">The following snippet shows the implementation of REST services that manage student borrowers using Django RESTful services and </st><span class="No-Break"><st c="9306">Django ORM:</st></span><pre class="source-code">
<strong class="bold"><st c="9317">(views.py)</st></strong><st c="9328">
from rest_framework.response import Response
from rest_framework.decorators import api_view
from </st><strong class="bold"><st c="9426">modules_django</st></strong><st c="9440">.olms.serializer import BorrowedHistSerializer, StudentBorrowerSerializer
from </st><strong class="bold"><st c="9519">modules_django</st></strong><st c="9533">.olms.models import StudentBorrower, BorrowedHist
@api_view(['GET'])
def getData(request):
    app = StudentBorrower.objects.all()
    serializer = StudentBorrowerSerializer(app, many=True)
    return Response(serializer.data)
@api_view(['POST'])
def postData(request):
    serializer = StudentBorrowerSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    else:
        return Response({"message:error"})</st></pre></li>				<li><st c="9966">Since we are </st><a id="_idIndexMarker1142"/><st c="9980">mounting our Django application as a WSGI sub-application, set </st><strong class="source-inline"><st c="10043">DJANGO_ALLOW_ASYNC_UNSAFE</st></strong><st c="10068"> to </st><strong class="source-inline"><st c="10072">false</st></strong><st c="10077"> using the </st><span class="No-Break"><strong class="source-inline"><st c="10088">os</st></strong></span><span class="No-Break"><st c="10090"> module:</st></span><pre class="source-code"><st c="10098">
os.environ["DJANGO_ALLOW_ASYNC_UNSAFE"] = "true"</st></pre><p class="list-inset"><st c="10147">Failure to set this setting to </st><strong class="source-inline"><st c="10179">true</st></strong><st c="10183"> will cause this </st><span class="No-Break"><st c="10200">runtime exception:</st></span></p><pre class="source-code"><st c="10218">django.core.exceptions.SynchronousOnlyOperation: You cannot call this from an async context - use a thread or sync_to_async.</st></pre></li>				<li><st c="10343">Lastly, import </st><strong class="source-inline"><st c="10359">get_wsgi_application</st></strong><st c="10379"> from the </st><strong class="source-inline"><st c="10389">django.core.wsgi</st></strong><st c="10405"> module and register it to </st><strong class="source-inline"><st c="10432">DispatcherMiddleware</st></strong><st c="10452">. For Django web applications, import </st><strong class="source-inline"><st c="10490">StaticFilesHandler</st></strong><st c="10508"> from the </st><strong class="source-inline"><st c="10518">django.contrib.staticfiles.handlers</st></strong><st c="10553"> module and wrap the </st><strong class="source-inline"><st c="10574">get_wsgi_application()</st></strong><st c="10596">’s returned object to access the static web files (e.g., CSS, </st><span class="No-Break"><st c="10659">JS, images):</st></span><pre class="source-code">
<strong class="bold"><st c="10671">from django.core.wsgi import get_wsgi_application</st></strong>
<strong class="bold"><st c="10721">from django.contrib.staticfiles.handlers import StaticFilesHandler</st></strong><st c="10788">
… … … … … …
</st><strong class="bold"><st c="10800">django_app = StaticFilesHandler(</st></strong> <strong class="bold"><st c="10832">get_wsgi_application())</st></strong><st c="10856">
… … … … … …
final_app = DispatcherMiddleware(app, {
    '/fastapi': ASGIMiddleware(fast_app),
    </st><strong class="bold"><st c="10946">'/django': django_app,</st></strong><st c="10968">
    '/flask': flask_sub_app
})</st></pre></li>			</ol>
			<p><st c="10995">Now, it is time to mount the main Flask app to the Tornado server after mounting the FastAPI, Django, and </st><span class="No-Break"><st c="11102">Flask sub-applications.</st></span></p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor329"/><st c="11125">Putting it all together with Tornado</st></h2>
			<p><st c="11162">Although it is ideal to use Gunicorn to run Flask applications in the production server, sometimes using the non-blocking Tornado server is a perfect choice for a Flask project that focuses more on event-driven transactions, WebSocket, and </st><strong class="bold"><st c="11403">Server-Sent Events</st></strong><st c="11421"> (</st><strong class="bold"><st c="11423">SSE</st></strong><st c="11426">). </st><st c="11430">For this chapter, our </st><a id="_idIndexMarker1143"/><st c="11452">design is to mount the main Flask application, which implements the core </st><em class="italic"><st c="11525">Online Library Management System’s</st></em><st c="11559"> transactions, to a Tornado application. </st><st c="11600">By the way, Tornado is a Python framework and asynchronous networking library whose strength is more on event-driven, non-blocking, and long polling transactions that require a long-live connection to a user. </st><st c="11809">It has a bundled non-blocking HTTP server, </st><span class="No-Break"><st c="11852">unlike FastAPI.</st></span></p>
			<p><st c="11867">To run a</st><a id="_idIndexMarker1144"/><st c="11876"> compatible WSGI application on Tornado’s HTTP server, it </st><a id="_idIndexMarker1145"/><st c="11934">has a </st><strong class="source-inline"><st c="11940">WSGIContainer</st></strong><st c="11953"> utility class that wraps a core Flask </st><strong class="source-inline"><st c="11992">app</st></strong><st c="11995"> instance and runs the application on the non-blocking or asynchronous </st><span class="No-Break"><st c="12066">server mode.</st></span></p>
			<p class="callout-heading"><st c="12078">Important note</st></p>
			<p class="callout"><st c="12093">At the moment of writing this book, </st><strong class="source-inline"><st c="12130">Flask[async]</st></strong><st c="12142"> with async HTTP requests mounted on the Tornado server throws a </st><strong class="source-inline"><st c="12207">SynchronousOnlyOperation</st></strong><st c="12231"> error. </st><st c="12239">Thus, this chapter focuses on the standard Flask request </st><span class="No-Break"><st c="12296">transactions only.</st></span></p>
			<p><st c="12314">The </st><a id="_idIndexMarker1146"/><st c="12319">following </st><strong class="source-inline"><st c="12329">main.py</st></strong><st c="12336"> snippet shows the integration of our core</st><a id="_idIndexMarker1147"/><st c="12378"> Flask app with the </st><span class="No-Break"><st c="12398">Tornado server:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="12413">from tornado.wsgi import WSGIContainer</st></strong>
<strong class="bold"><st c="12452">from tornado.web import FallbackHandler, Application</st></strong><st c="12505">
from tornado.platform.asyncio import AsyncIOMainLoop
</st><strong class="bold"><st c="12559">from modules_tornado.handlers.home import MainHandler</st></strong><st c="12612">
import asyncio
… … … … … …
from modules import create_app
app = create_app('../config_dev.toml')
… … … … … …
final_app = DispatcherMiddleware(app, {
    '/fastapi': ASGIMiddleware(fast_app),
    '/django': django_app,
    '/flask': flask_sub_app
})
</st><strong class="bold"><st c="12850">main_flask = WSGIContainer(final_app)</st></strong>
<strong class="bold"><st c="12887">application = Application([</st></strong><st c="12915">
       (r"/ch12/tornado", MainHandler),
       </st><strong class="bold"><st c="12949">(r".*", FallbackHandler, dict(fallback=main_flask))</st></strong><st c="13000">,
</st><strong class="bold"><st c="13002">])</st></strong><st c="13004">
if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    </st><strong class="bold"><st c="13064">application.listen(5000)</st></strong><st c="13088">
    loop().run_forever()</st></pre>			<p><st c="13109">Tornado is </st><a id="_idIndexMarker1148"/><st c="13121">not a WSGI application and is not thread-safe. </st><st c="13168">It uses one </st><a id="_idIndexMarker1149"/><st c="13180">thread to manage one process at a time. </st><st c="13220">It is a framework designed for event-driven applications with a built-in server created for running non-blocking I/O sockets. </st><st c="13346">But, it can now directly use </st><strong class="source-inline"><st c="13375">asyncio</st></strong><st c="13382"> to run our mounted applications asynchronously in replacement of </st><strong class="source-inline"><st c="13448">IOLoop </st></strong><st c="13455">for events. </st><st c="13467">In the given snippet, our Tornado and main Flask applications run on the </st><strong class="source-inline"><st c="13540">asyncio</st></strong><st c="13547"> platform using the main event loop retrieved by </st><strong class="source-inline"><st c="13596">get_event_loop()</st></strong><st c="13612">. By the way, our complete system has a Tornado handler, </st><strong class="source-inline"><st c="13669">MainHandler</st></strong><st c="13680">, in </st><strong class="source-inline"><st c="13685">modules_tornado</st></strong><st c="13700"> that renders a welcome message in </st><span class="No-Break"><st c="13735">JSON format.</st></span></p>
			<p><st c="13747">At this point, our application has become complex because of the mounting of different WSGI and ASGI applications, so it needs a microservice mechanism called </st><strong class="bold"><st c="13907">instrumentation</st></strong><st c="13922"> to </st><a id="_idIndexMarker1150"/><st c="13926">monitor the low-level behavior of each mounted application and capture low-level metrics such as database-related logs, memory usage, and library-specific logs </st><span class="No-Break"><st c="14086">and issues.</st></span></p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor330"/><st c="14097">Implementing Flask instrumentation</st></h1>
			<p><st c="14132">Instrumentation is a </st><a id="_idIndexMarker1151"/><st c="14154">mechanism that generates, collects, and exports data about the runtime diagnostics of an application, microservice, or distributed setup. </st><st c="14292">Usually, this observable data includes traces, logs, and metrics that can provide an understanding of the system. </st><st c="14406">Among the many ways to implement instrumentation, </st><strong class="bold"><st c="14456">OpenTelemetry</st></strong><st c="14469"> offers </st><a id="_idIndexMarker1152"/><st c="14477">easy configuration and vendor-agnostic approaches to monitoring and observing the system’s internal state. </st><st c="14584">To utilize OpenTelemetry for Flask, install the following external modules using the </st><span class="No-Break"><strong class="source-inline"><st c="14669">pip</st></strong></span><span class="No-Break"><st c="14672"> command:</st></span></p>
			<pre class="console"><st c="14681">
pip install opentelemetry-api opentelemetry-sdk opentelemetry-instrumentation-flask opentelemetry-instrumentation-requests</st></pre>			<p><st c="14804">The following </st><a id="_idIndexMarker1153"/><st c="14819">snippet added to the </st><strong class="source-inline"><st c="14840">create_app()</st></strong><st c="14852"> factory in the </st><strong class="source-inline"><st c="14868">__init__.py</st></strong><st c="14879"> of the main Flask application provides the </st><span class="No-Break"><st c="14923">console-based instrumentation:</st></span></p>
			<pre class="source-code"><st c="14953">
from opentelemetry import trace
from opentelemetry.sdk.resources import Resource
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.sdk.trace.export import ConsoleSpanExporter
from opentelemetry.sdk.resources import SERVICE_NAME, Resource
from opentelemetry.instrumentation.flask import FlaskInstrumentor
def create_app(config_file):
    provider = TracerProvider(resource= Resource.create({SERVICE_NAME: "</st><strong class="bold"><st c="15437">packt-flask-service</st></strong><st c="15457">"}))
    processor = BatchSpanProcessor(ConsoleSpanExporter())
    provider.add_span_processor(processor)
    trace.set_tracer_provider(provider)
    global tracer
    tracer = trace.get_tracer("</st><strong class="bold"><st c="15633">packt-flask-tracer</st></strong><st c="15652">")
    app = OpenAPI(__name__, info=info)
    … … … … … …
    </st><strong class="bold"><st c="15703">FlaskInstrumentor(app).instrument(</st></strong><strong class="bold"><st c="15737">enable_commenter=True, commenter_options={})</st></strong><st c="15782">
    … … … … … …</st></pre>			<p><st c="15793">OpenTelemetry</st><a id="_idIndexMarker1154"/><st c="15807"> requires the Flask application to set up the Tracing API consisting of </st><strong class="source-inline"><st c="15879">TracerProvider</st></strong><st c="15893">, </st><strong class="source-inline"><st c="15895">Tracer</st></strong><st c="15901">, and </st><strong class="source-inline"><st c="15907">Span</st></strong><st c="15911">(s). </st><st c="15917">The first component, </st><strong class="source-inline"><st c="15938">TracerProvider</st></strong><st c="15952">, is the entry point of the API and the registry for creating the tracers. </st><st c="16027">A tracer is responsible for creating spans. </st><st c="16071">On the other hand, a span is an API that can monitor any part of </st><span class="No-Break"><st c="16136">the application.</st></span></p>
			<p><st c="16152">After instantiating </st><strong class="source-inline"><st c="16173">TracerProvider</st></strong><st c="16187">, part of the setup to create a tracer is to </st><span class="No-Break"><st c="16232">apply </st></span><span class="No-Break"><strong class="source-inline"><st c="16238">Batch</st></strong></span><strong class="source-inline"><st c="16243">
SpanProcessor</st></strong><st c="16257">, which preprocesses the spans per batch before exporting them to another system, tool, or backend. </st><st c="16357">It requires a specific exporter class in its constructor parameter, such as </st><strong class="source-inline"><st c="16433">ConsoleSpanExporter</st></strong><st c="16452">, which sends the span to the console. </st><st c="16491">To complete the </st><strong class="source-inline"><st c="16507">TracerProvider</st></strong><st c="16521"> setup, add the processor to the </st><strong class="source-inline"><st c="16554">TracerProvider</st></strong><st c="16568"> object using its </st><span class="No-Break"><strong class="source-inline"><st c="16586">add_span_processor()</st></strong></span><span class="No-Break"><st c="16606"> method.</st></span></p>
			<p><st c="16614">Finally, import the trace API object from the </st><strong class="source-inline"><st c="16661">opentelemetry</st></strong><st c="16674"> module and invoke its </st><strong class="source-inline"><st c="16697">set_tracer_provider()</st></strong><st c="16718"> class method to set the created </st><strong class="source-inline"><st c="16751">TracerProvider</st></strong><st c="16765"> instance. </st><st c="16776">To extract the </st><strong class="source-inline"><st c="16791">tracer</st></strong><st c="16797"> object, invoke its </st><strong class="source-inline"><st c="16817">get_tracer()</st></strong><st c="16829"> method and specify its name, such </st><span class="No-Break"><st c="16864">as </st></span><span class="No-Break"><strong class="source-inline"><st c="16867">packt-flask-tracer</st></strong></span><span class="No-Break"><st c="16885">.</st></span></p>
			<p><st c="16886">Now, import the </st><strong class="source-inline"><st c="16903">tracer</st></strong><st c="16909"> object anywhere inside the application. </st><st c="16950">The following module script imports the </st><strong class="source-inline"><st c="16990">tracer</st></strong><st c="16996"> object to monitor the </st><span class="No-Break"><strong class="source-inline"><st c="17019">add_login()</st></strong></span><span class="No-Break"><st c="17030"> endpoint:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="17040">from modules import tracer</st></strong><st c="17067">
@current_app.post("/login/add)
def add_login():
    </st><strong class="bold"><st c="17116">with tracer.start_as_current_span('users_span'):</st></strong><st c="17164">
        login_json = request.get_json()
        repo = LoginRepository()
        result = repo.insert_login(login_json)
        if result == False:
            return jsonify(message="error"), 500
        else:
            return jsonify(record=login_json)</st></pre>			<p><st c="17357">Invoking the </st><strong class="source-inline"><st c="17371">start_as_current_span()</st></strong><st c="17394"> method of a </st><strong class="source-inline"><st c="17407">tracer</st></strong><st c="17413"> object creates a span, a single operation within a trace. </st><st c="17472">For larger systems, spans can be nested to form a trace tree for detailed monitoring. </st><st c="17558">A nested trace contains a root span, which typically describes the </st><a id="_idIndexMarker1155"/><st c="17625">upper-level operation, and one or more child spans for its lower-level operations. </st><span class="No-Break"><em class="italic"><st c="17708">Figure 12</st></em></span><em class="italic"><st c="17717">.3</st></em><st c="17719"> shows the console log after running the </st><span class="No-Break"><strong class="source-inline"><st c="17760">add_login()</st></strong></span><span class="No-Break"><st c="17771"> endpoint:</st></span></p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B19383_12_003.jpg" alt="Figure 12.3 – A tracer log exported to the console"/><st c="17781"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="18272">Figure 12.3 – A tracer log exported to the console</st></p>
			<p><st c="18322">Additionally, Jaeger, a distributed tracing </st><a id="_idIndexMarker1156"/><st c="18367">platform, can visualize </st><a id="_idIndexMarker1157"/><st c="18391">all the logs from the trace in graphical views. </st><st c="18439">OpenTelemetry has an exporter class that can export the spans to the Jaeger platform after preprocessing. </st><st c="18545">But first, install Jaeger either through its Docker image or binaries. </st><st c="18616">In this chapter, we start the Jaeger server through the </st><strong class="source-inline"><st c="18672">jaeger-all-in-one.exe</st></strong><st c="18693"> command from </st><span class="No-Break"><st c="18707">its binaries.</st></span></p>
			<p><st c="18720">Then, install the OpenTelemetry module for Jaeger support using the following </st><span class="No-Break"><strong class="source-inline"><st c="18799">pip</st></strong></span><span class="No-Break"><st c="18802"> command:</st></span></p>
			<pre class="console"><st c="18811">
pip install opentelemetry-exporter-jaeger</st></pre>			<p><st c="18853">After the installation, add the following snippet to the previous OpenTelemetry setup in the </st><span class="No-Break"><strong class="source-inline"><st c="18947">create_app()</st></strong></span><span class="No-Break"><st c="18959"> factory:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="18968">from opentelemetry.exporter.jaeger.thrift import JaegerExporter</st></strong><st c="19032">
    … … … … … …
    trace.set_tracer_provider(provider)
    </st><strong class="bold"><st c="19080">jaeger_exporter = JaegerExporter(agent_host_name= "localhost", agent_port=6831,)</st></strong><strong class="bold"><st c="19160">trace.get_tracer_provider().add_span_processor( BatchSpanProcessor(jaeger_exporter))</st></strong><st c="19245">
    global tracer
    tracer = trace.get_tracer("packt-flask-tracer")
    … … … … … …</st></pre>			<p><strong class="source-inline"><st c="19319">JaegerExporter</st></strong><st c="19334"> sends the traces to a thrift server running through the HTTP protocol. </st><st c="19406">The constructor parameters of the exporter class are all about the server details of the thrift server. </st><st c="19510">In our case, </st><strong class="source-inline"><st c="19523">agent_host_name</st></strong><st c="19538"> is </st><strong class="source-inline"><st c="19542">localhost</st></strong><st c="19551"> and </st><strong class="source-inline"><st c="19556">agent_port</st></strong> <span class="No-Break"><st c="19566">is </st></span><span class="No-Break"><strong class="source-inline"><st c="19570">6831</st></strong></span><span class="No-Break"><st c="19574">.</st></span></p>
			<p><st c="19575">Restart the Tornado</st><a id="_idIndexMarker1158"/><st c="19595"> server, run the monitored APIs, and open the Jaeger dashboard at </st><strong class="source-inline"><st c="19661">http://localhost:16686/</st></strong><st c="19684"> using the browser to check the traces. </st><span class="No-Break"><em class="italic"><st c="19724">Figure 12</st></em></span><em class="italic"><st c="19733">.4</st></em><st c="19735"> shows the </st><strong class="bold"><st c="19746">Search</st></strong><st c="19752"> page of the Jaeger dashboard after searching </st><span class="No-Break"><st c="19798">four traces:</st></span></p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B19383_12_004.jpg" alt="Figure 12.4 – Jaeger search result for span traces"/><st c="19810"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="20346">Figure 12.4 – Jaeger search result for span traces</st></p>
			<p><st c="20396">The left portion of Jaeger’s </st><strong class="bold"><st c="20426">Traces</st></strong><st c="20432"> view renders a list of Tracing API services that monitor our application. </st><st c="20507">Ours is </st><strong class="source-inline"><st c="20515">packt-flask-service</st></strong><st c="20534">, which gave four searches at the time of its search. </st><st c="20588">On the right portion of the dashboard is the search result listing the traces produced by the spans that monitored the transaction performed. </st><st c="20730">Clicking each row leads to trace details in a graphical format. </st><st c="20794">On the other hand, the graph in the header portion </st><a id="_idIndexMarker1159"/><st c="20845">summarizes all the traces at a </st><span class="No-Break"><st c="20876">specified duration.</st></span></p>
			<p><st c="20895">Let us now explore how to add OpenAPI 3.x documentation to the API endpoints of our </st><span class="No-Break"><st c="20980">Flask application.</st></span></p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor331"/><st c="20998">Applying OpenAPI 3.x specification with Swagger</st></h1>
			<p><st c="21046">Aside</st><a id="_idIndexMarker1160"/><st c="21052"> from instrumentation, some</st><a id="_idIndexMarker1161"/><st c="21079"> solutions provide well-formatted API documentation, as in FastAPI. </st><st c="21147">One of these solutions is to use </st><strong class="source-inline"><st c="21180">flask_openapi3</st></strong><st c="21194">, which applies OpenAPI 3.x specification to implement Flask components and document the API endpoints with Swagger, ReDoc, </st><span class="No-Break"><st c="21318">and RapiDoc.</st></span></p>
			<p><strong class="source-inline"><st c="21330">flask_openapi3</st></strong><st c="21345"> is not a library or dependency module of Flask but a separate framework based on the current Flask 3.x with the </st><strong class="source-inline"><st c="21458">pydantic</st></strong><st c="21466"> module to support OpenAPI documentation. </st><st c="21508">It also supports </st><span class="No-Break"><strong class="source-inline"><st c="21525">Flask[async]</st></strong></span><span class="No-Break"><st c="21537"> components.</st></span></p>
			<p><st c="21549">After installing </st><strong class="source-inline"><st c="21567">flask_openapi3</st></strong><st c="21581"> using the </st><strong class="source-inline"><st c="21592">pip</st></strong><st c="21595"> command, replace the </st><strong class="source-inline"><st c="21617">Flask</st></strong><st c="21622"> class with </st><strong class="source-inline"><st c="21634">OpenAPI</st></strong><st c="21641"> and </st><strong class="source-inline"><st c="21646">Blueprint</st></strong><st c="21655"> with </st><strong class="source-inline"><st c="21661">APIBlueprint</st></strong><st c="21673">. These are still the original Flask classes but with the feature of adding API documentation. </st><st c="21768">The following is the </st><strong class="source-inline"><st c="21789">create_app()</st></strong><st c="21801"> factory</st><a id="_idIndexMarker1162"/><st c="21809"> method of our main Flask</st><a id="_idIndexMarker1163"/><st c="21834"> application that uses </st><strong class="source-inline"><st c="21857">OpenAPI</st></strong><st c="21864"> to create the application object with the added </st><span class="No-Break"><st c="21913">documentation components:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="21938">from flask_openapi3 import Info</st></strong>
<strong class="bold"><st c="21970">from flask_openapi3 import OpenAPI</st></strong><st c="22005">
… … … … … …
</st><strong class="bold"><st c="22017">info = Info(title="Flask Interoperability (A</st></strong> <strong class="bold"><st c="22061">Microservice)", version="1.0.0")</st></strong><st c="22094">
… … … … … …
def create_app(config_file):
    … … … … … …
    </st><strong class="bold"><st c="22147">app = OpenAPI(__name__, info=info)</st></strong><st c="22181">
    app.config.from_file(config_file, toml.load)
    cors = CORS(app)
    app.config['CORS_HEADERS'] = 'Content-Type'
    … … … … … …</st></pre>			<p><st c="22299">The </st><strong class="source-inline"><st c="22304">Info</st></strong><st c="22308"> utility class provides the project title of the OpenAPI documentation. </st><st c="22380">Its instance is part of the constructor parameter values </st><span class="No-Break"><st c="22437">of OpenAPI.</st></span></p>
			<p><st c="22448">To document an API, add a summary of the endpoint, a complete description of the API transaction, tags, request field descriptions, and response details. </st><st c="22603">The following snippet shows a simple documentation of the </st><span class="No-Break"><strong class="source-inline"><st c="22661">list_login()</st></strong></span><span class="No-Break"><st c="22673"> endpoint:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="22683">from flask_openapi3 import Tag</st></strong>
<strong class="bold"><st c="22714">list_login_tag = Tag(name="list_login", description="List all user credentials.")</st></strong><st c="22796">
… … … … … …
@current_app.get("/login/list/all", </st><strong class="bold"><st c="22844">summary="List all login records.", tags=[list_login_tag]</st></strong><st c="22900">)
def list_login():
    </st><strong class="bold"><st c="22921">"""</st></strong><strong class="bold"><st c="22924">API for retrieving all the records from the olms database.</st></strong><strong class="bold"><st c="22983">"""</st></strong><st c="22987">
    with tracer.start_as_current_span('users_span'):
        repo = LoginRepository()
        result = repo.select_all_login()
        print(result)
        return jsonify(records=result)</st></pre>			<p><st c="23139">The HTTP </st><a id="_idIndexMarker1164"/><st c="23149">method decorators of OpenAPI allow additional </st><a id="_idIndexMarker1165"/><st c="23195">arguments such as a summary and tags describing the API endpoint. </st><st c="23261">The </st><strong class="source-inline"><st c="23265">Tags</st></strong><st c="23269"> class is a </st><strong class="source-inline"><st c="23281">flask_openapi3</st></strong><st c="23295"> utility that enables the creation of tags for an endpoint. </st><st c="23355">An endpoint can be associated with a list of tag objects. </st><st c="23413">On the other hand, the documentation comment placed in the first lines of the API function becomes the complete and detailed description of the </st><span class="No-Break"><st c="23557">API implementation.</st></span></p>
			<p><st c="23576">Now, an application using the </st><strong class="source-inline"><st c="23607">flask_openapi3</st></strong><st c="23621"> framework has an additional endpoint, </st><strong class="source-inline"><st c="23660">/openapi/swagger</st></strong><st c="23676">, which, when run on a web browser, will render a Swagger documentation, as illustrated in </st><span class="No-Break"><em class="italic"><st c="23767">Figure 12</st></em></span><span class="No-Break"><em class="italic"><st c="23776">.5</st></em></span><span class="No-Break"><st c="23778">:</st></span></p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B19383_12_005.jpg" alt="Figure 12.5 – An OpenAPI/Swagger documentation in Flask"/><st c="23780"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="24388">Figure 12.5 – An OpenAPI/Swagger documentation in Flask</st></p>
			<p><st c="24443">As long as </st><strong class="source-inline"><st c="24455">flask-openapi3</st></strong><st c="24469"> is always up to date and synchronized with the Flask releases, it is a helpful and feasible solution to build Flask applications with documentation implemented using OpenAPI/Swagger. </st><st c="24653">The framework can provide acceptable and standard API </st><a id="_idIndexMarker1166"/><st c="24707">documentation with less additional YAML or JSON configuration</st><a id="_idIndexMarker1167"/> <span class="No-Break"><st c="24768">in </st></span><span class="No-Break"><strong class="source-inline"><st c="24772">main.py</st></strong></span><span class="No-Break"><st c="24779">.</st></span></p>
			<p><st c="24780">In the next section, let us discuss other ways our Flask application can provide services outside the Python platform, starting with </st><span class="No-Break"><st c="24914">mobile development.</st></span></p>
			<h1 id="_idParaDest-325"><a id="_idTextAnchor332"/><st c="24933">Providing REST services to a Flutter mobile application</st></h1>
			<p><st c="24989">Flask applications can be a potential backend API service provider for many popular mobile platforms, such as Flutter. </st><st c="25109">Flutter</st><a id="_idIndexMarker1168"/><st c="25116"> is an open source mobile toolkit created by Google to provide commercially accepted and natively compiled applications for mobile platforms. </st><st c="25258">It can serve as a frontend framework for our </st><span class="No-Break"><st c="25303">microservice applications.</st></span></p>
			<p><st c="25329">To start Flutter, download the latest Flutter SDK release – in my case, for Windows, from</st><a id="_idIndexMarker1169"/><st c="25419"> the </st><a href="https://docs.flutter.dev/release/archive?tab=windows"><st c="25424">https://docs.flutter.dev/release/archive?tab=windows</st></a><st c="25476"> download site. </st><st c="25492">Unzip the file to your development directory and register </st><strong class="source-inline"><st c="25550">%FLUTTER_HOME%\bin</st></strong><st c="25568"> in the Windows </st><span class="No-Break"><st c="25584">global classpath.</st></span></p>
			<p><st c="25601">Afterward, download the latest Android Studio</st><a id="_idIndexMarker1170"/><st c="25647"> from </st><a href="https://developer.android.com/studio"><st c="25653">https://developer.android.com/studio</st></a><st c="25689">. Then, open the newly installed Android Studio and go to </st><strong class="bold"><st c="25747">Tools</st></strong><st c="25752"> | </st><strong class="bold"><st c="25755">SDK Manager</st></strong><st c="25766"> to install the </st><span class="No-Break"><st c="25782">following components:</st></span></p>
			<ul>
				<li><st c="25803">Android SDK platform, the latest </st><span class="No-Break"><st c="25837">API version</st></span></li>
				<li><st c="25848">Android SDK </st><span class="No-Break"><st c="25861">command-line tools</st></span></li>
				<li><st c="25879">Android SDK </st><span class="No-Break"><st c="25892">build tools</st></span></li>
				<li><st c="25903">Android SDK </st><span class="No-Break"><st c="25916">platform tools</st></span></li>
				<li><span class="No-Break"><st c="25930">Android Emulator</st></span></li>
			</ul>
			<p><st c="25947">After a </st><a id="_idIndexMarker1171"/><st c="25956">successful Android SDK update and </st><a id="_idIndexMarker1172"/><st c="25990">installation of SDK components, open a terminal and perform the following procedures for </st><span class="No-Break"><st c="26079">Flutter diagnostics:</st></span></p>
			<ol>
				<li><st c="26099">Run the </st><strong class="source-inline"><st c="26108">flutter doctor</st></strong><st c="26122"> command on </st><span class="No-Break"><st c="26134">the terminal.</st></span></li>
				<li><st c="26147">All settings and tools must be satisfied before the development. </st><st c="26213">There should be no issues at this point of </st><span class="No-Break"><st c="26256">the installation.</st></span></li>
				<li><st c="26273">Using the VS Code editor with the Flutter extension, create a Flutter project; it should have the project structure presented in </st><span class="No-Break"><em class="italic"><st c="26403">Figure 12</st></em></span><span class="No-Break"><em class="italic"><st c="26412">.6</st></em></span><span class="No-Break"><st c="26414">:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B19383_12_006.jpg" alt="Figure 12.6 – Our ch12-flutter-flask project"/><st c="26416"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="26629">Figure 12.6 – Our ch12-flutter-flask project</st></p>
			<p><st c="26673">Inside </st><strong class="source-inline"><st c="26681">/lib/olms/provider</st></strong><st c="26699">, </st><strong class="source-inline"><st c="26701">providers.dart</st></strong><st c="26715"> implements the transactions that consume</st><a id="_idIndexMarker1173"/><st c="26756"> the HTTP </st><strong class="source-inline"><st c="26766">GET</st></strong><st c="26769"> and </st><strong class="source-inline"><st c="26774">POST</st></strong><st c="26778"> of our</st><a id="_idIndexMarker1174"/><st c="26785"> APIs for user management. </st><st c="26812">Here are the </st><strong class="source-inline"><st c="26825">dart</st></strong><st c="26829"> codes for our </st><span class="No-Break"><st c="26844">service providers:</st></span></p>
			<pre class="source-code"><st c="26862">
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:library_app/olms/models/login.dart';
class LoginProvider with ChangeNotifier{
  List&lt;Login&gt; _items = [];
  List&lt;Login&gt; get items {
    return [..._items];
  }
  Future&lt;void&gt; addLogin(String username, String password, String role ) async {
    </st><strong class="bold"><st c="27210">String url = 'http://&lt;actual IP address&gt;:5000/login/add';</st></strong><st c="27267">
    try{
      if(username.isEmpty || password.isEmpty || role.isEmpty){
         return;
      }
      Map&lt;String, dynamic&gt; request = {"username": username, "password": password, "role": int.parse(role)};
      final headers = {'Content-Type': 'application/json'};
      </st><strong class="bold"><st c="27497">final response = await http.post(Uri.parse(url), headers: headers, body: json.encode(request));</st></strong><st c="27592">
      Map&lt;String, dynamic&gt; responsePayload = json.decode(response.body);
      final login = Login(
          username: responsePayload["username"],
          password: responsePayload["password"],
          role: responsePayload["role"]
      );
      print(login);
      notifyListeners();
    }catch(e){
      print(e);
    }
  }</st></pre>			<p><st c="27849">The given </st><strong class="source-inline"><st c="27860">addLogin()</st></strong><st c="27870"> consumes</st><a id="_idIndexMarker1175"/><st c="27879"> the </st><strong class="source-inline"><st c="27884">add_login()</st></strong><st c="27895"> API </st><a id="_idIndexMarker1176"/><st c="27900">from our Flask </st><span class="No-Break"><st c="27915">microservice app:</st></span></p>
			<pre class="source-code"><st c="27932">
  Future&lt;void&gt; get getLogin async {
    </st><strong class="bold"><st c="27967">String url = 'http://&lt;actual IP address&gt;:5000/login/list/all';</st></strong><st c="28029">
    var response;
    try{
      </st><strong class="bold"><st c="28049">response = await http.get(Uri.parse(url));</st></strong><strong class="bold"><st c="28091">Map body = json.decode(response.body);</st></strong><st c="28130">
      List&lt;Map&gt; loginRecs = body["records"].cast&lt;Map&gt;();
      print(loginRecs);
      _items = loginRecs.map((e) =&gt; Login(
          id: e["id"],
          username: e["username"],
          password: e["password"],
          role: e["role"],
      )
      ).toList();
    }catch(e){
      print(e);
    }
    notifyListeners();
  }
}</st></pre>			<p><st c="28376">The </st><strong class="source-inline"><st c="28381">Login</st></strong><st c="28386"> model class </st><a id="_idIndexMarker1177"/><st c="28399">mentioned in the code is a </st><a id="_idIndexMarker1178"/><st c="28426">Flutter class that the </st><strong class="source-inline"><st c="28449">addLogin()</st></strong><st c="28459"> and </st><strong class="source-inline"><st c="28464">getLogin()</st></strong><st c="28474"> provider transactions will map to the JSON records from the Flask API endpoints. </st><st c="28556">The following is Flutter’s </st><strong class="source-inline"><st c="28583">Login</st></strong><st c="28588"> model class derived from the </st><strong class="source-inline"><st c="28618">ch12-microservices-interop</st></strong><st c="28644">’s SQLAlchemy </st><span class="No-Break"><st c="28659">model layer:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="28671">(/lib/olms/models/login.dart</st></strong><st c="28700">
class Login{
  int? </st><st c="28719">id;
  String username;
  String password;
  int role;
  Login({ required this.username, required this.password, required this.role, this.id=0});
}</st></pre>			<p><st c="28857">Now, the given </st><strong class="source-inline"><st c="28873">getLogin()</st></strong><st c="28883"> retrieves the </st><strong class="source-inline"><st c="28898">Login</st></strong><st c="28903"> records in JSON format from our </st><strong class="source-inline"><st c="28936">list_login()</st></strong><st c="28948"> endpoint function. </st><st c="28968">Notice that Flutter requires the </st><em class="italic"><st c="29001">actual IP address</st></em><st c="29018"> of the host server for its services to access the API </st><span class="No-Break"><st c="29073">endpoint resources.</st></span></p>
			<p><st c="29092">The </st><strong class="source-inline"><st c="29097">/lib/olms/tasks/task.dart</st></strong><st c="29122"> file implements the form widgets and the corresponding events that invoke these two service methods. </st><st c="29224">The following part of the implementation shows the </st><span class="No-Break"><strong class="source-inline"><st c="29275">Login</st></strong></span><span class="No-Break"><st c="29280"> form:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="29286">(/lib/olms/tasks/task.dart)</st></strong><st c="29314">
… … … … … …
</st><strong class="bold"><st c="29326">class _TasksWidgetState extends State&lt;LoginViewWidget&gt; {</st></strong><st c="29382">
  … … … … … …
  @override
  Widget build(BuildContext context) {
    return Padding(
    … … … … … …
        children: [
          Row(
            children: [
              Expanded(
                child: TextFormField(
                  controller: userNameController,
                  decoration: const InputDecoration(
                    labelText: 'Username',
                    border: OutlineInputBorder(),
                  ),
              … … … … … …
              Expanded(
                child: TextFormField(
                  … … … … … …
                    labelText: 'Password',
                    border: OutlineInputBorder(),
                  ),
                ),
              ),
              Expanded(
                child: TextFormField(
                    … … … … … …
                    labelText: 'Role',
                    border: OutlineInputBorder(),
                  ),
              … … … … … …
              const SizedBox(width: 10,),
              ElevatedButton(
                  … … … … … …
                  child: const Text("Add"),
                  onPressed: () {
                    Provider.of&lt;LoginProvider&gt;(context, listen: false).addLogin(userNameController.text, passwordController.text, roleController.text);
                    … … … … … …
                  }
              )
            ],
          ),</st></pre>			<p><st c="30130">In general, </st><strong class="source-inline"><st c="30143">LoginViewWidget</st></strong><st c="30158"> component</st><a id="_idIndexMarker1179"/><st c="30168"> returns a </st><strong class="source-inline"><st c="30179">Padding</st></strong><st c="30186"> widget composed of two sub-widgets. </st><st c="30223">The preceding code renders a </st><a id="_idIndexMarker1180"/><st c="30252">horizontal form of three </st><strong class="source-inline"><st c="30277">TextFormField</st></strong><st c="30290"> widgets that will accept login details from the user and an </st><strong class="source-inline"><st c="30351">ElevatedButton</st></strong><st c="30365"> that will trigger the </st><strong class="source-inline"><st c="30388">add_login()</st></strong><st c="30399"> provider transaction to invoke our Flask </st><strong class="source-inline"><st c="30441">/login/add</st></strong><st c="30451"> endpoint. </st><st c="30462">The following code shows the next part of </st><strong class="source-inline"><st c="30504">LoginViewWidget</st></strong><st c="30519"> that renders the list of </st><strong class="source-inline"><st c="30545">Login</st></strong><st c="30550"> records from </st><span class="No-Break"><st c="30564">our database:</st></span></p>
			<pre class="source-code"><st c="30577">
… … … … … …
FutureBuilder(future: Provider.of&lt;LoginProvider&gt;(context, listen: false).getLogin,
       builder: (ctx, snapshot) =&gt;
         snapshot.connectionState == ConnectionState.waiting
          ? </st><st c="30754">const Center(child: CircularProgressIndicator())
          : Consumer&lt;LoginProvider&gt;(
              … … … … … …
              builder: (ctx, loginProvider, child) =&gt;
                … … … … … …
                    Container(
                    … … … … … … …
                      child: SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                            child: DataTable(
                              columns: &lt;DataColumn&gt;[
                                 DataColumn(
                                  label: Text(
                                    'Username',
                                    style:
                                        … … … … … …
                                ),
                                DataColumn(
                                  label: Text(
                                    'Password',
                                    style:
                                 … … … … … …
                                ),
                                DataColumn(
                                  label: Text(
                                    'Role',
                                … … … … … …
                                ),],
                         rows: &lt;DataRow&gt;[
                           DataRow(cells: &lt;DataCell&gt;[
                             DataCell(Text( loginProvider. </st><st c="31266">items[i].username)),
                             DataCell(Text(loginProvider. </st><st c="31316">items[i].password)),
                             DataCell(Text(loginProvider. </st><st c="31366">items[i].role.toString())),
                                  ],
                             … … … … … …</st></pre>			<p><st c="31408">The preceding code</st><a id="_idIndexMarker1181"/><st c="31427"> renders a </st><strong class="source-inline"><st c="31438">FutureWidget</st></strong><st c="31450"> component</st><a id="_idIndexMarker1182"/><st c="31460"> composed of </st><strong class="source-inline"><st c="31473">ListView</st></strong><st c="31481"> of </st><strong class="source-inline"><st c="31485">DataColumn</st></strong><st c="31495"> and </st><strong class="source-inline"><st c="31500">DataRow</st></strong><st c="31507"> widgets to showcase the </st><strong class="source-inline"><st c="31532">Login</st></strong><st c="31537"> records from our Flask </st><strong class="source-inline"><st c="31561">/login/list/all</st></strong><st c="31576"> endpoint. </st><st c="31587">It has a vertical scrollbar rendered by its </st><strong class="source-inline"><st c="31631">SingleChildScrollView </st></strong><st c="31653">widget. </st><span class="No-Break"><em class="italic"><st c="31661">Figure 12</st></em></span><em class="italic"><st c="31670">.7</st></em><st c="31672"> shows the resulting </st><strong class="source-inline"><st c="31693">LoginViewWidget</st></strong><st c="31708"> form after running our </st><strong class="source-inline"><st c="31732">ch12-flask-flutter</st></strong><st c="31750"> application using the </st><strong class="source-inline"><st c="31773">flutter run</st></strong><st c="31784"> command inside the </st><strong class="source-inline"><st c="31804">/</st></strong><span class="No-Break"><strong class="source-inline"><st c="31805">library_app</st></strong></span><span class="No-Break"><st c="31816"> directory.</st></span></p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B19383_12_007.jpg" alt="Figure 12.7 – A Flutter form for login transactions"/><st c="31827"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31921">Figure 12.7 – A Flutter form for login transactions</st></p>
			<p><st c="31972">In addition to</st><a id="_idIndexMarker1183"/><st c="31987"> mobile development, Flask APIs </st><a id="_idIndexMarker1184"/><st c="32019">can also provide data services to popular frontend frameworks, such as React. </st><st c="32097">Let us see how in the </st><span class="No-Break"><st c="32119">next section.</st></span></p>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor333"/><st c="32132">Consuming REST endpoints with a React application</st></h1>
			<p><st c="32182">React</st><a id="_idIndexMarker1185"/><st c="32188"> is a popular frontend server-side JavaScript library used to build scalable user interfaces for websites, mostly </st><strong class="bold"><st c="32302">single-page applications</st></strong><st c="32326"> (</st><strong class="bold"><st c="32328">SPAs</st></strong><st c="32332">). </st><st c="32336">It is a popular library in rendering pages that</st><a id="_idIndexMarker1186"/><st c="32383"> changes its state without reloading </st><span class="No-Break"><st c="32420">the page.</st></span></p>
			<p><st c="32429">After creating a </st><a id="_idIndexMarker1187"/><st c="32447">React project using the </st><strong class="source-inline"><st c="32471">create-react-app</st></strong><st c="32487"> command, our </st><strong class="source-inline"><st c="32501">ch12-react-flask</st></strong><st c="32517"> application has implemented the following functional component to build the form page and the table listing all the faculty borrowers of the </st><em class="italic"><st c="32659">Online Library </st></em><span class="No-Break"><em class="italic"><st c="32674">Management System</st></em></span><span class="No-Break"><st c="32691">:</st></span></p>
			<pre class="source-code"><st c="32693">
export const FacultyBorrowers =(props)=&gt;{
    const [id] = React.useState(0);
    const [firstname, setFirstname] = React.useState('');
    const [lastname, setLastname] = React.useState('');
    const [empid, setEmpid] = React.useState('');
    const [records, setRecords] = React.useState([]);</st></pre>			<p><st c="32969">The given </st><strong class="source-inline"><st c="32980">useState()</st></strong><st c="32990"> hook methods define the state variables that the form components will use to capture form data before submitting the details to the </st><strong class="source-inline"><st c="33123">add_faculty_borrower()</st></strong><st c="33145"> API endpoint of our </st><span class="No-Break"><st c="33166">FastAPI sub-application:</st></span></p>
			<pre class="source-code"><st c="33190">
    React.useEffect(() =&gt; {
        const url_get = 'http://localhost:5000/fastapi/ ch12/faculty/borrower/list/all';
        fetch(url_get)
        .then((response) =&gt;  response.json() )
        .then((json) =&gt;  { setRecords(json)})
        .catch((error) =&gt; console.log(error));
      }, []);
    const addRecord = () =&gt;{
         const url_post = 'http://localhost:5000/fastapi/ ch12/faculty/borrower/add';
         const options = {
            method: 'POST',
            headers:{
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(
                {
                'id': id,
                'firstname': firstname,
                'lastname': lastname,
                'empid': empid
                }
            )
        }
         fetch(url_post, options)
            .then((response) =&gt; { response.json() })
            .then((json) =&gt; { console.log(json)})
            .catch((error) =&gt; console.log(error));
            const url_get = 'http://localhost:5000/fastapi/ ch12/faculty/borrower/list/all';
            fetch(url_get)
            .then((response) =&gt;  response.json() )
            .then((json) =&gt;  { setRecords(json)})
            .catch((error) =&gt; console.log(error));
    }</st></pre>			<p><st c="34072">The </st><strong class="source-inline"><st c="34077">addRecord()</st></strong><st c="34088"> event </st><a id="_idIndexMarker1188"/><st c="34095">method forms the JSON data from the state variables before submitting it to the </st><strong class="source-inline"><st c="34175">add_faculty_borrower()</st></strong><st c="34197"> API endpoint. </st><st c="34212">Likewise, it retrieves all the faculty borrowers from the microservice through the </st><strong class="source-inline"><st c="34295">list_all_faculty_borrowers()</st></strong><st c="34323"> endpoint of the same </st><a id="_idIndexMarker1189"/><span class="No-Break"><st c="34345">FastAPI sub-application:</st></span></p>
			<pre class="source-code"><st c="34369">
    return &lt;div&gt;
      &lt;form id='idForm1' </st><strong class="bold"><st c="34402">onSubmit={ addRecord }</st></strong><st c="34424">&gt;
        Employee ID: &lt;input type='text' </st><strong class="bold"><st c="34459">onChange={ (e) =&gt; {setEmpid(e.target.value)}}</st></strong><st c="34504"> /&gt;&lt;br/&gt;
        First Name: &lt;input type='text' </st><strong class="bold"><st c="34544">onChange={ (e) =&gt; {setFirstname(e.target.value) }}</st></strong><st c="34594"> /&gt;&lt;br/&gt;
        Last Name: &lt;input type='text' </st><strong class="bold"><st c="34633">onChange={ (e) =&gt; {setLastname(e.target.value)}}</st></strong><st c="34681">/&gt;&lt;br/&gt;
        &lt;input type='submit' value='ADD Faculty Borrower'/&gt;
            &lt;/form&gt;
            &lt;br/&gt;
            &lt;h2&gt;List of Faculty Borrowers&lt;/h2&gt;
            &lt;table &gt;
              &lt;thead&gt;
                  &lt;tr&gt;&lt;th&gt;Id&lt;/th&gt;
                      &lt;th&gt;Employee ID&lt;/th&gt;
                      &lt;th&gt;First Name&lt;/th&gt;
                      &lt;th&gt;Last Name&lt;/th&gt;
              &lt;/tr&gt;&lt;/thead&gt;
              &lt;tbody&gt;
                </st><strong class="bold"><st c="34906">{records.map((u) =&gt; (</st></strong><st c="34927">
                  &lt;tr&gt;
                    &lt;td&gt;{u.id}&lt;/td&gt;
                    &lt;td&gt;{u.empid}&lt;/td&gt;
                    &lt;td&gt;{u.firstname}&lt;/td&gt;
                    &lt;td&gt;{u.lastname}&lt;/td&gt;
                  &lt;/tr&gt;
                ))}
            &lt;/tbody&gt;&lt;/table&gt;
        &lt;/div&gt;}</st></pre>			<p><st c="35047">The </st><strong class="source-inline"><st c="35052">records.map()</st></strong><st c="35065"> function builds the table of records after adding a new faculty borrower record to the database. </st><strong class="source-inline"><st c="35163">addRecord()</st></strong><st c="35174">, with the help of the </st><strong class="source-inline"><st c="35197">useEffect()</st></strong><st c="35208"> hook method, captures all the records from the </st><strong class="source-inline"><st c="35256">list_all_faculty_borrowers()</st></strong><st c="35284"> API and stores the list of JSON-formatted data to the state</st><a id="_idIndexMarker1190"/> <span class="No-Break"><st c="35344">variable, </st></span><span class="No-Break"><strong class="source-inline"><st c="35355">records</st></strong></span><span class="No-Break"><st c="35362">.</st></span></p>
			<p><st c="35363">Aside from building service providers for other platforms, Flask can also build GraphQL applications for easy CRUD operations. </st><st c="35491">Let’s learn about it in the </st><span class="No-Break"><st c="35519">next discussion.</st></span></p>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor334"/><st c="35535">Building a GraphQL application</st></h1>
			<p><st c="35566">GraphQL is </st><a id="_idIndexMarker1191"/><st c="35578">a mechanism that provides a platform-agnostic CRUD transaction across the applications without specifying the actual database connectivity details and database dialects. </st><st c="35748">This mechanism is model-centric or data-centric and focuses on the data the users want to fetch through the backend </st><span class="No-Break"><st c="35864">API implementations.</st></span></p>
			<p><st c="35884">Our microservice designed</st><a id="_idIndexMarker1192"/><st c="35910"> the Flask sub-application to be a GraphQL application with the following HTTP GET endpoint that creates the GraphQL </st><span class="No-Break"><st c="36027">UI explorer:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="36039">from ariadne.explorer import ExplorerGraphiQL</st></strong><st c="36085">
… … … … … …
</st><strong class="bold"><st c="36097">flask_sub_app = create_app_sub("../config_dev_sub.toml")</st></strong><st c="36153">
CORS(flask_sub_app)
</st><strong class="bold"><st c="36174">explorer_html = ExplorerGraphiQL().html(None)</st></strong>
<strong class="bold"><st c="36219">@flask_sub_app.route("/graphql", methods=["GET"])</st></strong><st c="36269">
def graphql_explorer():
    return explorer_html, 200</st></pre>			<p><st c="36319">Our solution </st><a id="_idIndexMarker1193"/><st c="36333">used the </st><strong class="source-inline"><st c="36342">Ariadne</st></strong><st c="36349"> module because it is updated and can integrate with Flask 3.x components. </st><span class="No-Break"><em class="italic"><st c="36424">Figure 12</st></em></span><em class="italic"><st c="36433">.8</st></em><st c="36435"> shows the actual GraphQL Explorer after accessing the given </st><strong class="source-inline"><st c="36496">/</st></strong><span class="No-Break"><strong class="source-inline"><st c="36497">flask/graphql</st></strong></span><span class="No-Break"><st c="36510"> endpoint.</st></span></p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B19383_12_008.jpg" alt="Figure 12.8 – The Ariadne GraphQL Explorer"/><st c="36520"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="36641">Figure 12.8 – The Ariadne GraphQL Explorer</st></p>
			<p><st c="36683">Next, build the crucial GraphQL schema configuration, the </st><strong class="source-inline"><st c="36742">schema.graphql</st></strong><st c="36756"> file, which creates all the GraphQL model classes derived from the ORM models, request data, and response objects of the supposed API endpoints. </st><st c="36902">The following is a snapshot of the </st><strong class="source-inline"><st c="36937">schema.graphql</st></strong><st c="36951"> file used by our </st><span class="No-Break"><st c="36969">Flask sub-application:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="36991">schema {</st></strong><strong class="bold"><st c="37000">query: Query</st></strong><strong class="bold"><st c="37013">mutation: Mutation</st></strong>
<strong class="bold"><st c="37032">}</st></strong>
<strong class="bold"><st c="37034"># These are the GraphQL model classes</st></strong>
<strong class="bold"><st c="37071">type Complainant {</st></strong>
<strong class="bold"><st c="37090">    id: ID!</st></strong>
<strong class="bold"><st c="37098">    firstname: String!</st></strong>
<strong class="bold"><st c="37117">    lastname: String!</st></strong>
<strong class="bold"><st c="37135">    middlename: String!</st></strong>
<strong class="bold"><st c="37155">    email: String!</st></strong>
<strong class="bold"><st c="37170">    date_registered: String!</st></strong>
<strong class="bold"><st c="37195">}</st></strong>
<strong class="bold"><st c="37197">type Complaint {</st></strong>
<strong class="bold"><st c="37213">   id: ID!</st></strong>
<strong class="bold"><st c="37221">   ticketId: String!</st></strong>
<strong class="bold"><st c="37239">   catid: Int!</st></strong>
<strong class="bold"><st c="37251">   complainantId: Int!</st></strong>
<strong class="bold"><st c="37271">   ctype: Int!</st></strong>
<strong class="bold"><st c="37283">}</st></strong></pre>			<p><st c="37285">The </st><a id="_idIndexMarker1194"/><st c="37289">language used to implement the </st><strong class="source-inline"><st c="37320">schema.graphql</st></strong><st c="37334"> file is </st><a id="_idIndexMarker1195"/><st c="37343">the </st><strong class="bold"><st c="37347">Schema Definition Language</st></strong><st c="37373"> (</st><strong class="bold"><st c="37375">SDL</st></strong><st c="37378">), and the first portion is the declaration of the operation types needed by the GraphQL REST services – namely, </st><strong class="source-inline"><st c="37492">Mutation</st></strong><st c="37500"> and </st><strong class="source-inline"><st c="37505">Query</st></strong><st c="37510">. Then, what follows are the definitions of GraphQL </st><em class="italic"><st c="37562">object types</st></em><st c="37574">, the building blocks of GraphQL that represent the records that the REST services will fetch from or persist in the data repository. </st><st c="37708">In the given definition file, the GraphQL transactions will focus on utilizing </st><strong class="source-inline"><st c="37787">Complainant</st></strong><st c="37798">, </st><strong class="source-inline"><st c="37800">Complaint</st></strong><st c="37809">, and their related model classes to manage the feedback sub-module of the </st><em class="italic"><st c="37884">Online Library </st></em><span class="No-Break"><em class="italic"><st c="37899">Management System</st></em></span><span class="No-Break"><st c="37916">.</st></span></p>
			<p><st c="37917">Each model class consists of </st><strong class="source-inline"><st c="37947">Int</st></strong><st c="37950">, </st><strong class="source-inline"><st c="37952">Float</st></strong><st c="37957">, </st><strong class="source-inline"><st c="37959">Boolean</st></strong><st c="37966">, </st><strong class="source-inline"><st c="37968">ID</st></strong><st c="37970">, or any custom scalar object type. </st><st c="38006">GraphQL also allows model classes to have </st><strong class="source-inline"><st c="38048">enum</st></strong><st c="38052"> and list (</st><strong class="source-inline"><st c="38063">[]</st></strong><st c="38066">) field types. </st><st c="38082">The scalar or multi-valued fields can be nullable or non-nullable (</st><strong class="source-inline"><st c="38149">!</st></strong><st c="38150">). </st><st c="38153">So far, the given model classes all consist of non-nullable scalar fields. </st><st c="38228">By the way, the octothorpe or hashtag (</st><strong class="source-inline"><st c="38267">#</st></strong><st c="38269">) sign is the comment symbol of </st><span class="No-Break"><st c="38301">the SDL.</st></span></p>
			<p><st c="38309">After</st><a id="_idIndexMarker1196"/><st c="38315"> building the model classes, the next step is to define the </st><strong class="source-inline"><st c="38375">Query</st></strong><st c="38380"> and </st><strong class="source-inline"><st c="38385">Mutation</st></strong><st c="38393"> operations with their parameters and </st><span class="No-Break"><st c="38431">return types.</st></span></p>
			<pre class="source-code"><st c="38444">
# The GraphQL operations
type Query {
    listAllComplainants: </st><strong class="bold"><st c="38504">ComplainantListResult</st></strong><st c="38525">!
    listAllComplaints: </st><strong class="bold"><st c="38546">ComplaintListResult</st></strong><st c="38565">!
    listAllCategories: </st><strong class="bold"><st c="38586">CategoryListResult</st></strong><st c="38604">!
    listAllComplaintTypes: </st><strong class="bold"><st c="38629">ComplaintTypeListResult</st></strong><st c="38652">!
}
type Mutation {
    createCategory(</st><strong class="bold"><st c="38687">name: String</st></strong><st c="38700">!): CategoryInsertResult!
    </st><st c="38726">createComplaintType(</st><strong class="bold"><st c="38746">name: String</st></strong><st c="38759">!): ComplaintTypeInsertResult!
    </st><st c="38790">createComplainant(</st><strong class="bold"><st c="38808">input: ComplainantInput</st></strong><st c="38832">!): ComplainantInsertResult!
    </st><st c="38861">createComplaint(</st><strong class="bold"><st c="38877">input: ComplaintInput</st></strong><st c="38899">!): ComplaintInsertResult!
</st><st c="38926">}</st></pre>			<p><st c="38927">Our Flask sub-application focuses on the persistence and retrieval of feedback about the Online Library’s processes. </st><st c="39044">Its </st><strong class="source-inline"><st c="39048">Query</st></strong><st c="39053"> operations involve retrieving the complaints (</st><strong class="source-inline"><st c="39100">listAllComplaints</st></strong><st c="39118">), complainants (</st><strong class="source-inline"><st c="39136">listAllComplainants</st></strong><st c="39156">), and the category (</st><strong class="source-inline"><st c="39178">listAllCategories</st></strong><st c="39196">) and complaint type (</st><strong class="source-inline"><st c="39219">listAllComplaintTypes</st></strong><st c="39241">) lookups. </st><st c="39253">On the other hand, the </st><strong class="source-inline"><st c="39276">Mutation</st></strong><st c="39284"> operations involve adding complaints (</st><strong class="source-inline"><st c="39323">createComplaint</st></strong><st c="39339">), complainants (</st><strong class="source-inline"><st c="39357">createComplainant</st></strong><st c="39375">), complaint categories (</st><strong class="source-inline"><st c="39401">createCategory</st></strong><st c="39416">), and complaint types (</st><strong class="source-inline"><st c="39441">createComplaintType</st></strong><st c="39461">) to the database. </st><strong class="source-inline"><st c="39481">createCategory</st></strong><st c="39495"> and </st><strong class="source-inline"><st c="39500">createComplaintType</st></strong><st c="39519"> have their respective </st><strong class="source-inline"><st c="39542">String</st></strong><st c="39548"> parameter name, but the other mutators use input types to organize and manage their lengthy parameter list. </st><st c="39657">Here are the</st><a id="_idIndexMarker1197"/><st c="39669"> implementations of the </st><strong class="source-inline"><st c="39693">ComplaintInput</st></strong><st c="39707"> and </st><span class="No-Break"><strong class="source-inline"><st c="39712">ComplainantInput</st></strong></span><span class="No-Break"><st c="39728"> types:</st></span></p>
			<pre class="source-code"><st c="39735">
# These are the input types
</st><strong class="bold"><st c="39764">input</st></strong><st c="39769"> ComplainantInput {
    firstname: String!
    </st><st c="39808">lastname: String!
    </st><st c="39826">middlename: String!
    </st><st c="39846">email: String!
    </st><st c="39861">date_registered: String!
</st><st c="39886">}
</st><strong class="bold"><st c="39888">input</st></strong><st c="39893"> ComplaintInput {
   ticketId: String!
   </st><st c="39929">complainantId: Int!
   </st><st c="39949">catid: Int!
   </st><st c="39961">ctype: Int!
</st><st c="39973">}</st></pre>			<p><st c="39974">Aside from input types, </st><strong class="source-inline"><st c="39998">Query</st></strong><st c="40003"> and </st><strong class="source-inline"><st c="40008">Mutation</st></strong><st c="40016"> operators need result types to manage the response of GraphQL’s REST service executions. </st><st c="40106">Here are some of the result types used by our </st><strong class="source-inline"><st c="40152">Query</st></strong><st c="40157"> and </st><span class="No-Break"><strong class="source-inline"><st c="40162">Mutation</st></strong></span><span class="No-Break"><st c="40170"> operations:</st></span></p>
			<pre class="source-code"><st c="40182">
# These are the result types
type ComplainantInsertResult {
    success: Boolean!
    </st><st c="40261">errors: [String]
    model: Complainant!
</st><st c="40298">}
type ComplaintInsertResult {
    success: Boolean!
    </st><st c="40347">errors: [String]
    model: Complaint!
</st><st c="40382">}
… … … … … …
type ComplainantListResult {
    success: Boolean!
    </st><st c="40443">errors: [String]
    complainants: [Complainant]!
</st><st c="40489">}
type ComplaintListResult {
    success: Boolean!
    </st><st c="40536">errors: [String]
    complaints: [Complaint]!
</st><st c="40578">}</st></pre>			<p><st c="40579">Now, all these</st><a id="_idIndexMarker1198"/><st c="40593"> object types, input types, and result types build GraphQL resolvers that implement these </st><strong class="source-inline"><st c="40683">Query</st></strong><st c="40688"> and </st><strong class="source-inline"><st c="40693">Mutation</st></strong><st c="40701"> operations. </st><st c="40714">A </st><em class="italic"><st c="40716">GraphQL resolver</st></em><st c="40732"> connects the application’s repository and data layer to the GraphQL architecture. </st><st c="40815">Although GraphQL can provide auto-generated resolver implementations, it is still practical to implement a custom resolver for each operation to capture the needed requirements, especially if the operations involve complex constraints and scenarios. </st><st c="41065">The following snippet from </st><strong class="source-inline"><st c="41092">modules_sub_flask/resolvers/complainant_repo.py</st></strong><st c="41139"> implements the resolvers of our </st><a id="_idIndexMarker1199"/><st c="41172">defined </st><strong class="source-inline"><st c="41180">Query</st></strong><st c="41185"> and </st><span class="No-Break"><strong class="source-inline"><st c="41190">Mutation</st></strong></span><span class="No-Break"><st c="41198"> operations:</st></span></p>
			<pre class="source-code"><st c="41210">
from ariadne import QueryType, MutationType
from typing import List, Any, Dict
from modules_sub_flask.models.db import Complainant
from sqlalchemy.orm import Session
</st><strong class="bold"><st c="41377">query = QueryType()</st></strong>
<strong class="bold"><st c="41396">mutation = MutationType()</st></strong><st c="41422">
class ComplainantResolver:
    def __init__(self, sess:Session):
        self.sess = sess
</st><strong class="bold"><st c="41501">    @mutation.field('complainant')</st></strong>
<strong class="bold"><st c="41531">    def insert_complainant(self, obj, info, input) -&gt; bool:</st></strong>
<strong class="bold"><st c="41587">        try:</st></strong>
<strong class="bold"><st c="41592">            complainant = Complainant(**input)</st></strong>
<strong class="bold"><st c="41627">            self.sess.add(complainant)</st></strong>
<strong class="bold"><st c="41654">            self.sess.commit()</st></strong>
<strong class="bold"><st c="41673">            payload = {</st></strong>
<strong class="bold"><st c="41685">                "success": True,</st></strong>
<strong class="bold"><st c="41702">                "model": complainant</st></strong>
<strong class="bold"><st c="41723">            }</st></strong>
<strong class="bold"><st c="41725">        except Exception as e:</st></strong>
<strong class="bold"><st c="41748">            print(e)</st></strong>
<strong class="bold"><st c="41757">            payload = {</st></strong>
<strong class="bold"><st c="41769">                "success": False,</st></strong>
<strong class="bold"><st c="41787">                "errors": [f"Complainant … not found"]</st></strong>
<strong class="bold"><st c="41826">            }</st></strong>
<strong class="bold"><st c="41828">        return payload</st></strong><st c="41843">
        … … … … … …</st></pre>			<p><st c="41854">The </st><strong class="source-inline"><st c="41859">insert_complainant()</st></strong><st c="41879"> transaction</st><a id="_idIndexMarker1200"/><st c="41891"> accepts the input from the GraphQL dashboard and saves the data to the database, while the following </st><strong class="source-inline"><st c="41993">select_all_complainant()</st></strong><st c="42017"> retrieves all the records from the database and renders them as a list of complainant records to the </st><span class="No-Break"><st c="42119">GraphQL dashboard:</st></span></p>
			<pre class="source-code"><st c="42137">
     def select_all_complainant(self, obj, info) -&gt; List[Any]:
        complainants = self.sess.query(Complainant).all()
        try:
            records = [todo.to_json() for todo in complainants]
            print(records)
            </st><strong class="bold"><st c="42318">payload = {</st></strong><strong class="bold"><st c="42329">"success": True,</st></strong><strong class="bold"><st c="42346">"complainants": records</st></strong><strong class="bold"><st c="42370">}</st></strong><st c="42372">
        except Exception as e:
            print(e)
            </st><strong class="bold"><st c="42405">payload = {</st></strong><strong class="bold"><st c="42416">"success": False,</st></strong><strong class="bold"><st c="42434">"errors": [str("Empty records")]</st></strong><strong class="bold"><st c="42467">}</st></strong><st c="42469">
   … … … … … …</st></pre>			<p><st c="42480">The </st><strong class="source-inline"><st c="42485">ariadne</st></strong><st c="42492"> module has </st><strong class="source-inline"><st c="42504">QueryType</st></strong><st c="42513"> and </st><strong class="source-inline"><st c="42518">MutationType</st></strong><st c="42530"> that map GraphQL components such as </st><em class="italic"><st c="42567">input types</st></em><st c="42578">. The </st><strong class="source-inline"><st c="42584">MutationType</st></strong><st c="42596"> object, for instance, maps the </st><strong class="source-inline"><st c="42628">ComplainantInput</st></strong><st c="42644"> type to the </st><strong class="source-inline"><st c="42657">input</st></strong><st c="42662"> parameter of the </st><span class="No-Break"><strong class="source-inline"><st c="42680">insert_complainant()</st></strong></span><span class="No-Break"><st c="42700"> method.</st></span></p>
			<p><st c="42708">Our GraphQL provider looks</st><a id="_idIndexMarker1201"/><st c="42735"> like a repository class, but it can also be a service type as long as it meets the requirements of the </st><strong class="source-inline"><st c="42839">Query</st></strong><st c="42844"> and </st><strong class="source-inline"><st c="42849">Mutation</st></strong><st c="42857"> functions defined in the </st><strong class="source-inline"><st c="42883">schema.graphql</st></strong> <span class="No-Break"><st c="42897">definition file.</st></span></p>
			<p><st c="42914">Now, the mapping of each resolver function to its respective HTTP request function in </st><strong class="source-inline"><st c="43001">schema.graphql</st></strong><st c="43015"> always happens in </st><strong class="source-inline"><st c="43034">main.py</st></strong><st c="43041">. The following snippet in </st><strong class="source-inline"><st c="43068">main_sub_flask.py</st></strong><st c="43085"> performs mapping of these two </st><span class="No-Break"><st c="43116">GraphQL components:</st></span></p>
			<pre class="source-code"><st c="43135">
… … … … … …
from ariadne import load_schema_from_path, make_executable_schema, \
    graphql_sync, snake_case_fallback_resolvers, ObjectType
from ariadne.explorer import ExplorerGraphiQL
</st><strong class="bold"><st c="43318">from modules_sub_flask.resolvers.complainant_repo import ComplainantResolver</st></strong>
<strong class="bold"><st c="43394">from modules_sub_flask.resolvers.complaint_repo import ComplaintResolver</st></strong><st c="43467">
from modules_sub_flask.models.config import db_session
… … … … … …
</st><strong class="bold"><st c="43535">complainant_repo = ComplainantResolver(db_session)</st></strong>
<strong class="bold"><st c="43585">category_repo = CategoryResolver(db_session)</st></strong><st c="43630">
… … … … … …
</st><strong class="bold"><st c="43642">query = ObjectType("Query")</st></strong><st c="43669">
query.set_field("listAllComplainants", complainant_repo.select_all_complainant)
query.set_field("listAllComplaints", complaint_repo.select_all_complaint)
… … … … … …
</st><strong class="bold"><st c="43836">mutation = ObjectType("Mutation")</st></strong><st c="43869">
mutation.set_field("createComplainant", complainant_repo.insert_complainant)
mutation.set_field("createComplaint", complaint_repo.insert_complaint)
… … … … … …
</st><strong class="bold"><st c="44030">type_defs = load_schema_from_path("./schema.graphql")</st></strong><st c="44083">
schema = make_executable_schema(
    type_defs, </st><strong class="bold"><st c="44128">query</st></strong><st c="44133">, </st><strong class="bold"><st c="44135">mutation</st></strong><st c="44143">,
)
… … … … … …</st></pre>			<p><strong class="source-inline"><st c="44158">main_sub_flask.py</st></strong><st c="44176"> loads all the </st><a id="_idIndexMarker1202"/><st c="44191">components from </st><strong class="source-inline"><st c="44207">schema.graphql</st></strong><st c="44221"> and maps all its operations to the repository and model layers of the mounted application. </st><st c="44313">It is recommended to place the schema definition file in the main project directory for easy access to the file. </st><span class="No-Break"><em class="italic"><st c="44426">Figure 12</st></em></span><em class="italic"><st c="44435">.9</st></em><st c="44437"> shows the sequence of operations needed to run the </st><span class="No-Break"><strong class="source-inline"><st c="44489">createComplainant</st></strong></span><span class="No-Break"><st c="44506"> mutator.</st></span></p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B19383_12_009.jpg" alt="Figure 12.9 – Syntax for running a GraphQL mutator"/><st c="44515"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="44782">Figure 12.9 – Syntax for running a GraphQL mutator</st></p>
			<p><st c="44832">And </st><span class="No-Break"><em class="italic"><st c="44837">Figure 12</st></em></span><em class="italic"><st c="44846">.10</st></em><st c="44849"> shows how </st><a id="_idIndexMarker1203"/><st c="44860">to run the </st><strong class="source-inline"><st c="44871">listAllComplainants</st></strong> <span class="No-Break"><st c="44890">query operation.</st></span></p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B19383_12_010.jpg" alt="Figure 12.10 – Syntax for running a GraphQL query operator"/><st c="44907"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="45310">Figure 12.10 – Syntax for running a GraphQL query operator</st></p>
			<p><st c="45368">There are other libraries Flask can integrate to implement the GraphQL architecture, but they need to be up to date to support </st><span class="No-Break"><st c="45496">Flask 3.x.</st></span></p>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor335"/><st c="45506">Summary</st></h1>
			<p><st c="45514">Flexibility, adaptability, extensibility, and maintainability are the best adjectives that fully describe Flask as a </st><span class="No-Break"><st c="45632">Python framework.</st></span></p>
			<p><st c="45649">Previous chapters have proven Flask to be a simple, minimalist, and Pythonic framework that can build API and web applications with fewer configurations and setups. </st><st c="45815">Its vast support helps us build applications that manage workflows and perform scientific calculations and visualization using plots, graphs, and charts. </st><st c="45969">Although a WSGI application at the core, it can implement asynchronous API and view functions with </st><strong class="source-inline"><st c="46068">async</st></strong><st c="46073"> services and </st><span class="No-Break"><st c="46087">repository transactions.</st></span></p>
			<p><st c="46111">Flask has </st><em class="italic"><st c="46122">Flask-SQLAlchemy</st></em><st c="46138">, </st><em class="italic"><st c="46140">Flask-WTF</st></em><st c="46149">, </st><em class="italic"><st c="46151">Flask-Session</st></em><st c="46164">, </st><em class="italic"><st c="46166">Flask-CORS</st></em><st c="46176">, and </st><em class="italic"><st c="46182">Flask-Login</st></em><st c="46193"> that can lessen the cost and time of development. </st><st c="46244">Other than that, stable and up-to-date extensions are available to help a Flask application secure its internals, run on an HTTPS platform, and protect its form handling from </st><strong class="bold"><st c="46419">Cross-Site Request Forgery</st></strong><st c="46445"> (</st><strong class="bold"><st c="46447">CSRF</st></strong><st c="46451">) problems. </st><st c="46464">On the other hand, Flask can use SQLAlchemy, Pony, or Peewee to manage data persistency and protect applications from SQL injection. </st><st c="46597">Also, the framework can  can manage NoSQL data using MongoDB, Neo4j, Redis, and </st><span class="No-Break"><st c="46676">CouchBase databases.</st></span></p>
			<p><st c="46696">Flask can also build WebSocket and SSE using standard and </st><span class="No-Break"><strong class="source-inline"><st c="46755">asyncio</st></strong></span><span class="No-Break"><st c="46762"> platforms.</st></span></p>
			<p><st c="46773">This last chapter has added, to Flask’s long list of capabilities and strengths, the ability to connect to various Python frameworks and to provide interfaces and services to applications outside the </st><span class="No-Break"><st c="46974">Python environment.</st></span></p>
			<p><st c="46993">Aside from managing project modules using Blueprints, Flask can use Werkzeug’s</st><strong class="bold"><st c="47072"> DispatcherMiddleware</st></strong><st c="47093"> to dispatch requests to other mounted WSGI applications such as Django and Flask sub-applications and compatible ASGI applications, such as FastAPI. </st><st c="47243">This mechanism shows Flask’s interoperability feature, which can lead to building microservices. </st><st c="47340">On the other hand, Flask can help provide services to Flutter apps, React web UIs, and GraphQL Explorer to run platform-agnostic </st><span class="No-Break"><st c="47469">query transactions.</st></span></p>
			<p><st c="47488">Hopefully, this book showcased Flask’s strengths as a web and API framework cover to cover and also helped discover some of its downsides along the way. </st><st c="47642">Flask 3.x is a lightweight Python framework that can offer many things in building enterprise-grade small-, middle-, and hopefully </st><span class="No-Break"><st c="47773">large-scale applications.</st></span></p>
			<p><st c="47798">This book has led us on a long journey of learning, understanding, and hands-on experience about Flask 3’s core and new asynchronous features. </st><st c="47942">I hope this reference book has provided the ideas and solutions that may help create the necessary features, deliverables, or systems for your business requirements, software designs, or daily goals and targets. </st><st c="48154">Thank you very much for choosing this book as your companion for knowledge. </st><st c="48230">And do not forget to share your Flask experiences with others because mastering something starts with sharing what </st><span class="No-Break"><st c="48345">you learned.</st></span></p>
		</div>
	<div id="charCountTotal" value="48357"/></body></html>