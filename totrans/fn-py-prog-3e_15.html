<html><head></head><body>
<section id="chapter-15-a-functional-approach-to-web-services" class="level2 chapterHead" data-number="0.19">&#13;
<h2 class="chapterHead" data-number="0.19"><span class="titlemark"> 15</span><br/>&#13;
<span id="x1-31200015"/>A Functional Approach to Web Services</h2>&#13;
<p>We’ll step away from the topic of exploratory data analysis to look at web servers and web services. A web server is, to an extent, a cascade of functions. We can apply a number of functional design patterns to the problem of presenting web content. Our goal is to look at ways in which we can approach<span id="dx1-312001"/> <span class="keyWord">Representational State Transfer </span>(<span class="keyWord">REST</span>). We want to build RESTful web services using functional design patterns.</p>&#13;
<p>We don’t need to invent yet another Python web framework. Nor do we want to select from among the available frameworks. There are many web frameworks available in Python, each with a distinct set of features and advantages.</p>&#13;
<p>The intent of this chapter is to present some principles that can be applied to most of the available frameworks. This will let us leverage functional design patterns for presenting web content.</p>&#13;
<p>When we look at extremely large or complex datasets, we might want a web service that supports subsetting or searching. We might also want a website that can download subsets in a variety of formats. In this case, we might need to use functional designs to create RESTful web services to support these more sophisticated requirements.</p>&#13;
<p>Interactive web applications often rely on stateful sessions to make the site easier for people to use. A user’s session information is updated with data provided through HTML forms, fetched from databases, or recalled from caches of previous interactions. Because the stateful data must be fetched as part of each transaction, it becomes more like an input parameter or result value. This can lead to functional-style programming even in the presence of cookies and database updates.</p>&#13;
<p>In this chapter, we’ll look at several topics:</p>&#13;
<ul>&#13;
<li><p>The general idea of the HTTP request and response model.</p></li>&#13;
<li><p>The <span class="keyWord">Web Server Gateway Interface </span>(<span class="keyWord">WSGI</span>) standard that Python applications use.</p></li>&#13;
<li><p>Leveraging WSGI, where it’s possible to define web services as functions. This fits with the HTTP idea of a stateless server.</p></li>&#13;
<li><p>We’ll also look at ways to authorize client applications to make use of a web service.</p></li>&#13;
</ul>&#13;
<p><span id="x1-312002r317"/></p>&#13;
<section id="the-http-request-response-model" class="level3 sectionHead" data-number="0.19.1">&#13;
<h3 class="sectionHead" data-number="0.19.1"><span class="titlemark">15.1 </span> <span id="x1-3130001"/>The HTTP request-response model</h3>&#13;
<p>The HTTP protocol is nearly stateless: a user agent (or browser) makes a request and the server provides a response. For services<span id="dx1-313001"/> that don’t involve cookies, a client application can take a functional view of the protocol. We can build a client using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">http.client</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">urllib.request</code></span></span> module. An HTTP user agent can be implemented as a function like the following:</p>&#13;
<pre id="listing-301" class="lstlisting"><code>import urllib.request &#13;
 &#13;
def urllib_get(url: str) -&gt; tuple[int, str]: &#13;
    with urllib.request.urlopen(url) as response: &#13;
        body_bytes = response.read() &#13;
        encoding = response.headers.get_content_charset("utf-8") &#13;
        return response.status, body_bytes.decode(encoding)</code></pre>&#13;
<p>A program like <span class="keyWord">wget</span><span id="dx1-313009"/> or <span class="keyWord">curl</span><span id="dx1-313010"/> does this kind of processing using a URL supplied as a command-line argument. A browser does this in response to the user pointing and clicking; the URL is taken from the user’s actions, often the action of clicking on linked text or images.</p>&#13;
<p>Note that a page’s encoding<span id="dx1-313011"/> is often described in two separate places in the response. The HTTP headers will often name the encoding in use. In this example, the default of <span class="obeylines-h"><span class="verb"><code class="inlineCode">"utf-8"</code></span></span> is supplied in the rare case that the headers are incomplete. In addition, the HTML content can <span class="cmti-10x-x-109">also </span>provide encoding information. Specifically, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">&lt;meta</code><code class="inlineCode"> charset="utf-8"&gt;</code></span></span> tag can claim an encoding. Ideally, it’s the same as the encoding noted in the headers. Alternatively, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">&lt;meta</code><code class="inlineCode"> http-equiv...&gt;</code></span></span> tag can provide an encoding.</p>&#13;
<p>While HTTP processing is stateless, the practical considerations<span id="dx1-313012"/> of <span class="keyWord">user</span> <span class="keyWord">experience </span>(<span class="keyWord">UX</span>) design lead to some implementation details that need to be stateful. For human users to feel comfortable, it’s essential for the server to know what they’ve been doing and retain a transaction state. This is implemented by making the client software (browser or mobile application) track cookies. To make cookies work, a response header provides the cookie data, and subsequent requests must return the saved cookies to the server.</p>&#13;
<p>An HTTP response will include a status code. In some cases, this status code will require additional actions on the part of the user agent. Many status codes in the 300-399 range indicate that the requested resource has been moved. The application or browser is then required to save details from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Location</code></span></span> header and request a new URL. The 401 status code indicates that authentication is required; the user agent must make another request using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Authorization</code></span></span> header that contains credentials for access to the server. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">urllib</code></span></span> library implementation handles this stateful client processing. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">http.client</code></span></span> library is similar, but doesn’t automatically follow 3xx redirect status codes.</p>&#13;
<p>Looking at the other side of the protocol, a static content server can be stateless. We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">http.server</code></span></span> library for this, as follows:</p>&#13;
<pre id="listing-302" class="lstlisting"><code>from http.server import HTTPServer, SimpleHTTPRequestHandler &#13;
from typing import NoReturn &#13;
 &#13;
def server_demo() -&gt; NoReturn: &#13;
    httpd = HTTPServer( &#13;
          (’localhost’, 8080), &#13;
          SimpleHTTPRequestHandler &#13;
    ) &#13;
    print(f"Serving on http://localhost:8080...") &#13;
    while True: &#13;
        httpd.handle_request() &#13;
    httpd.shutdown()</code></pre>&#13;
<p>We created a <span class="obeylines-h"><span class="verb"><code class="inlineCode">server</code></span></span> object, and assigned it to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">httpd</code></span></span> variable. We provided the address, <span class="obeylines-h"><span class="verb"><code class="inlineCode">localhost</code></span></span>, and port number <span class="obeylines-h"><span class="verb"><code class="inlineCode">8080</code></span></span>. As part of accepting<span id="dx1-313025"/> the request, the HTTP protocol will allocate another port; this is used to create an instance of the handler class. Listening on one port but doing the work on other ports allows a server to process numerous requests concurrently.</p>&#13;
<p>In this example, we provided <span class="obeylines-h"><span class="verb"><code class="inlineCode">SimpleHTTPRequestHandler</code></span></span> as the class to instantiate with each request. This class must implement a minimal interface, which will send headers and then send the body of the response to the client. This particular class will serve files from the local directory. If we wish to customize this, we can create a subclass that implements methods such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">do_GET()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">do_POST()</code></span></span> to alter the behavior.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">HTTPServer</code></span></span> class has a <span class="obeylines-h"><span class="verb"><code class="inlineCode">serve_forever()</code></span></span> method that saves having to write an explicit <span class="obeylines-h"><span class="verb"><code class="inlineCode">while</code></span></span> statement. We’ve shown the <span class="obeylines-h"><span class="verb"><code class="inlineCode">while</code></span></span> statement here to clarify that the server must, generally, be crashed with an interrupt signal if we need to stop it.</p>&#13;
<p>This example uses port number 8080, one that doesn’t require elevated privileges. Web servers generally use ports 80 and 443. These require elevated privileges. Generally, it’s best to use a server like <span class="keyWord">NGINX</span><span id="dx1-313026"/> or Apache<span id="dx1-313027"/> <span class="keyWord">httpd </span>to manage the privileged ports. <span id="x1-313028r322"/></p>&#13;
<section id="injecting-state-through-cookies" class="level4 subsectionHead" data-number="0.19.1.1">&#13;
<h4 class="subsectionHead" data-number="0.19.1.1"><span class="titlemark">15.1.1 </span> <span id="x1-3140001"/>Injecting state through cookies</h4>&#13;
<p>The addition<span id="dx1-314001"/> of cookies<span id="dx1-314002"/> changes the overall relationship between a client and server to become stateful. Interestingly, it involves no change to HTTP. The state information is communicated through headers on the request and the reply. The server will send cookies to the user agent in response headers. The user agent will save and reply with cookies in request headers.</p>&#13;
<p>The user agent or browser is required to retain a cache of cookie values, provided as part of a response, and include appropriate cookies in subsequent requests. The web server will look for cookies in the request header and provide updated cookies in the response header. The effect is to make the web <span class="cmti-10x-x-109">server</span> stateless; the state changes happen only in the <span class="cmti-10x-x-109">client</span>. Because a server sees cookies as additional arguments in a request and provides additional details in a response, this shapes our view of the function that responds to a request.</p>&#13;
<p>Cookies can contain anything that fits in 4,096 bytes. They are often encrypted to avoid exposing web server details to other applications running on the client computer. Transmitting large cookies can be slow, and should be avoided. The best practice is to keep session information in a database, and provide only a database key in a cookie. This makes the session persistent, and allows session processing to be handled by any available web server, allowing load-balancing among servers.</p>&#13;
<p>The concept of a <span class="keyWord">session</span><span id="dx1-314003"/> is a feature of the web application software, not HTTP. A session is commonly implemented via a cookie to retain session information. When an initial request is made, no cookie is available, and a new session cookie is created. Every subsequent request will include the cookie’s value. A logged-in user will have additional details in their session cookie. A session can last as long as the server is willing to accept the cookie; a cookie could be valid forever, or expire after a few minutes.</p>&#13;
<p>A RESTful approach to web services<span id="dx1-314004"/> does <span class="cmti-10x-x-109">not </span>rely on sessions or cookies. Each REST request is distinct. In many cases, an <span class="obeylines-h"><span class="verb"><code class="inlineCode">Authorization</code></span></span> header is provided with each request to provide credentials for authentication and authorization. This generally means that a separate client-facing application must create a pleasing user experience, often involving sessions. A common architecture is a front-end application, perhaps a mobile app or browser-based site to provide a view of the supporting RESTful web services.</p>&#13;
<p>We’ll focus on RESTful web services in this chapter. The RESTful approach fits well with stateless functional design patterns.</p>&#13;
<p>One consequence of sessionless REST processes is each individual REST request is separately authenticated. This generally means the REST service must also use <span class="keyWord">Secure Socket Layer </span>(<span class="keyWord">SSL</span>) protocols.<span id="dx1-314005"/> The <span class="obeylines-h"><span class="verb"><code class="inlineCode">HTTPS</code></span></span> scheme is required to transmit credentials securely from client to server. <span id="x1-314006r325"/></p>&#13;
</section>&#13;
<section id="considering-a-server-with-a-functional-design" class="level4 subsectionHead" data-number="0.19.1.2">&#13;
<h4 class="subsectionHead" data-number="0.19.1.2"><span class="titlemark">15.1.2 </span> <span id="x1-3150002"/>Considering a server with a functional design</h4>&#13;
<p>One core idea behind HTTP<span id="dx1-315001"/> is that the server’s response is a function of the request. Conceptually, a web service should have a top-level implementation that can be summarized as follows:</p>&#13;
<pre id="listing-303" class="lstlisting"><code>response = httpd(request)</code></pre>&#13;
<p>While this is the essence of HTTP, it lacks a number of important details. First, an HTTP request isn’t a simple, monolithic data structure. It has some required parts and some optional parts. A request may have headers, a method (e.g., <span class="obeylines-h"><span class="verb"><code class="inlineCode">GET</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">POST</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">PUT</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">PATCH</code></span></span>, etc.), a URL, and there may be attachments. The URL has several optional parts including a path, a query string, and a fragment identifier. The attachments may include input from HTML forms or uploaded files, or both.</p>&#13;
<p>Second, the response, similarly, has three parts to it. It has a status code, headers, and a response body. Our simplistic model of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">httpd()</code></span></span> function doesn’t cover these additional details.</p>&#13;
<p>We’ll need to expand on this simplistic view to more accurately decompose web processing into useful functions. <span id="x1-315003r326"/></p>&#13;
</section>&#13;
<section id="looking-more-deeply-into-the-functional-view" class="level4 subsectionHead" data-number="0.19.1.3">&#13;
<h4 class="subsectionHead" data-number="0.19.1.3"><span class="titlemark">15.1.3 </span> <span id="x1-3160003"/>Looking more deeply into the functional view</h4>&#13;
<p>Both HTTP<span id="dx1-316001"/> responses and requests have headers that are separate from the body. The request can also have some attached form data or other uploads. Therefore, we can more usefully think of a web server like this:</p>&#13;
<pre id="listing-304" class="lstlisting"><code>headers, content = httpd( &#13;
    headers, request, [attachments, either forms or uploads] &#13;
)</code></pre>&#13;
<p>The request headers may include cookie values, which can be seen as adding more arguments. Additionally, a web server is often dependent on the OS environment in which it’s running. This OS environment data can be considered as yet more arguments being provided as part of the request.</p>&#13;
<p>The <span class="keyWord">Multipurpose Internet Mail Extension </span>(<span class="keyWord">MIME</span>) types<span id="dx1-316005"/> define the kinds of content that a web service might return. MIME describes a large but reasonably well-defined spectrum of content. This can include plain text, HTML, JSON, XML, or any of the wide variety of non-text media that a website might serve.</p>&#13;
<p>There are some common features of HTTP request processing that we’d like to reuse. This idea of reusable elements is what leads to the creation of web service frameworks that fill a spectrum from simple to sophisticated. The ways that functional designs allow us to reuse functions indicate that the functional approach can help in building web services.</p>&#13;
<p>We’ll look at functional design of web services by examining how we can create a pipeline of the various elements of a service response. We’ll do this by nesting the functions for request processing so that inner elements are free from the generic overheads, which are provided by outer elements. This also allows the outer elements to act as filters: invalid requests can yield error responses, allowing the inner function to focus narrowly on the application processing. <span id="x1-316006r327"/></p>&#13;
</section>&#13;
<section id="nesting-the-services" class="level4 subsectionHead" data-number="0.19.1.4">&#13;
<h4 class="subsectionHead" data-number="0.19.1.4"><span class="titlemark">15.1.4 </span> <span id="x1-3170004"/>Nesting the services</h4>&#13;
<p>We can look at web request-handling as a number<span id="dx1-317001"/> of layered contexts. The foundation might cover session management: examining the request to determine if this is another request in an existing session or a new session. Built on this foundation, another layer can provide tokens used for form processing<span id="dx1-317002"/> that can detect <span class="keyWord">Cross-Site Request Forgeries </span>(<span class="keyWord">CSRF</span>). Another layer on top of these might handle user authentication within a session.</p>&#13;
<p>A conceptual view of the functions explained previously is something like this:</p>&#13;
<pre id="listing-305" class="lstlisting"><code>response = content( &#13;
    authentication( &#13;
        csrf( &#13;
            session(headers, request, forms) &#13;
        ) &#13;
    ) &#13;
)</code></pre>&#13;
<p>The idea here is that each function can build on the results of the previous function. Each function either enriches the request or rejects it because it’s invalid. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">session()</code></span></span> function, for example, can use headers to determine if this is an existing session or a new session. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">csrf()</code></span></span> function will examine form input to ensure that proper tokens were used. The CSRF handling requires a valid session. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">authentication()</code></span></span> function can return an error response for a session that lacks valid credentials; it can enrich the request with user information when valid credentials are present.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">content()</code></span></span> function is free from worrying about sessions, forgeries, and non- authenticated users. It can focus on parsing the path to determine what kind of content should be provided. In a more complex application, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">content()</code></span></span> function may include a rather complex mapping from path elements to the functions that determine the appropriate content.</p>&#13;
<p>This nested function view suffers from a profound problem. The stack of functions is defined to be used in a specific order. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">csrf()</code></span></span> function must be done first to provide useful information to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">authentication()</code></span></span> function. However, we can imagine a high-security scenario where authentication must be done before the CSRF tokens can be checked. We don’t want to have to define unique functions for each possible web architecture.</p>&#13;
<p>While each context must have a distinct<span id="dx1-317010"/> focus, it would be more helpful to have a single, unified view of request and response processing. This allows pieces to be built independently. A useful website would be a composition of a number of disparate functions.</p>&#13;
<p>With a standardized interface, we can combine functions to implement the required features. This will fit the functional programming objectives of having succinct and expressive programs that provide web content. The WSGI standard provides a uniform way to build complex services as a composition of parts. <span id="x1-317011r324"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="the-wsgi-standard" class="level3 sectionHead" data-number="0.19.2">&#13;
<h3 class="sectionHead" data-number="0.19.2"><span class="titlemark">15.2 </span> <span id="x1-3180002"/>The WSGI standard</h3>&#13;
<p>The <span class="keyWord">Web Server Gateway Interface </span>(<span class="keyWord">WSGI</span>) defines a standard<span id="dx1-318001"/> interface for creating a response to a web request. This is a common framework for most Python-based web servers. A great deal of information is present at the following link: <a href="http://wsgi.readthedocs.org/en/latest/" class="url">http://wsgi.readthedocs.org/en/latest/</a>.</p>&#13;
<div id="tcolobox-291" class="infobox note">&#13;
&#13;
&#13;
<p>Some important background on WSGI can be found at <a href="https://www.python.org/dev/peps/pep-0333/" class="url">https://www.python.org/dev/peps/pep-0333/</a>.</p>&#13;
&#13;
</div>&#13;
<p>The Python library’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">wsgiref</code></span></span> package includes a reference implementation of WSGI. Each WSGI <span class="keyWord">application</span><span id="dx1-318002"/> has the same interface, as shown here:</p>&#13;
<pre id="listing-306" class="lstlisting"><code>def some_app(environ, start_response): &#13;
    # compute the status, headers, and content of the response &#13;
    start_response(status, headers) &#13;
    return content</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">environ</code></span></span> parameter is a dictionary that contains all of the arguments of the request in a single, uniform structure. The headers, the request method, the path, and any attachments for forms or file uploads will all be in the environment dictionary. In addition to this, the OS-level context is also provided, along with a few items that are part of WSGI request handling.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">start_response</code></span></span> parameter is a function that must be used to send the status and headers of a response. The portion of a WSGI server that has the final responsibility for building the response will use the given <span class="obeylines-h"><span class="verb"><code class="inlineCode">start_response()</code></span></span> function and will also build the response document as the return value.</p>&#13;
<p>The response returned from a WSGI application<span id="dx1-318007"/> is a sequence of strings or string-like file wrappers that will be returned to the user agent. If an HTML template tool is used, then the sequence may have a single item. In some cases, such as using the <span class="keyWord">Jinja2 </span>templates to build HTML content, the template can be rendered lazily as a sequence of text chunks. This allows a server to interleave template filling with downloading to the user agent.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">wsgiref</code></span></span> package does not have a complete set of type definitions. This is not a problem in general. For example, within the <span class="obeylines-h"><span class="verb"><code class="inlineCode">werkzeug</code></span></span> package, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">werkzeug.wsgi</code></span></span> module has useful type definitions. Because the <span class="obeylines-h"><span class="verb"><code class="inlineCode">werkzeug</code></span></span> package is generally installed with Flask, it is very handy for our purposes.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">werkzeug.wsgi</code></span></span> module<span id="dx1-318008"/> includes a stubs file with a number of useful type hints. These hints are not part of the working application; they’re only used by the <span class="keyWord">mypy </span>tool.<span id="dx1-318009"/> We can study the following <span class="obeylines-h"><span class="verb"><code class="inlineCode">werkzeug.wsgi</code></span></span> type hints for a WSGI application:</p>&#13;
<pre id="listing-307" class="lstlisting"><code>from sys import _OptExcInfo &#13;
from typing import Any, Callable, Dict, Iterable, Protocol &#13;
 &#13;
class StartResponse(Protocol): &#13;
    def __call__( &#13;
        self, status: str, headers: list[tuple[str, str]], exc_info: "_OptExcInfo" | None = ... &#13;
    ) -&gt; Callable[[bytes], Any]: ... &#13;
 &#13;
WSGIEnvironment = Dict[str, Any] &#13;
WSGIApplication = Callable[[WSGIEnvironment, StartResponse], Iterable[bytes]]</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">WSGIEnvironment</code></span></span> type hint defines a dictionary with no useful boundaries on the values. It’s difficult to enumerate all of the possible types of values defined by the WSGI standard. Instead of an exhaustively complex definition, it seems better to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">Any</code></span></span>.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">StartResponse</code></span></span> type hint is the signature for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">start_response()</code></span></span> function provided to a WSGI application. This is defined as a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Protocol</code></span></span> to show the presence of an optional third parameter with exception information.</p>&#13;
<p>An overall WSGI application, <span class="obeylines-h"><span class="verb"><code class="inlineCode">WSGIApplication</code></span></span>, requires the environment and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">start_response()</code></span></span> function. The result is an iterable collection of bytes.</p>&#13;
<p>The idea behind these hints is to allow us to define an application as follows:</p>&#13;
<pre id="listing-308" class="lstlisting"><code>from typing import TYPE_CHECKING &#13;
 &#13;
if TYPE_CHECKING: &#13;
    from _typeshed.wsgi import ( &#13;
        WSGIApplication, WSGIEnvironment, StartResponse &#13;
    ) &#13;
 &#13;
def static_text_app( &#13;
    environ: "WSGIEnvironment", &#13;
    start_response: "StartResponse" &#13;
) -&gt; Iterable[bytes]: &#13;
    ...</code></pre>&#13;
<p>We’ve included a conditional <span class="obeylines-h"><span class="verb"><code class="inlineCode">import</code></span></span> to provide the type hints only when running the <span class="keyWord">mypy </span>tool. Outside using the <span class="keyWord">mypy </span>tool, the type hints are provided as strings. This additional clarification can help explain the design of a complex collection of functions that respond to web requests.</p>&#13;
<p>Each WSGI application<span id="dx1-318032"/> needs to be designed as a collection of functions. The collection can be viewed as nested functions or as a chain of transformations. Each application in the chain will either return an error or will hand the request to another application that will determine the final result.</p>&#13;
<p>Often, the URL path is used to determine which of many alternative applications will be used. This will lead to a tree of WSGI applications that may share common components.</p>&#13;
<p>Here’s a very simple routing application that takes the first element of the URL path and uses this to locate another WSGI application that provides content:</p>&#13;
<pre id="listing-309" class="lstlisting"><code>from wsgiref.simple_server import demo_app &#13;
 &#13;
SCRIPT_MAP: dict[str, "WSGIApplication"] = { &#13;
    "demo": demo_app, &#13;
    "static": static_text_app, &#13;
    "index.html": welcome_app, &#13;
    "": welcome_app, &#13;
} &#13;
 &#13;
def routing( &#13;
        environ: "WSGIEnvironment", &#13;
        start_response: "StartResponse" &#13;
) -&gt; Iterable[bytes]: &#13;
    top_level = wsgiref.util.shift_path_info(environ) &#13;
    if top_level: &#13;
        app = SCRIPT_MAP.get(top_level, welcome_app) &#13;
    else: &#13;
        app = welcome_app &#13;
    content = app(environ, start_response) &#13;
    return content</code></pre>&#13;
<p>This application<span id="dx1-318053"/> will use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">wsgiref.util.shift_path_info()</code></span></span> function to tweak the environment. The change is a <span class="cmti-10x-x-109">head</span>/<span class="cmti-10x-x-109">tail split </span>on the request path, available in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">environ[’</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">PATH_INFO’]</code></span></span> dictionary. The head of the path, up to the first <span class="obeylines-h"><span class="verb"><code class="inlineCode">"/"</code></span></span>, will be assigned to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">SCRIPT_NAME</code></span></span> item in the environment; the <span class="obeylines-h"><span class="verb"><code class="inlineCode">PATH_INFO</code></span></span> item will be updated to have the tail of the path. The returned value will also be the head of the path, the same value as <span class="obeylines-h"><span class="verb"><code class="inlineCode">environ[’SCRIPT_NAME’]</code></span></span>. In the case where there’s no path to parse, the return value is <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> and no environment updates are made.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">routing()</code></span></span> function uses the first item on the path to locate an application in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">SCRIPT_MAP</code></span></span> dictionary. We use <span class="obeylines-h"><span class="verb"><code class="inlineCode">welcome_app</code></span></span> as a default in case the requested path doesn’t fit the mapping. This seems a little better than an HTTP <span class="obeylines-h"><span class="verb"><code class="inlineCode">404</code><code class="inlineCode"> NOT</code><code class="inlineCode"> FOUND</code></span></span> error.</p>&#13;
<p>This WSGI application<span id="dx1-318054"/> is a function that chooses between a number of other WSGI functions. Note that the routing function doesn’t return a function; it provides the modified environment to the selected WSGI application. This is the typical design pattern for handing off the work from one function to another.</p>&#13;
<p>From this, we can see how a framework could generalize the path-matching process, using regular expressions. We can imagine configuring the <span class="obeylines-h"><span class="verb"><code class="inlineCode">routing()</code></span></span> function with a sequence of regular expressions and WSGI applications, instead of a mapping from a string to the WSGI application. The enhanced <span class="obeylines-h"><span class="verb"><code class="inlineCode">routing()</code></span></span> function application would evaluate each regular expression looking for a match. In the case of a match, any <span class="obeylines-h"><span class="verb"><code class="inlineCode">match.groups()</code></span></span> function could be used to update the environment before calling the requested application. <span id="x1-318055r328"/></p>&#13;
<section id="raising-exceptions-during-wsgi-processing" class="level4 subsectionHead" data-number="0.19.2.1">&#13;
<h4 class="subsectionHead" data-number="0.19.2.1"><span class="titlemark">15.2.1 </span> <span id="x1-3190001"/>Raising exceptions during WSGI processing</h4>&#13;
<p>One central feature of WSGI applications<span id="dx1-319001"/> is that each stage along the chain is responsible for filtering the requests. The idea is to reject faulty requests as early in the processing as possible. When building a pipeline of independent WSGI applications, each stage has the following two essential choices:</p>&#13;
<ul>&#13;
<li><p>Evaluate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">start_response()</code></span></span> function to start a reply with an error status</p></li>&#13;
<li><p>OR pass the request with an expanded environment to the next stage</p></li>&#13;
</ul>&#13;
<p>Consider a WSGI application that provides small text files. A file may not exist, or a request may refer to a directory of files. We can define a WSGI application that provides static content as follows:</p>&#13;
<pre id="listing-310" class="lstlisting"><code>def headers(content: bytes) -&gt; list[tuple[str, str]]: &#13;
    return [ &#13;
        ("Content-Type", ’text/plain;charset="utf-8"’), &#13;
        ("Content-Length", str(len(content))), &#13;
    ] &#13;
 &#13;
def static_text_app( &#13;
    environ: "WSGIEnvironment", &#13;
    start_response: "StartResponse" &#13;
) -&gt; Iterable[bytes]: &#13;
    log = environ[’wsgi.errors’] &#13;
    try: &#13;
        static_path = Path.cwd() / environ[’PATH_INFO’][1:] &#13;
        with static_path.open() as static_file: &#13;
            print(f"{static_path=}", file=log) &#13;
            content = static_file.read().encode("utf-8") &#13;
            start_response(’200 OK’, headers(content)) &#13;
            return [content] &#13;
    except IsADirectoryError as exc: &#13;
        return index_app(environ, start_response) &#13;
    except FileNotFoundError as exc: &#13;
        print(f"{static_path=} {exc=}", file=log) &#13;
        message = f"Not Found {environ[’PATH_INFO’]}".encode("utf-8") &#13;
        start_response(’404 NOT FOUND’, headers(message)) &#13;
        return [message]</code></pre>&#13;
<p>This application<span id="dx1-319027"/> creates a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Path</code></span></span> object from the current working directory and an element of the path provided as part of the requested URL. The path information is part of the WSGI environment, in an item with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">’PATH_INFO’</code></span></span> key. Because of the way the path is parsed, it will have a leading ”/”, which we discard by using <span class="obeylines-h"><span class="verb"><code class="inlineCode">environ[’PATH_INFO’][1:]</code></span></span>.</p>&#13;
<p>This application tries to open the requested path as a text file. There are two common problems, both of which are handled as exceptions:</p>&#13;
<ul>&#13;
<li><p>If the file is a directory, we’ll route the request to a different WSGI application, <span class="obeylines-h"><span class="verb"><code class="inlineCode">index_app</code></span></span>, to present directory contents</p></li>&#13;
<li><p>If the file is simply not found, we’ll return an HTTP <span class="obeylines-h"><span class="verb"><code class="inlineCode">404</code><code class="inlineCode"> NOT</code><code class="inlineCode"> FOUND</code></span></span> response</p></li>&#13;
</ul>&#13;
<p>Any other exceptions raised by this WSGI application will not be caught. The application that invoked this application should be designed with some generic error-response capability. If the application doesn’t handle the exceptions, a generic WSGI failure response will be used.</p>&#13;
<div id="tcolobox-292" class="packt_tip">&#13;
&#13;
&#13;
<p>Our processing involves a strict ordering of operations. We must read the entire file so that we can create a proper HTTP Content-Length header.</p>&#13;
&#13;
</div>&#13;
<p>This small application<span id="dx1-319028"/> shows the WSGI idea of either responding or passing the request onto another application that forms the response. This respond-now-or-forward design pattern enables the building of multi-stage pipelines. Each stage either rejects the request, handles it completely, or passes it on to some other application.</p>&#13;
<p>These pipelines are often called <span class="keyWord">middleware</span><span id="dx1-319029"/> because they are between a base server (like <span class="keyWord">NGINX</span>) and the final web application or RESTful API. The idea is to use middleware to perform a series of common filters or mappings for each request. <span id="x1-319030r330"/></p>&#13;
</section>&#13;
<section id="pragmatic-web-applications" class="level4 subsectionHead" data-number="0.19.2.2">&#13;
<h4 class="subsectionHead" data-number="0.19.2.2"><span class="titlemark">15.2.2 </span> <span id="x1-3200002"/>Pragmatic web applications</h4>&#13;
<p>The intent of the WSGI standard<span id="dx1-320001"/> is not to define a complete web framework; the intent is to define a minimum set of standards that allows flexible interoperability of web-related processing. This minimum fits well with functional programming concepts.</p>&#13;
<p>A web application framework is focused on the needs of developers. It should offer numerous simplifications to providing web services. The foundational interface must be compatible with WSGI, so that it can be used in a variety of contexts. The developer’s view, however, will diverge from the minimal WSGI definitions.</p>&#13;
<p>Web servers such as <span class="keyWord">Apache httpd</span><span id="dx1-320002"/> or <span class="keyWord">NGINX</span><span id="dx1-320003"/> have adapters to provide a WSGI-compatible interface from the web server to Python applications. For more information on WSGI implementations, visit <a href="https://wiki.python.org/moin/WSGIImplementations" class="url">https://wiki.python.org/moin/WSGIImplementations</a>.</p>&#13;
<p>Embedding our applications in a larger server allows us to have a tidy separation of concerns. We can use Apache <span class="keyWord">httpd </span>or <span class="keyWord">NGINX </span>to serve the static content, such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">.css</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">.js</code></span></span>, and image files. For HTML pages, though, a server like <span class="keyWord">NGINX </span>can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">uwsgi</code></span></span> module to hand off requests to a pool of Python processes. This focuses Python on handling the interestingly complex HTML portions of the web content.</p>&#13;
<p>Downloading static content requires little customization. There’s often no application-specific processing. This is best handled in a separate service that can be optimized to perform this fixed task.</p>&#13;
<p>The processing for dynamic content (often the HTML content of a web page) is where the interesting Python-based work happens. This work can be segregated to servers that are optimized to run this more complex application-specific computation.</p>&#13;
<p>Separating the static content from the dynamic<span id="dx1-320004"/> content to provide optimized downloads means that we must either create a separate media server, or define our website to have two sets of paths. For smaller sites, a separate <span class="obeylines-h"><span class="verb"><code class="inlineCode">/media</code></span></span> path works out nicely. For larger sites, distinct media servers are required.</p>&#13;
<p>An important consequence of the WSGI definition is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">environ</code></span></span> dictionary is often updated with additional configuration parameters. In this way, some WSGI applications can serve as gateways to enrich the environment with information extracted from cookies, headers, configuration files, or databases. <span id="x1-320005r329"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="defining-web-services-as-functions" class="level3 sectionHead" data-number="0.19.3">&#13;
<h3 class="sectionHead" data-number="0.19.3"><span class="titlemark">15.3 </span> <span id="x1-3210003"/>Defining web services as functions</h3>&#13;
<p>We’ll look at a RESTful<span id="dx1-321001"/> web service, which can slice and dice a source of data and provide downloads as JSON, XML, or CSV files.</p>&#13;
<p>The direct use of WSGI for this kind of application isn’t optimal because we need to create a great deal of ”boilerplate” processing for all the details of conventional website processing. A more effective approach is to use a more sophisticated web server like Flask,<span id="dx1-321002"/> Django,<span id="dx1-321003"/> Bottle, or any of the frameworks listed here: <a href="https://wiki.python.org/moin/WebFrameworks" class="url">https://wiki.python.org/moin/WebFrameworks</a>. These servers handle the conventional cases more completely, allowing us—as developers—to focus on the unique features of a page or site.</p>&#13;
<p>We’ll use a simple dataset with four series of data pairs: the Anscombe Quartet. We looked at ways to read and parse this data in <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions, Iterators,</span> <span class="cmti-10x-x-109">and Generators</span></a>. It’s a small set of data, but it can be used to show the principles of a RESTful web service.</p>&#13;
<p>We’ll split our application into two tiers: a web tier, which will provide the visible RESTful web service, and a data service tier, which will manage the underlying data. We’ll look at the web tier first, as this provides a context in which the data service tier must operate.</p>&#13;
<p>A request must include these two pieces of information:</p>&#13;
<ul>&#13;
<li><p>The series of data that is desired. The idea is to slice up the pool of available information by filtering and extracting the desired subset.</p></li>&#13;
<li><p>The output format that the user needs. This includes common serialization formats like HTML, CSV, JSON, and XML.</p></li>&#13;
</ul>&#13;
<p>The series selection is commonly<span id="dx1-321004"/> done through the request path. We can request <span class="obeylines-h"><span class="verb"><code class="inlineCode">/anscombe/I</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">/anscombe/II</code></span></span> to pick specific series from the quartet. Path design is important, and this seems to be the right way to identify the data.</p>&#13;
<p>The following two underlying ideas help define paths:</p>&#13;
<ul>&#13;
<li><p>A URL defines a resource</p></li>&#13;
<li><p>There’s no good reason for the URL to ever change</p></li>&#13;
</ul>&#13;
<p>In this case, the dataset selectors of <span class="obeylines-h"><span class="verb"><code class="inlineCode">I</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">II</code></span></span> aren’t dependent on publication dates or some organizational approval status, or other external factors. This design seems to create URLs that are timeless and absolute.</p>&#13;
<p>The output format, on the other hand, is not a first-class part of the URL. It is merely a serialization format, not the data itself. One choice is to name the format in the HTTP <span class="obeylines-h"><span class="verb"><code class="inlineCode">Accept</code></span></span> header. In some cases, to make things easy to use from a browser, a query string can be used to specify the output format. One approach is to use the query to specify the serialization format. We might use <span class="obeylines-h"><span class="verb"><code class="inlineCode">?form=json</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">?format=json</code></span></span>, or even <span class="obeylines-h"><span class="verb"><code class="inlineCode">?output_serialization=json</code></span></span> at the end of the path to specify that the output serialization format should be JSON. The HTTP <span class="obeylines-h"><span class="verb"><code class="inlineCode">Accept</code></span></span> header is preferred, but hard to experiment with using only a browser.</p>&#13;
<p>A browser-friendly URL we can use will look like this:</p>&#13;
<pre id="listing-311" class="lstlisting"><code>http://localhost:8080/anscombe/III?form=csv</code></pre>&#13;
<p>This would request a download of the third series in CSV format.</p>&#13;
<p>The OpenAPI Specification provides a way to define the family of URLs and the expected results. This specification<span id="dx1-321006"/> is helpful because it serves as a clear, formal contract for the web server’s expected behavior. What’s most helpful about the OpenAPI specification is having a concrete list of paths, parameters, and responses. A good specification will include examples, helping the process of writing an acceptance test suite for the server.</p>&#13;
<p>Generally, the OpenAPI specification is provided by the web server to help clients properly use the available services. A URL like <span class="obeylines-h"><span class="verb"><code class="inlineCode">"/openapi.yml"</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">"/openapi.json"</code></span></span> is suggested as a way to provide needed information about a web application. <span id="x1-321007r331"/></p>&#13;
<section id="flask-application-processing" class="level4 subsectionHead" data-number="0.19.3.1">&#13;
<h4 class="subsectionHead" data-number="0.19.3.1"><span class="titlemark">15.3.1 </span> <span id="x1-3220001"/>Flask application processing</h4>&#13;
<p>We’ll use the Flask framework<span id="dx1-322001"/> because it provides an easy-to-extend web services process. It supports a function-based design, with a mapping from a request path to a view function that builds the response. The framework<span id="dx1-322002"/> also makes use of decorators, providing a good fit with functional programming concepts.</p>&#13;
<p>In order to bind all of the configuration and URL routing together, an overall <span class="obeylines-h"><span class="verb"><code class="inlineCode">Flask</code></span></span> instance is used as a container. Our application will be an instance of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Flask</code></span></span> class. As a simplification, each view function is defined separately and bound into the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Flask</code></span></span> instance via a routing table that maps URLs to functions. This routing table is built via decorators.</p>&#13;
<p>The core of the application is this collection of view functions. Generally, each view function needs to do three things:</p>&#13;
<ol>&#13;
<li><div id="x1-322004x1">&#13;
<p>Validate the request.</p>&#13;
</div></li>&#13;
<li><div id="x1-322006x2">&#13;
<p>Perform the requested state change or data access.</p>&#13;
</div></li>&#13;
<li><div id="x1-322008x3">&#13;
<p>Prepare a response.</p>&#13;
</div></li>&#13;
</ol>&#13;
<p>Ideally, the view function does nothing more than this.</p>&#13;
<p>Here’s the initial <span class="obeylines-h"><span class="verb"><code class="inlineCode">Flask</code></span></span> object that will contain the routes and their functions:</p>&#13;
<pre id="listing-312" class="lstlisting"><code>from flask import Flask &#13;
 &#13;
app = Flask(__name__)</code></pre>&#13;
<p>We’ve created the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Flask</code></span></span> instance and assigned it to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">app</code></span></span> variable. As a handy default, we’ve used the module’s name, <span class="obeylines-h"><span class="verb"><code class="inlineCode">__name__</code></span></span>, as the name of the application. This is often sufficient. For complex<span id="dx1-322012"/> applications, it may be better to provide a name that’s not specifically tied to a Python module or package name.</p>&#13;
<p>Most applications will need to have configuration<span id="dx1-322013"/> parameters provided. In this case, the source data is a configurable value that might change.</p>&#13;
<p>For larger applications, it’s often necessary to locate an entire configuration file. For this small application, we’ll provide the configuration value as a literal:</p>&#13;
<pre id="listing-313" class="lstlisting"><code>from pathlib import Path &#13;
 &#13;
app.config[’FILE_PATH’] = Path.cwd() / "Anscombe.txt"</code></pre>&#13;
<p>Most of the view functions should be relatively small, focused functions that make use of other layers of the application. For this application, the web presentation depends on a data service tier to acquire and format the data. This leads to functions with the following three steps:</p>&#13;
<ol>&#13;
<li><div id="x1-322018x1">&#13;
<p>Validate the various inputs. This includes validating items like the path, any query parameters, form input data, uploaded files, header values, and even cookie values.</p>&#13;
</div></li>&#13;
<li><div id="x1-322020x2">&#13;
<p>If the method involves a state change like <span class="obeylines-h"><span class="verb"><code class="inlineCode">POST</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">PUT</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">PATCH</code></span></span>, or <span class="obeylines-h"><span class="verb"><code class="inlineCode">DELETE</code></span></span>, perform the state-changing operation. These will often return a ”redirect” response to a path that will display the results of the change. If the method involves a <span class="obeylines-h"><span class="verb"><code class="inlineCode">GET</code></span></span> request, gather the requested data.</p>&#13;
</div></li>&#13;
<li><div id="x1-322022x3">&#13;
<p>Prepare the response.</p>&#13;
</div></li>&#13;
</ol>&#13;
<p>What’s important about step 2 is all of the data manipulation is separate from the RESTful web application. The web presentation sits on a foundation of data access and manipulation. The web application is designed as a view or a presentation of the underlying structure.</p>&#13;
<p>We’ll look at two URL paths for the web application. The first path will provide an index of the available<span id="dx1-322023"/> series in the Anscombe<span id="dx1-322024"/> collection. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">view</code></span></span> function can be defined as follows:</p>&#13;
<pre id="listing-314" class="lstlisting"><code>from flask import request, abort, make_response, Response &#13;
 &#13;
@app.route("/anscombe/") &#13;
def index_view() -&gt; Response: &#13;
    # 1. Validate &#13;
    response_format = format() &#13;
    # 2. Get data &#13;
    data = get_series_map(app.config[’FILE_PATH’]) &#13;
    index_listofdicts = [{"Series": k} for k in data.keys()] &#13;
    # 3. Prepare Response &#13;
    try: &#13;
        content_bytes = serialize(response_format, index_listofdicts, document_tag="Index", row_tag="Series") &#13;
        response = make_response(content_bytes, 200, {"Content-Type": response_format}) &#13;
        return response &#13;
    except KeyError: &#13;
        abort(404, f"Unknown {response_format=}")</code></pre>&#13;
<p>This function has the Flask <span class="obeylines-h"><span class="verb"><code class="inlineCode">@app.route</code></span></span> decorator. This shows what URLs should be processed by this <span class="obeylines-h"><span class="verb"><code class="inlineCode">view</code></span></span> function. There are a fair number of options and alternatives available here. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">view</code></span></span> function will be evaluated when a request matches one of the available routes.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">format()</code></span></span> function definition will be shown in a little while. It locates the user’s desired format by looking in two places: the query string, after the <span class="obeylines-h"><span class="verb"><code class="inlineCode">?</code></span></span> in the URL, and also in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Accept</code></span></span> header. If the query string value is invalid, a 404 response will be created.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_series_map()</code></span></span> function is an essential feature of the data service tier. This will locate the Anscombe series data and create a mapping from <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series</code></span></span> name to the data of the series.</p>&#13;
<p>The index information<span id="dx1-322041"/> is in the form of a list-of-dict structure. This structure can be converted to JSON, CSV, and HTML without too much complication. Creating XML is a bit more difficult. The difficulty arises because the Python list and dictionary objects don’t have any specific class name, making it awkward to supply XML tags.</p>&#13;
<p>The data preparation<span id="dx1-322042"/> is performed in two parts. First, the index information is serialized in the desired format. Second, a Flask <span class="obeylines-h"><span class="verb"><code class="inlineCode">Response</code></span></span> object is built using the bytes, an HTTP status code of 200, and a specific value for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Content-Type</code></span></span> header.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">abort()</code></span></span> function stops process and returns an error response with the given code and reason information. For RESTful web services, it helps to add a small helper function to transform the result into JSON. The use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">abort()</code></span></span> function during data validation and preparation makes it easy to end processing at the first problem with the request.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">format()</code></span></span> function is defined as follows:</p>&#13;
<pre id="listing-315" class="lstlisting"><code>def format() -&gt; str: &#13;
    if arg := request.args.get(’form’): &#13;
        try: &#13;
            return { &#13;
                ’xml’: ’application/xml’, &#13;
                ’html’: ’text/html’, &#13;
                ’json’: ’application/json’, &#13;
                ’csv’: ’text/csv’, &#13;
            }[arg] &#13;
        except KeyError: &#13;
            abort(404, "Unknown ?form=") &#13;
    else: &#13;
        return request.accept_mimetypes.best or "text/html"</code></pre>&#13;
<p>This function looks for input from two attributes of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">request</code></span></span> object:</p>&#13;
<ul>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">args</code></span></span> will have the argument values that are present after the ”?” in the URL</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">accept_mimetypes</code></span></span> will have the parsed values from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Accept</code></span></span> header, allowing an application to locate a response that meets the client’s expectations</p></li>&#13;
</ul>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">request</code></span></span> object is a bit of thread-local storage with the details of the web request being made. It is used like a global<span id="dx1-322056"/> variable, making some functions<span id="dx1-322057"/> look a little awkward. The use of a global like <span class="obeylines-h"><span class="verb"><code class="inlineCode">request</code></span></span> tends to obscure the actual parameters to this function. Using explicit parameters requires also providing the underlying type information, which is little more than visual clutter.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">series_view()</code></span></span> function to provide series data is defined as follows:</p>&#13;
<pre id="listing-316" class="lstlisting"><code>@app.route("/anscombe/&lt;series_id&gt;") &#13;
def series_view(series_id: str, form: str | None = None) -&gt; Response: &#13;
    # 1. Validate &#13;
    response_format = format() &#13;
    # 2. Get data (and validate some more) &#13;
    data = get_series_map(app.config[’FILE_PATH’]) &#13;
    try: &#13;
        dataset = anscombe_filter(series_id, data)._as_listofdicts() &#13;
    except KeyError: &#13;
        abort(404, "Unknown Series") &#13;
    # 3. Prepare Response &#13;
    try: &#13;
        content_bytes = serialize(response_format, dataset, document_tag="Series", row_tag="Pair") &#13;
        response = make_response( &#13;
            content_bytes, 200, {"Content-Type": response_format} &#13;
        ) &#13;
        return response &#13;
    except KeyError: &#13;
        abort(404, f"Unknown {response_format=}")</code></pre>&#13;
<p>This function has a similar structure to the previous <span class="obeylines-h"><span class="verb"><code class="inlineCode">index_view()</code></span></span> function. The request is validated, the data acquired, and a response prepared. As with the previous function, the work is delegated to two other data access functions: <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_series_map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">anscombe_filter()</code></span></span>. These are separate from the web application, and could be part of a command-line application.</p>&#13;
<p>Both of these functions depend on an underlying data access layer. We’ll look at those functions in the next section. <span id="x1-322077r333"/></p>&#13;
</section>&#13;
<section id="the-data-access-tier" class="level4 subsectionHead" data-number="0.19.3.2">&#13;
<h4 class="subsectionHead" data-number="0.19.3.2"><span class="titlemark">15.3.2 </span> <span id="x1-3230002"/>The data access tier</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_series_map()</code></span></span> function is similar<span id="dx1-323001"/> to the examples shown in the <a href="Chapter_03.xhtml#x1-590006"><span class="cmti-10x-x-109">Cleaning raw data with generator functions</span></a> section of <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions,</span> <span class="cmti-10x-x-109">Iterators, and Generators</span></a>. In this section, we’ll include some important<span id="dx1-323002"/> changes. We’ll start with the following two <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> definitions:</p>&#13;
<pre id="listing-317" class="lstlisting"><code>from Chapter03.ch03_ex4 import ( &#13;
    series, head_split_fixed, row_iter) &#13;
from collections.abc import Callable, Iterable &#13;
from typing import NamedTuple, Any, cast &#13;
 &#13;
class Pair(NamedTuple): &#13;
    x: float &#13;
    y: float &#13;
 &#13;
    @classmethod &#13;
    def create(cls: type["Pair"], source: Iterable[str]) -&gt; "Pair": &#13;
        return Pair(*map(float, source)) &#13;
 &#13;
class Series(NamedTuple): &#13;
    series: str &#13;
    data: list[Pair] &#13;
 &#13;
    @classmethod &#13;
    def create(cls: type["Series"], name: str, source: Iterable[tuple[str, str]]) -&gt; "Series": &#13;
        return Series(name, list(map(Pair.create, source))) &#13;
 &#13;
    def _as_listofdicts(self) -&gt; list[dict[str, Any]]: &#13;
        return [p._asdict() for p in self.data]</code></pre>&#13;
<p>We’ve defined a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> named tuple and provided a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@classmethod</code></span></span> to build instances of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span>. This definition will automatically provide an <span class="obeylines-h"><span class="verb"><code class="inlineCode">_asdict()</code></span></span> method that responds with a dictionary of the form <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict[str,</code><code class="inlineCode"> Any]</code></span></span> containing the attribute names and values. This is helpful for serialization.</p>&#13;
<p>Similarly, we’ve defined a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series</code></span></span> named tuple. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">create()</code></span></span> method can build a tuple from an iterable source of lists of values. The automatically<span id="dx1-323026"/> provided <span class="obeylines-h"><span class="verb"><code class="inlineCode">_asdict()</code></span></span> method can be helpful for serializing. For this application, however, we’ll make use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">_as_listofdicts</code></span></span> method to create a list of dictionaries that can be serialized.</p>&#13;
<p>The function to produce the mapping<span id="dx1-323027"/> from series name to <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series</code></span></span> object has the following definition:</p>&#13;
<pre id="listing-318" class="lstlisting"><code>from pathlib import Path &#13;
 &#13;
def get_series_map(source_path: Path) -&gt; dict[str, Series]: &#13;
    with source_path.open() as source: &#13;
        raw_data = list(head_split_fixed(row_iter(source))) &#13;
        series_iter = ( &#13;
            Series.create(id_str, series(id_num, raw_data)) &#13;
            for id_num, id_str in enumerate( &#13;
                [’I’, ’II’, ’III’, ’IV’]) &#13;
        ) &#13;
        mapping = { &#13;
            series.series: series &#13;
            for series in series_iter &#13;
        } &#13;
    return mapping</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_series_map()</code></span></span> function opens the local data file, and applies the <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter()</code></span></span> function to each line of the file. This parses the line into a row of separate items. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">head_split_fixed()</code></span></span> function is used to remove the heading from the file. The result is a tuple-of-list structure, which is assigned the variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">raw_data</code></span></span>.</p>&#13;
<p>From the <span class="obeylines-h"><span class="verb"><code class="inlineCode">raw_data</code></span></span> structure, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series.create()</code></span></span> method is used to transform a sequence of values from the file into a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series</code></span></span> object composed of individual <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> instances. The final step is to use a dictionary comprehension to collect the individual <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series</code></span></span> instances into a single mapping from series name to <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series</code></span></span> object.</p>&#13;
<p>Since the output<span id="dx1-323043"/> from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_series_map()</code></span></span> function is a mapping, we can do something like the following example<span id="dx1-323044"/> to pick a specific series by name:</p>&#13;
<div id="tcolobox-293" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; source = Path.cwd() / "Anscombe.txt" &#13;
&gt;&gt;&gt; get_series_map(source)[’I’] &#13;
Series(series=’I’, data=[Pair(x=10.0, y=8.04), Pair(x=8.0, y=6.95), ...])</code></pre>&#13;
&#13;
</div>&#13;
<p>Given a key, for example, <span class="obeylines-h"><span class="verb"><code class="inlineCode">’I’</code></span></span>, the series is a list of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> objects that have the <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">y</code></span></span> values for each item in the series.</p>&#13;
<section id="applying-a-filter" class="level5 likesubsubsectionHead" data-number="0.19.3.2.1">&#13;
<h5 class="likesubsubsectionHead" data-number="0.19.3.2.1"><span id="x1-3240002"/>Applying a filter</h5>&#13;
<p>In this application, we’re using a very simple filter. The entire<span id="dx1-324001"/> filter process is embodied in the following function:</p>&#13;
<pre id="listing-319" class="lstlisting"><code>def anscombe_filter( &#13;
    set_id: str, raw_data_map: dict[str, Series] &#13;
) -&gt; Series: &#13;
    return raw_data_map[set_id]</code></pre>&#13;
<p>We made this trivial expression into a function for three reasons:</p>&#13;
<ul>&#13;
<li><p>The functional notation is slightly more consistent with other parts of the Flask application, and a bit more flexible than the subscript expression</p></li>&#13;
<li><p>We can easily expand the filtering to do more</p></li>&#13;
<li><p>We can include separate unit tests for this function</p></li>&#13;
</ul>&#13;
<p>While a simple lambda would work, it wouldn’t be quite as convenient to test.</p>&#13;
<p>For error handling, we’ve done exactly nothing. We’ve focused on what’s sometimes called the <span class="cmti-10x-x-109">happy path</span>: an ideal sequence of events. Any problems that arise in this function will raise an exception. The WSGI wrapper function should catch all exceptions and return an appropriate status message and error response content.</p>&#13;
<p>For example, it’s possible that the <span class="obeylines-h"><span class="verb"><code class="inlineCode">set_id</code></span></span> method will be wrong in some way. Rather than obsess over all the ways it could be wrong, we’ll allow Python to raise an exception. Indeed, this function<span id="dx1-324006"/> follows Admiral Grace Murray Hopper’s advice that <span class="cmti-10x-x-109">it’s better to seek forgiveness than to ask permission</span>. This advice is materialized in code by avoiding <span class="cmti-10x-x-109">permission-seeking</span>: there are no preparatory <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code></span></span> statements that seek to qualify the arguments as valid. There is only <span class="cmti-10x-x-109">forgiveness</span> handling: an exception will be raised and handled by evaluating the Flask <span class="obeylines-h"><span class="verb"><code class="inlineCode">abort()</code></span></span> function.</p>&#13;
</section>&#13;
<section id="serializing-the-results" class="level5 likesubsubsectionHead" data-number="0.19.3.2.2">&#13;
<h5 class="likesubsubsectionHead" data-number="0.19.3.2.2"><span id="x1-3250002"/>Serializing the results</h5>&#13;
<p><span class="keyWord">Serialization </span>is the conversion<span id="dx1-325001"/> of Python data into a stream of bytes, suitable for transmission. Each format is best described by a simple function that serializes<span id="dx1-325002"/> just that one format. A top-level generic serializer can then pick from a list of specific serializers.</p>&#13;
<p>The general type hint for a serializer is this:</p>&#13;
<pre id="listing-320" class="lstlisting"><code>from collections.abc import Callable &#13;
from typing import Any, TypeAlias &#13;
 &#13;
Serializer: TypeAlias = Callable[[list[dict[str, Any]]], bytes]</code></pre>&#13;
<p>This definition avoids the specific <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series</code></span></span> definition. It uses a more general <span class="lstinline"><span style="color:#000000"><code class="inlineCode">list</code></span><span style="color:#000000"><code class="inlineCode">[</code></span><span style="color:#000000"><code class="inlineCode">dict</code></span><span style="color:#000000"><code class="inlineCode">[</code></span><span style="color:#000000"><code class="inlineCode">str</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">Any</code></span><span style="color:#000000"><code class="inlineCode">]]</code></span></span> type hint. This can be applied to the data of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series</code></span></span> as well as other items like the series labels.</p>&#13;
<p>A mapping from MIME types to serializer functions will lead to the following mapping object:</p>&#13;
<pre>SERIALIZERS: dict[str, Serializer] = {&#13;
'application/xml': serialize_xml,&#13;
'text/html': serialize_html,&#13;
'application/json': serialize_json,&#13;
'text/csv': serialize_csv,&#13;
}&#13;
</pre>&#13;
<p>This variable will be defined after the four functions it references. We’ve provided it here to act as context, showing where the serialization<span id="dx1-325014"/> design is headed.</p>&#13;
<p>The top-level <span class="obeylines-h"><span class="verb"><code class="inlineCode">serialize()</code></span></span> function can be defined as follows:</p>&#13;
<pre id="listing-321" class="lstlisting"><code>def serialize( &#13;
    format: str | None, &#13;
    data: list[dict[str, Any]], &#13;
    **kwargs: str &#13;
) -&gt; bytes: &#13;
    """Relies on global SERIALIZERS, set separately""" &#13;
    if format is None: &#13;
        format = "text/html" &#13;
    function = SERIALIZERS.get( &#13;
        format.lower(), &#13;
        serialize_html &#13;
    ) &#13;
    return function(data, **kwargs)</code></pre>&#13;
<p>The overall <span class="obeylines-h"><span class="verb"><code class="inlineCode">serialize()</code></span></span> function locates a specific serializer in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">SERIALIZERS</code></span></span> dictionary. This specific function fits the the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Serializer</code></span></span> type hint. The function will transform a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series</code></span></span> object into bytes that can be downloaded to a web client application.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">serialize()</code></span></span> function doesn’t do any data transformation. It maps a MIME type string to a function that does the hard work of transformation.</p>&#13;
<p>We’ll look at some of the individual serializers below. It’s relatively common for Python processing to create strings. We can then encode the strings into bytes. To avoid repeating the encoding operation, we’ll define a decorator to compose the serialization with the bytes encoding. Here’s the decorator we can use:</p>&#13;
<pre id="listing-322" class="lstlisting"><code>from collections.abc import Callable &#13;
from typing import TypeVar, ParamSpec &#13;
from functools import wraps &#13;
 &#13;
T = TypeVar("T") &#13;
P = ParamSpec("P") &#13;
 &#13;
def to_bytes( &#13;
    function: Callable[P, str] &#13;
) -&gt; Callable[P, bytes]: &#13;
    @wraps(function) &#13;
    def decorated(*args: P.args, **kwargs: P.kwargs) -&gt; bytes: &#13;
        text = function(*args, **kwargs) &#13;
        return text.encode("utf-8") &#13;
    return decorated</code></pre>&#13;
<p>We’ve created a small decorator<span id="dx1-325043"/> named <span class="obeylines-h"><span class="verb"><code class="inlineCode">@to_bytes</code></span></span>. This will evaluate the given function and then encode the results using UTF-8 to get bytes. Note that the decorator changes the decorated function from having a return type of <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code></span></span> to a return type of <span class="obeylines-h"><span class="verb"><code class="inlineCode">bytes</code></span></span>. We used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ParamSpec</code></span></span> hint to collect declared parameters for the decorated function. This ensures that tools like <span class="keyWord">mypy </span>can match the parameter specification for the decorated function with the base function.</p>&#13;
<p>We’ll show how this is used with JSON and CSV serializers. The HTML and XML serialization involves a bit more programming, but no significant complexity.</p>&#13;
</section>&#13;
<section id="serializing-data-with-json-or-csv-formats" class="level5 likesubsubsectionHead" data-number="0.19.3.2.3">&#13;
<h5 class="likesubsubsectionHead" data-number="0.19.3.2.3"><span id="x1-3260002"/>Serializing data with JSON or CSV formats</h5>&#13;
<p>The JSON and CSV serializers<span id="dx1-326001"/> are similar because both rely on Python’s libraries to serialize. The libraries are inherently imperative, so the function bodies are sequences of statements.</p>&#13;
<p>Here’s the JSON<span id="dx1-326002"/> serializer:</p>&#13;
<pre id="listing-323" class="lstlisting"><code>import json &#13;
 &#13;
@to_bytes &#13;
def serialize_json(data: list[dict[str, Any]], **kwargs: str) -&gt; str: &#13;
    text = json.dumps(data, sort_keys=True) &#13;
    return text</code></pre>&#13;
<p>We created a list-of-dicts structure and used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">json.dumps()</code></span></span> function to create a string representation. The JSON module requires a materialized list object; we can’t provide a lazy generator function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sort_keys=True</code></span></span> argument value is helpful for unit testing because the order is clearly stated and can be used to match expected results. However, it’s not required for the application<span id="dx1-326009"/> and represents a bit of overhead.</p>&#13;
<p>Here’s the CSV<span id="dx1-326010"/> serializer:</p>&#13;
<pre id="listing-324" class="lstlisting"><code>import csv &#13;
import io &#13;
 &#13;
@to_bytes &#13;
def serialize_csv(data: list[dict[str, Any]], **kwargs: str) -&gt; str: &#13;
    buffer = io.StringIO() &#13;
    wtr = csv.DictWriter(buffer, sorted(data[0].keys())) &#13;
    wtr.writeheader() &#13;
    wtr.writerows(data) &#13;
    return buffer.getvalue()</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">csv</code></span></span> module’s readers and writers are a mixture of imperative and functional elements. We must create the writer, and properly create headings in a strict sequence. A client of this function can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">_fields</code></span></span> attribute of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> named tuple to determine the column headings for the writer.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">writerows()</code></span></span> method of the writer will accept a lazy generator function. A client of this function can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">_asdict()</code></span></span> method of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> object to return a dictionary suitable for use with the CSV writer.</p>&#13;
</section>&#13;
<section id="serializing-data-with-xml-and-html" class="level5 likesubsubsectionHead" data-number="0.19.3.2.4">&#13;
<h5 class="likesubsubsectionHead" data-number="0.19.3.2.4"><span id="x1-3270002"/>Serializing data with XML and HTML</h5>&#13;
<p>Serialization into XML<span id="dx1-327001"/> has a goal of creating<span id="dx1-327002"/> a document that looks like this:</p>&#13;
<pre id="listing-325" class="lstlisting"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt; &#13;
&lt;Series&gt; &#13;
&lt;Pair&gt;&lt;x&gt;2&lt;/x&gt;&lt;y&gt;3&lt;/y&gt;&lt;/Pair&gt; &#13;
&lt;Pair&gt;&lt;x&gt;5&lt;/x&gt;&lt;y&gt;7&lt;/y&gt;&lt;/Pair&gt; &#13;
&lt;/Series&gt;</code></pre>&#13;
<p>This XML<span id="dx1-327008"/> document doesn’t include a reference to formal <span class="keyWord">XML Schema</span> <span class="keyWord">Definition </span>(<span class="keyWord">XSD</span>). It is, however, designed to parallel the named tuple definitions shown above.</p>&#13;
<p>One way to produce a document<span id="dx1-327009"/> like this is to create a template and fill in the fields. This can be done with packages like Jinja or Mako. There are a number of sophisticated template tools to create XML or HTML pages. A number of these include the ability to embed iteration over a sequence of objects—like a list of dicts—in the template, separate from the function that initializes serialization. Visit <a href="https://wiki.python.org/moin/Templating" class="url">https://wiki.python.org/moin/Templating</a> for a list of alternatives.</p>&#13;
<p>A more sophisticated serialization library could be helpful here. There are many to choose from. Visit <a href="https://wiki.python.org/moin/PythonXml" class="url">https://wiki.python.org/moin/PythonXml</a> for a list of alternatives.</p>&#13;
<p>Modern HTML<span id="dx1-327010"/> is based on XML. Therefore, an HTML document can be built similarly to an XML document by filling the actual values into a template. HTML documents often have a great deal more overhead than XML documents. The additional complexity arises because in HTML, the document is expected to provide an entire web page with a great deal of context information.</p>&#13;
<p>We’ve omitted the details for creating HTML or XML, leaving them as exercises for the reader. <span id="x1-327011r332"/></p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section id="tracking-usage" class="level3 sectionHead" data-number="0.19.4">&#13;
<h3 class="sectionHead" data-number="0.19.4"><span class="titlemark">15.4 </span> <span id="x1-3280004"/>Tracking usage</h3>&#13;
<p>RESTful APIs need to be used for secured<span id="dx1-328001"/> connections. This means the server must use SSL, and the connection will be via HTTPS protocol. The idea is to manage the SSL certificates used by ”front-end” or client applications. In many web service environments, mobile applications and JavaScript-based interactive front-ends will have certificates allowing access to the back-end.</p>&#13;
<p>In addition to SSL, another common practice is to require an <span class="keyWord">API key</span><span id="dx1-328002"/> as part of each transaction. An API key can be used to authenticate access. It may also be used to authorize specific features. Most importantly, it’s essential for tracking actual usage. A consequence of tracking usage can be throttling requests if an API key is used too often in a given time period.</p>&#13;
<p>The variations in business models are numerous. For example, use of the API key could be a billable event and charges will be incurred. For other businesses, traffic must reach some threshold before payments are required.</p>&#13;
<p>What’s important is non-repudiation of the use of the API. When a transaction is executed to make a state change, the API key<span id="dx1-328003"/> can be used to identify the application making the request. This, in turn, means creating API keys that can act as a user’s authentication credentials. The key must be difficult to forge and relatively easy to verify.</p>&#13;
<p>One way to create API keys is to use a cryptographic<span id="dx1-328004"/> random number to generate a difficult-to-predict key string. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">secrets</code></span></span> module can be used to generate unique API key values. Here’s an example of generating a unique key that can be assigned to clients to track activity:</p>&#13;
<div id="tcolobox-294" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import secrets &#13;
&gt;&gt;&gt; secrets.token_urlsafe(24) &#13;
’NLHirCPVf-S7aSAiaAJo3JECYk9dSeyq’</code></pre>&#13;
&#13;
</div>&#13;
<p>A base 64 encoding is used on the random bytes to create a sequence of characters. Using a multiple of three for the length will avoid any trailing <span class="obeylines-h"><span class="verb"><code class="inlineCode">=</code></span></span> signs in the base 64 encoding. We’ve used the URL-safe base 64 encoding, which won’t include the <span class="obeylines-h"><span class="verb"><code class="inlineCode">/</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">+</code></span></span> characters in the resulting string. This means the key can be used as part of a URL or can be provided in a header.</p>&#13;
<p>A more elaborate method of generating a token won’t lead to more random data. The use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">secrets</code></span></span> module assures that it is very difficult to counterfeit a key assigned to another user.</p>&#13;
<div id="tcolobox-295" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">secrets</code></span></span> module<span id="dx1-328009"/> is notoriously hard to use as part of unit and integration test. In order to produce high-quality, secure values, it avoids having an explicit seed like the <span class="obeylines-h"><span class="verb"><code class="inlineCode">random</code></span></span> module does. Since reproducible unit test cases can’t depend on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">secrets</code></span></span> module having reproducible results, a mock object should be used when testing. One consequence of this is creating a design that facilitates testing.</p>&#13;
&#13;
</div>&#13;
<p>As API keys are generated, they need to be sent to the users creating applications, and also kept in a database that’s part of the API service.</p>&#13;
<p>If a request includes a key that’s in the database, the associated user is responsible for the request. If the API request doesn’t include a known key, the request can be rejected with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">401</code><code class="inlineCode"> UNAUTHORIZED</code></span></span> response.</p>&#13;
<p>This small database<span id="dx1-328010"/> can be a text file that the server loads to map API keys to authorized privileges. The file can be read at startup and the modification time checked to see if the version cached in the server is still current. When a new key is available, the file is updated and the server will re-read the file.</p>&#13;
<div id="tcolobox-296" class="infobox note">&#13;
&#13;
&#13;
<p>See <a href="https://swagger.io/docs/specification/2-0/authentication/api-keys/" class="url">https://swagger.io/docs/specification/2-0/authentication/api-keys/</a> for more information on API keys.</p>&#13;
&#13;
</div>&#13;
<p>The essential check for a valid API key<span id="dx1-328011"/> is so common that Flask provides a decorator to identify this function. Using <span class="obeylines-h"><span class="verb"><code class="inlineCode">@app.before_app_request</code></span></span> marks a function that will be invoked <span class="cmti-10x-x-109">before </span>every view function. This function can establish the validity of the API key before allowing any processing.</p>&#13;
<p>This API key-checking is often bypassed for a few paths. If, for example, the service will download its OpenAPI specification, the path should be handled without regard to the presence of an <span class="obeylines-h"><span class="verb"><code class="inlineCode">API-Key</code></span></span> header. This often means a special-case check to see if <span class="obeylines-h"><span class="verb"><code class="inlineCode">request.path</code></span></span> is <span class="obeylines-h"><span class="verb"><code class="inlineCode">openapi.json</code></span></span> or one of the other common names for the specification.</p>&#13;
<p>Similarly, a server may need to respond to requests based on the presence of CORS headers. See <a href="https://www.w3.org/TR/cors/#http-cors-protocol">https://www.w3.org/TR/cors/#http-cors-protocol</a> for more information. This can make the <span class="obeylines-h"><span class="verb"><code class="inlineCode">before_app_request()</code></span></span> function even more complex by adding another group of exceptions.</p>&#13;
<p>The good news is there are only two exceptions to requiring an <span class="obeylines-h"><span class="verb"><code class="inlineCode">API-Key</code></span></span> header with every request. One is handling the OpenAPI specification and the other is the CORS preflight request. This is unlikely to change, and a few <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code></span></span> statements are sufficient. <span id="x1-328012r339"/></p>&#13;
</section>&#13;
<section id="summary-14" class="level3 sectionHead" data-number="0.19.5">&#13;
<h3 class="sectionHead" data-number="0.19.5"><span class="titlemark">15.5 </span> <span id="x1-3290005"/>Summary</h3>&#13;
<p>In this chapter, we looked at ways in which we can apply functional design to the problem of serving content with REST-based web services. We looked at how the WSGI standard leads to somewhat functional overall applications. We also looked at how we can embed a more functional design into a WSGI context by extracting elements from the request for use by our application functions.</p>&#13;
<p>For simple services, the problem often decomposes into three distinct operations: getting the data, searching or filtering, and then serializing the results. We tackled this with three functions: <span class="obeylines-h"><span class="verb"><code class="inlineCode">raw_data()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">anscombe_filter()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">serialize()</code></span></span>. We wrapped these functions in a simple WSGI-compatible application to divorce the web services from the <span class="cmti-10x-x-109">real </span>processing around extracting and filtering the data.</p>&#13;
<p>We also looked at the way that web services’ functions can focus on the <span class="cmti-10x-x-109">happy</span> <span class="cmti-10x-x-109">path </span>and assume that all of the inputs are valid. If inputs are invalid, the ordinary Python exception handling will raise exceptions. The WSGI wrapper function will catch the errors and return appropriate status codes and error content.</p>&#13;
<p>We have not looked at more complex problems associated with uploading data or accepting data from forms to update a persistent data store. These are not significantly more complex than getting data and serializing the results.</p>&#13;
<p>For simple queries and data sharing, a small web service application can be helpful. We can apply functional design patterns and assure that the website code is succinct and expressive. For more complex web applications, we should consider using a framework that handles the details properly.</p>&#13;
<p>In the next chapter, we’ll look at a more complete example of functional programming. This is a case study that applies some statistical measures to sample data to determine if the data are likely to be random, or potentially include some interesting relationship. <span id="x1-329001r340"/></p>&#13;
</section>&#13;
<section id="exercises-14" class="level3 sectionHead" data-number="0.19.6">&#13;
<h3 class="sectionHead" data-number="0.19.6"><span class="titlemark">15.6 </span> <span id="x1-3300006"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-330001r334"/></p>&#13;
<section id="wsgi-application-welcome" class="level4 subsectionHead" data-number="0.19.6.1">&#13;
<h4 class="subsectionHead" data-number="0.19.6.1"><span class="titlemark">15.6.1 </span> <span id="x1-3310001"/>WSGI application: welcome</h4>&#13;
<p>In the <a href="#x1-3180002"><span class="cmti-10x-x-109">The WSGI standard</span></a> section of this chapter, a routing application was described. It showed three application routes, including paths starting with <span class="obeylines-h"><span class="verb"><code class="inlineCode">/demo</code></span></span> and a special case for the path <span class="obeylines-h"><span class="verb"><code class="inlineCode">/index.html</code></span></span>.</p>&#13;
<p>Creating applications via WSGI can be challenging. Build a function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">welcome_app()</code></span></span>, that displays an HTML page with some links for the demo app and the static download app.</p>&#13;
<p>A unit test for this application should use a mocked <span class="obeylines-h"><span class="verb"><code class="inlineCode">StartResponse</code></span></span> function, and a mocked environment. <span id="x1-331001r342"/></p>&#13;
</section>&#13;
<section id="wsgi-application-demo" class="level4 subsectionHead" data-number="0.19.6.2">&#13;
<h4 class="subsectionHead" data-number="0.19.6.2"><span class="titlemark">15.6.2 </span> <span id="x1-3320002"/>WSGI application: demo</h4>&#13;
<p>In the <a href="#x1-3180002"><span class="cmti-10x-x-109">The WSGI standard</span></a> section of this chapter, a routing application was described. It showed three application routes, including paths starting with <span class="obeylines-h"><span class="verb"><code class="inlineCode">/demo</code></span></span> and a special case for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">/index.html</code></span></span> path.</p>&#13;
<p>Build a function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">demo_app()</code></span></span>, to do some potentially useful activity. The intent here is to have a path that responds to an HTTP <span class="obeylines-h"><span class="verb"><code class="inlineCode">POST</code></span></span> request to do some work, creating an entry in a log file. The result must be a redirect (status 303, usually) to a URL that uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">static_text_app()</code></span></span> to download the log file. This behavior is described as Post/Redirect/Get, and allows for a good user experience when navigating back to a previous page. See <a href="https://www.geeksforgeeks.org/post-redirect-get-prg-design-pattern/" class="url">https://www.geeksforgeeks.org/post-redirect-get-prg-design-pattern/</a> for more details on this design pattern.</p>&#13;
<p>Here are two examples of useful work that might be implemented by the demo application:</p>&#13;
<ul>&#13;
<li><p>A <span class="obeylines-h"><span class="verb"><code class="inlineCode">GET</code></span></span> request can present an HTML page with a form. The submit button on the form can make a <span class="obeylines-h"><span class="verb"><code class="inlineCode">POST</code></span></span> request to do a computation of some kind.</p></li>&#13;
<li><p>A <span class="obeylines-h"><span class="verb"><code class="inlineCode">POST</code></span></span> request can execute <span class="obeylines-h"><span class="verb"><code class="inlineCode">doctest.testfile()</code></span></span> to run a unit test suite and collect the resulting log.</p></li>&#13;
</ul>&#13;
<p><span id="x1-332001r343"/></p>&#13;
</section>&#13;
<section id="serializing-data-with-xml" class="level4 subsectionHead" data-number="0.19.6.3">&#13;
<h4 class="subsectionHead" data-number="0.19.6.3"><span class="titlemark">15.6.3 </span> <span id="x1-3330003"/>Serializing data with XML</h4>&#13;
<p>In the <a href="#x1-3270002"><span class="cmti-10x-x-109">Serializing data with XML and HTML</span></a> section of this chapter, we described two additional features of the RESTful API built using Flask.</p>&#13;
<p>Extend the response in those examples to serialize the resulting data into XML in addition to CSV and JSON. One alternative to adding XML serialization is to download and install a library that will serialize <span class="obeylines-h"><span class="verb"><code class="inlineCode">Series</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> objects. Another choice is to write a function that can work with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">list[dict[str,</code><code class="inlineCode"> Any]]</code></span></span> object. Adding the XML serialization format also requires adding test cases to confirm the response has the expected format and content. <span id="x1-333001r344"/></p>&#13;
</section>&#13;
<section id="serializing-data-with-html" class="level4 subsectionHead" data-number="0.19.6.4">&#13;
<h4 class="subsectionHead" data-number="0.19.6.4"><span class="titlemark">15.6.4 </span> <span id="x1-3340004"/>Serializing data with HTML</h4>&#13;
<p>In the <a href="#x1-3270002"><span class="cmti-10x-x-109">Serializing data with XML and HTML</span></a> section of this chapter, we described two additional features of the RESTful API built using Flask.</p>&#13;
<p>Extend the response in those examples to serialize the resulting data into HTML in addition to CSV and JSON. HTML serialization can be more complex than XML serialization because there is quite a bit of overhead in an HTML presentation of data. Rather than a representation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> objects, it is common practice to include an entire HTML table structure that mirrors the CSV rows and columns. Adding the HTML serialization format also requires adding test cases to confirm the response has the expected format and content.</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-12" class="level3 likesectionHead" data-number="0.19.7">&#13;
<h3 class="likesectionHead" data-number="0.19.7"><span id="x1-3350004"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>