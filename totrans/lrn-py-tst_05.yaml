- en: Chapter 5. Structured Testing with unittest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 使用unittest进行结构化测试
- en: 'The `doctest` tool is flexible and extremely easy to use but, as we''ve noticed,
    it falls somewhat short when it comes to writing disciplined tests. That''s not
    to say that it''s impossible; we''ve seen that we can write well-behaved, isolated
    tests in `doctest`. The problem is that `doctest` doesn''t do any of that work
    for us. Fortunately, we have another testing tool on hand, a tool that requires
    a bit more structure in our tests, and provides a bit more support: `unittest`.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`工具非常灵活且极易使用，但我们已经注意到，在编写有纪律的测试时，它似乎有些不足。但这并不意味着不可能；我们已经看到我们可以在`doctest`中编写行为良好的、隔离的测试。问题是`doctest`并没有为我们做这些工作。幸运的是，我们手头还有另一个测试工具，这个工具要求我们的测试有更多的结构，并提供更多的支持：`unittest`。'
- en: The `unittest` module was designed based on the requirements of unit testing,
    but it's not actually limited to that. You can use unit test for integration and
    system testing, too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块是基于单元测试的要求设计的，但它实际上并不局限于这一点。您可以使用单元测试进行集成和系统测试。'
- en: Like `doctest`, `unittest` is a part of the Python standard library; thus, if
    you've got Python, you have unit test.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与`doctest`一样，`unittest`是Python标准库的一部分；因此，如果您有Python，您就有单元测试。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing tests within the `unittest` framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`unittest`框架内编写测试
- en: Running our new tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行我们的新测试
- en: Looking at the features that make `unittest` a good choice for larger test suites
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看使`unittest`成为大型测试套件良好选择的功能
- en: The basics
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: Before we start talking about new concepts and features, let's take a look at
    how to use `unittest` to express the ideas that we've already learned about. That
    way, we'll have something solid on which ground our new understanding.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论新的概念和功能之前，让我们看看如何使用`unittest`来表达我们已经学到的想法。这样，我们就会有一个坚实的基础来建立我们的新理解。
- en: We're going to revisit the `PID` class, or at least the tests for the `PID`
    class, from [Chapter 3](ch03.html "Chapter 3. Unit Testing with doctest"), *Unit
    Testing with doctest*. We're going to rewrite the tests so that they operate within
    the `unittest` framework.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新审视第3章中的`PID`类，或者至少是`PID`类的测试，[第3章](ch03.html "第3章. 使用doctest进行单元测试")，*使用doctest进行单元测试*。我们将重写测试，以便它们在`unittest`框架内运行。
- en: Before moving on, take a moment to refer back to the final version of the `pid.txt`
    file from [Chapter 3](ch03.html "Chapter 3. Unit Testing with doctest"), *Unit
    Testing with doctest*. We'll be implementing the same tests using the `unittest`
    framework.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请花一点时间回顾一下第3章中[第3章](ch03.html "第3章. 使用doctest进行单元测试")的`pid.txt`文件的最终版本。我们将使用`unittest`框架实现相同的测试。
- en: 'Create a new file called `test_pid.py` in the same directory as `pid.py`. Notice
    that this is a `.py` file: `unittest` tests are pure Python source code, rather
    than being plain text with source code embedded in it. This means that the tests
    will be less useful from a documentary point of view, but grants other benefits
    in exchange.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在与`pid.py`相同的目录下创建一个名为`test_pid.py`的新文件。请注意，这是一个`.py`文件：`unittest`测试是纯Python源代码，而不是包含源代码的纯文本。这意味着从文档的角度来看，测试将不那么有用，但这也带来了其他好处。
- en: 'Insert the following code into your newly created `test_pid.py` file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码插入您新创建的`test_pid.py`文件中：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It has been argued, sometimes with good reason, that unit tests should not contain
    more than one assertion. The idea is that each unit test should test one thing
    and one thing only, to further narrow down what the problem is, when the test
    fails. It's a good point but not something to be overly fanatic about, in my opinion.
    In cases like the preceding code, splitting each assertion out into its own test
    function will not produce any more informative error messages than we get in this
    way; it would just increase our overhead.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，人们会争论，单元测试不应该包含超过一个断言。这种想法是，每个单元测试应该只测试一件事情，以进一步缩小测试失败时的问题范围。这是一个很好的观点，但在我看来，不应该过分狂热。在像前面代码那样的情况下，将每个断言拆分到自己的测试函数中，并不会比我们这样得到更多的信息性错误消息；这只会增加我们的开销。
- en: 'My rule of thumb is that a test function can have any number of trivial assertions,
    and at most one non-trivial assertion:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我的经验法则是，一个测试函数可以有任意数量的简单断言，但最多只能有一个非简单断言：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, run the tests by typing the following on the command line:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在命令行中输入以下内容来运行测试：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see output similar to this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下内容的输出：
- en: '![The basics](img/3211OS_05_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![基础知识](img/3211OS_05_01.jpg)'
- en: 'So, what did we do there? There are several things to notice:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们做了什么呢？有几个需要注意的地方：
- en: First, all of the tests are their own methods of classes that inherit from `unittest.TestCase`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，所有测试都是继承自`unittest.TestCase`的类的自己的方法。
- en: The tests are named `test_<something>`, where `<something>` is a description
    to help you (and others who share the code) remember what the test is actually
    checking. This matters because `unittest` (and several other testing tools) use
    the name to differentiate tests from non-test methods. As a rule of thumb, your
    test method names and test module filenames should start with test.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的命名格式为`test_<something>`，其中`<something>`是一个描述，帮助你（以及共享代码的其他人）记住测试实际上在检查什么。这很重要，因为`unittest`（以及几个其他测试工具）使用名称来区分测试和非测试方法。一般来说，你的测试方法名称和测试模块文件名应该以test开头。
- en: Because each test is a method, each test naturally runs in its own variable
    scope. Right here, we gain a big advantage from keeping the tests isolated.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为每个测试都是一个方法，所以每个测试自然在自己的变量作用域中运行。在这里，我们通过保持测试的隔离性获得了很大的优势。
- en: We inherited a bunch of `assert<Something>` methods from `TestCase`. These give
    us more flexible ways of checking whether values match, and provide more useful
    error reports, than Python's basic `assert` statement.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`TestCase`继承了`assert<Something>`方法。这些方法为我们提供了更灵活的检查值是否匹配的方式，并提供了比Python基本`assert`语句更有用的错误报告。
- en: 'We used `unittest.mock.patch` as a method decorator. In [Chapter 4](ch04.html
    "Chapter 4. Decoupling Units with unittest.mock"), *Decoupling Units with unittest.mock*,
    we used it as a context manager. Either way, it does the same thing: it replaces
    an object with a mock object, and then puts the original back. When used as a
    decorator, the replacement happens before the method runs, and the original is
    put back after the method is complete. That''s exactly what we need when our test
    is a method, so we''ll be doing it in this way quite a lot.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`unittest.mock.patch`作为方法装饰器。在[第4章](ch04.html "第4章。使用unittest.mock解耦单元")中，我们将其用作上下文管理器。无论是哪种方式，它都做了同样的事情：用一个模拟对象替换一个对象，然后将其放回原处。当用作装饰器时，替换发生在方法运行之前，而原始对象在方法完成后被放回。这正是我们测试是一个方法时所需要的，所以我们将以这种方式做很多。
- en: We didn't patch over `time.time`, we patched `over pid.time`. This is because
    we're not reimporting the `pid` module for each test here. The `pid` module contains
    `from time import time`, which means that, when it is first loaded, the `time`
    function is referenced directly into the `pid` module's scope. From then on, changing
    `time.time` doesn't have any effect on `pid.time`, unless we change it and then
    reimport the `pid` module. Instead of going to all that trouble, we just patched
    `pid.time` directly.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有覆盖`time.time`，而是覆盖了`over pid.time`。这是因为我们在这里不是为每个测试重新导入`pid`模块。`pid`模块包含`from
    time import time`，这意味着当它首次加载时，`time`函数会直接引用到`pid`模块的作用域中。从那时起，改变`time.time`对`pid.time`没有任何影响，除非我们改变它并重新导入`pid`模块。为了避免所有这些麻烦，我们直接覆盖了`pid.time`。
- en: We didn't tell `unittest` which tests to run. Instead, we told it to discover
    them and it found the tests on its own and ran them automatically. This often
    works well and saves effort. We'll be looking at a more elaborate tool for test
    discovery and execution in [Chapter 6](ch06.html "Chapter 6. Running Your Tests
    with Nose"), *Running Your Tests with Nose*.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有告诉`unittest`要运行哪些测试。相反，我们让它自己发现测试，并且它自己找到了测试并自动运行它们。这通常效果很好，可以节省精力。我们将在[第6章](ch06.html
    "第6章。使用Nose运行你的测试")中查看一个更复杂的测试发现和执行工具。
- en: The `unittest` module prints out one dot for each successful test. It will give
    you more information for tests that fail, or raise an unexpected exception.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest`模块为每个成功的测试打印出一个点。对于失败的测试或引发意外异常的测试，它会提供更多信息。'
- en: The actual tests we performed are the same ones that were written in `doctest`.
    So far, all we're seeing is a different way of expressing them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际执行的测试与在`doctest`中编写的测试相同。到目前为止，我们看到的是表达它们的不同方式。
- en: Each test method embodies a single test of a single unit. This gives us a convenient
    way to structure our tests, grouping together related tests into the same class
    so that they're easier to find. You might have noticed that we used two test classes
    in the example. This was for organizational purposes in this case, although there
    can also be good practical reasons to separate your tests into multiple classes.
    We'll talk about that soon.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试方法体现了一个单一单元的单一测试。这为我们提供了一个方便的方式来组织测试，将相关的测试组合到同一个类中，以便更容易找到。你可能已经注意到我们在示例中使用了两个测试类。这在当前情况下是为了组织目的，尽管也有很好的实际理由将测试分离到多个类中。我们很快就会谈到这一点。
- en: Putting each test into its own method means that each test executes in an isolated
    namespace, which makes it easier to keep `unittest`-style tests from interfering
    with each other, relative to `doctest`-style tests. This also means that `unittest`
    knows how many unit tests are in your test file, instead of simply knowing how
    many expressions there are (you might have noticed that `doctest` counts each
    `>>>` line as a separate test). Finally, putting each test in its own method means
    that each test has a name, which can be a valuable feature. When you run `unittest`,
    it will include the names of any failing tests in the error report.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个测试放入它自己的方法意味着每个测试都在一个独立的命名空间中执行，这使得相对于 `doctest` 风格的测试，更容易保持 `unittest` 风格的测试之间不相互干扰。这也意味着
    `unittest` 知道你的测试文件中有多少个单元测试，而不是简单地知道有多少个表达式（你可能已经注意到 `doctest` 将每行 `>>>` 视为一个单独的测试）。最后，将每个测试放入它自己的方法意味着每个测试都有一个名称，这可以是一个非常有价值的特性。当你运行
    `unittest` 时，它会在错误报告中包括任何失败的测试的名称。
- en: Tests in `unittest` don't directly care about anything that isn't part of a
    call to one of the `TestCase` `assert` methods. This means that we don't have
    to be bothered about the return values of any functions we call or the results
    of any expressions we use, unless they're important to the test. This also means
    that we need to remember to write an assert describing every aspect of the test
    that we want to have checked. We'll go through the various assertion methods of
    `TestCase` shortly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 中的测试并不直接关心任何不是 `TestCase` 断言方法调用一部分的内容。这意味着我们不必担心我们调用的任何函数的返回值或我们使用的任何表达式的结果，除非它们对测试很重要。这也意味着我们需要记住为测试的每个方面编写一个断言。我们很快就会介绍
    `TestCase` 的各种断言方法。'
- en: Assertions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言
- en: Assertions are the mechanism we use to tell `unittest` what the important outcomes
    of the test are. By using appropriate assertions, we can tell `unittest` exactly
    what to expect from each test.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是我们用来告诉 `unittest` 测试的重要结果的机制。通过使用适当的断言，我们可以告诉 `unittest` 每个测试期望得到什么。
- en: The assertTrue method
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`assertTrue` 方法'
- en: When we call `self.assertTrue(expression)`, we're telling `unittest` that the
    expression must be true in order for the test to be a success.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `self.assertTrue(expression)` 时，我们是在告诉 `unittest` 表达式必须为真，测试才能成功。
- en: This is a very flexible assertion, since you can check for nearly anything by
    writing the appropriate Boolean expression. It's also one of the last assertions
    you should consider using, because it doesn't tell `unittest` anything about the
    kind of comparison you're making, which means that `unittest` can't tell you clearly
    what's gone wrong if the test fails.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常灵活的断言，因为你可以通过编写适当的布尔表达式来检查几乎所有内容。它也是你最后应该考虑使用的断言之一，因为它并没有告诉 `unittest`
    你正在进行的比较类型，这意味着如果测试失败，`unittest` 无法清楚地告诉你出了什么问题。
- en: 'For example, consider the following test code containing two tests that are
    guaranteed to fail:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下包含两个保证会失败的测试的测试代码：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It might seem that the two tests are interchangeable, since they both test the
    same thing. Certainly they'll both fail (or, in the unlikely event that one equals
    two, they'll both pass), so why prefer one over the other?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来这两个测试是可以互换的，因为它们都测试了相同的内容。当然，它们都会失败（或者，在极不可能的情况下，一个等于两个，它们都会通过），那么为什么选择其中一个而不是另一个呢？
- en: Run the tests and see what happens (and also notice that the tests were not
    executed in the same order as we wrote them; the tests are totally independent
    of each other, so that's okay, right?).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并查看发生了什么（同时注意测试的执行顺序并不一定与我们编写的顺序相同；测试之间完全独立，所以这是可以接受的，对吧？）。
- en: 'Both the tests fail, as expected, but the test that uses `assertEqual` tells
    us:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试都如预期那样失败了，但使用 `assertEqual` 的测试告诉我们：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The other one says:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个说法是：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s pretty clear which of these outputs is more useful in this situation.
    The `assertTrue` test was able to correctly determine that the test should fail,
    but it didn''t know enough to report any useful information about why it failed.
    The `assertEqual` test, on the other hand, knew first of all that it was checking
    whether the two expressions were equal, and second it knew how to present the
    results so that they would be most useful: by evaluating each of the expressions
    that it was comparing and placing a `!=` symbol between the results. It tells
    us both which expectation failed, and what the relevant expressions evaluate to.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，哪个输出更有用是很明显的。`assertTrue`测试能够正确地确定测试应该失败，但它不知道足够的信息来报告任何关于失败原因的有用信息。另一方面，`assertEqual`测试首先知道它正在检查两个表达式是否相等，其次它知道如何以最有用的方式呈现结果：通过评估它比较的每个表达式，并在结果之间放置一个`!=`符号。它告诉我们哪些期望失败了，以及相关的表达式评估结果是什么。
- en: The assertFalse method
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`assertFalse`方法'
- en: The `assertFalse` method will succeed when the `assertTrue` method will fail,
    and vice versa. It has the same limits in terms of producing useful output that
    `assertTrue` has, and the same flexibility in terms of being able to test nearly
    any condition.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当`assertTrue`方法失败时，`assertFalse`方法将成功，反之亦然。它在产生有用输出方面的限制与`assertTrue`相同，并且在能够测试几乎所有条件方面的灵活性也相同。
- en: The assertEqual method
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`assertEqual`方法'
- en: As mentioned in the `assertTrue` discussion, the `assertEqual` assertion checks
    whether its two parameters are in fact equal, and reports a failure if they are
    not, along with the actual values of the parameters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如在`assertTrue`讨论中提到的，`assertEqual`断言检查其两个参数是否确实相等，如果不相等，则报告失败，并附带参数的实际值。
- en: The assertNotEqual method
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`assertNotEqual`方法'
- en: The `assertNotEqual` assertion fails whenever the `assertEqual` assertion would
    have succeeded, and vice versa. When it reports a failure, its output indicates
    that the values of the two expressions are equal, and provides you with those
    values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当`assertEqual`断言成功时，`assertNotEqual`断言将失败，反之亦然。当它报告失败时，其输出表明两个表达式的值是相等的，并提供了这些值。
- en: The assertAlmostEqual method
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`assertAlmostEqual`方法'
- en: As we've seen before, comparing floating point numbers can be troublesome. In
    particular, checking whether two floating point numbers are equal is problematic,
    because things that you might expect to be equal—things that, mathematically,
    are equal—may still end up differing down among the least significant bits. Floating
    point numbers only compare equal when every bit is the same.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，比较浮点数可能会有麻烦。特别是，检查两个浮点数是否相等是有问题的，因为你可能期望相等的东西——在数学上相等的东西——最终在最低有效位上仍然会有所不同。只有当每个位都相同时，浮点数才相等。
- en: To address this problem, `unittest` provides `assertAlmostEqual`, which checks
    whether the two floating point values are almost the same; a small amount of difference
    between them is tolerated.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，`unittest`提供了`assertAlmostEqual`，它检查两个浮点值是否几乎相同；它们之间的一小部分差异是可以容忍的。
- en: 'Let''s look at this problem in action. If you take the square root of seven,
    and then square it, the result should be seven. Here''s a pair of tests that check
    this fact:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个问题在实际中的表现。如果你取7的平方根，然后平方它，结果应该是7。这里有一对测试来检查这个事实：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `test_square_root_of_seven_squared_incorrectly` method checks that ![The
    assertAlmostEqual method](img/3211OS_05_02.jpg), which is true in reality. In
    the more specialized number system available to computers, though, taking the
    square root of 7 and then squaring it doesn't quite get us back to 7, so this
    test will fail. We will look more closely at this in a moment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_square_root_of_seven_squared_incorrectly`方法检查![The assertAlmostEqual
    method](img/3211OS_05_02.jpg)，这在现实中是正确的。然而，在计算机可用的更专业的数系中，取7的平方根然后平方并不完全回到7，因此这个测试将失败。我们稍后会更详细地探讨这个问题。'
- en: The `test_square_root_of_seven_squared` method checks ![The assertAlmostEqual
    method](img/3211OS_05_03.jpg), which even the computer will find to be true, so
    this test should pass.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_square_root_of_seven_squared`方法检查![The assertAlmostEqual method](img/3211OS_05_03.jpg)，即使是计算机也会发现这是正确的，所以这个测试应该通过。'
- en: Unfortunately, floating point numbers (the representation of real numbers used
    by computers) are not precise, because the majority of numbers on the real number
    line cannot be represented with a finite, non-repeating sequence of digits, much
    less than a mere 64 bits. Consequently, what you get back from evaluating the
    mathematical expression in the previous example is not quite seven. It's good
    enough for government work though—or practically any other sort of work as well—so
    we don't want our test to quibble over that tiny difference. Because of this,
    we should habitually use `assertAlmostEqual` and `assertNotAlmostEqual` when we're
    comparing floating point numbers with equality.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，浮点数（计算机用于表示实数的数字表示）并不精确，因为实数线上的大多数数字不能用有限且不重复的数字序列来表示，更不用说只有64位了。因此，从上一个例子中评估数学表达式得到的结果并不完全是七。不过，这对于政府工作来说已经足够好了——或者实际上任何其他类型的工作也是如此——所以我们不想让我们的测试对那个微小的差异斤斤计较。正因为如此，当我们比较浮点数时，我们应该习惯性地使用
    `assertAlmostEqual` 和 `assertNotAlmostEqual`。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This problem doesn't generally carry over into other comparison operators. Checking
    whether one floating point number is less than the other, for example, is very
    unlikely to produce the wrong result due to insignificant errors. It's only in
    cases of equality that this problem bites us.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题通常不会影响到其他比较运算符。例如，检查一个浮点数是否小于另一个，由于微小的误差，产生错误结果的可能性非常低。只有在相等的情况下，这个问题才会困扰我们。
- en: The assertNotAlmostEqual method
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assertNotAlmostEqual 方法
- en: The `assertNotAlmostEqual` assertion fails whenever the `assertAlmostEqual`
    assertion would have succeeded, and vice versa. When it reports a failure, its
    output indicates that the values of the two expressions are nearly equal, and
    provides you with those values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `assertAlmostEqual` 断言会成功时，`assertNotAlmostEqual` 断言会失败，反之亦然。当它报告失败时，其输出表明两个表达式的值几乎相等，并提供了这些值。
- en: The assertIs and assertIsNot methods
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assertIs 和 assertIsNot 方法
- en: The `assertIs` and `assertIsNot` methods have the same relationship with Python's
    `is` operator that `assertEqual` and `assertNotEqual` have to Python's `==` operator.
    What this means is that they check whether the two operands are (or are not) exactly
    the same object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertIs` 和 `assertIsNot` 方法与 Python 的 `is` 运算符的关系与 `assertEqual` 和 `assertNotEqual`
    与 Python 的 `==` 运算符的关系相同。这意味着它们检查两个操作数是否（或不是）完全相同的对象。'
- en: The assertIsNone and assertIsNotNone methods
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assertIsNone 和 assertIsNotNone 方法
- en: The `assertIsNone` and `assertIsNotNone` methods are like `assertIs` and `assertIsNot`,
    except that they accept only one parameter that they always compare to `None`,
    rather than accepting two parameters and comparing them to each other.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: assertIsNone 和 assertIsNotNone 方法类似于 `assertIs` 和 `assertIsNot`，除了它们只接受一个参数，它们总是将其与
    `None` 进行比较，而不是接受两个参数并将它们相互比较。
- en: The assertIn and assertNotIn methods
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assertIn 和 assertNotIn 方法
- en: The `assertIn` method is used for checking container objects such as dictionaries,
    tuples, lists, and sets. If the first parameter is contained in the second, the
    assertion passes. If not, the assertion fails. The `assertNotIn` method performs
    the inverse check.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertIn` 方法用于检查容器对象，如字典、元组、列表和集合。如果第一个参数包含在第二个参数中，则断言通过。如果不包含，则断言失败。`assertNotIn`
    方法执行相反的检查。'
- en: The assertIsInstance and assertNotIsInstance methods
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assertIsInstance 和 assertNotIsInstance 方法
- en: The `assertIsInstance` method checks whether the object passed as the first
    parameter is an instance of the class passed as the second parameter. The `assertNotIsInstance`
    method performs the opposite check, ensuring that the object is not an instance
    of the class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertIsInstance` 方法检查作为第一个参数传递的对象是否是作为第二个参数传递的类的实例。`assertNotIsInstance`
    方法执行相反的检查，确保对象不是该类的实例。'
- en: The assertRaises method
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assertRaises 方法
- en: As always, we need to make sure that our units correctly signal errors. Doing
    the right thing when they receive good inputs is only half the job; they need
    to do something reasonable when they receive bad inputs, as well.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们需要确保我们的单元正确地报告错误。当它们接收到良好的输入时做正确的事情只是工作的一半；它们在接收到不良输入时也需要做一些合理的事情。
- en: The `assertRaises` method checks whether a callable raises a specified exception
    when passed a specified set of parameters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertRaises` 方法检查当传递指定的参数集时，可调用对象是否引发指定的异常。'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A callable is a function, a method, a class, or an object of any arbitrary type
    that has a `__call__` method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用对象是一个函数、一个方法、一个类或任何具有 `__call__` 方法的任意类型的对象。
- en: This assertion only works with callables, which means that you don't have a
    way of checking whether other sorts of expressions raise an expected exception.
    If that doesn't fit the needs of your test, it's possible to construct your own
    test using the `fail` method, described below.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言只适用于可调用对象，这意味着你没有一种方法来检查其他类型的表达式是否会引发预期的异常。如果这不符合你的测试需求，你可以使用下面描述的`fail`方法来构建自己的测试。
- en: To use `assertRaises`, first pass the expected exception to it, then the callable,
    and then the parameters that should be passed to the callable when it's invoked.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`assertRaises`，首先将预期的异常传递给它，然后是可调用对象，最后是调用可调用对象时应传递的参数。
- en: 'Here''s an example test using `assertRaises`. This test ought to fail, because
    the callable won''t raise the expected exception. `''8ca2''` is a perfectly acceptable
    input to `int`, when you''re also passing `base = 16` to it. Notice that `assertRaises`
    will accept any number of positional or keyword arguments, and pass them on to
    the callable on invocation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用`assertRaises`的示例测试。这个测试应该会失败，因为可调用对象不会引发预期的异常。当你也向`int`传递`base = 16`时，`'8ca2'`是`int`的一个完全可接受的输入。注意，`assertRaises`可以接受任意数量的位置参数或关键字参数，并在调用时将它们传递给可调用对象：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run this test, it fails (as we knew it would) because `int` didn''t
    raise the exception we told `assertRaises` to expect. The test fails and reports
    this as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个测试时，它会失败（正如我们所知道的），因为`int`没有抛出我们告诉`assertRaises`期望的异常。测试失败并报告如下：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If an exception is raised, but it's not the one you told `unittest` to expect,
    then `unittest` considers that as an error. An error is different from a failure.
    A failure means that one of your tests has detected a problem in the unit being
    tested. An error means that there's a problem with the test itself.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出了异常，但不是你告诉`unittest`期望的异常，那么`unittest`会将其视为错误。错误与失败不同。失败意味着你的某个测试检测到了正在测试的单元中的问题。错误意味着测试本身存在问题。
- en: The fail method
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`fail`方法'
- en: When all else fails, you can fall back on `fail`. When the code in your test
    calls fail, the test fails.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有其他方法都失败时，你可以退回到`fail`。当你的测试代码调用`fail`时，测试就会失败。
- en: What good does that do? When none of the `assert` methods do what you need,
    you can instead write your checks in such a way that `fail` will be called if
    the test does not pass. This allows you to use the full expressiveness of Python
    to describe checks for your expectations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么好处呢？当没有任何`assert`方法满足你的需求时，你可以将检查编写成这样，如果测试未通过，则调用`fail`。这允许你使用Python的全部表达能力来描述你的期望检查。
- en: 'Let''s take a look at an example. This time, we''re going to test on a less-than
    operation, which isn''t one of the operations directly supported by an `assert`
    method. Using fail, it''s easy to implement the test anyhow:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。这次，我们将对一个小于操作进行测试，这不是`assert`方法直接支持的操作之一。使用`fail`，我们仍然可以轻松实现这个测试：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If a particular comparison gets used repeatedly in your tests, you can write
    your own `assert` function for that comparison, using `fail` to report errors
    just as we did in the preceding example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在测试中某个特定的比较被反复使用，你可以为那个比较编写自己的`assert`函数，使用`fail`来报告错误，就像我们在前面的例子中所做的那样。
- en: A couple of things to notice here. First of all, take note of the `not` in the
    `if` statement. Since we want to run `fail` if the test should *not* pass, but
    we're used to describing the circumstances when the test should succeed, a good
    way to write the test is to write the success condition, and then invert it with
    `not`. That way we can continue thinking in the way we're used to when we use
    `fail`. The second thing to note is that you can pass a message to fail when you
    call it; it will be printed out in `unittest` report of failed tests. If you choose
    your message carefully, it can be a big help.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方。首先，注意`if`语句中的`not`。由于我们希望在测试应该不通过时运行`fail`，但我们习惯于描述测试应该成功的情况，所以编写测试的一个好方法是先写出成功条件，然后用`not`来反转它。这样我们就可以继续以我们习惯的方式使用`fail`。第二，注意当你调用`fail`时可以传递一个消息；它将在`unittest`的失败测试报告中打印出来。如果你选择一个合适的消息，它可以大有帮助。
- en: Make sure you get it
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保你理解了
- en: Take a look at the following `doctest`. Can you work out how the equivalent
    `unittest` would look like?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的`doctest`。你能想出等效的`unittest`会是什么样子吗？
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That `doctest` code tries to convert a string into an integer; if this conversion
    does not raise a `ValueError`, it reports an error. In `unittest`, that looks
    like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 代码尝试将字符串转换为整数；如果这种转换不会引发 `ValueError`，它将报告一个错误。在 `unittest` 中，这看起来是这样的：'
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How do you check whether two floating point numbers are equal in `unittest`?
    You should use the `assertAlmostEqual` method, so as not to get tripped by the
    floating point imprecision.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在 `unittest` 中检查两个浮点数是否相等？你应该使用 `assertAlmostEqual` 方法，这样就不会被浮点数的不精确性所困扰。
- en: When would you choose to use `assertTrue`? How about `fail`? You would use `assertTrue`
    if none of the more specialized assertions suit your needs. You would use fail
    if you need maximum control when a test succeeds or fails.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在什么情况下选择使用 `assertTrue`？又或者 `fail`？如果你没有更专业的断言满足你的需求，你会使用 `assertTrue`。如果你需要在测试成功或失败时拥有最大控制权，你会使用
    `fail`。
- en: Look back at some of the tests we wrote in the previous chapters, and translate
    them from `doctest` into `unittest`. Given what you already know of `unittest`,
    you should be able to translate any of the tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下我们在前几章中编写的某些测试，并将它们从 `doctest` 转换为 `unittest`。鉴于你已经对 `unittest` 有所了解，你应该能够翻译任何测试。
- en: While you're doing this, think about the relative merits of `unittest` and `doctest`
    for each of the tests that you translate. The two systems have different strengths,
    so it makes sense that each will be the more appropriate choice for different
    situations. When is `doctest` the better choice, and when is `unittest`?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这个过程中，思考一下 `unittest` 和 `doctest` 对你翻译的每个测试的相对优点。这两个系统有不同的优势，因此对于不同的情况，每个系统都将是更合适的选择。在什么情况下
    `doctest` 是更好的选择，而在什么情况下是 `unittest`？
- en: Test fixtures
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试固定装置
- en: The `unittest` has an important and highly useful capability that `doctest`
    lacks. You can tell `unittest` how to create a standardized environment for your
    unit tests to run inside, and how to clean up that environment when it's done.
    This ability to create and later destroy a standardized test environment is a
    test fixture. While test fixtures don't actually make any tests possible that
    were impossible before, they can certainly make them shorter and less repetitive.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 有一个重要且非常有用的功能，这是 `doctest` 所缺乏的。你可以告诉 `unittest` 如何为你的单元测试创建一个标准化的环境，以及如何在完成后清理这个环境。能够创建并在之后销毁一个标准化的测试环境的能力就是测试固定装置。虽然测试固定装置实际上并没有使之前不可能进行的任何测试成为可能，但它们确实可以使测试更短、更少重复。'
- en: Example – testing database-backed units
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 测试数据库支持的单元
- en: 'Many programs need to access a database for their operation, which means that
    many of the units these programs are made of also access a database. The point
    is that the purpose of a database is to store information and make it accessible
    in other, arbitrary places; in other words, databases exist to break the isolation
    of units. The same problem applies to other information stores as well: for example,
    files in permanent storage.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序需要访问数据库以进行操作，这意味着这些程序由许多也访问数据库的单元组成。关键是数据库的目的是存储信息并使其在其他任意位置可访问；换句话说，数据库的存在是为了打破单元的隔离。同样的问题也适用于其他信息存储：例如，永久存储中的文件。
- en: How do we deal with that? After all, just leaving the units that interact with
    the database untested is no solution. We need to create an environment where the
    database connection works as usual, but where any changes that are made do not
    last. There are a few different ways in which we can do this but, no matter what
    the details are, we need to set up the special database connection before each
    test that uses it, and we need to destroy any changes after each such test.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理这个问题？毕竟，仅仅不测试与数据库交互的单元并不是解决方案。我们需要创建一个环境，其中数据库连接像往常一样工作，但所做的任何更改都不会持续。我们可以用几种不同的方式来做这件事，但无论细节如何，我们都需要在每个使用它的测试之前设置特殊的数据库连接，并在每个这样的测试之后销毁任何更改。
- en: The `unittest` helps us do this by providing test fixtures via the `setUp` and
    `tearDown` methods of the `TestCase` class. These methods exist for us to override,
    with the default versions doing nothing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 通过提供 `TestCase` 类的 `setUp` 和 `tearDown` 方法来帮助我们完成这项工作。这些方法存在是为了让我们可以重写，默认版本不执行任何操作。'
- en: 'Here''s some database-using code (let''s say it exists in a file called `employees.py`),
    for which we''re going to write tests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用数据库的代码（假设它存在于一个名为 `employees.py` 的文件中），我们将为它编写测试：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code uses the sqlite3 database that ships with Python. Since the
    `sqlite3` interface is compatible with Python's DB-API 2.0, any database backend
    you find yourself using will have a similar interface to what you see here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了Python附带的sqlite3数据库。由于`sqlite3`接口与Python的DB-API 2.0兼容，因此你使用的任何数据库后端都将具有与这里看到类似的接口。
- en: 'We''ll start off by importing the needed modules and introducing our `TestCase`
    subclass:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入所需的模块并介绍我们的`TestCase`子类：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We need a `setUp` method to create the environment that our tests depend on.
    In this case, that means creating a new database connection to an in-memory-only
    database, and populating that database with the needed tables and rows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`setUp`方法来创建测试所依赖的环境。在这种情况下，这意味着创建一个新的数据库连接到仅内存的数据库，并使用所需的表和行填充该数据库：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need a `tearDown` method to undo whatever the `setUp` method did, so that
    each test can run in an untouched version of the environment. Since the database
    is only in memory, all we have to do is close the connection, and it goes away.
    The `tearDown` method may end up being much more complicated in other scenarios:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`tearDown`方法来撤销`setUp`方法所做的任何操作，以便每个测试都可以在一个未受干扰的环境中运行。由于数据库仅存在于内存中，我们只需关闭连接，它就会消失。在其他场景中，`tearDown`方法可能要复杂得多：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we need the tests themselves:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要测试本身：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We just used a `setUp` method in our `TestCase`, along with a matching `tearDown`
    method. Between them, these methods made sure that the environment in which the
    tests were executed was the one they needed (that was `setUp`'s job) and that
    the environment of each test was cleaned up after the test was run, so that the
    tests didn't interfere with each other (this was the job of `tearDown`). The `unittest`
    made sure that `setUp` was run once before each test method, and that `tearDown`
    was run once after each test method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`TestCase`中只使用了`setUp`方法以及相应的`tearDown`方法。它们之间确保了测试执行的 环境（这是`setUp`的工作）以及每个测试执行后的环境清理，这样测试就不会相互干扰（这是`tearDown`的工作）。`unittest`确保在每次测试方法之前运行一次`setUp`，在每次测试方法之后运行一次`tearDown`。
- en: Because a test fixture—as defined by `setUp` and `tearDown`—gets wrapped around
    every test in a `TestCase` class, the `setUp` and `tearDown` methods for the `TestCase`
    classes that contain too many tests can get very complicated and waste a lot of
    time dealing with details that are unnecessary for some of the tests. You can
    avoid this problem by simply grouping together those tests that require specific
    aspects of the environment into their own `TestCase` classes. Give each `TestCase`
    an appropriate `setUp` and `tearDown`, only dealing with those aspects of the
    environment that are necessary for the tests it contains. You can have as many
    `TestCase` classes as you want, so there's no need to skimp on them when you're
    deciding which tests to group together.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试固定装置——由`setUp`和`tearDown`定义——被包裹在`TestCase`类中的每个测试周围，因此包含太多测试的`TestCase`类的`setUp`和`tearDown`方法可能会变得非常复杂，并且会浪费大量时间处理一些测试中不必要的细节。你可以通过将需要特定环境方面的测试分组到它们自己的`TestCase`类中来避免这个问题。为每个`TestCase`提供一个适当的`setUp`和`tearDown`，只处理测试包含的必要环境方面。你可以有任意多的`TestCase`类，因此当你决定将哪些测试分组在一起时，没有必要在这些类上节省。
- en: 'Notice how simple the `tearDown` method we used was. That''s usually a good
    sign: when the changes that need to be undone in the `tearDown` method are simple
    to describe, it often means that you can be sure of doing this perfectly. Since
    any imperfection of the `tearDown` method makes it possible for the tests to leave
    behind stray data that might alter how other tests behave, getting it right is
    important. In this case, all of our changes were confined inside the database,
    so getting rid of the database does the trick.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的`tearDown`方法是多么简单。这通常是一个好兆头：当需要撤销的`tearDown`方法中的更改简单易描述时，这通常意味着你可以确信能够完美地完成这项工作。由于`tearDown`方法的任何不完善都可能使测试留下可能改变其他测试行为的散乱数据，因此正确执行这一点非常重要。在这种情况下，我们所有的更改都局限于数据库内部，因此删除数据库就完成了这项工作。
- en: We could have used a mock object for the database connection, instead. There's
    nothing wrong with that approach, except that, in this case, it would have been
    more effort for us. Sometimes mock objects are the perfect tool for the job, sometimes
    test fixtures save effort; sometimes you need both to get the job done easily.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用模拟对象来处理数据库连接，这种方法并没有什么问题，只是在这种情况下，对我们来说可能需要更多的努力。有时模拟对象是完成工作的完美工具，有时测试固定装置可以节省精力；有时你需要两者结合才能轻松完成任务。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter contained a lot of information about how to use the `unittest`
    framework to write your tests.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了大量关于如何使用`unittest`框架编写测试的信息。
- en: Specifically, we covered how to use `unittest` to express concepts you were
    already familiar with from `doctest`; differences and similarities between `unittest`
    and doctest; how to use test fixtures to embed your tests in a controlled and
    temporary environment; and how to use the `unittest.mock` patch to decorate test
    methods to further control the environment the test executes inside.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们介绍了如何使用`unittest`来表达你从`doctest`中已经熟悉的概念；`unittest`和doctest之间的差异和相似之处；如何使用测试固定装置将你的测试嵌入到一个受控和临时的环境中；以及如何使用`unittest.mock`补丁来装饰测试方法，以进一步控制测试执行时的环境。
- en: In the next chapter, we'll look at a tool called Nose that is capable of finding
    and running `doctest` tests, `unittest` tests, and ad hoc tests all in the same
    test run and of providing you with a unified test report.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一个名为Nose的工具，它能够在同一测试运行中找到并运行`doctest`测试、`unittest`测试和临时测试，并为你提供统一的测试报告。
