<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Introduction to Arduino Networking"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Introduction to Arduino Networking</h1></div></div></div><p>So far, we used a hardwired serial connection to interact with Arduino, a serial monitor to observe the Arduino serial data, and a Python serial library (<code class="literal">pySerial</code>) to transfer data between the Arduino and Python applications. During this entire exchange, the range of communication was limited due to the hardwired serial connection. As a solution, you can use a wireless <a id="id705" class="indexterm"/>protocol such as <span class="strong"><strong>ZigBee</strong></span>, <span class="strong"><strong>Bluetooth</strong></span>, or <a id="id706" class="indexterm"/>other RF channels to establish a communication channel for a remote serial interface. These wireless protocols are extensively used in remote hardware applications, and they use the serial interface to transfer data. Due to their use of serial communication, these protocols require very little to no additional programming changes on the Arduino or Python side. You may require additional hardware to enable these protocols, however. The major benefit of these protocols is that they are really easy to implement. However, they are restricted with only a small geographical coverage area and limited data bandwidth.</p><p>Besides serial communication methods, the other way to remotely access your Arduino device is to use a computer network. Today, computer networks are the most prolific way of communicating between computing units. In the next two chapters, we will explore various networking techniques using Arduino and Python, which range from establishing very basic Ethernet connectivity to developing complex, cloud-based web applications.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The fundamentals of networking and hardware extensions that enable networking for Arduino</li><li class="listitem" style="list-style-type: disc">Python frameworks used to <a id="id707" class="indexterm"/>develop <span class="strong"><strong>Hypertext Transfer Protocol</strong></span> (<span class="strong"><strong>HTTP</strong></span>) web servers on your computer</li><li class="listitem" style="list-style-type: disc">Interfacing Arduino-based HTTP clients with the Python web server</li><li class="listitem" style="list-style-type: disc">IoT messaging protocol MQTT (we will install a middleware tool called <span class="strong"><strong>Mosquitto</strong></span><a id="id708" class="indexterm"/> to enable MQTT on our computer)</li><li class="listitem" style="list-style-type: disc">Utilizing the publisher/subscriber paradigm, used by MQTT, to develop Arduino-Python web applications</li></ul></div><div class="section" title="Arduino and the computer networking"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Arduino and the computer networking</h1></div></div></div><p>Computer networking is a huge domain, and covering every aspect of networking is not the main <a id="id709" class="indexterm"/>objective of this book. We will, however, try to explain a few fundamentals of computer networking wherever this knowledge will need to be applied. Unlike the <a id="id710" class="indexterm"/>serial interface approach, where a point-to-point connection is required between devices, the network-based approach provides distributed access to resources. Specifically in hardware applications where a single hardware unit is required to be accessed by multiple endpoints (for example, in a personal computer, mobile phone, or remote server), the computer network stands superior.</p><p>In this section, we will cover the basics of networking and hardware components that enable networking in Arduino. Later in this chapter, we will use the Arduino library and a built-in example to demonstrate how remote access to Arduino using your local network works.</p><div class="section" title="Networking fundamentals"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec99"/>Networking fundamentals</h2></div></div></div><p>Whenever you see a <a id="id711" class="indexterm"/>computer or mobile device, you are also looking at some type of computer network being used to connect those devices with other devices. In simple terms, a computer network is a group of interconnected computational devices (also called network nodes) that allow the exchange of data between these devices. These network nodes include various devices such as your personal computers, mobile phones, servers, tablets, routers, and other pieces of networking hardware.</p><p>A computer network can be classified into numerous types according to parameters such as geographical location, network topology, and organizational scope. In terms of geographical scale, a network can be <a id="id712" class="indexterm"/>categorized <a id="id713" class="indexterm"/>into <span class="strong"><strong>local area network</strong></span> (<span class="strong"><strong>LAN</strong></span>), <span class="strong"><strong>home area network</strong></span> (<span class="strong"><strong>HAN</strong></span>), <span class="strong"><strong>wide area network</strong></span> (<span class="strong"><strong>WAN</strong></span>), and so on. When you are utilizing <a id="id714" class="indexterm"/>your home<a id="id715" class="indexterm"/> router <a id="id716" class="indexterm"/>to connect<a id="id717" class="indexterm"/> to the Internet, you are using the LAN created by your router. With regards to the organization that handles the network, LAN can be configured as Intranet, Extranet, and Internet. The Internet is the largest example of any computer network, as it interconnects all types of networks deployed globally. In your implementation of various projects throughout this book, you will mostly be using your LAN and the Internet for the exchange of data between an Arduino, your computer, the Raspberry Pi, and the cloud services.</p><p>To standardize communication between network nodes, various governing bodies and organizations have created a set of rules <a id="id718" class="indexterm"/>called <a id="id719" class="indexterm"/>
<span class="strong"><strong>protocols</strong></span>. In the large list of standard protocols, there are a few protocols that your computer uses on a daily basis. The examples of those protocols associated with the local area network include Ethernet and Wi-Fi. In the IEEE 802 family of standards, the IEEE 802.3 standard describes different types of wired connectivity between nodes in a local area network, also called Ethernet. Similarly, Wireless LAN (also referred to as Wi-Fi), is part of the IEEE 802.11 standard, where a communication channel uses wireless frequency bands to exchange data.</p><p>Most network nodes deployed with IEEE 802 standards (that is, Ethernet, Wi-Fi, and so on) have a unique identifier assigned to the network interface hardware, called a <span class="strong"><strong>media access control</strong></span> (<span class="strong"><strong>MAC</strong></span>) address. This address is assigned by the manufacturer and is mostly <a id="id720" class="indexterm"/>fixed for <a id="id721" class="indexterm"/>each network interface. While using Arduino for network connectivity, we will need the MAC address to enable networking. A MAC address is a 48-bit address, and in human-friendly form it contains six groups of two hexadecimal digits. For example, 01:23:45:67:89:ab is the human-readable form of a 48-bit MAC address.</p><p>While the MAC address is associated with the hardware-level (that is, "physical") protocols, the <a id="id722" class="indexterm"/>
<span class="strong"><strong>Internet Protocol</strong></span> (<span class="strong"><strong>IP</strong></span>) is a communication protocol that is widely used at the Internet <a id="id723" class="indexterm"/>level to enable internetworking between networked nodes. In the implementation of version 4 of the IP protocol suite (IPv4), each network node is assigned a 32-bit number called the <a id="id724" class="indexterm"/>
<span class="strong"><strong>IP address</strong></span> (for example, 192.168.0.1). When you connect a computer, phone, or <a id="id725" class="indexterm"/>any other device to your local home network, an IP address is assigned to that device by your router. One of the most popular IP addresses is 127.0.0.1, which is also called the <a id="id726" class="indexterm"/>
<span class="strong"><strong>localhost</strong></span> IP address. Apart from the IP address assigned to a <a id="id727" class="indexterm"/>computer by the network, each computer also has the localhost IP address associated with it. The localhost IP address is very useful when you want to internally access or call your computer from the same device. In the case of a remote-access application, you need to know the IP address assigned by the network.</p></div><div class="section" title="Obtaining the IP address of your computer"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec100"/>Obtaining the IP address of your computer</h2></div></div></div><p>Arduino is a resource-constrained device, and therefore it can only demonstrate a limited amount <a id="id728" class="indexterm"/>of network capability. While working with Arduino-based projects that include the utilization <a id="id729" class="indexterm"/>of a computer network, you will require a server or Gateway interface. These interfaces include, but are not limited to, a desktop computer, a laptop, the Raspberry Pi, and other remote computing instances. If you are using these interfaces as part of your hardware project, you will need their IP addresses. Ensure that they are under the same network as your Arduino. The following are the techniques to obtain IP addresses in major operating systems.</p><div class="section" title="Windows"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec65"/>Windows</h3></div></div></div><p>In most versions <a id="id730" class="indexterm"/>of the <a id="id731" class="indexterm"/>Windows OS, you can obtain the IP address from the <span class="strong"><strong>Network Connection</strong></span> utility in <span class="strong"><strong>Control Panel</strong></span>. Navigate to <span class="strong"><strong>Control Panel</strong></span> | <span class="strong"><strong>Network and Internet</strong></span> | <span class="strong"><strong>Network Connections</strong></span> and open the <span class="strong"><strong>Local Area Connection Status</strong></span> window. Click on the <span class="strong"><strong>Details</strong></span> button to see the details of the <span class="strong"><strong>Network Connection Details</strong></span> window. As you can see in this screenshot, the IP address of the network interface is listed as <span class="strong"><strong>IPv4 Address</strong></span> in the opened window:</p><div class="mediaobject"><img src="graphics/5938OS_08_01.jpg" alt="Windows"/></div><p>You can also obtain the IP address of your computer using the built-in <code class="literal">ipconfig</code> utility. Open the Command Prompt and enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; ipconfig</strong></span>
</pre></div><p>As you can see in the following screenshot, the IP address of your computer is listed under the Ethernet adapter. If you are using a wireless connection to connect to your network, the Ethernet adapter will be replaced by the wireless Ethernet adapter.</p><div class="mediaobject"><img src="graphics/5938OS_08_02.jpg" alt="Windows"/></div></div><div class="section" title="Mac OS X"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec66"/>Mac OS X</h3></div></div></div><p>If you are <a id="id732" class="indexterm"/>using Mac OS X, you can obtain the IP address from the network settings. Open <span class="strong"><strong>System Preferences</strong></span> and click on the <span class="strong"><strong>Network</strong></span> icon. You will see a window similar <a id="id733" class="indexterm"/>to what is shown in the next screenshot. In the left sidebar, click on the interface you are looking to obtain the IP address of.</p><div class="mediaobject"><img src="graphics/5938OS_08_03.jpg" alt="Mac OS X"/></div><p>If you want to get the IP address using the terminal, you can use the following command. This command will require you to enter the system name of the interface, <code class="literal">en0</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ipconfig getifaddr en0</strong></span>
</pre></div><p>If you are <a id="id734" class="indexterm"/>connected to <a id="id735" class="indexterm"/>multiple networks and are not aware of the network name, you can find the list of IP addresses associated with your computer, using the command shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ifconfig | grep inet</strong></span>
</pre></div><p>As you can see in this screenshot, you will get all the network addresses associated with your Mac computer and other network parameters:</p><div class="mediaobject"><img src="graphics/5938OS_08_04.jpg" alt="Mac OS X"/></div></div><div class="section" title="Linux"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec67"/>Linux</h3></div></div></div><p>On the Ubuntu OS, you<a id="id736" class="indexterm"/> can <a id="id737" class="indexterm"/>obtain the IP address of your computer from the <span class="strong"><strong>Network Settings</strong></span> utility. To open it, navigate to <span class="strong"><strong>System Settings</strong></span> | <span class="strong"><strong>Network</strong></span> and click on the adapter through which the computer is connected to your home network. You can select an appropriate adapter to obtain the IP address, as displayed in the following screenshot:</p><div class="mediaobject"><img src="graphics/5938OS_08_05.jpg" alt="Linux"/></div><p>In a Linux-based system, there are multiple ways of obtaining the IP address from the command line. You can use the same command (<code class="literal">ifconfig</code>) that we used in Mac OS X in the Linux <a id="id738" class="indexterm"/>environment<a id="id739" class="indexterm"/> to obtain the IP address of your computer:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ifconfig</strong></span>
</pre></div><p>You can obtain the IP address from the <code class="literal">inet addr</code> field of the appropriate adapter, as displayed in this screenshot:</p><div class="mediaobject"><img src="graphics/5938OS_08_06.jpg" alt="Linux"/></div><p>If supported by your operating system, another command that can be utilized to obtain the IP address is <code class="literal">hostname</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ hostname –I</strong></span>
</pre></div><p>Be careful when using this utility to obtain the IP address, as you may end up getting the IP address of a different adapter if you are not familiar with the supported command options of the utility.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>If you are going to connect your Arduino to the same local area network as your computer, make sure you are choosing the proper IP address that is covered by the same domain as that of your computer. Also ensure that no other network device is using the same IP address that you have selected for your Arduino. This practice will help you avoid IP address conflicts within the network.</p></div></div></div></div><div class="section" title="Networking extensions for Arduino"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec101"/>Networking extensions for Arduino</h2></div></div></div><p>There are various hardware devices available in the Arduino community that enable networking for the Arduino platform. Among these devices, a few can be used as extensions for <a id="id740" class="indexterm"/>your <a id="id741" class="indexterm"/>existing Arduino board, while others exist as standalone Arduino modules with networking capabilities. The most popular extensions used to enable networking are the Arduino Ethernet Shield and Arduino WiFi Shield. Similarly, Arduino Yún is an example of a standalone Arduino platform that includes built-in networking capabilities. In this book, we are going to develop various networking applications around the Arduino Ethernet Shield. There are also a few other extensions (Arduino GSM Shield) and standalone Arduino platforms (Arduino Ethernet, Arduino Tre, and so on), but we are not going to cover them in detail. Let's get familiar with the following Arduino extensions and board.</p><div class="section" title="Arduino Ethernet Shield"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec68"/>Arduino Ethernet Shield</h3></div></div></div><p>The Arduino Ethernet Shield is an officially supported and open source network extension <a id="id742" class="indexterm"/>designed to <a id="id743" class="indexterm"/>work with Arduino Uno. The Ethernet Shield is equipped with an RJ45 connector to enable Ethernet networking. The Ethernet Shield is designed to mount on top of Arduino Uno and it extends the layout of the pins from your Arduino Uno to the top of the board. The Ethernet Shield is also equipped with a microSD card slot to store important files over the network. Just like most of these shield extensions, the Ethernet Shield is powered by the Arduino board it is attached to.</p><div class="mediaobject"><img src="graphics/5938OS_08_07.jpg" alt="Arduino Ethernet Shield"/><div class="caption"><p>Source: <a class="ulink" href="http://arduino.cc/en/uploads/Main/ArduinoEthernetShield_R3_Front.jpg">http://arduino.cc/en/uploads/Main/ArduinoEthernetShield_R3_Front.jpg</a>
</p></div></div><p>Every Ethernet Shield board is equipped with a unique hardware (MAC) address. You can see it on the back of the board. You may want to note down this hardware address, as it <a id="id744" class="indexterm"/>will be required frequently in the upcoming exercises. Also make sure that you get familiar <a id="id745" class="indexterm"/>with mounting the Arduino Ethernet Shield for those exercises. Buy an Arduino Ethernet Shield module from SparkFun or Amazon before your start working on any <a id="id746" class="indexterm"/>exercises. You can obtain additional information about this Shield at <a class="ulink" href="http://arduino.cc/en/Main/ArduinoEthernetShield"> http://arduino.cc/en/Main/ArduinoEthernetShield</a>.</p></div><div class="section" title="Arduino WiFi Shield"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec69"/>Arduino WiFi Shield</h3></div></div></div><p>The Arduino WiFi Shield has a layout similar to that of the Arduino Ethernet Shield as far <a id="id747" class="indexterm"/>as mounting <a id="id748" class="indexterm"/>on top of the Arduino board is concerned. Instead of the Ethernet RJ45 connector, the WiFi Shield contains components to enable wireless networking. Using the WiFi Shield, you can connect to the IEEE 802.11 (Wi-Fi) wireless networks, which is one of the most popular ways of connecting computers to the home network nowadays.</p><div class="mediaobject"><img src="graphics/5938OS_08_08.jpg" alt="Arduino WiFi Shield"/><div class="caption"><p>Source: <a class="ulink" href="http://arduino.cc/en/uploads/Main/A000058_front.jpg">http://arduino.cc/en/uploads/Main/A000058_front.jpg</a>
</p></div></div><p>The Arduino WiFi Shield requires additional power through a USB connector. It also contains a microSD slot to save files. Just like the Ethernet Shield, you can view the MAC address on the back <a id="id749" class="indexterm"/>of the board. More information about the Arduino WiFi Shield can be found at <a class="ulink" href="http://arduino.cc/en/Main/ArduinoWi-FiShield">http://arduino.cc/en/Main/ArduinoWi-FiShield</a>.</p></div><div class="section" title="Arduino Yún"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec70"/>Arduino Yún</h3></div></div></div><p>Unlike the Ethernet Shield and the WiFi Shield, the Arduino Yún is a standalone variant of the <a id="id750" class="indexterm"/>Arduino board. It includes both Ethernet- and Wi-Fi-based network connectivity, in <a id="id751" class="indexterm"/>addition to the basic Arduino component—the microcontroller. Yún is equipped with the latest and more powerful processing units compared to Uno. Instead of the traditional way of using Arduino code, Yún supports a lightweight version of the Linux operating system, providing functionality similar to a single-board computer such as the Raspberry Pi. You can use your Arduino IDE to program Yún even while running Unix shell scripts.</p><div class="mediaobject"><img src="graphics/5938OS_08_09.jpg" alt="Arduino Yún"/><div class="caption"><p>Source: <a class="ulink" href="http://arduino.cc/en/uploads/Main/ArduinoYunFront_2.jpg">http://arduino.cc/en/uploads/Main/ArduinoYunFront_2.jpg</a>
</p></div></div><p>You can find more<a id="id752" class="indexterm"/> information about Yún at the Arduino official website, at <a class="ulink" href="http://arduino.cc/en/Main/ArduinoBoardYun">http://arduino.cc/en/Main/ArduinoBoardYun</a>.</p></div></div><div class="section" title="Arduino Ethernet library"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec102"/>Arduino Ethernet library</h2></div></div></div><p>The Arduino Ethernet library provides support for the Ethernet protocol, and hence provides <a id="id753" class="indexterm"/>support for <a id="id754" class="indexterm"/>Ethernet extensions of Arduino, such as the Ethernet Shield. This is a standard Arduino library and it gets deployed with the Arduino IDE.</p><p>The library is designed to accept incoming connection requests when deployed as a server and while making outgoing connections to other servers when being utilized as a client. The library concurrently supports up to four connections due to the limited <a id="id755" class="indexterm"/>computation <a id="id756" class="indexterm"/>capability of the Arduino board. To use the Ethernet library in your Arduino program, the first step you have to take is to import it in to your Arduino sketch:</p><div class="informalexample"><pre class="programlisting">#include &lt;Ethernet.h&gt;</pre></div><p>The Ethernet library implements various functionalities through specific classes, which are described as follows.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>We are going to describe only the important methods provided by these classes. You can obtain<a id="id757" class="indexterm"/> more information regarding this library and its classes from <a class="ulink" href="http://arduino.cc/en/Reference/Ethernet">http://arduino.cc/en/Reference/Ethernet</a>.</p></div></div><div class="section" title="The Ethernet class"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec71"/>The Ethernet class</h3></div></div></div><p>The <code class="literal">Ethernet</code> class is<a id="id758" class="indexterm"/> a core class of the Ethernet library, and it provides methods to initialize<a id="id759" class="indexterm"/> this library and the network settings. This is an essential class for any program that wants to use the Ethernet library to establish connections through the Ethernet Shield. The primary information required to establish this connection is the MAC address of the device. You'll need to create a variable that has the MAC address as an array of 6 bytes, as described here:</p><div class="informalexample"><pre class="programlisting">byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };</pre></div><p>The Ethernet library supports <a id="id760" class="indexterm"/>the <span class="strong"><strong>Dynamic Host Control Protocol</strong></span> (<span class="strong"><strong>DHCP</strong></span>), which is responsible for dynamically assigning IP addresses to new network nodes. If your home network is configured to support DHCP, you can establish the Ethernet connection using the <code class="literal">begin(mac)</code> method from the <code class="literal">Ethernet</code> class:</p><div class="informalexample"><pre class="programlisting">Ethernet.begin(mac);</pre></div><p>Keep in mind that when you are initializing an Ethernet connection using this class, you are only initializing the Ethernet connection and setting up the IP address. This means that you still need to configure Arduino as a server or a client in order to enable further communication.</p></div><div class="section" title="The IPAddress class"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec72"/>The IPAddress class</h3></div></div></div><p>In applications where you have to manually assign the IP address to your Arduino device, you <a id="id761" class="indexterm"/>will have to use the <code class="literal">IPAddress</code> class of the Ethernet library. This class provides methods to <a id="id762" class="indexterm"/>specify the IP address, which can be either local or remote depending upon the application:</p><div class="informalexample"><pre class="programlisting">IPAddress ip(192,168,1,177);</pre></div><p>The IP address created using this method can be used in the initialization of the network connection that we performed in the previous section. If you want to assign a manual IP address to your Arduino, you can use the <code class="literal">begin(mac, ip)</code> method with the MAC and IP addresses:</p><div class="informalexample"><pre class="programlisting">Ethernet.begin(mac, ip);</pre></div></div><div class="section" title="The Server class"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec73"/>The Server class</h3></div></div></div><p>The <code class="literal">Server</code> class is designed to create a server using the Ethernet library on Arduino, which <a id="id763" class="indexterm"/>listens to incoming connection requests for a specific port. The <code class="literal">EthernetServer()</code> method, when specified with in integer value of the port number, initializes the <a id="id764" class="indexterm"/>server on Arduino:</p><div class="informalexample"><pre class="programlisting">EthernetServer server = EthernetServer(80);</pre></div><p>By specifying port <code class="literal">80</code> in the previous line of code (which represents the HTTP protocol on the TCP/IP suite), we have specifically created a web server using the Ethernet library. To start listening to the incoming connection requests, you have to use the <code class="literal">begin()</code> method on the <code class="literal">server</code> object:</p><div class="informalexample"><pre class="programlisting">server.begin();</pre></div><p>Once the connection is established, you can respond to a request using various methods supported by the server class, such as <code class="literal">write()</code>, <code class="literal">print()</code>, and <code class="literal">println()</code>.</p></div><div class="section" title="The Client class"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec74"/>The Client class</h3></div></div></div><p>The <code class="literal">Client</code> class provides methods to create an Ethernet client to connect and communicate <a id="id765" class="indexterm"/>with <a id="id766" class="indexterm"/>servers. The <code class="literal">EthernetClient()</code> method initializes a client that can be connected to a specific server using its IP address and port number. The <code class="literal">connect(ip, port)</code> method on the <code class="literal">client</code> object will establish a connection with the server on the mentioned IP address:</p><div class="informalexample"><pre class="programlisting">EthernetClient client;
client.connect(server, 80);</pre></div><p>The <code class="literal">Client</code> class also has the <code class="literal">connected()</code> method, which provides the status of the current connection in binary. This status can be <code class="literal">true</code> (connected) or <code class="literal">false</code> (disconnected). This method is useful for the periodic monitoring of the connection status:</p><div class="informalexample"><pre class="programlisting">client.connected()</pre></div><p>Other important <a id="id767" class="indexterm"/>client methods <a id="id768" class="indexterm"/>include <code class="literal">read()</code> and <code class="literal">write()</code>. These methods help the Ethernet client to read the request from the server and to send messages to the server respectively.</p></div></div><div class="section" title="Exercise 1 – a web server, your first Arduino network program"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec103"/>Exercise 1 – a web server, your first Arduino network program</h2></div></div></div><p>The best way to test the Arduino Ethernet library and the Ethernet Shield is by using the <a id="id769" class="indexterm"/>built-in examples that are deployed with the Arduino IDE. If you are using version 1.x of the Arduino IDE, you can find a bunch of Ethernet examples by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Examples</strong></span> | <span class="strong"><strong>Ethernet</strong></span>. By utilizing one of these examples, we are going to build a web server that delivers the sensor values when requested by a web browser. As Arduino will be connected to your home network through the Ethernet, you will be able to access it from any other computer connected to your network. The major goals for this exercise are listed here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the Arduino Ethernet library with the Arduino Ethernet Shield extension to create a web server</li><li class="listitem" style="list-style-type: disc">Remotely access Arduino using your home computer network</li><li class="listitem" style="list-style-type: disc">Utilize a default Arduino example to provide humidity and motion sensor values using a web server</li></ul></div><p>To achieve these goals, the exercise is divided into the following stages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Design and build hardware for the exercise using your Arduino and the Ethernet Shield</li><li class="listitem" style="list-style-type: disc">Run a default example from the Arduino IDE as the starting point of the exercise</li><li class="listitem" style="list-style-type: disc">Modify the example to accommodate your hardware design and redeploy the code</li></ul></div><p>The following is a Fritzing diagram of the circuit required for this exercise. The first thing you should do is mount the Ethernet Shield on top of your Arduino Uno. Ensure that all the pins of the Ethernet Shield are aligned with the<a id="id770" class="indexterm"/> corresponding pins of the Arduino Uno. Then you need to connect the previously used humidity sensor, HIH-4030, and the PIR motion sensor.</p><div class="mediaobject"><img src="graphics/5938OS_08_10.jpg" alt="Exercise 1 – a web server, your first Arduino network program"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>While deploying the Arduino hardware for remote connectivity without USB, you will have to provide external power for the board, as you no longer have a USB connection to power the board.</p></div></div><p>Now connect your Arduino Uno to a computer using a USB cable. You will also need to connect Arduino to your local home network using an Ethernet cable. To do that, use a straight CAT5 or CAT6 cable and connect one end of the cable to your home router. This router should be the same device that provides network access to the computer you are using. Connect the other end of the Ethernet cable to the Ethernet port of the Arduino Ethernet Shield board. If the physical-level connection has been established correctly, you should see a green light on the port.</p><div class="mediaobject"><img src="graphics/5938OS_08_11.jpg" alt="Exercise 1 – a web server, your first Arduino network program"/></div><p>Now it's time to start coding your first Ethernet example. Open the <span class="strong"><strong>WebServer</strong></span> example by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Examples</strong></span> | <span class="strong"><strong>Ethernet</strong></span> | <span class="strong"><strong>WebServer</strong></span> in your Arduino IDE. As you<a id="id771" class="indexterm"/> can see, the Ethernet library is included with the other required libraries and the supported code. In the code, you will need to change the MAC and IP addresses to make it work for your configuration. While you can obtain the MAC address of the Ethernet Shield from the back of the board, you will have to select an IP address according to your home network configuration. As you have already obtained the IP address of the computer you are working with, select another address in the range. Ensure that no other network node is using this IP address. Use these MAC and IP addresses to update the following values in your code. You will need to repeat these steps for every exercise when you are dealing with Arduino Ethernet:</p><div class="informalexample"><pre class="programlisting">byte mac[] = {0x90, 0xA2, 0xDA, 0x0D, 0x3F, 0x62};
IPAddress ip(10,0,0,75);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>In the IP network, the visible range of IP addresses for your network is a function of another address called<a id="id772" class="indexterm"/> <span class="strong"><strong>subnetwork</strong></span> or <span class="strong"><strong>subnet</strong></span>. The subnet of your LAN IP network can help you select the appropriate IP address for the Ethernet Shield in the range of the IP address of your computer. You <a id="id773" class="indexterm"/>can learn about the basics of the subnet at <a class="ulink" href="http://en.wikipedia.org/wiki/Subnetwork">http://en.wikipedia.org/wiki/Subnetwork</a>.</p></div></div><p>Before venturing further into the code, compile the code with these modifications and upload it to your Arduino. Once the uploading process is completed successfully, open a web browser and enter the IP address that you had specified in the Arduino sketch. If everything goes fine, you should see text displaying the values of the analog pins.</p><p>To better <a id="id774" class="indexterm"/>understand what happened here, let's go back to the code. As you can see, at the beginning of the code we initialize the Ethernet server library on port <code class="literal">80</code> using the <code class="literal">EthernetServer</code> method from the Ethernet library:</p><div class="informalexample"><pre class="programlisting">EthernetServer server(80);</pre></div><p>During the execution of <code class="literal">setup()</code>, the program initializes the Ethernet connection through the Ethernet Shield using the <code class="literal">Ethernet.being()</code> method with the <code class="literal">mac</code> and <code class="literal">ip</code> variables that you defined earlier. The <code class="literal">server.begin()</code> method will start the server from here. Both of these steps are mandatory to start a server if you are using the Ethernet library for server code:</p><div class="informalexample"><pre class="programlisting">Ethernet.begin(mac, ip);
server.begin();</pre></div><p>In the <code class="literal">loop()</code> function, we initialize a <code class="literal">client</code> object to listen to incoming client requests using the <code class="literal">EthernetClient</code> method. This object will respond to any request coming from connected clients that try to access the Ethernet server through port <code class="literal">80</code>:</p><div class="informalexample"><pre class="programlisting">EthernetClient client = server.available();</pre></div><p>On receiving the request, the program will wait for the request payload to end. Then it will reply to the client with formatted HTML data using the <code class="literal">client.print()</code> method:</p><div class="informalexample"><pre class="programlisting">while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        Serial.write(c);
       # Response code
}</pre></div><p>If you try to access the Arduino server from the browser, you will see that the web server replies to the clients with the analog pin readings. Now, to obtain the proper values of the humidity and PIR sensors that we connected in the hardware design, you will have to perform the following modification to the code. You will notice here that we are replying to the clients with the calculated values of relative humidity, instead of raw readings from all the analog pins. We have also modified the text that will be printed in the web browser to match the proper sensor title:</p><div class="informalexample"><pre class="programlisting">if (c == '\n' &amp;&amp; currentLineIsBlank) {
          // send a standard http response header
          client.println("HTTP/1.1 200 OK");
          client.println("Content-Type: text/html");
          client.println("Connection: close");
          client.println("Refresh: 5");
          client.println();
          client.println("&lt;!DOCTYPE HTML&gt;");
          client.println("&lt;html&gt;");
          float sensorReading = getHumidity(analogChannel, temperature);
          client.print("Relative Humidity from HIH4030 is ");
          client.print(sensorReading);
          client.println(" % &lt;br /&gt;");
          client.println("&lt;/html&gt;");
          break;
        }</pre></div><p>In this process, we <a id="id775" class="indexterm"/>also added an Arduino function, <code class="literal">getHumidity()</code>, that will calculate the relative humidity from the values observed from the analog pins. We have already used a similar function to calculate relative humidity in one of the previous projects:</p><div class="informalexample"><pre class="programlisting">float getHumidity(int analogChannel, float temperature){
  float supplyVolt = 5.0;
  int HIH4030_Value = analogRead(analogChannel);
  float analogReading = HIH4030_Value/1023.0 * supplyVolt;
  float sensorReading = 161.0 * analogReading / supplyVolt - 25.8;
  float humidityReading = sensorReading / (1.0546 - 0.0026 * temperature);
  return humidityReading;
}</pre></div><p>You can implement these changes to the <span class="strong"><strong>WebServer</strong></span> Arduino example for the testing phase, or just open the <code class="literal">WebServer_Custom.ino</code> sketch from the <code class="literal">Exercise 1 - Web Server</code> folder of your code directory. As you can see in the opened sketch file, we have already modified the code to reflect the changes, but you will still have to change the MAC and IP addresses to the appropriate addresses. Once you are done with these minor changes, compile and upload the sketch to Arduino. </p><p>If everything goes as planned, you should be able to access the web server using your web browser. Open the IP address of your recently prepared Arduino in the web browser. You should be able to receive a similar response as displayed in the following screenshot. Although we are only displaying humidity values through this sketch, you can easily attach motion sensor values using additional <code class="literal">client.print()</code> methods.</p><div class="mediaobject"><img src="graphics/5938OS_08_12.jpg" alt="Exercise 1 – a web server, your first Arduino network program"/></div><p>Just like the <a id="id776" class="indexterm"/>mechanism we implemented in this exercise, a web server responds to the request made by a web browser and delivers the web pages you are looking for. Although this method is very popular and universally used to deliver web pages, the payload contains a lot of additional metadata compared to the actual size of the sensor information. Also, the server implementation using the Ethernet server library occupies a lot of the Arduino's resources. Arduino, being a resource-constrained device, is not suitable for running a server application, as the Arduino's resources should be prioritized to handle the sensors rather than communication. Moreover, the web server created using the Ethernet library supports a very limited amount of connections at a time, making it unusable for large-scale applications and multiuser systems.</p><p>The best approach to overcome this problem is by using Arduino as a client device, or by using lightweight communication protocols that are designed to work with resource-constrained hardware devices. In the next few sections, you are going to learn and implement these approaches for Arduino communication on the Ethernet.</p></div></div></div>
<div class="section" title="Developing web applications using Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec55"/>Developing web applications using Python</h1></div></div></div><p>By implementing the previous program, you have enabled networking on Arduino. In the preceding example, we created an HTTP web server using methods available from the Ethernet library. By creating an Arduino web server, we made the Arduino resources <a id="id777" class="indexterm"/>available on the network. Similarly, Python also provides extensibility by way of various libraries to create web server interfaces. By running the Python-based web server on your computer or other devices such as the Raspberry Pi, you can avoid using Arduino to host the web server. Web applications created using high-level languages such as Python can also provide additional capabilities and extensibility compared to Arduino.</p><p>In this section, we will use the Python library, <code class="literal">web.py</code>, to create a Python web server. We will also use this library to create interactive web applications that will enable the transfer of data between an Arduino client and a web browser. After you have learned the basics of <code class="literal">web.py</code>, we will interface Arduino with <code class="literal">web.py</code> using serial ports to make Arduino accessible through the Python web server. Then we will upgrade the Arduino communication method from the serial interface to HTTP-based messaging.</p><div class="section" title="Python web framework – web.py"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec104"/>Python web framework – web.py</h2></div></div></div><p>A web server <a id="id778" class="indexterm"/>can be developed in Python using various web frameworks such as <code class="literal">Django</code>, <code class="literal">bottle</code>, <code class="literal">Pylon</code>, and <code class="literal">web.py</code>. We have selected <code class="literal">web.py</code> as the preferred web framework due<a id="id779" class="indexterm"/> to its simple yet powerful functionalities. </p><p>The <code class="literal">web.py</code> library was initially developed by the late Aaron Swartz with the goal of developing an easy and straightforward approach to create web applications using Python. This library provides<a id="id780" class="indexterm"/> two main methods, <code class="literal">GET</code> and <code class="literal">POST</code>, to support the HTTP <span class="strong"><strong>Representation State Transfer</strong></span> (<span class="strong"><strong>REST</strong></span>) architecture. This architecture is designed to support the HTTP protocol by sending and receiving data between clients and the server. Today, the REST architecture is implemented by a huge number of websites to transfer data over HTTP.</p><div class="section" title="Installing web.py"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec75"/>Installing web.py</h3></div></div></div><p>To get started <a id="id781" class="indexterm"/>with <code class="literal">web.py</code>, you need to install the <code class="literal">web.py</code> library using Setuptools. We installed Setuptools for <a id="id782" class="indexterm"/>various operating systems in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Python and Arduino">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Python and Arduino</em></span>. On Linux and Mac OS X, execute either of these commands on the terminal to install <code class="literal">web.py</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo easy_install web.py</strong></span>
<span class="strong"><strong>$ sudo pip install web.py</strong></span>
</pre></div><p>On Windows, open the <span class="strong"><strong>Command Prompt</strong></span> and execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; easy_install.exe web.py</strong></span>
</pre></div><p>If Setuptools is <a id="id783" class="indexterm"/>set up <a id="id784" class="indexterm"/>correctly, you should be able to install the library without any difficulty. To verify the installation of the library, open the Python interactive prompt and run this command to see whether you have imported the library without any errors:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import web</strong></span>
</pre></div></div><div class="section" title="Your first Python web application"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec76"/>Your first Python web application</h3></div></div></div><p>Implementing a <a id="id785" class="indexterm"/>web server using <code class="literal">web.py</code> is a very simple and straightforward process. The <code class="literal">web.py</code> library requires the declaration of a mandatory method, <code class="literal">GET</code>, to successfully start the web server. When a client tries to access the server using a web browser or another client, <code class="literal">web.py</code> receives a <code class="literal">GET</code> request and returns data as specified by the method. To create a simple web application using the <code class="literal">web.py</code> library, create a Python file using the following lines of code and execute the file using Python. You can also run the <code class="literal">webPyBasicExample.py</code> file from the code folder of this chapter:</p><div class="informalexample"><pre class="programlisting">import web
urls = (
    '/', 'index'
)
class index:
    def GET(self):
        return "Hello, world!"
if __name__ == "__main__":
    app = web.application(urls, globals())
    app.run()</pre></div><p>On execution, you will see that the server is now running and accessible through the <code class="literal">http://0.0.0.0:8080</code> address. As the server program is running on the <code class="literal">0.0.0.0</code> IP address, you can access it using the same computer, localhost, or any other computer from the same network.</p><p>To check out the server, open a web browser and go to <code class="literal">http://0.0.0.0:8080</code>. When you are trying to access the server from the same computer, you can also use <code class="literal">http://127.0.0.1:8080</code> or <code class="literal">http://localhost:8080</code>. The <code class="literal">127.0.0.1</code> IP address actually stands for localhost, that is, the network address of the same computer on which the program is running. You will be able to see the response of the server displayed in the browser, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5938OS_08_13.jpg" alt="Your first Python web application"/></div><p>To understand how this simple code works, check out the <code class="literal">GET</code> method in the previous code <a id="id786" class="indexterm"/>snippet. As you can see, when the web browser requests the URL, the <code class="literal">GET</code> method returns the <code class="literal">Hello, world!</code> string to the browser. Meanwhile, you can also observe two other mandatory <code class="literal">web.py</code> components in your code: the <code class="literal">urls</code> and <code class="literal">web.application()</code> methods. The <code class="literal">web.py</code> library requires initialization of the response location in the declaration of the <code class="literal">urls</code> variable. Every <code class="literal">web.py</code>-based web application requires the <code class="literal">application(urls, global())</code> method to be called to initialize the web server. By default, the <code class="literal">web.py</code> applications run on port number <code class="literal">8080</code>, which can be changed to another port number by specifying it during execution. For example, if you want to run your <code class="literal">web.py</code> application on port <code class="literal">8888</code>, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python webPyBasicExample.py 8888</strong></span>
</pre></div><p>Although this only returns simple text, you have now successfully created your first web application using Python. We will take it forward from here and create more complex web applications in the upcoming chapters using the <code class="literal">web.py</code> library. To develop these complex applications, we will require more than just the <code class="literal">GET</code> method. Let's start exploring advance concepts to further enhance your familiarity with the <code class="literal">web.py</code> library.</p></div></div><div class="section" title="Essential web.py concepts for developing complex web applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec105"/>Essential web.py concepts for developing complex web applications</h2></div></div></div><p>The <code class="literal">web.py</code> library<a id="id787" class="indexterm"/> has been designed to provide convenient and simple methods to develop dynamic websites and web applications using Python. Using <code class="literal">web.py</code>, it is really easy to build complex websites by utilizing just a few additional Python concepts along with what you already know. Due to this limited learning curve and easy-to-implement methods, <code class="literal">web.py</code> is one of the quickest ways to create web applications in any programming language. Let's begin with understanding these <code class="literal">web.py</code> concepts in detail.</p><div class="section" title="Handling URLs"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec77"/>Handling URLs</h3></div></div></div><p>You might have <a id="id788" class="indexterm"/>noticed that in our first <code class="literal">web.py</code> program, we defined a variable called <code class="literal">urls</code> that points to the root location (<code class="literal">/</code>) of the <code class="literal">Index</code> class:</p><div class="informalexample"><pre class="programlisting">urls = (
    '/', 'index'
)</pre></div><p>In the preceding declaration, the first part, <code class="literal">'/'</code>, is a regular expression used to match the actual URL requests. You can use regular expressions to handle complex queries coming to your <code class="literal">web.py</code> server and point them to the appropriate class. In <code class="literal">web.py</code>, you can associate different landing page locations with appropriate classes. For example, if you want to redirect the <code class="literal">/data</code> location to the <code class="literal">data</code> class in addition to the <code class="literal">Index</code> class, you can change the <code class="literal">urls</code> variable as follows:</p><div class="informalexample"><pre class="programlisting">urls = (
    '/', 'index',
    '/data', 'data',
)</pre></div><p>With this provision, when a client sends a request to access the <code class="literal">http://&lt;ip-address&gt;:8080/data</code> address, the request will be directed towards the <code class="literal">data</code> class and then the <code class="literal">GET</code> or <code class="literal">POST</code> method of that class.</p></div><div class="section" title="The GET and POST methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec78"/>The GET and POST methods</h3></div></div></div><p>In exercise 1, where we created an Arduino-based web server running on port <code class="literal">80</code>, we used a <a id="id789" class="indexterm"/>web browser to access the web server. Web browsers are one of the most popular types of web <a id="id790" class="indexterm"/>clients used to access a web server; cURL, Wget, and web crawlers are the other types. A web browser uses HTTP to communicate with any web servers, including the Arduino web server that we used. <code class="literal">GET</code> and <code class="literal">POST</code> are two fundamental methods supported by the HTTP protocol to address server requests coming from a web browser.</p><p>Whenever you are trying to open a website in your browser or any other HTTP client, you are actually requesting the <code class="literal">GET</code> function from the web server; for example, when you open a website URL, <code class="literal">http://www.example.com/</code>, you are requesting that the web server that hosts this website serves you the <code class="literal">GET</code> request for the <code class="literal">'/'</code> location. In the <span class="emphasis"><em>Handling URLs</em></span> section, you learned how to associate the <code class="literal">web.py</code> classes with URL landing locations. Using the <code class="literal">GET</code> method provided by the <code class="literal">web.py</code> library, you can associate the <code class="literal">GET</code> request with individual classes. Once you have captured the <code class="literal">GET</code> request, you need to return appropriate values as the response to the client. The following code snippet shows how the <code class="literal">GET()</code> function will be called when anyone makes a <code class="literal">GET</code> request to the <code class="literal">'/'</code> location:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">def GET(self):</code>
  f = self.submit_form()
  f.validates()
  t = 75
  return render.test(f,t);</pre></div><p>The <code class="literal">POST</code> function of the HTTP protocol is mainly used to submit a form or any other data to the web server. In most cases, <code class="literal">POST</code> is embedded in a web page, and a request to the<a id="id791" class="indexterm"/> server is <a id="id792" class="indexterm"/>generated when a user submits the component carrying the <code class="literal">POST</code> function. The <code class="literal">web.py</code> library also provides the <code class="literal">POST()</code> function, which is called when a web client tries to contact the <code class="literal">web.py</code> server using the <code class="literal">POST</code> method. In most implementations of the <code class="literal">POST()</code> function, the request includes some kind of data submitted through forms. You can retrieve individual form elements using <code class="literal">f['Celsius'].value</code> which will give you a value associated with the form element called <code class="literal">Celsius</code>. Once the <code class="literal">POST()</code> function has performed the provided actions, you can return appropriate information to the client in response to the <code class="literal">POST</code> request:</p><div class="informalexample"><pre class="programlisting">    def POST(self):
        f = self.submit_form()
        f.validates()
        c = f['Celsius'].value
        t = c*(9.0/5.0) + 32
        return render.test(f,t)</pre></div></div><div class="section" title="Templates"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec79"/>Templates</h3></div></div></div><p>Now you know how to redirect an HTTP request to an appropriate URL, and also how to implement <a id="id793" class="indexterm"/>methods to respond to these HTTP requests (that is, <code class="literal">GET</code> and <code class="literal">POST</code>). But what about the web page that needs to be rendered once the request is received? To understand the rendering process, let's start with creating a folder called <code class="literal">templates</code> in the same directory where our <code class="literal">web.py</code> program is going to be placed. This folder will store the templates that will be used to render the web pages when requested. You have to specify the location of this template folder in the program using the <code class="literal">template.render()</code> function, as displayed in the following line of code:</p><div class="informalexample"><pre class="programlisting">render = web.template.render('templates')</pre></div><p>Once you have instantiated the rendering folder, it is time to create template files for your program. According to the requirements of your program, you can create as many template files as you want. A language called <a id="id794" class="indexterm"/>
<span class="strong"><strong>Templetor</strong></span> is used to create these template files in <code class="literal">web.py</code>. You can learn <a id="id795" class="indexterm"/>more about it at <a class="ulink" href="http://webpy.org/templetor">http://webpy.org/templetor</a>. Each template file created using Templetor needs to be stored in the HTML format with the <code class="literal">.html</code> extension. </p><p>Let's create a file called <code class="literal">test.html</code> in the <code class="literal">templates</code> folder using a text editor and paste the following code snippet in to the file:</p><div class="informalexample"><pre class="programlisting">$def with(form, i)
&lt;form method="POST"&gt;
    $:form.render()
&lt;/form&gt;
&lt;p&gt;Value is: $:i &lt;/p&gt;</pre></div><p>As you can see in the <a id="id796" class="indexterm"/>preceding code snippet, the template file begins with the <code class="literal">$def with()</code> expression, where you need to specify the input arguments as variables within the brackets. Once the template is rendered, these will be the only variables you can utilize for the web page; for example, in the previous code snippet, we passed two variables (<code class="literal">form</code> and <code class="literal">i</code>) as input variables. We utilized the <code class="literal">form</code> object using <code class="literal">$:form.render()</code> to render it inside the web page. When you need to render the <code class="literal">form</code> object, you can directly pass the other variable by simply declaring it (that is, <code class="literal">$:i</code>). Templetor will render the HTML code of the template file as it is, while utilizing the variables in the instances where they are being used.</p><p>Now you have a template file, <code class="literal">test.html</code>, ready to be used in your <code class="literal">web.py</code> program. Whenever a <code class="literal">GET()</code> or <code class="literal">POST()</code> function is executed, you are required to return a value to the requesting client. Although you can return any variable for these requests, including <code class="literal">None</code>, you will have to render a template file where the response is associated with loading a web page. You can return the template file using the <code class="literal">render()</code> function, followed by the filename of the template file and input arguments:</p><div class="informalexample"><pre class="programlisting">return render.test(f, i);</pre></div><p>As you can see in the preceding line of code, we are returning the rendered <code class="literal">test.html</code> page by specifying the <code class="literal">render.test()</code> function, where <code class="literal">test()</code> is just the filename without the <code class="literal">.html</code> extension. The function also includes a form object, <code class="literal">f</code>, and variable, <code class="literal">i</code>, that will be passed as input arguments.</p></div><div class="section" title="Forms"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec80"/>Forms</h3></div></div></div><p>The <code class="literal">web.py</code> library <a id="id797" class="indexterm"/>provides simple ways of creating form elements using the <code class="literal">Form</code> module. This module includes the capability to create HTML form elements, obtain inputs from users, and validate these inputs before utilizing them in the Python program. In the following code snippet, we are creating two form elements, <code class="literal">Textbox</code> and <code class="literal">Button</code>, using the <code class="literal">Form</code> library:</p><div class="informalexample"><pre class="programlisting">    submit_form = form.Form(
      form.Textbox('Celsius', description = 'Celsius'),
      form.Button('submit', type="submit", description='submit')
    )</pre></div><p>Besides <code class="literal">Textbox</code> (which obtains text input from users) and <code class="literal">Button</code> (which submits the form), the <code class="literal">Form</code> module also provides a few other form elements, such as <code class="literal">Password</code> to <a id="id798" class="indexterm"/>obtain hidden text input, <code class="literal">Dropbox</code> to obtain a mutually exclusive input from a drop-down list, <code class="literal">Radio</code> to obtain mutually exclusive inputs from multiple options, and <code class="literal">Checkbox</code> to select a binary input from the given options. While all of these elements are very easy to implement, you should select form elements only according to your program requirements.</p><p>In the <code class="literal">web.py</code> implementation of <code class="literal">Form</code>, the web page needs to execute the <code class="literal">POST</code> method every time the form is submitted. As you can in see in the following implementation of the form in the template file, we are explicitly declaring the form submission method as <code class="literal">POST</code>:</p><div class="informalexample"><pre class="programlisting">$def with(form, i)
&lt;form method="POST"&gt;
    $:form.render()
&lt;/form&gt;</pre></div></div></div><div class="section" title="Exercise 2 – playing with web.py concepts using the Arduino serial interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec106"/>Exercise 2 – playing with web.py concepts using the Arduino serial interface</h2></div></div></div><p>Now you have a general idea of the basic <code class="literal">web.py</code> concepts used to build a web application. In this exercise, we will utilize the concepts you learned to create an application to <a id="id799" class="indexterm"/>provide the Arduino with sensor information. As the goal of this exercise is to demonstrate the <code class="literal">web.py</code> server for Arduino data, we are not going to utilize the Ethernet Shield for communication. Instead, we will capture the Arduino data using the serial interface, while using the <code class="literal">web.py</code> server to respond to the requests coming from different clients. </p><p>As you can see in the following diagram, we are using the same hardware that you designed for exercise 1, but without utilizing the Ethernet connection to our home router. Your computer running the <code class="literal">web.py</code> server, which is also a part of your home network, will serve the client requests.</p><div class="mediaobject"><img src="graphics/5938OS_08_14.jpg" alt="Exercise 2 – playing with web.py concepts using the Arduino serial interface"/></div><p>In the first step, we<a id="id800" class="indexterm"/> are going to code Arduino to periodically send the humidity sensor value to the serial interface. For the Arduino code, open the <code class="literal">WebPySerialExample_Arduino.ino</code> sketch from the <code class="literal">Exercise 2</code> folder of your code directory. As you can see in the following code snippet of the Arduino sketch, we are sending raw values from the analog port to the serial interface. Now compile and upload the sketch to your Arduino board. Open the <span class="strong"><strong>Serial Monitor</strong></span> window from the Arduino IDE to confirm that you are receiving the raw humidity observations. Once you have confirmed it, close the <span class="strong"><strong>Serial Monitor</strong></span> window. You won't be able to run the Python code if the <span class="strong"><strong>Serial Monitor</strong></span> window is using the port:</p><div class="informalexample"><pre class="programlisting"> void loop() {
  int analogChannel = 0;
  int HIH4030_Value = analogRead(analogChannel);
  Serial.println(HIH4030_Value);
  delay(200); 
}</pre></div><p>Once the Arduino code is running properly, it is time to execute the Python program, which contains the <code class="literal">web.py</code> server. The Python program for this exercise is located in the <code class="literal">WebPySerialExample_Python</code> directory. Open the <code class="literal">webPySerialExample.py</code> file in your code editor. The Python program is organized in two sections: capturing sensor data from the serial interface using the <code class="literal">pySerial</code> library, and using the <code class="literal">web.py</code> server-based server to respond to the requests from the clients.</p><p>In the first stage of the code, we are interfacing the serial port using the <code class="literal">Serial()</code> method from the <code class="literal">pySerial</code> library. Don't forget to change the serial port name as it may be different for your computer, depending on the operating system and physical port that you are using:</p><div class="informalexample"><pre class="programlisting">import serial
port = serial.Serial('/dev/tty.usbmodemfa1331', 9600, timeout=1)</pre></div><p>Once the <code class="literal">port</code> object for the serial port is created, the program starts reading the text coming from <a id="id801" class="indexterm"/>the physical port, using the <code class="literal">readline()</code> method. Using the <code class="literal">relativeHumidity()</code> function, we convert the raw humidity data to appropriate relative humidity observations:</p><div class="informalexample"><pre class="programlisting">line = port.readline()
if line:
  data = float(line)
  humidity = relativeHumidity(line, 25)</pre></div><p>On the web server side, we will be using all the major <code class="literal">web.py</code> components you learned in the previous section to complete this goal. As part of it, we are implementing an input form for the temperature value. We will capture this user input and utilize it with the raw sensor data to calculate relative humidity. Therefore, we need to define the <code class="literal">render</code> object to use the <code class="literal">template</code> directory. In this exercise, we are only using the default landing page location ( <code class="literal">'/'</code>) for the web server, which is directed towards the <code class="literal">Index</code> class:</p><div class="informalexample"><pre class="programlisting">render = web.template.render('templates')</pre></div><p>As you can see in the <code class="literal">WebPySerialExample_Python</code> folder, we have a directory called <code class="literal">templates</code>. This directory contains a template with the <code class="literal">base.html</code> filename. As this is an HTML file, it is likely that if you just click on the file, it opens in a web browser. Make sure that you open the file in a text editor. In the opened file, you'll see that we are initializing the template file with <code class="literal">$def with(form, humidity)</code>. In this initialization, <code class="literal">form</code> and <code class="literal">humidity</code> are input variables that are required by the template during the rendering process. The template declares the actual <code class="literal">&lt;form&gt;</code> element with the <code class="literal">$:form.render()</code> method, while displaying the humidity value using the <code class="literal">$humidity</code> variable:</p><div class="informalexample"><pre class="programlisting">&lt;form method="POST"&gt;
    $:form.render()
&lt;/form&gt;
&lt;h3&gt;Relative Humidity is:&lt;/h3&gt;
&lt;p name="temp"&gt;$humidity &lt;/p&gt;</pre></div><p>Although the template file renders the <code class="literal">form</code> variable, we have to define this variable in the Python program first. As you can see in the following code snippet, we have declared a variable called <code class="literal">submit_form</code> using the <code class="literal">form.Form()</code> method of the <code class="literal">web.py</code> library. The <code class="literal">submit_form</code> variable includes a <code class="literal">Textbox</code> element to capture the temperature <a id="id802" class="indexterm"/>value and a <code class="literal">Button</code> element to enable the submit action:</p><div class="informalexample"><pre class="programlisting">submit_form = form.Form(
  form.Textbox('Temperature', description = 'Temperature'),
  form.Button('submit', type="submit", description='submit')
  )</pre></div><p>When you want to access the current submitted values of the <code class="literal">submit_form</code> variable, you will have to validate the form using the <code class="literal">validates()</code> method:</p><div class="informalexample"><pre class="programlisting">f = self.submit_form()
f.validates()</pre></div><p>Now we have the user-facing web page and input components designed for the exercise. It is time to define the two main methods, <code class="literal">GET</code> and <code class="literal">POST</code>, to respond to the request coming from the web page. When you launch or refresh the web page, the <code class="literal">web.py</code> server generates the <code class="literal">GET</code> request, which is then handled by the <code class="literal">GET</code> function of the <code class="literal">Index</code> class. So during the execution of the <code class="literal">GET</code> method, the program obtains the latest raw humidity value from the serial port and calculates the relative humidity using the <code class="literal">relativeHumidity()</code> method. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>In the process of dealing with the <code class="literal">GET</code> request, we are not submitting any form with the user input. For this reason, in the <code class="literal">GET</code> method, we will use the default value of temperature (<code class="literal">25</code>) for the <code class="literal">relativeHumidity()</code> method.</p></div></div><p>Once the humidity value is derived, the program will render the <code class="literal">base</code> template using the <code class="literal">render.base()</code> function, as displayed in the following code snippet, where <code class="literal">base()</code> refers to the base template:</p><div class="informalexample"><pre class="programlisting">def GET(self):
  f = self.submit_form()
  f.validates()
  line = port.readline()
  if line:
    data = float(line)
    humidity = relativeHumidity(line, 25)
    return render.base(f,humidity);
  else:
    return render.base(f, "Not valid data");</pre></div><p>Contrary to the <code class="literal">GET</code> method, the <code class="literal">POST</code> method is invoked when the form is submitted to the web page. The submitted form includes the temperature value provided by the user, which will be used to obtain the value of the relative humidity. Like the <code class="literal">GET() </code>function, the <code class="literal">POST()</code> function also renders the <code class="literal">base</code> template with the recent humidity value once the humidity is calculated:</p><div class="informalexample"><pre class="programlisting">def POST(self):
  f = self.submit_form()
  f.validates()
  temperature = f['Temperature'].value
  line = port.readline()
  if line:
    data = float(line)
    humidity = relativeHumidity(line, float(temperature))
    return render.base(f, humidity);
  else:
    return render.base(f, "Not valid data");</pre></div><p>Now it is time<a id="id803" class="indexterm"/> to run the <code class="literal">web.py</code>-based web server. In the Python program, make the necessary changes to accommodate the serial port name and any other appropriate values. If everything is configured correctly, you will be able to execute the program from the terminal without any errors. You can access the web server, which is running on port <code class="literal">8080</code>, from a web browser on the same computer, that is, <code class="literal">http://localhost:8080</code>. Now the goal of the exercise is to demonstrate the remote accessibility of the web server from your home network, and you can do this by opening the website from another computer in your network, that is, <code class="literal">http://&lt;ip-address&gt;:8080</code>, where <code class="literal">&lt;ip-address&gt;</code> refers to the IP address of the computer that is running the <code class="literal">web.py</code> service.</p><div class="mediaobject"><img src="graphics/5938OS_08_15.jpg" alt="Exercise 2 – playing with web.py concepts using the Arduino serial interface"/></div><p>The preceding screenshot shows how the web application will look when opened in a web browser. When you load the website, you will be able to see a relative humidity <a id="id804" class="indexterm"/>value obtained using the <code class="literal">GET</code> method. Now you can enter an appropriate temperature value and press the <span class="strong"><strong>submit</strong></span> button to invoke the <code class="literal">POST</code> method. On successful execution, you will be able to see the latest relative humidity value, which is calculated based on the temperature value that you submitted.</p></div></div>
<div class="section" title="RESTful web applications with Arduino and Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec56"/>RESTful web applications with Arduino and Python</h1></div></div></div><p>In the previous exercise, we implemented the <code class="literal">GET</code> and <code class="literal">POST</code> requests using the <code class="literal">web.py</code> library. These requests are actually part of the most popular communication architecture of the <a id="id805" class="indexterm"/>
<span class="strong"><strong>World Wide Web</strong></span> (<span class="strong"><strong>WWW</strong></span>) called REST. The REST architecture implements <a id="id806" class="indexterm"/>a client-server paradigm using the HTTP protocol for operations such as <code class="literal">POST</code>, <code class="literal">READ</code>, and <code class="literal">DELETE</code>. The <code class="literal">GET()</code> and <code class="literal">POST()</code> functions, implemented using <code class="literal">web.py</code>, are functional subsets of these standard HTTP REST operations, that is, <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">UPDATE</code>, and <code class="literal">DELETE</code>. The REST architecture is designed for network applications, websites, and web services to establish communication through HTTP-based calls. Rather than being just a set of standard rules, the REST architecture utilizes existing web technologies and protocols, making it a core component of the majority of the websites we use today. Due to this reason, the WWW can be considered to be the largest implementation of REST-based architecture.</p><div class="section" title="Designing REST-based Arduino applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec107"/>Designing REST-based Arduino applications</h2></div></div></div><p>The REST architecture uses a client-server model, where the server acts as a centralized <a id="id807" class="indexterm"/>node in the network. It responds to the requests made by the distributed network nodes (called <span class="strong"><strong>clients</strong></span>) that query it. In this paradigm, the client initiates a request for the state directed towards the server, while the server responds to the state request without storing the client context. This communication is always one-directional and always initiated from the client side.</p><div class="mediaobject"><img src="graphics/5938OS_08_16.jpg" alt="Designing REST-based Arduino applications"/></div><p>To further <a id="id808" class="indexterm"/>explain the state transfer for the <code class="literal">GET</code> and <code class="literal">POST</code> requests, check out the previous diagram. When a client sends a <code class="literal">GET</code> request to a server using a URL, the server responds with raw data as the HTTP response. Similarly, in the <code class="literal">POST</code> request, the client sends data as payload to the server, while the server responds with simply a "received confirmation" message.</p><p>REST methods are relatively simple to implement and develop using simple HTTP calls. We are going to start developing Arduino networking applications using REST-based requests, as they are easy to implement and understand and are directly available through examples. We will begin by individually implementing REST-based Arduino clients for HTTP-based <code class="literal">GET</code> and <code class="literal">POST</code> methods. Later in this chapter, we will go through an exercise to combine the <code class="literal">GET</code> and <code class="literal">POST</code> methods through the same Arduino REST client, while developing the HTTP server using <code class="literal">web.py</code>.</p></div><div class="section" title="Working with the GET request from Arduino"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec108"/>Working with the GET request from Arduino</h2></div></div></div><p>In this exercise, we <a id="id809" class="indexterm"/>will implement the HTTP <code class="literal">GET</code> client on Arduino, while using an HTTP server that was developed using <code class="literal">web.py</code>. The premise of this programming exercise is to use the Ethernet Shield extension and the Ethernet library to develop a physical Arduino HTTP client that supports the <code class="literal">GET</code> request.</p><div class="section" title="The Arduino code to generate the GET request"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec81"/>The Arduino code to generate the GET request</h3></div></div></div><p>The Arduino IDE ships <a id="id810" class="indexterm"/>with a few basic examples that utilize the Ethernet library. One of these examples is <span class="strong"><strong>WebClient</strong></span>, which can be found by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Examples</strong></span> | <span class="strong"><strong>Ethernet</strong></span> | <span class="strong"><strong>WebClient</strong></span>. It is designed to demonstrate the <code class="literal">GET</code> request by implementing the HTTP client on Arduino. Open this sketch in the Arduino IDE, as we are going to use this sketch and modify it to accommodate the Arduino hardware we created.</p><p>The first thing you need to change in the opened sketch is the IP address and the MAC address of your Arduino Ethernet Shield. Replace the following variables with the variables appropriate for your system. The following code snippet shows the IP address <a id="id811" class="indexterm"/>and the MAC address for our hardware, and you need to change it to accommodate yours:</p><div class="informalexample"><pre class="programlisting">byte mac[] = { 0x90, 0xA2, 0xDA, 0x00, 0x47, 0x28 };
IPAddress ip(10,0,0,75);</pre></div><p>As you can see, the example uses Google as a server to get a response. You need to change this address to reflect the IP address of your computer, which will host the <code class="literal">web.py</code> server:</p><div class="informalexample"><pre class="programlisting">char server[] = "10.0.0.20";</pre></div><p>In the <code class="literal">setup()</code> function, you will have to change the server IP address again. Also change the default HTTP port (<code class="literal">80</code>) to the port used by <code class="literal">web.py</code> (<code class="literal">8080</code>):</p><div class="informalexample"><pre class="programlisting">  if (client.connect(server, 8080)) {
    Serial.println("connected");
    // Make a HTTP request:
    client.println("GET /data HTTP/1.1");
    client.println("Host: 10.0.0.20");
    client.println("Connection: close");
    client.println();
  }</pre></div><p>Once you have made all of these changes, go to the <code class="literal">Arduino_GET_Webpy\ArduinoGET</code> folder and open the <code class="literal">ArduinoGET.ino</code> sketch. Compare your modified sketch with this sketch and perform the appropriate changes. Now you can save your sketch and compile your code for any errors.</p><p>At this stage, we are assuming that you have the Arduino Ethernet Shield mounted on your Arduino Uno. Connect the Ethernet Shield to your local network using an Ethernet cable, and connect Uno with your computer using a USB cable. Upload the sketch to the Arduino board and open the <span class="strong"><strong>Serial Monitor</strong></span> window to check the activity. At this stage, Arduino would not be able to connect to the server because your <code class="literal">web.py</code> server is still not running. You can close the serial monitor for now.</p></div><div class="section" title="The HTTP server using web.py to handle the GET request"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec82"/>The HTTP server using web.py to handle the GET request</h3></div></div></div><p>In your first <code class="literal">web.py</code> application, you developed a server that returned <code class="literal">Hello, world!</code> when requested from a web browser. Despite all the additional tasks it can perform, your web browser is an HTTP client at its core. This means that if your first <code class="literal">web.py</code> server code <a id="id812" class="indexterm"/>was able to respond to the <code class="literal">GET</code> request made by the web browser, it should also be able to respond to the Arduino web client. To check this out, open your first <code class="literal">web.py</code> program, <code class="literal">webPyBasicExample.py</code>, and change the return string from <code class="literal">Hello World!</code> to <code class="literal">test</code>. We are performing this string change to differentiate it from the other instances of this program. Execute the Python program from the terminal and open the <span class="strong"><strong>Serial Monitor</strong></span> window in the Arduino IDE again. This time, you will be able to see that your Arduino client is receiving a response for the <code class="literal">GET</code> request it sent to the <code class="literal">web.py</code> server. As you can see in the following screenshot, you will be able to see the <code class="literal">test</code> string printed in the <span class="strong"><strong>Serial Monitor</strong></span> window, which is returned by the <code class="literal">web.py</code> server for the <code class="literal">GET</code> request:</p><div class="mediaobject"><img src="graphics/5938OS_08_17.jpg" alt="The HTTP server using web.py to handle the GET request"/></div><p>Although in this example we are returning a simple string for the <code class="literal">GET</code> request, you can extend this method to obtain different user-specified parameters from the web server. This <code class="literal">GET</code> implementation can be used in a large number of applications where Arduino requires repeated input from the user or other programs. But what if the web server requires input from the Arduino? In that case, we will have to use the <code class="literal">POST</code> request. Let's develop an Arduino program to accommodate the HTTP <code class="literal">POST</code> request.</p></div></div><div class="section" title="Working with the POST request from Arduino"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec109"/>Working with the POST request from Arduino</h2></div></div></div><p>Since we have now implemented the <code class="literal">GET</code> request, we can use a similar approach to exercise<a id="id813" class="indexterm"/> the <code class="literal">POST</code> request. Instead of asking the server to provide a response for a state request, we will send sensor data as payload from Arduino in the implementation of the <code class="literal">POST</code> request. Similarly, on the server side, we will utilize <code class="literal">web.py</code> to accept the <code class="literal">POST</code> request and display it through a web browser.</p><div class="section" title="The Arduino code to generate the POST request"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec83"/>The Arduino code to generate the POST request</h3></div></div></div><p>Open the Arduino sketch <code class="literal">ArduinoPOST.ino</code> from the <code class="literal">Arduino_POST_Webpy\ArduinoPOST</code> folder of the code repository. As in the previous exercise, you will first have to provide the IP address and <a id="id814" class="indexterm"/>the MAC address of your Arduino.</p><p>Once you have completed these basic changes, observe the following code snippet for the implementation of the <code class="literal">POST</code> request. You might notice that we are creating payload for the <code class="literal">POST</code> request as the variable data from the values obtained from analog pin 0:</p><div class="informalexample"><pre class="programlisting">  String data;
  data+="";
  data+="Humidity ";
  data+=analogRead(analogChannel);</pre></div><p>In the following Arduino code, we'll first create a <code class="literal">client</code> object using the Ethernet library. In the recurring <code class="literal">loop()</code> function, we'll use this <code class="literal">client</code> object to connect to the <code class="literal">web.py</code> server running on our computer. You will have to replace the IP address in the <code class="literal">connect()</code> method with the IP address of your <code class="literal">web.py</code> server. Once connected, we'll create a custom <code class="literal">POST</code> message with the payload data we calculated previously. The Arduino <code class="literal">loop()</code> function will periodically send the updated sensor value generated by this code sample to the <code class="literal">web.py</code> server:</p><div class="informalexample"><pre class="programlisting">  if (client.connect("10.0.0.20",8080)) {
    Serial.println("connected");
    client.println("POST /data HTTP/1.1");
    client.println("Host: 10.0.0.20");
    client.println("Content-Type: application/x-www-form-urlencoded");
    client.println("Connection: close");
    client.print("Content-Length: ");
    client.println(data.length());
    client.println();
    client.print(data);
    client.println();
    Serial.println("Data sent.");
  }</pre></div><p>Once you have performed the changes, compile and upload this sketch to the Arduino board. As<a id="id815" class="indexterm"/> the <code class="literal">web.py</code> server is yet not implemented, the <code class="literal">POST</code> request that originated from Arduino will not be able to reach its destination successfully, so let's create the <code class="literal">web.py</code> server to accept <code class="literal">POST</code> requests.</p></div><div class="section" title="The HTTP server using web.py to handle the POST request"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec84"/>The HTTP server using web.py to handle the POST request</h3></div></div></div><p>In this implementation of the <code class="literal">POST</code> method, we require two <code class="literal">web.py</code> classes, <code class="literal">index</code> and <code class="literal">data</code>, to individually <a id="id816" class="indexterm"/>serve requests from the web browser and Arduino respectively. As we are going to use two separate classes to update common sensor values (that is, <code class="literal">humidity</code> and <code class="literal">temperature</code>), we are going to declare them as global variables:</p><div class="informalexample"><pre class="programlisting">global temperature, humidity
temperature = 25</pre></div><p>As you may have noticed in the Arduino code (<code class="literal">client.println("POST /data HTTP/1.1")</code>), we were sending the <code class="literal">POST</code> request to the URL located at <code class="literal">/data</code>. Similarly, we will use the default root location, <code class="literal">'/'</code>, to land any request coming from the web browser. These requests for the root location will be handled by the <code class="literal">index</code> class, just as we covered in exercise 2:</p><div class="informalexample"><pre class="programlisting">urls = ( 
    '/', 'index',
    '/data','data',
)</pre></div><p>The <code class="literal">data</code> class takes care of any <code class="literal">POST</code> request originating from the <code class="literal">/data</code> location. In this case, these <code class="literal">POST</code> requests contain payload that has sensor information attached by the Arduino <code class="literal">POST</code> client. On receiving the message, the method splits the payload string into sensor-type and value, updating the global value of the <code class="literal">humidity</code> variable in this process:</p><div class="informalexample"><pre class="programlisting">class data:
    def POST(self):
        global humidity
        i = web.input()
        data = web.data()
        data = data.split()[1]
        humidity = relativeHumidity(data,temperature)
        return humidity</pre></div><p>Each <code class="literal">POST</code> request received from Arduino updates the raw humidity value, which is represented by the <code class="literal">data</code> variable. We are using the same code from exercise 2 to obtain <a id="id817" class="indexterm"/>manual temperature values from the user. The relative humidity value, <code class="literal">humidity</code>, is updated according to the temperature value you updated using the web browser and the raw humidity value is obtained from your Arduino.</p><div class="mediaobject"><img src="graphics/5938OS_08_18.jpg" alt="The HTTP server using web.py to handle the POST request"/></div><p>To check out the Python code, open the <code class="literal">WebPyEthernetPOST.py</code> file from the code repository. After making the appropriate changes, execute the code from the terminal. If you don't start getting any updates from the Arduino on the terminal, you should restart Arduino to reestablish the connection with the <code class="literal">web.py</code> server. Once you start seeing periodic updates from the Arduino <code class="literal">POST</code> requests at the terminal, open the location of the web application in your browser. You will be able to see something similar to the preceding screenshot. Here, you can submit the manual temperature value using the form, while the browser will reload with the updated relative humidity according to the temperature value entered.</p></div></div><div class="section" title="Exercise 3 – a RESTful Arduino web application"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec110"/>Exercise 3 – a RESTful Arduino web application</h2></div></div></div><p>The goal of this exercise is to simply combine the <code class="literal">GET</code> and <code class="literal">POST</code> methods you learned in the previous two sections in order to create a complete REST experience using Arduino and Python. The <a id="id818" class="indexterm"/>architecture for this exercise can be described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Arduino client periodically uses the <code class="literal">GET</code> request to obtain the sensor type from the server. It uses this sensor type to select a sensor for observation. In our case, it is either a humidity or motion sensor.</li><li class="listitem" style="list-style-type: disc">The web server responds to the <code class="literal">GET</code> request by returning the current sensor type of the sensor selected by the user. The user provides this selection through a web application.</li><li class="listitem" style="list-style-type: disc">After receiving the sensor type, the Arduino client utilizes <code class="literal">POST</code> to send sensor observation to the server.</li><li class="listitem" style="list-style-type: disc">The web <a id="id819" class="indexterm"/>server receives the <code class="literal">POST</code> data and updates the sensor observation for that particular sensor type.</li><li class="listitem" style="list-style-type: disc">On the user side, the web server obtains the current sensor type through the web browser.</li><li class="listitem" style="list-style-type: disc">When the <span class="strong"><strong>submit</strong></span> button in the browser is pressed, the server updates the sensor value in the browser with the latest value.</li></ul></div><div class="section" title="The Arduino sketch for the exercise"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec85"/>The Arduino sketch for the exercise</h3></div></div></div><p>Using the same Arduino hardware we built, open the Arduino sketch named <code class="literal">WebPyEthernetArduinoGETPOST.ino</code> from the <code class="literal">Exercise 3 - RESTful application Arduino and webpy</code> code folder. As we described in the exercise's architecture<a id="id820" class="indexterm"/> earlier, the Arduino client should periodically send <code class="literal">GET</code> requests to the server and get the corresponding value of the sensor type in the response. After comparing the sensor type, the Arduino client fetches the current sensor observation from the Arduino pins and sends that observation back to the server using <code class="literal">POST</code>:</p><div class="informalexample"><pre class="programlisting">if (client.connected()) {
      if (client.find("Humidity")){
           # Fetch humidity sensor value
           if (client.connect("10.0.0.20",8080)) {
           # Post humidity values
          }
      }
      else{
           # Fetch motion sensor value
           if (client.connect("10.0.0.20",8080)) {
           # Post motion values
          }
      }
     # Add delay
}</pre></div><p>After changing the appropriate server's IP address in the code, compile and upload it to the Arduino. Open the <span class="strong"><strong>Serial Monitor</strong></span> window, where you will find unsuccessful connection attempts, as your <code class="literal">web.py</code> server is not yet running. Close any other instance or program of the <code class="literal">web.py</code> server running on your computer.</p></div><div class="section" title="The web.py application to support REST requests"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec86"/>The web.py application to support REST requests</h3></div></div></div><p>Open the <code class="literal">WebPyEthernetGETPOST.py</code> file from the <code class="literal">Exercise 3 - RESTful application Arduino and webpy</code> code folder. As you can see, the <code class="literal">web.py</code> based web server implements two separate classes, <code class="literal">index</code> and <code class="literal">data</code>, to support the REST architecture <a id="id821" class="indexterm"/>for the web browser and the Arduino client, respectively. We are introducing a new concept for the <code class="literal">Form</code> element, called <code class="literal">Dropdown()</code>. Using this <code class="literal">Form</code> method, you can implement the drop-down selection menu and ask the user to select one option from the list of options:</p><div class="informalexample"><pre class="programlisting">form.Dropdown('dropdown',
           [('Humidity','Humidity'),('Motion','Motion')]),
form.Button('submit',
          type="submit", description='submit'))</pre></div><p>In the previous <code class="literal">web.py</code> program, we implemented the <code class="literal">GET</code> and <code class="literal">POST</code> methods for the <code class="literal">index</code> class and only the <code class="literal">POST</code> method for the <code class="literal">data</code> class. Moving forward in this exercise, we'll also add the <code class="literal">GET</code> method to the <code class="literal">data</code> class. This method returns the value of the <code class="literal">sensorType</code> variable when the <code class="literal">GET</code> request is made for the <code class="literal">/data</code> location. From the user side, the value of the <code class="literal">sensorType</code> variable is updated when the form gets submitted with an option. This action sends a selected value to the <code class="literal">POST</code> method of the <code class="literal">index</code> class, ultimately updating the <code class="literal">sensorType</code> value:</p><div class="informalexample"><pre class="programlisting">class data:
    def GET(self):
        return sensorType
    def POST(self):
        global humidity, motion
        i = web.input()
        data = web.data()
        data = data.split()[1]
        if sensorType == "Humidity":
            humidity = relativeHumidity(data,temperature)
            return humidity
        else:
            motion = data
            return motion</pre></div><p>Before you run this Python program, make sure you have checked every component of the code and updated the values where needed. Then execute the code from the terminal. Your web server will now run on your local computer on the port number <code class="literal">8080</code>. Power-cycle your Arduino device in case the connection attempt from Arduino fails. To test your system, open the web application from your web browser. You will see a web page open in your browser, as displayed in the following screenshot:</p><div class="mediaobject"><img src="graphics/5938OS_08_19.jpg" alt="The web.py application to support REST requests"/></div><p>You can choose<a id="id822" class="indexterm"/> the sensor type from the <span class="strong"><strong>dropdown</strong></span> menu ( <span class="strong"><strong>Humidity</strong></span> or <span class="strong"><strong>Motion</strong></span>) before pressing the <span class="strong"><strong>Submit</strong></span> button. On submission, you will be able to see the page updated with the appropriate sensor type and its current value.</p></div></div><div class="section" title="Why do we need a resource-constrained messaging protocol?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec111"/>Why do we need a resource-constrained messaging protocol?</h2></div></div></div><p>In the previous section, you learned how to use the HTTP <code class="literal">REST</code> architecture to send and receive <a id="id823" class="indexterm"/>data between your Arduino and the host server. The HTTP protocol was originally designed to serve textual data through web pages on the Internet. The data delivery mechanism used by HTTP requires a comparatively large amount of computation and network resources, which may be sufficient for a computer system but not for resource-constrained hardware platforms such as Arduino. As we discussed earlier, the client-server paradigm implemented by the HTTP REST architecture creates a tightly coupled system. In this paradigm, both sides (the client and the server) need to be constantly active, or live, to respond. Also, the REST architecture only allows unidirectional communication from client to server, where requests are always initialized by the client and the server responds to the client. This request-response-based architecture is not suitable for constrained hardware devices because of (but not limited to) the following reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">These devices should avoid active communication mode to save power</li><li class="listitem" style="list-style-type: disc">The communication should have less data overhaul to save network resources</li><li class="listitem" style="list-style-type: disc">They usually do not have enough computational resources to enable bidirectional REST communication, that is, implementing both client and server mechanisms on each side</li><li class="listitem" style="list-style-type: disc">The <a id="id824" class="indexterm"/>code should have a smaller footprint due to storage constraints<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>The REST-based architecture can still be useful when the application specifically requires a request-response architecture, but most sensor-based hardware applications are limited due to the preceding points.</p></div></div></li></ul></div><p>Among other data delivery paradigms that solve the preceding problems, the architecture based on <span class="strong"><strong>publisher/subscriber</strong></span> (<span class="strong"><strong>pub/sub</strong></span>) stands tall. The pub/sub architecture enables bidirectional communication capabilities between the node that generates the data (<span class="strong"><strong>Publisher</strong></span>) and the node that consumes the data (<span class="strong"><strong>Subscriber</strong></span>). We are going to use MQTT as the protocol that uses the pub/sub model of message transportation. Let's begin by covering the pub/sub architecture and MQTT in detail.</p></div></div>
<div class="section" title="MQTT &#x2013; A lightweight messaging protocol"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>MQTT – A lightweight messaging protocol</h1></div></div></div><p>Just like REST, pub/sub is one of the most popular messaging patterns, mostly deployed to transfer short messages between nodes. Instead of deploying client-server-based <a id="id825" class="indexterm"/>architecture, the pub/sub paradigm implements messaging middleware called a <span class="strong"><strong>broker</strong></span>
<a id="id826" class="indexterm"/> to receive, queue, and relay messages between the subscriber and publisher clients:</p><div class="mediaobject"><img src="graphics/5938OS_08_20.jpg" alt="MQTT – A lightweight messaging protocol"/></div><p>The pub/sub architecture utilizes a topic-based system to select and process messages, where each message is labeled with a specific topic name. Instead of sending a message directly to the subscriber, the publisher sends it first to the broker with a topic name. In a totally independent process, the subscriber registers its subscription for <a id="id827" class="indexterm"/>particular topics with the broker. In the event of receiving a message from the publisher, the broker performs topic-based filtering on that message before forwarding it to the subscribers registered for that topic. As publishers are loosely coupled to subscribers in this architecture, the publishers do not need to know the whereabouts of the subscribers and can work uninterrupted without worrying about their status.</p><p>While discussing the limitations of the REST architecture, we noticed that it requires the implementation of both the HTTP client and server on the Arduino end to enable bidirectional communication with Arduino. With the broker-based architecture demonstrated by pub/sub, you only need to implement lightweight code for the publisher or subscriber client on Arduino, while the broker can be implemented on a device with more computation resources. Henceforth, you will have bidirectional communication enabled on Arduino without using significant resources.</p><div class="section" title="Introduction to MQTT"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Introduction to MQTT</h2></div></div></div><p>
<span class="strong"><strong>Message Queue Telemetry Transport</strong></span> (<span class="strong"><strong>MQTT</strong></span>) is a very simple, easy, and open implementation of the pub/sub paradigm. IBM has been working on standardizing and supporting the MQTT protocol. The documentation for the latest specification of the MQTT protocol, v3.1, can be obtained from the official <a id="id828" class="indexterm"/>MQTT website at <a class="ulink" href="http://www.mqtt.org">http://www.mqtt.org</a>.</p><p>As a standard for machine messaging, MQTT is designed to be extremely lightweight and with a smaller footprint for code, while also using a lower network bandwidth for communication. MQTT is very specifically designed to work on embedded systems—like hardware platforms such as Arduino and other appliances—that carry limited processor and memory resources. While MQTT is a transport layer messaging protocol, it uses TCP/IP for network-level connectivity. As MQTT is designed to support the pub/sub messaging paradigm, the implementation of MQTT on your hardware application provides support for one-to-many distributed messaging, eliminating the limitation of unidirectional communication demonstrated by HTTP REST. As MQTT is agnostic of the content of the payload, there is no restriction on the type of message you can pass using this protocol.</p><p>Due to all the benefits associated with the pub/sub paradigm and its implementation in the MQTT protocol, we will be using the MQTT protocol for the rest of the exercises to have messages communicated between Arduino and its networked computer. To achieve this, we will be using the MQTT broker to provide the ground work for message communication and host topics, while deploying the MQTT publisher and subscriber clients at the Arduino and Python ends.</p></div><div class="section" title="Mosquitto – an open source MQTT broker"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec113"/>Mosquitto – an open source MQTT broker</h2></div></div></div><p>As we described, MQTT is just a protocol standard, and it still requires software tools so that it <a id="id829" class="indexterm"/>can be implemented in actual applications. <span class="strong"><strong>Mosquitto</strong></span> is an open source implementation of the message broker, which supports the latest version of the MQTT protocol <a id="id830" class="indexterm"/>standard. The Mosquitto broker enables the pub/sub paradigm implemented by the MQTT protocol, while providing a lightweight mechanism to enable messaging between machines. Development of Mosquitto is supported through community efforts. Mosquitto is one of the most popular MQTT implementations, freely available and widely supported on the Internet. You can obtain further <a id="id831" class="indexterm"/>information regarding the actual tool and community from its website, at <a class="ulink" href="http://www.mosquitto.org">http://www.mosquitto.org</a>.</p></div><div class="section" title="Setting up Mosquitto"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec114"/>Setting up Mosquitto</h2></div></div></div><p>The installation and configuration of Mosquitto are very straightforward processes. At the time of <a id="id832" class="indexterm"/>writing this book, the latest version of Mosquitto is 1.3.4. You can also obtain the latest updates and installation information regarding Mosquitto at <a class="ulink" href="http://www.mosquitto.org/download/">http://www.mosquitto.org/download/</a>.</p><p>On Windows, you can simply download the latest version of the installation files for Windows, which is made for Win32 or Win64 systems. Download and run the executable file to install the Mosquitto broker. To run Mosquitto from the command prompt, you will have to add the Mosquitto directory to the <code class="literal">PATH</code> variables in the environment variables of the system properties. In <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Python and Arduino">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Python and Arduino</em></span>, we comprehensively described the process of adding a <code class="literal">PATH</code> variable to install Python. Using the same method, add the path of the Mosquitto installation directory at the end of the <code class="literal">PATH</code> value. If you are using a 64-bit operating system, you should use <code class="literal">C:\Program Files (x86)\mosquitto</code>. For a 32-bit operating system, you should use <code class="literal">C:\Program Files\mosquitto</code> as the path. Once you are done with adding this value at the end of the <code class="literal">PATH</code> value, close any existing command prompt windows and open a new Command Prompt window. You can validate the installation by typing the following command in the newly opened window. If everything is installed and configured correctly, the following command should execute without any errors:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>C:\&gt; mosquitto</strong></span>
</pre></div><p>For Mac OS X, the best way to install Mosquitto is to use the Homebrew tool. We already went through the process of installing and configuring Homebrew in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Python and Arduino">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Python and Arduino</em></span>. Install the Mosquitto broker by simply executing the following script on the terminal. This script will install Mosquitto with the Mosquitto utilities and also configure them to run from the terminal as <a id="id833" class="indexterm"/>commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ brew install mosquitto</strong></span>
</pre></div><p>On Ubuntu, the default repository already has the installation package for Mosquitto. Depending on the version of Ubuntu you are using, this Mosquitto version could be older than the current version. In that case, you must add this repository first:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-add-repository ppa:mosquitto-dev/mosquitto-ppa</strong></span>
<span class="strong"><strong>$ sudo apt-get update</strong></span>
</pre></div><p>Now you can install the Mosquitto packages by simply running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install mosquitto mosquitto-clients</strong></span>
</pre></div></div><div class="section" title="Getting familiar with Mosquitto"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec115"/>Getting familiar with Mosquitto</h2></div></div></div><p>Due to the multiple installation methods involved for different operating systems, the initialization<a id="id834" class="indexterm"/> of Mosquitto may be different for your instance. In some cases, Mosquitto might already be running on your computer. For a Unix-based operating system, you can check whether Mosquitto is running or not with this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ps aux | grep mosquitto</strong></span>
</pre></div><p>Unless you find a running instance of the broker, you can start Mosquitto by executing the following command in the terminal. After executing it, you should be able to see the broker running while printing the initialization parameters and other requests coming to it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mosquitto</strong></span>
</pre></div><p>When you installed the Mosquitto broker, the installation process would also have installed a few Mosquitto utilities, which include the MQTT clients for the publisher and the subscriber. These client utilities can be used to communicate with any Mosquitto broker.</p><p>To use the subscriber client utility, <code class="literal">mosquitto_sub</code>, use the following command at the terminal with the IP address of the Mosquitto broker. As we are communicating to the Mosquitto broker running on the same computer, you can avoid the <code class="literal">–h &lt;Broker-IP&gt;</code> option. The subscriber utility uses the <code class="literal">–t</code> option to specify the name of the topic that you are planning to subscribe. As you can see, we are subscribing to the <code class="literal">test</code> topic:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mosquitto_sub -h &lt;Broker-IP&gt; -t test</strong></span>
</pre></div><p>Similar to the <a id="id835" class="indexterm"/>subscriber client, the publisher client (<code class="literal">mosquitto_pub</code>) can be used to publish a message to the broker for a specific topic. As described in the following command, you are required to use the <code class="literal">–m</code> option followed by a message to successfully publish it. In this command, we are publishing a <code class="literal">Hello</code> message for the <code class="literal">test</code> topic:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mosquitto_pub -h &lt;Broker-IP&gt; -t test -m Hello</strong></span>
</pre></div><p>Other important Mosquitto utilities include <code class="literal">mosquitto_password</code> and <code class="literal">mosquitto.conf</code>, which can be used to manage the Mosquitto password files and the setup broker configuration, respectively.</p></div></div>
<div class="section" title="Getting started with MQTT on Arduino and Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Getting started with MQTT on Arduino and Python</h1></div></div></div><p>Now that you have the Mosquitto broker installed on your computer, it means that you have a working broker that implements the MQTT protocol. Our next goal is to develop the MQTT clients in Arduino and also in Python so that they will work as publishers and subscribers. After implementing the MQTT clients, we will have a fully-functional MQTT system, where these clients communicate through the Mosquitto broker. Let's begin with deploying MQTT on the Arduino platform. </p><div class="section" title="MQTT on Arduino using the PubSubClient library"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec116"/>MQTT on Arduino using the PubSubClient library</h2></div></div></div><p>As MQTT is a <a id="id836" class="indexterm"/>network-based messaging protocol, you will always need an Ethernet Shield to communicate <a id="id837" class="indexterm"/>with your network. For the following exercise, we will continue using the same hardware that we have been using throughout this chapter.</p><div class="section" title="Installing the PubSubClient library"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec87"/>Installing the PubSubClient library</h3></div></div></div><p>To use Arduino for pub/sub and enable simple MQTT messaging, you need the Arduino client library for MQTT, also known as the <code class="literal">PubSubClient</code> library. The <code class="literal">PubSubClient</code> library helps you develop Arduino as an MQTT client, which can then communicate <a id="id838" class="indexterm"/>with the MQTT server (Mosquitto broker in our case) running on your computer. As the library provides methods to create only an MQTT client and not a broker, the <a id="id839" class="indexterm"/>footprint of the Arduino code is quite small compared to other messaging paradigms. The <code class="literal">PubSubClient</code> library extensively utilizes the default Arduino Ethernet library and implements the MQTT client as a subclass of the Ethernet client.</p><p>To get started with the <code class="literal">PubSubClient</code> library, you'll first need to import the library to your Arduino IDE. Download the latest version of the <code class="literal">PubSubClient</code> Arduino library from <a class="ulink" href="https://github.com/knolleary/pubsubclient/">https://github.com/knolleary/pubsubclient/</a>. Once you have the file <a id="id840" class="indexterm"/>downloaded, import it to your Arduino IDE.</p><p>We will be using one of the examples installed with the <code class="literal">PubSubClient</code> library to get started. The goal of the exercise is to utilize a basic example to create an Arduino MQTT client, while performing minor modifications to accommodate the local network parameters. We will then use the Mosquitto commands you learned in the previous section to test the Arduino MQTT client. Meanwhile, ensure that your Mosquitto broker is running in the background.</p></div><div class="section" title="Developing the Arduino MQTT client"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec88"/>Developing the Arduino MQTT client</h3></div></div></div><p>Let's start with <a id="id841" class="indexterm"/>opening the <code class="literal">mqtt_basic</code> example by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Examples</strong></span> | <span class="strong"><strong>PubSubClient</strong></span> in our Arduino IDE menu. In the opened program, change the MAC and IP address values for Arduino by updating the <code class="literal">mac[]</code> and <code class="literal">ip[]</code> variables, respectively. In the previous section, you successfully installed and tested the Mosquitto broker. Use the IP address of the computer running Mosquitto to update the <code class="literal">server[]</code> variable:</p><div class="informalexample"><pre class="programlisting">byte mac[]    = {  0x90, 0xA2, 0xDA, 0x0D, 0x3F, 0x62 };
byte server[] = { 10, 0, 0, 20 };
byte ip[]     = { 10, 0, 0, 75 };</pre></div><p>As you can see in the code, we are initializing the client using the IP address of the server, Mosquitto port number, and Ethernet client. Before using any other method for the <code class="literal">PubSubClient</code> library, you will always have to initialize the MQTT client using a similar method:</p><div class="informalexample"><pre class="programlisting">EthernetClient ethClient;
PubSubClient client(server, 1883, callback, ethClient);</pre></div><p>Further on in the code, we are using the <code class="literal">publish()</code> and <code class="literal">subscribe()</code> methods on the <code class="literal">client</code> class to publish a message for the <code class="literal">outTopic</code> topic and subscribe to the <code class="literal">inTopic</code> topic. You can specify the name of the client using the <code class="literal">client.connect()</code> method. As you can see in the following code snippet, we are declaring <code class="literal">arduinoClient</code> as the name for this client:</p><div class="informalexample"><pre class="programlisting">  Ethernet.begin(mac, ip);
  if (client.connect("arduinoClient")) {
    client.publish("outTopic","hello world");
    client.subscribe("inTopic");
  }</pre></div><p>As we are <a id="id842" class="indexterm"/>using this code in the <code class="literal">setup()</code> function, the client will only publish the <code class="literal">hello world</code> message once—during the initialization of the code—while the <code class="literal">subscribe</code> method will keep looking for new messages for <code class="literal">inTopic</code> due to the use of the <code class="literal">client.loop()</code> method in the Arduino <code class="literal">loop()</code> function:</p><div class="informalexample"><pre class="programlisting">  client.loop();</pre></div><p>Now, while running Mosquitto in the background, open another terminal window. In this terminal window, run the following command. This command will use a computer-based Mosquitto client to subscribe to the <code class="literal">outTopic</code> topic:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mosquitto_sub -t "outTopic"</strong></span>
</pre></div><p>Compile your Arduino sketch and upload it. As soon as the upload process is complete, you will be able to see the <code class="literal">hello world</code> string printed. Basically, as soon as the Arduino code starts running, the Arduino MQTT client will publish the <code class="literal">hello world</code> string to the Mosquitto broker for the <code class="literal">outTopic</code> topic. On the other side, that is, on the side of the Mosquitto client, you've started using the <code class="literal">mosquitto_sub</code> utility and will receive this message, as it is subscribed to <code class="literal">outTopic</code>.</p><p>Although you ran the modified Arduino example, <code class="literal">mqtt_basic</code>, you can also find the code for this exercise from this chapter's code folder. In this exercise, the Arduino client is also subscribed to <code class="literal">inTopic</code> to receive any message that originates for this topic. Unfortunately, the program doesn't display or deal with messages it obtains as a subscriber. To test the subscriber functionalities of the Arduino MQTT client, let's open the <code class="literal">mqtt_advance</code> Arduino sketch from this chapter's code folder.</p><p>As you can see in the following code snippet, we have added code to display the received message in the <code class="literal">callback()</code> method. The <code class="literal">callback()</code> method will be called when the client receives any message from the subscribed topics. Therefore, you can implement all types of functionality on the received message from the <code class="literal">callback()</code> method:</p><div class="informalexample"><pre class="programlisting">void callback(char* topic, byte* payload, unsigned int length) {
  // handle message arrived
  Serial.print(topic);
  Serial.print(':');
  Serial.write(payload,length);
  Serial.println();
}</pre></div><p>In this <code class="literal">mqtt_advance</code> Arduino sketch, we have also moved the publishing statement of <code class="literal">outTopic</code> from <code class="literal">setup()</code> to the <code class="literal">loop()</code> function. This action will help us to periodically publish the value for <code class="literal">outTopic</code>. In future, we will expand this method to use sensor information as messages so that the other devices can obtain those sensor values by<a id="id843" class="indexterm"/> subscribing to these sensor topics:</p><div class="informalexample"><pre class="programlisting">void loop()
{
  client.publish("outTopic","From Arduino");
  delay(1000);
  client.loop();
}</pre></div><p>After updating the <code class="literal">mqtt_advance</code> sketch with the appropriate network addresses, compile and upload the sketch to your Arduino hardware. To test the Arduino client, use the same <code class="literal">mosquitto_sub</code> command to subscribe to <code class="literal">outTopic</code>. This time, you will periodically get updates for <code class="literal">outTopic</code> on the terminal. To check out the subscriber functionality of your Arduino client, open your <span class="strong"><strong>Serial Monitor</strong></span> window in your Arduino IDE. Once the <span class="strong"><strong>Serial Monitor</strong></span> window begins running, execute the following command in the terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mosquitto_pub – t "inTopic" –m "Test"</strong></span>
</pre></div><p>You can see in the <span class="strong"><strong>Serial Monitor</strong></span> window that the <code class="literal">Test</code> text is printed with the topic name as <code class="literal">inTopic</code>. Henceforth, your Arduino will serve as both an MQTT publisher and an MQTT subscriber. Now let's develop a Python program to implement the MQTT clients.</p></div></div><div class="section" title="MQTT on Python using paho-mqtt"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec117"/>MQTT on Python using paho-mqtt</h2></div></div></div><p>In the previous exercise, we tested the Arduino MQTT client using command-line utilities. Unless the published and subscribed messages are captured in Python, we cannot<a id="id844" class="indexterm"/> utilize them to develop all the other applications we've built so far. To transfer messages <a id="id845" class="indexterm"/>between the Mosquitto broker and the Python interpreter, we use a Python library called <code class="literal">paho-mqtt</code>. This library used to be called <code class="literal">mosquitto-python</code> before it was donated to the Paho project. Identical to the Arduino MQTT client library, the <code class="literal">paho-mqtt</code> library provides similar methods to develop the MQTT pub/sub client using Python.</p><div class="section" title="Installing paho-mqtt"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec89"/>Installing paho-mqtt</h3></div></div></div><p>Like all other Python libraries we used, <code class="literal">paho-mqtt</code> can also be installed using Setuptools. To<a id="id846" class="indexterm"/> install the <a id="id847" class="indexterm"/>library, run this command in the terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo pip install paho-mqtt</strong></span>
</pre></div><p>For the Windows operating system, use <code class="literal">easy_install.exe</code> to install the library. Once it is installed, you can check the successful installation of the library using the following command in the Python interactive terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import paho.mqtt.client</strong></span>
</pre></div></div><div class="section" title="Using the paho-mqtt Python library"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec90"/>Using the paho-mqtt Python library</h3></div></div></div><p>The <code class="literal">paho-mqtt</code> Python library provides very simple methods to connect to your Mosquitto broker. Let's open the <code class="literal">mqttPython.py</code> file from this chapter's code folder. As you can <a id="id848" class="indexterm"/>see, we have <a id="id849" class="indexterm"/>initialized the code by importing the <code class="literal">paho.mqtt.client</code> library method:</p><div class="informalexample"><pre class="programlisting">import paho.mqtt.client as mq</pre></div><p>Just like the Arduino MQTT library, the <code class="literal">paho-mqtt</code> library also provides methods to connect to the Mosquitto broker. As you can see, we have named our client <code class="literal">mosquittoPython</code> by simply using the <code class="literal">Client()</code> method. The library also provides methods for activities, for example, when the client receives a message, <code class="literal">on_message</code>, and publishes a message, <code class="literal">on_publish</code>. Once you have initialized these methods, you can connect your client to the Mosquitto server by specifying the server IP address and the port number.</p><p>To subscribe to or publish for a topic, you simply need to implement the <code class="literal">subscribe()</code> and <code class="literal">publish()</code> methods on the client, respectively, as displayed in the following code snippet. In this exercise, we are using the <code class="literal">loop_forever()</code> method for the client to periodically check the broker for any new messages. As you can see in the code, we are executing the <code class="literal">publishTest()</code> function before the control enters the loop:</p><div class="informalexample"><pre class="programlisting">cli = mq.Client('mosquittoPython')
cli.on_message = onMessage
cli.on_publish = onPublish
cli.connect("10.0.0.20", 1883, 15)
cli.subscribe("outTopic", 0)
publishTest()
cli.loop_forever()</pre></div><p>It is very important to run all the required functions or pieces of code before you enter the loop, as the program will enter the loop with the Mosquitto server once <code class="literal">loop_forever()</code> is executed. During this period, the client will only execute the <code class="literal">on_publish</code> and <code class="literal">on_message</code> methods for any update on the subscribed or published topics.</p><p>To overcome this <a id="id850" class="indexterm"/>situation, we are implementing the multithreading paradigm of the Python programming language. Although we are not going to dive deep into multithreading, the following <a id="id851" class="indexterm"/>example will teach you enough to implement basic programming logic. To understand more <a id="id852" class="indexterm"/>about the Python threading library and supported methods, visit <a class="ulink" href="https://docs.python.org/2/library/threading.html">https://docs.python.org/2/library/threading.html</a>.</p><p>To better understand our implementation of the threading method, check out the following code snippet. As you can see in the code, we are implementing recursion for the <code class="literal">publishTest()</code> function every 5 seconds, using the <code class="literal">Timer()</code> threading method. Using this method, the program will start a new thread that is separate from the main program thread that contains the loop for Mosquitto. Every 5 seconds, the <code class="literal">publishTest()</code> function will be executed, recursively running the <code class="literal">publish()</code> method, and ultimately publishing a message for <code class="literal">inTopic</code>:</p><div class="informalexample"><pre class="programlisting">import threading
def publishTest():
    cli.publish("inTopic","From Python")
    threading.Timer(5, publishTest).start()</pre></div><p>Now, in the main thread, when the client gets a new message from the subscribed topics, the thread invokes the <code class="literal">onMessage()</code> function. In the current implementation of this function, we are just printing the topic and message for demonstration purposes. In real applications, this function can be used to implement any kind of operation on the received message, for example, writing a message to a database, running an Arduino command, selecting an input, calling other functions, and so on. In short, this function is the entry point of any input you receive through the Mosquitto broker from your subscribed topics:</p><div class="informalexample"><pre class="programlisting">def onMessage(mosq, obj, msg):
    print msg.topic+":"+msg.payload</pre></div><p>Similarly, every time you publish a message from the second thread, the <code class="literal">onPublish()</code> function is executed by the program. Just like the previous function, you can implement various operations within this function, while the function behaves as the exit point of any message published using this Python MQTT client. In the current implementation of <code class="literal">onPublish()</code>, we are not performing any operations:</p><div class="informalexample"><pre class="programlisting">def onPublish(mosq, obj, mid):
    pass</pre></div><p>In the opened Python file, <code class="literal">mqttPython.py</code>, you will only need to change the IP address of the server running the Mosquitto broker. If you are running the Mosquitto broker on the same computer, you can use <code class="literal">127.0.0.1</code> as the IP address of the localhost. Before you execute this Python file, ensure that your Arduino is running with the MQTT client we created in the previous exercise. Once you run this code, you can start <a id="id853" class="indexterm"/>seeing the messages being sent from your Arduino in the Python terminal, as displayed in the following screenshot. Whenever a new message is received, the Python <a id="id854" class="indexterm"/>program prints the <span class="strong"><strong>outTopic</strong></span> topic name followed by the <span class="strong"><strong>From Arduino</strong></span> message. This confirms that the Python client is receiving messages for <code class="literal">outTopic</code>, to which it is subscribed. If you look back at the Arduino code, you will notice that it is the same message that we were publishing from the Arduino client.</p><div class="mediaobject"><img src="graphics/5938OS_08_21.jpg" alt="Using the paho-mqtt Python library"/></div><p>Now, to confirm the publishing operation of the Python MQTT client, let's open the <span class="strong"><strong>Serial Monitor</strong></span> window from your Arduino IDE. As you can see in the <span class="strong"><strong>Serial Monitor</strong></span> window, text that contains the <span class="strong"><strong>inTopic</strong></span> topic name and the <span class="strong"><strong>From Python</strong></span> message is being printed every 5 seconds. This validates the Python publisher, as we are publishing the same message for the same topic every 5 seconds through the <code class="literal">publishTest()</code> function.</p><div class="mediaobject"><img src="graphics/5938OS_08_22.jpg" alt="Using the paho-mqtt Python library"/></div></div></div><div class="section" title="Exercise 4 – MQTT Gateway for Arduino"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec118"/>Exercise 4 – MQTT Gateway for Arduino</h2></div></div></div><p>In exercise 3, we used the REST architecture to transfer motion and humidity sensor data between our <a id="id855" class="indexterm"/>Arduino and the web browser. In this exercise, we will develop an MQTT Gateway using the Mosquitto broker and the MQTT clients to transfer sensor information from our Arduino to the web browser. The goal of the exercise is to replicate the same components that we implemented in the REST exercise, but with the MQTT protocol.</p><p>As you can see in the architectural sketch of the system, we have Arduino with the Ethernet Shield connected to our home network, while the computer is running the Mosquitto broker and the Python applications on the same network. We are using the same sensors (that is, a motion sensor and a humidity sensor) and the same hardware design that we used in the previous exercises in this chapter.</p><div class="mediaobject"><img src="graphics/5938OS_08_23.jpg" alt="Exercise 4 – MQTT Gateway for Arduino"/></div><p>In the software architecture, we have the Arduino code that interfaces with the humidity and motion sensors using analog pin 0 and digital pin 3, respectively. Using the <code class="literal">PubSubClient</code> library, the Arduino publishes sensor information to the Mosquitto broker. On the MQTT Gateway, we have two different Python programs running on the computer. The first program uses the <code class="literal">paho-mqtt</code> library to subscribe and retrieve sensor information from the Mosquitto broker and then <code class="literal">post</code> it to the web application. The second Python program, which is based on <code class="literal">web.py</code>, implements the web applications while obtaining sensor values from the first Python program. This program provides a user interface front for the MQTT Gateway.</p><p>Although both of the preceding Python programs can be part of a single application, we are delegating the tasks of communicating with Mosquitto and serving information using the web <a id="id856" class="indexterm"/>application to separate applications for the following reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We want to demonstrate the functions of both libraries, <code class="literal">paho-mqtt</code> and <code class="literal">web.py</code>, in separate applications</li><li class="listitem" style="list-style-type: disc">If you want to run routines based on <code class="literal">paho-mqtt</code> and <code class="literal">web.py</code> in the same application, you will have to implement multithreading, as both of these routines need to be run independently</li><li class="listitem" style="list-style-type: disc">We also want to demonstrate the transfer of information between the two Python programs using Python-based REST methods with the help of the <code class="literal">httplib</code> library<div class="mediaobject"><img src="graphics/5938OS_08_24.jpg" alt="Exercise 4 – MQTT Gateway for Arduino"/></div></li></ul></div><p>In this exercise, we are labeling humidity and motion sensor information with the topic labels <code class="literal">Arduino/humidity</code> and <code class="literal">Arduino/motion</code>, respectively. The Arduino-based MQTT publisher and the Python-based MQTT subscriber will be utilizing these topic names if they want to transfer information through the Mosquitto broker. Before we begin with implementing the MQTT client on our Arduino, let's start the Mosquitto broker on our computer.</p><div class="section" title="Developing Arduino as the MQTT client"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec91"/>Developing Arduino as the MQTT client</h3></div></div></div><p>The goal of the Arduino MQTT client is to periodically publish the humidity and motion data to <a id="id857" class="indexterm"/>the Mosquitto broker running on your computer. Open the <code class="literal">Step1_Arduino.ino</code> sketch from the <code class="literal">Exercise 4 - MQTT gateway</code> folder in your code repository. Like all the other exercises, you first need to change the MAC address and the server address value, and assign an IP address for your Arduino client. Once you are done with these modifications, you can see the <code class="literal">setup()</code> function that we are publishing as a one-time connection message to the Mosquitto broker to check the connection. You can implement a similar function on a periodic basis if you have a problem with keeping your Mosquitto connection alive:</p><div class="informalexample"><pre class="programlisting">if (client.connect("Arduino")) {
    client.publish("Arduino/connection","Connected.");
  }</pre></div><p>In the <code class="literal">loop()</code> method, we are executing the <code class="literal">publishData()</code> function every 5 seconds. It contains the code to publish sensor information. The <code class="literal">client.loop()</code> method also helps <a id="id858" class="indexterm"/>us keep the Mosquitto connection alive and avoids the connection timeout from the Mosquitto broker.</p><div class="informalexample"><pre class="programlisting">void loop()
{
  publishData();
  delay(5000);
  client.loop();
}</pre></div><p>As you can see in the following code snippet, the <code class="literal">publishData()</code> function obtains the sensor values and publishes them using the appropriate topic labels. You might have noticed that we are using the <code class="literal">dtostrf()</code> function in this function to change the data format before publishing. The <code class="literal">dtostrf()</code> function is a function provided by the default Arduino library that converts a double value into an ASCII string representation. We are also adding a delay of another 5 seconds between the successive publishing of sensor data to avoid any data buffering issues:</p><div class="informalexample"><pre class="programlisting">void publishData()
{
  float humidity = getHumidity(22.0);
  humidityC = dtostrf(humidity, 5, 2, message_buff2);
  client.publish("Arduino/humidity", humidityC);
  delay(5000);
  int motion = digitalRead(MotionPin);
  motionC = dtostrf(motion, 5, 2, message_buff2);
  client.publish("Arduino/motion", motionC);
}</pre></div><p>Complete any other modification you want to implement, and then compile your code. If your code is compiled successfully, you can upload it to your Arduino board. If your Mosquitto is running, you will be able see that a new client is connected as Arduino, which is the client name you specified in the preceding Arduino code.</p></div><div class="section" title="Developing the MQTT Gateway using Mosquitto"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec92"/>Developing the MQTT Gateway using Mosquitto</h3></div></div></div><p>You can have the Mosquitto broker running on the same computer as the Mosquitto Gateway, or on any other node in your local network. For this exercise, let's run it on the same<a id="id859" class="indexterm"/> computer. Open the program file named <code class="literal">mosquittoGateway.py</code> for this stage from the <code class="literal">Step2_Gateway_mosquitto</code> folder, which is inside the <code class="literal">Exercise 4 - MQTT gateway</code> folder. The first stage of the Gateway application includes the <code class="literal">paho-mqtt</code> based Python program, which subscribes to the Mosquitto broker for the <code class="literal">Arduino/humidity</code> and <code class="literal">Arduino/motion</code> topics:</p><div class="informalexample"><pre class="programlisting">cli.subscribe("Arduino/humidity", 0)
cli.subscribe("Arduino/motion", 0)</pre></div><p>When this MQTT subscriber program receives a message from the broker, it calls the <code class="literal">onMessage()</code> function, as we've already described in the previous coding exercise. This method then identifies the appropriate sensor type and sends the data to the <code class="literal">web.py</code> program using the <code class="literal">POST</code> method. We are using the default Python library, <code class="literal">httplib</code>, to implement the <code class="literal">POST</code> method in this program. While using the <code class="literal">httplib</code> library, you have to use the <code class="literal">HTTPConnection()</code> method to connect to the web application running on port number <code class="literal">8080</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>Although this program requires that your web application (second stage) must run in parallel, we are going to implement this web application in the upcoming section. Make sure that you first run the web application from the next section before executing this program; otherwise you will end up with errors.</p></div></div><p>The implementation of this library requires that you first import the library into your program. Being a built-in library, <code class="literal">httplib</code> does not require an additional setup process:</p><div class="informalexample"><pre class="programlisting">import httplib</pre></div><p>Once the connection is established with the web application, you have to prepare the data that needs to be sent in the <code class="literal">POST</code> method. The <code class="literal">httplib</code> method uses the <code class="literal">request()</code> method on the opened connection to post the data. You can also use the same method in other applications to implement the <code class="literal">GET</code> function. Once you are done with sending the data, you can close the connection using the <code class="literal">close()</code> method. In the current implementation of the <code class="literal">httplib</code> library, we are creating and closing the connection on each message. You can also declare the connection outside the <code class="literal">onMessage()</code> function and close it when you terminate the program:</p><div class="informalexample"><pre class="programlisting">def onMessage(mosq, obj, msg):
    print msg.topic
    connection = httplib.HTTPConnection('10.0.0.20:8080')
    if msg.topic == "Arduino/motion":
        data = "motion:" + msg.payload
        connection.request('POST', '/data', data)
        postResult = connection.getresponse()
        print postResult
    elif msg.topic == "Arduino/humidity":
        data = "humidity:" + msg.payload
        connection.request('POST', '/data', data)
        postResult = connection.getresponse()
        print postResult
    else:
        pass
    connection.close()</pre></div><p>Once you have <a id="id860" class="indexterm"/>performed the appropriate modifications, such as changing the IP address of the Mosquitto broker and the <code class="literal">web.py</code> application, go to the next exercise before running the code.</p></div><div class="section" title="Extending the MQTT Gateway using web.py"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec93"/>Extending the MQTT Gateway using web.py</h3></div></div></div><p>The MQTT Gateway <a id="id861" class="indexterm"/>code provides the user interface with the sensor information using the <code class="literal">web.py</code> based web application. The code is quite similar to what you implemented in exercise 3. The program file is named <code class="literal">GatewayWebApplication.py</code> and located in your <code class="literal">Exercise 4 - MQTT gateway</code> code folder. In this application, we have removed the sensor selection process by simply implementing a button, displayed as <span class="strong"><strong>Refresh</strong></span>. This application waits for the <code class="literal">POST</code> message from the previous program, which will be received on the <code class="literal">http://&lt;ip-address&gt;:8080/data</code> URL, ultimately triggering the <code class="literal">data</code> class. The <code class="literal">POST</code> method in this class will split the received string to identify and update the value of the <code class="literal">humidity</code> and <code class="literal">motion</code> global sensor variables:</p><div class="informalexample"><pre class="programlisting">class data:
    def POST(self):
        global motion, humidity
        i = web.input()
        data = web.data()
        data = data.split(":")
        if data[0] == "humidity":
            humidity = data[1]
        elif data[0] == "motion":
            motion = data[1]
        else:
            pass
        return "Ok" </pre></div><p>The default URL, <code class="literal">http://&lt;ip-address&gt;:8080/</code>, displays the <code class="literal">base</code> template with the <span class="strong"><strong>Refresh</strong></span> button, populated using the <code class="literal">Form()</code> method. As displayed in the following code snippet, the <a id="id862" class="indexterm"/>default <code class="literal">index</code> class renders the template with the updated (current) <code class="literal">humidity</code> and <code class="literal">motion</code> values when it receives the <code class="literal">GET</code> or <code class="literal">POST</code> request:</p><div class="informalexample"><pre class="programlisting">class index:
    submit_form = form.Form(
        form.Button('Refresh',
                    type="submit",
                    description='refresh')
    )
    # GET function
    def GET(self):
        f = self.submit_form()
        return render.base(f, humidity, motion)

    # POST function
    def POST(self):
        f = self.submit_form()
        return render.base(f, humidity, motion)</pre></div><p>Run the program from the command line. Make sure that you are running both programs from separate terminal windows.</p></div><div class="section" title="Testing your Mosquitto Gateway"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec94"/>Testing your Mosquitto Gateway</h3></div></div></div><p>You have to follow these steps in the specified order to successfully execute and test all the components<a id="id863" class="indexterm"/> of this exercise:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the Mosquitto broker.</li><li class="listitem">Run the Arduino client. If it is running already, restart the program by powering off the Arduino client and powering it on again.</li><li class="listitem">Execute the web application in your terminal or from the Command Prompt.</li><li class="listitem">Run the <code class="literal">paho-mqtt</code> Gateway program.</li></ol></div><p>If you follow this sequence, all of your programs will start without any errors. If you get any errors while executing, make sure that you follow all the instructions correctly, while also confirming the IP addresses in your programs. To check out your Arduino MQTT client, open the <span class="strong"><strong>Serial Monitor</strong></span> window in your Arduino IDE. You will be able to see the periodic publication of the sensor information, as displayed in this screenshot:</p><div class="mediaobject"><img src="graphics/5938OS_08_25.jpg" alt="Testing your Mosquitto Gateway"/></div><p>Now open a <a id="id864" class="indexterm"/>web browser on your computer and go to the URL of your web application. You should be able to see a window that looks like what is shown in the following screenshot. You can click on the <span class="strong"><strong>Refresh</strong></span> button to check out the updated sensor values.</p><div class="mediaobject"><img src="graphics/5938OS_08_26.jpg" alt="Testing your Mosquitto Gateway"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>We have set a delay of 5 seconds between successive sensor updates. Henceforth, you won't be able to see the updated values if you rapidly press the <span class="strong"><strong>Refresh</strong></span> button.</p></div></div><p>On the Gateway program terminal, you will be able to see the label of the topic every time the program receives a new message from Mosquitto. If the delay between successive sensor updates is not sufficient and <code class="literal">httplib</code> doesn't have enough time to get the response back from the <code class="literal">web.py</code> application, the program will generate an error message with the <code class="literal">httplib</code> function. Although we require an additional delay for <code class="literal">httplib</code> to successively send the data and receive the response, we will be able to avoid this delay when we implement the core Python code with threading, avoiding the entire notion of <code class="literal">POST</code> in between the programs:</p><div class="mediaobject"><img src="graphics/5938OS_08_27.jpg" alt="Testing your Mosquitto Gateway"/></div><p>With this exercise, you <a id="id865" class="indexterm"/>have implemented two different types of messaging architecture to transfer data between your Arduino and your computer or web applications using your home network. Although we recommend the use of hardware-centric and lightweight MQTT messaging paradigms over REST architecture, you can use either of these communication methods according to the application's requirements.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Summary</h1></div></div></div><p>Connectivity to computer networks can really open up limitless possibilities for future application development using Arduino. We started the chapter by explaining important computer network fundamentals, while also covering hardware extensions that enable computer networking for Arduino. Regarding the various methods of enabling networking, we began the chapter by establishing a web server for Arduino. We concluded that the web server on Arduino is not the best way for network communication due to the limited number of connections offered by the web server. Then we demonstrated the use of Arduino as a web client to enable HTTP-based <code class="literal">GET</code> and <code class="literal">POST</code> requests. Although this method is useful for request-based communication and requires fewer resources compared to a web server, it is still not the best way for sensor communication due to the additional data overhead. In the later part of the chapter, we described a lightweight messaging protocol, MQTT, designed specifically for sensor communication. We demonstrated its superiority to HTTP-based protocols using a few exercises.</p><p>With the help of each method of Arduino Ethernet communication, you learned about compatible Python libraries used to support these communication methods. We used the <code class="literal">web.py</code> library to develop a web server using Python, and demonstrated the use of the library with multiple examples. To support the MQTT protocol, we explored an MQTT broker, Mosquitto, and employed the Python library, <code class="literal">paho_mqtt</code>, to serve the MQTT requests.</p><p>Overall, we covered every major aspect of Arduino and Python communication methods throughout this chapter, and demonstrated them with simple exercises. In the upcoming chapters, we will build upon the basics you learned in this chapter, in order to develop advanced Arduino-Python projects that will enable remote access to our Arduino hardware through the Internet.</p></div></body></html>