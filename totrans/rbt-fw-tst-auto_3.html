<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Further Test Customization</h1></div></div></div><p>This chapter covers syntax and styles necessary to create reusable test components for automated tests. Apart from the Robot Framework centric tests, it also covers an introduction to behavior-driven development and covers the following major topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Need for test re-use</li><li class="listitem" style="list-style-type: disc">Internal and external re-use</li><li class="listitem" style="list-style-type: disc">Feeding data into test scripts</li><li class="listitem" style="list-style-type: disc">Higher order test re-use</li><li class="listitem" style="list-style-type: disc">Different styles of writing tests</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Automation and agile</h1></div></div></div><p>The agile manifesto places tremendous importance on usable code over conventional documents. It encourages practices such as extreme programming, which is a type of agile software development practice that improves software quality and makes the software development more responsive to the ever changing customer requirements. Amongst other important tenets of this practice is the automated acceptance testing. An acceptance test is simply some code that can be run and captures at its heart some aspect of the functionality of the system. The idea is that both the developer and the stakeholder collaborate on writing this test together, to capture the requirements in the code, which when passed, forms some kind of seal of approval. These are distinct from unit and integration tests as they are largely written by the developer, and for the developer. They help them emerge, validate design, and protect against errors. Acceptance tests are written by the stakeholder and the developer, for the stakeholder and the developer. Agile methodology places importance over tests as tests themselves become specifications rather than business reports or documentation.</p><p>A commonly used expression is that the difference between unit tests and acceptance tests is that unit tests helps you build the thing right, whereas acceptance tests helps you build the right thing.</p><p>As mentioned before, the Robot Framework as an automated acceptance test-driven development tool provides various capabilities out of the box and allows the user with enough flexibility to go about with automation to ensure that the software in question can always have its basic functionality in place.</p><p>Before proceeding with writing down the tests, it is necessary to know how to implement a design that will help scale and maintain the tests for future requirements. Similar to the creation of any other software, the tests written in modular fashion enable re-use through selection of different test modules as required. This can better be explained by the following diagram:</p><div><img src="img/3033OS_03_01.jpg" alt="Automation and agile"/></div><p>Here, it is evident that separation of test <strong>1</strong> into a unique module has enabled us to use the same set of tests in part of three other tests, thereby reducing the amount of repetition involved in writing if the tests were to be created manually.</p><p>However, generally, during acceptance tests, there are some portions that are unique to the situation under which the test is executing. Consider the following example that needs to perform acceptance testing for a large website consisting of hundreds of pages.</p><p>Test website module functionality:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <a id="id80" class="indexterm"/>browser.</li><li class="listitem">Go to the specific page URL.</li><li class="listitem">Ensure that it is not an empty page/invalid URL.</li><li class="listitem">Check whether the site headers and footers exist and are displayed properly.</li><li class="listitem">Ascertain if the actual page content (excluding the header and footer) is not empty.</li><li class="listitem">Search and verify whether a specific element exists in the page.</li><li class="listitem">Close the browser.</li></ol></div><p>Even in this brief test, there are innumerable possibilities and a single test cannot address all of them. For this reason, testers make copies of tests such as this and after making changes, put them elsewhere to meet another requirement. However, copying leads to presence of duplicate tests that are hard to change as change in the environment requires changes across the different tests. On the other hand, if there is test re-use, then changes in the re-used test at one place can reflect across different tests. To address the concern of uniqueness in different scenarios, one can parameterize the same test. In the preceding example, a possible parameterization can be as follows.</p><p>Test website module functionality(browser, URL, and content):</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <strong>browser</strong> (select the specified browser).</li><li class="listitem">Go to the specific page <strong>URL</strong> (as specified in the parameters).</li><li class="listitem">Ensure that it is not an empty page/invalid <strong>URL</strong>.</li><li class="listitem">Check whether the site headers and footers exist and are displayed properly.</li><li class="listitem">Ascertain if the actual page <strong>content</strong> (excluding the header and footer as specified in the parameter) is not empty.</li><li class="listitem">Search and verify whether the parameterized <strong>content</strong> exists in the page.</li><li class="listitem">Close the browser.</li></ol></div><p>Now the same test can be used in a wide variety of scenarios (read pages) and different portions of the entire website can be tested for page contents using the same test.</p><p>As mentioned here, the same parameterized approach to create reusable tests can be applied to the Robot Framework through the use of variables. The variables can be used as an input mechanism from a given source of information which is not related with the test and the execution of tests occurs depending upon the obtained data. As repetition of test actions forms the cornerstone of test re-use, there is a possibility to repeat test actions even within the tests. While doing so, a single test or use case can repeat the same instructions again internally, often with some variable data that is unique to a specific repetition. These are detailed in the following sections.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Internal re-use</h1></div></div></div><p>As mentioned earlier, repetition within the single test constitutes test re-use internally. Note that the data, if any,<a id="id81" class="indexterm"/> involved in different instances of the iterations might come from outside, but the repetition only occurs within the test action.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Loops and flow control</h2></div></div></div><p>Having gained a good background of the syntax of writing a test, it is time to move on to the most common and convenient way of iteration, that is, a loop. Robot Framework solves this problem<a id="id82" class="indexterm"/> through the use of Python styled <code class="literal">for</code> loops, but that's easily understandable for the uninitiated as well.</p><p>It follows a<a id="id83" class="indexterm"/> straightforward syntax, the loop is started with <code class="literal">FOR</code> which is a special keyword. This is followed with a variable that is present within the loop. This variable is followed by a mandatory <code class="literal">IN</code> statement. This is followed by the variable or a collection over which the <code class="literal">for</code> loop is to run. Like Python loops, the subsequent statements are indented by a single space. As soon as the indentation stops, it is assumed that the body of the loop is finished.</p><p>All this seems like an iterative construct of any programming language, but in the Robot Framework there are a couple of exceptions, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">for</code> loop can iterate with multiple variables</li><li class="listitem" style="list-style-type: disc">The loop cannot have directly nested loops within itself, but can make use of custom keywords within the loops that can contain loops within themselves</li><li class="listitem" style="list-style-type: disc">The <strong>scalar variable</strong> collection<a id="id84" class="indexterm"/> over which the loop iterates can be specified as different arguments</li></ul></div><p>Note that the <code class="literal">for</code> loop requires explicit whitespace definition to clearly demarcate different columns as a simple text file with space/tab delimiters wouldn't do. If tried to run, it will print out the error message "FOR loop contains no keywords". This is because the body of the loop requires (an extra) indentation, which is not possible in simple whitespace as two or more than two spaces are only constructed as a single separation.</p><p>The <code class="literal">for</code> loop has a variant that allows for iteration over a range of values. This is idiomatic Python, but is quite convenient at times. Its syntax is: <code class="literal">FOR</code> keyword followed by a single variable. Next comes the <code class="literal">In Range</code> keyword that provides various range limits through arguments. This can be demonstrated as follows:</p><div><pre class="programlisting"># This code block runs 5 times for values of x between 0 and 4
|  | :FOR | ${x} | IN RANGE | 5
# This code block runs 5 times for values of x between 11 and 15
|  | :FOR | ${x} | IN RANGE | 11 | 16 | 
# This code block runs 5 times for x = 10, 12, 14, 16,18
|  | :FOR | ${x} | IN RANGE | 10  |  20 |  2  |
|  |    |  Log  |  ${x} |</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Flow control</h1></div></div></div><p>At times during the loop iteration, there may be cases where the execution needs to be changed, which can be done either to skip the present and continue with the next iteration or to terminate the loop entirely.</p><p>Sometimes, the loop contents need to be processed in such a manner, which is not iterative in nature. In this case, we need to issue special commands that allow us to manipulate the contents of the flow of contents within the loop irrespective of the iteration status. In most conventional programming languages, this is specified by the <code class="literal">continue</code> and <code class="literal">break</code> constructs. Robot Framework offers a similar approach by providing some special keywords for this purpose in its default library.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Breaking off without finishing</h2></div></div></div><p>By using the <code class="literal">Exit For Loop</code> or the <code class="literal">Exit For Loop If</code> built-in keywords, it is possible to terminate the loop and continue with the further statements:</p><div><pre class="programlisting">|  |  | Run Keyword If | ${val} &gt; 10 | Exit For Loop</pre></div><p>In the preceding<a id="id85" class="indexterm"/> example, <code class="literal">Run Keyword if</code> is used, which is present in the built-in library. As soon as its condition is evaluated to true, it is executed and the <code class="literal">Exit for Loop</code> keyword causes the loop to terminate. If the test case contains any other statements after the loop, then they will get executed normally.</p><p>This can be simplified through the use of <code class="literal">Exit For Loop If</code> keyword as it acts as a handler for the break operation without requiring a separate <code class="literal">if</code> condition and hence the preceding command can be rewritten as:</p><div><pre class="programlisting">|  |  | Exit For Loop If | ${val} &gt; 10 |</pre></div><p>Continuing with the next iteration, similar to breaking the loop, sometimes there are exceptional cases where there is a need to continue with the next iteration of the loop before the present iteration has completed:</p><div><pre class="programlisting">|  |  | Continue Keyword If | ${val} &gt; 10 | Exit For Loop</pre></div><p>Note the use of the <code class="literal">If</code> suffix on various commands. The <code class="literal">If</code> statement is not a specific keyword, but many statements, such as the <code class="literal">Exit For Loop</code> and <code class="literal">continue</code> keywords, have alternate definitions that act conditionally in the presence of certain conditions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Feeding external data</h1></div></div></div><p>Tests can be<a id="id86" class="indexterm"/> fed data from any external data store such as a database, an Excel, or a CSV file or some external application that returns values dynamically and then can execute over the same data. To demonstrate this concept of test re-use further, we will undertake another exercise that focuses on performing the same task repeatedly. For the sake of the reader, we have abstracted the concepts now as these can then be implemented <a id="id87" class="indexterm"/>in whichever manner possible.</p><p>Basically, if we are having a set of repeatable tasks specified in a collection of values, then we can perform them in two different manners:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Perform the set of tasks repeatedly inside a test for each value</li><li class="listitem" style="list-style-type: disc">Perform the entire test repeatedly for the values</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Performing a set of tasks repeatedly within a test</h2></div></div></div><p>In this scenario, we create a test that takes in the argument or uses a variable containing a list of elements and<a id="id88" class="indexterm"/> iterate over it. As a precursor to this, first let us create the file containing the dynamic variable. Here, the system under test is a Python script that selects values out of current time in an array whose value we cannot predetermine:</p><div><pre class="programlisting">import time 
var = [] 
while(time.time()%10 &lt;8): 
  var.append(int(time.time()%10)) 
  time.sleep(1)</pre></div><p>The preceding script first imports the <code class="literal">time</code> module as it will be used in the program later on. Next, the <code class="literal">var</code> array is created. This is followed by a <code class="literal">while</code> loop that checks the last decimal value of the currently elapsed time and checks if it is less than <code class="literal">8</code>. If it is, then it adds this last value as an integer into the array and sleeps for a second to get another value. Although, the <code class="literal">var</code> array is not randomized, its size and contents are unknown beforehand, which makes the <code class="literal">var</code> array dynamic at runtime.</p><p>This lets us have the variable <code class="literal">var</code> with an unspecified amount of value. Now we can use it to better utilize collection of values within tests. Within the test, first this Python variable file is loaded and then the contents are iterated upon:</p><div><pre class="programlisting">| *Setting* | *Value* | 
| Variables | ./dynamic_variables.py | 
| *Test Cases* | *Action* | *Argument* | 
| List should exist | Variable Should Exist | @{var} | 
| Variable not declared should not be there | Variable Should Not Exist | ${val} | 
| Iterate over Dynamic variables | :FOR | ${val} | IN | @{var} | 
|                |         | Log      | ${val} | 
|                | Log  | finished iteration |</pre></div><p>This will load the contents from the script, and iterate over the collection of values and perform a sample task over the value.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec05"/>Application in test automation</h3></div></div></div><p>The outlined concept of looping can be applied in test automation through the use of customized user keywords and loading of test data via an external program that can leverage any available data medium <a id="id89" class="indexterm"/>to load the data for the system under test. As explained earlier, this is useful in achieving test re-use and ensuring that as testers, we follow the principals of <strong>Don't Repeat Yourself</strong> (<strong>DRY</strong>).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Higher order re-use</h1></div></div></div><p>The tests can be repeated within the test suite through the creation and use of constructs of higher order that contain various test commands and at times even entire tests. This enables the tester to<a id="id90" class="indexterm"/> combine similar or equivalent user stories or use cases into a single test and provide different inputs depending upon the circumstances. Another significant advantage that test re-use offers is the overall clarity of the project. Tests if re-used have to be called from various places, thereby giving the benefits of DRY.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>User keywords</h2></div></div></div><p>As mentioned earlier, user<a id="id91" class="indexterm"/> keywords can be used to embed a part of test into a single custom keyword. These can be re-used and they can also specify arguments in their definition, which can be used to pass on test data parameters by the callers of these tests.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Test templates</h2></div></div></div><p>Test templates are used to create components within a test that can accept different parameters at runtime. <a id="id92" class="indexterm"/>This is different from user keywords as the user keywords have to be called with their name and arguments by the caller, but templates are provided with only the data to be processed. A better picture can be obtained from a sample template that just logs the provided data to it:</p><div><pre class="programlisting">Template to print params  [Template]  Log
                                      Alpha
                                      Beta
                                      Gamma
                                      Delta</pre></div><p>This example provides the arguments to the template one at a time in order to get itself processed. Here the <a id="id93" class="indexterm"/>test repeats the operation specified by the templates to its arguments and the test effectively becomes the shorter version of the following actual test:</p><div><pre class="programlisting">A normal test to print param
                Log  Alpha
                Log  Beta
                Log  Gamma
                Log  Delta</pre></div><p>Note that this is a simple example of template that is only visible inside the test cases table. There are other possibilities in creation of a template that can be re-used across different tests. Through the use of templates, the test becomes more oriented towards data and the official Robot Framework documentation states that, through templates, the keyword driven tests can be converted into data driven tests.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>User libraries</h2></div></div></div><p>User libraries provide wrappers for implementing functionality into the Robot Framework. By using user libraries, <a id="id94" class="indexterm"/>we are able to extend the framework to provide for a certain task, or more importantly, extend the capability of this tool to work on some other tool. Conversely, to use a custom library, the Robot Framework test must follow the keywords made available by such a library and provide data to the necessary arguments, thereby fulfilling the keyword format contract that leads to correct execution of the tests. This technique of creating customized library and consuming it in various tests will be dealt in detail in the next chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Approaches towards writing tests</h1></div></div></div><p>There are various approaches involved in testing and it is often the different nature of various test writing styles that separates the tests from other forms of software development. Writing acceptance tests can either be done by using the standard and external library keywords<a id="id95" class="indexterm"/> directly as mentioned before, or by using some mechanism to simplify the text of tests and make them more readable from the perspective <a id="id96" class="indexterm"/>of a non-technical person. This is crucial in agile software development as the stakeholders are involved in the design of software early on that might not be technically inclined or requiring to understand the syntax of tests like a programmer. However, they can provide a vision of how an application is supposed to work or behave; their input and feedback are important.</p><p>The Robot Framework supports mainly three styles of writing tests. While the execution and output of the tests are not different, it is the nature of the test's syntax itself that separates it from a similar test written in a different style. These are explained in detail in the following section:</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Keyboard-driven tests</h2></div></div></div><p>Keyboard-driven test is the most commonly used technique where the test is broken down into different portions known as keywords, which determine the contents of the tests. These keywords may further<a id="id97" class="indexterm"/> contain other keywords or tests, which are able to be re-used and extracted wherever<a id="id98" class="indexterm"/> needed. Through the use of keywords, test constructs can be made abstract and multiple and/or complex statements can be added under a single keyword that can make the tests a lot easier to understand and its function can be easily understood.</p><p>To better understand this approach, consider the following test code, which uses the process library to open the Firefox browser with <a class="ulink" href="http://google.com">google.com</a> as the opened page:</p><div><pre class="programlisting">Start Process  firefox  google.com</pre></div><p>Now consider the keyword approach:</p><div><pre class="programlisting">Open google.com homepage in firefox browser</pre></div><p>This does exactly the same as the previous code, but offers much clearer view in the test. Its implementation details can be hidden in the <code class="literal">Keyword</code> table as follows:</p><div><pre class="programlisting"> Open ${url} homepage on ${prog} browser  Start Process  ${prog}  ${url}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Data-driven tests</h2></div></div></div><p>The data-driven tests are useful while doing parameterization as the same test can be re-used with data comprising<a id="id99" class="indexterm"/> of different values. This makes tests like<a id="id100" class="indexterm"/> these versatile and without performing the same set of actions, one can easily have various test cases where the task to be carried out largely remains the same with only the inputs and outputs to be changed. This differs from the keyword-driven tests as these tests are coarser, granular, and depend on the test templates to provide the necessary tests in place as explained in the test template section earlier.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Behavior-driven tests</h2></div></div></div><p>One of the popular<a id="id101" class="indexterm"/> styles that has recently seen an increased growth is the behavior-driven development. Creating tests that cover software behavior and writing actual software based on these<a id="id102" class="indexterm"/> tests is known as <strong>Behavior-Driven Development</strong> (<strong>BDD</strong>). However, <a id="id103" class="indexterm"/>so far this book was dealing with keyword-driven acceptance test, which is quite rigid in its structure. To deal with automation, external data streams can be used and the tests can be fed this information based on the data. However, the tests can also be structured to suit the business user requirements oriented towards behavior. However, first we need to understand<a id="id104" class="indexterm"/> BDD before applying the same in our tests.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Behavior-driven development</h1></div></div></div><p>Despite the obvious benefits <a id="id105" class="indexterm"/>of automated acceptance tests, in practice, even amongst experienced XP and TDD teams, it's rarely done, or done well. One of the reasons is that finding a stakeholder with the technical ability, interest, and patience to sit in front of a computer writing pure code for even a DSL like gerkin or RSpec is hard. Consider the following <code class="literal">rspec</code> test present in WEBrick (an HTTP server in Ruby commonly used in development):</p><div><pre class="programlisting">  should "be a WEBrick" do 
    GET("/test") 
    status.should.equal 200 
    response["SERVER_SOFTWARE"].should =~ /WEBrick/ 
    response["HTTP_VERSION"].should.equal "HTTP/1.1" 
    response["SERVER_PROTOCOL"].should.equal "HTTP/1.1" 
    response["SERVER_PORT"].should.equal "9202" 
    response["SERVER_NAME"].should.equal "127.0.0.1" 
  end</pre></div><p>This example observes the behavior that is based on the response from the server, from this it can be concluded that the server is a WEBrick server or not.</p><p>However, at time this may be deeply integrated into the code of test and requires that the internals of the system under test are exposed to it. This is because the developer is required to provide the actual method calls/interfaces or code mocks or stubs of the software right into the <code class="literal">rspec</code> tests, which might be fine in projects involving developers, but is not feasible where black box testing, as in acceptance testing is required.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>BDD using the Robot Framework</h1></div></div></div><p>Robot Framework not only provides a DSL or a platform to easily write the code in a human-readable <a id="id106" class="indexterm"/>format, but also separates itself from understanding the internals of the concerned software as it only performs the acceptance<a id="id107" class="indexterm"/> testing for a given behavior. These tests only differ in the manner in which the user keywords take in arguments, which is done within the keywords themselves. Here these keywords comprise of multiple letters and describe a specific thing to do.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Standard libraries</h1></div></div></div><p>The Robot Framework<a id="id108" class="indexterm"/> provides various keywords, which have been discussed so far. These are contained in the <code class="literal">builtIn</code> library and are available to any test by default. In addition to these, there are certain extra keywords that are part of the <a id="id109" class="indexterm"/>framework which are bundled as separate libraries and to use them, an explicit reference needs to be provided without any installation. These libraries are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Collections</li><li class="listitem" style="list-style-type: disc">Dialogs</li><li class="listitem" style="list-style-type: disc">Operating System</li><li class="listitem" style="list-style-type: disc">Process</li><li class="listitem" style="list-style-type: disc">Screenshot</li><li class="listitem" style="list-style-type: disc">String</li><li class="listitem" style="list-style-type: disc">Telnet</li><li class="listitem" style="list-style-type: disc">XML</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Collections</h2></div></div></div><p>This library uses the supplied lists and dictionaries from an external Python file and performs various<a id="id110" class="indexterm"/> operations, such as comparison and modification over it. Some keywords from the <code class="literal">builtin</code> library that operate over lists and dictionaries can also be used in <a id="id111" class="indexterm"/>conjunction with this library. For example, consider the following example where the Python file defines the following variables:</p><div><pre class="programlisting">details = [1,'ssh', .034, 'main-repository']
user = {'name':'john doe', 'age': 21, 'account':'basic'}</pre></div><p>These variables can be manipulated in the test as follows:</p><div><pre class="programlisting">*** Setting ***

Library  Collections
Variables  filename.py

*** Test Cases ***

Lists  Should not be empty  ${details}
       Append to List  ${details}  12500
       ${custom}  Create List  1  ssh  .34  main-repository  12500
       Lists should be equal  ${details}  ${custom}

Dicts  Should not be empty  ${user}
       Dictionary should contain key  ${user}  name
       Dictionary should contain value  ${user}  21
       Dictionary should contain value  ${user}  basic</pre></div><p>Similarly, other <a id="id112" class="indexterm"/>keywords belonging to the collections library can<a id="id113" class="indexterm"/> be used together with other libraries.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Dialogs</h2></div></div></div><p>Dialogs provide a <a id="id114" class="indexterm"/>way to let the user input data during the test execution. Although this goes against the principles of automated testing, but is desired at times.<a id="id115" class="indexterm"/>
</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>Note that currently, this library does not work on IronPython runtime.</p></div></div><p>For instance, the following command lets the user pass or fail a given step:</p><div><pre class="programlisting">Execute Manual Step  Perform manual operation and continue</pre></div><p>This provides the following dialog box which waits for the user input to continue:</p><div><img src="img/36033OS_03_02.jpg" alt="Dialogs"/></div><p>On specifying the <strong>Fail</strong> option, the user is further requested for the failure message before failing the test.</p><p>Similarly, the other keywords specified in this library can be used.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Operating System</h2></div></div></div><p>This library provides the Robot Framework<a id="id116" class="indexterm"/> interaction with the OS environment, such as files and folders, environment variables, and the ability to call various <a id="id117" class="indexterm"/>processes. Most of the methods declared in this library are self-explanatory. However, keywords that manage processes are deprecated and are now also present in process library.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Process</h2></div></div></div><p>This library allows the test to <a id="id118" class="indexterm"/>run external programs. It uses the sub process module in Python where the external process is spawned, the input/error/output message pipes are connected, and the return codes are obtained. It can either run<a id="id119" class="indexterm"/> process and wait<a id="id120" class="indexterm"/> for their termination or run the processes in the background. For better management, it can also terminate one or all the processes started by the test.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Screenshot</h2></div></div></div><p>This library enables<a id="id121" class="indexterm"/> capture of screens during the Robot Framework test execution, which allows detailed reporting of the project if there are screens present in the test environment. If using with Python runtime, this will require additional libraries like <code class="literal">wxPython</code> or <code class="literal">pygtk</code>. Other runtimes provide an out of the box support for screen capture. The <code class="literal">take</code> screenshot takes the screenshot of the screen and saves it where the<a id="id122" class="indexterm"/> log file or the XML output is generated if no setting or file location is specified. If no name is given, then <code class="literal">Screenshot_number.jpg</code> is saved where the number gets incremented after every execution to create a unique saved image. Similarly, the width argument specifies how much area gets allocated to the image in the log file.</p><p>The following specifies the file name and size of screen capture image:</p><div><pre class="programlisting">  Take Screenshot  screenpic.jpg  width=500 px</pre></div><p>This saves the following image and embeds it into the log file:</p><div><img src="img/3033OS_03_03.jpg" alt="Screenshot"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>String</h2></div></div></div><p>This provides the normal String operation, such as substring, replace, and splitting strings, as well as<a id="id123" class="indexterm"/> specialized <a id="id124" class="indexterm"/>functions that generate random string. This also contains utility methods that operate over strings present across multiple lines.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Telnet</h2></div></div></div><p>This library enables the Robot Framework test to connect to a Telnet server and pass commands to run over the server. An <a id="id125" class="indexterm"/>easiest way to test this is to set up a test server on your machine itself. Considering you set the Telnet server correctly on your machine with<a id="id126" class="indexterm"/> user and password both set to <code class="literal">test</code>, then the following code will perform as desired:</p><div><pre class="programlisting">*** Setting ***
Library  Telnet
*** Test Cases ***
Telnet Session  Close All Connections
    Open Connection  127.0.0.1  prompt=test
    Login  test  test  login_prompt=login:  password_prompt=password:
    ${details}  Execute Command  ls-l
    Log  ${details}</pre></div><div><div><h3 class="title"><a id="note06"/>Note</h3><p>Note that setting up prompt in the<a id="id127" class="indexterm"/> <code class="literal">Open Connection</code> command is not mandatory, but is needed for certain commands like the <code class="literal">execute</code> command. This library is sufficient for opening, closing, as well as changing between multiple Telnet connections and covers most of the Telnet features.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>XML</h2></div></div></div><p>This is the XML parser supplied by the framework and can be used to search and validate supplied XML file or text. It <a id="id128" class="indexterm"/>uses the ElementTree library internally and offers capabilities to parse and find different elements, attributes, values, and supports <a id="id129" class="indexterm"/>Xpath-styled lookup.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Remote test execution</h1></div></div></div><p>The Robot Framework also supports <a id="id130" class="indexterm"/>the use of remote libraries, where a part of the test can be hosted as a server and can be used by other tests remotely. This is useful in centralizing a part of test at a single place and all the client tests can derive information based on that test itself.</p><p>It uses the XML-RPC protocol for the remote interaction and offers various capabilities for distributed testing, such as making different keywords available remotely that can be used to perform some operation over the remote server by different tests. Hence, a method in the remote library can be used to perform some task that can be called as a library keyword in the<a id="id131" class="indexterm"/> tests which provides re-usability of code across different tests.</p><p>To start off with the remote test, within the test, only the setting table needs to specify the location of the remote test:</p><div><pre class="programlisting">Library  Remote  http://localhost:8567</pre></div><p>On the server side, the following can be specified:</p><div><pre class="programlisting">def strings_should_be_equal(self, str1, str2):
  print "Comparing '%s' to '%s'" % (str1, str2)
  if str1 != str2
    raise AssertionError("Given strings are not equal")
  else:
    return "Given Strings are not equal"
  if name == '__main__':
    from robotremoteserver import RobotRemoteServer
    RobotRemoteServer(ExampleRemoteLibrary(), *sys.argv[1:])</pre></div><p>Here, this file can be run from the Python command to set up a Robot Remote Server and the methods defined here can be used as keywords, such as <code class="literal">strings should be equal</code>. If you are wondering if the code needs anything more, then you need to download the provided <code class="literal">RobotRemoteServer</code> script file separately and place it besides this script. Currently, the servers for Python and Ruby are present, but other servers can also be created. Thus, writing distributed tests in the Robot Framework is trivial and can easily be used through HTTP.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Summary</h1></div></div></div><p>This chapter dealt with the philosophy and style of writing the tests. As the tests should be written with automation in mind, both the internal and external re-use through iteration and parameterization of test cases as well as getting data into the tests was covered as these are amongst the important things to consider while going forward with the automation. Next, all three different writing styles consisting of keyword, data, and behavior driven tests was covered followed with brief discussion of importance of behavior-driven development and comparison with other development tools currently in popular use. This chapter provides all the remaining portions of the Robot Framework library and you can now confidently begin writing tests that can be automated and provide testing for small to large enterprise software systems by using the wide variety of tools and support provided within the framework itself. In order to extend the capabilities of the framework and make it usable with a wide variety of software, extensive focus will be made on user library in the following chapter.</p></div></body></html>