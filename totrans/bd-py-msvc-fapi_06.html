<html><head></head><body>
		<div id="_idContainer039">
			<h1 id="_idParaDest-153" class="chapter-number"><a id="_idTextAnchor155"/>6</h1>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor156"/>Using a Non-Relational Database</h1>
			<p>So far, we have learned that relational databases store data using table columns and rows. All these table records are structurally optimized and designed using different keys, such as primary, unique, and composite keys. The tables are connected using foreign/reference keys. Foreign key integrity plays a significant role in the table relationship of a database schema because it gives consistency and integrity to the data that’s persisted in the tables. <a href="B17975_05.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a>, <em class="italic">Connecting to a Relational Database</em>, provided considerable proof that FastAPI can connect to relational databases using any of the present ORMs smoothly without lots of complexities. This time, we will focus on using non-relational databases as data storage for our FastAPI microservice application. </p>
			<p>If FastAPI uses ORM for relational databases, it uses <strong class="bold">Object Document Mapping</strong> (<strong class="bold">ODM</strong>) to manage data using non-relational data stores or <strong class="bold">NoSQL</strong> databases. There are no tables, keys, and foreign key constraints involved in ODM, but a JSON document is needed to hold the various pieces of information. Different NoSQL databases vary in the storage model type that’s used to store data. The simplest among these databases manages data as key-value pairs, such as <strong class="bold">Redis</strong>, while complicated databases utilize schema-free document structures easily mapped to objects. This is usually done in <strong class="bold">MongoDB</strong>. Some use columnar data stores such as <strong class="bold">Cassandra</strong>, while some have graph-oriented data storage such as <strong class="bold">Neo4j</strong>. However, this chapter will focus on the FastAPI-MongoDB connectivity and the different ODM we can apply to pursue data management with a document-based database.</p>
			<p>The main objective of this chapter is to study, formalize, and scrutinize different ways to use MongoDB as a database for our FastAPI application. Building the repository layer and showcasing the CRUD implementation will be the main highlight. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Setting up the database environment</li>
				<li>Applying the PyMongo driver for synchronous connections</li>
				<li>Creating asynchronous CRUD transactions using Motor</li>
				<li>Implementing CRUD transactions using MongoEngine</li>
				<li>Implementing asynchronous CRUD transactions using Beanie </li>
				<li>Building an asynchronous repository for FastAPI using ODMantic</li>
				<li>Creating CRUD transactions using MongoFrames</li>
			</ul>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor157"/>Technical requirements</h1>
			<p>This chapter focuses on an eBookstore web portal, <em class="italic">online book reselling system</em>, where users can sell and buy books from home through the internet. The virtual store allows users to view the <em class="italic">sellers' profiles</em>, <em class="italic">book catalogs</em>, <em class="italic">list of orders</em>, and <em class="italic">archive of purchases</em>. When it comes to the e-commerce side, the user can select their preferred books and add them to a cart. Then, they can check out the items as orders and pursue the payment transaction afterward. All the data is stored in a MongoDB database. The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI">https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI</a> in the <strong class="source-inline">ch06</strong> project.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor158"/>Setting up the database environment</h1>
			<p>Before we start <a id="_idIndexMarker405"/>discussing the application’s database connectivity, we <a id="_idIndexMarker406"/>need to download the appropriate MongoDB database server from <a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a>. <em class="italic">online book reselling system</em> uses MongoDB 5.0.5 for a Windows platform. The installation will provide default service configuration details for the service name, data directory, and log directory. However, it is advised that you use different directory paths instead of the default ones. </p>
			<p>After the installation, we can start the MongoDB server by running <strong class="source-inline">/bin/mongod.exe</strong>. This will automatically create a database directory called <strong class="source-inline">/data/db</strong> in the <strong class="source-inline">C:/</strong> drive (Windows). We can place the <strong class="source-inline">/data/db</strong> directory in some other location, but be sure to run the <strong class="source-inline">mongod</strong> command with the <strong class="source-inline">--dbpath</strong> option while specifying <strong class="source-inline">&lt;new path&gt;/data/db</strong>.</p>
			<p>The MongoDB platform has utilities that can aid in managing database collections, and one of them is <strong class="bold">MongoDB Compass</strong>. It can provide <a id="_idIndexMarker407"/>a GUI experience that allows you to browse, explore, and easily manipulate the database and its collections. Also, it has built-in performance metrics, query views, and schema visualization features that can help with scrutinizing the correctness of the database structure. The following screenshot shows the dashboard for MongoDB Compass version 1.29.6:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_6.01_B17975.jpg" alt="Figure 6.1 – The MongoDB Compass dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The MongoDB Compass dashboard</p>
			<p>The preceding dashboard shows<a id="_idIndexMarker408"/> the document structure of the <strong class="bold">login</strong> collection, which is part of the <strong class="bold">obrs</strong> database. It gives us the spread of the data, which is an easy way to view its embedded documents, such as <strong class="source-inline">profile</strong> and list of books for sale.</p>
			<p>Once the server and utility have been installed, we need to design the data collections for our database using the <strong class="bold">class diagram</strong>. A class <a id="_idIndexMarker409"/>diagram is a UML approach to describing the components of a class and visualizing the associations and structures of the model classes involved in a system. The class diagram is one of the solutions that’s used to design the document structure of the MongoDB database since there are no records, tables, or keys involved that are essential for ERD, like in a relational database. Designing a NoSQL database always requires an equal balance between the data retrieval methods and the data composition of the database. Data that will be stored in MongoDB always needs an ideal, feasible, and appropriate document structure, associations, aggregations, and layout. The following diagram shows the class diagram for our application’s MongoDB database, <strong class="source-inline">obrs</strong>:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_6.02_B17975.jpg" alt="Figure 6.2 – The class diagram for the obrs database&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The class diagram for the obrs database</p>
			<p>Our application uses all the collections<a id="_idIndexMarker410"/> depicted in the preceding diagram to store all the information it captures from the client. Each context box represents one collection, with all the attributes and expected underlying transactions indicated inside the box. It also shows the associations that bind these collections, such as the one-to-one association between <strong class="source-inline">login</strong> and <strong class="source-inline">profile</strong> and the many-to-one association between <strong class="source-inline">BookForSale</strong> and <strong class="source-inline">UserProfile</strong>.</p>
			<p>Now that the database server has been installed and designed, let us look at the different ways of establishing a connection from our FastAPI microservice application to its MongoDB database.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor159"/>Applying the PyMongo driver for synchronous connections</h1>
			<p>We will start by learning how<a id="_idIndexMarker411"/> the FastAPI application connects to MongoDB using the PyMongo database driver. This driver is<a id="_idIndexMarker412"/> equivalent to <strong class="source-inline">psycopg2</strong>, which allows us to access PostgreSQL without using any ORM. Some popular ODMs, such as MongoEngine and Motor, use PyMongo as their core driver, which gives us the reason to explore PyMongo first before we touch on issues regarding popular ODMs. Studying the driver’s behavior can provide baseline transactions that will show how an ODM builds the database connectivity, models, and CRUD transactions. But before we proceed with the details, we need to install the <strong class="source-inline">pymongo</strong> extension using <strong class="source-inline">pip</strong>:</p>
			<p class="source-code">pip install pymongo </p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor160"/>Setting up the database connectivity</h2>
			<p>PyMongo uses its <strong class="source-inline">MongoClient</strong> module class<a id="_idIndexMarker413"/> to connect to any MongoDB database. We instantiate it with the specified host and port to extract the client object, such as <strong class="source-inline">MongoClient("localhost", "27017")</strong>, or a database URI, such as <strong class="source-inline">MongoClient('mongodb://localhost:27017/')</strong>. Our application uses the latter to connect to its database. But if we instantiate without providing the parameters, it will use the default <strong class="source-inline">localhost</strong> and <strong class="source-inline">27017</strong> details.</p>
			<p>After extracting the client object, we can use it to access the database through a dot (<strong class="source-inline">.</strong>) operator or <strong class="source-inline">attribute-style access</strong> if the database name follows the Python naming convention; for example, <strong class="source-inline">client.obrs</strong>. Otherwise, we can use the bracket symbols (<strong class="source-inline">[]</strong>) or dictionary-style access; for example, <strong class="source-inline">client["obrs_db"]</strong>. Once the database object has been retrieved, we can access the collections using the access rules. Note that a collection is equivalent to a table in a relational database, where the collated records, known as documents, are stored. The following code shows a generator function that’s used by the application to open database connectivity and access the necessary collections in preparation for the CRUD implementation:</p>
			<pre class="source-code">
<strong class="bold">from pymongo import MongoClient</strong>
def create_db_collections():
    <strong class="bold">client = MongoClient('mongodb://localhost:27017/')</strong>
    try:
        <strong class="bold">db = client.obrs</strong>
        <strong class="bold">buyers = db.buyer</strong>
        <strong class="bold">users = db.login</strong>
        <strong class="bold">print("connect")</strong>
        yield {"users": users, "buyers": buyers}
    finally:
        <strong class="bold">client.close()</strong></pre>
			<p>A generator function such as <strong class="source-inline">create_db_collections()</strong> is preferred because the <strong class="source-inline">yield</strong> statement works perfectly when it comes to managing the database connection over the <strong class="source-inline">return</strong> statement. The <strong class="source-inline">yield</strong> statement suspends the function’s execution when it sends a value back<a id="_idIndexMarker414"/> to the caller but retains the state where the function can resume at the point where it left off. This feature is applied by the generator to close the database connection when it resumes the execution at the <strong class="source-inline">finally</strong> clause. The <strong class="source-inline">return</strong> statement, on the other hand, will not be applicable for this purpose because <strong class="source-inline">return</strong> will finish the whole transaction before it sends a value to the caller. </p>
			<p>However, before we invoke the generator, let us scrutinize how PyMongo builds its model layer to pursue the necessary CRUD transactions.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor161"/>Building the model layer</h2>
			<p>Documents in MongoDB are <a id="_idIndexMarker415"/>represented and collated as JSON-style structures, specifically <a id="_idIndexMarker416"/>BSON documents. A BSON document offers more data types than the JSON structure. We can use dictionaries to represent and persist these BSON documents in PyMongo. Once a dictionary has been persisted, the BSON-type document will look like this:</p>
			<pre class="source-code">
{
   <strong class="bold">_id:ObjectId("61e7a49c687c6fd4abfc81fa")</strong>,
   id:1,
   user_id:10,
   <strong class="bold">date_purchased:"2022-01-19T00:00:00.000000"</strong>,
   purchase_history: 
   [
       {
        purchase_id:100,
        shipping_address:"Makati City",
        email:"mailer@yahoo.com",
        <strong class="bold">date_purchased:"2022-01-19T00:00:00.000000"</strong>,
        <strong class="bold">date_shipped:"2022-01-19T00:00:00.000000"</strong>,
        <strong class="bold">date_payment:"2022-01-19T00:00:00.000000"</strong>
      },
      {
        purchase_id:110,
        shipping_address:"Pasig City",
        email:"edna@yahoo.com",
        <strong class="bold">date_purchased:"2022-01-19T00:00:00.000000"</strong>,
        <strong class="bold">date_shipped:"2022-01-19T00:00:00.000000"</strong>,
        <strong class="bold">date_payment:"2022-01-19T00:00:00.000000"</strong>
      }
    ],
   customer_status: 
   {
        status_id:90,
        name:"Sherwin John C. Tragura",
        discount:50,
        <strong class="bold">date_membership:"2022-01-19T00:00:00.000000"</strong>
   }
}</pre>
			<p>Common Python data<a id="_idIndexMarker417"/> types such as <strong class="source-inline">str</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">float</strong> are <a id="_idIndexMarker418"/>supported by the BSON specification, but there are types such as <strong class="source-inline">ObjectId</strong>, <strong class="source-inline">Decimal128</strong>, <strong class="source-inline">RegEx</strong>, and <strong class="source-inline">Binary</strong> that are intrinsic only to the <strong class="source-inline">bson</strong> module. The specification only supports the <strong class="source-inline">timestamp</strong> and <strong class="source-inline">datetime</strong> temporal types. To install <strong class="source-inline">bson</strong>, use the following <strong class="source-inline">pip</strong> command:</p>
			<p class="source-code">pip install bson</p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">BSON</strong> is short for <strong class="bold">Binary JSON</strong>, a serialized and binary<a id="_idIndexMarker419"/> encoding for JSON-like documents. The specification behind this is lightweight and flexible. The efficient encoding format is <a id="_idIndexMarker420"/>explained in more detail at <a href="https://bsonspec.org/spec.html">https://bsonspec.org/spec.html</a>.</p>
			<p><strong class="source-inline">ObjectId</strong> is an essential data type in a MongoDB document because it serves as a <em class="italic">unique identifier</em> for the main document structure. It is a <em class="italic">12-byte</em> field that consists of a 4-byte UNIX <em class="italic">embedded timestamp</em>, the 3-byte <em class="italic">machine ID</em> of the MongoDB server, a 2-byte <em class="italic">process ID</em>, and a 3-byte <em class="italic">arbitrary value</em> for the ID’s increments. Conventionally, the declared field of the document, <strong class="source-inline">_id</strong>, always refers to the <strong class="source-inline">ObjectId</strong> value of the document structure. We can allow the MongoDB server to generate the _<strong class="source-inline">id</strong> object for the document or create an instance of the object type during persistence. When<a id="_idIndexMarker421"/> retrieved, <strong class="source-inline">ObjectId</strong> can be in <em class="italic">24 hexadecimal digit</em> or <em class="italic">string</em> format. Note that the <strong class="source-inline">_id</strong> field is the key indicator that a dictionary is ready to be persisted as a valid<a id="_idIndexMarker422"/> BSON document. Now, BSON documents can also be linked with one another using some associations.</p>
			<h3>Establishing document associations</h3>
			<p>MongoDB has no<a id="_idIndexMarker423"/> concept of referential integrity constraints, but a relationship among documents is possible based on structures. There are two types of documents: <em class="italic">main</em> and <em class="italic">embedded</em> documents. A document has a <em class="italic">one-to-one association</em> with another if it is an embedded document of the other. Likewise, a document has a <em class="italic">many-to-one association</em> if a list in that document is linked to the main document structure. </p>
			<p>The previous purchase BSON document shows a sample of the principal <strong class="source-inline">buyer</strong> document with a one-to-one association with the <strong class="source-inline">customer_status</strong> embedded document and a many-to-one association with the <strong class="source-inline">purchase_history</strong> documents. As depicted from this sample document, embedded documents have no separate collection because they have no respective <strong class="source-inline">_id</strong> field to make them stand as primary documents. </p>
			<h3>Using the BaseModel classes for transactions</h3>
			<p>Since PyMongo has no<a id="_idIndexMarker424"/> predefined model classes, the Pydantic models of FastAPI can be used to represent MongoDB documents with all the<a id="_idIndexMarker425"/> necessary validation rules and encoders. We can use the <strong class="source-inline">BaseModel</strong> classes to contain document details and pursue <em class="italic">insert</em>, <em class="italic">update</em>, and <em class="italic">delete</em> transactions since the Pydantic models are compatible with MongoDB documents. The following models are <a id="_idIndexMarker426"/>being used by our online book <a id="_idIndexMarker427"/>reselling application to store and retrieve the <strong class="source-inline">buyer</strong>, <strong class="source-inline">purchase_history</strong>, and <strong class="source-inline">customer_status</strong> document details:</p>
			<pre class="source-code">
<strong class="bold"> from pydantic import BaseModel, validator</strong>
from typing import List, Optional, Dict
<strong class="bold">from bson import ObjectId</strong>
from datetime import date
class PurchaseHistoryReq(<strong class="bold">BaseModel</strong>):
    purchase_id: int
    shipping_address: str 
    email: str   
    <strong class="bold">date_purchased: date</strong>
    <strong class="bold">date_shipped: date</strong>
    <strong class="bold">date_payment: date</strong>
    <strong class="bold">@validator('date_purchased')</strong>
    def date_purchased_datetime(cls, value):
        return <strong class="bold">datetime.strptime(value,</strong> 
           <strong class="bold">"%Y-%m-%dT%H:%M:%S").date()</strong>
    
    <strong class="bold">@validator('date_shipped')</strong>
    def date_shipped_datetime(cls, value):
        return <strong class="bold">datetime.strptime(value, </strong>
           <strong class="bold">"%Y-%m-%dT%H:%M:%S").date()</strong>
    
    <strong class="bold">@validator('date_payment')</strong>
    def date_payment_datetime(cls, value):
        return <strong class="bold">datetime.strptime(value, </strong>
           <strong class="bold">"%Y-%m-%dT%H:%M:%S").date()</strong>
    
    <strong class="bold">class Config:</strong>
        <strong class="bold">arbitrary_types_allowed = True</strong>
        <strong class="bold">json_encoders = {</strong>
            <strong class="bold">ObjectId: str</strong>
        <strong class="bold">}</strong>
        
class PurchaseStatusReq(<strong class="bold">BaseModel</strong>):
    status_id: int 
    name: str
    discount: float 
    <strong class="bold">date_membership: date</strong>
    <strong class="bold">@validator('date_membership')</strong>
    def date_membership_datetime(cls, value):
        return <strong class="bold">datetime.strptime(value,</strong> 
            <strong class="bold">"%Y-%m-%dT%H:%M:%S").date()</strong>
    
    <strong class="bold">class Config:</strong>
        <strong class="bold">arbitrary_types_allowed = True</strong>
        <strong class="bold">json_encoders = {</strong>
            <strong class="bold">ObjectId: str</strong>
        <strong class="bold">}</strong>
        
class BuyerReq(<strong class="bold">BaseModel</strong>):
    <strong class="bold">_id: ObjectId</strong>
    Buyer_id: int
    user_id: int
    date_purchased: date
    purchase_history: List[Dict] = list()
    customer_status: Optional[Dict]
    <strong class="bold">@validator('date_purchased')</strong>
    def date_purchased_datetime(cls, value):
        return <strong class="bold">datetime.strptime(value,</strong> 
            <strong class="bold">"%Y-%m-%dT%H:%M:%S").date()</strong>
  
    <strong class="bold">class Config:</strong>
        <strong class="bold">arbitrary_types_allowed = True</strong>
        <strong class="bold">json_encoders = {</strong>
            <strong class="bold">ObjectId: str</strong>
        <strong class="bold">}</strong></pre>
			<p>For these request<a id="_idIndexMarker428"/> models to recognize<a id="_idIndexMarker429"/> the BSON data types, we should make some modifications to the default behavior of these models. Just like earlier in this chapter, where we added the <strong class="source-inline">orm_mode</strong> option, there is also a need to add a nested <strong class="source-inline">Config</strong> class to the <strong class="source-inline">BaseModel</strong> blueprint with the <strong class="source-inline">arbitrary_types_allowed</strong> option set to <strong class="source-inline">True</strong>. This additional<a id="_idIndexMarker430"/> configuration will recognize the BSON data types used in the attribute declaration, including compliance with the necessary underlying validation rules for the corresponding BSON data types used. Moreover, the <strong class="source-inline">json_encoders</strong> option <a id="_idIndexMarker431"/>should also be part of the configuration to convert the <strong class="source-inline">ObjectId</strong> property of the document into a string during a query transaction.</p>
			<h3>Using Pydantic validation</h3>
			<p>However, some other types are too<a id="_idIndexMarker432"/> complex for <strong class="source-inline">json_encoders</strong> to process, such as the BSON <strong class="source-inline">datettime</strong> field being converted into a Python <strong class="source-inline">datetime.date</strong>. Since the ODM cannot automatically convert a <a id="_idIndexMarker433"/>MongoDB datetime into a Python <strong class="source-inline">date</strong> type, we need to create a custom validation and parse this BSON <strong class="source-inline">datetime</strong> through Pydantic’s <strong class="source-inline">@validation</strong> decorator. We must also use custom validators and parsers in the FastAPI services to convert all incoming Python date parameters into BSON datetime. This will be covered later.</p>
			<p><strong class="source-inline">@validator</strong> creates a <strong class="source-inline">class</strong> method that accepts <strong class="source-inline">class name</strong> as the first parameter, not the instance, of the field(s) to be validated and parsed. Its second parameter is an option that specifies the field name or class attribute that needs to be converted into another data type, such as <strong class="source-inline">date_purchased</strong>, <strong class="source-inline">date_shipped</strong>, or <strong class="source-inline">date_payment</strong> of the <strong class="source-inline">PurchaseRequestReq</strong> model. The <strong class="source-inline">pre</strong> attribute of <strong class="source-inline">@validator</strong> tells FastAPI to process the class methods before any built-in validation can be done in the API service implementation. These methods are executed right after <strong class="source-inline">APIRouter</strong> runs its custom and built-in FastAPI validation rules for the request models, if there are any.</p>
			<p>Note that these request models have been placed in the <strong class="source-inline">/models/request/buyer.py</strong> module of the application.</p>
			<h3>Using the Pydantic @dataclass to query documents</h3>
			<p>Wrapping the queried BSON <a id="_idIndexMarker434"/>documents using the <strong class="source-inline">BaseModel</strong> model classes is still the best approach to implementing the<a id="_idIndexMarker435"/> query transaction. But since BSON has issues with the Python <strong class="source-inline">datetime.date</strong> fields, we cannot always utilize the request model classes that are used for the CRUD transaction by wrapping retrieved BSON documents. Sometimes, using the model yields an <strong class="source-inline">"invalid date format (type=value_error.date)"</strong> error because all the models have the Python <strong class="source-inline">datetime.date</strong> fields, whereas the incoming data has a BSON <strong class="source-inline">datetime</strong> or <strong class="source-inline">timestamp</strong>. Instead of adding more complexities to the request models, we should resort to another approach to extracting the documents – that is, utilizing the Pydantic <strong class="source-inline">@dataclass</strong>. The following data <a id="_idIndexMarker436"/>classes are defined for wrapping the extracted <strong class="source-inline">buyer</strong> documents:</p>
			<pre class="source-code">
<strong class="bold">from pydantic.dataclasses import dataclass</strong>
<strong class="bold">from dataclasses import field</strong>
<strong class="bold">from pydantic import validator</strong>
from datetime import date, datetime
from bson import ObjectId
from typing import List, Optional
class <strong class="bold">Config</strong>:
        <strong class="bold">arbitrary_types_allowed = True</strong>
<strong class="bold">@dataclass(config=Config)</strong>
class <strong class="bold">PurchaseHistory</strong>:
    purchase_id: <strong class="bold">Optional[int] = None</strong>
    shipping_address: <strong class="bold">Optional[str] = None</strong>
    email: <strong class="bold">Optional[str] = None</strong>   
    date_purchased: <strong class="bold">Optional[date] = "1900-01-01T00:00:00"</strong>
    date_shipped: <strong class="bold">Optional[date] = "1900-01-01T00:00:00"</strong>
    date_payment: <strong class="bold">Optional[date] = "1900-01-01T00:00:00"</strong>
    
    <strong class="bold">@validator('date_purchased', pre=True)</strong>
    def date_purchased_datetime(cls, value):
        return datetime.strptime(value, 
           "%Y-%m-%dT%H:%M:%S").date()
    
    <strong class="bold">@validator('date_shipped', pre=True)</strong>
    def date_shipped_datetime(cls, value):
        return datetime.strptime(value, 
           "%Y-%m-%dT%H:%M:%S").date()
    
    <strong class="bold">@validator('date_payment', pre=True)</strong>
    def date_payment_datetime(cls, value):
        return datetime.strptime(value, 
           "%Y-%m-%dT%H:%M:%S").date()
<strong class="bold">@dataclass(config=Config)</strong>
class <strong class="bold">PurchaseStatus</strong>:
    status_id: <strong class="bold">Optional[int] = None</strong>
    name: <strong class="bold">Optional[str] = None</strong>
    discount: <strong class="bold">Optional[float] = None</strong>
    date_membership: <strong class="bold">Optional[date] = "1900-01-01T00:00:00"</strong>
    
    <strong class="bold">@validator('date_membership', pre=True)</strong>
    def date_membership_datetime(cls, value):
        return datetime.strptime(value, 
           "%Y-%m-%dT%H:%M:%S").date()
      
<strong class="bold">@dataclass(config=Config)</strong>
class <strong class="bold">Buyer</strong>:
    buyer_id: int 
    user_id: int 
    date_purchased: date 
    purchase_history: List[PurchaseHistory] = 
          <strong class="bold">field(default_factory=list )</strong>
    customer_status: Optional[PurchaseStatus] = 
          <strong class="bold">field(default_factory=dict)</strong>
    <strong class="bold">_id: ObjectId = field(default=ObjectId())</strong>
    
    <strong class="bold">@validator('date_purchased', pre=True)</strong>
    def date_purchased_datetime(cls, value):
        print(type(value))
        return datetime.strptime(value, 
             "%Y-%m-%dT%H:%M:%S").date()</pre>
			<p><strong class="source-inline">@dataclass</strong> is a decorator <a id="_idIndexMarker437"/>function <a id="_idIndexMarker438"/>that adds an <strong class="source-inline">__init__()</strong> to a Python class to initialize its attributes and other special functions, such as <strong class="source-inline">__repr__()</strong>. The <strong class="source-inline">PurchasedHistory</strong>, <strong class="source-inline">PurchaseStatus</strong>, and <strong class="source-inline">Buyer</strong> custom classes shown in the preceding code are typical classes that can<a id="_idIndexMarker439"/> be converted into request model classes. FastAPI supports both <strong class="source-inline">BaseModel</strong> and data classes when creating model classes. Apart from being under the <strong class="source-inline">Pydantic</strong> module, using <strong class="source-inline">@dataclass</strong> is not a replacement for using <strong class="source-inline">BaseModel</strong> when creating model classes. This is because the two components are different in terms of their flexibility, features, and hooks. <strong class="source-inline">BaseModel</strong> is configuration-friendly and can be adapted to many validation rules and type hints, while <strong class="source-inline">@dataclass</strong> has problems recognizing some <strong class="source-inline">Config</strong> attributes such as <strong class="source-inline">extra</strong>, <strong class="source-inline">allow_population_by_field_name</strong>, and <strong class="source-inline">json_encoders</strong>. If a data class requires some additional details, a custom class is needed to define these configurations and set the <strong class="source-inline">config</strong> parameter of the decorator. For instance, the <strong class="source-inline">Config</strong> class in the preceding code, which sets <strong class="source-inline">arbitrary_types_allowed</strong> to <strong class="source-inline">True</strong>, has been added to the three model classes. </p>
			<p>Besides <strong class="source-inline">config</strong>, the decorator has other parameters such as <strong class="source-inline">init</strong>, <strong class="source-inline">eq</strong>, and <strong class="source-inline">repr</strong> that accept <strong class="source-inline">bool</strong> values to generate their respective hook methods. The <strong class="source-inline">frozen</strong> parameter enables exception handling concerning field type mismatches when set to <strong class="source-inline">True</strong>.</p>
			<p>When it comes to data <a id="_idIndexMarker440"/>parsing, transition, and conversion, <strong class="source-inline">@dataclass</strong> is always dependent on augmented validations, unlike <strong class="source-inline">BaseModel</strong>, which can process data type conversion simply by adding <strong class="source-inline">json_encoders</strong>. In the data classes shown previously, all the validators focus on BSON <strong class="source-inline">datetime</strong> to Python <strong class="source-inline">datetime.date</strong> conversion during the document retrieval process. These validations will occur before any custom or built-in validation in <strong class="source-inline">APIRouter</strong> because the <strong class="source-inline">pre</strong> parameter of the <strong class="source-inline">@validator</strong> decorator is set to <strong class="source-inline">True</strong>.</p>
			<p>When dealing with default values, <strong class="source-inline">BaseModel</strong> classes can use typical type hints such as <strong class="source-inline">Optional</strong> or object instantiation such as <strong class="source-inline">dict()</strong> or <strong class="source-inline">list()</strong> to define the preconditional state of its complex attributes. With <strong class="source-inline">@dataclass</strong>, a <strong class="source-inline">ValueError</strong> exception is always thrown at compile time when type hints are applied to set default values of complex field<a id="_idIndexMarker441"/> types such as <strong class="source-inline">list</strong>, <strong class="source-inline">dict</strong>, and <strong class="source-inline">ObjectId</strong>. It requires the <strong class="source-inline">field()</strong> specifier from Python’s <strong class="source-inline">dataclasses</strong> module to set the default values of these fields, either by assigning an actual value through the specifier’s <strong class="source-inline">default</strong> parameter or invoking a function or lambda that returns a valid value through the <strong class="source-inline">default_factory</strong> parameter. The use of <strong class="source-inline">field()</strong> indicates that Pydantic’s <strong class="source-inline">@dataclass</strong> is an exact replacement of Python’s core data classes but with some additional features, such as the <strong class="source-inline">config</strong> parameter and the inclusion of the <strong class="source-inline">@validator</strong> components. </p>
			<p>Note that it is advised that all <strong class="source-inline">@dataclass</strong> models have default values when using type hints or <strong class="source-inline">field()</strong>, especially for embedded documents and for models with the <strong class="source-inline">date</strong> or <strong class="source-inline">datetime</strong> types, to <a id="_idIndexMarker442"/>avoid some missing constructor parameter(s) errors. On the other hand, an <strong class="source-inline">@dataclass</strong> can <a id="_idIndexMarker443"/>also create embedded structures in the <strong class="source-inline">BaseModel</strong> classes, for example, by defining attributes with the class types. This is highlighted in the <strong class="source-inline">Buyer</strong> model.</p>
			<p>All these model classes have been placed in the <strong class="source-inline">/models/data/pymongo.py</strong> script. Let us now apply these data models to create the repository layer.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor162"/>Implementing the repository layer</h2>
			<p>PyMongo needs <strong class="source-inline">collection</strong> to build the<a id="_idIndexMarker444"/> repository layer of the application. Besides<a id="_idIndexMarker445"/> the <strong class="source-inline">collection</strong> object, the <em class="italic">insert</em>, <em class="italic">delete</em>, and <em class="italic">update</em> transactions will also need the <strong class="source-inline">BaseModel</strong> classes to contain all the details from the client and convert them into BSON documents after the transaction. Meanwhile, our query transactions will require the data classes to convert all BSON documents into JSON-able resources during the document retrieval process. Now, let us look at how a repository can be implemented using a PyMongo driver.</p>
			<h3>Building the CRUD transactions</h3>
			<p>The repository <a id="_idIndexMarker446"/>class in the following code block implements the CRUD transactions that aim to manage the <strong class="source-inline">buyer</strong>, <strong class="source-inline">purchase_history</strong>, and <strong class="source-inline">customer_status</strong> information based on basic specifications of the <em class="italic">online book reselling </em>system:</p>
			<pre class="source-code">
from typing import Dict, Any
<strong class="bold">class BuyerRepository: </strong>
    
    def __init__(self, <strong class="bold">buyers</strong>): 
        <strong class="bold">self.buyers = buyers</strong>
    
    def <strong class="bold">insert_buyer</strong>(self, users, 
          details:Dict[str, Any]) -&gt; bool: 
        try:
           user = users.find_one(
                {"_id": details["user_id"]})
           print(user)
           if user == None:
               return False
           else: 
               <strong class="bold">self.buyers.insert_one(details)</strong>
                  
        except Exception as e:
            return False 
        return True</pre>
			<p>Let us examine <strong class="source-inline">insert_buyer()</strong>, which inserts details about a registered book buyer who had some previous transactions in the system as a <strong class="source-inline">login</strong> user. The PyMongo collection offers helper methods for <a id="_idIndexMarker447"/>processing CRUD transactions, such as <strong class="source-inline">insert_one()</strong>, which adds a single main document from its <strong class="source-inline">Dict</strong> parameter. It also has <strong class="source-inline">insert_many()</strong>, which accepts a valid list of dictionaries that can be persisted as multiple documents. These two methods can generate an <strong class="source-inline">ObjectId</strong> for the <strong class="source-inline">_id</strong> field of the BSON document during the insertion process. The buyer’s details are extracted from the <strong class="source-inline">BuyerReq</strong> Pydantic model.</p>
			<p>Next, <strong class="source-inline">update_buyer()</strong> shows how to update a specific document in the <strong class="source-inline">buyer</strong> collection:</p>
			<pre class="source-code">
    def <strong class="bold">update_buyer</strong>(self, id:int, 
              details:Dict[str, Any]) -&gt; bool: 
       try:
          <strong class="bold">self.buyers.update_one({"buyer_id": id},</strong>
                  <strong class="bold">{"$set":details})</strong>
       except: 
           return False 
       return True
   
    def <strong class="bold">delete_buyer</strong>(self, id:int) -&gt; bool: 
        try:
            <strong class="bold">self.buyers.delete_one({"buyer_id": id})</strong>
        except: 
            return False 
        return True</pre>
			<p>The collection has an <strong class="source-inline">update_one()</strong> method that requires two parameters: a unique and valid field/value dictionary pair that will serve as the <em class="italic">search key</em> of the record search, and another dictionary pair<a id="_idIndexMarker448"/> with the predefined <strong class="source-inline">$set</strong> key with the dictionary of updated <em class="italic">details for replacement</em>. It also has <strong class="source-inline">update_many()</strong>, which can update multiple documents, given that the primary dictionary field/value parameter is not unique.</p>
			<p><strong class="source-inline">delete_buyer()</strong> is the transaction that deletes a <strong class="source-inline">buyer</strong> document using a unique and valid field/value pair such as <strong class="source-inline">{"buyer_id": id}</strong>. If this parameter or search key is a common/non-unique data, the collection offers <strong class="source-inline">delete_many()</strong>, which can delete multiple documents. Now, the following script shows how to implement query transactions in PyMongo</p>
			<pre class="source-code">
<strong class="bold">from dataclasses import asdict</strong>
<strong class="bold">from models.data.pymongo import Buyer</strong>
from datetime import datetime
<strong class="bold">from bson.json_util import dumps</strong>
<strong class="bold">import json</strong>
    … … …
    … … …  
    … … …
    def <strong class="bold">get_all_buyer</strong>(self):
        <strong class="bold">buyers = [asdict(Buyer(**json.loads(dumps(b)))) </strong>
              for b in self.buyers.find()]
        return buyers
    
    def <strong class="bold">get_buyer</strong>(self, id:int): 
        buyer = self.buyers.find_one({"buyer_id": id})
        return <strong class="bold">asdict(Buyer(**json.loads(dumps(buyer))))</strong></pre>
			<p>When querying documents, PyMongo has a <strong class="source-inline">find()</strong> method, which retrieves all the documents in the collection, and <strong class="source-inline">find_one()</strong>, which can get a unique and single document. Both methods need two parameters: the conditional or logical query parameter in the form of a dictionary field/value pair and the set of fields that needs to appear in the record. <strong class="source-inline">get_buyer()</strong> in the previous code block shows how to retrieve a buyer document<a id="_idIndexMarker449"/> through the unique <strong class="source-inline">buyer_id</strong> field. The absence of its second parameter means the presence of all the fields in the result. Meanwhile, <strong class="source-inline">get_all_buyer()</strong> retrieves all the buyer documents without constraints. Constraints or filter expressions are formulated using BSON comparison operators, as shown in the following table:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Table_011.jpg" alt=""/>
				</div>
			</div>
			<p>For instance, retrieving buyer documents with <em class="italic">user_id greater than 5</em> requires the <strong class="source-inline">buyers.find({"user_id": {"$gte": 5}})</strong> query operation. If we need to build compound filters, we must apply<a id="_idIndexMarker450"/> the following logical operators:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Table_021.jpg" alt=""/>
				</div>
			</div>
			<p>Retrieving buyer documents with <em class="italic">buyer_id less than 50</em> and <em class="italic">buyer_id greater than 10</em> will require the <strong class="source-inline">find({'and': [{'buyer_id': {'$lt': 50}}, {'user_id':{'$gt':10}}]})</strong> query.</p>
			<p>Both methods return<a id="_idIndexMarker451"/> BSON documents that are not JSON-able components of the FastAPI framework. To convert the documents into JSON, the <strong class="source-inline">bson.json_util</strong> extension has a <strong class="source-inline">dumps()</strong> method that can convert a single document or list of documents into a JSON string. Both <strong class="source-inline">get_all_buyer()</strong> and <strong class="source-inline">get_buyer()</strong>convert every single document retrieved into JSON so that each can be mapped to the <strong class="source-inline">Buyer</strong> data class. The main objective of the mapping is to convert the <strong class="source-inline">datetime</strong> fields into Python <strong class="source-inline">datetime.date</strong> while utilizing the validators of the <strong class="source-inline">Buyer</strong> data class. The mapping will only be successful if the <strong class="source-inline">loads()</strong> method of the <strong class="source-inline">json</strong> extension is used to convert <strong class="source-inline">str</strong> into a <strong class="source-inline">dict</strong> data structure. After generating the list of <strong class="source-inline">Buyer</strong> data classes, the <strong class="source-inline">asdict()</strong> method of Python’s <strong class="source-inline">dataclasses</strong> module is needed to transform the list of <strong class="source-inline">Buyer</strong> data classes into a list of dictionaries to be consumed by <strong class="source-inline">APIRouter</strong>.</p>
			<h3>Managing document association</h3>
			<p>Technically, there are two ways to<a id="_idIndexMarker452"/> construct a document association in PyMongo. The first one is to use the <strong class="source-inline">DBRef</strong> class of the <strong class="source-inline">bison.dbref</strong> module to link the parent and child documents. The only prerequisite is for both documents to have an <strong class="source-inline">_id</strong> value of the <strong class="source-inline">ObjectId</strong> type and have their respective collection exist. For instance, if <strong class="source-inline">PurchaseHistoryReq</strong> is a core document, we can insert one purchase record into the list through the following query: </p>
			<pre class="source-code">
buyer["purchase_history"].append(new  DBRef("purchase_history", "49a3e4e5f462204490f70911"))</pre>
			<p>Here, the first<a id="_idIndexMarker453"/> parameter of the <strong class="source-inline">DBRef</strong> constructor pertains to the name of the collection where the child document is placed, while the second one is the <strong class="source-inline">ObjectId</strong> property of the child document in string format. However, some people use an <strong class="source-inline">ObjectId</strong> instance instead of the string version. On the other hand, to find a specific <strong class="source-inline">purchase_history</strong> document from the <strong class="source-inline">buyer</strong> collection using <strong class="source-inline">DBRef</strong>, we can write our query like this:</p>
			<pre class="source-code">
buyer.find({ "purchase_history ": DBRef("purchase_history",ObjectId("49a3e4e5f462204490f70911")) })</pre>
			<p>The second way is to<a id="_idIndexMarker454"/> add the whole BSON document structure to the <strong class="source-inline">list</strong> field of <strong class="source-inline">buyer</strong> through the <strong class="source-inline">BuyerReq</strong> model. This solution applies to embedded documents that do not have <strong class="source-inline">_id</strong> and <strong class="source-inline">collection</strong> but are essential to the core document. <strong class="source-inline">add_purchase_history()</strong> in the following code shows how this approach is applied to create a many-to-one association between the <strong class="source-inline">purchase_history</strong> and <strong class="source-inline">buyer</strong> documents:</p>
			<pre class="source-code">
def <strong class="bold">add_purchase_history</strong>(self, id:int, 
                details:Dict[str, Any]): 
        try:
            buyer = self.buyers.<strong class="bold">find_one</strong>({"buyer_id": id})
            <strong class="bold">buyer["purchase_history"].append(details)</strong>
            self.buyers.<strong class="bold">update_one</strong>({"buyer_id": id},
           {"$set": {"purchase_history": 
                     buyer["purchase_history"]}})
        except Exception as e: 
           return False 
        return True
    
    def <strong class="bold">add_customer_status</strong>(self, id:int, 
                  details:Dict[str, Any]): 
        try:
            buyer = self.buyers.<strong class="bold">find_one</strong>({"buyer_id": id})
            self.buyers.<strong class="bold">update_one</strong>({"buyer_id": id},
                {"$set":{"customer_status": details}})
        except Exception as e: 
           return False 
        return True</pre>
			<p>The <strong class="source-inline">add_customer_status()</strong> method shows how to implement the second approach in building a one-to-one<a id="_idIndexMarker455"/> association between the <strong class="source-inline">buyer</strong> and <strong class="source-inline">purchase_status</strong> documents. The first approach, which involves using <strong class="source-inline">DBRef</strong>, can also be applied if <strong class="source-inline">PurchaseStatusReq</strong> is an independent core document.</p>
			<p>The complete repository class can be found in the <strong class="source-inline">/repository/pymongo/buyer.py</strong> script file. Now, let us apply these CRUD transactions to our API services.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor163"/>Running the transactions</h2>
			<p>Before executing <a id="_idIndexMarker456"/>the <strong class="source-inline">BuyerRepository</strong> transactions, the <strong class="source-inline">create_db_collections()</strong> generator should be injected into the API services using <strong class="source-inline">Depends</strong>. Since PyMongo has difficulty processing Python types that are not BSON-supported, such as <strong class="source-inline">datettime.date</strong>, custom validations and serializers are sometimes required to pursue some transactions. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The implementation of <strong class="source-inline">@validator</strong> inside <strong class="source-inline">@dataclass</strong> and <strong class="source-inline">BaseModel</strong> converts outgoing BSON <strong class="source-inline">datetime</strong> parameters into Python <strong class="source-inline">date</strong> during query retrieval. Meanwhile, the JSON encoder validation in this API layer converts incoming Python <strong class="source-inline">date</strong> values into BSON <strong class="source-inline">datetime</strong> values during the transition from the application to MongoDB. </p>
			<p>For instance, the <strong class="source-inline">add_buyer()</strong>, <strong class="source-inline">update_buyer()</strong>, and <strong class="source-inline">add_purchase_history()</strong> transaction methods in the following code require a custom serializer such as <strong class="source-inline">json_serialize_date()</strong> to transform the Python <strong class="source-inline">datetime.date</strong> value<a id="_idIndexMarker457"/> into the <strong class="source-inline">datettime.datetime</strong> type so that it complies with PyMongo’s BSON specification: </p>
			<pre class="source-code">
from fastapi import APIRouter, <strong class="bold">Depends</strong>
from fastapi.responses import JSONResponse
<strong class="bold">from models.request.buyer import BuyerReq</strong>, 
      <strong class="bold">PurchaseHistoryReq, PurchaseStatusReq</strong>
<strong class="bold">from repository.pymongo.buyer import BuyerRepository</strong>
<strong class="bold">from db_config.pymongo_config import create_db_collections</strong>
from datetime import date, datetime
from json import dumps, loads
from bson import ObjectId
router = APIRouter()
def <strong class="bold">json_serialize_date</strong>(obj):
    if isinstance(obj, (date, datetime)):
        return obj.strftime('%Y-%m-%dT%H:%M:%S')
    raise TypeError ("The type %s not serializable." % 
            type(obj))
def <strong class="bold">json_serialize_oid</strong>(obj):
    if isinstance(obj, ObjectId):
        return str(obj)
    elif isinstance(obj, date):
        return obj.isoformat()
    raise TypeError ("The type %s not serializable." % 
            type(obj))
<strong class="bold">@router.post("/buyer/add")</strong>
def add_buyer(req: BuyerReq, 
            <strong class="bold">db=Depends(create_db_collections))</strong>: 
    buyer_dict = req.dict(exclude_unset=True)
    buyer_json = dumps(buyer_dict, 
              <strong class="bold">default=json_serialize_date</strong>)
    repo:BuyerRepository = BuyerRepository(db["buyers"])
    result = repo.insert_buyer(db["users"], 
            loads(buyer_json))  
   
    if result == True: 
        return JSONResponse(content={"message": 
          "add buyer successful"}, status_code=201) 
    else: 
        return JSONResponse(content={"message": 
          "add buyer unsuccessful"}, status_code=500) 
<strong class="bold">@router.patch("/buyer/update")</strong>
def update_buyer(id:int, req:BuyerReq, 
           <strong class="bold">db=Depends(create_db_collections))</strong>: 
    buyer_dict = req.dict(exclude_unset=True)
    buyer_json = dumps(buyer_dict, 
             <strong class="bold">default=json_serialize_date</strong>)
    repo:BuyerRepository = BuyerRepository(db["buyers"])
    result = repo.update_buyer(id, loads(buyer_json))  
   
    if result == True: 
        return JSONResponse(content={"message": 
         "update buyer successful"}, status_code=201) 
    else: 
        return JSONResponse(content={"message": 
         "update buyer unsuccessful"}, status_code=500)
<strong class="bold">@router.post("/buyer/history/add")</strong>
def add_purchase_history(id:int, req:PurchaseHistoryReq, 
           <strong class="bold">db=Depends(create_db_collections)</strong>): 
    history_dict = req.dict(exclude_unset=True)
    history_json = dumps(history_dict, 
           <strong class="bold">default=json_serialize</strong>_date)
    repo:BuyerRepository = BuyerRepository(db["buyers"])
    result = repo.add_purchase_history(id, 
           loads(history_json))  </pre>
			<p>The <strong class="source-inline">json_serialize_date()</strong> function<a id="_idIndexMarker458"/> becomes part of the JSON serialization process of the <strong class="source-inline">dumps()</strong> method but only handles the temporal type conversion while transforming the <strong class="source-inline">buyer</strong> details into JSON objects. It is applied in the <em class="italic">INSERT</em> and <em class="italic">UPDATE</em> transactions of the repository class to extract the serialized JSON string equivalent of the <strong class="source-inline">BuyerReq</strong>, <strong class="source-inline">PurchaseHistoryReq</strong>, and <strong class="source-inline">PurchaseStatusReq</strong> models. </p>
			<p>Now, another custom converter is applied in the data retrievals of the <strong class="source-inline">list_all_buyer()</strong> and <strong class="source-inline">get_buyer()</strong> methods:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/buyer/list/all")</strong>
def list_all_buyer(<strong class="bold">db=Depends(create_db_collections)</strong>): 
  repo:BuyerRepository = BuyerRepository(db["buyers"])
  buyers = repo.get_all_buyer() 
  return loads(dumps(buyers, <strong class="bold">default=json_serialize_oid</strong>))
<strong class="bold">@router.get("/buyer/get/{id}")</strong>
def get_buyer(id:int, <strong class="bold">db=Depends(create_db_collections)</strong>): 
  repo:BuyerRepository = BuyerRepository(db["buyers"])
  buyer = repo.get_buyer(id)
  return loads(dumps(buyer, <strong class="bold">default=json_serialize_oid</strong>))</pre>
			<p>The data <a id="_idIndexMarker459"/>models involved in our query transactions are data classes, so the results of the two preceding query methods have already been mapped and transformed into JSON format. However, unfortunately, they’re not JSON-able enough for the FastAPI framework. Aside from BSON <strong class="source-inline">datetime</strong> types, the PyMongo ODM cannot automatically convert <strong class="source-inline">ObjectId</strong> into a default type in Python, thus throwing <strong class="source-inline">ValueError</strong> during data retrieval from MongoDB. To fix this problem, <strong class="source-inline">dumps()</strong>needs a custom serializer, such as <strong class="source-inline">json_serialize_oid()</strong>, to convert all <strong class="source-inline">ObjectId</strong> parameters in MongoDB into FastAPI transitions. It also converts BSON <strong class="source-inline">datetime</strong> values into Python <strong class="source-inline">date</strong> values following the <em class="italic">ISO-8601</em> format. The valid JSON string from <strong class="source-inline">dumps()</strong> will enable the <strong class="source-inline">loads()</strong> method to produce a JSON-able result for the FastAPI services. The complete API services can be found in the <strong class="source-inline">/api/buyer.py</strong> script file.</p>
			<p>After complying with all the<a id="_idIndexMarker460"/> requirements, PyMongo can help store and manage all the information using the MongoDB server. However, the driver only works for synchronous CRUD transactions. If we opt for an asynchronous way of implementing CRUD, we must always resort to the Motor driver.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor164"/>Creating async CRUD transactions using Motor</h1>
			<p>Motor is an asynchronous driver that relies <a id="_idIndexMarker461"/>on the AsyncIO environment of the FastAPI. It wraps PyMongo to produce non-blocking and coroutine-based classes<a id="_idIndexMarker462"/> and methods needed to create asynchronous repository layers. It is almost like PyMongo when it comes to <a id="_idIndexMarker463"/>most of the requirements except for the database connectivity and repository implementation.</p>
			<p>But before we proceed, we need to install the <strong class="source-inline">motor</strong> extension using the following <strong class="source-inline">pip</strong> command:</p>
			<p class="source-code">pip install motor</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor165"/>Setting up the database connectivity</h2>
			<p>Using the <strong class="source-inline">AsyncIO</strong> platform <a id="_idIndexMarker464"/>of the FastAPI, the Motor driver opens a connection to the MongoDB database through its <strong class="source-inline">AsyncIOMotorClient</strong> class. When instantiated, the default connection credential is always <strong class="source-inline">localhost</strong> at port <strong class="source-inline">27017</strong>. Alternatively, we can specify the new details in <strong class="source-inline">str</strong> format through its constructor. The following script shows how to create a global <strong class="source-inline">AsyncIOMotorClient</strong> reference with the specified database credentials:</p>
			<pre class="source-code">
<strong class="bold">from motor.motor_asyncio import AsyncIOMotorClient</strong>
def create_async_db():
    <strong class="bold">global client</strong>
    <strong class="bold">client = AsyncIOMotorClient(str("localhost:27017"))</strong>
def create_db_collections():
    db = client.obrs
    buyers = db["buyer"]
    users = db["login"]
    return {"users": users, "buyers": buyers}
def close_async_db(): 
    client.close()</pre>
			<p>The format of the database URI is a string with a colon (<strong class="source-inline">:</strong>) in between the details. Now, the application needs the<a id="_idIndexMarker465"/> following Motor methods to start the database transactions: </p>
			<ul>
				<li><strong class="source-inline">create_async_db()</strong>: A method for establishing the database connection and loading schema definitions</li>
				<li><strong class="source-inline">close_async_db()</strong>: A method for closing the connection</li>
			</ul>
			<p><strong class="source-inline">APIRouter</strong> will require event handlers to manage these two core methods as application-level events. Later, we will register <strong class="source-inline">create_async_db()</strong> as a startup event and <strong class="source-inline">close_async_db()</strong> as a shutdown event. On the other hand, the <strong class="source-inline">create_db_collections()</strong> method creates some references to the <strong class="source-inline">login</strong> and <strong class="source-inline">buyer</strong> collections, which will be needed by the repository transactions later. </p>
			<p>In general, creating<a id="_idIndexMarker466"/> the database connection and getting the reference to the document collections do not require the <strong class="source-inline">async/await</strong> expression since no I/O is involved in the process. These methods can be found in the <strong class="source-inline">/db_config/motor_config.py</strong> script file. It is time now to create Motor's repository layer.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor166"/>Creating the model layer</h2>
			<p>PyMongo and Motor share the <a id="_idIndexMarker467"/>same approaches in creating both the request and data models. All base models, data classes, validators, and serializers used by PyMongo also apply to Motor connectivity.</p>
			<h3>Building the asynchronous repository layer</h3>
			<p>When it comes to the<a id="_idIndexMarker468"/> CRUD implementation, both PyMongo and Motor have some slight differences in the syntax but a considerable difference in the performance of each transaction. Their helper methods for inserting, updating, and deleting documents, including the necessary method parameters, are all the same, except that Motor has the non-blocking versions. Invoking the non-blocking Motor methods inside the repository requires an async/await expression. Here is an asynchronous version of PyMongo’s <strong class="source-inline">BuyerRepository</strong>:</p>
			<pre class="source-code">
class BuyerRepository: 
    
    def __init__(self, buyers): 
        self.buyers = buyers
    
    <strong class="bold">async</strong> def insert_buyer(self, users, 
           details:Dict[str, Any]) -&gt; bool: 
        try:
           user = await users.find_one({"_id": 
                details["user_id"]})
           … … … … …
           else: 
               <strong class="bold">await self.buyers.insert_one(details)</strong>
           … … … … …
        return True
    
    <strong class="bold">async</strong> def add_purchase_history(self, id:int, 
            details:Dict[str, Any]): 
        try:
            … … … … …
            <strong class="bold">await self.buyers.update_one({"buyer_id": id},</strong>
                   <strong class="bold">{"$set":{"purchase_history": </strong>
                     <strong class="bold">buyer["purchase_history"]}})</strong>
            … … … … …
        return True</pre>
			<p><strong class="source-inline">insert_buyer()</strong> in the <a id="_idIndexMarker469"/>preceding code block is defined as <strong class="source-inline">async</strong> because <strong class="source-inline">insert_one()</strong> is a non-blocking operation that requires an <strong class="source-inline">await</strong> invocation. The same goes for <strong class="source-inline">add_purchase_history()</strong>, which updates the <strong class="source-inline">purchase_history</strong> embedded documents using the non-blocking <strong class="source-inline">update_one()</strong>:</p>
			<pre class="source-code">
    <strong class="bold">async</strong> def get_all_buyer(self):
        <strong class="bold">cursor = self.buyers.find()</strong>
        buyers = [asdict(Buyer(**json.loads(dumps(b)))) 
           for b in <strong class="bold">await cursor.to_list(length=None)</strong>]
        return buyers
    
    <strong class="bold">async</strong> def get_buyer(self, id:int): 
        buyer = <strong class="bold">await self.buyers.find_one(</strong>
                    <strong class="bold">{"buyer_id": id})</strong>
        return asdict(Buyer(**json.loads(dumps(buyer))))</pre>
			<p>The <strong class="source-inline">delete_many()</strong> and <strong class="source-inline">find_one()</strong> operations are also invoked through an <strong class="source-inline">await</strong> expression. However, <strong class="source-inline">find()</strong> in Motor is not asynchronous and behaves differently than it does with PyMongo. The reason is that <strong class="source-inline">find()</strong> is not an I/O operation in Motor, and it returns an <strong class="source-inline">AsyncIOMotorCursor</strong> or asynchronous cursor, an iterable type that <a id="_idIndexMarker470"/>contains all the BSON documents. We apply <strong class="source-inline">async</strong> to the cursor when retrieving all its stored documents. The <strong class="source-inline">get_all_buyer()</strong> transaction in the preceding code shows how we call the <strong class="source-inline">find()</strong> operation and invoke the cursor to extract the necessary documents for JSON transformation. This repository class can be found in the <strong class="source-inline">/repository/motor/buyer.py</strong> script file. Let us now apply these CRUD transactions to our API services.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor167"/>Running the CRUD transactions</h2>
			<p>For the repository to work <a id="_idIndexMarker471"/>with <strong class="source-inline">APIRouter</strong>, we need to create two event handlers to manage the database connection and document collection retrieval. The first event, which is the startup event that the Uvicorn server executes before the application runs, should trigger the <strong class="source-inline">create_async_db()</strong> method’s execution to instantiate <strong class="source-inline">AsyncIOMotorClient</strong> and make references to the collections. The second event, which is the shutdown event, runs when the Uvicorn server is shutting down and should trigger the <strong class="source-inline">close_async_db()</strong> execution to close the connection. <strong class="source-inline">APIRouter</strong> has an <strong class="source-inline">add_event_handler()</strong> method to create these two event handlers. The following is a portion of the <strong class="source-inline">APIRouter</strong> script that shows how to prepare the database connection for the <strong class="source-inline">BuyerRepository</strong> transactions:</p>
			<pre class="source-code">
… … … … … …
<strong class="bold">from db_config.motor_config import create_async_db,</strong>
  <strong class="bold">create_db_collections, close_async_db</strong>
… … … … … …
router = APIRouter()
<strong class="bold">router.add_event_handler("startup", </strong>
            <strong class="bold">create_async_db)</strong>
<strong class="bold">router.add_event_handler("shutdown", </strong>
            <strong class="bold">close_async_db)</strong></pre>
			<p>The <strong class="source-inline">"startup"</strong> and <strong class="source-inline">"shutdown"</strong> values are pre-built configuration values and not just any arbitrary string values <a id="_idIndexMarker472"/>used to indicate the type of event handlers. We will discuss these event handlers in more detail in <a href="B17975_08.xhtml#_idTextAnchor229"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Coroutines, Events, and Message-Driven Transactions</em>. </p>
			<p>After setting these events handlers, the API services can now invoke the repository transactions asynchronously using an await/async expression. The validations and serialization utilities that are applied in PyMongo can also be utilized here in this version of <strong class="source-inline">BuyerRepository</strong>. The collections will be available to the API services upon injecting <strong class="source-inline">create_db_collections()</strong> into the API services. The <strong class="source-inline">add_buyer()</strong> API service showcases the implementation of an asynchronous REST transaction using the Motor driver:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/buyer/async/add")</strong>
<strong class="bold">async</strong> def add_buyer(req: BuyerReq, 
          <strong class="bold">db=Depends(create_db_collections)</strong>): 
    buyer_dict = req.dict(exclude_unset=True)
    buyer_json = dumps(buyer_dict, 
              default=json_serialize_date)
    repo:BuyerRepository = BuyerRepository(db["buyers"])
   
    result = <strong class="bold">await repo.insert_buyer(db["users"],</strong> 
                  <strong class="bold">loads(buyer_json))  </strong>
    if result == True: 
        return JSONResponse(content={"message":
            "add buyer successful"}, status_code=201) 
    else: 
        return JSONResponse(content={"message": 
            "add buyer unsuccessful"}, status_code=500)</pre>
			<p>Using PyMongo and Mongo drivers provides a minimal and exhaustive implementation of the MongoDB transactions. The core implementation of every CRUD transaction varies from one developer to another, and the approaches that are used to scrutinize and analyze the processes<a id="_idIndexMarker473"/> involved are managed in different ways. Also, there are no established standards for defining the document fields, such as <em class="italic">data uniqueness</em>, <em class="italic">the length of the field value</em>, <em class="italic">the value range</em>, and even the idea of adding a <em class="italic">unique ID</em>. To address these issues surrounding PyMongo and Motor, let us explore other ways of opening a connection to MongoDB to create <a id="_idIndexMarker474"/>CRUD transactions, such as using an <strong class="bold">ODM</strong>.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor168"/>Implementing CRUD transactions using MongoEngine</h1>
			<p>MongoEngine is an ODM that uses <a id="_idIndexMarker475"/>PyMongo to create an easy-to-use framework that can assist in managing MongoDB documents. It offers API <a id="_idIndexMarker476"/>classes that can help generate model classes using its field types and attribute metadata. It provides a declarative way of creating and structuring the embedded documents. </p>
			<p>Before we explore this ODM, we need to install it using the following <strong class="source-inline">pip</strong> command:</p>
			<p class="source-code">pip install mongoengine</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor169"/>Establishing database connection</h2>
			<p>MongoEngine has one<a id="_idIndexMarker477"/> of the most straightforward ways to establish a connection. Its <strong class="source-inline">mongoengine</strong> module has a <strong class="source-inline">connect()</strong> helper method that connects to the MongoDB database when it’s given the appropriate database connections. Our application must have a generator method to create a reference to the database connection and close this created connection after the transactions expire. The following script showcases the MongoEngine database connectivity:</p>
			<pre class="source-code">
<strong class="bold">from mongoengine import connect</strong>
def <strong class="bold">create_db</strong>():
    try:
        <strong class="bold">db = connect(db="obrs", host="localhost", </strong>
                 <strong class="bold">port=27017)</strong>
        yield db
    finally: 
        <strong class="bold">db.close()</strong></pre>
			<p>The <strong class="source-inline">connect()</strong> method <a id="_idIndexMarker478"/>has a mandatory first parameter, named <strong class="source-inline">db</strong>, which indicates the name of the database. The remaining parameters refer to the other remaining details of the database connection, such as <strong class="source-inline">host</strong>, <strong class="source-inline">port</strong>, <strong class="source-inline">username</strong>, and <strong class="source-inline">password</strong>. This configuration can be found in the <strong class="source-inline">/db_config/mongoengine_config.py</strong> script file. Let us now create data models for our MongoEngine repository.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor170"/>Building the model layer</h2>
			<p>MongoEngine provides a<a id="_idIndexMarker479"/> convenient and declarative way of mapping BSON documents to the model classes through its <strong class="source-inline">Document</strong> API class. A model class must subclass <strong class="source-inline">Document</strong> to inherit the structure and properties of a qualified and valid MongoDB document. The following is a <strong class="source-inline">Login</strong> definition that’s been created using the <strong class="source-inline">Document</strong> API class:</p>
			<pre class="source-code">
<strong class="bold">from mongoengine import Document, StringField, </strong>
         <strong class="bold">SequenceField, EmbeddedDocumentField</strong>
import json
class <strong class="bold">Login(Document)</strong>: 
    id = <strong class="bold">SequenceField</strong>(required=True, primary_key=True)
    username = <strong class="bold">StringField</strong>(db_field="username", 
         max_length=50, required=True, unique=True)
    password = <strong class="bold">StringField</strong>(db_field="password", 
         max_length=50, required=True)
    profile = <strong class="bold">EmbeddedDocumentField</strong>(UserProfile, 
         required=False)
    
    def <strong class="bold">to_json</strong>(self):
            return {
            <strong class="bold">"id": self.id</strong>,
            <strong class="bold">"username": self.username</strong>,
            <strong class="bold">"password": self.password</strong>,
            <strong class="bold">"profile": self.profile</strong>
        }
        
    @classmethod
    def <strong class="bold">from_json</strong>(cls, json_str):
        <strong class="bold">json_dict = json.loads(json_str)</strong>
        return <strong class="bold">cls(**json_dict)</strong></pre>
			<p>Unlike PyMongo and the Motor drivers, MongoEngine can define class attributes using its <strong class="source-inline">Field</strong> classes and their properties. Some of its <strong class="source-inline">Field</strong> classes include <strong class="source-inline">StringField</strong>, <strong class="source-inline">IntField</strong>, <strong class="source-inline">FloatField</strong>, <strong class="source-inline">BooleanField</strong>, and <strong class="source-inline">DateField</strong>. These can declare the <strong class="source-inline">str</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">bool</strong>, and <strong class="source-inline">datetime.date</strong> class attributes, respectively. </p>
			<p>Another convenient<a id="_idIndexMarker480"/> feature that this ODM has is that it can create <strong class="source-inline">SequenceField</strong>, which behaves the same as the <strong class="source-inline">auto_increment</strong> column field in a relational database or <strong class="source-inline">Sequence</strong> in an object-relational database. The <strong class="source-inline">id</strong> field of a model class should be declared as <strong class="source-inline">SequenceField</strong> so that it serves as the primary key of the document. Like in a typical sequence, this field has utilities to increment its value or reset it to zero, depending on what document record must be accessed. </p>
			<p>Other than the field types, field classes can also provide field arguments to attributes such as <strong class="source-inline">choices</strong>, <strong class="source-inline">required</strong>, <strong class="source-inline">unique</strong>, <strong class="source-inline">min_value</strong>, <strong class="source-inline">max_value</strong>, <strong class="source-inline">max_length</strong>, and <strong class="source-inline">min_length</strong> to give constraints to the field values. The <strong class="source-inline">choices</strong> parameter, for instance, accepts an iterable of string values that will serve as an enumeration. The <strong class="source-inline">required</strong> parameter indicates whether the field always needs a field value, while the <strong class="source-inline">unique</strong> parameter means the field value has no duplicates in the collection. Violating the <strong class="source-inline">unique</strong> parameter will lead to the following error message:</p>
			<p class="source-code">Tried to save duplicate unique keys (E11000 duplicate key error collection: obrs.login index: username_...)</p>
			<p><strong class="source-inline">min_value</strong> and <strong class="source-inline">max_value</strong>, on the other hand, indicate the minimum and maximum values for the numeric fields, respectively. <strong class="source-inline">min_length</strong> specifies the minimum length of a string value, while <strong class="source-inline">max_length</strong> sets the maximum string length. The <strong class="source-inline">db_field</strong> parameter, on the other hand, can also be applied when specifying another document field name instead of the class attribute name. The given <strong class="source-inline">Login</strong> class also has <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> fields defined to hold string values, an id primary key defined as <strong class="source-inline">SequenceField</strong>, and an embedded document field to establish document association.</p>
			<h3>Creating document association</h3>
			<p>The <strong class="source-inline">profile</strong> field <a id="_idIndexMarker481"/>of <strong class="source-inline">Login</strong> creates a one-to-one association between the <strong class="source-inline">Login</strong> document and <strong class="source-inline">UserProfile</strong>. But before the association can work, we need to define the <strong class="source-inline">profile</strong> field as being of the <strong class="source-inline">EmbeddedDocumentField</strong> type and <strong class="source-inline">UserProfile</strong> as being of the <strong class="source-inline">EmbeddedDocument</strong> type. The<a id="_idIndexMarker482"/> following is the complete blueprint of <strong class="source-inline">UserProfile</strong>: </p>
			<pre class="source-code">
class <strong class="bold">UserProfile(EmbeddedDocument)</strong>:
   firstname = StringField(db_field="firstname", 
          max_length=50, required=True)
   lastname = StringField(db_field="lastname", 
          max_length=50, required=True)
   middlename = StringField(db_field="middlename", 
          max_length=50, required=True)
   position = StringField(db_field="position", 
          max_length=50, required=True)
   date_approved = DateField(db_field="date_approved", 
          required=True)
   status = BooleanField(db_field="status", required=True)
   level = IntField(db_field="level", required=True)
   login_id = IntField(db_field="login_id", required=True)
   booksale = EmbeddedDocumentListField(BookForSale, 
           required=False)
   
   def to_json(self):
            return {
            "firstname": self.firstname,
            "lastname": self.lastname,
            "middlename": self.middlename,
            "position": self.position,
            "date_approved": 
               self.date_approved.strftime("%m/%d/%Y"),
            "status": self.status,
            "level": self.level,
            "login_id": self.login_id,
            "books": self.books
        }
        
   @classmethod
   def from_json(cls, json_str):
        json_dict = json.loads(json_str)
        return cls(**json_dict)</pre>
			<p>The <strong class="source-inline">EmbeddedDocument</strong> API is a <strong class="source-inline">Document</strong> without an <strong class="source-inline">id</strong> and has no collection of its own. Subclasses of this API are model classes that have been created to be part of a core document structure, such as <strong class="source-inline">UserProfile</strong> being part of the <strong class="source-inline">Login</strong> details. Now, the field that refers to this document has a <strong class="source-inline">required</strong> property set to <strong class="source-inline">False</strong> since an embedded document can’t be present at all times.</p>
			<p>On the other hand, a field <a id="_idIndexMarker483"/>declared as <strong class="source-inline">EmbeddedDocumentList</strong> is used to create a many-to-one association between documents. The preceding <strong class="source-inline">UserProfile</strong> class is strongly connected to a list of <strong class="source-inline">BookForSale</strong> embedded documents because of its declared <strong class="source-inline">booksale</strong> field. Again, the field type should always set its <strong class="source-inline">required</strong> property to <strong class="source-inline">False</strong> to avoid problems when dealing with empty values.</p>
			<h3>Applying custom serialization and deserialization</h3>
			<p>There are no built-in hooks for validation and serialization <a id="_idIndexMarker484"/>in this ODM. Every model class in the <em class="italic">online book reselling</em> application has implemented a <strong class="source-inline">from_json()</strong> class method that converts JSON details into a valid <strong class="source-inline">Document</strong> instance. When converting the BSON document into a JSON object, model classes must have the custom <strong class="source-inline">to_json()</strong> instance method, which builds the JSON structure and automatically transforms the BSON <strong class="source-inline">datetime</strong> into JSON-able <strong class="source-inline">date</strong> objects through formatting. Let us now create the repository layer using the model classes.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor171"/>Implementing the CRUD transactions</h2>
			<p>MongoEngine<a id="_idIndexMarker485"/> provides the most convenient and straightforward approach to building the repository layer for the application. All its operations come from the <strong class="source-inline">Document</strong> model class and they are easy to use. <strong class="source-inline">LoginRepository</strong> uses the ODM to implement its CRUD transactions:</p>
			<pre class="source-code">
from typing import Dict, Any
<strong class="bold">from models.data.mongoengine import Login</strong>
class LoginRepository: 
     
    def <strong class="bold">insert_login</strong>(self, details:Dict[str, Any]) -&gt; bool: 
        try:
            login = Login(**details)
            <strong class="bold">login.save()</strong>
        except Exception as e:
            print(e)
            return False 
        return True
    
    def <strong class="bold">update_password</strong>(self, id:int, newpass:str) -&gt; bool: 
       try:
          login = Login.objects(id=id).get()
          <strong class="bold">login.update(password=newpass)</strong>
       except: 
           return False 
       return True
   
    def <strong class="bold">delete_login</strong>(self, id:int) -&gt; bool: 
        try:
            login = Login.objects(id=id).get()
            <strong class="bold">login.delete()</strong>
        except: 
            return False 
        return True</pre>
			<p>It only takes two lines for the <strong class="source-inline">insert_login()</strong> method to save the <strong class="source-inline">Login</strong> document. After creating the <strong class="source-inline">Login</strong> instance with the necessary document details, we simply call the <strong class="source-inline">save()</strong> method of the <strong class="source-inline">Document</strong> instance to pursue the insert transaction. When it comes to modifying some document values, the <strong class="source-inline">Document</strong> API class has an <strong class="source-inline">update()</strong> method that manages changes in state for every class attribute. But first, we need to find the document using the <strong class="source-inline">objects()</strong> utility method, which retrieves document structures <a id="_idIndexMarker486"/>from the collection. This <strong class="source-inline">objects()</strong> method can fetch a document by providing its parameter with an <strong class="source-inline">id</strong> field value or extracting a list of document records by supplying the method with a generic search expression. The instance of the retrieved document must invoke its <strong class="source-inline">update()</strong> method to pursue the modification of some, if not all, of its field values. The given <strong class="source-inline">update_password()</strong> method updates the password field of <strong class="source-inline">Login</strong>, which gives us a good template regarding how to pursue update operations on other field attributes.   </p>
			<p>On the other hand, <strong class="source-inline">delete_login()</strong> shows how to delete a <strong class="source-inline">Login</strong> document from its collection after it searches for the object using a simple call to the instance’s <strong class="source-inline">delete()</strong> method. The following script shows how to perform query transactions in MongoEngine:</p>
			<pre class="source-code">
    def <strong class="bold">get_all_login</strong>(self):
        <strong class="bold">login = Login.objects()</strong>
        <strong class="bold">login_list = [l.to_json() for l in login]</strong>
        return login_list
    
    def get_login(self, id:int): 
        <strong class="bold">login = Login.objects(id=id).get()</strong>
        return <strong class="bold">login.to_json()</strong></pre>
			<p>The only way to perform single- or multiple-document retrieval is to utilize the <strong class="source-inline">objects()</strong> method. There is no need to implement JSON converters for the query results because every <strong class="source-inline">Document</strong> model class has a <strong class="source-inline">to_json()</strong> method to provide the JSON-able equivalent of the instance. The given <strong class="source-inline">get_all_login()</strong> transaction uses list comprehension to create a list of JSON documents from the result of <strong class="source-inline">objects()</strong>, while the <strong class="source-inline">get_login()</strong> method invokes <strong class="source-inline">to_json()</strong> after extracting a single document.</p>
			<h3>Managing the embedded documents</h3>
			<p>It is easier to implement<a id="_idIndexMarker487"/> document associations with an ODM than the core PyMongo and Motor database drivers. Since the operations of MongoEngine are comfortable to use, it takes only a few lines to manage the embedded documents. In the following <strong class="source-inline">UserProfileRepository</strong> script, <strong class="source-inline">insert_profile()</strong> shows how adding a <strong class="source-inline">UserProfile</strong> detail to the <strong class="source-inline">Login</strong> document can be done<a id="_idIndexMarker488"/> by performing a simple object search and an <strong class="source-inline">update()</strong> call:</p>
			<pre class="source-code">
from typing import Dict, Any
<strong class="bold">from models.data.mongoengine import Login, UserProfile, </strong>
      <strong class="bold">BookForSale</strong>
class UserProfileRepository(): 
    
    def <strong class="bold">insert_profile</strong>(self, login_id:int, 
             details:Dict[str, Any]) -&gt; bool: 
        try:
            profile = UserProfile(**details)
            login = Login.objects(id=login_id).get()
            <strong class="bold">login.update(profile=profile)</strong>
        except Exception as e:
            print(e)
            return False 
        return True
    
    def add_book_sale(self, login_id:int, 
             details:Dict[str, Any]): 
        try:
            sale = BookForSale(**details)
            <strong class="bold">login = Login.objects(id=login_id).get()</strong>
            <strong class="bold">login.profile.booksale.append(sale)         </strong>
            <strong class="bold">login.update(profile=login.profile)</strong>
        except Exception as e:
            print(e)
            return False 
        return True</pre>
			<p>Likewise, the given <strong class="source-inline">add_book_sale()</strong> transaction creates a many-to-one association between <strong class="source-inline">BookForSale</strong> and <strong class="source-inline">UserProfile</strong> using the same approach applied in <strong class="source-inline">insert_profile() </strong>with an additional List's <strong class="source-inline">append()</strong> operation.</p>
			<p>Querying the embedded documents is also feasible in MongoEngine. The ODM has a <strong class="source-inline">filter()</strong> method that uses <em class="italic">field lookup syntax</em> to refer to a specific document structure or list of embedded documents. This field lookup syntax consists of the <em class="italic">field name of the embedded document</em>, followed by a <em class="italic">double underscore</em> in place of the dot in the usual object attribute <a id="_idIndexMarker489"/>access syntax. Then, it has <em class="italic">another double underscore</em> to cater to some <em class="italic">operators</em>, such as <strong class="source-inline">lt</strong>, <strong class="source-inline">gt</strong>, <strong class="source-inline">eq</strong>, and <strong class="source-inline">exists</strong>. In the following code, <strong class="source-inline">get_all_profile()</strong>uses the <strong class="source-inline">profile__login_id__exists=True</strong> field lookup to filter all <strong class="source-inline">user_profile</strong> embedded documents that have valid <strong class="source-inline">login</strong> structures. However, the <strong class="source-inline">get_profile()</strong> transaction does not need to use <strong class="source-inline">filter()</strong> and field lookups because it can simply access the specific login docu<a id="_idTextAnchor172"/>ment to fetch its profile details:</p>
			<pre class="source-code">
     def <strong class="bold">get_all_profile</strong>(self):
        profiles = Login.objects.filter(
               <strong class="bold">profile__login_id__exists=True</strong>)
        profiles_dict = list(
              map(lambda h: h.profile.to_json(), 
                Login.objects().filter(
                    <strong class="bold">profile__login_id__exists=True</strong>)))
        return profiles_dict
    
    def get_profile(self, login_id:int): 
        <strong class="bold">login = Login.objects(id=login_id).get()</strong>
        profile = <strong class="bold">login.profile.to_json()</strong>
        return profile</pre>
			<p>The preceding query transactions <a id="_idIndexMarker490"/>are just simple implementations compared to some other complex MongoEngine queries, which involve complicated embedded document structures that require complex field lookup syntax. Let us now apply the CRUD transactions to our API services.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor173"/>Running the CRUD transactions</h2>
			<p>CRUD will not work without passing our <strong class="source-inline">create_db()</strong> method to the <em class="italic">startup</em> event and <strong class="source-inline">disconnect_db()</strong> to the <em class="italic">shutdown</em> event. The former will open the MongoDB connection during the<a id="_idIndexMarker491"/> Uvicorn startup, while the latter will close it during server shutdown.</p>
			<p>The following script shows the application’s <strong class="source-inline">profile</strong> router with a <strong class="source-inline">create_profile()</strong> REST service that asks clients for a profile detail, given a specific login record, and pursues the insert transaction using <strong class="source-inline">UserProfileRepository</strong>: </p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
from fastapi.responses import JSONResponse
from models.request.profile import UserProfileReq, 
         BookForSaleReq
<strong class="bold">from repository.mongoengine.profile import </strong>
         <strong class="bold">UserProfileRepository</strong>
<strong class="bold">from db_config.mongoengine_config import create_db</strong>
router = APIRouter()
<strong class="bold">@router.post("/profile/login/add", </strong>
      <strong class="bold">dependencies=[Depends(create_db)]</strong>)
def create_profile(login_id:int, req:UserProfileReq): 
    profile_dict = req.dict(exclude_unset=True)
    repo:UserProfileRepository = UserProfileRepository()
    result = repo.insert_profile(login_id, profile_dict)
    if result == True: 
        return req 
    else: 
        return JSONResponse(content={"message": 
          "insert profile unsuccessful"}, status_code=500) </pre>
			<p><strong class="source-inline">create_profile()</strong> is a standard API service that deals with MongoEngine’s synchronous <strong class="source-inline">insert_profile()</strong> transaction. When it comes to asynchronous REST services, it is not advisable to <a id="_idIndexMarker492"/>use MongoEngine because its platform only works with synchronous ones. In the next section, we will discuss an ODM that’s popular in building an asynchronous repository layer.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor174"/>Implementing async transactions using Beanie</h1>
			<p><strong class="bold">Beanie</strong> is a non-boilerplate mapper that utilizes the core features of Motor and Pydantic. This ODM offers a more<a id="_idIndexMarker493"/> straightforward <a id="_idIndexMarker494"/>approach to implementing asynchronous CRUD transactions than its precursor, the Motor driver.</p>
			<p>To use Beanie, we need to install it using the following <strong class="source-inline">pip</strong> command:</p>
			<p class="source-code">pip install beanie</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Installing Beanie may uninstall the current version of your Motor module because it sometimes requires lower version of Motor module. Pursuing this will produce errors in your existing Motor transactions.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor175"/>Creating the database connection</h2>
			<p>Beanie uses the Motor driver to open a <a id="_idIndexMarker495"/>database connection to MongoDB. Instantiating the Motor’s <strong class="source-inline">AsyncIOMotorClient</strong> class with the database URL is the first step of configuring it. But what makes Beanie unique compared to other ODMs is how it pre-initializes and pre-recognizes the model classes that will be involved in a CRUD transaction. The ODM has an asynchronous <strong class="source-inline">init_beanie()</strong> helper method that initiates the model class initialization using the database name. Calling this method will also set up the collection-domain mapping, where all the model classes are registered in the <strong class="source-inline">document_models</strong> parameter of <strong class="source-inline">init_beanie()</strong>. The following script shows the database configuration that’s required to access our MongoDB database, <strong class="source-inline">obrs</strong>:</p>
			<pre class="source-code">
from motor.motor_asyncio import AsyncIOMotorClient
from beanie import init_beanie
from models.data.beanie import Cart, Order, Receipt
async def db_connect():
    global client
    <strong class="bold">client = </strong>
     <strong class="bold">AsyncIOMotorClient(f"mongodb://localhost:27017/obrs")</strong>
    <strong class="bold">await init_beanie(client.obrs, </strong>
         <strong class="bold">document_models=[Cart, Order, Receipt])</strong>
    
async def db_disconnect():
     <strong class="bold">client.close()</strong></pre>
			<p>Here, <strong class="source-inline">db_connect()</strong> uses an async/await expression because its method invocation to <strong class="source-inline">init_beanie()</strong> is asynchronous. <strong class="source-inline">db_disconnect()</strong> will close the database connection by calling the <strong class="source-inline">close()</strong> method of the <strong class="source-inline">AsyncIOMotorClient</strong> instance. Both of these methods <a id="_idIndexMarker496"/>are executed as events, just like in MongoEngine. Their implementation can be found in the <strong class="source-inline">/db_config/beanie_config.py</strong> script file. Let us now create the model classes.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor176"/>Defining the model classes</h2>
			<p>The Beanie ODM has a <strong class="source-inline">Document</strong> API class that’s<a id="_idIndexMarker497"/> responsible for defining its model classes, mapping them to MongoDB collections, and handling repository transactions, just like in MongoEngine. Although there is no <strong class="source-inline">Field</strong> directive for defining class attributes, the ODM supports Pydantic’s validation and parsing rules and <strong class="source-inline">typing</strong> extension for declaring models and their attributes. But it also has built-in validation and encoding features, which can be used together with Pydantic. The following script shows how to define Beanie model classes while it’s being configured:</p>
			<pre class="source-code">
from typing import Optional, List
<strong class="bold">from beanie import Document</strong>
<strong class="bold">from bson import datetime </strong>
class <strong class="bold">Cart(Document)</strong>:
    id: int 
    book_id: int 
    user_id: int
    qty: int
    <strong class="bold">date_carted: datetime.datetime</strong>
    discount: float
 
    class <strong class="bold">Collection</strong>:
        name = "cart"
    … … … … … …
                
class <strong class="bold">Order(Document)</strong>:
    id: int 
    user_id: int
    <strong class="bold">date_ordered: datetime.datetime</strong>
    orders: List[Cart] = list()
        
    class <strong class="bold">Collection</strong>:
        name = "order"
    … … … … … …
        
class <strong class="bold">Receipt(Document)</strong>: 
    id: int 
    <strong class="bold">date_receipt: datetime.datetime </strong>
    total: float 
    payment_mode: int
    order: Optional[Order] = None
    
    class <strong class="bold">Collection</strong>:
        name = "receipt"
    class <strong class="bold">Settings</strong>:
        <strong class="bold">use_cache = True</strong>
        cache_expiration_time =    
             datetime.timedelta(seconds=10)
        cache_capacity = 10</pre>
			<p>The <strong class="source-inline">id</strong> attribute of the given <strong class="source-inline">Document</strong> classes automatically translates into an <strong class="source-inline">_id</strong> value. This serves as the primary key of the document. Beanie allows you to replace the default <strong class="source-inline">ObjectId</strong> type of <strong class="source-inline">_id</strong> with another type, such as <strong class="source-inline">int</strong>, which is not possible in other ODMs. And with Motor, this ODM <a id="_idIndexMarker498"/>needs custom JSON serializers because it has difficulty converting BSON <strong class="source-inline">datetime</strong> types into Python <strong class="source-inline">datetime.date</strong> types during CRUD transactions.</p>
			<p>A document in Beanie can be configured by adding the <strong class="source-inline">Collection</strong> and <strong class="source-inline">Settings</strong> nested classes. The <strong class="source-inline">Collection</strong> class can replace the default name of the collection where the model is supposed to be mapped. It can also provide indexes to document fields if needed. The <strong class="source-inline">Settings</strong> inner class, on the other hand, can override existing BSON encoders, apply caching, manage concurrent updates, and add validation when the document is being saved. These three model classes include the collection configuration in their definitions to replace the names of their respective collections with their class names.</p>
			<h3>Creating the document associations</h3>
			<p>Python syntax, Pydantic rules, and API <a id="_idIndexMarker499"/>classes are used to establish links between documents in this mapper. To create a one-to-one association between <strong class="source-inline">Order</strong> and <strong class="source-inline">Receipt</strong>, for instance, we only need to set an <strong class="source-inline">Order</strong> field attribute that will link to a single <strong class="source-inline">Receipt</strong> instance. For many-to-one associations, such as the relationship between <strong class="source-inline">Order</strong> and <strong class="source-inline">Cart</strong>, the <strong class="source-inline">Cart</strong> document should only need a list field that will contain all the <strong class="source-inline">Order</strong> embedded documents. </p>
			<p>However, the ODM has a <strong class="source-inline">Link</strong> type, which can be used to define class fields to generate these associations. Its CRUD operations, such as <strong class="source-inline">save()</strong>, <strong class="source-inline">insert()</strong>, and <strong class="source-inline">update()</strong>, strongly support these <strong class="source-inline">Link</strong> types, so long as the <strong class="source-inline">link_rule</strong> parameter is provided in their parameters. For query transactions, the <strong class="source-inline">find()</strong> method can include the <strong class="source-inline">Link</strong> documents during document fetching, given that its <strong class="source-inline">fetch_links</strong> parameter is set to <strong class="source-inline">True</strong>. Now, let us implement the repository layer using the model classes.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor177"/>Implementing the CRUD transactions</h2>
			<p>Implementing repositories with<a id="_idIndexMarker500"/> Beanie is similar to how it’s done with MongoEngine – that is, it uses short and direct CRUD syntax due to the convenient helper methods like create(), update(), and delete(), provided by the <strong class="source-inline">Document</strong> API class. However, the Beanie mapper creates an asynchronous repository layer because all the API methods that are inherited by the model classes are non-blocking. The following code for the <strong class="source-inline">CartRepository</strong> class shows a sample implementation of an asynchronous repository class using this Beanie ODM:</p>
			<pre class="source-code">
from typing import Dict, Any
<strong class="bold">from models.data.beanie import Cart</strong>
class <strong class="bold">CartRepository</strong>: 
    
    async def <strong class="bold">add_item</strong>(self, 
             details:Dict[str, Any]) -&gt; bool: 
        try:
            <strong class="bold">receipt = Cart(**details)</strong>
            <strong class="bold">await receipt.insert()</strong>
        except Exception as e:
            print(e)
            return False 
        return True
    
    async def <strong class="bold">update_qty</strong>(self, id:int, qty:int) -&gt; bool: 
       try:
          <strong class="bold">cart = await Cart.get(id)</strong>
          <strong class="bold">await cart.set({Cart.qty:qty})</strong>
       except: 
           return False 
       return True
    
    async def <strong class="bold">delete_item</strong>(self, id:int) -&gt; bool: 
        try:
            <strong class="bold">cart = await Cart.get(id)</strong>
            <strong class="bold">await cart.delete()</strong>
        except: 
            return False 
        return True</pre>
			<p>The <strong class="source-inline">add_item()</strong> method showcases the use of the asynchronous <strong class="source-inline">insert()</strong>method to persist a newly created <strong class="source-inline">Cart</strong> instance. The <strong class="source-inline">Document</strong> API also has a <strong class="source-inline">create()</strong> method that works like <strong class="source-inline">insert()</strong>. Another option is to use the <strong class="source-inline">insert_one()</strong> class method instead of the instance methods. Moreover, adding multiple documents is allowed in this ODM<a id="_idIndexMarker501"/> because an <strong class="source-inline">insert_many()</strong> operation exists to pursue that kind of insert.</p>
			<p>Updating a document can be initiated using two methods, namely <strong class="source-inline">set()</strong> and <strong class="source-inline">replace()</strong>.<strong class="source-inline">update_qty()</strong> in the preceding script chooses the <strong class="source-inline">set()</strong> operation to update the current <strong class="source-inline">qty</strong> value of the items placed in a cart. </p>
			<p>When it comes to document removal, the ODM only has the <strong class="source-inline">delete()</strong> method to pursue the transactions. This is present in the <strong class="source-inline">delete_item()</strong> transaction in the preceding code.</p>
			<p>Retrieving a single document or a list of documents using this ODM is easy. No further serialization and cursor wrapping is needed during its query operations. When fetching a single document structure, the mapper provides the <strong class="source-inline">get()</strong> method if the fetching process only requires the <strong class="source-inline">_id</strong> field; it provides <strong class="source-inline">find_one()</strong> when the fetching process requires a conditional expression. Moreover, Beanie has a <strong class="source-inline">find_all()</strong> method that fetches all the documents without constraints and the <strong class="source-inline">find()</strong> method for retrieving data with<a id="_idIndexMarker502"/> conditions. The following code shows the query transaction for retrieving cart items from the database:</p>
			<pre class="source-code">
async def get_cart_items(self):
        return await Cart.find_all().to_list()
    
    async def get_items_user(self, user_id:int): 
        return await Cart.find(
              Cart.user_id == user_id).to_list()
    
    async def get_item(self, id:int): 
        return await Cart.get(id)</pre>
			<p>Both the <strong class="source-inline">find()</strong> and <strong class="source-inline">find_all()</strong> operations are used in the methods to return a <strong class="source-inline">FindMany</strong> object that has a <strong class="source-inline">to_list()</strong> utility that returns a list of JSON-able documents. Let us now apply our CRUD transactions to the API services.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor178"/>Running the repository transactions</h2>
			<p>The <strong class="source-inline">CartRepository</strong> methods will <a id="_idIndexMarker503"/>only run successfully if <strong class="source-inline">db_connect()</strong> from the configuration file is injected into the router. Although injecting it into each API service is acceptable, our solution prefers injecting the component into <strong class="source-inline">APIRouter</strong> using <strong class="source-inline">Depends</strong>:</p>
			<pre class="source-code">
<strong class="bold">from repository.beanie.cart import CartRepository</strong>
<strong class="bold">from db_config.beanie_config import db_connect</strong>
router = APIRouter(<strong class="bold">dependencies=[Depends(db_connect)]</strong>)
<strong class="bold">@router.post("/cart/add/item")</strong>
<strong class="bold">async</strong> def add_cart_item(req:CartReq): 
    <strong class="bold">repo:CartRepository = CartRepository()</strong>
    result = <strong class="bold">await repo.add_item(loads(cart_json))</strong>
          "insert cart unsuccessful"}, status_code=500)</pre>
			<p>The asynchronous <strong class="source-inline">add_cart_item()</strong> service asynchronously inserts the cart account into the database using <strong class="source-inline">CartRepository</strong>. </p>
			<p>Another asynchronous <a id="_idIndexMarker504"/>mapper that can integrate perfectly with FastAPI is <em class="italic">ODMantic</em>.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor179"/>Building async repository for FastAPI using ODMantic</h1>
			<p>The dependencies<a id="_idIndexMarker505"/> of Beanie and ODMantic come from Motor and Pydantic. ODMantic also utilizes Motor’s <strong class="source-inline">AsyncIOMotorClient</strong> class to open <a id="_idIndexMarker506"/>a database connection. It also uses Pydantic features for class attribute validation, Python’s typing <a id="_idIndexMarker507"/>extension for type hinting, and other Python components for management. But its edge over Beanie is that it complies with ASGI frameworks such as FastAPI.</p>
			<p>To pursue ODMantic, we need to install the extension using the following <strong class="source-inline">pip</strong> command:</p>
			<p class="source-code">pip install odmantic</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor180"/>Creating the database connection</h2>
			<p>Setting up the database connectivity in ODMantic is the same as what we do with the Beanie mapper, except <a id="_idIndexMarker508"/>that the setup includes creating an engine that will handle all its CRUD operations. This engine is <strong class="source-inline">AIOEngine</strong> from the <strong class="source-inline">odmantic</strong> module, which requires both the motor client object and the database name to be created successfully. The following is a complete implementation of the database connectivity needed by the ODMantic mapper:</p>
			<pre class="source-code">
<strong class="bold">from odmantic import AIOEngine</strong>
<strong class="bold">from motor.motor_asyncio import AsyncIOMotorClient</strong>
def <strong class="bold">create_db_connection</strong>():
   global client_od
   client_od = 
     AsyncIOMotorClient(f"mongodb://localhost:27017/")
def <strong class="bold">create_db_engine</strong>():
   <strong class="bold">engine = AIOEngine(motor_client=client_od, </strong>
         <strong class="bold">database="obrs")</strong>
   return engine
def <strong class="bold">close_db_connection</strong>():
    client_od.close() </pre>
			<p>We need to create event <a id="_idIndexMarker509"/>handlers in <strong class="source-inline">APIRouter</strong> to run <strong class="source-inline">create_db_connection()</strong> and <strong class="source-inline">close_db_connection()</strong> for our repository transactions to work. Let us now implement the model layer of the ODM.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor181"/>Creating the model layer</h2>
			<p>ODMantic has a <strong class="source-inline">Model</strong> API class that provides properties to model classes when subclassed. It relies on Python types and BSON <a id="_idIndexMarker510"/>specifications to define the class attributes. When transforming field types, such as converting a BSON <strong class="source-inline">datetime</strong> value into a Python <strong class="source-inline">datetime.date</strong> value, the mapper allows you to add custom <strong class="source-inline">@validator</strong> methods into the model classes to implement the appropriate object serializer. Generally, ODMantic relies on the <strong class="source-inline">pydantic</strong> module when it comes to data validation, unlike in the Beanie mapper. The following is a standard ODMantic model class definition:</p>
			<pre class="source-code">
<strong class="bold">from odmantic import Model</strong>
<strong class="bold">from bson import datetime</strong>
class <strong class="bold">Purchase(Model)</strong>: 
    purchase_id: int
    buyer_id: int 
    book_id: int 
    items: int 
    price: float 
    <strong class="bold">date_purchased: datetime.datetime</strong>
    
    class <strong class="bold">Config</strong>:
        collection = "purchase"</pre>
			<p>For advanced configurations, we can<a id="_idIndexMarker511"/> add a nested <strong class="source-inline">Config</strong> class to the model class to set these additional options, such as the <strong class="source-inline">collection</strong> option, which replaces the default name of the collection with a custom one. We can also configure some familiar options, such as <strong class="source-inline">json_encoders</strong>, to convert one field type into another supported one.</p>
			<h3>Establishing document association</h3>
			<p>When creating <a id="_idIndexMarker512"/>associations, the typical Python approach of declaring fields so that they refer to an embedded document(s) is still applicable in this ODM. However, this ODM mapper has an <strong class="source-inline">EmbeddedModel</strong> API class to create a model with no <strong class="source-inline">_id</strong> field; this can be linked to another document. The <strong class="source-inline">Model</strong> classes, on the other hand, can define a field<a id="_idIndexMarker513"/> attribute that will refer to an <strong class="source-inline">EmbeddedModel</strong> class to establish a one-to-one association or a list of <strong class="source-inline">EmbeddedModel</strong> instances for a many-to-one association.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor182"/>Implementing the CRUD transactions</h2>
			<p>Creating the repository <a id="_idIndexMarker514"/>layer using ODMantic always requires the engine object that was created in the startup event. This is because all the CRUD operations that are needed will come from this engine. The following <strong class="source-inline">PurchaseRepository</strong> shows the operations from the <strong class="source-inline">AIOEngine</strong> object that we need to create CRUD transactions:</p>
			<pre class="source-code">
from typing import List, Dict, Any
from models.data.odmantic import Purchase
class PurchaseRepository: 
    
    def __init__(self, engine): 
        self.engine = engine
        
    async def insert_purchase(self, 
              details:Dict[str, Any]) -&gt; bool: 
        try:
           <strong class="bold">purchase = Purchase(**details)</strong>
           <strong class="bold">await self.engine.save(purchase)</strong>
                  
        except Exception as e:
            print(e)
            return False 
        return True</pre>
			<p>This <strong class="source-inline">insert_purchase()</strong> method shows the standard way to insert a record into the database using ODMantic. Through the engine’s <strong class="source-inline">save()</strong> method, we can persist one document at a time using the model class. <strong class="source-inline">AIOEngine</strong> also provides the <strong class="source-inline">save_all()</strong> method<a id="_idIndexMarker515"/> for inserting a list of multiple documents into the associated MongoDB collection. </p>
			<p>Now, there is no specific way to update transactions, but ODMantic allows you to fetch the record that needs to be updated. The following code can be used to update a record using ODMantic:</p>
			<pre class="source-code">
    async def update_purchase(self, id:int, 
              details:Dict[str, Any]) -&gt; bool: 
       try:
          <strong class="bold">purchase = await self.engine.find_one(</strong>
                <strong class="bold">Purchase, Purchase.purchase_id == id)</strong>
                  
          for key,value in details.items():
            setattr(purchase,key,value)
          
          <strong class="bold">await self.engine.save(purchase)</strong>
       except Exception as e:
           print(e) 
           return False 
       return True</pre>
			<p>After accessing and changing the field values, the fetched document object will be re-saved using the <strong class="source-inline">save()</strong> method to reflect the changes in physical storage. The complete process is implemented in the preceding <strong class="source-inline">update_purchase()</strong> transaction:</p>
			<pre class="source-code">
     async def delete_purchase(self, id:int) -&gt; bool: 
        try:
            <strong class="bold">purchase = await self.engine.find_one(</strong>
                <strong class="bold">Purchase, Purchase.purchase_id == id) </strong>
            <strong class="bold">await self.engine.delete(purchase)</strong>
        except: 
            return False 
        return True</pre>
			<p>When it comes to document<a id="_idIndexMarker516"/> removal, you must fetch the document to be deleted. We pass the fetched document object to the <strong class="source-inline">delete()</strong> method of the engine to pursue the removal process. This implementation is shown in the <strong class="source-inline">delete_purchase()</strong> method.</p>
			<p>When fetching a single document so that it can be updated or deleted, <strong class="source-inline">AIOEngine</strong> has a <strong class="source-inline">find_one()</strong> method that requires two arguments: the model class name and the conditional expression, which involves either the <strong class="source-inline">id</strong> primary key or some non-unique fields. All the fields can be accessed like class variables. The following <strong class="source-inline">get_purchase()</strong> method retrieves a <strong class="source-inline">Purchase</strong> document with the specified <strong class="source-inline">id</strong>:</p>
			<pre class="source-code">
    async def get_all_purchase(self):
        purchases = await self.engine.find(Purchase)
        return purchases
            
    async def get_purchase(self, id:int): 
        <strong class="bold">purchase = await self.engine.find_one(</strong>
            <strong class="bold">Purchase, Purchase.purchase_id == id) </strong>
        return purchase</pre>
			<p>The engine has a <strong class="source-inline">find()</strong> operation to retrieve all <strong class="source-inline">Purchase</strong> documents, for instance, from the database. It only<a id="_idIndexMarker517"/> needs an argument – the name of the model class. Let now apply our repository layer to the API services.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor183"/>Running the CRUD transaction</h2>
			<p>For the repository <a id="_idIndexMarker518"/>classes to run, all the router services must be asynchronous. Then, we need to create the startup and shutdown event handlers for <strong class="source-inline">create_db_connection()</strong> and <strong class="source-inline">close_db_connection()</strong>, respectively, to open the connection for repository transactions. Lastly, for the repository class to work, <strong class="source-inline">create_db_engine()</strong> must be injected into each API service to derive the engine object:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
from fastapi.responses import JSONResponse
from models.request.purchase import PurchaseReq
from repository.odmantic.purchase import PurchaseRepository
<strong class="bold">from db_config.odmantic_config import create_db_engine, </strong>
    <strong class="bold">create_db_connection, close_db_connection</strong>
from datetime import date, datetime
from json import dumps, loads
router = APIRouter()
router.add_event_handler("startup", <strong class="bold">create_db_connection</strong>)
router.add_event_handler("shutdown", <strong class="bold">close_db_connection</strong>)
<strong class="bold">@router.post("/purchase/add")</strong>
<strong class="bold">async</strong> def add_purchase(req: PurchaseReq, 
          <strong class="bold">engine=Depends(create_db_engine)</strong>): 
     purchase_dict = req.dict(exclude_unset=True) 
     purchase_json = dumps(purchase_dict, 
                default=json_serial)
     repo:PurchaseRepository = PurchaseRepository(<strong class="bold">engine</strong>)
     result = await 
            repo.insert_purchase(loads(purchase_json))
     if result == True: 
        return req 
     else: 
        return JSONResponse(content={"message": 
          "insert purchase unsuccessful"}, status_code=500)
     return req</pre>
			<p>At this point, we should know how to compare these mappers and drivers when it comes to the setup and<a id="_idIndexMarker519"/> procedures needed to manage MongoDB documents. Each has its strengths and weaknesses based on the code they produce and the performance, popularity, support, and complexity of its solution. Some may work on other requirements, while others may not. The final ODM we will cover focuses on being the lightest and least obtrusive mapper. It aims to fit into an existing application without generating syntax and performance problems. </p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor184"/>Creating CRUD transactions using MongoFrames</h1>
			<p>If you are tired of using<a id="_idIndexMarker520"/> complicated and heavy-loaded ODMs, then MongoFrames is ideal for your requirements. MongoFrames is <a id="_idIndexMarker521"/>one of the newest ODMs and is very convenient to use, especially when building a new repository layer for an already existing complex and legacy FastAPI microservice application. But this mapper can only create synchronous and standard types of CRUD transactions.</p>
			<p>But before we proceed, let us install the extension module using <strong class="source-inline">pip</strong>:</p>
			<p class="source-code">pip install MongoFrames</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor185"/>Creating the database connection</h2>
			<p>The MongoFrames platform runs <a id="_idIndexMarker522"/>on top of PyMongo, which is why it cannot build an asynchronous repository layer. To create the database connection, it uses the <strong class="source-inline">MongoClient</strong> API class from the <strong class="source-inline">pymongo</strong> module, with the database URL in string format. Unlike in the other ODMs, where we create a client variable, in this mapper, we access the <strong class="source-inline">variable _client</strong> class from the <strong class="source-inline">Frame</strong> API class to refer to the client connection object. The following code shows <strong class="source-inline">create_db_client()</strong>, which will open the database connection for our app, and <strong class="source-inline">disconnect_db_client()</strong>, which will close this connection:</p>
			<pre class="source-code">
<strong class="bold">from pymongo import MongoClient</strong>
<strong class="bold">from mongoframes import Frame</strong>
def create_db_client():
    <strong class="bold">Frame._client = </strong>
        <strong class="bold">MongoClient('mongodb://localhost:27017/obrs')</strong>
        
def disconnect_db_client():
    <strong class="bold">Frame._client.close()</strong></pre>
			<p>Just like in the previous ODMs, we need event handlers to execute these core methods to start building the model and repository layers.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor186"/>Building the model layer</h2>
			<p>The process of creating model classes in<a id="_idIndexMarker523"/> MongoFrames<a id="_idIndexMarker524"/> is called <strong class="bold">framing</strong> because it uses the <strong class="source-inline">Frame</strong> API class to define the model classes. Once inherited, <strong class="source-inline">Frame</strong> does not require a model class to define its attributes. It uses the <strong class="source-inline">_fields</strong> property to contain all the necessary fields of the document without indicating any metadata. The following model classes are defined by the <strong class="source-inline">Frame</strong> API class:</p>
			<pre class="source-code">
<strong class="bold">from mongoframes import Frame, SubFrame</strong>
class <strong class="bold">Book(Frame)</strong>:
    <strong class="bold">_fields</strong> = {
        'id ',
        'isbn',
        'author', 
        'date_published', 
        'title', 
        'edition',
        'price',
        'category'
    }
    <strong class="bold">_collection = "book"</strong>
    
    
class <strong class="bold">Category(SubFrame)</strong>:
    
    <strong class="bold">_fields</strong> = {
        'id',
        'name',
        'description',
        'date_added'
        }
    
    <strong class="bold">_collection = "category"</strong>
class <strong class="bold">Reference(Frame)</strong>:
    <strong class="bold">_fields</strong> = {
        'id',
        'name',
        'description',
        'categories'
        }
    
    <strong class="bold">_collection = "reference"</strong></pre>
			<p>A <strong class="source-inline">Frame</strong> model class can <a id="_idIndexMarker525"/>wrap a document in dictionary form or in a <strong class="source-inline">kwargs</strong> that contains the key-value details of the document’s structure. It can also provide attributes and helper methods that can help pursue CRUD transactions. All the fields of the model class can be accessed through dot (<strong class="source-inline">.</strong>) notation, just like typical class variables.</p>
			<h3>Creating the document association</h3>
			<p>We need to define the <strong class="source-inline">SubFrame</strong> model before <a id="_idIndexMarker526"/>creating associations among these documents. A <strong class="source-inline">SubFrame</strong> model class is mapped to an embedded document structure and has no collection table of its own. The MongoFrames mapper provides operations that allow you to append, update, remove, and query the <strong class="source-inline">SubFrame</strong> class of the <strong class="source-inline">Frame</strong> instance. These operations will determine the type of association among documents since the field references of <strong class="source-inline">Frame</strong> do not have specific field types. The <strong class="source-inline">Reference</strong> document, for instance, will have a list of categories linked to its <strong class="source-inline">categories</strong> field because our transaction will build that association as designed. A <strong class="source-inline">Book</strong> document, on the other hand, will refer to a <strong class="source-inline">Category</strong> child document through its <strong class="source-inline">category</strong> field because a<a id="_idIndexMarker527"/> transaction will build that association at runtime. So, MongoFrames is both restrained and non-strict when it comes to defining the type of association among these documents.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor187"/>Creating the repository layer</h2>
			<p>The <strong class="source-inline">Frame</strong> API class provides the <a id="_idIndexMarker528"/>model classes and the necessary helper methods to implement the asynchronous repository transactions. The following code shows an implementation of a repository class that uses MongoFrames to create its CRUD transactions:</p>
			<pre class="source-code">
<strong class="bold">from mongoframes.factory.makers import Q</strong>
<strong class="bold">from models.data.mongoframe import Book, Category</strong>
from typing import List, Dict, Any
class BookRepository: 
    def <strong class="bold">insert_book</strong>(self, 
             details:Dict[str, Any]) -&gt; bool: 
        try:
           book = Book(**details)
           <strong class="bold">book.insert()</strong>
                  
        except Exception as e:
            return False 
        return True</pre>
			<p>The given <strong class="source-inline">insert_book()</strong> transaction inserts a book instance into its mapped collection. The <strong class="source-inline">Frame</strong> API provides an <strong class="source-inline">insert()</strong> method that saves the given model object into the database. It also has <strong class="source-inline">insert_many()</strong>, which inserts a list of multiple BSON documents or a list of model instances. The following script shows how to create an <em class="italic">UPDATE</em> transaction in MongoFrames:</p>
			<pre class="source-code">
    def <strong class="bold">update_book</strong>(self, id:int, 
            details:Dict[str, Any]) -&gt; bool: 
       try:
        <strong class="bold">book = Book.one(Q.id == id)</strong>
        for key,value in details.items():
            setattr(book,key,value)
        <strong class="bold">book.update()</strong>
       except: 
           return False 
       return True</pre>
			<p>The given <strong class="source-inline">update_book()</strong> transaction shows that the <strong class="source-inline">Frame</strong> model class also has an <strong class="source-inline">update()</strong> method, which recognizes<a id="_idIndexMarker529"/> and saves the changes reflected in the field values of a document object right after fetching them from the collection. A similar process is applied to the <strong class="source-inline">delete_book()</strong> process, which calls the <strong class="source-inline">delete()</strong> operation of the document object right after fetching it from the collection:</p>
			<pre class="source-code">
    def <strong class="bold">delete_book</strong>(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">book = Book.one(Q.id == id)</strong>
           <strong class="bold">book.delete()</strong>
        except: 
            return False 
        return True</pre>
			<p>When creating query transactions, the <strong class="source-inline">Frame</strong> API provides two class methods – the <strong class="source-inline">many()</strong> method, which extracts all BSON documents, and the <strong class="source-inline">one()</strong> method, which returns a single document<a id="_idIndexMarker530"/> object. Both operations can accept a query expression as an argument if there are any constraints. Moreover, MongoFrames has a <strong class="source-inline">Q</strong> query maker class that’s used to build conditionals in a query expression. The expression starts with <strong class="source-inline">Q</strong>, followed by dot (<strong class="source-inline">.</strong>) notation to define the field name or path – for example, <strong class="source-inline">Q.categories.fiction</strong> – followed by an operator (for example, <strong class="source-inline">==</strong>, <strong class="source-inline">!=</strong>, <strong class="source-inline">&gt;</strong>, <strong class="source-inline">&gt;=</strong>, <strong class="source-inline">&lt;</strong>, or <strong class="source-inline">&lt;=</strong>) and finally a value. The following code shows examples of the query transactions being translated using the MongoFrames ODM syntax:</p>
			<pre class="source-code">
    def <strong class="bold">get_all_book</strong>(self):
        books = [b.to_json_type() for b in <strong class="bold">Book.many()</strong>]
        return books
    
    def get_book(self, id:int): 
        book = <strong class="bold">Book.one(Q.id == id).to_json_type()</strong>
        return book</pre>
			<p>The <strong class="source-inline">get_book()</strong> method shows how to extract a single <strong class="source-inline">Book</strong> document with a <strong class="source-inline">Q</strong> expression that filters the correct <strong class="source-inline">id</strong>, while <strong class="source-inline">get_all_book()</strong> retrieves all <strong class="source-inline">Book</strong> documents without any constraints. </p>
			<p>The <strong class="source-inline">many()</strong> operator returns a list of <strong class="source-inline">Frame</strong> objects, while the <strong class="source-inline">one()</strong> operator returns a single <strong class="source-inline">Frame</strong> instance. To convert the result into JSON-able components, we need to invoke the <strong class="source-inline">to_json_type()</strong> method in each <strong class="source-inline">Frame</strong> instance.</p>
			<p>As explained earlier, adding embedded documents is determined by the operation and not by the model attributes. In the following <strong class="source-inline">add_category()</strong> transaction, it is clear that a <strong class="source-inline">Category</strong> object has been assigned to a <strong class="source-inline">category</strong> field of a <strong class="source-inline">Book</strong> instance, even if the field is not defined to refer to an embedded document of the <strong class="source-inline">Category</strong> type. Instead of throwing an<a id="_idIndexMarker531"/> exception, MongoFrame will update the <strong class="source-inline">Book</strong> document right after the <strong class="source-inline">update()</strong> call:</p>
			<pre class="source-code">
    def <strong class="bold">add_category</strong>(self, id:int, 
               category:Category) -&gt; bool: 
       try:
        <strong class="bold">book = Book.one(Q.id == id)</strong>
        <strong class="bold">book.category = category</strong>
        <strong class="bold">book.update()</strong>
       except: 
           return False 
       return True</pre>
			<p>Now, it is time to apply these CRUD transactions to our API services.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor188"/>Applying the repository layer</h2>
			<p>Our repository classes will not work if we do not inject the <strong class="source-inline">create_db_client()</strong> injectable into the router. The<a id="_idIndexMarker532"/> following solution injects the component into <strong class="source-inline">APIRouter</strong>, even if it is acceptable to inject it into each API service implementation:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
from fastapi.responses import JSONResponse
from models.request.category import BookReq
<strong class="bold">from repository.mongoframe.book import BookRepository</strong>
<strong class="bold">from db_config.mongoframe_config import create_db_client</strong>
from datetime import date, datetime
from json import dumps, loads
router = APIRouter(
         dependencies=[<strong class="bold">Depends(create_db_client)</strong>])
<strong class="bold">@router.post("/book/create")</strong>
def create_book(req:BookReq): 
    book_dict = req.dict(exclude_unset=True) 
    book_json = dumps(book_dict, default=json_serial)
    <strong class="bold">repo:BookRepository = BookRepository()</strong>
    result = repo.insert_book(loads(book_json))
    if result == True: 
        return req 
    else: 
        return JSONResponse(content={"message": 
          "insert book unsuccessful"}, status_code=500)</pre>
			<p>The <strong class="source-inline">create_book()</strong> service uses <strong class="source-inline">BookRepository</strong> to insert book details into the MongoDB database. In <a id="_idIndexMarker533"/>general, MongoFrames has an easy setup because it requires fewer configuration details for creating the database connection, building the model layer, and implementing the repository transactions. Its platform can be adapted to the existing requirements of the application and can easily reflect changes if modifications need to be made to its mapping mechanisms.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor189"/>Summary</h1>
			<p>In this chapter, we looked at various ways to manage data using MongoDB. We utilized MongoDB to store non-relational data for our <em class="italic">online book reselling system</em> since we expect the data to become large when information is exchanged between the book buyers and resellers. Additionally, the details involved in the transactions are mainly strings, floats, and integers, which are all order and purchase values that will be easier to mine and analyze if they’re stored in schema-less storage. </p>
			<p>This chapter took the non-relational data management roadmap for utilizing the data in sales forecasting, regression analysis of book readers’ demands, and other descriptive data analysis forms.</p>
			<p>First, you learned how the PyMongo and Motor drivers connect the FastAPI application to the MongoDB database. After understanding the nuts and bolts of creating CRUD transactions using these drivers, you learned that ODM is the better option for pursuing MongoDB connectivity. We explored the features of MongoEngine, Beanie, ODMantic, and MongoFrames and studied their strengths and weaknesses as ODM mappers. All these ODMs can be integrated well with the FastAPI platform and provide the application with a standardized way to back up data.</p>
			<p>Now that we’ve spent two chapters covering data management, in the next chapter, we will learn how to secure our FastAPI microservice applications.</p>
		</div>
		<div>
			<div id="_idContainer040">
			</div>
		</div>
	</body></html>