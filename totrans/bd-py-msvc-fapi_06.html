<html><head></head><body>
		<div><h1 id="_idParaDest-153" class="chapter-number"><a id="_idTextAnchor155"/>6</h1>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor156"/>Using a Non-Relational Database</h1>
			<p>So far, we have learned that relational databases store data using table columns and rows. All these table records are structurally optimized and designed using different keys, such as primary, unique, and composite keys. The tables are connected using foreign/reference keys. Foreign key integrity plays a significant role in the table relationship of a database schema because it gives consistency and integrity to the data that’s persisted in the tables. <a href="B17975_05.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a>, <em class="italic">Connecting to a Relational Database</em>, provided considerable proof that FastAPI can connect to relational databases using any of the present ORMs smoothly without lots of complexities. This time, we will focus on using non-relational databases as data storage for our FastAPI microservice application. </p>
			<p>If FastAPI uses ORM for relational databases, it uses <strong class="bold">Object Document Mapping</strong> (<strong class="bold">ODM</strong>) to manage data using non-relational data stores or <strong class="bold">NoSQL</strong> databases. There are no tables, keys, and foreign key constraints involved in ODM, but a JSON document is needed to hold the various pieces of information. Different NoSQL databases vary in the storage model type that’s used to store data. The simplest among these databases manages data as key-value pairs, such as <strong class="bold">Redis</strong>, while complicated databases utilize schema-free document structures easily mapped to objects. This is usually done in <strong class="bold">MongoDB</strong>. Some use columnar data stores such as <strong class="bold">Cassandra</strong>, while some have graph-oriented data storage such as <strong class="bold">Neo4j</strong>. However, this chapter will focus on the FastAPI-MongoDB connectivity and the different ODM we can apply to pursue data management with a document-based database.</p>
			<p>The main objective of this chapter is to study, formalize, and scrutinize different ways to use MongoDB as a database for our FastAPI application. Building the repository layer and showcasing the CRUD implementation will be the main highlight. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Setting up the database environment</li>
				<li>Applying the PyMongo driver for synchronous connections</li>
				<li>Creating asynchronous CRUD transactions using Motor</li>
				<li>Implementing CRUD transactions using MongoEngine</li>
				<li>Implementing asynchronous CRUD transactions using Beanie </li>
				<li>Building an asynchronous repository for FastAPI using ODMantic</li>
				<li>Creating CRUD transactions using MongoFrames</li>
			</ul>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor157"/>Technical requirements</h1>
			<p>This chapter focuses on an eBookstore web portal, <em class="italic">online book reselling system</em>, where users can sell and buy books from home through the internet. The virtual store allows users to view the <em class="italic">sellers' profiles</em>, <em class="italic">book catalogs</em>, <em class="italic">list of orders</em>, and <em class="italic">archive of purchases</em>. When it comes to the e-commerce side, the user can select their preferred books and add them to a cart. Then, they can check out the items as orders and pursue the payment transaction afterward. All the data is stored in a MongoDB database. The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI">https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI</a> in the <code>ch06</code> project.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor158"/>Setting up the database environment</h1>
			<p>Before we start <a id="_idIndexMarker405"/>discussing the application’s database connectivity, we <a id="_idIndexMarker406"/>need to download the appropriate MongoDB database server from <a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a>. <em class="italic">online book reselling system</em> uses MongoDB 5.0.5 for a Windows platform. The installation will provide default service configuration details for the service name, data directory, and log directory. However, it is advised that you use different directory paths instead of the default ones. </p>
			<p>After the installation, we can start the MongoDB server by running <code>/bin/mongod.exe</code>. This will automatically create a database directory called <code>/data/db</code> in the <code>C:/</code> drive (Windows). We can place the <code>/data/db</code> directory in some other location, but be sure to run the <code>mongod</code> command with the <code>--dbpath</code> option while specifying <code>&lt;new path&gt;/data/db</code>.</p>
			<p>The MongoDB platform has utilities that can aid in managing database collections, and one of them is <strong class="bold">MongoDB Compass</strong>. It can provide <a id="_idIndexMarker407"/>a GUI experience that allows you to browse, explore, and easily manipulate the database and its collections. Also, it has built-in performance metrics, query views, and schema visualization features that can help with scrutinizing the correctness of the database structure. The following screenshot shows the dashboard for MongoDB Compass version 1.29.6:</p>
			<div><div><img src="img/Figure_6.01_B17975.jpg" alt="Figure 6.1 – The MongoDB Compass dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The MongoDB Compass dashboard</p>
			<p>The preceding dashboard shows<a id="_idIndexMarker408"/> the document structure of the <code>profile</code> and list of books for sale.</p>
			<p>Once the server and utility have been installed, we need to design the data collections for our database using the <code>obrs</code>:</p>
			<div><div><img src="img/Figure_6.02_B17975.jpg" alt="Figure 6.2 – The class diagram for the obrs database&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The class diagram for the obrs database</p>
			<p>Our application uses all the collections<a id="_idIndexMarker410"/> depicted in the preceding diagram to store all the information it captures from the client. Each context box represents one collection, with all the attributes and expected underlying transactions indicated inside the box. It also shows the associations that bind these collections, such as the one-to-one association between <code>login</code> and <code>profile</code> and the many-to-one association between <code>BookForSale</code> and <code>UserProfile</code>.</p>
			<p>Now that the database server has been installed and designed, let us look at the different ways of establishing a connection from our FastAPI microservice application to its MongoDB database.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor159"/>Applying the PyMongo driver for synchronous connections</h1>
			<p>We will start by learning how<a id="_idIndexMarker411"/> the FastAPI application connects to MongoDB using the PyMongo database driver. This driver is<a id="_idIndexMarker412"/> equivalent to <code>psycopg2</code>, which allows us to access PostgreSQL without using any ORM. Some popular ODMs, such as MongoEngine and Motor, use PyMongo as their core driver, which gives us the reason to explore PyMongo first before we touch on issues regarding popular ODMs. Studying the driver’s behavior can provide baseline transactions that will show how an ODM builds the database connectivity, models, and CRUD transactions. But before we proceed with the details, we need to install the <code>pymongo</code> extension using <code>pip</code>:</p>
			<pre>pip install pymongo </pre>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor160"/>Setting up the database connectivity</h2>
			<p>PyMongo uses its <code>MongoClient</code> module class<a id="_idIndexMarker413"/> to connect to any MongoDB database. We instantiate it with the specified host and port to extract the client object, such as <code>MongoClient("localhost", "27017")</code>, or a database URI, such as <code>MongoClient('mongodb://localhost:27017/')</code>. Our application uses the latter to connect to its database. But if we instantiate without providing the parameters, it will use the default <code>localhost</code> and <code>27017</code> details.</p>
			<p>After extracting the client object, we can use it to access the database through a dot (<code>.</code>) operator or <code>attribute-style access</code> if the database name follows the Python naming convention; for example, <code>client.obrs</code>. Otherwise, we can use the bracket symbols (<code>[]</code>) or dictionary-style access; for example, <code>client["obrs_db"]</code>. Once the database object has been retrieved, we can access the collections using the access rules. Note that a collection is equivalent to a table in a relational database, where the collated records, known as documents, are stored. The following code shows a generator function that’s used by the application to open database connectivity and access the necessary collections in preparation for the CRUD implementation:</p>
			<pre class="source-code">
<strong class="bold">from pymongo import MongoClient</strong>
def create_db_collections():
    <strong class="bold">client = MongoClient('mongodb://localhost:27017/')</strong>
    try:
        <strong class="bold">db = client.obrs</strong>
        <strong class="bold">buyers = db.buyer</strong>
        <strong class="bold">users = db.login</strong>
        <strong class="bold">print("connect")</strong>
        yield {"users": users, "buyers": buyers}
    finally:
        <strong class="bold">client.close()</strong></pre>
			<p>A generator function such as <code>create_db_collections()</code> is preferred because the <code>yield</code> statement works perfectly when it comes to managing the database connection over the <code>return</code> statement. The <code>yield</code> statement suspends the function’s execution when it sends a value back<a id="_idIndexMarker414"/> to the caller but retains the state where the function can resume at the point where it left off. This feature is applied by the generator to close the database connection when it resumes the execution at the <code>finally</code> clause. The <code>return</code> statement, on the other hand, will not be applicable for this purpose because <code>return</code> will finish the whole transaction before it sends a value to the caller. </p>
			<p>However, before we invoke the generator, let us scrutinize how PyMongo builds its model layer to pursue the necessary CRUD transactions.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor161"/>Building the model layer</h2>
			<p>Documents in MongoDB are <a id="_idIndexMarker415"/>represented and collated as JSON-style structures, specifically <a id="_idIndexMarker416"/>BSON documents. A BSON document offers more data types than the JSON structure. We can use dictionaries to represent and persist these BSON documents in PyMongo. Once a dictionary has been persisted, the BSON-type document will look like this:</p>
			<pre class="source-code">
{
   <strong class="bold">_id:ObjectId("61e7a49c687c6fd4abfc81fa")</strong>,
   id:1,
   user_id:10,
   <strong class="bold">date_purchased:"2022-01-19T00:00:00.000000"</strong>,
   purchase_history: 
   [
       {
        purchase_id:100,
        shipping_address:"Makati City",
        email:"mailer@yahoo.com",
        <strong class="bold">date_purchased:"2022-01-19T00:00:00.000000"</strong>,
        <strong class="bold">date_shipped:"2022-01-19T00:00:00.000000"</strong>,
        <strong class="bold">date_payment:"2022-01-19T00:00:00.000000"</strong>
      },
      {
        purchase_id:110,
        shipping_address:"Pasig City",
        email:"edna@yahoo.com",
        <strong class="bold">date_purchased:"2022-01-19T00:00:00.000000"</strong>,
        <strong class="bold">date_shipped:"2022-01-19T00:00:00.000000"</strong>,
        <strong class="bold">date_payment:"2022-01-19T00:00:00.000000"</strong>
      }
    ],
   customer_status: 
   {
        status_id:90,
        name:"Sherwin John C. Tragura",
        discount:50,
        <strong class="bold">date_membership:"2022-01-19T00:00:00.000000"</strong>
   }
}</pre>
			<p>Common Python data<a id="_idIndexMarker417"/> types such as <code>str</code>, <code>int</code>, and <code>float</code> are <a id="_idIndexMarker418"/>supported by the BSON specification, but there are types such as <code>ObjectId</code>, <code>Decimal128</code>, <code>RegEx</code>, and <code>Binary</code> that are intrinsic only to the <code>bson</code> module. The specification only supports the <code>timestamp</code> and <code>datetime</code> temporal types. To install <code>bson</code>, use the following <code>pip</code> command:</p>
			<pre>pip install bson</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">BSON</strong> is short for <strong class="bold">Binary JSON</strong>, a serialized and binary<a id="_idIndexMarker419"/> encoding for JSON-like documents. The specification behind this is lightweight and flexible. The efficient encoding format is <a id="_idIndexMarker420"/>explained in more detail at <a href="https://bsonspec.org/spec.html">https://bsonspec.org/spec.html</a>.</p>
			<p><code>ObjectId</code> is an essential data type in a MongoDB document because it serves as a <em class="italic">unique identifier</em> for the main document structure. It is a <em class="italic">12-byte</em> field that consists of a 4-byte UNIX <em class="italic">embedded timestamp</em>, the 3-byte <em class="italic">machine ID</em> of the MongoDB server, a 2-byte <em class="italic">process ID</em>, and a 3-byte <em class="italic">arbitrary value</em> for the ID’s increments. Conventionally, the declared field of the document, <code>_id</code>, always refers to the <code>ObjectId</code> value of the document structure. We can allow the MongoDB server to generate the _<code>id</code> object for the document or create an instance of the object type during persistence. When<a id="_idIndexMarker421"/> retrieved, <code>ObjectId</code> can be in <em class="italic">24 hexadecimal digit</em> or <em class="italic">string</em> format. Note that the <code>_id</code> field is the key indicator that a dictionary is ready to be persisted as a valid<a id="_idIndexMarker422"/> BSON document. Now, BSON documents can also be linked with one another using some associations.</p>
			<h3>Establishing document associations</h3>
			<p>MongoDB has no<a id="_idIndexMarker423"/> concept of referential integrity constraints, but a relationship among documents is possible based on structures. There are two types of documents: <em class="italic">main</em> and <em class="italic">embedded</em> documents. A document has a <em class="italic">one-to-one association</em> with another if it is an embedded document of the other. Likewise, a document has a <em class="italic">many-to-one association</em> if a list in that document is linked to the main document structure. </p>
			<p>The previous purchase BSON document shows a sample of the principal <code>buyer</code> document with a one-to-one association with the <code>customer_status</code> embedded document and a many-to-one association with the <code>purchase_history</code> documents. As depicted from this sample document, embedded documents have no separate collection because they have no respective <code>_id</code> field to make them stand as primary documents. </p>
			<h3>Using the BaseModel classes for transactions</h3>
			<p>Since PyMongo has no<a id="_idIndexMarker424"/> predefined model classes, the Pydantic models of FastAPI can be used to represent MongoDB documents with all the<a id="_idIndexMarker425"/> necessary validation rules and encoders. We can use the <code>BaseModel</code> classes to contain document details and pursue <em class="italic">insert</em>, <em class="italic">update</em>, and <em class="italic">delete</em> transactions since the Pydantic models are compatible with MongoDB documents. The following models are <a id="_idIndexMarker426"/>being used by our online book <a id="_idIndexMarker427"/>reselling application to store and retrieve the <code>buyer</code>, <code>purchase_history</code>, and <code>customer_status</code> document details:</p>
			<pre class="source-code">
<strong class="bold"> from pydantic import BaseModel, validator</strong>
from typing import List, Optional, Dict
<strong class="bold">from bson import ObjectId</strong>
from datetime import date
class PurchaseHistoryReq(<strong class="bold">BaseModel</strong>):
    purchase_id: int
    shipping_address: str 
    email: str   
    <strong class="bold">date_purchased: date</strong>
    <strong class="bold">date_shipped: date</strong>
    <strong class="bold">date_payment: date</strong>
    <strong class="bold">@validator('date_purchased')</strong>
    def date_purchased_datetime(cls, value):
        return <strong class="bold">datetime.strptime(value,</strong> 
           <strong class="bold">"%Y-%m-%dT%H:%M:%S").date()</strong>
    
    <strong class="bold">@validator('date_shipped')</strong>
    def date_shipped_datetime(cls, value):
        return <strong class="bold">datetime.strptime(value, </strong>
           <strong class="bold">"%Y-%m-%dT%H:%M:%S").date()</strong>
    
    <strong class="bold">@validator('date_payment')</strong>
    def date_payment_datetime(cls, value):
        return <strong class="bold">datetime.strptime(value, </strong>
           <strong class="bold">"%Y-%m-%dT%H:%M:%S").date()</strong>
    
    <strong class="bold">class Config:</strong>
        <strong class="bold">arbitrary_types_allowed = True</strong>
        <strong class="bold">json_encoders = {</strong>
            <strong class="bold">ObjectId: str</strong>
        <strong class="bold">}</strong>
        
class PurchaseStatusReq(<strong class="bold">BaseModel</strong>):
    status_id: int 
    name: str
    discount: float 
    <strong class="bold">date_membership: date</strong>
    <strong class="bold">@validator('date_membership')</strong>
    def date_membership_datetime(cls, value):
        return <strong class="bold">datetime.strptime(value,</strong> 
            <strong class="bold">"%Y-%m-%dT%H:%M:%S").date()</strong>
    
    <strong class="bold">class Config:</strong>
        <strong class="bold">arbitrary_types_allowed = True</strong>
        <strong class="bold">json_encoders = {</strong>
            <strong class="bold">ObjectId: str</strong>
        <strong class="bold">}</strong>
        
class BuyerReq(<strong class="bold">BaseModel</strong>):
    <strong class="bold">_id: ObjectId</strong>
    Buyer_id: int
    user_id: int
    date_purchased: date
    purchase_history: List[Dict] = list()
    customer_status: Optional[Dict]
    <strong class="bold">@validator('date_purchased')</strong>
    def date_purchased_datetime(cls, value):
        return <strong class="bold">datetime.strptime(value,</strong> 
            <strong class="bold">"%Y-%m-%dT%H:%M:%S").date()</strong>
  
    <strong class="bold">class Config:</strong>
        <strong class="bold">arbitrary_types_allowed = True</strong>
        <strong class="bold">json_encoders = {</strong>
            <strong class="bold">ObjectId: str</strong>
        <strong class="bold">}</strong></pre>
			<p>For these request<a id="_idIndexMarker428"/> models to recognize<a id="_idIndexMarker429"/> the BSON data types, we should make some modifications to the default behavior of these models. Just like earlier in this chapter, where we added the <code>orm_mode</code> option, there is also a need to add a nested <code>Config</code> class to the <code>BaseModel</code> blueprint with the <code>arbitrary_types_allowed</code> option set to <code>True</code>. This additional<a id="_idIndexMarker430"/> configuration will recognize the BSON data types used in the attribute declaration, including compliance with the necessary underlying validation rules for the corresponding BSON data types used. Moreover, the <code>json_encoders</code> option <a id="_idIndexMarker431"/>should also be part of the configuration to convert the <code>ObjectId</code> property of the document into a string during a query transaction.</p>
			<h3>Using Pydantic validation</h3>
			<p>However, some other types are too<a id="_idIndexMarker432"/> complex for <code>json_encoders</code> to process, such as the BSON <code>datettime</code> field being converted into a Python <code>datetime.date</code>. Since the ODM cannot automatically convert a <a id="_idIndexMarker433"/>MongoDB datetime into a Python <code>date</code> type, we need to create a custom validation and parse this BSON <code>datetime</code> through Pydantic’s <code>@validation</code> decorator. We must also use custom validators and parsers in the FastAPI services to convert all incoming Python date parameters into BSON datetime. This will be covered later.</p>
			<p><code>@validator</code> creates a <code>class</code> method that accepts <code>class name</code> as the first parameter, not the instance, of the field(s) to be validated and parsed. Its second parameter is an option that specifies the field name or class attribute that needs to be converted into another data type, such as <code>date_purchased</code>, <code>date_shipped</code>, or <code>date_payment</code> of the <code>PurchaseRequestReq</code> model. The <code>pre</code> attribute of <code>@validator</code> tells FastAPI to process the class methods before any built-in validation can be done in the API service implementation. These methods are executed right after <code>APIRouter</code> runs its custom and built-in FastAPI validation rules for the request models, if there are any.</p>
			<p>Note that these request models have been placed in the <code>/models/request/buyer.py</code> module of the application.</p>
			<h3>Using the Pydantic @dataclass to query documents</h3>
			<p>Wrapping the queried BSON <a id="_idIndexMarker434"/>documents using the <code>BaseModel</code> model classes is still the best approach to implementing the<a id="_idIndexMarker435"/> query transaction. But since BSON has issues with the Python <code>datetime.date</code> fields, we cannot always utilize the request model classes that are used for the CRUD transaction by wrapping retrieved BSON documents. Sometimes, using the model yields an <code>"invalid date format (type=value_error.date)"</code> error because all the models have the Python <code>datetime.date</code> fields, whereas the incoming data has a BSON <code>datetime</code> or <code>timestamp</code>. Instead of adding more complexities to the request models, we should resort to another approach to extracting the documents – that is, utilizing the Pydantic <code>@dataclass</code>. The following data <a id="_idIndexMarker436"/>classes are defined for wrapping the extracted <code>buyer</code> documents:</p>
			<pre class="source-code">
<strong class="bold">from pydantic.dataclasses import dataclass</strong>
<strong class="bold">from dataclasses import field</strong>
<strong class="bold">from pydantic import validator</strong>
from datetime import date, datetime
from bson import ObjectId
from typing import List, Optional
class <strong class="bold">Config</strong>:
        <strong class="bold">arbitrary_types_allowed = True</strong>
<strong class="bold">@dataclass(config=Config)</strong>
class <strong class="bold">PurchaseHistory</strong>:
    purchase_id: <strong class="bold">Optional[int] = None</strong>
    shipping_address: <strong class="bold">Optional[str] = None</strong>
    email: <strong class="bold">Optional[str] = None</strong>   
    date_purchased: <strong class="bold">Optional[date] = "1900-01-01T00:00:00"</strong>
    date_shipped: <strong class="bold">Optional[date] = "1900-01-01T00:00:00"</strong>
    date_payment: <strong class="bold">Optional[date] = "1900-01-01T00:00:00"</strong>
    
    <strong class="bold">@validator('date_purchased', pre=True)</strong>
    def date_purchased_datetime(cls, value):
        return datetime.strptime(value, 
           "%Y-%m-%dT%H:%M:%S").date()
    
    <strong class="bold">@validator('date_shipped', pre=True)</strong>
    def date_shipped_datetime(cls, value):
        return datetime.strptime(value, 
           "%Y-%m-%dT%H:%M:%S").date()
    
    <strong class="bold">@validator('date_payment', pre=True)</strong>
    def date_payment_datetime(cls, value):
        return datetime.strptime(value, 
           "%Y-%m-%dT%H:%M:%S").date()
<strong class="bold">@dataclass(config=Config)</strong>
class <strong class="bold">PurchaseStatus</strong>:
    status_id: <strong class="bold">Optional[int] = None</strong>
    name: <strong class="bold">Optional[str] = None</strong>
    discount: <strong class="bold">Optional[float] = None</strong>
    date_membership: <strong class="bold">Optional[date] = "1900-01-01T00:00:00"</strong>
    
    <strong class="bold">@validator('date_membership', pre=True)</strong>
    def date_membership_datetime(cls, value):
        return datetime.strptime(value, 
           "%Y-%m-%dT%H:%M:%S").date()
      
<strong class="bold">@dataclass(config=Config)</strong>
class <strong class="bold">Buyer</strong>:
    buyer_id: int 
    user_id: int 
    date_purchased: date 
    purchase_history: List[PurchaseHistory] = 
          <strong class="bold">field(default_factory=list )</strong>
    customer_status: Optional[PurchaseStatus] = 
          <strong class="bold">field(default_factory=dict)</strong>
    <strong class="bold">_id: ObjectId = field(default=ObjectId())</strong>
    
    <strong class="bold">@validator('date_purchased', pre=True)</strong>
    def date_purchased_datetime(cls, value):
        print(type(value))
        return datetime.strptime(value, 
             "%Y-%m-%dT%H:%M:%S").date()</pre>
			<p><code>@dataclass</code> is a decorator <a id="_idIndexMarker437"/>function <a id="_idIndexMarker438"/>that adds an <code>__init__()</code> to a Python class to initialize its attributes and other special functions, such as <code>__repr__()</code>. The <code>PurchasedHistory</code>, <code>PurchaseStatus</code>, and <code>Buyer</code> custom classes shown in the preceding code are typical classes that can<a id="_idIndexMarker439"/> be converted into request model classes. FastAPI supports both <code>BaseModel</code> and data classes when creating model classes. Apart from being under the <code>Pydantic</code> module, using <code>@dataclass</code> is not a replacement for using <code>BaseModel</code> when creating model classes. This is because the two components are different in terms of their flexibility, features, and hooks. <code>BaseModel</code> is configuration-friendly and can be adapted to many validation rules and type hints, while <code>@dataclass</code> has problems recognizing some <code>Config</code> attributes such as <code>extra</code>, <code>allow_population_by_field_name</code>, and <code>json_encoders</code>. If a data class requires some additional details, a custom class is needed to define these configurations and set the <code>config</code> parameter of the decorator. For instance, the <code>Config</code> class in the preceding code, which sets <code>arbitrary_types_allowed</code> to <code>True</code>, has been added to the three model classes. </p>
			<p>Besides <code>config</code>, the decorator has other parameters such as <code>init</code>, <code>eq</code>, and <code>repr</code> that accept <code>bool</code> values to generate their respective hook methods. The <code>frozen</code> parameter enables exception handling concerning field type mismatches when set to <code>True</code>.</p>
			<p>When it comes to data <a id="_idIndexMarker440"/>parsing, transition, and conversion, <code>@dataclass</code> is always dependent on augmented validations, unlike <code>BaseModel</code>, which can process data type conversion simply by adding <code>json_encoders</code>. In the data classes shown previously, all the validators focus on BSON <code>datetime</code> to Python <code>datetime.date</code> conversion during the document retrieval process. These validations will occur before any custom or built-in validation in <code>APIRouter</code> because the <code>pre</code> parameter of the <code>@validator</code> decorator is set to <code>True</code>.</p>
			<p>When dealing with default values, <code>BaseModel</code> classes can use typical type hints such as <code>Optional</code> or object instantiation such as <code>dict()</code> or <code>list()</code> to define the preconditional state of its complex attributes. With <code>@dataclass</code>, a <code>ValueError</code> exception is always thrown at compile time when type hints are applied to set default values of complex field<a id="_idIndexMarker441"/> types such as <code>list</code>, <code>dict</code>, and <code>ObjectId</code>. It requires the <code>field()</code> specifier from Python’s <code>dataclasses</code> module to set the default values of these fields, either by assigning an actual value through the specifier’s <code>default</code> parameter or invoking a function or lambda that returns a valid value through the <code>default_factory</code> parameter. The use of <code>field()</code> indicates that Pydantic’s <code>@dataclass</code> is an exact replacement of Python’s core data classes but with some additional features, such as the <code>config</code> parameter and the inclusion of the <code>@validator</code> components. </p>
			<p>Note that it is advised that all <code>@dataclass</code> models have default values when using type hints or <code>field()</code>, especially for embedded documents and for models with the <code>date</code> or <code>datetime</code> types, to <a id="_idIndexMarker442"/>avoid some missing constructor parameter(s) errors. On the other hand, an <code>@dataclass</code> can <a id="_idIndexMarker443"/>also create embedded structures in the <code>BaseModel</code> classes, for example, by defining attributes with the class types. This is highlighted in the <code>Buyer</code> model.</p>
			<p>All these model classes have been placed in the <code>/models/data/pymongo.py</code> script. Let us now apply these data models to create the repository layer.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor162"/>Implementing the repository layer</h2>
			<p>PyMongo needs <code>collection</code> to build the<a id="_idIndexMarker444"/> repository layer of the application. Besides<a id="_idIndexMarker445"/> the <code>collection</code> object, the <em class="italic">insert</em>, <em class="italic">delete</em>, and <em class="italic">update</em> transactions will also need the <code>BaseModel</code> classes to contain all the details from the client and convert them into BSON documents after the transaction. Meanwhile, our query transactions will require the data classes to convert all BSON documents into JSON-able resources during the document retrieval process. Now, let us look at how a repository can be implemented using a PyMongo driver.</p>
			<h3>Building the CRUD transactions</h3>
			<p>The repository <a id="_idIndexMarker446"/>class in the following code block implements the CRUD transactions that aim to manage the <code>buyer</code>, <code>purchase_history</code>, and <code>customer_status</code> information based on basic specifications of the <em class="italic">online book reselling </em>system:</p>
			<pre class="source-code">
from typing import Dict, Any
<strong class="bold">class BuyerRepository: </strong>
    
    def __init__(self, <strong class="bold">buyers</strong>): 
        <strong class="bold">self.buyers = buyers</strong>
    
    def <strong class="bold">insert_buyer</strong>(self, users, 
          details:Dict[str, Any]) -&gt; bool: 
        try:
           user = users.find_one(
                {"_id": details["user_id"]})
           print(user)
           if user == None:
               return False
           else: 
               <strong class="bold">self.buyers.insert_one(details)</strong>
                  
        except Exception as e:
            return False 
        return True</pre>
			<p>Let us examine <code>insert_buyer()</code>, which inserts details about a registered book buyer who had some previous transactions in the system as a <code>login</code> user. The PyMongo collection offers helper methods for <a id="_idIndexMarker447"/>processing CRUD transactions, such as <code>insert_one()</code>, which adds a single main document from its <code>Dict</code> parameter. It also has <code>insert_many()</code>, which accepts a valid list of dictionaries that can be persisted as multiple documents. These two methods can generate an <code>ObjectId</code> for the <code>_id</code> field of the BSON document during the insertion process. The buyer’s details are extracted from the <code>BuyerReq</code> Pydantic model.</p>
			<p>Next, <code>update_buyer()</code> shows how to update a specific document in the <code>buyer</code> collection:</p>
			<pre class="source-code">
    def <strong class="bold">update_buyer</strong>(self, id:int, 
              details:Dict[str, Any]) -&gt; bool: 
       try:
          <strong class="bold">self.buyers.update_one({"buyer_id": id},</strong>
                  <strong class="bold">{"$set":details})</strong>
       except: 
           return False 
       return True
   
    def <strong class="bold">delete_buyer</strong>(self, id:int) -&gt; bool: 
        try:
            <strong class="bold">self.buyers.delete_one({"buyer_id": id})</strong>
        except: 
            return False 
        return True</pre>
			<p>The collection has an <code>update_one()</code> method that requires two parameters: a unique and valid field/value dictionary pair that will serve as the <em class="italic">search key</em> of the record search, and another dictionary pair<a id="_idIndexMarker448"/> with the predefined <code>$set</code> key with the dictionary of updated <em class="italic">details for replacement</em>. It also has <code>update_many()</code>, which can update multiple documents, given that the primary dictionary field/value parameter is not unique.</p>
			<p><code>delete_buyer()</code> is the transaction that deletes a <code>buyer</code> document using a unique and valid field/value pair such as <code>{"buyer_id": id}</code>. If this parameter or search key is a common/non-unique data, the collection offers <code>delete_many()</code>, which can delete multiple documents. Now, the following script shows how to implement query transactions in PyMongo</p>
			<pre class="source-code">
<strong class="bold">from dataclasses import asdict</strong>
<strong class="bold">from models.data.pymongo import Buyer</strong>
from datetime import datetime
<strong class="bold">from bson.json_util import dumps</strong>
<strong class="bold">import json</strong>
    … … …
    … … …  
    … … …
    def <strong class="bold">get_all_buyer</strong>(self):
        <strong class="bold">buyers = [asdict(Buyer(**json.loads(dumps(b)))) </strong>
              for b in self.buyers.find()]
        return buyers
    
    def <strong class="bold">get_buyer</strong>(self, id:int): 
        buyer = self.buyers.find_one({"buyer_id": id})
        return <strong class="bold">asdict(Buyer(**json.loads(dumps(buyer))))</strong></pre>
			<p>When querying documents, PyMongo has a <code>find()</code> method, which retrieves all the documents in the collection, and <code>find_one()</code>, which can get a unique and single document. Both methods need two parameters: the conditional or logical query parameter in the form of a dictionary field/value pair and the set of fields that needs to appear in the record. <code>get_buyer()</code> in the previous code block shows how to retrieve a buyer document<a id="_idIndexMarker449"/> through the unique <code>buyer_id</code> field. The absence of its second parameter means the presence of all the fields in the result. Meanwhile, <code>get_all_buyer()</code> retrieves all the buyer documents without constraints. Constraints or filter expressions are formulated using BSON comparison operators, as shown in the following table:</p>
			<div><div><img src="img/Table_011.jpg" alt=""/>
				</div>
			</div>
			<p>For instance, retrieving buyer documents with <em class="italic">user_id greater than 5</em> requires the <code>buyers.find({"user_id": {"$gte": 5}})</code> query operation. If we need to build compound filters, we must apply<a id="_idIndexMarker450"/> the following logical operators:</p>
			<div><div><img src="img/Table_021.jpg" alt=""/>
				</div>
			</div>
			<p>Retrieving buyer documents with <em class="italic">buyer_id less than 50</em> and <em class="italic">buyer_id greater than 10</em> will require the <code>find({'and': [{'buyer_id': {'$lt': 50}}, {'user_id':{'$gt':10}}]})</code> query.</p>
			<p>Both methods return<a id="_idIndexMarker451"/> BSON documents that are not JSON-able components of the FastAPI framework. To convert the documents into JSON, the <code>bson.json_util</code> extension has a <code>dumps()</code> method that can convert a single document or list of documents into a JSON string. Both <code>get_all_buyer()</code> and <code>get_buyer()</code>convert every single document retrieved into JSON so that each can be mapped to the <code>Buyer</code> data class. The main objective of the mapping is to convert the <code>datetime</code> fields into Python <code>datetime.date</code> while utilizing the validators of the <code>Buyer</code> data class. The mapping will only be successful if the <code>loads()</code> method of the <code>json</code> extension is used to convert <code>str</code> into a <code>dict</code> data structure. After generating the list of <code>Buyer</code> data classes, the <code>asdict()</code> method of Python’s <code>dataclasses</code> module is needed to transform the list of <code>Buyer</code> data classes into a list of dictionaries to be consumed by <code>APIRouter</code>.</p>
			<h3>Managing document association</h3>
			<p>Technically, there are two ways to<a id="_idIndexMarker452"/> construct a document association in PyMongo. The first one is to use the <code>DBRef</code> class of the <code>bison.dbref</code> module to link the parent and child documents. The only prerequisite is for both documents to have an <code>_id</code> value of the <code>ObjectId</code> type and have their respective collection exist. For instance, if <code>PurchaseHistoryReq</code> is a core document, we can insert one purchase record into the list through the following query: </p>
			<pre class="source-code">
buyer["purchase_history"].append(new  DBRef("purchase_history", "49a3e4e5f462204490f70911"))</pre>
			<p>Here, the first<a id="_idIndexMarker453"/> parameter of the <code>DBRef</code> constructor pertains to the name of the collection where the child document is placed, while the second one is the <code>ObjectId</code> property of the child document in string format. However, some people use an <code>ObjectId</code> instance instead of the string version. On the other hand, to find a specific <code>purchase_history</code> document from the <code>buyer</code> collection using <code>DBRef</code>, we can write our query like this:</p>
			<pre class="source-code">
buyer.find({ "purchase_history ": DBRef("purchase_history",ObjectId("49a3e4e5f462204490f70911")) })</pre>
			<p>The second way is to<a id="_idIndexMarker454"/> add the whole BSON document structure to the <code>list</code> field of <code>buyer</code> through the <code>BuyerReq</code> model. This solution applies to embedded documents that do not have <code>_id</code> and <code>collection</code> but are essential to the core document. <code>add_purchase_history()</code> in the following code shows how this approach is applied to create a many-to-one association between the <code>purchase_history</code> and <code>buyer</code> documents:</p>
			<pre class="source-code">
def <strong class="bold">add_purchase_history</strong>(self, id:int, 
                details:Dict[str, Any]): 
        try:
            buyer = self.buyers.<strong class="bold">find_one</strong>({"buyer_id": id})
            <strong class="bold">buyer["purchase_history"].append(details)</strong>
            self.buyers.<strong class="bold">update_one</strong>({"buyer_id": id},
           {"$set": {"purchase_history": 
                     buyer["purchase_history"]}})
        except Exception as e: 
           return False 
        return True
    
    def <strong class="bold">add_customer_status</strong>(self, id:int, 
                  details:Dict[str, Any]): 
        try:
            buyer = self.buyers.<strong class="bold">find_one</strong>({"buyer_id": id})
            self.buyers.<strong class="bold">update_one</strong>({"buyer_id": id},
                {"$set":{"customer_status": details}})
        except Exception as e: 
           return False 
        return True</pre>
			<p>The <code>add_customer_status()</code> method shows how to implement the second approach in building a one-to-one<a id="_idIndexMarker455"/> association between the <code>buyer</code> and <code>purchase_status</code> documents. The first approach, which involves using <code>DBRef</code>, can also be applied if <code>PurchaseStatusReq</code> is an independent core document.</p>
			<p>The complete repository class can be found in the <code>/repository/pymongo/buyer.py</code> script file. Now, let us apply these CRUD transactions to our API services.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor163"/>Running the transactions</h2>
			<p>Before executing <a id="_idIndexMarker456"/>the <code>BuyerRepository</code> transactions, the <code>create_db_collections()</code> generator should be injected into the API services using <code>Depends</code>. Since PyMongo has difficulty processing Python types that are not BSON-supported, such as <code>datettime.date</code>, custom validations and serializers are sometimes required to pursue some transactions. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The implementation of <code>@validator</code> inside <code>@dataclass</code> and <code>BaseModel</code> converts outgoing BSON <code>datetime</code> parameters into Python <code>date</code> during query retrieval. Meanwhile, the JSON encoder validation in this API layer converts incoming Python <code>date</code> values into BSON <code>datetime</code> values during the transition from the application to MongoDB. </p>
			<p>For instance, the <code>add_buyer()</code>, <code>update_buyer()</code>, and <code>add_purchase_history()</code> transaction methods in the following code require a custom serializer such as <code>json_serialize_date()</code> to transform the Python <code>datetime.date</code> value<a id="_idIndexMarker457"/> into the <code>datettime.datetime</code> type so that it complies with PyMongo’s BSON specification: </p>
			<pre class="source-code">
from fastapi import APIRouter, <strong class="bold">Depends</strong>
from fastapi.responses import JSONResponse
<strong class="bold">from models.request.buyer import BuyerReq</strong>, 
      <strong class="bold">PurchaseHistoryReq, PurchaseStatusReq</strong>
<strong class="bold">from repository.pymongo.buyer import BuyerRepository</strong>
<strong class="bold">from db_config.pymongo_config import create_db_collections</strong>
from datetime import date, datetime
from json import dumps, loads
from bson import ObjectId
router = APIRouter()
def <strong class="bold">json_serialize_date</strong>(obj):
    if isinstance(obj, (date, datetime)):
        return obj.strftime('%Y-%m-%dT%H:%M:%S')
    raise TypeError ("The type %s not serializable." % 
            type(obj))
def <strong class="bold">json_serialize_oid</strong>(obj):
    if isinstance(obj, ObjectId):
        return str(obj)
    elif isinstance(obj, date):
        return obj.isoformat()
    raise TypeError ("The type %s not serializable." % 
            type(obj))
<strong class="bold">@router.post("/buyer/add")</strong>
def add_buyer(req: BuyerReq, 
            <strong class="bold">db=Depends(create_db_collections))</strong>: 
    buyer_dict = req.dict(exclude_unset=True)
    buyer_json = dumps(buyer_dict, 
              <strong class="bold">default=json_serialize_date</strong>)
    repo:BuyerRepository = BuyerRepository(db["buyers"])
    result = repo.insert_buyer(db["users"], 
            loads(buyer_json))  
   
    if result == True: 
        return JSONResponse(content={"message": 
          "add buyer successful"}, status_code=201) 
    else: 
        return JSONResponse(content={"message": 
          "add buyer unsuccessful"}, status_code=500) 
<strong class="bold">@router.patch("/buyer/update")</strong>
def update_buyer(id:int, req:BuyerReq, 
           <strong class="bold">db=Depends(create_db_collections))</strong>: 
    buyer_dict = req.dict(exclude_unset=True)
    buyer_json = dumps(buyer_dict, 
             <strong class="bold">default=json_serialize_date</strong>)
    repo:BuyerRepository = BuyerRepository(db["buyers"])
    result = repo.update_buyer(id, loads(buyer_json))  
   
    if result == True: 
        return JSONResponse(content={"message": 
         "update buyer successful"}, status_code=201) 
    else: 
        return JSONResponse(content={"message": 
         "update buyer unsuccessful"}, status_code=500)
<strong class="bold">@router.post("/buyer/history/add")</strong>
def add_purchase_history(id:int, req:PurchaseHistoryReq, 
           <strong class="bold">db=Depends(create_db_collections)</strong>): 
    history_dict = req.dict(exclude_unset=True)
    history_json = dumps(history_dict, 
           <strong class="bold">default=json_serialize</strong>_date)
    repo:BuyerRepository = BuyerRepository(db["buyers"])
    result = repo.add_purchase_history(id, 
           loads(history_json))  </pre>
			<p>The <code>json_serialize_date()</code> function<a id="_idIndexMarker458"/> becomes part of the JSON serialization process of the <code>dumps()</code> method but only handles the temporal type conversion while transforming the <code>buyer</code> details into JSON objects. It is applied in the <em class="italic">INSERT</em> and <em class="italic">UPDATE</em> transactions of the repository class to extract the serialized JSON string equivalent of the <code>BuyerReq</code>, <code>PurchaseHistoryReq</code>, and <code>PurchaseStatusReq</code> models. </p>
			<p>Now, another custom converter is applied in the data retrievals of the <code>list_all_buyer()</code> and <code>get_buyer()</code> methods:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/buyer/list/all")</strong>
def list_all_buyer(<strong class="bold">db=Depends(create_db_collections)</strong>): 
  repo:BuyerRepository = BuyerRepository(db["buyers"])
  buyers = repo.get_all_buyer() 
  return loads(dumps(buyers, <strong class="bold">default=json_serialize_oid</strong>))
<strong class="bold">@router.get("/buyer/get/{id}")</strong>
def get_buyer(id:int, <strong class="bold">db=Depends(create_db_collections)</strong>): 
  repo:BuyerRepository = BuyerRepository(db["buyers"])
  buyer = repo.get_buyer(id)
  return loads(dumps(buyer, <strong class="bold">default=json_serialize_oid</strong>))</pre>
			<p>The data <a id="_idIndexMarker459"/>models involved in our query transactions are data classes, so the results of the two preceding query methods have already been mapped and transformed into JSON format. However, unfortunately, they’re not JSON-able enough for the FastAPI framework. Aside from BSON <code>datetime</code> types, the PyMongo ODM cannot automatically convert <code>ObjectId</code> into a default type in Python, thus throwing <code>ValueError</code> during data retrieval from MongoDB. To fix this problem, <code>dumps()</code>needs a custom serializer, such as <code>json_serialize_oid()</code>, to convert all <code>ObjectId</code> parameters in MongoDB into FastAPI transitions. It also converts BSON <code>datetime</code> values into Python <code>date</code> values following the <em class="italic">ISO-8601</em> format. The valid JSON string from <code>dumps()</code> will enable the <code>loads()</code> method to produce a JSON-able result for the FastAPI services. The complete API services can be found in the <code>/api/buyer.py</code> script file.</p>
			<p>After complying with all the<a id="_idIndexMarker460"/> requirements, PyMongo can help store and manage all the information using the MongoDB server. However, the driver only works for synchronous CRUD transactions. If we opt for an asynchronous way of implementing CRUD, we must always resort to the Motor driver.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor164"/>Creating async CRUD transactions using Motor</h1>
			<p>Motor is an asynchronous driver that relies <a id="_idIndexMarker461"/>on the AsyncIO environment of the FastAPI. It wraps PyMongo to produce non-blocking and coroutine-based classes<a id="_idIndexMarker462"/> and methods needed to create asynchronous repository layers. It is almost like PyMongo when it comes to <a id="_idIndexMarker463"/>most of the requirements except for the database connectivity and repository implementation.</p>
			<p>But before we proceed, we need to install the <code>motor</code> extension using the following <code>pip</code> command:</p>
			<pre>pip install motor</pre>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor165"/>Setting up the database connectivity</h2>
			<p>Using the <code>AsyncIO</code> platform <a id="_idIndexMarker464"/>of the FastAPI, the Motor driver opens a connection to the MongoDB database through its <code>AsyncIOMotorClient</code> class. When instantiated, the default connection credential is always <code>localhost</code> at port <code>27017</code>. Alternatively, we can specify the new details in <code>str</code> format through its constructor. The following script shows how to create a global <code>AsyncIOMotorClient</code> reference with the specified database credentials:</p>
			<pre class="source-code">
<strong class="bold">from motor.motor_asyncio import AsyncIOMotorClient</strong>
def create_async_db():
    <strong class="bold">global client</strong>
    <strong class="bold">client = AsyncIOMotorClient(str("localhost:27017"))</strong>
def create_db_collections():
    db = client.obrs
    buyers = db["buyer"]
    users = db["login"]
    return {"users": users, "buyers": buyers}
def close_async_db(): 
    client.close()</pre>
			<p>The format of the database URI is a string with a colon (<code>:</code>) in between the details. Now, the application needs the<a id="_idIndexMarker465"/> following Motor methods to start the database transactions: </p>
			<ul>
				<li><code>create_async_db()</code>: A method for establishing the database connection and loading schema definitions</li>
				<li><code>close_async_db()</code>: A method for closing the connection</li>
			</ul>
			<p><code>APIRouter</code> will require event handlers to manage these two core methods as application-level events. Later, we will register <code>create_async_db()</code> as a startup event and <code>close_async_db()</code> as a shutdown event. On the other hand, the <code>create_db_collections()</code> method creates some references to the <code>login</code> and <code>buyer</code> collections, which will be needed by the repository transactions later. </p>
			<p>In general, creating<a id="_idIndexMarker466"/> the database connection and getting the reference to the document collections do not require the <code>async/await</code> expression since no I/O is involved in the process. These methods can be found in the <code>/db_config/motor_config.py</code> script file. It is time now to create Motor's repository layer.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor166"/>Creating the model layer</h2>
			<p>PyMongo and Motor share the <a id="_idIndexMarker467"/>same approaches in creating both the request and data models. All base models, data classes, validators, and serializers used by PyMongo also apply to Motor connectivity.</p>
			<h3>Building the asynchronous repository layer</h3>
			<p>When it comes to the<a id="_idIndexMarker468"/> CRUD implementation, both PyMongo and Motor have some slight differences in the syntax but a considerable difference in the performance of each transaction. Their helper methods for inserting, updating, and deleting documents, including the necessary method parameters, are all the same, except that Motor has the non-blocking versions. Invoking the non-blocking Motor methods inside the repository requires an async/await expression. Here is an asynchronous version of PyMongo’s <code>BuyerRepository</code>:</p>
			<pre class="source-code">
class BuyerRepository: 
    
    def __init__(self, buyers): 
        self.buyers = buyers
    
    <strong class="bold">async</strong> def insert_buyer(self, users, 
           details:Dict[str, Any]) -&gt; bool: 
        try:
           user = await users.find_one({"_id": 
                details["user_id"]})
           … … … … …
           else: 
               <strong class="bold">await self.buyers.insert_one(details)</strong>
           … … … … …
        return True
    
    <strong class="bold">async</strong> def add_purchase_history(self, id:int, 
            details:Dict[str, Any]): 
        try:
            … … … … …
            <strong class="bold">await self.buyers.update_one({"buyer_id": id},</strong>
                   <strong class="bold">{"$set":{"purchase_history": </strong>
                     <strong class="bold">buyer["purchase_history"]}})</strong>
            … … … … …
        return True</pre>
			<p><code>insert_buyer()</code> in the <a id="_idIndexMarker469"/>preceding code block is defined as <code>async</code> because <code>insert_one()</code> is a non-blocking operation that requires an <code>await</code> invocation. The same goes for <code>add_purchase_history()</code>, which updates the <code>purchase_history</code> embedded documents using the non-blocking <code>update_one()</code>:</p>
			<pre class="source-code">
    <strong class="bold">async</strong> def get_all_buyer(self):
        <strong class="bold">cursor = self.buyers.find()</strong>
        buyers = [asdict(Buyer(**json.loads(dumps(b)))) 
           for b in <strong class="bold">await cursor.to_list(length=None)</strong>]
        return buyers
    
    <strong class="bold">async</strong> def get_buyer(self, id:int): 
        buyer = <strong class="bold">await self.buyers.find_one(</strong>
                    <strong class="bold">{"buyer_id": id})</strong>
        return asdict(Buyer(**json.loads(dumps(buyer))))</pre>
			<p>The <code>delete_many()</code> and <code>find_one()</code> operations are also invoked through an <code>await</code> expression. However, <code>find()</code> in Motor is not asynchronous and behaves differently than it does with PyMongo. The reason is that <code>find()</code> is not an I/O operation in Motor, and it returns an <code>AsyncIOMotorCursor</code> or asynchronous cursor, an iterable type that <a id="_idIndexMarker470"/>contains all the BSON documents. We apply <code>async</code> to the cursor when retrieving all its stored documents. The <code>get_all_buyer()</code> transaction in the preceding code shows how we call the <code>find()</code> operation and invoke the cursor to extract the necessary documents for JSON transformation. This repository class can be found in the <code>/repository/motor/buyer.py</code> script file. Let us now apply these CRUD transactions to our API services.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor167"/>Running the CRUD transactions</h2>
			<p>For the repository to work <a id="_idIndexMarker471"/>with <code>APIRouter</code>, we need to create two event handlers to manage the database connection and document collection retrieval. The first event, which is the startup event that the Uvicorn server executes before the application runs, should trigger the <code>create_async_db()</code> method’s execution to instantiate <code>AsyncIOMotorClient</code> and make references to the collections. The second event, which is the shutdown event, runs when the Uvicorn server is shutting down and should trigger the <code>close_async_db()</code> execution to close the connection. <code>APIRouter</code> has an <code>add_event_handler()</code> method to create these two event handlers. The following is a portion of the <code>APIRouter</code> script that shows how to prepare the database connection for the <code>BuyerRepository</code> transactions:</p>
			<pre class="source-code">
… … … … … …
<strong class="bold">from db_config.motor_config import create_async_db,</strong>
  <strong class="bold">create_db_collections, close_async_db</strong>
… … … … … …
router = APIRouter()
<strong class="bold">router.add_event_handler("startup", </strong>
            <strong class="bold">create_async_db)</strong>
<strong class="bold">router.add_event_handler("shutdown", </strong>
            <strong class="bold">close_async_db)</strong></pre>
			<p>The <code>"startup"</code> and <code>"shutdown"</code> values are pre-built configuration values and not just any arbitrary string values <a id="_idIndexMarker472"/>used to indicate the type of event handlers. We will discuss these event handlers in more detail in <a href="B17975_08.xhtml#_idTextAnchor229"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Coroutines, Events, and Message-Driven Transactions</em>. </p>
			<p>After setting these events handlers, the API services can now invoke the repository transactions asynchronously using an await/async expression. The validations and serialization utilities that are applied in PyMongo can also be utilized here in this version of <code>BuyerRepository</code>. The collections will be available to the API services upon injecting <code>create_db_collections()</code> into the API services. The <code>add_buyer()</code> API service showcases the implementation of an asynchronous REST transaction using the Motor driver:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/buyer/async/add")</strong>
<strong class="bold">async</strong> def add_buyer(req: BuyerReq, 
          <strong class="bold">db=Depends(create_db_collections)</strong>): 
    buyer_dict = req.dict(exclude_unset=True)
    buyer_json = dumps(buyer_dict, 
              default=json_serialize_date)
    repo:BuyerRepository = BuyerRepository(db["buyers"])
   
    result = <strong class="bold">await repo.insert_buyer(db["users"],</strong> 
                  <strong class="bold">loads(buyer_json))  </strong>
    if result == True: 
        return JSONResponse(content={"message":
            "add buyer successful"}, status_code=201) 
    else: 
        return JSONResponse(content={"message": 
            "add buyer unsuccessful"}, status_code=500)</pre>
			<p>Using PyMongo and Mongo drivers provides a minimal and exhaustive implementation of the MongoDB transactions. The core implementation of every CRUD transaction varies from one developer to another, and the approaches that are used to scrutinize and analyze the processes<a id="_idIndexMarker473"/> involved are managed in different ways. Also, there are no established standards for defining the document fields, such as <em class="italic">data uniqueness</em>, <em class="italic">the length of the field value</em>, <em class="italic">the value range</em>, and even the idea of adding a <em class="italic">unique ID</em>. To address these issues surrounding PyMongo and Motor, let us explore other ways of opening a connection to MongoDB to create <a id="_idIndexMarker474"/>CRUD transactions, such as using an <strong class="bold">ODM</strong>.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor168"/>Implementing CRUD transactions using MongoEngine</h1>
			<p>MongoEngine is an ODM that uses <a id="_idIndexMarker475"/>PyMongo to create an easy-to-use framework that can assist in managing MongoDB documents. It offers API <a id="_idIndexMarker476"/>classes that can help generate model classes using its field types and attribute metadata. It provides a declarative way of creating and structuring the embedded documents. </p>
			<p>Before we explore this ODM, we need to install it using the following <code>pip</code> command:</p>
			<pre>pip install mongoengine</pre>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor169"/>Establishing database connection</h2>
			<p>MongoEngine has one<a id="_idIndexMarker477"/> of the most straightforward ways to establish a connection. Its <code>mongoengine</code> module has a <code>connect()</code> helper method that connects to the MongoDB database when it’s given the appropriate database connections. Our application must have a generator method to create a reference to the database connection and close this created connection after the transactions expire. The following script showcases the MongoEngine database connectivity:</p>
			<pre class="source-code">
<strong class="bold">from mongoengine import connect</strong>
def <strong class="bold">create_db</strong>():
    try:
        <strong class="bold">db = connect(db="obrs", host="localhost", </strong>
                 <strong class="bold">port=27017)</strong>
        yield db
    finally: 
        <strong class="bold">db.close()</strong></pre>
			<p>The <code>connect()</code> method <a id="_idIndexMarker478"/>has a mandatory first parameter, named <code>db</code>, which indicates the name of the database. The remaining parameters refer to the other remaining details of the database connection, such as <code>host</code>, <code>port</code>, <code>username</code>, and <code>password</code>. This configuration can be found in the <code>/db_config/mongoengine_config.py</code> script file. Let us now create data models for our MongoEngine repository.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor170"/>Building the model layer</h2>
			<p>MongoEngine provides a<a id="_idIndexMarker479"/> convenient and declarative way of mapping BSON documents to the model classes through its <code>Document</code> API class. A model class must subclass <code>Document</code> to inherit the structure and properties of a qualified and valid MongoDB document. The following is a <code>Login</code> definition that’s been created using the <code>Document</code> API class:</p>
			<pre class="source-code">
<strong class="bold">from mongoengine import Document, StringField, </strong>
         <strong class="bold">SequenceField, EmbeddedDocumentField</strong>
import json
class <strong class="bold">Login(Document)</strong>: 
    id = <strong class="bold">SequenceField</strong>(required=True, primary_key=True)
    username = <strong class="bold">StringField</strong>(db_field="username", 
         max_length=50, required=True, unique=True)
    password = <strong class="bold">StringField</strong>(db_field="password", 
         max_length=50, required=True)
    profile = <strong class="bold">EmbeddedDocumentField</strong>(UserProfile, 
         required=False)
    
    def <strong class="bold">to_json</strong>(self):
            return {
            <strong class="bold">"id": self.id</strong>,
            <strong class="bold">"username": self.username</strong>,
            <strong class="bold">"password": self.password</strong>,
            <strong class="bold">"profile": self.profile</strong>
        }
        
    @classmethod
    def <strong class="bold">from_json</strong>(cls, json_str):
        <strong class="bold">json_dict = json.loads(json_str)</strong>
        return <strong class="bold">cls(**json_dict)</strong></pre>
			<p>Unlike PyMongo and the Motor drivers, MongoEngine can define class attributes using its <code>Field</code> classes and their properties. Some of its <code>Field</code> classes include <code>StringField</code>, <code>IntField</code>, <code>FloatField</code>, <code>BooleanField</code>, and <code>DateField</code>. These can declare the <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, and <code>datetime.date</code> class attributes, respectively. </p>
			<p>Another convenient<a id="_idIndexMarker480"/> feature that this ODM has is that it can create <code>SequenceField</code>, which behaves the same as the <code>auto_increment</code> column field in a relational database or <code>Sequence</code> in an object-relational database. The <code>id</code> field of a model class should be declared as <code>SequenceField</code> so that it serves as the primary key of the document. Like in a typical sequence, this field has utilities to increment its value or reset it to zero, depending on what document record must be accessed. </p>
			<p>Other than the field types, field classes can also provide field arguments to attributes such as <code>choices</code>, <code>required</code>, <code>unique</code>, <code>min_value</code>, <code>max_value</code>, <code>max_length</code>, and <code>min_length</code> to give constraints to the field values. The <code>choices</code> parameter, for instance, accepts an iterable of string values that will serve as an enumeration. The <code>required</code> parameter indicates whether the field always needs a field value, while the <code>unique</code> parameter means the field value has no duplicates in the collection. Violating the <code>unique</code> parameter will lead to the following error message:</p>
			<pre>Tried to save duplicate unique keys (E11000 duplicate key error collection: obrs.login index: username_...)</pre>
			<p><code>min_value</code> and <code>max_value</code>, on the other hand, indicate the minimum and maximum values for the numeric fields, respectively. <code>min_length</code> specifies the minimum length of a string value, while <code>max_length</code> sets the maximum string length. The <code>db_field</code> parameter, on the other hand, can also be applied when specifying another document field name instead of the class attribute name. The given <code>Login</code> class also has <code>username</code> and <code>password</code> fields defined to hold string values, an id primary key defined as <code>SequenceField</code>, and an embedded document field to establish document association.</p>
			<h3>Creating document association</h3>
			<p>The <code>profile</code> field <a id="_idIndexMarker481"/>of <code>Login</code> creates a one-to-one association between the <code>Login</code> document and <code>UserProfile</code>. But before the association can work, we need to define the <code>profile</code> field as being of the <code>EmbeddedDocumentField</code> type and <code>UserProfile</code> as being of the <code>EmbeddedDocument</code> type. The<a id="_idIndexMarker482"/> following is the complete blueprint of <code>UserProfile</code>: </p>
			<pre class="source-code">
class <strong class="bold">UserProfile(EmbeddedDocument)</strong>:
   firstname = StringField(db_field="firstname", 
          max_length=50, required=True)
   lastname = StringField(db_field="lastname", 
          max_length=50, required=True)
   middlename = StringField(db_field="middlename", 
          max_length=50, required=True)
   position = StringField(db_field="position", 
          max_length=50, required=True)
   date_approved = DateField(db_field="date_approved", 
          required=True)
   status = BooleanField(db_field="status", required=True)
   level = IntField(db_field="level", required=True)
   login_id = IntField(db_field="login_id", required=True)
   booksale = EmbeddedDocumentListField(BookForSale, 
           required=False)
   
   def to_json(self):
            return {
            "firstname": self.firstname,
            "lastname": self.lastname,
            "middlename": self.middlename,
            "position": self.position,
            "date_approved": 
               self.date_approved.strftime("%m/%d/%Y"),
            "status": self.status,
            "level": self.level,
            "login_id": self.login_id,
            "books": self.books
        }
        
   @classmethod
   def from_json(cls, json_str):
        json_dict = json.loads(json_str)
        return cls(**json_dict)</pre>
			<p>The <code>EmbeddedDocument</code> API is a <code>Document</code> without an <code>id</code> and has no collection of its own. Subclasses of this API are model classes that have been created to be part of a core document structure, such as <code>UserProfile</code> being part of the <code>Login</code> details. Now, the field that refers to this document has a <code>required</code> property set to <code>False</code> since an embedded document can’t be present at all times.</p>
			<p>On the other hand, a field <a id="_idIndexMarker483"/>declared as <code>EmbeddedDocumentList</code> is used to create a many-to-one association between documents. The preceding <code>UserProfile</code> class is strongly connected to a list of <code>BookForSale</code> embedded documents because of its declared <code>booksale</code> field. Again, the field type should always set its <code>required</code> property to <code>False</code> to avoid problems when dealing with empty values.</p>
			<h3>Applying custom serialization and deserialization</h3>
			<p>There are no built-in hooks for validation and serialization <a id="_idIndexMarker484"/>in this ODM. Every model class in the <em class="italic">online book reselling</em> application has implemented a <code>from_json()</code> class method that converts JSON details into a valid <code>Document</code> instance. When converting the BSON document into a JSON object, model classes must have the custom <code>to_json()</code> instance method, which builds the JSON structure and automatically transforms the BSON <code>datetime</code> into JSON-able <code>date</code> objects through formatting. Let us now create the repository layer using the model classes.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor171"/>Implementing the CRUD transactions</h2>
			<p>MongoEngine<a id="_idIndexMarker485"/> provides the most convenient and straightforward approach to building the repository layer for the application. All its operations come from the <code>Document</code> model class and they are easy to use. <code>LoginRepository</code> uses the ODM to implement its CRUD transactions:</p>
			<pre class="source-code">
from typing import Dict, Any
<strong class="bold">from models.data.mongoengine import Login</strong>
class LoginRepository: 
     
    def <strong class="bold">insert_login</strong>(self, details:Dict[str, Any]) -&gt; bool: 
        try:
            login = Login(**details)
            <strong class="bold">login.save()</strong>
        except Exception as e:
            print(e)
            return False 
        return True
    
    def <strong class="bold">update_password</strong>(self, id:int, newpass:str) -&gt; bool: 
       try:
          login = Login.objects(id=id).get()
          <strong class="bold">login.update(password=newpass)</strong>
       except: 
           return False 
       return True
   
    def <strong class="bold">delete_login</strong>(self, id:int) -&gt; bool: 
        try:
            login = Login.objects(id=id).get()
            <strong class="bold">login.delete()</strong>
        except: 
            return False 
        return True</pre>
			<p>It only takes two lines for the <code>insert_login()</code> method to save the <code>Login</code> document. After creating the <code>Login</code> instance with the necessary document details, we simply call the <code>save()</code> method of the <code>Document</code> instance to pursue the insert transaction. When it comes to modifying some document values, the <code>Document</code> API class has an <code>update()</code> method that manages changes in state for every class attribute. But first, we need to find the document using the <code>objects()</code> utility method, which retrieves document structures <a id="_idIndexMarker486"/>from the collection. This <code>objects()</code> method can fetch a document by providing its parameter with an <code>id</code> field value or extracting a list of document records by supplying the method with a generic search expression. The instance of the retrieved document must invoke its <code>update()</code> method to pursue the modification of some, if not all, of its field values. The given <code>update_password()</code> method updates the password field of <code>Login</code>, which gives us a good template regarding how to pursue update operations on other field attributes.   </p>
			<p>On the other hand, <code>delete_login()</code> shows how to delete a <code>Login</code> document from its collection after it searches for the object using a simple call to the instance’s <code>delete()</code> method. The following script shows how to perform query transactions in MongoEngine:</p>
			<pre class="source-code">
    def <strong class="bold">get_all_login</strong>(self):
        <strong class="bold">login = Login.objects()</strong>
        <strong class="bold">login_list = [l.to_json() for l in login]</strong>
        return login_list
    
    def get_login(self, id:int): 
        <strong class="bold">login = Login.objects(id=id).get()</strong>
        return <strong class="bold">login.to_json()</strong></pre>
			<p>The only way to perform single- or multiple-document retrieval is to utilize the <code>objects()</code> method. There is no need to implement JSON converters for the query results because every <code>Document</code> model class has a <code>to_json()</code> method to provide the JSON-able equivalent of the instance. The given <code>get_all_login()</code> transaction uses list comprehension to create a list of JSON documents from the result of <code>objects()</code>, while the <code>get_login()</code> method invokes <code>to_json()</code> after extracting a single document.</p>
			<h3>Managing the embedded documents</h3>
			<p>It is easier to implement<a id="_idIndexMarker487"/> document associations with an ODM than the core PyMongo and Motor database drivers. Since the operations of MongoEngine are comfortable to use, it takes only a few lines to manage the embedded documents. In the following <code>UserProfileRepository</code> script, <code>insert_profile()</code> shows how adding a <code>UserProfile</code> detail to the <code>Login</code> document can be done<a id="_idIndexMarker488"/> by performing a simple object search and an <code>update()</code> call:</p>
			<pre class="source-code">
from typing import Dict, Any
<strong class="bold">from models.data.mongoengine import Login, UserProfile, </strong>
      <strong class="bold">BookForSale</strong>
class UserProfileRepository(): 
    
    def <strong class="bold">insert_profile</strong>(self, login_id:int, 
             details:Dict[str, Any]) -&gt; bool: 
        try:
            profile = UserProfile(**details)
            login = Login.objects(id=login_id).get()
            <strong class="bold">login.update(profile=profile)</strong>
        except Exception as e:
            print(e)
            return False 
        return True
    
    def add_book_sale(self, login_id:int, 
             details:Dict[str, Any]): 
        try:
            sale = BookForSale(**details)
            <strong class="bold">login = Login.objects(id=login_id).get()</strong>
            <strong class="bold">login.profile.booksale.append(sale)         </strong>
            <strong class="bold">login.update(profile=login.profile)</strong>
        except Exception as e:
            print(e)
            return False 
        return True</pre>
			<p>Likewise, the given <code>add_book_sale()</code> transaction creates a many-to-one association between <code>BookForSale</code> and <code>UserProfile</code> using the same approach applied in <code>insert_profile() </code>with an additional List's <code>append()</code> operation.</p>
			<p>Querying the embedded documents is also feasible in MongoEngine. The ODM has a <code>filter()</code> method that uses <em class="italic">field lookup syntax</em> to refer to a specific document structure or list of embedded documents. This field lookup syntax consists of the <em class="italic">field name of the embedded document</em>, followed by a <em class="italic">double underscore</em> in place of the dot in the usual object attribute <a id="_idIndexMarker489"/>access syntax. Then, it has <em class="italic">another double underscore</em> to cater to some <em class="italic">operators</em>, such as <code>lt</code>, <code>gt</code>, <code>eq</code>, and <code>exists</code>. In the following code, <code>get_all_profile()</code>uses the <code>profile__login_id__exists=True</code> field lookup to filter all <code>user_profile</code> embedded documents that have valid <code>login</code> structures. However, the <code>get_profile()</code> transaction does not need to use <code>filter()</code> and field lookups because it can simply access the specific login docu<a id="_idTextAnchor172"/>ment to fetch its profile details:</p>
			<pre class="source-code">
     def <strong class="bold">get_all_profile</strong>(self):
        profiles = Login.objects.filter(
               <strong class="bold">profile__login_id__exists=True</strong>)
        profiles_dict = list(
              map(lambda h: h.profile.to_json(), 
                Login.objects().filter(
                    <strong class="bold">profile__login_id__exists=True</strong>)))
        return profiles_dict
    
    def get_profile(self, login_id:int): 
        <strong class="bold">login = Login.objects(id=login_id).get()</strong>
        profile = <strong class="bold">login.profile.to_json()</strong>
        return profile</pre>
			<p>The preceding query transactions <a id="_idIndexMarker490"/>are just simple implementations compared to some other complex MongoEngine queries, which involve complicated embedded document structures that require complex field lookup syntax. Let us now apply the CRUD transactions to our API services.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor173"/>Running the CRUD transactions</h2>
			<p>CRUD will not work without passing our <code>create_db()</code> method to the <em class="italic">startup</em> event and <code>disconnect_db()</code> to the <em class="italic">shutdown</em> event. The former will open the MongoDB connection during the<a id="_idIndexMarker491"/> Uvicorn startup, while the latter will close it during server shutdown.</p>
			<p>The following script shows the application’s <code>profile</code> router with a <code>create_profile()</code> REST service that asks clients for a profile detail, given a specific login record, and pursues the insert transaction using <code>UserProfileRepository</code>: </p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
from fastapi.responses import JSONResponse
from models.request.profile import UserProfileReq, 
         BookForSaleReq
<strong class="bold">from repository.mongoengine.profile import </strong>
         <strong class="bold">UserProfileRepository</strong>
<strong class="bold">from db_config.mongoengine_config import create_db</strong>
router = APIRouter()
<strong class="bold">@router.post("/profile/login/add", </strong>
      <strong class="bold">dependencies=[Depends(create_db)]</strong>)
def create_profile(login_id:int, req:UserProfileReq): 
    profile_dict = req.dict(exclude_unset=True)
    repo:UserProfileRepository = UserProfileRepository()
    result = repo.insert_profile(login_id, profile_dict)
    if result == True: 
        return req 
    else: 
        return JSONResponse(content={"message": 
          "insert profile unsuccessful"}, status_code=500) </pre>
			<p><code>create_profile()</code> is a standard API service that deals with MongoEngine’s synchronous <code>insert_profile()</code> transaction. When it comes to asynchronous REST services, it is not advisable to <a id="_idIndexMarker492"/>use MongoEngine because its platform only works with synchronous ones. In the next section, we will discuss an ODM that’s popular in building an asynchronous repository layer.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor174"/>Implementing async transactions using Beanie</h1>
			<p><strong class="bold">Beanie</strong> is a non-boilerplate mapper that utilizes the core features of Motor and Pydantic. This ODM offers a more<a id="_idIndexMarker493"/> straightforward <a id="_idIndexMarker494"/>approach to implementing asynchronous CRUD transactions than its precursor, the Motor driver.</p>
			<p>To use Beanie, we need to install it using the following <code>pip</code> command:</p>
			<pre>pip install beanie</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">Installing Beanie may uninstall the current version of your Motor module because it sometimes requires lower version of Motor module. Pursuing this will produce errors in your existing Motor transactions.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor175"/>Creating the database connection</h2>
			<p>Beanie uses the Motor driver to open a <a id="_idIndexMarker495"/>database connection to MongoDB. Instantiating the Motor’s <code>AsyncIOMotorClient</code> class with the database URL is the first step of configuring it. But what makes Beanie unique compared to other ODMs is how it pre-initializes and pre-recognizes the model classes that will be involved in a CRUD transaction. The ODM has an asynchronous <code>init_beanie()</code> helper method that initiates the model class initialization using the database name. Calling this method will also set up the collection-domain mapping, where all the model classes are registered in the <code>document_models</code> parameter of <code>init_beanie()</code>. The following script shows the database configuration that’s required to access our MongoDB database, <code>obrs</code>:</p>
			<pre class="source-code">
from motor.motor_asyncio import AsyncIOMotorClient
from beanie import init_beanie
from models.data.beanie import Cart, Order, Receipt
async def db_connect():
    global client
    <strong class="bold">client = </strong>
     <strong class="bold">AsyncIOMotorClient(f"mongodb://localhost:27017/obrs")</strong>
    <strong class="bold">await init_beanie(client.obrs, </strong>
         <strong class="bold">document_models=[Cart, Order, Receipt])</strong>
    
async def db_disconnect():
     <strong class="bold">client.close()</strong></pre>
			<p>Here, <code>db_connect()</code> uses an async/await expression because its method invocation to <code>init_beanie()</code> is asynchronous. <code>db_disconnect()</code> will close the database connection by calling the <code>close()</code> method of the <code>AsyncIOMotorClient</code> instance. Both of these methods <a id="_idIndexMarker496"/>are executed as events, just like in MongoEngine. Their implementation can be found in the <code>/db_config/beanie_config.py</code> script file. Let us now create the model classes.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor176"/>Defining the model classes</h2>
			<p>The Beanie ODM has a <code>Document</code> API class that’s<a id="_idIndexMarker497"/> responsible for defining its model classes, mapping them to MongoDB collections, and handling repository transactions, just like in MongoEngine. Although there is no <code>Field</code> directive for defining class attributes, the ODM supports Pydantic’s validation and parsing rules and <code>typing</code> extension for declaring models and their attributes. But it also has built-in validation and encoding features, which can be used together with Pydantic. The following script shows how to define Beanie model classes while it’s being configured:</p>
			<pre class="source-code">
from typing import Optional, List
<strong class="bold">from beanie import Document</strong>
<strong class="bold">from bson import datetime </strong>
class <strong class="bold">Cart(Document)</strong>:
    id: int 
    book_id: int 
    user_id: int
    qty: int
    <strong class="bold">date_carted: datetime.datetime</strong>
    discount: float
 
    class <strong class="bold">Collection</strong>:
        name = "cart"
    … … … … … …
                
class <strong class="bold">Order(Document)</strong>:
    id: int 
    user_id: int
    <strong class="bold">date_ordered: datetime.datetime</strong>
    orders: List[Cart] = list()
        
    class <strong class="bold">Collection</strong>:
        name = "order"
    … … … … … …
        
class <strong class="bold">Receipt(Document)</strong>: 
    id: int 
    <strong class="bold">date_receipt: datetime.datetime </strong>
    total: float 
    payment_mode: int
    order: Optional[Order] = None
    
    class <strong class="bold">Collection</strong>:
        name = "receipt"
    class <strong class="bold">Settings</strong>:
        <strong class="bold">use_cache = True</strong>
        cache_expiration_time =    
             datetime.timedelta(seconds=10)
        cache_capacity = 10</pre>
			<p>The <code>id</code> attribute of the given <code>Document</code> classes automatically translates into an <code>_id</code> value. This serves as the primary key of the document. Beanie allows you to replace the default <code>ObjectId</code> type of <code>_id</code> with another type, such as <code>int</code>, which is not possible in other ODMs. And with Motor, this ODM <a id="_idIndexMarker498"/>needs custom JSON serializers because it has difficulty converting BSON <code>datetime</code> types into Python <code>datetime.date</code> types during CRUD transactions.</p>
			<p>A document in Beanie can be configured by adding the <code>Collection</code> and <code>Settings</code> nested classes. The <code>Collection</code> class can replace the default name of the collection where the model is supposed to be mapped. It can also provide indexes to document fields if needed. The <code>Settings</code> inner class, on the other hand, can override existing BSON encoders, apply caching, manage concurrent updates, and add validation when the document is being saved. These three model classes include the collection configuration in their definitions to replace the names of their respective collections with their class names.</p>
			<h3>Creating the document associations</h3>
			<p>Python syntax, Pydantic rules, and API <a id="_idIndexMarker499"/>classes are used to establish links between documents in this mapper. To create a one-to-one association between <code>Order</code> and <code>Receipt</code>, for instance, we only need to set an <code>Order</code> field attribute that will link to a single <code>Receipt</code> instance. For many-to-one associations, such as the relationship between <code>Order</code> and <code>Cart</code>, the <code>Cart</code> document should only need a list field that will contain all the <code>Order</code> embedded documents. </p>
			<p>However, the ODM has a <code>Link</code> type, which can be used to define class fields to generate these associations. Its CRUD operations, such as <code>save()</code>, <code>insert()</code>, and <code>update()</code>, strongly support these <code>Link</code> types, so long as the <code>link_rule</code> parameter is provided in their parameters. For query transactions, the <code>find()</code> method can include the <code>Link</code> documents during document fetching, given that its <code>fetch_links</code> parameter is set to <code>True</code>. Now, let us implement the repository layer using the model classes.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor177"/>Implementing the CRUD transactions</h2>
			<p>Implementing repositories with<a id="_idIndexMarker500"/> Beanie is similar to how it’s done with MongoEngine – that is, it uses short and direct CRUD syntax due to the convenient helper methods like create(), update(), and delete(), provided by the <code>Document</code> API class. However, the Beanie mapper creates an asynchronous repository layer because all the API methods that are inherited by the model classes are non-blocking. The following code for the <code>CartRepository</code> class shows a sample implementation of an asynchronous repository class using this Beanie ODM:</p>
			<pre class="source-code">
from typing import Dict, Any
<strong class="bold">from models.data.beanie import Cart</strong>
class <strong class="bold">CartRepository</strong>: 
    
    async def <strong class="bold">add_item</strong>(self, 
             details:Dict[str, Any]) -&gt; bool: 
        try:
            <strong class="bold">receipt = Cart(**details)</strong>
            <strong class="bold">await receipt.insert()</strong>
        except Exception as e:
            print(e)
            return False 
        return True
    
    async def <strong class="bold">update_qty</strong>(self, id:int, qty:int) -&gt; bool: 
       try:
          <strong class="bold">cart = await Cart.get(id)</strong>
          <strong class="bold">await cart.set({Cart.qty:qty})</strong>
       except: 
           return False 
       return True
    
    async def <strong class="bold">delete_item</strong>(self, id:int) -&gt; bool: 
        try:
            <strong class="bold">cart = await Cart.get(id)</strong>
            <strong class="bold">await cart.delete()</strong>
        except: 
            return False 
        return True</pre>
			<p>The <code>add_item()</code> method showcases the use of the asynchronous <code>insert()</code>method to persist a newly created <code>Cart</code> instance. The <code>Document</code> API also has a <code>create()</code> method that works like <code>insert()</code>. Another option is to use the <code>insert_one()</code> class method instead of the instance methods. Moreover, adding multiple documents is allowed in this ODM<a id="_idIndexMarker501"/> because an <code>insert_many()</code> operation exists to pursue that kind of insert.</p>
			<p>Updating a document can be initiated using two methods, namely <code>set()</code> and <code>replace()</code>.<code>update_qty()</code> in the preceding script chooses the <code>set()</code> operation to update the current <code>qty</code> value of the items placed in a cart. </p>
			<p>When it comes to document removal, the ODM only has the <code>delete()</code> method to pursue the transactions. This is present in the <code>delete_item()</code> transaction in the preceding code.</p>
			<p>Retrieving a single document or a list of documents using this ODM is easy. No further serialization and cursor wrapping is needed during its query operations. When fetching a single document structure, the mapper provides the <code>get()</code> method if the fetching process only requires the <code>_id</code> field; it provides <code>find_one()</code> when the fetching process requires a conditional expression. Moreover, Beanie has a <code>find_all()</code> method that fetches all the documents without constraints and the <code>find()</code> method for retrieving data with<a id="_idIndexMarker502"/> conditions. The following code shows the query transaction for retrieving cart items from the database:</p>
			<pre class="source-code">
async def get_cart_items(self):
        return await Cart.find_all().to_list()
    
    async def get_items_user(self, user_id:int): 
        return await Cart.find(
              Cart.user_id == user_id).to_list()
    
    async def get_item(self, id:int): 
        return await Cart.get(id)</pre>
			<p>Both the <code>find()</code> and <code>find_all()</code> operations are used in the methods to return a <code>FindMany</code> object that has a <code>to_list()</code> utility that returns a list of JSON-able documents. Let us now apply our CRUD transactions to the API services.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor178"/>Running the repository transactions</h2>
			<p>The <code>CartRepository</code> methods will <a id="_idIndexMarker503"/>only run successfully if <code>db_connect()</code> from the configuration file is injected into the router. Although injecting it into each API service is acceptable, our solution prefers injecting the component into <code>APIRouter</code> using <code>Depends</code>:</p>
			<pre class="source-code">
<strong class="bold">from repository.beanie.cart import CartRepository</strong>
<strong class="bold">from db_config.beanie_config import db_connect</strong>
router = APIRouter(<strong class="bold">dependencies=[Depends(db_connect)]</strong>)
<strong class="bold">@router.post("/cart/add/item")</strong>
<strong class="bold">async</strong> def add_cart_item(req:CartReq): 
    <strong class="bold">repo:CartRepository = CartRepository()</strong>
    result = <strong class="bold">await repo.add_item(loads(cart_json))</strong>
          "insert cart unsuccessful"}, status_code=500)</pre>
			<p>The asynchronous <code>add_cart_item()</code> service asynchronously inserts the cart account into the database using <code>CartRepository</code>. </p>
			<p>Another asynchronous <a id="_idIndexMarker504"/>mapper that can integrate perfectly with FastAPI is <em class="italic">ODMantic</em>.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor179"/>Building async repository for FastAPI using ODMantic</h1>
			<p>The dependencies<a id="_idIndexMarker505"/> of Beanie and ODMantic come from Motor and Pydantic. ODMantic also utilizes Motor’s <code>AsyncIOMotorClient</code> class to open <a id="_idIndexMarker506"/>a database connection. It also uses Pydantic features for class attribute validation, Python’s typing <a id="_idIndexMarker507"/>extension for type hinting, and other Python components for management. But its edge over Beanie is that it complies with ASGI frameworks such as FastAPI.</p>
			<p>To pursue ODMantic, we need to install the extension using the following <code>pip</code> command:</p>
			<pre>pip install odmantic</pre>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor180"/>Creating the database connection</h2>
			<p>Setting up the database connectivity in ODMantic is the same as what we do with the Beanie mapper, except <a id="_idIndexMarker508"/>that the setup includes creating an engine that will handle all its CRUD operations. This engine is <code>AIOEngine</code> from the <code>odmantic</code> module, which requires both the motor client object and the database name to be created successfully. The following is a complete implementation of the database connectivity needed by the ODMantic mapper:</p>
			<pre class="source-code">
<strong class="bold">from odmantic import AIOEngine</strong>
<strong class="bold">from motor.motor_asyncio import AsyncIOMotorClient</strong>
def <strong class="bold">create_db_connection</strong>():
   global client_od
   client_od = 
     AsyncIOMotorClient(f"mongodb://localhost:27017/")
def <strong class="bold">create_db_engine</strong>():
   <strong class="bold">engine = AIOEngine(motor_client=client_od, </strong>
         <strong class="bold">database="obrs")</strong>
   return engine
def <strong class="bold">close_db_connection</strong>():
    client_od.close() </pre>
			<p>We need to create event <a id="_idIndexMarker509"/>handlers in <code>APIRouter</code> to run <code>create_db_connection()</code> and <code>close_db_connection()</code> for our repository transactions to work. Let us now implement the model layer of the ODM.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor181"/>Creating the model layer</h2>
			<p>ODMantic has a <code>Model</code> API class that provides properties to model classes when subclassed. It relies on Python types and BSON <a id="_idIndexMarker510"/>specifications to define the class attributes. When transforming field types, such as converting a BSON <code>datetime</code> value into a Python <code>datetime.date</code> value, the mapper allows you to add custom <code>@validator</code> methods into the model classes to implement the appropriate object serializer. Generally, ODMantic relies on the <code>pydantic</code> module when it comes to data validation, unlike in the Beanie mapper. The following is a standard ODMantic model class definition:</p>
			<pre class="source-code">
<strong class="bold">from odmantic import Model</strong>
<strong class="bold">from bson import datetime</strong>
class <strong class="bold">Purchase(Model)</strong>: 
    purchase_id: int
    buyer_id: int 
    book_id: int 
    items: int 
    price: float 
    <strong class="bold">date_purchased: datetime.datetime</strong>
    
    class <strong class="bold">Config</strong>:
        collection = "purchase"</pre>
			<p>For advanced configurations, we can<a id="_idIndexMarker511"/> add a nested <code>Config</code> class to the model class to set these additional options, such as the <code>collection</code> option, which replaces the default name of the collection with a custom one. We can also configure some familiar options, such as <code>json_encoders</code>, to convert one field type into another supported one.</p>
			<h3>Establishing document association</h3>
			<p>When creating <a id="_idIndexMarker512"/>associations, the typical Python approach of declaring fields so that they refer to an embedded document(s) is still applicable in this ODM. However, this ODM mapper has an <code>EmbeddedModel</code> API class to create a model with no <code>_id</code> field; this can be linked to another document. The <code>Model</code> classes, on the other hand, can define a field<a id="_idIndexMarker513"/> attribute that will refer to an <code>EmbeddedModel</code> class to establish a one-to-one association or a list of <code>EmbeddedModel</code> instances for a many-to-one association.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor182"/>Implementing the CRUD transactions</h2>
			<p>Creating the repository <a id="_idIndexMarker514"/>layer using ODMantic always requires the engine object that was created in the startup event. This is because all the CRUD operations that are needed will come from this engine. The following <code>PurchaseRepository</code> shows the operations from the <code>AIOEngine</code> object that we need to create CRUD transactions:</p>
			<pre class="source-code">
from typing import List, Dict, Any
from models.data.odmantic import Purchase
class PurchaseRepository: 
    
    def __init__(self, engine): 
        self.engine = engine
        
    async def insert_purchase(self, 
              details:Dict[str, Any]) -&gt; bool: 
        try:
           <strong class="bold">purchase = Purchase(**details)</strong>
           <strong class="bold">await self.engine.save(purchase)</strong>
                  
        except Exception as e:
            print(e)
            return False 
        return True</pre>
			<p>This <code>insert_purchase()</code> method shows the standard way to insert a record into the database using ODMantic. Through the engine’s <code>save()</code> method, we can persist one document at a time using the model class. <code>AIOEngine</code> also provides the <code>save_all()</code> method<a id="_idIndexMarker515"/> for inserting a list of multiple documents into the associated MongoDB collection. </p>
			<p>Now, there is no specific way to update transactions, but ODMantic allows you to fetch the record that needs to be updated. The following code can be used to update a record using ODMantic:</p>
			<pre class="source-code">
    async def update_purchase(self, id:int, 
              details:Dict[str, Any]) -&gt; bool: 
       try:
          <strong class="bold">purchase = await self.engine.find_one(</strong>
                <strong class="bold">Purchase, Purchase.purchase_id == id)</strong>
                  
          for key,value in details.items():
            setattr(purchase,key,value)
          
          <strong class="bold">await self.engine.save(purchase)</strong>
       except Exception as e:
           print(e) 
           return False 
       return True</pre>
			<p>After accessing and changing the field values, the fetched document object will be re-saved using the <code>save()</code> method to reflect the changes in physical storage. The complete process is implemented in the preceding <code>update_purchase()</code> transaction:</p>
			<pre class="source-code">
     async def delete_purchase(self, id:int) -&gt; bool: 
        try:
            <strong class="bold">purchase = await self.engine.find_one(</strong>
                <strong class="bold">Purchase, Purchase.purchase_id == id) </strong>
            <strong class="bold">await self.engine.delete(purchase)</strong>
        except: 
            return False 
        return True</pre>
			<p>When it comes to document<a id="_idIndexMarker516"/> removal, you must fetch the document to be deleted. We pass the fetched document object to the <code>delete()</code> method of the engine to pursue the removal process. This implementation is shown in the <code>delete_purchase()</code> method.</p>
			<p>When fetching a single document so that it can be updated or deleted, <code>AIOEngine</code> has a <code>find_one()</code> method that requires two arguments: the model class name and the conditional expression, which involves either the <code>id</code> primary key or some non-unique fields. All the fields can be accessed like class variables. The following <code>get_purchase()</code> method retrieves a <code>Purchase</code> document with the specified <code>id</code>:</p>
			<pre class="source-code">
    async def get_all_purchase(self):
        purchases = await self.engine.find(Purchase)
        return purchases
            
    async def get_purchase(self, id:int): 
        <strong class="bold">purchase = await self.engine.find_one(</strong>
            <strong class="bold">Purchase, Purchase.purchase_id == id) </strong>
        return purchase</pre>
			<p>The engine has a <code>find()</code> operation to retrieve all <code>Purchase</code> documents, for instance, from the database. It only<a id="_idIndexMarker517"/> needs an argument – the name of the model class. Let now apply our repository layer to the API services.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor183"/>Running the CRUD transaction</h2>
			<p>For the repository <a id="_idIndexMarker518"/>classes to run, all the router services must be asynchronous. Then, we need to create the startup and shutdown event handlers for <code>create_db_connection()</code> and <code>close_db_connection()</code>, respectively, to open the connection for repository transactions. Lastly, for the repository class to work, <code>create_db_engine()</code> must be injected into each API service to derive the engine object:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
from fastapi.responses import JSONResponse
from models.request.purchase import PurchaseReq
from repository.odmantic.purchase import PurchaseRepository
<strong class="bold">from db_config.odmantic_config import create_db_engine, </strong>
    <strong class="bold">create_db_connection, close_db_connection</strong>
from datetime import date, datetime
from json import dumps, loads
router = APIRouter()
router.add_event_handler("startup", <strong class="bold">create_db_connection</strong>)
router.add_event_handler("shutdown", <strong class="bold">close_db_connection</strong>)
<strong class="bold">@router.post("/purchase/add")</strong>
<strong class="bold">async</strong> def add_purchase(req: PurchaseReq, 
          <strong class="bold">engine=Depends(create_db_engine)</strong>): 
     purchase_dict = req.dict(exclude_unset=True) 
     purchase_json = dumps(purchase_dict, 
                default=json_serial)
     repo:PurchaseRepository = PurchaseRepository(<strong class="bold">engine</strong>)
     result = await 
            repo.insert_purchase(loads(purchase_json))
     if result == True: 
        return req 
     else: 
        return JSONResponse(content={"message": 
          "insert purchase unsuccessful"}, status_code=500)
     return req</pre>
			<p>At this point, we should know how to compare these mappers and drivers when it comes to the setup and<a id="_idIndexMarker519"/> procedures needed to manage MongoDB documents. Each has its strengths and weaknesses based on the code they produce and the performance, popularity, support, and complexity of its solution. Some may work on other requirements, while others may not. The final ODM we will cover focuses on being the lightest and least obtrusive mapper. It aims to fit into an existing application without generating syntax and performance problems. </p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor184"/>Creating CRUD transactions using MongoFrames</h1>
			<p>If you are tired of using<a id="_idIndexMarker520"/> complicated and heavy-loaded ODMs, then MongoFrames is ideal for your requirements. MongoFrames is <a id="_idIndexMarker521"/>one of the newest ODMs and is very convenient to use, especially when building a new repository layer for an already existing complex and legacy FastAPI microservice application. But this mapper can only create synchronous and standard types of CRUD transactions.</p>
			<p>But before we proceed, let us install the extension module using <code>pip</code>:</p>
			<pre>pip install MongoFrames</pre>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor185"/>Creating the database connection</h2>
			<p>The MongoFrames platform runs <a id="_idIndexMarker522"/>on top of PyMongo, which is why it cannot build an asynchronous repository layer. To create the database connection, it uses the <code>MongoClient</code> API class from the <code>pymongo</code> module, with the database URL in string format. Unlike in the other ODMs, where we create a client variable, in this mapper, we access the <code>variable _client</code> class from the <code>Frame</code> API class to refer to the client connection object. The following code shows <code>create_db_client()</code>, which will open the database connection for our app, and <code>disconnect_db_client()</code>, which will close this connection:</p>
			<pre class="source-code">
<strong class="bold">from pymongo import MongoClient</strong>
<strong class="bold">from mongoframes import Frame</strong>
def create_db_client():
    <strong class="bold">Frame._client = </strong>
        <strong class="bold">MongoClient('mongodb://localhost:27017/obrs')</strong>
        
def disconnect_db_client():
    <strong class="bold">Frame._client.close()</strong></pre>
			<p>Just like in the previous ODMs, we need event handlers to execute these core methods to start building the model and repository layers.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor186"/>Building the model layer</h2>
			<p>The process of creating model classes in<a id="_idIndexMarker523"/> MongoFrames<a id="_idIndexMarker524"/> is called <code>Frame</code> API class to define the model classes. Once inherited, <code>Frame</code> does not require a model class to define its attributes. It uses the <code>_fields</code> property to contain all the necessary fields of the document without indicating any metadata. The following model classes are defined by the <code>Frame</code> API class:</p>
			<pre class="source-code">
<strong class="bold">from mongoframes import Frame, SubFrame</strong>
class <strong class="bold">Book(Frame)</strong>:
    <strong class="bold">_fields</strong> = {
        'id ',
        'isbn',
        'author', 
        'date_published', 
        'title', 
        'edition',
        'price',
        'category'
    }
    <strong class="bold">_collection = "book"</strong>
    
    
class <strong class="bold">Category(SubFrame)</strong>:
    
    <strong class="bold">_fields</strong> = {
        'id',
        'name',
        'description',
        'date_added'
        }
    
    <strong class="bold">_collection = "category"</strong>
class <strong class="bold">Reference(Frame)</strong>:
    <strong class="bold">_fields</strong> = {
        'id',
        'name',
        'description',
        'categories'
        }
    
    <strong class="bold">_collection = "reference"</strong></pre>
			<p>A <code>Frame</code> model class can <a id="_idIndexMarker525"/>wrap a document in dictionary form or in a <code>kwargs</code> that contains the key-value details of the document’s structure. It can also provide attributes and helper methods that can help pursue CRUD transactions. All the fields of the model class can be accessed through dot (<code>.</code>) notation, just like typical class variables.</p>
			<h3>Creating the document association</h3>
			<p>We need to define the <code>SubFrame</code> model before <a id="_idIndexMarker526"/>creating associations among these documents. A <code>SubFrame</code> model class is mapped to an embedded document structure and has no collection table of its own. The MongoFrames mapper provides operations that allow you to append, update, remove, and query the <code>SubFrame</code> class of the <code>Frame</code> instance. These operations will determine the type of association among documents since the field references of <code>Frame</code> do not have specific field types. The <code>Reference</code> document, for instance, will have a list of categories linked to its <code>categories</code> field because our transaction will build that association as designed. A <code>Book</code> document, on the other hand, will refer to a <code>Category</code> child document through its <code>category</code> field because a<a id="_idIndexMarker527"/> transaction will build that association at runtime. So, MongoFrames is both restrained and non-strict when it comes to defining the type of association among these documents.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor187"/>Creating the repository layer</h2>
			<p>The <code>Frame</code> API class provides the <a id="_idIndexMarker528"/>model classes and the necessary helper methods to implement the asynchronous repository transactions. The following code shows an implementation of a repository class that uses MongoFrames to create its CRUD transactions:</p>
			<pre class="source-code">
<strong class="bold">from mongoframes.factory.makers import Q</strong>
<strong class="bold">from models.data.mongoframe import Book, Category</strong>
from typing import List, Dict, Any
class BookRepository: 
    def <strong class="bold">insert_book</strong>(self, 
             details:Dict[str, Any]) -&gt; bool: 
        try:
           book = Book(**details)
           <strong class="bold">book.insert()</strong>
                  
        except Exception as e:
            return False 
        return True</pre>
			<p>The given <code>insert_book()</code> transaction inserts a book instance into its mapped collection. The <code>Frame</code> API provides an <code>insert()</code> method that saves the given model object into the database. It also has <code>insert_many()</code>, which inserts a list of multiple BSON documents or a list of model instances. The following script shows how to create an <em class="italic">UPDATE</em> transaction in MongoFrames:</p>
			<pre class="source-code">
    def <strong class="bold">update_book</strong>(self, id:int, 
            details:Dict[str, Any]) -&gt; bool: 
       try:
        <strong class="bold">book = Book.one(Q.id == id)</strong>
        for key,value in details.items():
            setattr(book,key,value)
        <strong class="bold">book.update()</strong>
       except: 
           return False 
       return True</pre>
			<p>The given <code>update_book()</code> transaction shows that the <code>Frame</code> model class also has an <code>update()</code> method, which recognizes<a id="_idIndexMarker529"/> and saves the changes reflected in the field values of a document object right after fetching them from the collection. A similar process is applied to the <code>delete_book()</code> process, which calls the <code>delete()</code> operation of the document object right after fetching it from the collection:</p>
			<pre class="source-code">
    def <strong class="bold">delete_book</strong>(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">book = Book.one(Q.id == id)</strong>
           <strong class="bold">book.delete()</strong>
        except: 
            return False 
        return True</pre>
			<p>When creating query transactions, the <code>Frame</code> API provides two class methods – the <code>many()</code> method, which extracts all BSON documents, and the <code>one()</code> method, which returns a single document<a id="_idIndexMarker530"/> object. Both operations can accept a query expression as an argument if there are any constraints. Moreover, MongoFrames has a <code>Q</code> query maker class that’s used to build conditionals in a query expression. The expression starts with <code>Q</code>, followed by dot (<code>.</code>) notation to define the field name or path – for example, <code>Q.categories.fiction</code> – followed by an operator (for example, <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, or <code>&lt;=</code>) and finally a value. The following code shows examples of the query transactions being translated using the MongoFrames ODM syntax:</p>
			<pre class="source-code">
    def <strong class="bold">get_all_book</strong>(self):
        books = [b.to_json_type() for b in <strong class="bold">Book.many()</strong>]
        return books
    
    def get_book(self, id:int): 
        book = <strong class="bold">Book.one(Q.id == id).to_json_type()</strong>
        return book</pre>
			<p>The <code>get_book()</code> method shows how to extract a single <code>Book</code> document with a <code>Q</code> expression that filters the correct <code>id</code>, while <code>get_all_book()</code> retrieves all <code>Book</code> documents without any constraints. </p>
			<p>The <code>many()</code> operator returns a list of <code>Frame</code> objects, while the <code>one()</code> operator returns a single <code>Frame</code> instance. To convert the result into JSON-able components, we need to invoke the <code>to_json_type()</code> method in each <code>Frame</code> instance.</p>
			<p>As explained earlier, adding embedded documents is determined by the operation and not by the model attributes. In the following <code>add_category()</code> transaction, it is clear that a <code>Category</code> object has been assigned to a <code>category</code> field of a <code>Book</code> instance, even if the field is not defined to refer to an embedded document of the <code>Category</code> type. Instead of throwing an<a id="_idIndexMarker531"/> exception, MongoFrame will update the <code>Book</code> document right after the <code>update()</code> call:</p>
			<pre class="source-code">
    def <strong class="bold">add_category</strong>(self, id:int, 
               category:Category) -&gt; bool: 
       try:
        <strong class="bold">book = Book.one(Q.id == id)</strong>
        <strong class="bold">book.category = category</strong>
        <strong class="bold">book.update()</strong>
       except: 
           return False 
       return True</pre>
			<p>Now, it is time to apply these CRUD transactions to our API services.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor188"/>Applying the repository layer</h2>
			<p>Our repository classes will not work if we do not inject the <code>create_db_client()</code> injectable into the router. The<a id="_idIndexMarker532"/> following solution injects the component into <code>APIRouter</code>, even if it is acceptable to inject it into each API service implementation:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
from fastapi.responses import JSONResponse
from models.request.category import BookReq
<strong class="bold">from repository.mongoframe.book import BookRepository</strong>
<strong class="bold">from db_config.mongoframe_config import create_db_client</strong>
from datetime import date, datetime
from json import dumps, loads
router = APIRouter(
         dependencies=[<strong class="bold">Depends(create_db_client)</strong>])
<strong class="bold">@router.post("/book/create")</strong>
def create_book(req:BookReq): 
    book_dict = req.dict(exclude_unset=True) 
    book_json = dumps(book_dict, default=json_serial)
    <strong class="bold">repo:BookRepository = BookRepository()</strong>
    result = repo.insert_book(loads(book_json))
    if result == True: 
        return req 
    else: 
        return JSONResponse(content={"message": 
          "insert book unsuccessful"}, status_code=500)</pre>
			<p>The <code>create_book()</code> service uses <code>BookRepository</code> to insert book details into the MongoDB database. In <a id="_idIndexMarker533"/>general, MongoFrames has an easy setup because it requires fewer configuration details for creating the database connection, building the model layer, and implementing the repository transactions. Its platform can be adapted to the existing requirements of the application and can easily reflect changes if modifications need to be made to its mapping mechanisms.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor189"/>Summary</h1>
			<p>In this chapter, we looked at various ways to manage data using MongoDB. We utilized MongoDB to store non-relational data for our <em class="italic">online book reselling system</em> since we expect the data to become large when information is exchanged between the book buyers and resellers. Additionally, the details involved in the transactions are mainly strings, floats, and integers, which are all order and purchase values that will be easier to mine and analyze if they’re stored in schema-less storage. </p>
			<p>This chapter took the non-relational data management roadmap for utilizing the data in sales forecasting, regression analysis of book readers’ demands, and other descriptive data analysis forms.</p>
			<p>First, you learned how the PyMongo and Motor drivers connect the FastAPI application to the MongoDB database. After understanding the nuts and bolts of creating CRUD transactions using these drivers, you learned that ODM is the better option for pursuing MongoDB connectivity. We explored the features of MongoEngine, Beanie, ODMantic, and MongoFrames and studied their strengths and weaknesses as ODM mappers. All these ODMs can be integrated well with the FastAPI platform and provide the application with a standardized way to back up data.</p>
			<p>Now that we’ve spent two chapters covering data management, in the next chapter, we will learn how to secure our FastAPI microservice applications.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>