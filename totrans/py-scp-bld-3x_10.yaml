- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced and Modal Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), we have resorted to operators
    to implement our features in Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Operators have already proved to be incredibly flexible, with custom properties
    and looks. They can be even more powerful once we learn how to override all their
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The operators encountered in the previous chapters run as soon as they are launched
    and finish immediately. If we need to, we can make the execution modal and let
    the operator listen to input events.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to control the execution of an operator,
    and how you can write fully interactive operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the operator flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting properties programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing modal operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Blender and Visual Studio Code in this chapter, but any other programmer
    text editor can be used. The examples created in this chapter can be found at
    [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch10](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch10).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the operator flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We dealt with operators since [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049),
    and we learned how their `poll` method checks whether the operator can be executed,
    while `execute` performs the operation and exits.
  prefs: []
  type: TYPE_NORMAL
- en: Then in [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075), we added editable parameters
    to the *Elevator* operator, thanks to the `'REGISTER'` and `'``UNDO'` options.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the clever trick to change a result in real time when
    a user changes a parameter – Blender secretly undoes the last operation and performs
    it again with the new options, hence the need for `'UNDO'`.
  prefs: []
  type: TYPE_NORMAL
- en: That became more evident in [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171),
    when we learned how using **Edit** | **Adjust Last Operation** from the menu bar
    changes the result of the last operation.
  prefs: []
  type: TYPE_NORMAL
- en: While those solutions allow us to get input parameters with ease, they don’t
    give access to the actual input events, such as the pressure of a key or the movement
    of a mouse.
  prefs: []
  type: TYPE_NORMAL
- en: That would require a `execute` method instantly, so it couldn’t possibly wait
    for inputs; therefore, the events must be handled by another method.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we cannot do in `execute` is set the operator’s editable parameters.
    Since Blender runs `execute` again when a parameter is changed, the user would
    find themselves unable to set a property, as it would be overridden immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing events and initializing operator parameters are two tasks that cannot
    be performed by `execute`. Luckily, `execute` is not the only method involved
    when an operator is launched; we will see that an operator’s lifetime encompasses
    a set of methods, each of them with a specific purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Steps of execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know from [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), that the operator
    `poll` and `execute` methods are required, respectively, for validation and execution.
    In [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100), we used `invoke` to make sure
    that the operator properties are displayed before it runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will take a closer look at how operators are displayed and run:'
  prefs: []
  type: TYPE_NORMAL
- en: Blender checks the return value of `poll`. If the result is `False`, the operator
    is grayed out; otherwise, the operator can be launched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operator is launched, and it runs the `invoke` method. This method is optional;
    if we don’t write it, its step is skipped, and Blender runs `execute` directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One common use of `invoke` is the initialization of the operator’s variables
    or internal value; unlike conventional Python classes, operators don’t implement
    the traditional `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: Like `execute`, `invoke` must return an exit status, which can be `'FINISHED'`,
    `'CANCELLED'`, or `'RUNNING_MODAL'`.
  prefs: []
  type: TYPE_NORMAL
- en: If our operator is meant to listen for mouse and keyboard events, in `invoke`,
    we add it to the application `'RUNNING_MODAL'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the operator is part of the handlers, its `modal` method is executed at every
    trigger event (when a mouse cursor moves, a key is pressed, etc.), until the modal
    returns `'CANCELLED'` or `'FINISHED'`. Otherwise, to continue listening, it should
    return `'RUNNING_MODAL'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `bl_options` is `{'REGISTER','UNDO'}`, the operator properties are displayed
    in a panel at the bottom left of the screen. The panel relies on the operator’s
    `draw` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, all the operator properties that are not flagged with `hidden` upon
    declaration are displayed in the panel. Reimplementing this method allows us to
    implement a custom design using the techniques learned in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing a value in the operator panel runs `execute` again, with updated properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution flow is summed up in *Figure 10**.1*, which helps us understand
    how the methods in the execution flow add up when an operator is launched.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The operator methods from the start to the end of the evaluation](img/Figure_10.01_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The operator methods from the start to the end of the evaluation'
  prefs: []
  type: TYPE_NORMAL
- en: While `poll` is run by the interface every time that the operator is displayed,
    `invoke` is the first step of an operator flow, so we can use it to set the operator’s
    parameters programmatically and, from there, move to `execute` or `modal`. In
    the next section, we will use `invoke` to initialize the operator parameters according
    to the time of the day.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the “PunchClock” add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some tools can require the current date and time from the operating system clock.
    In Python, we can use the `datetime` module to get them in our scripts, generally
    for versioning or logging purposes. There are no Blender properties designed specifically
    for time units, but an hour and a minute can be stored as two separate integer
    properties of an operator.
  prefs: []
  type: TYPE_NORMAL
- en: We know how to use the `default` argument to declare the initial value of a
    property, but what if that value is not always the same? For example, the current
    hour and minute change during the day, but `default` only sets static values.
  prefs: []
  type: TYPE_NORMAL
- en: But since `invoke` is executed before all the other methods, we can set our
    default values programmatically in there.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate that, we will create an add-on to create a time format text in
    the current scene. By default, the text displays the current time of the day,
    but the user can change that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the add-on script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create the `ch10` folder in our Python project, and then in **Blender
    Preferences**, we set it as the **Scripts** folder and restart Blender:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `PythonScriptingBlender/ch10/addons` in your file browser or programmer
    editor – for instance, **VS Code**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file by clicking on the **New** **File** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `punch_clock.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `PythonScriptingBlender/ch10` in the Blender **File Paths** preferences
    and restart Blender.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We store the add-on information in the `bl_info` dictionary, as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This add-on contains an operator, which will be available in the **Add** menu
    of the 3D Viewport.
  prefs: []
  type: TYPE_NORMAL
- en: We start with an operator that creates a text in the *HH:MM* format, like digital
    clocks, where *HH* stands for a 2-digit hour number and *MM* for the minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hours and minutes are stored as `IntProperty`, ranging between `0` and `23`
    for the hours and `0` and `59` for the minutes. The operator’s code starts as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a new object if Blender is in `poll` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In `execute`, we create new text data and set it to `{hour}:{min}`. The Blender
    type for text is named `FONT`, and its displayed text is stored in the `body`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `:02` after a variable specifies that we want to display a 2-digit number
    – for instance, `f"{3:02}"` becomes `"03"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an object to link it to the current collection and see the text in
    the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we return `FINISHED` as execution state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first draft of our operator is ready, and now we create a `menu` function
    to add to the interface. We can use `time` in the search field, we end up with
    three relevant icons – `TIME`, `MOD_TIME`, and `SORTTIME`. Any of those will do;
    we will pick `TIME` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The time-related default icons in Icon Viewer](img/Figure_10.02_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The time-related default icons in Icon Viewer'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start `menu_func` with a `separator` to set our operator apart, and then
    we add our entry for `PunchClock` via `Layout.operator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add and remove our operator and menu item in the `register` and
    `unregister` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we restart Blender or refresh the **Add-ons** list, we should be able to
    see the **PunchClock** add-on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: PunchClock, as displayed in the Add-ons list](img/Figure_10.03_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: PunchClock, as displayed in the Add-ons list'
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, selecting **Add** | **Create Hour/Minutes Text** in the 3D Viewport
    top menu would add a text object displaying the time *00:00*.
  prefs: []
  type: TYPE_NORMAL
- en: We can get the current time from `datetime` and convert it to text, but we can
    do something even better – by setting `self.hour` and `self.mins` inside `invoke`,
    we will achieve the same result but also allow a user to change the displayed
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Using invoke to initialize properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get the current time, we import `datetime` at the beginning of the script.
    The `import` section becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the operator class, we implement the `invoke` method. It can come
    right after `poll`, but any place under the `PunchClock` class will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, the hour and minute of the operator are set up in `invoke`, and then `execute`
    is called to carry on the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing with `execute` is important, as that’s what Blender expects when updating
    its operations chronology.
  prefs: []
  type: TYPE_NORMAL
- en: Launching **Create Hour/Minutes Text** now displays the current time in a new
    text object and allows us to change the hour and minute using the operator panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Adding editable hour and minute fields, set to the current time](img/Figure_10.04_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Adding editable hour and minute fields, set to the current time'
  prefs: []
  type: TYPE_NORMAL
- en: By using `invoke`, we have set our default values programmatically. That’s a
    common request in productions, since the desired defaults can change across projects,
    tasks, and departments.
  prefs: []
  type: TYPE_NORMAL
- en: We have added our operator to the `execute` method directly.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the menu from skipping `invoke`, we need to override the layout’s
    context in our menu function.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring default invoke in pop-up menus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layout elements can pass a custom context and force a design choice on operators.
    For example, buttons displayed outside the viewport avoid displaying operator
    properties, and pop-up menus bypass the `invoke` method.
  prefs: []
  type: TYPE_NORMAL
- en: We have encountered this behavior in the *Displaying buttons* section of [*Chapter
    5*](B18375_05.xhtml#_idTextAnchor100), and in the *Writing the Action to Range
    add-on* section in [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171).
  prefs: []
  type: TYPE_NORMAL
- en: We worked around those issues, respectively, by calling a properties dialog
    in `invoke`, or by using `invoke` to run even when the operator is launched from
    the `invoke`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will change the layout’s `operator_context` to `"INVOKE_DEFAULT"`.
    We only need that for `PunchClock`, so, to minimize any potential impact on other
    menu entries, we add a new row and change only its `operator_context`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our menu function becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By executing `PunchClock` with its default context, we make sure that `invoke`
    is never skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the operator will always display its properties and let a user change them,
    but we can also implement a way to change the displayed time by just moving the
    mouse.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will add operator response to mouse and keyboard input,
    making our operator a modal application handler.
  prefs: []
  type: TYPE_NORMAL
- en: Adding modal behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In user interfaces, the term **modal** designates a sub-window or widget that
    takes all the user interaction for itself, until the operation is ended explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, operators are designed to return to the main application immediately.
    If we don’t want that, they should be added to the window manager’s modal handlers.
  prefs: []
  type: TYPE_NORMAL
- en: The operator is then considered modal and will listen to the user inputs until
    it’s closed manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make `PunchClock` modal and use mouse movement to set our clock. Modal
    operators have two requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invoke` adds the operator to the handlers and returns `''RUNNING_MODAL''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modal` is implemented and returns `''RUNNING_MODAL''`. It returns `''FINISHED''`
    when a user ends it, or `''CANCELLED''` to exit with no changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start to implement the modal execution by changing `invoke` and its
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the operator to the modal handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of passing to `execute`, `invoke` now calls the `modal_handler_add`
    method of the current `window_manager`, and then it returns `{'RUNNING_MODAL'}`.
    The return status notifies that the operator is running in Blender and listens
    to events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `modal` runs at every window update, we should keep it light and small.
    Adding objects to the scene is expensive, so we create and link the text in `invoke`,
    and only edit its body in `modal`. The `invoke` method stores `txt_crv` and `txt_obj`
    as operator member attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The keywords that can be returned as status are listed in the API documentation
    ([https://docs.blender.org/api/3.3/bpy_types_enum_items/operator_return_items.xhtml](https://docs.blender.org/api/3.3/bpy_types_enum_items/operator_return_items.xhtml))
    and are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RUNNING_MODAL`: Keeps the operator running with Blender'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CANCELLED`: The operator exited without doing anything, so no undo entry should
    be pushed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FINISHED`: The operator exited after completing its action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PASS_THROUGH`: Do nothing and pass the event on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTERFACE`: Handled but not executed (pop-up menus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already dealt with `'RUNNING_MODAL'`, `'CANCELLED'`, and `'FINISHED'`,
    while `'PASS_THROUGH'` is useful to pass an event to the rest of an application,
    even if our script was listening to it. `'INTERFACE'` is used in pop-up menus,
    but usually, we don’t need that for our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Status is not everything!
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to know that returning a status ratifies what was done in a method,
    but it doesn’t perform anything.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, returning `'CANCELLED'` alone doesn’t undo what was done in a
    method; we should undo all the changes programmatically – for example, remove
    the objects that our method might have created, and then return `'CANCELLED'`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the application handler will look for a `modal` method and run it,
    we can proceed with writing one for our operator.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the modal method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once an operator is added to the handlers, the window manager will run its `modal`
    method at every event of the user interface. As with `invoke`, besides `self`
    and `context`, this method takes a third argument – `event`.
  prefs: []
  type: TYPE_NORMAL
- en: The `event` argument contains information about what triggered any execution
    of `modal`. It can be a movement of a mouse or the press of a key.
  prefs: []
  type: TYPE_NORMAL
- en: The most relevant information is `type`, a string whose keywords are documented
    at [https://docs.blender.org/api/3.3/bpy_types_enum_items/event_type_items.xhtml](https://docs.blender.org/api/3.3/bpy_types_enum_items/event_type_items.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at `event.type`, we can find out what triggered the update, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This means that the user did just move the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: If the event was caused by the keyboard, `event.type` would be a letter, such
    as `"A"`, or a description of the key, such as `"LEFT_CTRL"`. The event type associated
    with numeric keys is the uppercase letters for that number – for example, `"THREE"`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, moving the mouse toward the right increases the current time,
    and moving it to the left decreases it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like with real clocks, we can set either the hours or minutes – we add a Boolean
    property to distinguish between the two. The properties section becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can finally write `PunchClock.modal`.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the mouse updates the attributes associated with the cursor. For instance,
    the cursor position on the horizontal axis is stored as `mouse_x`, while the previous
    position is still available as `mouse_prev_x.` The difference between the two
    gives the movement direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We store that number as `delta` and divide it to slow the transition. A factor
    of 10 makes it slow enough for our purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`delta` is a float number, and as such, it cannot be summed with hour and mins,
    which are integers. For that reason, we round it to an integer value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use `round` rather than `int` for this conversion. Since `int` approximates
    to the least or equal integer value, it would make the progress from one value
    to the next less smooth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of `set_hours` decides whether `delta` is added to the hours or the
    minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To change `set_hours`, we resort to a key press. We make the user switch between
    hours and minutes by pressing the *Tab* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get that key press, we ensure that `event.type` is `''TAB''` and `event.value`
    is `''PRESS''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Boolean variables can only be `True` or `False`, which are each other’s negation.
    So, we have converted `set_hours` to its opposite by just using `not`.
  prefs: []
  type: TYPE_NORMAL
- en: Type is not enough!
  prefs: []
  type: TYPE_NORMAL
- en: A key that is pressed will also be released, and this action will generate another
    event, whose value is `'RELEASE'`. Checking only `event.type` without checking
    `event.value` puts our code at the risk of responding to keystrokes twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, when a user is happy with the displayed time, they can press *Return*
    and exit. Pressing *Return* triggers an event of type `''RET''`. We don’t need
    to bother with `event.value` for exit events. Once we return `{''FINISHED''}`,
    the operator stops, so there are no risks of duplicate execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, what if the user has second thoughts and wants to exit the tool without
    doing anything? We can allow the operation to be aborted at the press of `'ESC'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, the operator must clean after itself by deleting the text created
    in `invoke`, and then return `{''CANCELLED''}` to avoid being added to the undo
    queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That was the last event covered by our operator. We ignore any other event and,
    by default, return `{'RUNNING_MODAL'}` as status to keep listening.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the last line of `modal` is usually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Calling **Reload Scripts**, and then **Add** | **Create Hour/Minutes Text**,
    creates a text of the current hour and starts listening to mouse/keyboard events.
    Moving the mouse left and right increases/decreases the current value, pressing
    *Tab* switches between hours and minutes, and pressing *Return* or *Esc* ends
    the operator.
  prefs: []
  type: TYPE_NORMAL
- en: Since all the action now takes place between `invoke` and `modal`, we could
    remove `execute`, but since `bl_options` is set to `{'REGISTER', 'UNDO'}`, Blender
    displays the operator properties. When a property is changed, the `execute` method
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that after *Return* is pressed, **hour**, **min**, and **set_hours**
    can be changed in the operator panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Operator properties after modal has exited](img/Figure_10.05_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Operator properties after modal has exited'
  prefs: []
  type: TYPE_NORMAL
- en: That panel can be customized – operators have a `draw` method that works in
    the same way as `Panel.draw`, which we learned about in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100).
  prefs: []
  type: TYPE_NORMAL
- en: So, rather than displaying hours and minutes in a column, we could show them
    in a time format in the operator panel. In the next section, we will implement
    the `draw` method and change the **Create Hour/Minutes** **Text** panel.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the operator panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that the operator panel is displayed in these circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: When `context.window_manager.invoke_props_dialog` is called explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `bl_options` is set to `{'REGISTER', 'UNDO'}` and the operator has finished.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `bl_options = {'``REGISTER', 'UNDO'}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, all properties are displayed in a column layout. Most property types
    can be declared with a `hidden=True` flag, but that’s not the case for `BoolProperty`,
    so we cannot do it with `set_hours`.
  prefs: []
  type: TYPE_NORMAL
- en: As a workaround, we could change `set_hours` to `IntProperty`, with a `0` to
    `1` range and `hidden` set to `True`, but by implementing the `draw` method for
    our operator, we can just omit the properties that we don’t want to display.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the draw method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to change two things in the **Create Hour/Minutes** **Text** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: The hour and minutes should be in the same row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `set_hours` internal variable should not be displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding a `draw` method to an operator changes its layout. The method arguments
    are `self` and `context`, but we will only use the first. To display our properties
    on the same line, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a row to display hours and minutes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable `align` for the new `row`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the alignment to `''CENTER''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `row.prop` to display `self.hour`, `row.label` to display a semicolon,
    and `row.prop` again to display `self.mins`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have set the text of `hour` and `mins` to `""` because no explanation is
    required. As intended, no checkbox is displayed for `set_hours`, since it’s not
    mentioned in `draw`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: The custom hour/minutes operator panel](img/Figure_10.06_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: The custom hour/minutes operator panel'
  prefs: []
  type: TYPE_NORMAL
- en: We could add more features, such as numeric input to set the hours, but since
    we have implemented all the operator methods, we can consider **PunchClock** finished.
  prefs: []
  type: TYPE_NORMAL
- en: Although we will discuss other operators in the rest of the book, this is the
    last chapter that covers them specifically, as we have learned how to customize
    every step of their execution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gained a deep understanding of how operators are integrated in different
    parts of Blender and how we can manipulate their appearance and behavior. We have
    also learned how they can capture input and how they interact with the application
    event handler and interface.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks the end of the second part of this book. The next chapter,
    *Object Modifiers*, is the start of *Part 3*, which deals with how the data of
    a scene is processed into the finished output.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which operator method runs before the operator is launched?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a user launch an operator if its `poll` method returns `False`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we set a default value on our operator parameters in a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `modal` method can only return the `'RUNNING_MODAL'` status – true or false?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does returning `'CANCELLED'` undo everything we did in a method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we override the operator context of a menu or a panel layout?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we change the layout of an operator panel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 3: Delivering Output'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This part is centered on the final stages of the 3D pipeline: generating and
    deforming geometries and setting up the rendering and shading system. Automation
    of simple rigs and the construction of shader node trees are explored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This section comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18375_11.xhtml#_idTextAnchor265), *Object Modifiers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18375_12.xhtml#_idTextAnchor304), *Rendering and Shaders*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
