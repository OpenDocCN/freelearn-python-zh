- en: When Objects Are Alike
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当对象相似时
- en: In the programming world, duplicate code is considered evil. We should not have
    multiple copies of the same, or similar, code in different places.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，重复代码被认为是邪恶的。我们不应该在不同地方有相同或相似的代码的多个副本。
- en: 'There are many ways to merge pieces of code or objects that have a similar
    functionality. In this chapter, we''ll be covering the most famous object-oriented
    principle: inheritance. As discussed in [Chapter 1](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml),
    *Object-Oriented Design*, inheritance allows us to create is a relationships between
    two or more classes, abstracting common logic into superclasses and managing specific
    details in the subclass. In particular, we''ll be covering the Python syntax and
    principles for the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以合并具有相似功能的部分代码或对象。在本章中，我们将介绍最著名的面向对象原则：继承。如[第1章](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml)中所述，*面向对象设计*，继承允许我们在两个或多个类之间创建is
    a关系，将共同逻辑抽象到超类中，并在子类中管理具体细节。特别是，我们将介绍以下Python语法和原则：
- en: Basic inheritance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本继承
- en: Inheriting from built-in types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内置类型继承
- en: Multiple inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重继承
- en: Polymorphism and duck typing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态和鸭子类型
- en: Basic inheritance
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本继承
- en: Technically, every class we create uses inheritance. All Python classes are
    subclasses of the special built-in class named `object`. This class provides very
    little in terms of data and behaviors (the behaviors it does provide are all double-underscore
    methods intended for internal use only), but it does allow Python to treat all
    objects in the same way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们创建的每个类都使用了继承。所有Python类都是名为`object`的特殊内置类的子类。这个类在数据和行为方面提供很少的功能（它提供的行为都是双下划线方法，仅用于内部使用），但它确实允许Python以相同的方式处理所有对象。
- en: 'If we don''t explicitly inherit from a different class, our classes will automatically
    inherit from `object`. However, we can openly state that our class derives from
    `object` using the following syntax:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有明确地从不同的类继承，我们的类将自动继承自`object`。然而，我们可以明确地使用以下语法来声明我们的类从`object`派生：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is inheritance! This example is, technically, no different from our very
    first example in [Chapter 2](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml), *Objects
    in Python*, since Python 3 automatically inherits from `object` if we don't explicitly
    provide a different **superclass**. A superclass, or parent class, is a class
    that is being inherited from. A subclass is a class that is inheriting from a
    superclass. In this case, the superclass is `object`, and `MySubClass` is the
    subclass. A subclass is also said to be derived from its parent class or that
    the subclass extends the parent.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是继承！从技术上讲，这个例子与[第2章](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml)中我们的第一个例子没有区别，因为Python
    3如果没有明确提供不同的**超类**，会自动从`object`继承。超类，或父类，是从中继承的类。子类是从超类继承的类。在这种情况下，超类是`object`，而`MySubClass`是子类。子类也被说成是从其父类派生，或者子类扩展了父类。
- en: As you've probably figured out from the example, inheritance requires a minimal
    amount of extra syntax over a basic class definition. Simply include the name
    of the parent class inside parentheses between the class name and the colon that
    follows. This is all we have to do to tell Python that the new class should be
    derived from the given superclass.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从示例中推断出的那样，继承在基本类定义之上只需要额外的最小语法。只需在类名和冒号之间括号内包含父类名即可。这就是我们要告诉Python新类应该从给定的超类派生的所有操作。
- en: 'How do we apply inheritance in practice? The simplest and most obvious use
    of inheritance is to add functionality to an existing class. Let''s start with
    a simple contact manager that tracks the name and email address of several people.
    The `Contact` class is responsible for maintaining a list of all contacts in a
    class variable, and for initializing the name and address for an individual contact:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在实践中应用继承？继承最简单、最明显的用途是为现有类添加功能。让我们从一个简单的联系人管理器开始，该管理器跟踪几个人的姓名和电子邮件地址。`Contact`类负责在类变量中维护所有联系人的列表，并为单个联系人初始化姓名和地址：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example introduces us to **class variables**. The `all_contacts` list,
    because it is part of the class definition, is shared by all instances of this
    class. This means that there is only one `Contact.all_contacts` list. We can also
    access it as `self.all_contacts` from within any method on an instance of the
    `Contact` class. If a field can't be found on the object (via `self`), then it
    will be found on the class and will thus refer to the same single list.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们介绍了**类变量**。`all_contacts`列表，因为它属于类定义的一部分，被这个类的所有实例共享。这意味着只有一个`Contact.all_contacts`列表。我们也可以从`Contact`类的任何方法中访问它作为`self.all_contacts`。如果一个字段在对象上找不到（通过`self`），那么它将在类上找到，因此将引用同一个单个列表。
- en: Be careful with this syntax, for if you ever *set* the variable using `self.all_contacts`,
    you will actually be creating a **new** instance variable associated just with
    that object. The class variable will still be unchanged and accessible as `Contact.all_contacts`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 小心这个语法，因为如果你使用`self.all_contacts`来设置变量，你实际上会创建一个**新**的实例变量，仅与该对象相关联。类变量仍然不变，并且可以通过`Contact.all_contacts`访问。
- en: 'This is a simple class that allows us to track a couple of pieces of data about
    each contact. But what if some of our contacts are also suppliers that we need
    to order supplies from? We could add an `order` method to the `Contact` class,
    but that would allow people to accidentally order things from contacts who are
    customers or family friends. Instead, let''s create a new `Supplier` class that
    acts like our `Contact` class, but has an additional `order` method:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类，允许我们跟踪每个联系人的几份数据。但如果我们的一些联系人也需要从我们这里订购供应品，怎么办呢？我们可以在`Contact`类中添加一个`order`方法，但这会让人们不小心从客户或家人朋友那里订购东西。相反，让我们创建一个新的`Supplier`类，它像我们的`Contact`类一样工作，但有一个额外的`order`方法：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, if we test this class in our trusty interpreter, we see that all contacts,
    including suppliers, accept a name and email address in their `__init__`, but
    that only suppliers have a functional order method:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用我们信任的解释器测试这个类，我们会看到所有联系人，包括供应商，在它们的`__init__`中接受一个名称和电子邮件地址，但只有供应商有一个功能性的`order`方法：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, now our `Supplier` class can do everything a contact can do (including adding
    itself to the list of `all_contacts`) and all the special things it needs to handle
    as a supplier. This is the beauty of inheritance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的`Supplier`类可以做任何联系人能做的事情（包括将自己添加到`all_contacts`联系人列表中），以及作为供应商需要处理的特殊事情。这就是继承的美丽之处。
- en: Extending built-ins
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展内置类
- en: 'One interesting use of this kind of inheritance is adding functionality to
    built-in classes. In the `Contact` class seen earlier, we are adding contacts
    to a list of all contacts. What if we also wanted to search that list by name?
    Well, we could add a method on the `Contact` class to search it, but it feels
    like this method actually belongs to the list itself. We can do this using inheritance:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型继承的一个有趣用途是向内置类添加功能。在前面看到的`Contact`类中，我们正在将联系人添加到所有联系人的列表中。如果我们还想按名称搜索这个列表怎么办？嗯，我们可以在`Contact`类上添加一个方法来搜索它，但感觉这个方法实际上属于列表本身。我们可以使用继承来做这件事：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of instantiating a normal list as our class variable, we create a new
    `ContactList` class that extends the built-in `list` data type. Then, we instantiate
    this subclass as our `all_contacts` list. We can test the new search functionality
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将普通列表作为我们的类变量实例化，而是创建一个新的`ContactList`类，它扩展了内置的`list`数据类型。然后，我们将这个子类实例化为我们`all_contacts`列表。我们可以如下测试新的搜索功能：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Are you wondering how we changed the built-in syntax `[]` into something we
    can inherit from? Creating an empty list with `[]` is actually a shortcut for
    creating an empty list using `list()`; the two syntaxes behave identically:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道我们是如何将内置语法`[]`改变成可以继承的吗？使用`[]`创建一个空列表实际上是一个使用`list()`创建空列表的快捷方式；两种语法的行为相同：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In reality, the `[]` syntax is actually so-called **syntactic sugar** that
    calls the `list()` constructor under the hood. The `list` data type is a class
    that we can extend. In fact, the list itself extends the `object` class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`[]`语法实际上是所谓的**语法糖**，在底层调用`list()`构造函数。`list`数据类型是一个我们可以扩展的类。事实上，列表本身扩展了`object`类：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As a second example, we can extend the `dict` class, which is, similar to the
    list, the class that is constructed when using the `{}` syntax shorthand:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个例子，我们可以扩展`dict`类，它类似于列表，是在使用`{}`语法简写时构建的类：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is easy to test in the interactive interpreter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这在交互式解释器中很容易测试：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Most built-in types can be similarly extended. Commonly extended built-ins are
    `object`, `list`, `set`, `dict`, `file`, and `str`. Numerical types such as `int`
    and `float` are also occasionally inherited from.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内置类型都可以类似地扩展。常见的扩展内置类型有`object`、`list`、`set`、`dict`、`file`和`str`。数值类型如`int`和`float`也偶尔会被继承。
- en: Overriding and super
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写和super
- en: So, inheritance is great for *adding* new behavior to existing classes, but
    what about *changing* behavior? Our `Contact` class allows only a name and an
    email address. This may be sufficient for most contacts, but what if we want to
    add a phone number for our close friends?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继承对于向现有类添加新行为是非常好的，但关于改变行为呢？我们的`Contact`类只允许有名字和电子邮件地址。这可能对大多数联系人来说已经足够了，但如果我们想为我们的亲密朋友添加一个电话号码怎么办？
- en: 'As we saw in [Chapter 2](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml), *Objects
    in Python*, we can do this easily by just setting a `phone` attribute on the contact
    after it is constructed. But if we want to make this third variable available
    on initialization, we have to override `__init__`. Overriding means altering or
    replacing a method of the superclass with a new method (with the same name) in
    the subclass. No special syntax is needed to do this; the subclass''s newly created
    method is automatically called instead of the superclass''s method. As shown in
    the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml)中看到的，*Python中的对象*，我们可以通过在对象构造后只设置一个`phone`属性来轻松做到这一点。但如果我们想在初始化时使这个第三个变量可用，我们必须重写`__init__`。重写意味着用子类中具有相同名称的新方法（在超类中）替换或更改超类的方法。为此不需要特殊的语法；子类新创建的方法会自动调用，而不是超类的方法。如下面的代码所示：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any method can be overridden, not just `__init__`. Before we go on, however,
    we need to address some problems in this example. Our `Contact` and `Friend` classes
    have duplicate code to set up the `name` and `email` properties; this can make
    code maintenance complicated, as we have to update the code in two or more places.
    More alarmingly, our `Friend` class is neglecting to add itself to the `all_contacts`
    list we have created on the `Contact` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方法都可以被重写，不仅仅是`__init__`。在我们继续之前，我们需要解决这个例子中的一些问题。我们的`Contact`和`Friend`类在设置`name`和`email`属性方面有重复的代码；这可能会使代码维护变得复杂，因为我们必须在两个或更多地方更新代码。更令人担忧的是，我们的`Friend`类忽略了将自身添加到我们在`Contact`类上创建的`all_contacts`列表。
- en: 'What we really need is a way to execute the original `__init__` method on the
    `Contact` class from inside our new class. This is what the `super` function does;
    it returns the object as an instance of the parent class, allowing us to call
    the parent method directly:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是一种方法，在新的类内部执行`Contact`类上的原始`__init__`方法。这正是`super`函数的作用；它返回父类的对象作为实例，使我们能够直接调用父类方法：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example first gets the instance of the parent object using `super`, and
    calls `__init__` on that object, passing in the expected arguments. It then does
    its own initialization, namely, setting the `phone` attribute.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首先使用`super`获取父对象的实例，并在该对象上调用`__init__`，传递预期的参数。然后它进行自己的初始化，即设置`phone`属性。
- en: A `super()` call can be made inside any method. Therefore, all methods can be
    modified via overriding and calls to `super`. The call to `super` can also be
    made at any point in the method; we don't have to make the call as the first line.
    For example, we may need to manipulate or validate incoming parameters before
    forwarding them to the superclass.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()`调用可以在任何方法内部进行。因此，所有方法都可以通过重写和调用`super`来修改。`super`的调用也可以在任何方法点进行；我们不必将调用作为第一行。例如，我们可能需要在将参数转发给超类之前对其进行操作或验证。'
- en: Multiple inheritance
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'Multiple inheritance is a touchy subject. In principle, it''s simple: a subclass
    that inherits from more than one parent class is able to access functionality
    from both of them. In practice, this is less useful than it sounds and many expert
    programmers recommend against using it.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承是一个敏感的话题。在原则上，它是简单的：从多个父类继承的子类能够访问它们的功能。在实践中，这比听起来要少用得多，许多专家程序员都建议不要使用它。
- en: As a humorous rule of thumb, if you think you need multiple inheritance, you're
    probably wrong, but if you know you need it, you might be right.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种幽默的经验法则，如果你认为你需要多重继承，你可能错了，但如果你知道你需要它，你可能是对的。
- en: 'The simplest and most useful form of multiple inheritance is called a **mixin**.
    A mixin is a superclass that is not intended to exist on its own, but is meant
    to be inherited by some other class to provide extra functionality. For example,
    let''s say we wanted to add functionality to our `Contact` class that allows sending
    an email to `self.email`. Sending email is a common task that we might want to
    use on many other classes. So, we can write a simple mixin class to do the emailing
    for us:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承最简单且最有用的形式被称为**混入（mixin）**。混入是一个不打算独立存在的超类，而是意味着被其他类继承以提供额外功能。例如，假设我们想要向我们的`Contact`类添加功能，允许向`self.email`发送电子邮件。发送电子邮件是一个常见的任务，我们可能希望在其他许多类中使用。因此，我们可以编写一个简单的混入类来为我们处理电子邮件：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For brevity, we won't include the actual email logic here; if you're interested
    in studying how it's done, see the `smtplib` module in the Python standard library.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们这里不包括实际的电子邮件逻辑；如果你对如何实现感兴趣，请查看Python标准库中的`smtplib`模块。
- en: 'This class doesn''t do anything special (in fact, it can barely function as
    a standalone class), but it does allow us to define a new class that describes
    both a `Contact` and a `MailSender`, using multiple inheritance:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类没有做任何特别的事情（实际上，它几乎不能作为一个独立的类使用），但它确实允许我们定义一个新的类，该类描述了`Contact`和`MailSender`，使用多重继承：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The syntax for multiple inheritance looks like a parameter list in the class
    definition. Instead of including one base class inside the parentheses, we include
    two (or more), separated by a comma. We can test this new hybrid to see the mixin
    at work:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承的语法看起来像类定义中的参数列表。在括号内包含一个基类而不是一个，我们包含两个（或更多），用逗号分隔。我们可以测试这个新的混合体，看看混入（mixin）是如何工作的：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Contact` initializer is still adding the new contact to the `all_contacts`
    list, and the mixin is able to send mail to `self.email`, so we know that everything
    is working.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contact`初始化器仍然会将新联系人添加到`all_contacts`列表中，混入（mixin）能够向`self.email`发送邮件，因此我们知道一切正常。'
- en: 'This wasn''t so hard, and you''re probably wondering what the dire warnings
    about multiple inheritance are. We''ll get into the complexities in a minute,
    but let''s consider some other options we had for this example, rather than using
    a mixin:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不那么困难，你可能想知道关于多重继承的严重警告是什么。我们将在下一分钟探讨复杂性，但让我们考虑一下这个例子中我们有的其他选项，而不是使用混入（mixin）：
- en: We could have used single inheritance and added the `send_mail` function to
    the subclass. The disadvantage here is that the email functionality then has to
    be duplicated for any other classes that need an email.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用单继承，并将`send_mail`函数添加到子类中。这里的缺点是，电子邮件功能必须为任何需要电子邮件的其他类重复。
- en: We can create a standalone Python function for sending an email, and just call
    that function with the correct email address supplied as a parameter when the
    email needs to be sent (this would be my choice).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个独立的Python函数来发送电子邮件，并在需要发送电子邮件时，通过将正确的电子邮件地址作为参数传递给该函数来调用该函数（这将是我的选择）。
- en: We could have explored a few ways of using composition instead of inheritance.
    For example, `EmailableContact` could have a `MailSender` object as a property
    instead of inheriting from it.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以探索一些使用组合而不是继承的方法。例如，`EmailableContact`可以有一个`MailSender`对象作为属性，而不是从它继承。
- en: We could monkey patch (we'll briefly cover monkey patching in [Chapter 7](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml),
    *Python Object-Oriented Shortcuts*) the `Contact` class to have a `send_mail`
    method after the class has been created. This is done by defining a function that
    accepts the `self` argument, and setting it as an attribute on an existing class.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在类创建后对`Contact`类进行猴子补丁（我们将在[第7章](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml)，*Python面向对象快捷方式*)中简要介绍猴子补丁），添加一个`send_mail`方法。这是通过定义一个接受`self`参数的函数，并将其设置为现有类的属性来实现的。
- en: Multiple inheritance works all right when mixing methods from different classes,
    but it gets very messy when we have to call methods on the superclass. There are
    multiple superclasses. How do we know which one to call? How do we know what order
    to call them in?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当混合来自不同类的方法时，多重继承工作得很好，但当我们必须调用超类的方法时，它会变得非常混乱。我们有多个超类。我们如何知道调用哪一个？我们如何知道它们的调用顺序？
- en: Let's explore these questions by adding a home address to our `Friend` class.
    There are a few approaches we might take. An address is a collection of strings
    representing the street, city, country, and other related details of the contact.
    We could pass each of these strings as a parameter into the `Friend` class's `__init__`
    method. We could also store these strings in a tuple, dictionary, or dataclass
    (we'll discuss dataclasses in [Chapter 6](6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml),* Python
    Data Structures*) and pass them into `__init__` as a single argument. This is
    probably the best course of action if there are no methods that need to be added
    to the address.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向我们的`Friend`类添加家庭地址来探讨这些问题。我们可以采取几种方法。地址是由表示街道、城市、国家和其他相关细节的字符串组成的集合。我们可以将这些字符串中的每一个作为参数传递给`Friend`类的`__init__`方法。我们也可以将这些字符串存储在元组、字典或数据类（我们将在[第6章](6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml)，*Python
    数据结构*)中，并将它们作为一个单一参数传递给`__init__`。如果没有需要添加到地址中的方法，这可能是最好的做法。
- en: Another option would be to create a new `Address` class to hold those strings
    together, and then pass an instance of this class into the `__init__` method in
    our `Friend` class. The advantage of this solution is that we can add behavior
    (say, a method to give directions or to print a map) to the data instead of just
    storing it statically. This is an example of composition, as we discussed in [Chapter
    1](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml), *Object-Oriented Design*. The
    has a relationship of composition is a perfectly viable solution to this problem
    and allows us to reuse `Address` classes in other entities, such as buildings,
    businesses, or organizations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是创建一个新的`Address`类来将这些字符串放在一起，然后在我们的`Friend`类的`__init__`方法中传递这个类的实例。这个解决方案的优点是，我们可以给数据添加行为（比如，提供方向或打印地图的方法），而不仅仅是静态存储。这是我们讨论过的组合的一个例子，正如我们在[第1章](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml)，*面向对象设计*中所讨论的那样。组合关系是解决这个问题的完美可行方案，并允许我们在其他实体（如建筑物、企业或组织）中重用`Address`类。
- en: 'However, inheritance is also a viable solution, and that''s what we want to
    explore. Let''s add a new class that holds an address. We''ll call this new class
    `AddressHolder` instead of `Address` because inheritance defines an is a relationship.
    It is not correct to say a `Friend` class is an `Address` class, but since a friend
    can have an `Address` class, we can argue that a `Friend` class is an `AddressHolder` class.
    Later, we could create other entities (companies, buildings) that also hold addresses.
    Then again, such convoluted naming is a decent indication we should be sticking
    with composition, rather than inheritance. But for pedagogical purposes, we''ll
    stick with inheritance. Here''s our `AddressHolder` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，继承也是一个可行的解决方案，这正是我们想要探讨的。让我们添加一个新的类来存储地址。我们将这个新类称为`AddressHolder`而不是`Address`，因为继承定义了一个“是”的关系。说一个`Friend`类是一个`Address`类是不正确的，但是既然一个朋友可以有一个`Address`类，我们可以争论说一个`Friend`类是一个`AddressHolder`类。稍后，我们可以创建其他也持有地址的实体（公司、建筑物）。再次强调，这种复杂的命名是一个很好的迹象，我们应该坚持使用组合，而不是继承。但是为了教学目的，我们将坚持使用继承。这是我们的`AddressHolder`类：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We just take all the data and toss it into instance variables upon initialization.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在初始化时将所有数据都扔到实例变量中。
- en: The diamond problem
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钻石问题
- en: 'We can use multiple inheritance to add this new class as a parent of our existing
    `Friend` class. The tricky part is that we now have two parent `__init__` methods,
    both of which need to be initialized. And they need to be initialized with different
    arguments. How do we do this? Well, we could start with a naive approach:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多重继承来将这个新类作为现有`Friend`类的父类。棘手的部分是现在我们有两个父`__init__`方法，它们都需要被初始化。而且它们需要用不同的参数来初始化。我们怎么做到这一点呢？好吧，我们可以从一个简单的方法开始：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we directly call the `__init__` function on each of the superclasses
    and explicitly pass the `self` argument. This example technically works; we can
    access the different variables directly on the class. But there are a few problems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们直接在每个超类上调用`__init__`函数，并显式传递`self`参数。这个例子在技术上是可以工作的；我们可以直接在类上访问不同的变量。但是存在一些问题。
- en: First, it is possible for a superclass to go uninitialized if we neglect to
    explicitly call the initializer. That wouldn't break this example, but it could
    cause hard-to-debug program crashes in common scenarios. Imagine trying to insert
    data into a database that has not been connected to, for example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果忽略显式调用初始化器，超类可能会未初始化。这不会破坏这个例子，但它可能导致在常见场景中难以调试的程序崩溃。想象一下尝试向尚未连接的数据库中插入数据。
- en: 'A more insidious possibility is a superclass being called multiple times because
    of the organization of the class hierarchy. Look at this inheritance diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 更隐蔽的可能性是，由于类层次结构的组织，一个超类被多次调用。看看这个继承图：
- en: '![](img/48be52f3-363e-4fe2-8b90-a3f1c8464aea.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48be52f3-363e-4fe2-8b90-a3f1c8464aea.png)'
- en: The `__init__` method from the `Friend` class first calls `__init__` on `Contact`,
    which implicitly initializes the `object` superclass (remember, all classes derive
    from `object`). `Friend` then calls `__init__` on `AddressHolder`, which implicitly
    initializes the `object` superclass *again*. This means the parent class has been
    set up twice. With the `object` class, that's relatively harmless, but in some
    situations, it could spell disaster. Imagine trying to connect to a database twice
    for every request!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Friend` 类中的 `__init__` 方法首先在 `Contact` 上调用 `__init__`，这隐式地初始化了 `object` 超类（记住，所有类都从
    `object` 继承）。然后 `Friend` 在 `AddressHolder` 上调用 `__init__`，这又隐式地初始化了 `object` 超类。这意味着父类被设置了两次。使用
    `object` 类，这相对无害，但在某些情况下，它可能带来灾难。想象一下，每次请求都要尝试连接数据库两次！'
- en: The base class should only be called once. Once, yes, but when? Do we call `Friend`,
    then `Contact`, then `Object`, and then `AddressHolder`? Or `Friend`, then `Contact`,
    then `AddressHolder`, and then `Object`?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基类应该只被调用一次。是的，但什么时候调用？我们是先调用 `Friend`，然后 `Contact`，然后 `Object`，再然后 `AddressHolder`？还是先调用
    `Friend`，然后 `Contact`，然后 `AddressHolder`，最后 `Object`？
- en: The order in which methods can be called can be adapted on the fly by modifying
    the `__mro__` (**Method Resolution Order**) attribute on the class. This is beyond
    the scope of this book. If you think you need to understand it, we recommend *Expert
    Python Programming*, *Tarek Ziadé*, *Packt Publishing*, or read the original documentation
    (beware, it's deep!) on the topic at [http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以调用的顺序可以通过修改类上的 `__mro__`（**方法解析顺序**）属性来动态调整。这超出了本书的范围。如果您认为需要了解它，我们建议阅读
    *Expert Python Programming*，作者 *Tarek Ziadé*，由 *Packt Publishing* 出版，或者阅读该主题的原始文档（请注意，内容很深！）在
    [http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/)。
- en: 'Let''s look at a second contrived example, which illustrates this problem more
    clearly. Here, we have a base class that has a method named `call_me`. Two subclasses
    override that method, and then another subclass extends both of these using multiple
    inheritance. This is called diamond inheritance because of the diamond shape of
    the class diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第二个人为设计的例子，它更清楚地说明了这个问题。在这里，我们有一个基类，它有一个名为 `call_me` 的方法。两个子类覆盖了该方法，然后另一个子类使用多继承扩展了这两个类。这被称为菱形继承，因为类图呈菱形形状：
- en: '![](img/ed5ab038-124e-44a3-b0c6-975e0f92392b.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed5ab038-124e-44a3-b0c6-975e0f92392b.png)'
- en: 'Let''s convert this diagram to code; this example shows when the methods are
    called:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个图转换为代码；这个例子显示了方法调用的顺序：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This example ensures that each overridden `call_me` method directly calls the
    parent method with the same name. It lets us know each time a method is called
    by printing the information to the screen. It also updates a static variable on
    the class to show how many times it has been called. If we instantiate one `Subclass`
    object and call the method on it once, we get the output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例确保每个重写的 `call_me` 方法直接调用具有相同名称的父方法。它通过将信息打印到屏幕上来告诉我们每次方法被调用。它还更新类的静态变量，以显示它被调用的次数。如果我们实例化一个
    `Subclass` 对象并对其调用一次方法，我们得到以下输出：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Thus, we can clearly see the base class's `call_me` method being called twice.
    This could lead to some pernicious bugs if that method is doing actual work, such
    as depositing into a bank account, twice.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以清楚地看到基类的 `call_me` 方法被调用了两次。如果该方法实际执行工作，如向银行账户存钱，这可能会导致一些有害的bug。
- en: 'The thing to keep in mind with multiple inheritance is that we only want to
    call the `next` method in the class hierarchy, not the `parent` method. In fact,
    that next method may not be on a parent or ancestor of the current class. The
    `super` keyword comes to our rescue once again. Indeed, `super` was originally
    developed to make complicated forms of multiple inheritance possible. Here is
    the same code written using `super`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The change is pretty minor; we only replaced the naive direct calls with calls
    to `super()`, although the bottom subclass only calls `super` once rather than
    having to make the calls for both the left and right. The change is easy enough,
    but look at the difference when we execute it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Looks good; our base method is only being called once. But what is `super()`
    actually doing here? Since the `print` statements are executed after the `super`
    calls, the printed output is in the order each method is actually executed. Let's
    look at the output from back to front to see who is calling what.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: First, `call_me` of `Subclass` calls `super().call_me()`, which happens to refer
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: to `LeftSubclass.call_me()`. The `LeftSubclass.call_me()` method then calls
    `super().call_me()`, but in this case, `super()` is referring to `RightSubclass.call_me()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**Pay particular attention to this**: the `super` call is *not* calling the
    method on the superclass of `LeftSubclass` (which is `BaseClass`). Rather, it
    is calling `RightSubclass`, even though it is not a direct parent of `LeftSubclass`!
    This is the *next* method, not the parent method. `RightSubclass` then calls `BaseClass`
    and the `super` calls have ensured each method in the class hierarchy is executed
    once.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Different sets of arguments
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is going to make things complicated as we return to our `Friend` multiple
    inheritance example. In the `__init__` method for `Friend`, we were originally
    calling `__init__` for both parent classes, *with different sets of arguments*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How can we manage different sets of arguments when using `super`? We don't necessarily
    know which class `super` is going to try to initialize first. Even if we did,
    we need a way to pass the `extra` arguments so that subsequent calls to `super`,
    on other subclasses, receive the right arguments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, if the first call to `super` passes the `name` and `email` arguments
    to `Contact.__init__`, and `Contact.__init__` then calls `super`, it needs to
    be able to pass the address-related arguments to the `next` method, which is `AddressHolder.__init__`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: This problem manifests itself anytime we want to call superclass methods with
    the same name, but with different sets of arguments. Most often, the only time
    you would want to call a superclass with a completely different set of arguments
    is in `__init__`, as we're doing here. Even with regular methods, though, we may
    want to add optional parameters that only make sense to one subclass or set of
    subclasses.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, the only way to solve this problem is to plan for it from the beginning.
    We have to design our base class parameter lists to accept keyword arguments for
    any parameters that are not required by every subclass implementation. Finally,
    we must ensure the method freely accepts unexpected arguments and passes them
    on to its `super` call, in case they are necessary to later methods in the inheritance
    order.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，解决这个问题的唯一方法是从一开始就为此进行规划。我们必须设计我们的基类参数列表，以便接受任何不需要每个子类实现所需的参数的关键字参数。最后，我们必须确保该方法可以自由地接受意外的参数，并将它们传递给其`super`调用，以防它们对于继承顺序中后续的方法是必要的。
- en: 'Python''s function parameter syntax provides all the tools we need to do this,
    but it makes the overall code look cumbersome. Have a look at the proper version
    of the `Friend` multiple inheritance code, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Python的函数参数语法提供了我们完成这项任务所需的所有工具，但它使得整体代码看起来很繁琐。看看`Friend`多重继承代码的正确版本，如下所示：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've changed all arguments to keyword arguments by giving them an empty string
    as a default value. We've also ensured that a `**kwargs` parameter is included
    to capture any additional parameters that our particular method doesn't know what
    to do with. It passes these parameters up to the next class with the `super` call.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过给它们一个空字符串作为默认值，将所有参数都更改为关键字参数。我们还确保包含一个`**kwargs`参数来捕获我们特定的方法不知道如何处理的任何附加参数。它通过`super`调用将这些参数传递给下一个类。
- en: If you aren't familiar with the `**kwargs` syntax, it basically collects any
    keyword arguments passed into the method that were not explicitly listed in the
    parameter list. These arguments are stored in a dictionary named `kwargs` (we
    can call the variable whatever we like, but convention suggests `kw`, or `kwargs`).
    When we call a different method (for example, `super().__init__`) with a `**kwargs`
    syntax, it unpacks the dictionary and passes the results to the method as normal
    keyword arguments. We'll cover this in detail in [Chapter 7](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml),
    *Python Object-Oriented Shortcuts*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对`**kwargs`语法不熟悉，它基本上收集了传递给方法的所有关键字参数，这些参数在参数列表中没有明确列出。这些参数存储在一个名为`kwargs`的字典中（我们可以将变量命名为任何我们喜欢的，但惯例建议使用`kw`或`kwargs`）。当我们使用`**kwargs`语法调用不同的方法（例如，`super().__init__`）时，它会展开字典，并将结果作为正常的关键字参数传递给方法。我们将在[第7章](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml)中详细介绍，*Python面向对象快捷方式*。
- en: The previous example does what it is supposed to do. But it's starting to look
    messy, and it is difficult to answer the question, *What arguments do we need
    to pass into* `Friend.__init__`? This is the foremost question for anyone planning
    to use the class, so a docstring should be added to the method to explain what
    is happening.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子做了它应该做的事情。但它开始看起来很混乱，很难回答问题，“我们需要将哪些参数传递给”`Friend.__init__`？这是任何计划使用该类的人的首要问题，因此应该在方法中添加一个文档字符串来解释正在发生的事情。
- en: Furthermore, even this implementation is insufficient if we want to *reuse*
    variables in parent classes. When we pass the `**kwargs` variable to `super`,
    the dictionary does not include any of the variables that were included as explicit
    keyword arguments. For example, in `Friend.__init__`, the call to `super` does
    not have `phone` in the `kwargs` dictionary. If any of the other classes need
    the `phone` parameter, we need to ensure it is in the dictionary that is passed.
    Worse, if we forget to do this, it will be extremely frustrating to debug because
    the superclass will not complain, but will simply assign the default value (in
    this case, an empty string) to the variable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使这个实现也不足以满足我们在父类中*重用*变量的需求。当我们把`**kwargs`变量传递给`super`时，该字典不包含任何作为显式关键字参数包含的变量。例如，在`Friend.__init__`中，对`super`的调用在`kwargs`字典中没有`phone`。如果其他任何类需要`phone`参数，我们需要确保它在传递的字典中。更糟糕的是，如果我们忘记这样做，调试将会非常令人沮丧，因为超类不会抱怨，而只是简单地给变量分配默认值（在这种情况下，一个空字符串）。
- en: 'There are a few ways to ensure that the variable is passed upward. Assume the
    `Contact` class does, for some reason, need to be initialized with a `phone` parameter,
    and the `Friend` class will also need access to it. We can do any of the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 确保变量向上传递有几种方法。假设`Contact`类由于某种原因需要使用`phone`参数进行初始化，而`Friend`类也将需要访问它。我们可以做以下任何一种：
- en: Don't include `phone` as an explicit keyword argument. Instead, leave it in
    the `kwargs` dictionary. `Friend` can look it up using the `kwargs['phone'] ` syntax.
    When it passes `**kwargs` to the `super` call, `phone` will still be in the dictionary.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将`phone`作为一个显式的关键字参数。相反，将其留在`kwargs`字典中。`Friend`可以使用`kwargs['phone']`语法来查找。当它将`**kwargs`传递给`super`调用时，`phone`仍然会在字典中。
- en: Make `phone` an explicit keyword argument, but update the `kwargs` dictionary
    before passing it to `super`, using the standard dictionary `kwargs['phone'] =
    phone` syntax.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`phone`作为一个显式的关键字参数，但在传递给`super`之前，使用标准的字典`kwargs['phone'] = phone`语法更新`kwargs`字典。
- en: 'Make `phone` an explicit keyword argument, but update the `kwargs` dictionary
    using the `kwargs.update` method. This is useful if you have several arguments
    to update. You can create the dictionary passed into `update` using either the
    `dict(phone=phone)` constructor, or the dictionary `{''phone'': phone}` syntax.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`phone`作为一个显式的关键字参数，但使用`kwargs.update`方法更新`kwargs`字典。如果你有多个参数要更新，这很有用。你可以使用`dict(phone=phone)`构造函数，或者`{''phone'':
    phone}`语法来创建传递给`update`的字典。'
- en: Make `phone` an explicit keyword argument, but pass it to the super call explicitly
    with the `super().__init__(phone=phone, **kwargs)` syntax.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`phone`作为一个显式的关键字参数，但使用`super().__init__(phone=phone, **kwargs)`语法显式地将其传递给super调用。
- en: We have covered many of the caveats involved with multiple inheritance in Python.
    When we need to account for all possible situations, we have to plan for them
    and our code will get messy. Basic multiple inheritance can be handy but, in many
    cases, we may want to choose a more transparent way of combining two disparate
    classes, usually using composition or one of the design patterns we'll be covering
    in [Chapter 10](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml), *Design Patterns
    I,* and [Chapter 11](8f3d1c0f-4a63-4d06-8fb2-ad4dfe2669a3.xhtml), *Design Patterns
    II*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Python中多重继承涉及到的许多注意事项。当我们需要考虑所有可能的情况时，我们必须计划它们，我们的代码会变得混乱。基本的多重继承可能很有用，但在许多情况下，我们可能希望选择一种更透明的方式来组合两个不同的类，通常使用组合或我们在[第10章](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml)中将要讨论的设计模式之一，*设计模式I*，以及[第11章](8f3d1c0f-4a63-4d06-8fb2-ad4dfe2669a3.xhtml)中将要讨论的设计模式之二。
- en: I have wasted entire days of my life trawling through complex multiple inheritance
    hierarchies trying to figure out what arguments I need to pass into one of the
    deeply nested subclasses. The author of the code tended not to document his classes
    and often passed the kwargs—Just in case they might be needed someday. This was
    a particularly bad example of using multiple inheritance when it was not needed.
    Multiple inheritance is a big fancy term that new coders like to show off, but
    I recommend avoiding it, even when you think it's a good choice. Your future self
    and other coders will be glad they understand your code when they have to read
    it later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我浪费了我生命中的整个白天，试图在复杂的多重继承层次结构中寻找我需要传递给深层嵌套子类中的哪些参数。代码的作者往往不记录他的类，并且经常传递kwargs——以防万一将来可能需要。这是一个在不需要多重继承时使用多重继承的特别糟糕的例子。多重继承是一个大而华丽的术语，新程序员喜欢炫耀，但我建议即使你认为这是一个好选择，也要避免使用它。当你以后不得不阅读代码时，你未来的自己和其他程序员会很高兴他们理解了你的代码。
- en: Polymorphism
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: 'We were introduced to polymorphism in [Chapter 1](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml),
    *Object-Oriented Design*. It is a showy name describing a simple concept: different
    behaviors happen depending on which subclass is being used, without having to
    explicitly know what the subclass actually is. As an example, imagine a program
    that plays audio files. A media player might need to load an `AudioFile` object
    and then `play` it. We can put a `play()` method on the object, which is responsible
    for decompressing or extracting the audio and routing it to the sound card and
    speakers. The act of playing an `AudioFile` could feasibly be as simple as:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml)中介绍了多态性，*面向对象设计*。这是一个华丽的名字，描述了一个简单的概念：不同的行为取决于正在使用哪个子类，而不需要明确知道子类实际上是什么。作为一个例子，想象一个播放音频文件的程序。媒体播放器可能需要加载一个`AudioFile`对象，然后播放它。我们可以在对象上放置一个`play()`方法，它负责解压缩或提取音频并将其路由到声卡和扬声器。播放`AudioFile`的行为可能实际上非常简单，就像这样：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, the process of decompressing and extracting an audio file is very different
    for different types of files. While `.wav` files are stored uncompressed, `.mp3`,
    `.wma`, and `.ogg` files all utilize totally different compression algorithms.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，解压缩和提取音频文件的过程对于不同类型的文件来说非常不同。虽然`.wav`文件以未压缩的形式存储，但`.mp3`、`.wma`和`.ogg`文件都使用完全不同的压缩算法。
- en: 'We can use inheritance with polymorphism to simplify the design. Each type
    of file can be represented by a different subclass of `AudioFile`, for example,
    `WavFile` and `MP3File`. Each of these would have a `play()` method that would
    be implemented differently for each file to ensure that the correct extraction
    procedure is followed. The media player object would never need to know which
    subclass of `AudioFile` it is referring to; it just calls `play()` and polymorphically
    lets the object take care of the actual details of playing. Let''s look at a quick
    skeleton showing how this might look:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过继承和多态来简化设计。每种文件类型都可以由`AudioFile`的不同子类来表示，例如`WavFile`和`MP3File`。这些子类中的每一个都会有一个`play()`方法，这个方法会针对每种文件以不同的方式实现，以确保遵循正确的提取过程。媒体播放器对象永远不需要知道它引用的是`AudioFile`的哪个子类；它只需调用`play()`，并通过多态让对象处理播放的实际细节。让我们看看一个快速框架，看看这可能会是什么样子：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All audio files check to ensure that a valid extension was given upon initialization.
    But did you notice how the `__init__` method in the parent class is able to access
    the `ext` class variable from different subclasses? That's polymorphism at work.
    If the filename doesn't end with the correct name, it raises an exception (exceptions
    will be covered in detail in the next chapter). The fact that the `AudioFile`
    parent class doesn't actually store a reference to the `ext` variable doesn't
    stop it from being able to access it on the subclass.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有音频文件在初始化时都会检查是否给出了有效的扩展名。但你有没有注意到父类中的`__init__`方法是如何能够从不同的子类中访问`ext`类变量的？这就是多态在起作用。如果文件名不以正确的名称结尾，它会引发异常（异常将在下一章中详细介绍）。`AudioFile`父类实际上并没有存储对`ext`变量的引用，但这并不妨碍它能够访问它。在子类中。
- en: 'In addition, each subclass of `AudioFile` implements `play()` in a different
    way (this example doesn''t actually play the music; audio compression algorithms
    really deserve a separate book!). This is also polymorphism in action. The media
    player can use the exact same code to play a file, no matter what type it is;
    it doesn''t care what subclass of `AudioFile` it is looking at. The details of
    decompressing the audio file are *encapsulated*. If we test this example, it works
    as we would hope:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`AudioFile`的每个子类都以不同的方式实现`play()`（这个示例实际上并没有播放音乐；音频压缩算法真的值得有一本单独的书来介绍！）。这也是多态在起作用。媒体播放器可以使用完全相同的代码来播放文件，无论其类型如何；它不在乎它正在查看的是`AudioFile`的哪个子类。解压缩音频文件的细节被*封装*了。如果我们测试这个示例，它将按预期工作：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See how `AudioFile.__init__` is able to check the file type without actually
    knowing which subclass it is referring to?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`AudioFile.__init__`是如何能够在不知道它引用的是哪个子类的情况下检查文件类型的？
- en: 'Polymorphism is actually one of the coolest things about object-oriented programming,
    and it makes some programming designs obvious that weren''t possible in earlier
    paradigms. However, Python makes polymorphism seem less awesome because of duck
    typing. Duck typing in Python allows us to use *any* object that provides the
    required behavior without forcing it to be a subclass. The dynamic nature of Python
    makes this trivial. The following example does not extend `AudioFile`, but it
    can be interacted with in Python using the exact same interface:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 多态实际上是面向对象编程中最酷的事情之一，它使得一些在早期范式下不可能的编程设计变得显而易见。然而，由于鸭子类型，Python使得多态看起来不那么酷。Python中的鸭子类型允许我们使用提供所需行为的任何对象，而不需要强制它成为子类。Python的动态特性使得这一点变得微不足道。以下示例没有扩展`AudioFile`，但它可以使用与扩展`AudioFile`相同的接口在Python中进行交互：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our media player can play this object just as easily as one that extends `AudioFile`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的媒体播放器可以像播放扩展自`AudioFile`的对象一样轻松地播放这个对象。
- en: Polymorphism is one of the most important reasons to use inheritance in many
    object-oriented contexts. Because any objects that supply the correct interface
    can be used interchangeably in Python, it reduces the need for polymorphic common
    superclasses. Inheritance can still be useful for sharing code, but if all that
    is being shared is the public interface, duck typing is all that is required.
    This reduced need for inheritance also reduces the need for multiple inheritance;
    often, when multiple inheritance appears to be a valid solution, we can just use
    duck typing to mimic one of the multiple superclasses.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just because an object satisfies a particular interface (by providing
    required methods or attributes) does not mean it will simply work in all situations.
    It has to fulfill that interface in a way that makes sense in the overall system.
    Just because an object provides a `play()` method does not mean it will automatically
    work with a media player. For example, our chess AI object from [Chapter 1](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml),
    *Object-Oriented Design*, may have a `play()` method that moves a chess piece.
    Even though it satisfies the interface, this class would likely break in spectacular
    ways if we tried to plug it into a media player!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature of duck typing is that the duck-typed object only needs
    to provide those methods and attributes that are actually being accessed. For
    example, if we needed to create a fake file object to read data from, we can create
    a new object that has a `read()` method; we don't have to override the `write`
    method if the code that is going to interact with the fake object will not be
    calling it. More succinctly, duck typing doesn't need to provide the entire interface
    of an object that is available; it only needs to fulfill the interface that is
    actually accessed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Abstract base classes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While duck typing is useful, it is not always easy to tell in advance if a class
    is going to fulfill the protocol you require. Therefore, Python introduced the
    idea of **abstract base classes** (**ABC**s). Abstract base classes define a set
    of methods and properties that a class must implement in order to be considered
    a duck-type instance of that class. The class can extend the abstract base class
    itself in order to be used as an instance of that class, but it must supply all
    the appropriate methods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it's rarely necessary to create new abstract base classes, but
    we may find occasions to implement instances of existing ABCs. We'll cover implementing
    ABCs first, and then briefly see how to create your own, should you ever need
    to.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Using an abstract base class
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the abstract base classes that exist in the Python standard library
    live in the `collections` module. One of the simplest ones is the `Container`
    class. Let''s inspect it in the Python interpreter to see what methods this class
    requires:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, the `Container` class has exactly one abstract method that needs to be
    implemented, `__contains__`. You can issue `help(Container.__contains__)` to see
    what the function signature should look like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Container`类恰好有一个需要实现的方法，即`__contains__`。你可以使用`help(Container.__contains__)`来查看函数签名应该是什么样子：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see that `__contains__` needs to take a single argument. Unfortunately,
    the help file doesn't tell us much about what that argument should be, but it's
    pretty obvious from the name of the ABC and the single method it implements that
    this argument is the value the user is checking to see whether the container holds.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`__contains__`需要接受一个单一参数。不幸的是，帮助文件并没有告诉我们这个参数应该是什么，但从ABC的名称和它实现的单一方法来看，这个参数很明显是用户检查容器是否包含的值。
- en: 'This method is implemented by `list`, `str`, and `dict` to indicate whether
    or not a given value is *in* that data structure. However, we can also define
    a silly container that tells us whether a given value is in the set of odd integers:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法由`list`、`str`和`dict`实现，以指示给定的值是否在该数据结构中。然而，我们也可以定义一个愚蠢的容器，告诉我们给定的值是否在奇数集合中：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here''s the interesting part: we can instantiate an `OddContainer` object and
    determine that, even though we did not extend `Container`, the class is a `Container`
    object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是：我们可以实例化一个`OddContainer`对象，并确定，尽管我们没有扩展`Container`，但这个类是一个`Container`对象：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And that is why duck typing is way more awesome than classical polymorphism.
    We can create is a relationships without the overhead of writing the code to set
    up inheritance (or worse, multiple inheritance).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，鸭子类型（duck typing）比经典的多态性更酷。我们可以创建关系，而不需要编写设置继承（或者更糟糕的是多重继承）的代码。
- en: 'One cool thing about the `Container` ABC is that any class that implements
    it gets to use the `in` keyword for free. In fact, `in` is just syntax sugar that
    delegates to the `__contains__` method. Any class that has a `__contains__` method
    is a `Container` and can therefore be queried by the `in` keyword, for example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Container` ABC的一个酷特点是，任何实现它的类都可以免费使用`in`关键字。实际上，`in`只是一个语法糖，它委托给`__contains__`方法。任何具有`__contains__`方法的类都是`Container`，因此可以通过`in`关键字进行查询，例如：'
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating an abstract base class
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个抽象基类
- en: 'As we saw earlier, it''s not necessary to have an abstract base class to enable
    duck typing. However, imagine we were creating a media player with third-party
    plugins. It is advisable to create an abstract base class in this case to document
    what API the third-party plugins should provide (documentation is one of the stronger
    use cases for ABCs). The `abc` module provides the tools you need to do this,
    but I''ll warn you in advance, this utilizes some of Python''s most arcane concepts,
    as demonstrated in the following block of code::'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，不需要有抽象基类（ABC）就能启用鸭子类型。然而，想象一下，如果我们正在创建一个带有第三方插件的媒体播放器。在这种情况下，创建一个抽象基类是明智的，以记录第三方插件应该提供的API（文档是ABC的强大用例之一）。`abc`模块提供了你需要的工具来完成这项工作，但我要提前警告你，这利用了Python最晦涩的概念，如下面的代码块所示：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a complicated example that includes several Python features that won't
    be explained until later in this book. It is included here for completeness, but
    you do not need to understand all of it to get the gist of how to create your
    own ABC.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含多个Python特性（这些特性将在本书的后面部分进行解释）的复杂示例。它被包含在这里是为了完整性，但你不需要完全理解它，就能掌握如何创建自己的ABC。
- en: The first weird thing is the `metaclass` keyword argument that is passed into
    the class where you would normally see the list of parent classes. This is a seldom-used
    construct from the mystic art of metaclass programming. We won't be covering metaclasses
    in this book, so all you need to know is that by assigning the `ABCMeta` metaclass,
    you are giving your class superhero (or at least superclass) abilities.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件奇怪的事情是`metaclass`关键字参数，它被传递到类中，你通常会在那里看到父类列表。这是元类编程神秘艺术中很少使用的结构。本书不会涉及元类，所以你只需要知道，通过分配`ABCMeta`元类，你正在给你的类赋予超级英雄（或者至少是超类）的能力。
- en: Next, we see the `@abc.abstractmethod` and `@abc.abstractproperty` constructs.
    These are Python decorators. We'll discuss those in [Chapter 10](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml),
    *Python Design Patterns I*. For now, just know that by marking a method or property
    as being abstract, you are stating that any subclass of this class must implement
    that method or supply that property in order to be considered a proper member
    of the class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到`@abc.abstractmethod`和`@abc.abstractproperty`构造。这些是Python装饰器。我们将在第10章[Python设计模式I](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml)中讨论这些。现在，只需知道，通过将方法或属性标记为抽象的，你是在声明任何这个类的子类都必须实现该方法或提供该属性，才能被认为是这个类的合适成员。
- en: 'See what happens if you implement subclasses that do, or don''t, supply those
    properties:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如果你实现了提供或不提供这些属性的子类会发生什么：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since the `Wav` class fails to implement the abstract attributes, it is not
    possible to instantiate that class. The class is still a legal abstract class,
    but you'd have to subclass it to actually do anything. The `Ogg` class supplies
    both attributes, so it instantiates cleanly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Wav`类未能实现抽象属性，因此无法实例化该类。这个类仍然是一个合法的抽象类，但你必须将其子类化才能实际做任何事情。`Ogg`类提供了这两个属性，因此可以干净地实例化。
- en: Going back to the `MediaLoader` ABC, let's dissect that `__subclasshook__` method.
    It is basically saying that any class that supplies concrete implementations of
    all the abstract attributes of this ABC should be considered a subclass of `MediaLoader`,
    even if it doesn't actually inherit from the `MediaLoader` class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MediaLoader`抽象基类（ABC），让我们剖析一下那个`__subclasshook__`方法。它基本上表示任何提供这个ABC所有抽象属性具体实现的类都应该被认为是`MediaLoader`的子类，即使它实际上并没有从`MediaLoader`类继承。
- en: More common object-oriented languages have a clear separation between the interface
    and the implementation of a class. For example, some languages provide an explicit
    `interface` keyword that allows us to define the methods that a class must have
    without any implementation. In such an environment, an abstract class is one that
    provides both an interface and a concrete implementation of some, but not all,
    methods. Any class can explicitly state that it implements a given interface.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的面向对象语言在类的接口和实现之间有一个清晰的分离。例如，一些语言提供了一个显式的`interface`关键字，允许我们定义一个类必须有的方法而不需要任何实现。在这样的环境中，一个抽象类是提供接口和一些方法的具体实现的类，但不是所有方法。任何类都可以明确声明它实现了给定的接口。
- en: Python's ABCs help to supply the functionality of interfaces without compromising
    on the benefits of duck typing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python的ABC（抽象基类）有助于在不牺牲鸭子类型（duck typing）的好处的情况下提供接口的功能。
- en: Demystifying the magic
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭秘魔法
- en: 'You can copy and paste the subclass code without understanding it if you want
    to make abstract classes that fulfill this particular contract. We''ll cover most
    of the unusual syntaxes in the book, but let''s go over it line by line to get
    an overview:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建满足这个特定契约的抽象类，你可以复制并粘贴子类代码而不必理解它。我们将在书中介绍大多数不寻常的语法，但让我们逐行过一遍，以获得一个概览：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This decorator marks the method as a class method. It essentially says that
    the method can be called on a class instead of an instantiated object:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器将方法标记为类方法。它本质上表示该方法可以在类上调用，而不是在实例化对象上调用：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This defines the `__subclasshook__` class method. This special method is called
    by the Python interpreter to answer the question: Is the class `C` a subclass
    of this class?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了`__subclasshook__`类方法。这个特殊方法由Python解释器调用，以回答问题：类`C`是这个类的子类吗？
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We check to see whether the method was called specifically on this class, rather
    than, say, a subclass of this class. This prevents, for example, the `Wav` class
    from being thought of as a parent class of the `Ogg` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查方法是否专门在这个类上调用，而不是，比如说，这个类的子类。这防止了例如`Wav`类被误认为是`Ogg`类的父类：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'All this line does is get the set of methods and properties that the class
    has, including any parent classes in its class hierarchy:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码所做的只是获取类拥有的方法集合和属性，包括其类层次结构中的任何父类：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This line uses set notation to see whether the set of abstract methods in this
    class has been supplied in the candidate class. We'll cover sets in detail in
    the [Chapter 6](6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml), *Python Data Structures**.*
    Note that it doesn't check to see whether the methods have been implemented; just
    if they are there. Thus, it's possible for a class to be a subclass and yet still
    be an abstract class itself.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If all the abstract methods have been supplied, then the candidate class is
    a subclass of this class and we return `True`. The method can legally return one
    of the three values: `True`, `False`, or `NotImplemented`. `True` and `False`
    indicate that the class is, or isn''t, definitively a subclass of this class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If any of the conditionals have not been met (that is, the class is not `MediaLoader`
    or not all abstract methods have been supplied), then return `NotImplemented`.
    This tells the Python machinery to use the default mechanism (does the candidate
    class explicitly extend this class?) for subclass detection.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we can now define the `Ogg` class as a subclass of the `MediaLoader`
    class without actually extending the `MediaLoader` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Case study
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try to tie everything we've learned together with a larger example. We'll
    be developing an automated grading system for programming assignments, similar
    to that employed at Dataquest or Coursera. The system will need to provide a simple
    class-based interface for course writers to create their assignments and should
    give a useful error message if it does not fulfill that interface. The writers
    need to be able to supply their lesson content and to write custom answer checking
    code to make sure their students got the answer right. It will also be nice for
    them to have access to the students' names to make the content seem a little friendlier.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The grader itself will need to keep track of which assignment the student is
    currently working on. A student might make several attempts at an assignment before
    they get it right. We want to keep track of the number of attempts so the course
    authors can improve the content of the more difficult lessons.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the interface that the course authors will need to
    use. Ideally, it will require the course authors to write a minimal amount of
    extra code besides their lesson content and answer checking code. Here is the
    simplest class I could come up with:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Admittedly, that particular course author may be a little naive in how they
    do their answer checking. If you haven't seen the `f"""` syntax before, we'll
    cover it in detail in the [Chapter 8](9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml), *Strings
    and Serialization*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with an abstract base class that defines this interface, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This ABC defines the two required abstract methods and provides the magic `__subclasshook__`
    method to allow a class to be perceived as a subclass without having to explicitly
    extend it (I usually just copy and paste this code. It isn't worth memorizing.)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm that the `IntroToPython` class fulfills this interface using
    `issubclass(IntroToPython, Assignment)`, which should return `True`. Of course,
    we can explicitly extend the `Assignment` class if we prefer, as seen in this
    second assignment:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This course author, unfortunately, is also rather naive. The `exec` call will
    execute the student's code right inside the grading system, giving them access
    to the entire system. Obviously, the first thing they will do is hack the system
    to make their grades 100%. They probably think that's easier than doing the assignments
    correctly!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a class that manages how many attempts the student has
    made at a given assignment:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This class uses composition instead of inheritance. At first glance, it would
    make sense for these methods to exist on the `Assignment` superclass. That would
    eliminate the annoying `lesson` method, which just proxies through to the same
    method on the assignment object. It would certainly be possible to put all this
    logic directly on the `Assignment` abstract base class, or even to have the ABC
    inherit from this `AssignmentGrader` class. In fact, I would normally recommend
    that, but in this case, it would force all course authors to explicitly extend
    the class, which violates our request that content authoring be as simple as possible.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can start to put together the `Grader` class, which is responsible
    for managing which assignments are available and which one each student is currently
    working on. The most interesting part is the register method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This code block includes the initializer, which includes two dictionaries we'll
    discuss in a minute. The `register` method is a bit complex, so we'll dissect
    it thoroughly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The first odd thing is the parameter this method accepts: `assignment_class`.
    This parameter is intended to be an actual class, not an instance of the class.
    Remember, classes are objects, too, and can be passed around like other classes.
    Given the `IntroToPython` class we defined earlier, we might register it without
    instantiating it, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The method first checks whether that class is a subclass of the `Assignment`
    class. Of course, we implemented a custom `__subclasshook__` method, so this includes
    classes that do not explicitly subclass `Assignment`. The naming is, perhaps,
    a bit deceitful! If it doesn't have the two required methods, it raises an exception.
    Exceptions are a topic we'll cover in detail in the next chapter; for now, just
    assume that it makes the program get angry and quit.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Then, we generate a random identifier to represent that specific assignment.
    We store the `assignment_class` in a dictionary indexed by that ID, and return
    the ID so that the calling code can look that assignment up in the future. Presumably,
    another object would then place that ID in a course syllabus of some sort so students
    do the assignments in order, but we won't be doing that for this part of the project.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The `uuid` function returns a specially formatted string called a universally
    unique identifier, also known as a globally unique identifier. It essentially
    represents an extremely large random number that is almost, but not quite, impossible
    to conflict with another similarly generated identifier. It is a great, quick,
    and clean way to create an arbitrary ID to keep track of items.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we have the `start_assignment` function, which allows a student to
    start working on an assignment given the ID of that assignment. All it does is
    construct an instance of the `AssignmentGrader` class we defined earlier and plop
    it in a dictionary stored on the `Grader` class, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After that, we write a couple of proxy methods that get the lesson or check
    the code for whatever assignment the student is currently working on:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we create a method that gives a summary of a student''s current assignment
    progress. It looks up the assignment object and creates a formatted string with
    all the information we have about that student:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: And that's it. You'll notice that this case study does not use a ton of inheritance,
    which may seem a bit odd given the topic of the chapter, but duck typing is very
    prevalent. It is quite common for Python programs to be designed with inheritance
    that gets simplified into more versatile constructs as it is iterated on. As another
    example, I originally defined the `AssignmentGrader` as an inheritance relationship,
    but realized halfway through that it would be better to use composition, for the
    reasons outlined previously.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a bit of test code that shows all these objects connected together:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Exercises
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look around you at some of the physical objects in your workspace and see if
    you can describe them in an inheritance hierarchy. Humans have been dividing the
    world into taxonomies like this for centuries, so it shouldn't be difficult. Are
    there any non-obvious inheritance relationships between classes of objects? If
    you were to model these objects in a computer application, what properties and
    methods would they share? Which ones would have to be polymorphically overridden?
    What properties would be completely different between them?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Now write some code. No, not for the physical hierarchy; that's boring. Physical
    items have more properties than methods. Just think about a pet programming project
    you've wanted to tackle in the past year, but never gotten around to. For whatever
    problem you want to solve, try to think of some basic inheritance relationships
    and then implement them. Make sure that you also pay attention to the sorts of
    relationships that you actually don't need to use inheritance for. Are there any
    places where you might want to use multiple inheritance? Are you sure? Can you
    see any place where you would want to use a mixin? Try to knock together a quick
    prototype. It doesn't have to be useful or even partially working. You've seen
    how you can test code using `python -i` already; just write some code and test
    it in the interactive interpreter. If it works, write some more. If it doesn't,
    fix it!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Now, take a look at the student grader system in the case study. There is a
    lot missing from it, and not just decent course content! How do students get into
    the system? Is there a curriculum that defines which order they should study lessons
    in? What happens if you change the `AssignmentGrader` to use inheritance, rather
    than composition, on the `Assignment` objects?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Finally, try to come up with some good use cases for mixins, then experiment
    with them until you realize that there is probably a better design using composition!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've gone from simple inheritance, one of the most useful tools in the object-oriented
    programmer's toolbox, all the way through to multiple inheritance—One of the most
    complicated. Inheritance can be used to add functionality to existing classes
    and built-ins using inheritance. Abstracting similar code into a parent class
    can help increase maintainability. Methods on parent classes can be called using
    `super` and argument lists must be formatted safely for these calls to work when
    using multiple inheritance. Abstract base classes allow you to document what methods
    and properties a class must have to fulfill a particular interface, and even allow
    you to change the very definition of *subclass*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover the subtle art of handling exceptional circumstances.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
