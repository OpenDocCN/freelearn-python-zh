- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Asynchronous Programming with Thread and Queue
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程和队列进行异步编程
- en: Many times, code that works flawlessly in the simplicity of a test environment
    encounters problems in the real world; unfortunately, this seems to be the case
    for the ABQ Data Entry application. While your network functions ran instantaneously
    in your localhost-only test environment, the lab's slow VPN uplink has exposed
    some shortcomings in your programming. Users report that the application freezes
    or becomes unresponsive when network transactions are taking place. Although it
    does work, it looks unprofessional and is an annoyance to users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，在测试环境的简单性中完美运行的代码在现实世界中会遇到问题；不幸的是，ABQ数据输入应用程序似乎就是这样。虽然你的网络功能在你的本地主机测试环境中运行得非常快，但实验室缓慢的VPN上行链路暴露了你编程中的一些不足。用户报告说，当进行网络事务时，应用程序会冻结或变得无响应。尽管它确实可以工作，但看起来不够专业，使用户感到烦恼。
- en: 'To solve this problem, we''re going to need to apply asynchronous programming
    techniques, which we''ll learn about in the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要应用异步编程技术，我们将在以下主题中学习这些技术：
- en: In *The Tkinter event queue*, we'll learn how to manipulate Tkinter's event
    processing to improve the responsiveness of the application.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Tkinter事件队列* 中，我们将学习如何操作Tkinter的事件处理来提高应用程序的响应性。
- en: In *Running code in the background with threads*, we'll explore writing multi-threaded
    applications using Python's `threading` module.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *使用线程在后台运行代码* 中，我们将探讨使用Python的 `threading` 模块编写多线程应用程序。
- en: In *Passing messages using a queue*, you'll learn how to use `Queue` objects
    to implement inter-thread communication.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *使用队列传递消息* 中，你将学习如何使用 `Queue` 对象来实现线程间通信。
- en: In *Using locks to protect shared resources*, we'll utilize a `Lock` object
    to keep threads from overwriting one another.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *使用锁来保护共享资源* 中，我们将利用 `Lock` 对象来防止线程相互覆盖。
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Tkinter's event queue
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter的事件队列
- en: As we discussed in *Chapter 11*, *Creating Automated Tests with unittest*, many
    tasks in Tkinter, such as drawing and updating widgets, are done asynchronously
    rather than taking immediate action when called in code. More specifically, the
    actions you perform in Tkinter, such as clicking a button, triggering a key bind
    or trace, or resizing a window, place an **event** in the event queue. On each
    iteration of the main loop, Tkinter pulls all outstanding events from the queue
    and processes them one at a time. For each event, Tkinter executes any **tasks**
    (that is, callbacks or internal operations like redrawing widgets) bound to the
    event before proceeding to the next event in the queue.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第11章* 中讨论的，*使用unittest创建自动化测试*，Tkinter中的许多任务，如绘图和更新小部件，都是异步执行的，而不是在代码中调用时立即采取行动。更具体地说，你在Tkinter中执行的操作，如点击按钮、触发键绑定或跟踪，或调整窗口大小，都会在事件队列中放置一个
    **事件**。在主循环的每次迭代中，Tkinter从队列中提取所有挂起的事件，并逐个处理它们。对于每个事件，Tkinter在继续处理队列中的下一个事件之前，执行与事件绑定的任何
    **任务**（即回调或重绘小部件等内部操作）。
- en: Tasks are roughly prioritized by Tkinter as either **regular** or **do-when-idle**
    (often referred to as **idle tasks**). During event processing, regular tasks
    are processed first, followed by idle tasks when all the regular tasks are finished.
    Most drawing or widget-updating tasks are classified as idle tasks, while actions
    like callback functions are, by default, regular priority.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter大致将任务优先级分为 **常规** 或 **空闲时执行**（通常称为 **空闲任务**）。在事件处理过程中，常规任务首先处理，当所有常规任务完成后，再处理空闲任务。大多数绘图或小部件更新任务被归类为空闲任务，而像回调函数这样的操作默认为常规优先级。
- en: Event queue control
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件队列控制
- en: Most of the time, we get the behavior we need from Tkinter by relying on higher-level
    constructs like `command` callbacks and `bind()`. However, there are situations
    where we might want to directly interact with the event queue and manually control
    how events are processed. We've already seen some of the functionality available
    to do this, but let's take a deeper look at them here.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们通过依赖高级构造，如 `command` 回调和 `bind()`，从Tkinter获得所需的行为。然而，在某些情况下，我们可能希望直接与事件队列交互并手动控制事件的处理方式。我们已经看到了一些可用于此目的的功能，但让我们在这里更深入地了解一下。
- en: The update() methods
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: update() 方法
- en: In *Chapter 11*, *Creating Automated Tests with unittest*, you learned about
    the `update()` and `update_idletasks()` methods. To review, these methods will
    cause Tkinter to execute any tasks for events currently in the queue; `update()`
    runs tasks for all events currently waiting in the queue until it's entirely clear,
    while `update_idletasks()` only runs the idle tasks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 11 章*，*使用 unittest 创建自动化测试* 中，你学习了 `update()` 和 `update_idletasks()` 方法。为了复习，这些方法将导致
    Tkinter 执行队列中当前所有事件的任何任务；`update()` 运行队列中所有当前等待的事件，直到完全清除，而 `update_idletasks()`
    只运行空闲任务。
- en: Since idle tasks are generally smaller and safer operations, it's recommended
    to use `update_idletasks()` unless you find it doesn't do the job.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空闲任务通常较小且更安全，除非你发现它不起作用，否则建议使用 `update_idletasks()`。
- en: Note that `update()` and `update_idletasks()` will cause the processing of *all*
    outstanding events for *all* widgets, regardless of what widget the method is
    called on. There is no way to only process events for a particular widget or Tkinter
    object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`update()` 和 `update_idletasks()` 将导致处理所有小部件的所有挂起事件，无论方法是在哪个小部件上调用。没有方法可以只处理特定小部件或
    Tkinter 对象的事件。
- en: The after() methods
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`after()` 方法'
- en: 'In addition to allowing us to control the processing of the queue, Tkinter
    widgets have two methods for adding arbitrary code to the event queue on a delay:
    `after()` and `after_idle()`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许我们控制队列的处理外，Tkinter 小部件还有两种方法可以在延迟后向事件队列添加任意代码：`after()` 和 `after_idle()`。
- en: 'Basic use of `after()` looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`after()` 的基本用法如下：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we're setting the `root.quit()` method to run after 1 second
    (1,000 milliseconds). What actually happens here is that an event bound to `root.quit`
    is added to the event queue, but with the condition that it shouldn't be executed
    until at least 1,000 milliseconds from the moment when `after()` is called. During
    that time period, any other events in the queue will be processed first. As a
    result, while the command will not be executed *sooner* than 1,000 milliseconds,
    it will very likely be executed *later*, depending on what else is being processed
    already in the event queue.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `root.quit()` 方法设置为在 1 秒（1,000 毫秒）后运行。实际上发生的情况是，一个绑定到 `root.quit`
    的事件被添加到事件队列中，但有一个条件，即它不应在从调用 `after()` 的那一刻起至少 1,000 毫秒内执行。在这段时间内，队列中的任何其他事件都将首先被处理。因此，虽然命令不会在
    1,000 毫秒内执行，但它很可能会在之后执行，具体取决于事件队列中已经正在处理的其他内容。
- en: The `after_idle()` method also adds a task to the event queue, but rather than
    giving it an explicit delay it simply adds it as an idle task, ensuring that it
    will be run after any regular tasks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`after_idle()` 方法也会将一个任务添加到事件队列中，但它不是提供一个明确的延迟，而是简单地将其添加为一个空闲任务，确保它将在任何常规任务之后运行。'
- en: 'In both methods, any additional arguments after the callback reference are
    simply passed to the callback as positional arguments; for example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种方法中，任何附加到回调引用的额外参数都简单地作为位置参数传递给回调；例如：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we're passing the arguments `'hello'`, `'Python'`, and `'programmers'`
    to a `print()` call. This statement will schedule the statement `print('hello',
    'Python', 'programmers!')` to be run as soon as possible after 1 second has elapsed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `'hello'`、`'Python'` 和 `'programmers'` 参数传递给一个 `print()` 调用。这个语句将计划在
    1 秒后尽可能快地运行 `print('hello', 'Python', 'programmers!')` 语句。
- en: Note that `after()` and `after_idle()` cannot take keyword arguments for the
    passed callable, only positional arguments.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`after()` 和 `after_idle()` 不能为传递的可调用对象接受关键字参数，只能接受位置参数。
- en: Code scheduled with `after()` can also be un-scheduled using the `after_cancel()`
    method. The method takes a task ID number, which is returned when we call `after()`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `after()` 方法计划的任务也可以使用 `after_cancel()` 方法取消计划。该方法接受一个任务 ID 号，该 ID 号是在我们调用
    `after()` 时返回的。
- en: 'For example, we could amend our previous example like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以修改之前的例子如下：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this script, we save the return value of `after()`, which gives us the ID
    of the scheduled task. Then, in the callback for our button, we call `after_cancel()`,
    passing in the ID value. Clicking the button before the 3 seconds is up results
    in the `root.quit` task being canceled and the application remaining open.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们保存了 `after()` 的返回值，这给我们提供了计划任务的 ID。然后，在我们的按钮回调中，我们调用 `after_cancel()`，传入
    ID 值。在 3 秒内点击按钮会导致 `root.quit` 任务被取消，应用程序保持打开状态。
- en: Common uses of event queue control
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件队列控制的一般用途
- en: In *Chapter 11*, *Creating Automated Tests with unittest*, we made good use
    of queue control methods to make sure our tests ran quickly and efficiently without
    having to wait on human interaction. There are a few different ways we can use
    these methods in actual applications though, which we'll look at here.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第11章**，**使用unittest创建自动化测试**中，我们很好地使用了队列控制方法，以确保我们的测试运行得既快又高效，而无需等待人工交互。尽管如此，我们可以在实际应用程序中使用这些方法的不同方式，我们将在下面探讨。
- en: Smoothing out display changes
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平滑显示更改
- en: In an application with dynamic GUI changes, the smoothness of these changes
    may suffer a bit as the windows resize in response to elements appearing and reappearing.
    For example, in the ABQ application, you may notice a smaller application window
    appearing just after login, which gets quickly resized as the GUI is built. This
    is not a major issue, but it detracts from the overall presentation of the application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有动态GUI更改的应用程序中，当窗口根据元素的出现和重新出现进行缩放时，这些更改的平滑性可能会略有下降。例如，在ABQ应用程序中，你可能会注意到登录后立即出现一个较小的应用程序窗口，随着GUI的构建，它很快就会被调整大小。这不是一个主要问题，但它会从整体上影响应用程序的展示。
- en: 'We can correct this by delaying the `deiconify()` call after login using `after()`.
    Inside `Application.__init__()`, let''s alter that line as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在登录后使用`after()`延迟`deiconify()`调用来纠正这个问题。在`Application.__init__()`内部，让我们将那行代码修改如下：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, instead of immediately restoring the application window after login, we
    have delayed the restore by a quarter of a second. While barely perceptible to
    the user, it gives Tkinter enough time to build and redraw the GUI before displaying
    the window, smoothing out the operation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再在登录后立即恢复应用程序窗口，而是将其延迟了四分之一秒。虽然对用户来说几乎察觉不到，但它给了Tkinter足够的时间在显示窗口之前构建和重绘GUI，从而平滑了操作。
- en: Use delayed code sparingly, and don't rely on it in situations where the delayed
    code's stability or security depends on some other process finishing first. This
    can lead to a **race condition**, in which some unforeseen circumstance like a
    slow disk or network connection can cause your delay to be insufficient to properly
    order the execution of code. In the case of our application, our delay is merely
    a cosmetic fix; nothing disastrous will happen if the application window is restored
    before it finishes drawing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应该谨慎使用延迟代码，并且不要在延迟代码的稳定性或安全性依赖于其他进程先完成的情况下依赖它。这可能导致**竞态条件**，在这种情况下，一些不可预见的情况，如缓慢的磁盘或网络连接，可能导致你的延迟不足以正确地安排代码的执行顺序。在我们的应用程序中，我们的延迟仅仅是一个表面上的修复；如果在应用程序窗口完成绘制之前恢复窗口，不会发生灾难性的事故。
- en: Mitigating GUI freezes
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓解GUI冻结
- en: Because callback tasks are prioritized over screen-updating tasks, a callback
    task that blocks code execution for an extended period of time can cause the program
    to seem frozen or stuck at an awkward point while the redrawing tasks wait for
    it to complete. One way to address this is to use the `after()` and `update()`
    methods to control the event queue processing manually. To see how this works,
    we'll build a simple application that uses these methods to keep the UI responsive
    during a long-running task.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于回调任务优先于屏幕更新任务，一个长时间阻塞代码执行的回调任务可能导致程序看起来冻结或卡在尴尬的位置，而重绘任务则等待其完成。解决这个问题的方法之一是使用`after()`和`update()`方法手动控制事件队列处理。为了了解这是如何工作的，我们将构建一个简单的应用程序，使用这些方法在长时间运行的任务期间保持UI响应。
- en: 'Start with this simple, but slow, application:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个简单但缓慢的应用程序开始：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This application uses `time.sleep()` to simulate some heavy processing task
    done in multiple phases. The GUI presents the user with a button, which launches
    the processes, and a status indicator to show progress.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序使用`time.sleep()`来模拟多个阶段完成的一些重处理任务。GUI向用户提供了一个按钮，用于启动进程，以及一个状态指示器来显示进度。
- en: 'When the user clicks the button, the status indicator is *supposed* to do the
    following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，状态指示器应该**应该**执行以下操作：
- en: Show **Starting process** for 2 seconds.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示**启动进程**2秒钟。
- en: Show **Phase 1**, **Phase 2**, through **Phase 4** for 2 seconds each.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示**阶段1**、**阶段2**，通过**阶段4**，每个阶段持续2秒钟。
- en: Finally, it should read **Complete**.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它应该显示为**完成**。
- en: If you try it, though, you'll see it does no such thing. Instead, it freezes
    up the moment the button goes down and does not unfreeze until all the phases
    are complete and the status reads **Complete**. Why does this happen?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果你尝试它，你会发现它并没有这样做。相反，当按钮按下时，它会立即冻结，并且不会解冻，直到所有阶段都完成并且状态显示为**完成**。为什么会发生这种情况？
- en: When the button-click event is processed by the main loop, the `run_process()`
    callback takes priority over any drawing tasks (since those are idle tasks) and
    is immediately executed, blocking the main loop until it returns. When the callback
    calls `self.status.set()`, the `status` variable's write events are placed in
    the queue (where they will eventually trigger a redraw event on the `Label` widget).
    However, processing of the queue is currently halted, waiting on the `run_process()`
    method to return. When it finally does return, all the updates to `status` that
    were waiting in the event queue are executed in a fraction of a second.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮点击事件由主循环处理时，`run_process()` 回调比任何绘图任务（因为那些是空闲任务）具有优先级，并且立即执行，阻塞主循环直到它返回。当回调调用
    `self.status.set()` 时，`status` 变量的写事件被放入队列（它们最终会在 `Label` 小部件上触发重绘事件）。然而，当前队列的处理已被暂停，等待
    `run_process()` 方法返回。当它最终返回时，所有等待在事件队列中的 `status` 更新都在一秒钟内执行。
- en: 'To make this a bit better, let''s schedule `run_process()` using `after()`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个方法更好一些，让我们使用 `after()` 来安排 `run_process()`：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, the loop part of `run_process()` is split off into a separate method
    called `_run_phases()`. The `run_process()` method itself just sets the starting
    status, then schedules `_run_phases()` to run 50 milliseconds later. This delay
    gives Tkinter time to finish up any drawing tasks and to update the status before
    kicking off the long blocking loop. The exact amount of time isn't critical in
    this case, just so long as it's sufficient for Tkinter to finish drawing operations,
    but short enough that users aren't likely to notice it; 50 milliseconds seems
    to do the job just fine.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`run_process()` 的循环部分被拆分到一个单独的方法 `_run_phases()` 中。`run_process()` 方法本身只是设置起始状态，然后安排
    `_run_phases()` 在 50 毫秒后运行。这个延迟给 Tkinter 时间来完成任何绘图任务并在启动长时间阻塞循环之前更新状态。在这种情况下，确切的时间并不重要，只要足够
    Tkinter 完成绘图操作，但又不至于让用户注意到；50 毫秒似乎可以很好地完成这项工作。
- en: We still aren't seeing individual phase status messages with this version, though;
    it goes directly from **Starting process** to **Complete** because the `_run_phases()`
    method is still blocking the event loop when it eventually runs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们仍然没有看到这个版本的各个阶段状态消息；它直接从 **开始进程** 跳到 **完成**，因为 `_run_phases()` 方法最终运行时仍然会阻塞事件循环。
- en: 'To fix this, we can use `update_idletasks()` in the loop:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在循环中使用 `update_idletasks()`：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By forcing Tkinter to run the remaining idle tasks in the queue before starting
    the long blocking method, our GUI kept is up to date. Unfortunately, there are
    some shortcomings to this approach:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强制 Tkinter 在开始长时间阻塞方法之前运行队列中的剩余空闲任务，我们的 GUI 保持更新。不幸的是，这种方法存在一些缺点：
- en: Firstly, the individual tasks still block the application while they're running.
    No matter how we break them up, the application will still be frozen while the
    individual units of the process are executing.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，单个任务在运行时仍然会阻塞应用程序。无论我们如何将其拆分，当处理过程的各个单元执行时，应用程序仍然会被冻结。
- en: Secondly, this approach is problematic for separation of concerns. In a real
    application, our processing phases are likely going to be running in a backend
    or model class of some kind. Those classes should not be manipulating GUI widgets.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，这种方法在关注点分离方面存在问题。在实际应用中，我们的处理阶段很可能会在某种后端或模型类中运行。这些类不应该操作 GUI 小部件。
- en: 'While these queue control methods can be useful for managing GUI-layer processes,
    it''s clear we need a better solution for working with slow background processes
    like the ABQ network upload functions. For those, we''ll need to use something
    more powerful: threads.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些队列控制方法可以用于管理 GUI 层面的进程，但很明显，我们需要一个更好的解决方案来处理像 ABQ 网络上传功能这样的慢速后台进程。对于这些，我们需要使用更强大的工具：线程。
- en: Running code in the background with threads
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程在后台运行代码
- en: All of the code we have written up to this point in the book can be described
    as **single-threaded**; that is, every statement is executed one at a time, the
    prior statement finishing before the next one is begun. Even asynchronous elements
    such as our Tkinter event queue, though they may change the order in which tasks
    are executed, still execute only one task at a time. This means that a long-running
    procedure like a slow network transaction or file read will unavoidably freeze
    up our application while it runs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 书中到目前为止所写的所有代码都可以描述为**单线程**；也就是说，每个语句一次执行一个，前一个语句完成之前，下一个语句才开始执行。即使像我们的Tkinter事件队列这样的异步元素可能会改变任务执行的顺序，但它们仍然一次只执行一个任务。这意味着像慢速网络事务或文件读取这样的长时间运行的过程不可避免地会在运行时冻结我们的应用程序。
- en: 'To see this in action, run the `sample_rest_service.py` script included with
    the example code for *Chapter 14* (make sure you run the *Chapter 14* version,
    not the *Chapter 13* version!). Now run ABQ Data Entry, make sure you''ve got
    some data in the database for today, and run the REST upload. The upload should
    take about 20 seconds, during which time the service script should be printing
    status messages like these:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个效果，请运行示例代码中包含的`sample_rest_service.py`脚本，该脚本对应于第14章（确保运行的是第14章版本，而不是第13章版本！）现在运行ABQ数据输入，确保你今天数据库中有一些数据，并运行REST上传。上传应该需要大约20秒，在这段时间内，服务脚本应该会打印出类似以下的状态消息：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Meanwhile, though, our GUI application is frozen. You'll find you cannot interact
    with any of the controls, and moving or resizing it may result in a blank gray
    window. Only when the upload process completes will your application become responsive
    again.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们的GUI应用程序会冻结。你会发现你无法与任何控件交互，移动或调整大小可能会导致一个空白的灰色窗口。只有当上传过程完成时，你的应用程序才会再次变得响应。
- en: To truly get around this problem, we need to create a **multi-threaded** application,
    in which multiple pieces of code can be run concurrently without needing to wait
    for one another. In Python, we can do this using the `threading` module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正解决这个问题，我们需要创建一个**多线程**应用程序，其中多个代码片段可以同时运行，而无需相互等待。在Python中，我们可以使用`threading`模块来实现这一点。
- en: The threading module
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程模块
- en: Multi-threaded application programming can be quite challenging to grasp fully,
    but the standard library's `threading` module makes working with threads about
    as simple as it can be.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程应用程序编程可能相当具有挑战性，但标准库的`threading`模块使得使用线程变得尽可能简单。
- en: 'To demonstrate the basic use of `threading`, let''s first create an intentionally
    slow function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`threading`的基本用法，让我们首先创建一个故意慢速的函数：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function takes a string and prints it at a rate of one word per second.
    This will simulate a long-running, computationally expensive process and give
    us some feedback that it's still running.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个字符串，并以每秒一个单词的速度打印它。这将模拟一个长时间运行、计算密集型的过程，并给我们一些反馈，表明它仍在运行。
- en: 'Let''s create a Tkinter GUI frontend for this function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个函数创建一个Tkinter GUI前端：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This simple application has a text entry and a button; when the button is pushed,
    the text in the entry is sent to the `print_slowly()` function. Run this code,
    then enter or paste a long sentence into the `Entry` widget.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的应用程序有一个文本输入框和一个按钮；当按钮被按下时，输入框中的文本会被发送到`print_slowly()`函数。运行此代码，然后在`Entry`小部件中输入或粘贴一个长句子。
- en: When you click the button, you'll see that the entire application freezes up
    as the words are printed to the console. That's because it's all running in a
    single execution thread.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击按钮时，你会看到整个应用程序冻结，因为单词被打印到控制台。这是因为所有操作都在单个执行线程中运行。
- en: 'Now let''s add the threading code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加线程代码：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time, we've imported the `Thread` class and created a new callback called
    `print_threaded()`. This callback uses a `Thread` object to run `print_slowly()`
    in its own execution thread.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们导入了`Thread`类并创建了一个名为`print_threaded()`的新回调。这个回调使用一个`Thread`对象在其自己的执行线程中运行`print_slowly()`。
- en: A `Thread` object takes a `target` argument that points to the callable which
    will be run in the new execution thread. It can also take an `args` tuple, which
    contains arguments to be passed into the `target` argument, and a `kwargs` dictionary,
    which will also be expanded in the `target` function's argument list.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`对象接受一个`target`参数，该参数指向将在新执行线程中运行的调用函数。它还可以接受一个`args`元组，该元组包含要传递给`target`参数的参数，以及一个`kwargs`字典，它也会在`target`函数的参数列表中展开。'
- en: To execute the `Thread` object, we call its `start()` method. This method does
    not block, so the `print_threaded()` callback immediately returns, allowing Tkinter
    to resume its event loop while `thread` executes in the background.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 `Thread` 对象，我们调用它的 `start()` 方法。此方法不会阻塞，因此 `print_threaded()` 回调立即返回，允许
    Tkinter 继续其事件循环，同时 `thread` 在后台执行。
- en: If you try this code, you'll see that the GUI no longer freezes while the sentence
    is printed. No matter how long the sentence, the GUI remains responsive the whole
    time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行此代码，你会看到在打印句子时 GUI 不会冻结。无论句子有多长，GUI 整个过程中都保持响应。
- en: Tkinter and thread safety
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tkinter 和线程安全
- en: Threading introduces a great deal of complication into a code base, and not
    all code is written to behave properly in a multi-threaded environment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 线程引入了大量的复杂性到代码库中，并不是所有的代码都是为在多线程环境中正确行为而编写的。
- en: We refer to code that is written with threading in mind as being **thread-safe**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑到线程的代码称为 **线程安全**。
- en: It's often repeated that Tkinter is not thread-safe; this isn't entirely true.
    Assuming your Tcl/Tk binaries have been compiled with thread support (which those
    included with the official Python distributions for Linux, Windows, and macOS
    have been), Tkinter should work fine in a multi-threaded program. However, the
    Python documentation warns us that there are still some edge cases where Tkinter
    calls across threads do not behave properly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 经常有人说 Tkinter 不是线程安全的；这并不完全正确。假设你的 Tcl/Tk 二进制文件已经编译了线程支持（Linux、Windows 和 macOS
    的官方 Python 发行版中包含的），Tkinter 应该在多线程程序中运行良好。然而，Python 文档警告我们，在跨线程调用中，Tkinter 仍然存在一些边缘情况，其行为可能不正确。
- en: The best way to avoid these issues is to keep our Tkinter code within a single
    thread and restrict our use of threads to non-Tkinter code (such as our model
    classes).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这些问题的最佳方式是将我们的 Tkinter 代码保持在单个线程中，并将线程的使用限制在非 Tkinter 代码（如我们的模型类）中。
- en: More information about Tkinter and threading can be found at [https://docs.python.org/3/library/tkinter.html#threading-model](https://docs.python.org/3/library/tkinter.html#threading-model).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Tkinter 和线程的更多信息可以在 [https://docs.python.org/3/library/tkinter.html#threading-model](https://docs.python.org/3/library/tkinter.html#threading-model)
    找到。
- en: Converting our network functions to threaded execution
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的网络函数转换为线程执行
- en: Passing a function to a `Thread` object's `target` argument is one way of running
    code in a thread; a more flexible and powerful approach is to subclass the `Thread`
    class and override its `run()` method with the code you want to execute. To demonstrate
    this approach, let's update the corporate REST upload feature we created for ABQ
    Data Entry in *Chapter 13*, *Connecting to the Cloud*, so that it runs the slow
    upload operation in a separate thread.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个函数传递给 `Thread` 对象的 `target` 参数是在线程中运行代码的一种方法；一个更灵活且强大的方法是继承 `Thread` 类，并用你想要执行的代码覆盖其
    `run()` 方法。为了演示这种方法，让我们更新在 *第13章*，*连接到云端* 中为 ABQ 数据录入创建的企业 REST 上传功能，使其在单独的线程中运行缓慢的上传操作。
- en: 'To begin, open up `models.py` and let''s import the `Thread` class, like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 `models.py` 并导入 `Thread` 类，如下所示：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Rather than having a `CorporateRestModel` method execute the upload, we're going
    to create a class based on `Thread` whose instances will be able to execute the
    upload operation in a separate thread. We'll call it `ThreadedUploader`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是让一个 `CorporateRestModel` 方法来执行上传，而是将创建一个基于 `Thread` 的类，其实例将能够在单独的线程中执行上传操作。我们将它命名为
    `ThreadedUploader`。
- en: To execute its upload, the `ThreadedUploader` instance will need an endpoint
    URL and a local file path; we can simply pass those to the object in its initializer.
    It will also need access to an authenticated session; that presents more of a
    problem. We might be able to get away with passing our authenticated `Session`
    object to the thread, but at the time of writing there is a great deal of uncertainty
    as to whether `Session` objects are thread-safe, so it's best to avoid sharing
    them between threads.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行其上传，`ThreadedUploader` 实例需要一个端点 URL 和本地文件路径；我们可以简单地将这些传递给对象在其初始化器中。它还需要访问认证会话；这会带来更多的问题。我们可能能够通过将我们的认证
    `Session` 对象传递给线程来解决这个问题，但在编写本文时，关于 `Session` 对象是否线程安全存在很大的不确定性，因此最好避免在线程之间共享它们。
- en: However, we don't really need the whole `Session` object, just the authentication
    token or session cookie.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们实际上并不需要整个 `Session` 对象，只需要认证令牌或会话cookie。
- en: 'It turns out that when we authenticate to the REST server, a cookie called
    `session` is placed in our cookie jar, which we can see by inspecting the `Session.cookies`
    object from a terminal, like so:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，当我们对REST服务器进行身份验证时，一个名为`session`的cookie被放置在我们的cookie jar中，我们可以通过检查终端中的`Session.cookies`对象来查看，如下所示：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `cookies` attribute is a `requests.CookieJar` object, which behaves in many
    ways like a dictionary. Each cookie has a unique name, which can be used to retrieve
    the cookie itself. In this case, our session cookie is called `session`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`cookies`属性是一个`requests.CookieJar`对象，它在许多方面都像字典一样工作。每个cookie都有一个唯一的名称，可以用来检索cookie本身。在这种情况下，我们的会话cookie被称为`session`。'
- en: Since the cookie itself is just a string, we can safely pass it to another thread.
    Once there, we'll create a new `Session` object and give it the cookie, after
    which it can authenticate requests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于cookie本身只是一个字符串，我们可以安全地将其传递给另一个线程。一旦到达那里，我们将创建一个新的`Session`对象，并将cookie传递给它，之后它就可以验证请求了。
- en: Immutable objects, including strings, integers, and floats, are always thread-safe.
    Since immutable objects can't be altered after creation, we don't have to worry
    that two threads will try to change the object at the same time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象，包括字符串、整数和浮点数，总是线程安全的。由于不可变对象在创建后不能被更改，我们不必担心两个线程会同时尝试更改对象。
- en: 'Let''s start our new uploader class as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下方式开始我们的新上传器类：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The initializer method starts by calling the superclass initializer to set up
    the `Thread` object, then assigns the passed `files_url` and `filepath` strings
    to instance attributes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化方法首先调用超类初始化器以设置`Thread`对象，然后将传递的`files_url`和`filepath`字符串分配给实例属性。
- en: 'Next, we create a new `Session` object and add the passed cookie value to the
    cookie jar by assigning it to the `session` key (the same key used in the original
    session''s cookie jar). Now we have all the information we need to execute an
    upload process. The actual process to be executed in the thread is implemented
    in its `run()` method, which we''ll add next:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的`Session`对象，并将传递的cookie值添加到cookie jar中，通过将其分配给`session`键（与原始会话的cookie
    jar中使用的相同键）。现在我们有了执行上传过程所需的所有信息。在线程中要执行的实际过程在其`run()`方法中实现，我们将在下面添加它：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that this code is essentially the code from the model's `upload()` method,
    except that the function arguments have been changed to instance properties.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码基本上是模型`upload()`方法的代码，只是函数参数已经被更改为了实例属性。
- en: Now, let's head over to our model and see how we can use this class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到我们的模型，看看我们如何使用这个类。
- en: The Python documentation recommends that you *only* override `run()` and `__init__()`
    when subclassing `Thread`. Other methods should be left alone for proper operation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python文档建议，在子类化`Thread`时，只重写`run()`和`__init__()`方法。其他方法应保持不变以确保正确操作。
- en: Using the threaded uploader
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用线程化上传器
- en: 'Now that we''ve created a threaded uploader, we just need to make `CorporateRestModel`
    use it. Find your model class and let''s rewrite the `upload_file()` method as
    follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个线程化的上传器，我们只需要让`CorporateRestModel`使用它。找到你的模型类，然后按照以下方式重写`upload_file()`方法：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we start by extracting the session cookie from our `Session` object, then
    pass it along with the URL and the file path to the `ThreadedUploader` initializer.
    Finally, we call the thread's `start()` method to begin execution of the upload.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先从我们的`Session`对象中提取会话cookie，然后将其与URL和文件路径一起传递给`ThreadedUploader`初始化器。最后，我们调用线程的`start()`方法以开始上传的执行。
- en: Now, give your REST upload another try and you'll see that the application doesn't
    freeze up. Great job! However, it doesn't quite behave how we'd like it to yet...
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次尝试你的REST上传，你会发现应用程序不会冻结。干得好！然而，它还没有完全按照我们希望的方式表现...
- en: Remember, you override the `run()` method, but call the `start()` method. Mixing
    these up will cause your code to either do nothing or block like a normal single-threaded
    call.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你重写了`run()`方法，但调用的是`start()`方法。混淆这些会导致你的代码要么什么都不做，要么像正常单线程调用一样阻塞。
- en: Passing messages using a queue
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用队列传递消息
- en: We've solved the problem of the program freezing up, but now we have some new
    problems. The most obvious problem is that our callback immediately shows a message
    box claiming that we've successfully uploaded the file, even though you can see
    from the server output that the process is still ongoing in the background. A
    subtler and far worse problem is that we aren't alerted to errors. If you try
    terminating the test service while the upload is running (so that the callback
    should fail), it will still immediately claim that the upload succeeded, even
    though you can see on the terminal that exceptions are being raised. What's going
    on here?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了程序冻结的问题，但现在我们遇到了一些新的问题。最明显的问题是我们的回调立即显示一个消息框，声称我们已经成功上传了文件，尽管你可以从服务器输出中看到该过程仍在后台进行。一个更微妙但更严重的问题是，我们没有收到错误通知。如果你在上传过程中尝试终止测试服务（因此回调应该失败），它仍然会立即声称上传成功，尽管你可以在终端上看到正在抛出异常。这里发生了什么？
- en: The first problem here is that the `Thread.start()` method doesn't block code
    execution. This is what we wanted, of course, but it now means our success dialog
    isn't waiting until the upload process is complete before it displays. As soon
    as the new thread is launched, the execution of code in the main thread continues
    in parallel with the new thread, immediately showing the success dialog.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题首先是 `Thread.start()` 方法不会阻塞代码执行。当然，这是我们想要的，但现在这意味着我们的成功对话框不会等待上传过程完成才显示。一旦启动新线程，主线程中的代码就会与新线程并行执行，立即显示成功对话框。
- en: The second problem is that code running in its own thread cannot pass exceptions
    caused in the thread's `run()` method back to the main thread. Those exceptions
    are raised within the new thread, and can only be caught in the new thread. As
    far as our main thread is concerned, the code in the `try` block executed just
    fine. In fact, the upload operation can't communicate failures *or* successes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，在其自己的线程中运行的代码无法将线程的 `run()` 方法中引起的异常传递回主线程。这些异常是在新线程中抛出的，并且只能在新线程中被捕获。就我们的主线程而言，`try`
    块中的代码执行得很好。事实上，上传操作无法通信失败或成功。
- en: In order to solve these problems, we need a way for the GUI and model threads
    to communicate, so that the upload thread can send error or progress messages
    back to the main thread to be handled appropriately. We can do this using a **queue**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们需要一种方式让 GUI 和模型线程进行通信，以便上传线程可以将错误或进度消息发送回主线程以适当处理。我们可以使用**队列**来实现这一点。
- en: The Queue object
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列对象
- en: 'Python''s `queue.Queue` class provides a **first-in first-out** (**FIFO**)
    data structure. Python objects can be placed into a `Queue` object using the `put()`
    method, and retrieved using the `get()` method; to see how this works, execute
    this in the Python shell:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `queue.Queue` 类提供了一个**先进先出**（**FIFO**）的数据结构。Python 对象可以使用 `put()` 方法放入
    `Queue` 对象中，并使用 `get()` 方法检索；要查看这是如何工作的，请在 Python shell 中执行以下操作：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This may not seem terribly exciting; after all, you can do essentially the same
    thing with a `list` object. What makes `Queue` useful, though, is that it is thread-safe.
    One thread can place messages on the queue, and another can retrieve them and
    respond appropriately.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来并不特别令人兴奋；毕竟，你可以用 `list` 对象做同样的事情。然而，使 `Queue` 有用之处在于它是线程安全的。一个线程可以将消息放置在队列上，另一个线程可以检索它们并相应地做出反应。
- en: By default, the queue's `get()` method will block execution until an item is
    received. This behavior can be altered by passing `False` as its first argument,
    or using the `get_nowait()` method. In no-wait mode, the method will return immediately,
    raising an exception if the queue is empty.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，队列的 `get()` 方法将阻塞执行，直到接收到一个项目。这种行为可以通过将 `False` 作为其第一个参数传递或使用 `get_nowait()`
    方法来改变。在不等待模式下，该方法将立即返回，如果队列为空，则抛出异常。
- en: 'To see how this works, execute the following in the shell:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这是如何工作的，请在 shell 中执行以下操作：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can also check whether the queue is empty using the `empty()` or `qsize()`
    methods; for example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `empty()` 或 `qsize()` 方法检查队列是否为空；例如：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, `empty()` returns a Boolean indicating if the queue is empty,
    and `qsize()` returns the number of items in the queue. `Queue` has several other
    methods that are useful in more advanced multi-threading situations, but `get()`,
    `put()`, and `empty()` will be sufficient to solve our problems.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`empty()` 返回一个布尔值，表示队列是否为空，而 `qsize()` 返回队列中的项目数量。`Queue` 类还有其他一些在更高级的多线程情况下有用的方法，但
    `get()`、`put()` 和 `empty()` 将足以解决我们的问题。
- en: Using queues to communicate between threads
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用队列在线程之间进行通信
- en: Before editing our application code, let's create a simple example application
    to make sure we understand how to use `Queue` to communicate between threads.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑我们的应用程序代码之前，让我们创建一个简单的示例应用程序，以确保我们理解如何使用 `Queue` 在线程之间进行通信。
- en: 'Start with a long-running thread:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个长时间运行的线程开始：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Backend` object is a subclass of `Thread` that takes a `Queue` object as
    an argument and saves it as an instance property. Its `run()` method simulates
    a long-running four-phase process using `print()` and `sleep()`. At the beginning,
    at the end, and before each phase, we use `queue.put()` to place a status message
    into the queue module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backend` 对象是 `Thread` 的一个子类，它接受一个 `Queue` 对象作为参数，并将其保存为实例属性。它的 `run()` 方法使用
    `print()` 和 `sleep()` 模拟一个长时间运行的四阶段过程。在开始、结束和每个阶段之前，我们使用 `queue.put()` 将状态消息放入队列模块。'
- en: 'Now we''ll create a frontend for this process in Tkinter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Tkinter 为此过程创建一个前端：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This simple application contains a `Label` object bound to a `status` control
    variable, a `Button` widget bound to a callback method, `go()`, and a `Queue`
    object stored as an instance variable. The idea is that, when we click the **Run
    process** button, the `go()` method will run our `Backend` class and the queued
    messages will be displayed in the label by way of the `status` control variable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的应用程序包含一个绑定到 `status` 控制变量的 `Label` 对象，一个绑定到回调方法 `go()` 的 `Button` 小部件，以及存储为实例变量的
    `Queue` 对象。想法是，当我们点击 **运行进程** 按钮时，`go()` 方法将运行我们的 `Backend` 类，并通过 `status` 控制变量将队列中的消息显示在标签上。
- en: 'Let''s create the `go()` method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 `go()` 方法：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `go()` method creates an instance of the `Backend` class, passing in the
    application's `Queue` object, and starts it. Because both threads now have a reference
    to `queue`, we can use it to communicate between them. We've already seen how
    `Backend` places status messages on the queue, so how should `App()` retrieve
    them?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`go()` 方法创建 `Backend` 类的一个实例，传入应用程序的 `Queue` 对象，并启动它。因为现在两个线程都有一个对 `queue`
    的引用，我们可以用它来在它们之间进行通信。我们已经看到 `Backend` 如何将状态消息放置在队列上，那么 `App()` 应该如何检索它们呢？'
- en: 'Maybe we could start a loop, like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们可以启动一个循环，如下所示：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That won't work, of course, because the loop will block; the Tkinter event loop
    would be stuck executing `go()`, freezing up the GUI and defeating the purpose
    of using a second thread. Instead, we need a way to periodically poll the `queue`
    object for status messages and update the status whenever one is received.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不会起作用，因为循环会阻塞；Tkinter 事件循环会卡在执行 `go()` 上，冻结 GUI，并违背使用第二个线程的目的。相反，我们需要一种方法来定期轮询
    `queue` 对象以获取状态消息，并在收到消息时更新状态。
- en: 'We''ll start by writing a method that can check the queue and respond appropriately:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个可以检查队列并相应响应的方法：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using the `Queue.empty()` method, we first find out if the queue is empty or
    not. If it is, we don't want to do anything, because `get()` will, by default,
    block until it receives a message, and we don't want to block execution. If the
    `queue` object contains items, we'll want to get those items and send them to
    our `status` variable. We're doing this in a `while` loop so that we only leave
    the function when the queue is empty.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Queue.empty()` 方法，我们首先找出队列是否为空。如果是，我们不想做任何事情，因为默认情况下 `get()` 会阻塞，直到它收到消息，我们不希望阻塞执行。如果
    `queue` 对象包含项目，我们将想要获取这些项目并将它们发送到我们的 `status` 变量。我们正在使用 `while` 循环这样做，这样我们只有在队列为空时才离开函数。
- en: This only performs one check, of course; we want to keep polling the queue module
    until the thread sends a `done` message. Thus, if our status is not `done`, we
    need to schedule another queue check.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只会执行一次检查；我们希望继续轮询队列模块，直到线程发送 `done` 消息。因此，如果我们的状态不是 `done`，我们需要调度另一个队列检查。
- en: 'That can be done with a call to `after()` at the end of `check_queue()`, like
    this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在 `check_queue()` 的末尾调用 `after()` 来完成，如下所示：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now `check_queue()` will do its job, then schedule itself to run again every
    `100` milliseconds until the status is `done`. All that remains is to kick off
    the process at the end of `go()`, like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `check_queue()` 将执行其工作，然后每 `100` 毫秒调度自己再次运行，直到状态为 `done`。剩下的只是在 `go()` 的末尾启动进程，如下所示：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you run this application, you'll see that we get status messages in (relatively)
    real time. Unlike the single-threaded application we created earlier in the chapter,
    there is no freezing, even while the tasks are running.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个应用程序，你会看到我们能够实时地（相对地）获得状态消息。与我们在本章早期创建的单线程应用程序不同，即使在任务运行时，也没有冻结。
- en: Adding a communication queue to our threaded uploader
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的线程上传器添加通信队列
- en: 'Let''s apply our knowledge of queues to fix the problems with the `ThreadedUploader`
    class. To begin, we''ll update the initializer signature so that we can pass in
    a `Queue` object, then store the object as an instance attribute, like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用我们对队列的知识来解决`ThreadedUploader`类的问题。首先，我们将更新初始化器签名，以便我们可以传入一个`Queue`对象，然后将其存储为实例属性，如下所示：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just as we did in our example application, we''ll create the `Queue` object
    in the `CorporateRestModel` object so that both the uploader and the model have
    a reference to it. In addition, we''ll save the queue as a public attribute of
    the model so that the application object can also reference it. To do that, we''ll
    first need to import `Queue` into `models.py`, so add this import at the top:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在示例应用程序中所做的那样，我们将在`CorporateRestModel`对象中创建`Queue`对象，以便上传者和模型都可以引用它。此外，我们将保存队列作为模型的公共属性，以便应用程序对象也可以引用它。为此，我们首先需要将`Queue`导入到`models.py`中，所以请在顶部添加此导入：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, back down in the `CorporateRestModel` initializer, create a `Queue` object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`CorporateRestModel`初始化器中，创建一个`Queue`对象：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we need to update the `upload_file()` method so that it passes the queue
    into the `ThreadedUploader` object:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`upload_file()`方法，以便它将队列传递给`ThreadedUploader`对象：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now the GUI can access the queue from `rest_model.queue`, and we can use that
    connection to send messages from our upload thread back to the GUI. Before we
    can use that connection, however, we need to develop a communications protocol.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GUI可以从`rest_model.queue`访问队列，我们可以使用这个连接从我们的上传线程向GUI发送消息。然而，在我们可以使用这个连接之前，我们需要开发一个通信协议。
- en: Creating a communications protocol
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建通信协议
- en: Now that we have established a channel for inter-thread communication, we have
    to decide how our two threads will communicate. In other words, what exactly will
    our uploader thread place on the queue, and how should our application thread
    respond to it? We could just throw anything into the queue and keep writing `if`
    statements on the app-side to deal with whatever shows up, but a better approach
    is to standardize communications by defining a simple protocol.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个线程间通信的通道，我们必须决定我们的两个线程将如何通信。换句话说，上传线程将确切地在队列上放置什么，以及我们的应用程序线程应该如何响应它？我们可以在队列中随意放入任何东西，并在应用程序端继续编写`if`语句来处理出现的任何内容，但更好的方法是通过对定义一个简单的协议来标准化通信。
- en: Our uploader thread will mainly be sending status-related information back to
    the application so that it can display updates about what's happening in message
    boxes or on the status bar. We will create a message format that we can use to
    determine what the thread is doing and communicate that to the user.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的上传线程将主要发送状态相关信息回应用程序，以便它可以在消息框或状态栏上显示正在发生的事情的更新。我们将创建一个消息格式，我们可以使用它来确定线程正在做什么，并将此信息传达给用户。
- en: 'The message structure will look like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 消息结构将看起来像这样：
- en: '| Field | Description |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| `status` | One word indicating the type of message, such as info or error
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `status` | 表示消息类型的单个单词，例如info或error |'
- en: '| `subject` | A short sentence summarizing the message |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `subject` | 总结消息的简短句子 |'
- en: '| `body` | A longer string with details about the message |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `body` | 包含关于消息详细信息的较长的字符串 |'
- en: We could create a structure like this using dictionary or a class, but simple
    collections of named fields like this are a great use-case for **named tuples**.
    The `collections.namedtuple()` function allows us to quickly create mini-classes
    that contain only named properties.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字典或类创建这样的结构，但像这样简单的命名字段集合是一个很好的用例。`collections.namedtuple()`函数允许我们快速创建只包含命名属性的迷你类。
- en: 'Creating a `namedtuple` class looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`namedtuple`类的样子如下：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is equivalent to writing:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于编写：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `namedtuple()` method is much faster to create than a class, and unlike
    a dictionary it enforces uniformity—that is, every `MyClass` object must have
    a `prop1` and a `prop2` attribute, whereas a dictionary is never required to have
    any particular keys.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple()`方法比创建一个类要快得多，并且与字典不同，它强制统一性——也就是说，每个`MyClass`对象都必须有`prop1`和`prop2`属性，而字典从不要求有特定的键。'
- en: 'At the top of the `models.py` file, let''s import `namedtuple` and use it to
    define a class called `Message`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models.py`文件的顶部，让我们导入`namedtuple`并使用它来定义一个名为`Message`的类：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we''ve created the `Message` class, making a new `Message` object
    is just like making an instance of any other class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`Message`类，创建一个新的`Message`对象就像创建任何其他类的实例一样：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's implement the use of these `Message` objects in our queue.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在队列中实现这些`Message`对象的使用。
- en: Sending messages from the uploader
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从上传器发送消息
- en: 'Now that we have established a protocol, it''s time to put it to use. Locate
    the `ThreadedUploader` class, and let''s update the `run()` method to send messages,
    starting with an informational message:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个协议，是时候将其付诸实践了。定位`ThreadedUploader`类，让我们更新`run()`方法以发送消息，从信息性消息开始：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our first message is just an informational message indicating that the upload
    is starting. Next, we''ll begin the upload and return some messages indicating
    the success or failure of the operation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一条消息只是一个信息性消息，表明上传开始。接下来，我们将开始上传并返回一些指示操作成功或失败的消息：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As before, we begin the upload process by opening the file and making our `PUT`
    request to the web service. This time, though, we run `raise_for_status()` in
    a `try` block. If we catch an exception from the operation, we put a message with
    a status of `error` on the queue along with the text of the exception. If we succeed,
    we place a success message on the queue.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们通过打开文件并向网络服务发出`PUT`请求开始上传过程。这次，我们在`try`块中运行`raise_for_status()`。如果操作中捕获到异常，我们在队列中放置一个状态为`error`的消息以及异常的文本。如果我们成功，我们在队列中放置一个成功消息。
- en: That's all that our `ThreadedUploader` needs to do; now we need to head over
    the GUI to implement a response to these messages.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`ThreadedUploader`需要做的；现在我们需要转向GUI以实现对这些消息的响应。
- en: Handling queue messages
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理队列消息
- en: Back in the `Application` object, we need to add some code to monitor the queue
    and take appropriate actions when a message is sent from the thread. As we did
    in our queue demo application, we'll create a method that uses the Tkinter event
    loop to periodically poll the queue and handle any messages sent from the model's
    queue object.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application`对象中，我们需要添加一些代码来监控队列，并在从线程发送消息时采取适当的行动。正如我们在队列演示应用程序中所做的那样，我们将创建一个方法，使用Tkinter事件循环定期轮询队列并处理从模型的队列对象发送的任何消息。
- en: 'Start the `Application._check_queue()` method like so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样启动`Application._check_queue()`方法：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The method accepts a `Queue` object, and starts by checking to see whether it
    has any items. If so, it retrieves one. Once we have one, we need to examine it
    and determine what to do with it based on the `status` value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个`Queue`对象，首先检查它是否有任何项目。如果有，它检索一个。一旦我们有一个，我们需要检查它并根据`status`值确定如何处理它。
- en: 'First, let''s handle a `done` status; add this code under the `if` block:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们处理一个`done`状态；在`if`块下添加此代码：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When our upload finishes successfully, we want to show a message box and set
    the status, then return without doing anything else.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的上传成功完成时，我们想要显示一个消息框并设置状态，然后返回而不做其他任何事情。
- en: The `Message` object's `status`, `subject`, and `body` attributes map nicely
    to the `title`, `message`, and `detail` arguments of the message box, so we've
    just passed those directly to it. We also show the subject of the message in the
    application's status bar by setting the `status` variable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`对象的`status`、`subject`和`body`属性很好地映射到消息框的`title`、`message`和`detail`参数，所以我们直接将它们传递给它。我们还通过设置`status`变量在应用程序的状态栏中显示消息的主题。'
- en: 'Next, we''ll handle `error` messages from the queue:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理队列中的`error`消息：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once again, we show a message box, this time using `showerror()`. We also want
    to exit the method, since the thread has presumably quit and we don't need to
    schedule the next queue check.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次显示一个消息框，这次使用`showerror()`。我们还想退出方法，因为线程可能已经退出，我们不需要安排下一次队列检查。
- en: 'Finally, let''s handle the `info` statuses:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们处理`info`状态：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Informational messages don't really warrant a modal message box, so we're just
    sending them to the status bar.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 信息性消息并不真正需要模态消息框，所以我们只是将它们发送到状态栏。
- en: 'The last thing we need to do in this method is make sure it gets called again
    if the thread is still going. Since `done` and `error` messages cause the method
    to return, if we''ve reached this point in the function the thread is still running
    and we should continue to poll it. So, we''ll add a call to `after()`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们最后需要确保如果线程仍在运行，它会被再次调用。由于`done`和`error`消息会导致方法返回，如果我们已经到达函数的这个点，线程仍在运行，我们应该继续轮询它。因此，我们将添加一个对`after()`的调用：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With `_check_queue()` written, we just need to eliminate the exception handling
    around `rest_model.upload_file()` at the end of `_upload_to_corporate_rest()`
    and call `_check_queue()` instead:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`_check_queue()`编写完成后，我们只需要消除`_upload_to_corporate_rest()`末尾围绕`rest_model.upload_file()`的异常处理，并调用`_check_queue()`代替：'
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This call doesn't need to be scheduled with `after()` since there will most
    likely not be a message on the first call, causing `_check_queue()` to just schedule
    its next call and return.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用不需要使用`after()`来调度，因为第一次调用很可能没有消息，导致`_check_queue()`只是调度其下一次调用并返回。
- en: Now that we've finished that update, launch the test server and the application
    and try the REST upload again. Watch the status bar and you'll see the progress
    getting displayed, ending with a message box when the process completes. Try it
    with the HTTP server turned off, and you should see an error message pop up right
    away.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了更新，启动测试服务器和应用程序，再次尝试REST上传。观察状态栏，你会看到进度条被显示出来，当过程完成时会显示一个消息框。尝试关闭HTTP服务器，你应该会立即看到一个错误消息弹出。
- en: Using locks to protect shared resources
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用锁来保护共享资源
- en: While it's great that our application no longer freezes up during slow file
    uploads, it raises a potential problem. Suppose a user tries to start a second
    REST upload while the first is ongoing? Go ahead and try this; launch the sample
    HTTP server and the application, and try to launch two REST uploads in quick succession,
    so that the second begins before the first finishes. Note the output from the
    REST server; depending on your timing, you may see confusing log messages with
    percentages going up and down as both threads upload files at the same time.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的应用程序在慢速文件上传期间不再冻结是件好事，但它也引发了一个潜在的问题。假设用户在第一个上传正在进行时尝试启动第二个REST上传？继续尝试这个操作；启动示例HTTP服务器和应用程序，并尝试快速连续启动两个REST上传，以便第二个在上一个完成之前开始。注意REST服务器的输出；根据你的时间，你可能会看到一些令人困惑的日志消息，百分比上下波动，因为两个线程同时上传文件。
- en: Of course, our sample REST server only simulates a slow link with `sleep()`;
    the actual file upload happens so fast it's unlikely to cause a problem. In a
    situation with a genuinely slow network, concurrent uploads could be more problematic.
    While it's possible that the receiving server is robust enough to sensibly handle
    two threads trying to upload the same file, it's best if we avoid that situation
    in the first place.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的示例REST服务器只是使用`sleep()`模拟慢速链接；实际的文件上传发生得非常快，不太可能引起问题。在真正慢速网络的情况下，并发上传可能会更成问题。虽然接收服务器可能足够健壮，可以合理地处理两个尝试上传相同文件的线程，但最好我们一开始就避免这种情况。
- en: What we need is some kind of flag that is shared between threads which can indicate
    if a thread is currently uploading so that others will know not to do so. We can
    do this using the `threading` module's `Lock` object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种某种类型的标志，它可以在线程之间共享，以指示一个线程是否正在上传，这样其他线程就会知道不要这样做。我们可以使用`threading`模块的`Lock`对象来实现这一点。
- en: Understanding the Lock object
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解锁对象
- en: 'A lock is a very simple object with two states: **acquired** and **released**.
    When a `Lock` object is in the released state, any thread may call its `acquire()`
    method to put it in the acquired state. Once a thread has acquired the lock, the
    `acquire()` method will block until the lock has been released by calling its
    `release()` method. That means that if another thread calls `acquire()`, its execution
    will wait until the lock is released by the first thread.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 锁是一个非常简单的对象，有两个状态：**获取**和**释放**。当`Lock`对象处于释放状态时，任何线程都可以调用它的`acquire()`方法将其置于获取状态。一旦一个线程获取了锁，`acquire()`方法将阻塞，直到通过调用其`release()`方法释放锁。这意味着如果另一个线程调用`acquire()`，它的执行将等待直到第一个线程释放锁。
- en: To see how this works, look at the `basic_threading_demo.py` script we created
    earlier in this chapter. Run that script from a terminal prompt, enter a sentence
    into the `Entry` widget, and click the **Run threaded** button.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这是如何工作的，请查看本章前面创建的`basic_threading_demo.py`脚本。从终端提示符运行该脚本，在`Entry`小部件中输入一个句子，然后点击**运行线程化**按钮。
- en: As we noted earlier, the sentence prints out at one word per second to the terminal
    output. But now, click the **Run threaded** button twice in quick succession.
    Notice that the output is a jumble of repeated words as the two threads simultaneously
    output text to the terminal. You can just imagine the havoc multiple threads could
    wreak upon a file or network session in a situation like this.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，句子以每秒一个单词的速度打印到终端输出。但现在，连续两次快速点击**运行线程**按钮。注意，输出是一团糟的重复单词，因为两个线程同时向终端输出文本。你可以想象在类似的情况下，多个线程会对文件或网络会话造成多大的破坏。
- en: 'To correct this, let''s create a lock. First, import `Lock` from the `threading`
    module and create an instance of it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这个问题，让我们创建一个锁。首先，从`threading`模块导入`Lock`并创建一个实例：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, inside the `print_slowly()` function, let''s add calls to `acquire()`
    and `release()` around the method, like so:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`print_slowly()`函数内部，让我们在方法周围添加对`acquire()`和`release()`的调用，如下所示：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save this file as `basic_threading_demo_with_lock.py` and run it again. Now,
    when you click the **Run threaded** button multiple times, each run waits for
    the previous one to release the lock before beginning. In this way, we can force
    threads to wait for each other while still maintaining a responsive application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`basic_threading_demo_with_lock.py`并再次运行。现在，当你多次点击**运行线程**按钮时，每次运行都会等待前一个运行释放锁后再开始。这样，我们可以在保持应用程序响应的同时强制线程相互等待。
- en: 'The `Lock` object can also be used as a context manager so that `acquire()`
    is called on entering the block and `release()` upon exiting. Thus, we could rewrite
    the preceding example like so:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock`对象也可以用作上下文管理器，这样在进入块时调用`acquire()`，在退出时调用`release()`。因此，我们可以将前面的示例重写如下：'
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using a Lock object to prevent concurrent uploads
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用锁对象防止并发上传
- en: 'Let''s apply our understanding of the `Lock` object to prevent concurrent uploading
    to the corporate REST server. To begin, we need to import `Lock` into `models.py`,
    like so:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将对`Lock`对象的理解应用到防止对公司的REST服务器并发上传。首先，我们需要将`Lock`导入到`models.py`中，如下所示：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we''ll create a `Lock` object as a class attribute of the `ThreadedUploader`
    class, like so:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`Lock`对象作为`ThreadedUploader`类的类属性，如下所示：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Recall from *Chapter 4*, *Organizing Our Code with Classes*, that objects assigned
    to class attributes are shared by all instances of the class. Therefore, by creating
    the lock as a class attribute, any `ThreadedUploader` thread will have access
    to the lock.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下*第4章*，*使用类组织代码*，分配给类属性的实例是共享的。因此，通过将锁作为类属性创建，任何`ThreadedUploader`线程都可以访问这个锁。
- en: 'Now, inside the `run()` method, we need to utilize our lock. The cleanest approach
    is to use it as a context manager, like so:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`run()`方法内部，我们需要使用我们的锁。最干净的方法是将其用作上下文管理器，如下所示：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Whether the `put()` call returns or raises an exception, the context manager
    will ensure that `release()` is called when the block exits so that other calls
    to `run()` can acquire the lock.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`put()`调用是返回还是抛出异常，上下文管理器都会确保在块退出时调用`release()`，以便其他对`run()`的调用可以获取锁。
- en: After adding this code, run the test HTTP server and the application again and
    try launching two REST uploads in quick succession. Now you should see that the
    second upload doesn't start until the first has completed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此代码后，再次运行测试HTTP服务器和应用程序，并尝试快速连续启动两个REST上传。现在你应该会看到第二个上传直到第一个完成才启动。
- en: Threading and the GIL
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程和GIL
- en: Whenever we discuss threading in Python, it's important to understand Python's
    **Global Interpreter Lock** (**GIL**) and how it affects threading.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们讨论Python中的线程时，了解Python的全局解释器锁（GIL）及其对线程的影响是非常重要的。
- en: The GIL is a lock mechanism that protects Python's memory management by preventing
    more than one thread from executing Python commands at the same time. Similar
    to the lock we implemented in our `ThreadedUploader` class, the GIL can be thought
    of like a token that can be held by only one thread at a time; whichever thread
    holds the token may execute Python instructions, and the rest have to wait.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: GIL是一种锁机制，通过防止多个线程同时执行Python命令来保护Python的内存管理。类似于我们在`ThreadedUploader`类中实现的锁，GIL可以被看作是一个只能由一个线程一次持有的令牌；持有令牌的线程可以执行Python指令，其余的则必须等待。
- en: 'It may seem like this defeats the idea of multi-threading on Python, However,
    there are two factors that mitigate the impact of the GIL:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是违背了Python多线程的理念，然而，有两个因素可以减轻GIL的影响：
- en: First, the GIL only limits the execution of *Python* code; many libraries execute
    code in other languages. For example, Tkinter executes TCL code, and `psycopg2`
    executes compiled C code. Non-Python code like this can run in a separate thread
    while Python code runs in another.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，GIL 只限制 Python 代码的执行；许多库在其它语言中执行代码。例如，Tkinter 执行 TCL 代码，而 `psycopg2` 执行编译后的
    C 代码。这类非 Python 代码可以在单独的线程中运行，同时 Python 代码在另一个线程中运行。
- en: Second, **Input/Output** (**I/O**) operations like disk access or network requests
    can run concurrently with Python code. For instance, when we make an HTTP request
    using `requests`, the GIL is released while waiting for the server to respond.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，**输入/输出**（**I/O**）操作，如磁盘访问或网络请求，可以与 Python 代码并发运行。例如，当我们使用 `requests` 发起
    HTTP 请求时，在等待服务器响应的过程中，全局解释器锁（GIL）会被释放。
- en: The only situation where the GIL really limits the utility of multi-threading
    is when we have computationally expensive Python code. Slow operations in typical
    data-oriented applications like ABQ are likely to be I/O-based operations, and
    for heavy-computation situations we can use non-Python libraries like `numpy`.
    Even so, it's good to be aware of the GIL and know that it may impact the effectiveness
    of a multi-threaded design.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: GIL 真正限制多线程效用的情况是当我们有计算密集型的 Python 代码时。在典型的以数据为导向的应用程序（如 ABQ）中的慢速操作很可能是 I/O
    基于的操作，对于计算密集型的情况，我们可以使用非 Python 库，如 `numpy`。即便如此，了解 GIL 并知道它可能会影响多线程设计的有效性仍然是好的。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use asynchronous and multi-threaded programming
    techniques to remove unresponsive behavior from your program. You learned how
    to work with and control Tkinter's event queue using the `after()` and `update()`
    methods, and how to apply these methods to solve problems in your application.
    You also learned how to use Python's `threading` module to run processes in the
    background, and how to utilize `Queue` objects to communicate between threads.
    Finally, you learned to use the `Lock` object to prevent shared resources from
    getting corrupted.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用异步和多线程编程技术从你的程序中移除无响应行为。你学习了如何使用 `after()` 和 `update()` 方法与 Tkinter
    的事件队列进行交互和控制，以及如何将这些方法应用于解决应用程序中的问题。你还学习了如何使用 Python 的 `threading` 模块在后台运行进程，以及如何利用
    `Queue` 对象在线程之间进行通信。最后，你学习了如何使用 `Lock` 对象防止共享资源被破坏。
- en: 'In the next chapter, we''re going to explore the most powerful widget in Tkinter:
    the Canvas. We''ll learn how to draw images and animate them, and create useful
    and informative charts.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索 Tkinter 中最强大的小部件：Canvas。我们将学习如何绘制图像和动画化它们，以及创建有用和富有信息量的图表。
