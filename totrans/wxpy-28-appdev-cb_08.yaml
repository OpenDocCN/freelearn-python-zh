- en: Chapter 8. Drawing to the Screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Screen drawing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing `SystemSettings`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `GraphicsContext`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing with `RendererNative`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing flicker in drawing routines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to display objects on a computer's display is one of the most basic
    functionalities of a GUI toolkit. In wxPython, objects are shown on the display
    through drawing commands issued to a **Device Context** (**DC**). Underneath the
    hood, all controls are represented as bitmaps that are drawn on the screen's display.
    The interface provided by a DC allows for the customization of a control's appearance.
    When used in combination with events, they are also the basis for creating new
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: These rudimentary tools open a number of doors and possibilities that allow
    the application designer to fill the gaps in what the toolkit provides in order
    to meet the specific needs of an application. Now that the tool has been presented,
    it is time to pick it up and put it to use.
  prefs: []
  type: TYPE_NORMAL
- en: Screen drawing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All windows that are visible on the screen issue some drawing commands to a
    Device Context (often referred to as a DC) to tell the system what kind of pixel
    information to display on the screen. Some control's classes, such as `wx.Control,
    wx.Window`, and `wx.Panel` allow for user-defined control of what is drawn on
    the screen through the use of `wx.EVT_PAINT`. This recipe provides an introduction
    to screen drawing by creating a simple little slideshow widget that will load
    a PNG or JPG file from a directory, and then draw that image on the screen along
    with some label text below it, to show which image is out of the set.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will look at our `ImageCanvas` widget. Starting with its constructor
    we `Bind` to `EVT_PAINT` so that we can get call backs from the framework when
    a part of our window has been marked as needing to be redrawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we override `DoGetBestSize` so that the widget can be resized depending
    upon the size of the image that is displayed in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in `OnPaint`, we handle `EVT_PAINT` and create a `PaintDC` to draw the
    current image on the Panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add a few methods for client code to interact with in order to
    change the image and set the image source directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That was pretty easy, so let's take a quick walkthrough to see how everything
    works. First we derived our `ImageCanvas` panel from `PyPanel` so that we could
    get access to some of its virtual methods. Next, in the constructor, we `Bind`
    our paint handler to `EVT_PAINT` so that we will get `PaintEvent` notifications.
  prefs: []
  type: TYPE_NORMAL
- en: The next method, `DoGetBestSize`, is a virtual override. The framework will
    call this method when it wants us to tell it what our best size is. This occurs
    when the layout is being calculated. We base the best size on the size of the
    current image, but reserve a minimum rectangle of 300x300 pixels just to ensure
    that we have some space to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Next we get to `OnPaint`. This is where the main focus of this recipe unfolds.
    The first thing to notice is that we create a `PaintDC`. This is a required step.
    If a `PaintDC` is not created within an `EVT_PAINT` handler, then on platforms
    such as Windows there will be errors when refreshing the window. The `PaintDC`
    provides the interface to the DC, which will allow us to draw on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the work in `OnPaint` is just calculating where to position what we
    want to draw. We do this by first getting the rectangle that we have to work in,
    which is simply returned by calling `GetClientRect`. From here, in the case where
    we have some images to display, we do some simple calculations to center the current
    image, and then use the DC's `DrawBitmap` method to draw our `Bitmap` object to
    the screen. Then we proceed to draw some text under the image to show what number
    the image is in the set. To do this, we use `GetTextExtent` to get the on-screen
    size that our string will require to be drawn with the current font. In the case
    where there are no images, we simply use the DC's `DrawLabel` function with the
    `ALIGN_CENTER` flag to draw a warning label in the middle of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate cycling through the images in the directory specified by calling
    `SetImageDir`, we have two methods: `Next` and `Previous`. These methods simply
    increment or decrement the index we are looking at in the list, and then call
    `Refresh. Refresh` will cause the system to issue a new `PaintEvent`. When this
    happens, our `OnPaint` handler will be called and will draw the new image. See
    the sample code that accompanies this recipe for a sample application using our
    `ImageCanvas` widget.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using Bitmaps* recipe in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with wxPython"), *Getting Started with wxPython* discusses the basics of using
    Bitmaps in an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* explains
    the usage of the `Py` classes and how to override their virtual methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides being able to draw text and bitmaps, DC's are also able to draw arbitrary
    shapes and lines. These rudimentary tools are what make it possible to create
    entirely custom widgets and controls, and to perform tasks such as drawing diagrams.
    This recipe explores these additional abilities of the `PaintDC` by creating a
    simple smiley face control.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will define our simple smiley face control that is derived from PyControl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here in, `OnPaint` is where we will draw our Smiley face onto the `PyControl''s`
    background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'First we will start by drawing the circle for the head, by finding the center
    of the control''s rectangle and using `DrawCircle` to draw a yellow circle with
    a black border, using the current Pen and Brush that was set above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to draw the eyes. This smiley face is going to have blue,
    square-shaped eyes. To do this, we first calculate the size of the eyes as 1/8th
    of the total face area, set the brush to blue, and then use the DC''s `DrawRectangle`
    method to draw each of the eyes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least is to draw the smile onto the face. To do this, we set the
    brush back to yellow and then use the DC''s `DrawArc` method to draw a slice of
    a circle. Since all we want is the bottom part of the arc to use as the smile,
    we finish by drawing a yellow rectangle over the top part of the slice, to cover
    up the wedge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we made use of a `Pen`, a `Brush`, and some of the rudimentary
    drawing routines that `PaintDC` provides us with. Let's take a look at our `OnPaint`
    method, to see how everything works.
  prefs: []
  type: TYPE_NORMAL
- en: First, we start off by setting up our DCs drawing tools. We set a black `Pen`,
    which will be used by the DC when it draws lines. We then set a yellow `Brush`.
    A `Brush` is used to fill the area inside of a shape when it is drawn. Next, we
    proceed to draw the face, which is a circle. To do this, we simply needed to find
    the center of our drawing area and then call the `DrawCircle` method with the
    center point and radius that we desire. The DC will then use our `Pen` and `Brush`
    to create a yellow circle with a black border drawn around it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, for the eyes, we decided to draw them as blue squares. So we changed to
    a blue `Brush` and called the `DrawRectangle` routine to draw the squares. This
    method's first two arguments are where the top left corner of the rectangle will
    be drawn from. The second two are the width and height of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to draw the smile, which is just a simple arc. To perform
    this step, we need to figure out where we want the arc's two end points to be,
    which we just based on the center point of our circle. Then we called the `DrawArc`
    method, which will draw a slice of a circle. Because it draws a slice, there will
    be two unwanted lines from the center point extending to the start and end points
    of the arc. To get rid of this, we drew a yellow rectangle over the top of these
    two lines to erase it and only leave the arc which makes up the smile.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a quick reference to the basic drawing functions of a `PaintDC`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Functions | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawArc(x1,y1,x2,y2, xcenter,ycenter)` | Draws a section of a circle with
    an arc from `x1,y1` to `x2,y2` centered from `xcenter,ycenter`. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawBitmap(bmp,x,y, useMask=False)` | Draws a bitmap at position `x,y`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawCheckMark(x,y,width, height)` | Draws a checkmark in the given rectangle.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawCircle(x,y,radius)` | Draws a circle with center point `x,y` and the
    given radius. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawEllipse(x,y,width,height)` | Draws an ellipse in the given rectangle.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawEllipticArc(x,y,w,h, start,end)` | Draw the arc of an ellipse in the
    given rectangle. The start and end parameters are angles that specify the start
    and end of the arc relative to the 3 o''clock position in the rectangle. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawIcon(icon, x, y)` | Draw an icon at `x,y`. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawImageLabel(lbl,bmp,rect, align)` | Draw a label and a bitmap in the
    given rectangle, using the given alignment flags. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawLabel(text,rect,align)` | Draw the text in the rectangle with the given
    alignment flags. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawLine(x1,y1,x2,y2)` | Draw a line with the current pen from `x1,y1` to
    `x2,y2`. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawPoint(x,y)` | Draw a point at `x,y` with the current pen. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawPolygon(points,x,y)` | Draw a polygon based on the list of points at
    position `x,y`. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawRectangle(x,y,w,h)` | Draw a rectangle of size `w,h` at position `x,y`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawRotatedText(text,x,y, angle)` | Draw text at position `x,y` rotated
    to the given angle. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawRoundedRectangle(x,y,w,h, angle)` | Draw a rectangle with rounded corners.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawSpline(points)` | Draw a spline using the list of points. |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawText(text,x,y)` | Draw text at position `x,y`. |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Screen drawing* recipe in this chapter for the basics of creating and
    using a `DeviceContext`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing SystemSettings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SystemSettings` object allows a program to query the system for information
    about default colors and fonts. Being able to know this information can be very
    helpful when creating custom drawings, as it makes it possible to use the same
    colors and fonts that the native system components are using, so that your custom
    control or window decoration can blend in and look like it belongs with the other
    native components that share the same window with it. In this recipe, we will
    use `SystemSettings` to create a custom control that is similar to a `StaticBox`
    but with a caption that is similar to the title bar of the `Frame` bar.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this custom control, we will again start by deriving from `PyPanel` so
    that we have access to its `DoGetBestSize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in our `EVT_PAINT` handler, we draw a simple caption at the top of the
    panel, and a border around the rest, using the caption color that we retrieve
    from the `SystemSettings` singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we derived our new `CaptionBox` class from `PyPanel`. This was
    done because this control is going to be a container of other controls, and the
    use of `PyPanel` will allow the use of sizers to manage the layout and sizing
    of the control.
  prefs: []
  type: TYPE_NORMAL
- en: As a part of the initial layout of the Panel in `__DoLayout`, we reserved 20
    pixels of space on the top and 8 pixels around the other sides, for the caption
    and border. This was done by putting in a spacer at the top plus an additional
    8 pixel border around the `BoxSizer` that will be used to layout the `CaptionBox's`
    children controls. Also as part of the layout management, we overrode `DoGetBestSize`
    in order to handle cases where the caption text is wider than the box's children
    windows. When using this class, its `AddItem` method must be used to add its children
    controls to it.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's check out how we draw the control. In `OnPaint`, the first thing we
    do is use the `SystemSettings` singleton to get the system-defined colours for
    a caption's background and text, which will allow the control to fit in and match
    other controls no matter what theme or operating system it is run on. Next, we
    shrink the drawing `Rect` by 2 pixels in both directions to define the controls
    border. After this, all there is to do is set the Pen to the caption color and
    call `DrawRect` to draw the border. The caption bar is also drawn in a similar
    fashion by creating a smaller rectangle in the upper space we had reserved in
    the layout and drawing a solid rectangle by setting the `Brush` to the caption
    color. All that leaves is the final step of drawing the caption text on the rectangle
    we just drew. See the following screenshot, which shows two `CaptionBoxes:`
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to being able to provide colors, the `SystemSettings` object can
    also provide system fonts and metrics. The three methods `GetColour, GetFont`,
    and `GetMetric` all take an index parameter that is one of the `wx.SYS_*` constants.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Screen drawing* recipe in this chapter for details of how to create
    and use a Device Context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a GraphicsContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GraphicsContext` is a new feature in wxPython2.8\. It provides access to
    the platform's higher-level drawing functionality. It provides features such as
    anti-aliasing, a floating point precision coordinate system, alpha blending, gradient
    brushes, and a handful of advanced methods. This recipe uses it to create a custom
    control that is like `StaticText`, but has a gradient-filled, pill-shaped background.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much like the other recipes in this chapter, we will derive our new control
    from `PyControl` so that we can override its `DoGetBestSize` method to size the
    control to our label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This time in `OnPaint`, we will create a GCDC from our `PaintDC` and do the
    drawing with the GCDC and its `GraphicsContext:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to draw this control in `OnPaint`, we took the `PaintDC` and wrapped
    it in a `GCDC`. A `GCDC` is a device context interface that uses a `GraphicsContext`
    internally. Using this interface makes it possible to use a `GraphicsContext`
    in a similar way to using a regular device context.
  prefs: []
  type: TYPE_NORMAL
- en: When setting up the `Pen` and `Brush`, we used a transparent pen in order to
    not draw a border round the control. Drawing a gradient-colored background with
    a `GraphicsContext` is made simple with the use of the `GraphicsBrush` returned
    by the `CreateLinearGradientBrush` method of `GraphicsContext`. This method will
    create a brush that draws a gradient from the first set of coordinates to the
    second set, starting with the first color and blending it to the second. In this
    case, our second color only differs in its alpha level, so the gradient will fade
    to partially-transparent, which will show the panel behind it.
  prefs: []
  type: TYPE_NORMAL
- en: All that is left now is to just call the `GraphicsContext's DrawRoundedRectangle`
    method, to draw a nice pill-shaped background that is filled with the gradient
    defined by the `GraphicsBrush` we created earlier. Then all that is left is to
    draw the label text on top of the background. To do this, we used the `DrawLabel`
    method of `GCDC` which is just like the `DrawLabel` method of `PaintDC` but uses
    the `GraphicsContext` under the hood to draw smooth, anti-aliased text. The following
    screenshot shows an example dialog with three instances of the `PodLabel` control
    on it. As can be seen, using the `GraphicsContext` has allowed the control to
    be drawn with smooth, anti-aliased edges and a gradient background that fades
    and becomes transparent near the bottom by taking advantage of the alpha blending
    of `GraphicsContext`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Screen drawing* recipe in this chapter discusses the use of Device Contexts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Drawing shapes* recipe in this chapter for an overview of the basic
    drawing routines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Reducing flicker in drawing routines* recipe in this chapter for more
    examples of using a `GraphicsContext`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing with RendererNative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RendererNative` is a class that contains a collection of functions that encapsulate
    the drawing of a native UI component. It allows you to draw things such as native-looking
    `Button` and `CheckBox` objects in a device context without needing to know any
    of the details about how it is done. This is a very powerful and useful class
    when you need to create generic widgets but want and maintain the native look
    and feel of the platform''s own widgets. This recipe uses `RendererNative` to
    create a custom button class for showing a drop-down menu.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This custom Button class will use `RendererNative` to do its drawing, based
    on the location and state of the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We override `DoGetBestSize` and use the size of the label string as the basis
    for calculating the button''s size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we add handlers for `EVT_LEFT_DOWN` and `EVT_LEFT_UP` to change the state
    of the control, and to show our pop-up menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in `OnPaint`, we create the required `PaintDC` and get a reference to
    the `RendererNative` singleton, which we will use to help us draw the Button''s
    background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have an API to allow the client code to set the Button''s pop-up
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a completely new custom button control that looks
    just like a regular native button but has a drop-down arrow and will show a `Menu`
    when clicked on. Using `RendererNative` to handle most of the drawing has greatly
    simplified the creation of this nice-looking control, so let's take a look at
    how it all came together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the `OnPaint` method, since it is where the control
    gets drawn. First, we created the required `PaintDC`, and then we used this to
    create a `GCDC` that will allow us to draw anti-aliased text just like the native
    control has. Then we get a reference to the `RendererNative` singleton by calling
    the classes `Get` method. Next, we start drawing the control. All the `RenderNative`
    methods take the same four arguments: the window we are drawing on, a DC, the
    `Rect`, and the renderer flags. `DrawPushButton` will draw a native button control
    with the given DC in the state specified by the renderer flag''s bitmask. We pass
    in one of three flags in this example: `0` for the default state, `CONTROL_CURRENT`
    for the hover-over state, and `CONTROL_PRESSED` for when the control is pressed.
    We finish up the rest with `DrawLabel` and `DrawDropArrow` to draw the button''s
    label with a down arrow to the right of it.'
  prefs: []
  type: TYPE_NORMAL
- en: To make this behave like a button, we bind to a number of mouse events in the
    `__init__` method of our control. `EVT_ENTER_WINDOW` and `EVT_LEAVE_WINDOW` are
    used to toggle the hover-over state by changing the control flag between `CONTROL_CURRENT`
    and `0\. EVT_LEFT_DOWN` is used to set the `CONTROL_PRESSED` state, and finally
    `EVT_LEFT_UP` is used to show the pop-up menu. After each state change, `Refresh`
    is called to re-invoke the `OnPaint` handler and draw the control in its new state.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Included below are some quick reference tables that list the drawing commands
    for `RendererNative`, and the state flags that affect how it draws the control.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table is a quick reference to the `RendererNative` methods. All
    the methods take the same first four arguments: `window, DC, rect`, and `flags`.'
  prefs: []
  type: TYPE_NORMAL
- en: '| `RendererNative` methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawCheckBox` | Draws a `CheckBox` |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawChoice` | Draws a `Choice` control |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawComboBox` | Draws a `ComboBox` |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawComboBoxDropButton` | Draws a `ComboBox` button |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawDropArrow` | Draws a drop arrow |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawHeaderButton` | Draws a `ListCtrl` column header |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawItemSelectionRect` | Draws a selection rectangle |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawPushButton` | Draws a `Button` |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawRadioButton` | Draws a `RadioButton` |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawSplitterBorder` | Draws the border of a `SplitterWindow` sash |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawSplitterSash` | Draws a `SplitterWindow` sash |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawTextCtrl` | Draws a `TextCtrl` |'
  prefs: []
  type: TYPE_TB
- en: '| `DrawTreeItemButton` | Draws a `TreeCtrl` node button |'
  prefs: []
  type: TYPE_TB
- en: Control Flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following flags can be passed as a part of a bitmask to the draw method''s
    `flags` parameter. Not passing any flags, or passing `0` for the `flags` parameter,
    results in the control being drawn in its default state:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTROL_CHECKABLE` | Control can be checked (for `DrawCheckBox)` |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTROL_CHECKED` | Control is checked (for `DrawCheckBox)` |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTROL_CURRENT` | Mouse is over the control |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTROL_DISABLED` | Control is disabled |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTROL_EXPANDED` | Only for `DrawTreeItemButton` |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTROL_FOCUSED` | Control has the keyboard focus |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTROL_ISDEFAULT` | Is default control (for `DrawPushButton)` |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTROL_PRESSED` | Button is pressed |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTROL_SELECTED` | Control is selected |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTROL_UNDETERMINED` | `CheckBox` is in undetermined state |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Playing with the mouse* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for some additional examples of working with
    `MouseEvents`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing flicker in drawing routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flicker occurs when the redrawing of the window leads to a visible flashing
    in the user interface. Even simple drawing routines, when done improperly, can
    lead to flicker. Luckily there are a number of things that can be done to combat
    and minimize flicker, which will then lead to an improved look and feel in an
    application's interface. This recipe shows a few snippets of three techniques
    that can be used to reduce flicker in drawing routines. The sample code that accompanies
    this chapter includes a sample application that uses all of these techniques in
    a simple animated wristwatch control.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with one of the simplest techniques, which is to avoid unnecessary
    background erasure events by binding to `EVT_ERASE_BACKGROUND:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need do nothing in the handler for it, in order to prevent it from
    erasing the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The next technique is to use a buffered `PaintDC` in the `OnPaint` handler,
    so that all the individual drawing steps are performed off-screen, and then the
    finished product is displayed on the screen in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The third technique is to just redraw the bare minimum of the screen when possible,
    by using the `Refresh` method''s `rect` argument to tell it the part of the window
    that needs to be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first technique that was shown creates an empty event handler and bind it
    to the `EVT_ERASE_BACKGROUND` event. This is usually the first thing to try when
    you are running into flicker issues in your drawing routines. By doing nothing
    in the event handler, we prevent the system from clearing the background, so that
    when we draw it again in `OnPaint` it will draw over the existing background.
    This reduces the visibility of the redraw because the background won't flash to
    white in between `EVT_ERASE_BACKGROUND` and `EVT_PAINT`.
  prefs: []
  type: TYPE_NORMAL
- en: The second technique uses an `AutoBufferedPaintDCFactory` in order to create
    a buffered `PaintDC` instead of a regular `PaintDC` in the `OnPaint` handler.
    Buffered DCs do all the drawing in an off-screen `Bitmap` and then `Blit` the
    whole new `Bitmap` to the screen in one operation. This greatly reduces flicker
    because the screen gets updated in one single change instead of many individual
    changes when drawing to the screen directly in an unbuffered DC.
  prefs: []
  type: TYPE_NORMAL
- en: The final technique shown was to only redraw the minimal part of the screen
    that needs to be redrawn. This technique can be used when a control needs to manually
    redraw only a part of itself due to a state change. For example, imagine a control
    that consists of some label text and an image. If the control has the behavior
    to change the label color on mouse over, it could call Refresh on itself using
    the `rect` argument to specify just the label's rectangle in the control, so that
    only that part of the control is updated, minimizing the area of the screen that
    is redrawn.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Handling events* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* explains the basics of event handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Using a GraphicsContext* recipe in this chapter for more detailed information
    on using the `GraphicsContext` class for drawing gradients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Using Timers* recipe in [Chapter 11](ch11.html "Chapter 11. Using Threads
    and Timers to Create Responsive Interfaces"), *Using Threads and Timers to Create
    Responsive Interfaces* for more information on using timers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
