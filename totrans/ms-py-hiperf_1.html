<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Profiling 101</h1></div></div></div><p>Just like any infant needs to learn how to crawl before running 100 mts with obstacles in under 12 seconds, programmers need to understand the basics of profiling before trying to master that art. So, before we start delving into the mysteries of performance optimization and profiling on Python programs, we need to have a clear understanding of the basics.</p><p>Once you know the basics, you'll be able to learn about the tools and techniques. So, to start us off, this chapter will cover everything you need to know about profiling but were too afraid to ask. In this chapter we will do the following things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We will provide a clear definition of what profiling is and the different profiling techniques.</li><li class="listitem" style="list-style-type: disc">We will explain the importance of profiling in the development cycle, because profiling is not something you do only once and then forget about it. Profiling should be an integral part of the development process, just like writing tests is.</li><li class="listitem" style="list-style-type: disc">We will cover things we can profile. We'll go over the different types of resources we'll be able to measure and how they'll help us find our problems.</li><li class="listitem" style="list-style-type: disc">We will discuss the risk of premature optimization, that is, why optimizing before profiling is generally a bad idea.</li><li class="listitem" style="list-style-type: disc">You will learn about running time complexity. Understanding profiling techniques is one step into successful optimization, but we also need to understand how to measure the complexity of an algorithm in order to understand whether we need to improve it or not.</li><li class="listitem" style="list-style-type: disc">We will also look at good practices. Finally, we'll go over some good practices to keep in mind when starting the profiling process of your project.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>What is profiling?</h1></div></div></div><p>A program that hasn't been optimized will normally spend most of its CPU cycles in some particular <a id="id0" class="indexterm"/>subroutines. Profiling is the analysis of how the code behaves in relation to the resources it's using. For instance, profiling will tell you how much CPU time an instruction is using or how much memory the full program is consuming. It is achieved by modifying either the source code of the program or the binary executable form (when possible) to use something called as a profiler.</p><p>Normally, developers profile their programs when they need to either optimize their performance or when those programs are suffering from some kind of weird bug, which can normally be associated with memory leaks. In such cases, profiling can help them get an in-depth understanding of how their code is using the computer's resources (that is, how many times a certain function is being called).</p><p>A developer can use this information, along with a working knowledge of the source code, to find the program's bottlenecks and memory leaks. The developer can then fix whatever is wrong with the code.</p><p>There are two main methodologies for profiling software: event-based profiling and statistical profiling. When using these types of software, you should keep in mind that they both have pros and cons.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Event-based profiling</h2></div></div></div><p>Not every<a id="id1" class="indexterm"/> programming language supports this type of profiling. Here <a id="id2" class="indexterm"/>are some programming languages that<a id="id3" class="indexterm"/> support event-based profiling:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Java</strong>: The <strong>JVMTI</strong> (<strong>JVM Tools Interface</strong>) provides hooks for profilers to trap<a id="id4" class="indexterm"/> events such as calls, thread-related events, class loads and so on</li><li class="listitem" style="list-style-type: disc"><strong>.NET</strong>: Just like with Java, the runtime provides events (<a class="ulink" href="http://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Testing/Profiling#Methods_of_data_gathering">http://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Testing/Profiling#Methods_of_data_gathering</a>)</li><li class="listitem" style="list-style-type: disc"><strong>Python</strong>: Using the <code class="literal">sys.setprofile</code> function, a developer can trap events such as <code class="literal">python_[call|return|exception]</code> or <code class="literal">c_[call|return|exception]</code></li></ul></div><p>
<strong>Event-based profilers</strong> (also known as <strong>tracing profilers</strong>) work by gathering data on specific events<a id="id5" class="indexterm"/> during the execution of our program. These profilers <a id="id6" class="indexterm"/>generate a large amount of data. Basically, the more events they listen to, the more data they will gather. This makes them somewhat impractical to use, and they are not the first choice when starting to profile a program. However, they are a good last resort when other profiling methods aren't enough or just aren't specific enough. Consider the case where you'd want to profile all the return statements. This type of profiler would give you the granularity you'd need for this task, while others would simply not allow you to execute this task.</p><p>A simple<a id="id7" class="indexterm"/> example of an event-based profiler on Python could be the<a id="id8" class="indexterm"/> following code (we'll understand this topic better once we reach the upcoming chapters):</p><div><pre class="programlisting">import sys

def profiler(frame, event, arg):
    print 'PROFILER: %r %r' % (event, arg)

sys.setprofile(profiler)

#simple (and very ineficient) example of how to calculate the Fibonacci sequence for a number.
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

def fib_seq(n):
    seq = [ ]
    if n &gt; 0:
        seq.extend(fib_seq(n-1))
    seq.append(fib(n))
    return seq

print fib_seq(2)</pre></div><p>The preceding code contributes to the following output:</p><div><pre class="programlisting">PROFILER: 'call' None
PROFILER: 'call' None
PROFILER: 'call' None
PROFILER: 'call' None
PROFILER: 'return' 0
PROFILER: 'c_call' &lt;built-in method append of list object at 0x7f570ca215f0&gt;
PROFILER: 'c_return' &lt;built-in method append of list object at 0x7f570ca215f0&gt;
PROFILER: 'return' [0]
PROFILER: 'c_call' &lt;built-in method extend of list object at 0x7f570ca21bd8&gt;
PROFILER: 'c_return' &lt;built-in method extend of list object at 0x7f570ca21bd8&gt;
PROFILER: 'call' None
PROFILER: 'return' 1
PROFILER: 'c_call' &lt;built-in method append of list object at 0x7f570ca21bd8&gt;
PROFILER: 'c_return' &lt;built-in method append of list object at 0x7f570ca21bd8&gt;
PROFILER: 'return' [0, 1]
PROFILER: 'c_call' &lt;built-in method extend of list object at 0x7f570ca55bd8&gt;
PROFILER: 'c_return' &lt;built-in method extend of list object at 0x7f570ca55bd8&gt;
PROFILER: 'call' None
PROFILER: 'call' None
PROFILER: 'return' 1
PROFILER: 'call' None
PROFILER: 'return' 0
PROFILER: 'return' 1
PROFILER: 'c_call' &lt;built-in method append of list object at 0x7f570ca55bd8&gt;
PROFILER: 'c_return' &lt;built-in method append of list object at 0x7f570ca55bd8&gt;
PROFILER: 'return' [0, 1, 1]
[0, 1, 1]
PROFILER: 'return' None
PROFILER: 'call' None
PROFILER: 'c_call' &lt;built-in method discard of set object at 0x7f570ca8a960&gt;
PROFILER: 'c_return' &lt;built-in method discard of set object at 0x7f570ca8a960&gt;
PROFILER: 'return' None
PROFILER: 'call' None
PROFILER: 'c_call' &lt;built-in method discard of set object at 0x7f570ca8f3f0&gt;
PROFILER: 'c_return' &lt;built-in method discard of set object at 0x7f570ca8f3f0&gt;
PROFILER: 'return' None</pre></div><p>As you <a id="id9" class="indexterm"/>can see, <code class="literal">PROFILER</code> is called on every event. We can<a id="id10" class="indexterm"/> print/gather the information we deem relevant inside the <code class="literal">PROFILER</code> function. The last line on the sample code shows that the simple execution of <code class="literal">fib_seq(2)</code> generates a lot of output data. If we were dealing with a real-world program, this output would be several orders of magnitude bigger. This is why event-based profiling is normally the last option when it comes to profiling. There are other alternatives out there (as we'll see) that generate much less output, but, of course, have a lower accuracy rate.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Statistical profiling</h2></div></div></div><p>Statistical profilers <a id="id11" class="indexterm"/>work by sampling the program counter at regular<a id="id12" class="indexterm"/> intervals. This in turn allows the developer to get an idea of how much time the target program is spending on each function. Since it works by sampling the PC, the resulting numbers will be a statistical approximation of reality instead of exact numbers. Still, it should be enough to get a glimpse of what the profiled program is doing and where the bottlenecks are.</p><p>Some advantages<a id="id13" class="indexterm"/> of this type of profiling are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Less data to analyze</strong>: Since we're only sampling the program's execution instead of saving every little piece of data, the amount of information to analyze will be significantly smaller.</li><li class="listitem" style="list-style-type: disc"><strong>Smaller profiling footprint</strong>: Due to the way the sampling is made (using OS interrupts), the target program suffers a smaller hit on its performance. Although the presence of the profiler is not 100 percent unnoticed, statistical profiling does less damage than the event-based one.</li></ul></div><p>Here is an <a id="id14" class="indexterm"/>example of the output of <strong>OProfile</strong> (<a class="ulink" href="http://oprofile.sourceforge.net/news/">http://oprofile.sourceforge.net/news/</a>), a Linux statistical profiler:</p><div><pre class="programlisting">Function name,File name,Times Encountered,Percentage
"func80000","statistical_profiling.c",30760,48.96%
"func40000","statistical_profiling.c",17515,27.88%
"func20000","static_functions.c",7141,11.37%
"func10000","static_functions.c",3572,5.69%
"func5000","static_functions.c",1787,2.84%
"func2000","static_functions.c",768,1.22%
"func1500","statistical_profiling.c",701,1.12%
"func1000","static_functions.c",385,0.61%
"func500","statistical_profiling.c",194,0.31%</pre></div><p>Here is the output of profiling the same Fibonacci code from the preceding code using a statistical profiler for Python called statprof:</p><div><pre class="programlisting">  %   cumulative      self          
 time    seconds   seconds  name    
100.00      0.01      0.01  B02088_01_03.py:11:fib
  0.00      0.01      0.00  B02088_01_03.py:17:fib_seq
  0.00      0.01      0.00  B02088_01_03.py:21:&lt;module&gt;
---
Sample count: 1
Total time: 0.010000 seconds</pre></div><p>As you can <a id="id15" class="indexterm"/>see, there is quite a difference between the output of both profilers for the same code.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>The importance of profiling</h1></div></div></div><p>Now that we know what profiling means, it is also important to understand how important and <a id="id16" class="indexterm"/>relevant it is to actually do it during the development cycle of our applications.</p><p>Profiling is not something everyone is used to do, especially with non-critical software (unlike peace maker embedded software or any other type of execution-critical example). Profiling takes time and is normally useful only after we've detected that something is wrong with our program. However, it could still be performed before that even happens to catch possible unseen bugs, which would, in turn, help chip away the time spent debugging the application at a later stage.</p><p>As hardware keeps advancing, getting faster and cheaper, it is increasingly hard to understand why we, as developers, should spend resources (mainly time) on profiling our creations. After all, we have practices such as test-driven development, code review, pair programming and others that assure us our code is solid and that it'll work as we want it. Right?</p><p>However, what we sometimes fail to realize is that the higher level our languages become (we've gone from assembler to JavaScript in just a few years), the less we think about CPU cycles, memory allocation, CPU registries, and so on. New generations of programmers learn their craft using higher level languages because they're easier to understand and provide more power out of the box. However, they also abstract the hardware and our interaction with it. As this tendency keeps growing, the chances that new developers will even consider profiling their software as another step on its development grows weaker by the second.</p><p>Let's look at the following scenario:</p><p>As we know, profiling measures the resources our program uses. As I've stated earlier, they keep getting cheaper and cheaper. So, the cost of getting our software out and the cost of making it available to a higher number of users is also getting cheaper.</p><p>These days, it is increasingly easy to create and publish an application that will be reached by thousands of people. If they like it and spread the word through social media, that number can blow up exponentially. Once that happens, something that is very common is that the software will crash, or it'll become impossibly slow and the users will just go away.</p><p>A possible explanation for the preceding scenario is, of course, a badly thought and non-scalable architecture. After all, one single server with a limited amount of RAM and processing power will get you so far until it becomes your bottleneck. However, another possible explanation, one that proves to be true many times, is that we failed to stress test our application. We didn't think about resource consumption; we just made sure our tests passed, and we were happy with that. In other words, we failed to go that extra mile, and as a result, our project crashed and burned.</p><p>Profiling can help<a id="id17" class="indexterm"/> avoid that crash and burn outcome, since it provides a fairly accurate view of what our program is doing, no matter the load. So, if we profile it with a very light load, and the result is that we're spending 80 percent of our time doing some kind of I/O operation, it might raise a flag for us. Even if, during our test, the application performed correctly, it might not do so under heavy stress. Think of a memory leak-type scenario. In those cases, small tests might not generate a big enough problem for us to detect it. However, a production deployment under heavy stress will. Profiling can provide enough evidence for us to detect this problem before it even turns into one.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>What can we profile?</h1></div></div></div><p>Going deeper into profiling, it is very important to understand what we can actually profile. Measuring<a id="id18" class="indexterm"/> is the core of profiling, so let's take a detailed look at the things we can measure during a program's execution.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Execution time</h2></div></div></div><p>The most basic <a id="id19" class="indexterm"/>of the numbers we can gather when profiling is the <a id="id20" class="indexterm"/>execution time. The execution time of the entire process or just of a particular portion of the code will shed some light on its own. If you have experience in the area your program is running (that is, you're a web developer and you're working on a web framework), you probably already know what it means for your system to take too much time. For instance, a simple web server might take up to 100 milliseconds when querying the database, rendering the response, and sending it back to the client. However, if the same piece of code starts to slow down and now it takes 60 seconds to do the same task, then you should start thinking about profiling. You also have to consider that numbers here are relative. Let's assume another process: a MapReduce job that is meant to process 2 TB of information stored on a set of text files takes 20 minutes. In this case, you might not consider it as a slow process, even when it takes considerably more time than the slow web server mentioned earlier.</p><p>To get this type of information, you don't really need a lot of profiling experience or even complex tools to get the numbers. Just add the required lines into your code and run the program.</p><p>For instance, the<a id="id21" class="indexterm"/> following code will calculate the Fibonnacci sequence <a id="id22" class="indexterm"/>for the number 30:</p><div><pre class="programlisting">import datetime

tstart = None
tend = None

def start_time():
    global tstart
    tstart = datetime.datetime.now()
def get_delta():
    global tstart
    tend = datetime.datetime.now()
    return tend - tstart
    
  

 def fib(n):
     return n if n == 0 or n == 1 else fib(n-1) + fib(n-2)

def fib_seq(n):
    seq = [ ]
    if n &gt; 0:
        seq.extend(fib_seq(n-1))
    seq.append(fib(n))
    return seq

start_time()
print "About to calculate the fibonacci sequence for the number 30"
delta1 = get_delta()

start_time()
seq = fib_seq(30) 
delta2 = get_delta()

print "Now we print the numbers: "
start_time()
for n in seq:
    print n
delta3 = get_delta()

print "====== Profiling results ======="
print "Time required to print a simple message: %(delta1)s" % locals()
print "Time required to calculate fibonacci: %(delta2)s" % locals()
print "Time required to iterate and print the numbers: %(delta3)s" % locals()
print "======  ======="</pre></div><p>Now, the<a id="id23" class="indexterm"/> code<a id="id24" class="indexterm"/> will produce the following output:</p><div><pre class="programlisting">About to calculate the Fibonacci sequence for the number 30
Now we print the numbers: 
0
1
1
2
3
5
8
13
21
#...more numbers
4181
6765
10946
17711
28657
46368
75025
121393
196418
317811
514229
832040
====== Profiling results =======
<strong>Time required to print a simple message: 0:00:00.000030</strong>
<strong>Time required to calculate fibonacci: 0:00:00.642092</strong>
<strong>Time required to iterate and print the numbers: 0:00:00.000102</strong>
</pre></div><p>Based on the last three lines, we see the obvious results: the most expensive part of the code is the actual calculation of the Fibonacci sequence.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Where are the bottlenecks?</h2></div></div></div><p>Once you've measured how much time your code needs to execute, you can profile it by paying special attention to the slow sections. These are the bottlenecks, and normally, they are related to one or a combination of the following reasons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Heavy I/O operations, such as reading and parsing big files, executing long-running database queries, calling external services (such as HTTP requests), and so on</li><li class="listitem" style="list-style-type: disc">Unexpected<a id="id25" class="indexterm"/> memory leaks that start building up until there is no memory left for the rest of the program to execute properly</li><li class="listitem" style="list-style-type: disc">Unoptimized code that gets executed frequently</li><li class="listitem" style="list-style-type: disc">Intensive operations that are not cached when they could be</li></ul></div><p>I/O-bound code (file reads/write, database queries, and so on) is usually harder to optimize, because that would imply changing the way the program is dealing with that I/O (normally using core functions from the language). Instead, when optimizing compute-bound code (like a function that is using a badly implemented algorithm), getting a performance improvement is easier (although not necessarily easy). This is because it just implies rewriting it.</p><p>A general indicator that you're near the end of a performance optimization process is when most of the bottlenecks left are due to I/O-bound code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Memory consumption and memory leaks</h1></div></div></div><p>Another very important resource to consider when developing software is memory. Regular software <a id="id26" class="indexterm"/>developers don't really care much about it, since the <a id="id27" class="indexterm"/>era of the 640 KB of RAM PC is long dead. However, a memory leak on a long-running program can turn any server into a 640 KB computer. Memory consumption is not just about having enough memory for your program to run; it's also about having control over the memory that your programs use.</p><p>There are some developments, such as embedded systems, that actually require developers to pay extra attention to the amount of memory they use, because it is a limited resource in those systems. However, an average developer can expect their target system to have the amount of RAM they require.</p><p>With RAM and higher level languages that come with automatic memory management (like garbage collection), the developer is less likely to pay much attention to memory utilization, trusting the platform to do it for them.</p><p>Keeping track of memory consumption is relatively straightforward. At least for a basic approach, just use your OS's task manager. It'll display, among other things, the amount of memory used or at least the percentage of total memory used by your program. The task manager is<a id="id28" class="indexterm"/> also a great tool to check your CPU time consumption. As <a id="id29" class="indexterm"/>you can see in the next screenshot, a simple Python program (the preceding one) is taking up almost the entire CPU power (99.8 percent), and barely 0.1 percent of the total memory that is available:</p><div><img src="img/B02088_01_01.jpg" alt="Memory consumption and memory leaks"/></div><p>With a tool like that (the <code class="literal">top</code> command line tool from Linux), spotting memory leaks can be easy, but that will depend on the type of software you're monitoring. If your program is constantly loading data, its memory consumption rate will be different from another program that doesn't have to deal much with external resources.</p><p>For instance, if we were to chart the memory consumption over time of a program dealing with lots <a id="id30" class="indexterm"/>of external data, it would look like the following <a id="id31" class="indexterm"/>chart:</p><div><img src="img/B02088_01_02.jpg" alt="Memory consumption and memory leaks"/></div><p>There will be peaks, when these resources get fully loaded into memory, but there will also be some drops, when those resources are released. Although the memory consumption numbers fluctuate quite a bit, it's still possible to estimate the average amount of memory that the program will use when no resources are loaded. Once you define that area (marked as a green box in the preceding chart), you can spot memory leaks.</p><p>Let's look at how the same chart would look with bad resource handling (not fully releasing allocated memory):</p><div><img src="img/B02088_01_03.jpg" alt="Memory consumption and memory leaks"/></div><p>In the preceding<a id="id32" class="indexterm"/> chart, you can clearly see that not all memory is<a id="id33" class="indexterm"/> released when a resource is no longer used, which is causing the line to move out of the green box. This means the program is consuming more and more memory every second, even when the resources loaded are released.</p><p>The same can be done with programs that aren't resource heavy, for instance, scripts that execute a particular processing task for a considerable period of time. In those cases, the memory consumption and the leaks should be easier to spot.</p><p>Let's take a look at an example:</p><div><img src="img/B02088_01_04.jpg" alt="Memory consumption and memory leaks"/></div><p>When the <a id="id34" class="indexterm"/>processing stage starts, the memory consumption <a id="id35" class="indexterm"/>should stabilize within a clearly defined range. If we spot numbers outside that range, especially if it goes out of it and never comes back, we're looking at another example of a memory leak.</p><p>Let's look at an example of such a case:</p><div><img src="img/B02088_01_05.jpg" alt="Memory consumption and memory leaks"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The risk of premature optimization</h1></div></div></div><p>Optimization is normally considered a good practice. However, this doesn't hold true when the act <a id="id36" class="indexterm"/>of optimization ends up driving the design decisions of the software solution.</p><p>A very common pitfall developers face while starting to code a new piece of software is premature optimization.</p><p>When this happens, the end result ends up being quite the opposite of the intended optimized code. It can contain an incomplete version of the required solution, or it can even contain errors derived from the optimization-driven design decisions.</p><p>As a normal rule of thumb, if you haven't measured (profiled) your code, optimizing it might not be the best idea. First, focus on readable code. Then, profile it and find out where the real bottlenecks are, and as a final step, perform the actual optimization.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Running time complexity</h1></div></div></div><p>When profiling <a id="id37" class="indexterm"/>and optimizing code, it's really important to understand what <strong>Running time complexity</strong> (<strong>RTC</strong>) is and how we can use that knowledge to properly optimize our code.</p><p>RTC helps quantify the execution time of a given algorithm. It does so by providing a mathematical approximation of the time a piece of code will take to execute for any given input. It is an approximation, because that way, we're able to group similar algorithms using that value.</p><p>RTC is expressed<a id="id38" class="indexterm"/> using something called <strong>Big O notation</strong>. In mathematics, Big O notation is used to express the limiting behavior of a given function when the terms tend to infinity. If I apply that concept in computer science, we can use Big O notation to express the limiting behavior of the function describing the execution time.</p><p>In other words, this notation will give us a broad idea of how long our algorithm will take to process an arbitrarily large input. It will not, however, give us a precise number for the time of execution, which would require a more in-depth analysis of the source code.</p><p>As I've said earlier, we can use this tendency to group algorithms. Here are some of the most common groups:</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Constant time – O(1)</h2></div></div></div><p>This is the<a id="id39" class="indexterm"/> simplest of them all. This notation basically means that the <a id="id40" class="indexterm"/>action we're measuring will always take a constant amount of time, and this time is not dependent on the size of the input.</p><p>Here are some examples of code that have <em>O(1)</em> execution time:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Determining whether a number is odd or even:<div><pre class="programlisting">if number % 2:
  odd = True 
else:
  odd = False</pre></div></li><li class="listitem" style="list-style-type: disc">Printing a message into standard output:<div><pre class="programlisting">print "Hello world!"</pre></div></li></ul></div><p>Even <a id="id41" class="indexterm"/>something more conceptually complex, like finding the value <a id="id42" class="indexterm"/>of a key inside a dictionary (or hash table), if implemented correctly, can be done in constant time. Technically speaking, accessing an element on the hash takes <em>O(1)</em> amortized time, which roughly means that the average time each operation takes (without taking into account edge cases) is a constant <em>O(1)</em> time.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Linear time – O(n)</h2></div></div></div><p>Linear time <a id="id43" class="indexterm"/>dictates that for a given input of arbitrary length <em>n</em>, the <a id="id44" class="indexterm"/>amount of time required for the execution of the algorithm is linearly proportional to <em>n</em>, for instance, <em>3n</em>, <em>4n + 5</em>, and so on.</p><div><img src="img/B02088_01_06.jpg" alt="Linear time – O(n)"/></div><p>The preceding chart clearly shows that both the blue (<em>3n</em>) line and the red one (<em>4n + 5</em>) have the same upper limit as the black line (<em>n</em>) when <em>x</em> tends to infinity. So, to simplify, we can just say that all three functions are <em>O(n)</em>.</p><p>Examples<a id="id45" class="indexterm"/> of algorithms with this execution order are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Finding<a id="id46" class="indexterm"/> the smallest value in an unsorted list</li><li class="listitem" style="list-style-type: disc">Comparing two strings</li><li class="listitem" style="list-style-type: disc">Deleting the last item inside a linked list</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Logarithmic time – O(log n)</h2></div></div></div><p>An algorithm <a id="id47" class="indexterm"/>with logarithmic execution time is one that will have <a id="id48" class="indexterm"/>a very determined upper limit time. A logarithmic function grows quickly at first, but it'll slow down as the input size gets bigger. It will never stop growing, but the amount it grows by will be so small that it will be irrelevant.</p><div><img src="img/B02088_01_07.jpg" alt="Logarithmic time – O(log n)"/></div><p>The preceding chart shows three different logarithmic functions. You can clearly see that they all possess<a id="id49" class="indexterm"/> a similar shape, including the upper limit <em>x</em>, which <a id="id50" class="indexterm"/>keeps increasing to infinity.</p><p>Some examples of algorithms that have logarithmic execution time are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Binary search</li><li class="listitem" style="list-style-type: disc">Calculating Fibonacci numbers (using matrix multiplications)</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Linearithmic time – O(nlog n)</h2></div></div></div><p>A particular<a id="id51" class="indexterm"/> combination of the previous two orders of execution <a id="id52" class="indexterm"/>is the linearithmic time. It grows quickly as soon as the value of <em>x</em> starts increasing.</p><p>Here are some examples of algorithms that have this order of execution:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Merge sort</li><li class="listitem" style="list-style-type: disc">Heap sort</li><li class="listitem" style="list-style-type: disc">Quick sort (at least its average time complexity)</li></ul></div><p>Let's see a few examples of plotted linearithmic functions to understand them better:</p><div><img src="img/B02088_01_08.jpg" alt="Linearithmic time – O(nlog n)"/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Factorial time – O(n!)</h2></div></div></div><p>Factorial time is<a id="id53" class="indexterm"/> one of the worst execution times we might get <a id="id54" class="indexterm"/>out of an algorithm. It grows so quickly that it's hard to plot.</p><p>Here is a rough approximation of how the execution time of our algorithm would look with factorial time:</p><div><img src="img/B02088_01_09.jpg" alt="Factorial time – O(n!)"/></div><p>An example of an<a id="id55" class="indexterm"/> algorithm with factorial execution time is the solution<a id="id56" class="indexterm"/> for the traveling salesman using brute force search (basically checking every single possible solution).</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Quadratic time – O(n^)</h2></div></div></div><p>Quadratic <a id="id57" class="indexterm"/>execution time is another example of a fast growing <a id="id58" class="indexterm"/>algorithm. The bigger the input size, the longer it's going to take (this is true for most complexities, but then again, specially true for this one). Quadratic execution time is even less efficient that linearithmic time.</p><p>Some examples of algorithms having this order of execution are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Bubble sort</li><li class="listitem" style="list-style-type: disc">Traversing a 2D array</li><li class="listitem" style="list-style-type: disc">Insertion sort</li></ul></div><p>Here are some examples of plotted exponential functions:</p><div><img src="img/B02088_01_10.jpg" alt="Quadratic time – O(n^)"/></div><p>Finally, let's<a id="id59" class="indexterm"/> look at all examples plotted together to get a clear idea <a id="id60" class="indexterm"/>of algorithm efficiency:</p><div><img src="img/B02088_01_11.jpg" alt="Quadratic time – O(n^)"/></div><p>Leaving <a id="id61" class="indexterm"/>aside constant execution time, which is clearly faster<a id="id62" class="indexterm"/> but most of the time impossible to achieve in complex algorithms, the order or preference should be:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Logarithmic</li><li class="listitem" style="list-style-type: disc">Linear</li><li class="listitem" style="list-style-type: disc">Linearithmic</li><li class="listitem" style="list-style-type: disc">Quadratic</li><li class="listitem" style="list-style-type: disc">Factorial</li></ul></div><p>Obviously, there are cases when you'll have no choice but to get a quadratic execution time as the best possible result. The idea is to always aim for the faster algorithms, but the limitations of your problems and technology will affect the actual result.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Note that between quadratic and factorial times, there are several other alternatives (cubic, <em>n ^ 4</em>, and so on).</p></div></div><p>Another important consideration is that most algorithms don't have only a single order of execution time. They can have up to three orders of execution time: for the best case, normal case, and worst case scenarios. The scenario is determined by the properties of the input data. For instance, the insertion sort algorithm will run much faster if the input is already sorted (best case), and it will be worst (exponential order) for other types of input.</p><p>Other interesting <a id="id63" class="indexterm"/>cases to look at are the data types used. They inherently<a id="id64" class="indexterm"/> come with execution time that is associated with actions you can perform on them (lookup, insert, search, and so on). Let's look at some of the most common data types and their associated actions:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Data Structure</p>
</th><th colspan="8" style="text-align: center" valign="bottom">
<p>Time complexity</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> </td><td colspan="4" style="text-align: center" valign="top">
<p>
<strong>Average case</strong>
</p>
</td><td colspan="4" style="text-align: center" valign="top">
<p>
<strong>Worst case</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<strong>Indexing</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<strong>Search</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<strong>Insertion</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<strong>Deletion</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<strong>Indexing</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<strong>Search</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<strong>Insertion</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<strong>Deletion</strong>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>List</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>-</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>-</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>-</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>-</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Linked list</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Doubly linked list</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Dictionary</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>-</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(1)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>-</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Binary search tree</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(log(n))</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(log(n))</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(log(n))</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(log(n))</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>
<em>O(n)</em>
</p>
</td></tr></tbody></table></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Profiling best practices</h1></div></div></div><p>Profiling is a<a id="id65" class="indexterm"/> repetitive task. You'll do it several times inside the same project in order to get the best results, and you'll do it again on the next project. Just like with any other repetitive task in software development, there is a set of best practices you can follow to ensure that you get the most out of the process. Let's look at some of them:</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Build a regression-test suite</h2></div></div></div><p>Before starting any kind of optimization process, you need to make sure that the changes you make to <a id="id66" class="indexterm"/>the code will not affect its functioning in a bad way. The best way to do this, especially when it's a big code base, is to create a test suite. Make sure that your code coverage is high enough to provide the confidence you need to make the changes. A test suite with 60 percent code coverage can lead to very bad results.</p><p>A regression-test suite will allow you to make as many optimization tries as you need to without fear of breaking the code.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Mind your code</h2></div></div></div><p>Functional code tends to be easier to refactor, mainly because the functions structured that way tend to<a id="id67" class="indexterm"/> avoid side effects. This reduces any risk of affecting unwanted parts of your system. If your functions avoid a local mutable state, that's another winning point for you. This is because the code should be pretty straightforward for you to understand and change. Functions that don't follow the previously mentioned guidelines will require more work and care while refactoring.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Be patient</h2></div></div></div><p>Profiling is not fast, not easy, and not an exact process. What this means is that you should not expect<a id="id68" class="indexterm"/> to just run the profiler and expect the data from it to point directly to your problem. That could happen, yes. However, most of the time, the problems you're trying to solve are the ones that simple debugging couldn't fix. This means you'll be browsing through data, plotting it to try to make sense of it, and narrowing down the source of your problem until you either need to start again, or you find it.</p><p>Keep in mind that the deeper you get into the profiled data, the deeper into the rabbit hole you get. Numbers will stop making sense right away, so make sure you know what you're doing and that you have the right tools for the job before you start. Otherwise, you'll waste your time and end up with nothing but frustration.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Gather as much data as you can</h2></div></div></div><p>Depending on <a id="id69" class="indexterm"/>the type and size of software you're dealing with, you might want to get as much data as you can before you start analyzing it. Profilers are a great source for this. However, there are other sources, such as server logs from web applications, custom logs, system resources snapshots (like from the OS task manager), and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Preprocess your data</h2></div></div></div><p>After you have all the information from your profilers, your logs, and other sources, you will probably<a id="id70" class="indexterm"/> need to preprocess the data before analyzing it. Don't shy away from unstructured data just because a profiler can't understand it. Your analysis of the data will benefit from the extra numbers.</p><p>For instance, getting the web server logs is a great idea if you're profiling a web application, but those files are normally just text files with one line per request. By parsing it and getting the data into some kind of database system (like MongoDB, MySQL, or the like), you'll be able to give that data meaning (by parsing the dates, doing geolocation by source IP address, and so on) and query that information afterwards.</p><p>The formal name for the stage is ETL, which stands for <em>extracting the data from it's sources, transforming it into something with meaning, and loading it into another system that you can later query</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Visualize your data</h2></div></div></div><p>If you don't know exactly what it is that you're looking for and you're just looking for ways to <a id="id71" class="indexterm"/>optimize your code before something goes wrong, a great idea to get some insight into the data you've already preprocessed is to visualize it. Computers are great with numbers, but humans, on the other hand, are great with images when we want to find patterns and understand what kind of insight we can gather from the information we have.</p><p>For instance, to continue with the web server logs example, a simple plot (such as the ones you can do with MS Excel) for the requests by hour can provide some insight into the behavior of your users:</p><div><img src="img/B02088_01_12.jpg" alt="Visualize your data"/></div><p>The preceding <a id="id72" class="indexterm"/>chart clearly shows that the majority of requests are done during late afternoon and continue into the night. You can use this insight later on for further profiling. For instance, an optional improvement of your setup here would be to provide more resources for your infrastructure during that time (something that can be done with service providers such as Amazon Web Services).</p><p>Another example, using custom profiling data, could be the following chart:</p><div><img src="img/B02088_01_13.jpg" alt="Visualize your data"/></div><p>It uses data<a id="id73" class="indexterm"/> from the first code example of this chapter by counting the number of each event that triggers the <code class="literal">profile</code> function. We can then plot it and get an idea of the most common events. In our case, the <code class="literal">call</code> and <code class="literal">return</code> events are definitely taking up most of our program's time.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter, we've covered the basics of profiling. You understood profiling and its importance. You also learned how we can leverage it in order to get the most out of our code.</p><p>In the next chapter, we'll start getting our hands dirty by looking at some Python profilers and how we can use them on our applications.</p></div></body></html>