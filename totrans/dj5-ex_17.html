<html><head></head><body>
<div><h1 class="chapterNumber">17</h1>
<h1 class="chapterTitle" id="_idParaDest-446">Going Live</h1>
<p class="normal">In the previous chapter, you built a real-time chat server for students using Django Channels. Now that you have created a fully functional e-learning platform, you need to set up a production environment so that it can be accessed over the internet. Until now, you have been working in a development environment, using the Django development server to run your site. In this chapter, you will learn how to set up a production environment that is able to serve your Django project in a secure and efficient manner.</p>
<p class="normal">This chapter will cover the following topics:</p>
<ul>
<li class="bulletList">Configuring Django settings for multiple environments</li>
<li class="bulletList">Using Docker Compose to run multiple services</li>
<li class="bulletList">Setting up a web server with uWSGI and Django</li>
<li class="bulletList">Serving PostgreSQL and Redis with Docker Compose</li>
<li class="bulletList">Using the Django system check framework</li>
<li class="bulletList">Serving NGINX with Docker</li>
<li class="bulletList">Serving static assets through NGINX</li>
<li class="bulletList">Securing <a id="_idIndexMarker1529"/>connections through <strong class="keyWord">Transport Layer Security</strong> (<strong class="keyWord">TLS</strong>) / <strong class="keyWord">Secure Sockets Layer</strong> (<strong class="keyWord">SSL</strong>)</li>
<li class="bulletList">Using <a id="_idIndexMarker1530"/>the Daphne <strong class="keyWord">Asynchronous Server Gateway Interface</strong> (<strong class="keyWord">ASGI</strong>) server for Django Channels</li>
<li class="bulletList">Creating <a id="_idIndexMarker1531"/>a custom Django middleware</li>
<li class="bulletList">Implementing custom Django management commands</li>
</ul>
<p class="normal">In previous chapters, diagrams at the start represented views, templates, and end-to-end functionalities. This chapter, however, shifts focus to setting up a production environment. Instead, you will find specific diagrams to illustrate the environment setup throughout the chapter.</p>
<p class="normal">The source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter17">https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter17</a>.</p>
<p class="normal">All Python modules used in this chapter are included in the <code class="inlineCode">requirements.txt</code> file in the source code that comes along with this chapter. You can follow the instructions to install each Python module below or you can install all requirements at once with the <code class="inlineCode">python -m pip install -r requirements.txt</code> command.</p>
<h1 class="heading-1" id="_idParaDest-447">Creating a production environment</h1>
<p class="normal">It’s time <a id="_idIndexMarker1532"/>to deploy your Django project in a production environment. You will start by configuring Django settings for multiple environments, and then you will set up a production environment.</p>
<h2 class="heading-2" id="_idParaDest-448">Managing settings for multiple environments</h2>
<p class="normal">In real-world projects, you will have to deal with multiple environments. You will usually have at <a id="_idIndexMarker1533"/>least a local environment for development and a production environment for serving your application. You could have other environments as well, such as testing or staging environments.</p>
<p class="normal">Some project settings will be common to all environments, but others will be specific to each environment. Usually, you will use a base file that defines common settings, and a settings file per environment that overrides any necessary settings and defines additional ones.</p>
<p class="normal">We will manage the following environments:</p>
<ul>
<li class="bulletList"><code class="inlineCode">local</code>: The local environment to run the project on your machine</li>
<li class="bulletList"><code class="inlineCode">prod</code>: The environment for deploying your project on a production server</li>
</ul>
<p class="normal">Create a <code class="inlineCode">settings/</code> directory next to the <code class="inlineCode">settings.py</code> file of the <code class="inlineCode">educa</code> project. Rename the <code class="inlineCode">settings.py</code> file to <code class="inlineCode">base.py</code> and move it into the new <code class="inlineCode">settings/</code> directory.</p>
<p class="normal">Create the following additional files inside the <code class="inlineCode">settings/</code> folder so that the new directory looks as follows:</p>
<pre class="programlisting con"><code class="hljs-con">settings/
    __init__.py
    base.py
    local.py
    prod.py
</code></pre>
<p class="normal">These files are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">base.py</code>: The base settings file, which contains common settings (previously <code class="inlineCode">settings.py</code>)</li>
<li class="bulletList"><code class="inlineCode">local.py</code>: Custom settings for your local environment</li>
<li class="bulletList"><code class="inlineCode">prod.py</code>: Custom settings for the production environment</li>
</ul>
<p class="normal">You have moved the settings files to a directory one level below, so you need to update the <code class="inlineCode">BASE_DIR</code> setting in the <code class="inlineCode">settings/base.py</code> file to point to the main project directory.</p>
<p class="normal">When <a id="_idIndexMarker1534"/>handling multiple environments, create a base settings file and a settings file for each environment. Environment settings files should inherit the common settings and override environment-specific settings.</p>
<p class="normal">Edit the <code class="inlineCode">settings/base.py</code> file and replace the following line:</p>
<pre class="programlisting code"><code class="hljs-code">BASE_DIR = Path(__file__).resolve().parent.parent
</code></pre>
<p class="normal">Replace the preceding line with the following one:</p>
<pre class="programlisting code"><code class="hljs-code">BASE_DIR = Path(__file__).resolve().parent.parent<strong class="hljs-slc">.parent</strong>
</code></pre>
<p class="normal">You point to one directory above by adding <code class="inlineCode">.parent</code> to the <code class="inlineCode">BASE_DIR</code> path. Let’s configure the settings for the local environment.</p>
<h3 class="heading-3" id="_idParaDest-449">Local environment settings</h3>
<p class="normal">Instead <a id="_idIndexMarker1535"/>of using a default configuration <a id="_idIndexMarker1536"/>for the <code class="inlineCode">DEBUG</code> and <code class="inlineCode">DATABASES</code> settings, you will define them for each environment explicitly. These settings will be environment specific. Edit the <code class="inlineCode">educa/settings/local.py</code> file and add the following lines:</p>
<pre class="programlisting code"><code class="hljs-code">from .base import *
DEBUG = True
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
</code></pre>
<p class="normal">This is <a id="_idIndexMarker1537"/>the settings file for your local environment. In this file, you import all settings defined in the <code class="inlineCode">base.py</code> file, and you define the <code class="inlineCode">DEBUG</code> and <code class="inlineCode">DATABASES</code> settings for this environment. The <code class="inlineCode">DEBUG</code> and <code class="inlineCode">DATABASES</code> settings remain the same as you have been using for development.</p>
<p class="normal">Now, remove the <code class="inlineCode">DATABASES</code> and <code class="inlineCode">DEBUG</code> settings from the <code class="inlineCode">base.py</code> settings file.</p>
<p class="normal">Django <a id="_idIndexMarker1538"/>management commands won’t automatically detect the settings file to use because the project settings file is not the default <code class="inlineCode">settings.py</code> file. When running management commands, you need to indicate the settings module that you want to use by adding a <code class="inlineCode">--settings</code> option, as follows:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py runserver --settings=educa.settings.local
</code></pre>
<p class="normal">Next, we are going to validate the project and the local environment configuration.</p>
<h3 class="heading-3" id="_idParaDest-450">Running the local environment</h3>
<p class="normal">Let’s run the local environment using the new settings structure. Make sure Redis is running <a id="_idIndexMarker1539"/>or start the Redis Docker container in a shell with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker run -it --rm --name redis -p 6379:6379 redis:7.2.4
</code></pre>
<p class="normal">Run the <a id="_idIndexMarker1540"/>following management command in another shell, from the project directory:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py runserver --settings=educa.settings.local
</code></pre>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/</code> in your browser and check that the site loads correctly. You are now serving your site using the settings for the <code class="inlineCode">local</code> environment.</p>
<p class="normal">If don’t want to pass the <code class="inlineCode">--settings</code> option every time you run a management command, you can define the <code class="inlineCode">DJANGO_SETTINGS_MODULE</code> environment variable. Django will use it to identify the settings module to use. If you are using Linux or macOS, you can define the environment variable by executing the following command in the shell:</p>
<pre class="programlisting con"><code class="hljs-con">export DJANGO_SETTINGS_MODULE=educa.settings.local
</code></pre>
<p class="normal">If you are using Windows, you can execute the following command in the shell:</p>
<pre class="programlisting con"><code class="hljs-con">set DJANGO_SETTINGS_MODULE=educa.settings.local
</code></pre>
<p class="normal">Any management command you execute after this will use the settings defined in the <code class="inlineCode">DJANGO_SETTINGS_MODULE</code> environment variable.</p>
<p class="normal">Stop the <a id="_idIndexMarker1541"/>Django development server from the shell by pressing the <em class="italic">Ctrl </em>+ <em class="italic">C</em> keys and stop the Redis Docker container from the shell by also pressing the <em class="italic">Ctrl</em> + <em class="italic">C</em> keys.</p>
<p class="normal">The local <a id="_idIndexMarker1542"/>environment works well. Let’s prepare the settings for the production environment.</p>
<h3 class="heading-3" id="_idParaDest-451">Production environment settings</h3>
<p class="normal">Let’s <a id="_idIndexMarker1543"/>start by adding initial <a id="_idIndexMarker1544"/>settings for the production environment. Edit the <code class="inlineCode">educa/settings/prod.py</code> file and make it look as follows:</p>
<pre class="programlisting code"><code class="hljs-code">from .base import *
DEBUG = False
ADMINS = [
    ('Antonio M', 'email@mydomain.com'),
]
ALLOWED_HOSTS = ['*']
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        NAME: BASE_DIR / 'db.sqlite3',
    }
}
</code></pre>
<p class="normal">These are the settings for the production environment:</p>
<ul>
<li class="bulletList"><code class="inlineCode">DEBUG</code>: Setting <code class="inlineCode">DEBUG</code> to <code class="inlineCode">False</code> is necessary for any production environment. Failing to do so will result in the traceback information and sensitive configuration data being exposed to everyone.</li>
<li class="bulletList"><code class="inlineCode">ADMINS</code>: When <code class="inlineCode">DEBUG</code> is <code class="inlineCode">False</code> and a view raises an exception, all information will be sent by email to the people listed in the <code class="inlineCode">ADMINS</code> setting. Make sure that you replace the name/email tuple with your own information.</li>
<li class="bulletList"><code class="inlineCode">ALLOWED_HOSTS</code>: For security reasons, Django will only allow the hosts included in this list to serve the project. For now, you allow all hosts by using the asterisk symbol, <code class="inlineCode">*</code>. You will limit the hosts that can be used for serving the project later.</li>
<li class="bulletList"><code class="inlineCode">DATABASES</code>: You keep the <code class="inlineCode">default</code> database settings pointing to the SQLite database of your local environment. You will configure the production database later.</li>
</ul>
<p class="normal">Over the <a id="_idIndexMarker1545"/>next sections of this <a id="_idIndexMarker1546"/>chapter, you will complete the settings file for your production environment.</p>
<p class="normal">You have successfully organized settings for handling multiple environments. Now, you will build a complete production environment by setting up different services with Docker.</p>
<h1 class="heading-1" id="_idParaDest-452">Using Docker Compose</h1>
<p class="normal">You initially used Docker in <em class="italic">Chapter 3</em>, <em class="italic">Extending Your Blog Application</em>, and you have been using Docker throughout this book to run containers for different services, such as PostgreSQL, Redis, and RabbitMQ.</p>
<p class="normal">Each Docker <a id="_idIndexMarker1547"/>container combines application source code with operating system libraries and dependencies required to run the application. By using application containers, you can improve your application portability. For the production environment, we will use Docker Compose to build and run multiple Docker containers.</p>
<p class="normal">Docker Compose is a tool for defining and running multi-container applications. You can create a configuration file to define the different services and use a single command to start all services <a id="_idIndexMarker1548"/>from your configuration. You can find information about Docker Compose at <a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a>.</p>
<p class="normal">For the production environment, you will create a distributed application that runs across multiple Docker containers. Each Docker container will run a different service. You will initially <a id="_idIndexMarker1549"/>define the following three services and you will add additional services in the next sections:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Web service</strong>: A web <a id="_idIndexMarker1550"/>server to serve the Django project</li>
<li class="bulletList"><strong class="keyWord">Database service</strong>: A database <a id="_idIndexMarker1551"/>service to run PostgreSQL</li>
<li class="bulletList"><strong class="keyWord">Cache service</strong>: A <a id="_idIndexMarker1552"/>service to run Redis</li>
</ul>
<p class="normal">Let’s start by installing Docker Compose.</p>
<h2 class="heading-2" id="_idParaDest-453">Installing Docker Compose via Docker Desktop</h2>
<p class="normal">You can run Docker Compose on macOS, 64-bit Linux, and Windows. The fastest way to install <a id="_idIndexMarker1553"/>Docker Compose is by installing <a id="_idIndexMarker1554"/>Docker Desktop. The installation includes Docker Engine, the command-line interface, and Docker Compose.</p>
<p class="normal">Install <a id="_idIndexMarker1555"/>Docker Desktop by following the instructions at <a href="https://docs.docker.com/compose/install/compose-desktop/">https://docs.docker.com/compose/install/compose-desktop/</a>.</p>
<p class="normal">Open the Docker Desktop application and click on <strong class="screenText">Containers</strong>. It will look as follows:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_01.png"/></figure>
<p class="packt_figref">Figure 17.1: The Docker Desktop interface</p>
<p class="normal">After <a id="_idIndexMarker1556"/>installing Docker Compose, you need to <a id="_idIndexMarker1557"/>create a Docker image for your Django project.</p>
<h2 class="heading-2" id="_idParaDest-454">Creating a Dockerfile</h2>
<p class="normal">You need to create a Docker image to run the Django project. A <code class="inlineCode">Dockerfile</code> is a text file that contains <a id="_idIndexMarker1558"/>the commands for Docker to assemble a Docker image. You will prepare a <code class="inlineCode">Dockerfile</code> with the commands for building the <a id="_idIndexMarker1559"/>Docker image for the Django project.</p>
<p class="normal">Next to the <code class="inlineCode">educa</code> project directory, create a new file and name it <code class="inlineCode">Dockerfile</code>. Add the following code to the new file:</p>
<pre class="programlisting code"><code class="hljs-code"># Pull official base Python Docker image
FROM python:3.12.3
# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
# Set work directory
WORKDIR /code
# Install dependencies
RUN pip install --upgrade pip
COPY requirements.txt .
RUN pip install -r requirements.txt
# Copy the Django project
COPY . .
</code></pre>
<p class="normal">This code <a id="_idIndexMarker1560"/>performs the following tasks:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">The <a id="_idIndexMarker1561"/>Python <code class="inlineCode">3.12.3</code> parent Docker image is used. You can <a id="_idIndexMarker1562"/>find the official Python Docker image at <a href="https://hub.docker.com/_/python">https://hub.docker.com/_/python</a>.</li>
<li class="numberedList">The following environment variables are set:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
<li class="alphabeticList" value="1"><code class="inlineCode">PYTHONDONTWRITEBYTECODE</code>: This prevents Python from writing out <code class="inlineCode">pyc</code> files.</li>
<li class="alphabeticList"><code class="inlineCode">PYTHONUNBUFFERED</code>: This ensures that the Python <code class="inlineCode">stdout</code> and <code class="inlineCode">stderr</code> streams are sent straight to the terminal without first being buffered.</li>
</ol>
</li>
<li class="numberedList">The <code class="inlineCode">WORKDIR</code> command is used to define the working directory of the image.</li>
<li class="numberedList">The <code class="inlineCode">pip</code> package of the image is upgraded.</li>
<li class="numberedList">The <code class="inlineCode">requirements.txt</code> file is copied to the working directory (<code class="inlineCode">.</code>) of the parent Python image.</li>
<li class="numberedList">The Python packages in <code class="inlineCode">requirements.txt</code> are installed in the image using <code class="inlineCode">pip</code>.</li>
<li class="numberedList">The Django project source code is copied from the local directory to the working directory (<code class="inlineCode">.</code>) directory of the image.</li>
</ol>
<p class="normal">With this <code class="inlineCode">Dockerfile</code>, you have defined how the Docker image that will serve Django will be assembled. You can find the <code class="inlineCode">Dockerfile</code> reference at <a href="https://docs.docker.com/reference/dockerfile/">https://docs.docker.com/reference/dockerfile/</a>.</p>
<h2 class="heading-2" id="_idParaDest-455">Adding the Python requirements</h2>
<p class="normal">A <code class="inlineCode">requirements.txt</code> file is used in the <code class="inlineCode">Dockerfile</code> you created to install all of the necessary <a id="_idIndexMarker1563"/>Python packages for the project.</p>
<p class="normal">Next to <a id="_idIndexMarker1564"/>the <code class="inlineCode">educa</code> project directory, create a new file and name it <code class="inlineCode">requirements.txt</code>. You may have already created this file before and copied the content for the <code class="inlineCode">requirements.txt</code> file from <a href="https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter17/requirements.txt">https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter17/requirements.txt</a>. If you haven’t done so, add the following lines to the newly created <code class="inlineCode">requirements.txt</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">asgiref==3.8.1
Django~=5.0.4
Pillow==10.3.0
sqlparse==0.5.0
django-braces==1.15.0
django-embed-video==1.4.9
pymemcache==4.0.0
django-debug-toolbar==4.3.0
redis==5.0.4
django-redisboard==8.4.0
djangorestframework==3.15.1
requests==2.31.0
channels[daphne]==4.1.0
channels-redis==4.2.0
psycopg==3.1.18
uwsgi==2.0.25.1
python-decouple==3.8
</code></pre>
<p class="normal">In addition to the Python packages that you installed in the previous chapters, the <code class="inlineCode">requirements.txt </code>file includes the following packages:</p>
<ul>
<li class="bulletList"><code class="inlineCode">psycopg</code>: This is <a id="_idIndexMarker1565"/>the PostgreSQL adapter. You will use PostgreSQL for the production environment.</li>
<li class="bulletList"><code class="inlineCode">uwsgi</code>: A WSGI <a id="_idIndexMarker1566"/>web server. You will configure this web server later to serve Django in the production environment.</li>
<li class="bulletList"><code class="inlineCode">python-decouple</code>: Package to load environment variables easily.</li>
</ul>
<p class="normal">Let’s start by setting up the Docker application in Docker Compose. We will create a Docker Compose file with the definition for the web server, database, and Redis services.</p>
<h2 class="heading-2" id="_idParaDest-456">Creating a Docker Compose file</h2>
<p class="normal">To define the services that will run in different Docker containers, we will use a Docker Compose file. The Compose file is a text file in YAML format, defining services, networks, and data <a id="_idIndexMarker1567"/>volumes for a Docker application. YAML is a human-readable data-serialization language. You can see an example of a YAML file at <a href="https://yaml.org/">https://yaml.org/</a>.</p>
<p class="normal">Next to the <code class="inlineCode">educa</code> project directory, create a new file and name it <code class="inlineCode">docker-compose.yml</code>. Add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">services:
  web:
    build: .
    command: python /code/educa/manage.py runserver 0.0.0.0:8000
    restart: always
    volumes:
      - .:/code
    ports:
      - "8000:8000"
    environment:
      - DJANGO_SETTINGS_MODULE=educa.settings.prod
</code></pre>
<p class="normal">In this file, you define a <code class="inlineCode">web</code> service. The sections to define this service are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">build</code>: This defines the build requirements for a service container image. This can <a id="_idIndexMarker1568"/>be a single string defining a context path, or a detailed build definition. You provide a relative path with a single dot (<code class="inlineCode">.</code>) to point to the same directory where the Compose file is located. Docker Compose will look for a <code class="inlineCode">Dockerfile</code> at this location. You can read more about the <code class="inlineCode">build</code> section at <a href="https://docs.docker.com/compose/compose-file/build/">https://docs.docker.com/compose/compose-file/build/</a>.</li>
<li class="bulletList"><code class="inlineCode">command</code>: This overrides <a id="_idIndexMarker1569"/>the default command of the container. You run the Django development server using the <code class="inlineCode">runserver</code> management command. The project is served on host <code class="inlineCode">0.0.0.0</code>, which is the default Docker IP, on port <code class="inlineCode">8000</code>.</li>
<li class="bulletList"><code class="inlineCode">restart</code>: This <a id="_idIndexMarker1570"/>defines the restart policy for the container. Using <code class="inlineCode">always</code>, the container is always restarted if it stops. This is useful for a production environment where you want to minimize downtime. You can read more about the restart policy at <a href="https://docs.docker.com/config/containers/start-containers-automatically/">https://docs.docker.com/config/containers/start-containers-automatically/</a>.</li>
<li class="bulletList"><code class="inlineCode">volumes</code>: Data in <a id="_idIndexMarker1571"/>Docker containers is not permanent. Each Docker container has a virtual filesystem that is populated with the files of the image and that is destroyed when the container is stopped. Volumes are the preferred method to persist data generated and used by Docker containers. In this section, you mount the local . directory to the <code class="inlineCode">/code</code> directory of the image. You can read more about Docker volumes at <a href="https://docs.docker.com/storage/volumes/">https://docs.docker.com/storage/volumes/</a>.</li>
<li class="bulletList"><code class="inlineCode">ports</code>: This exposes <a id="_idIndexMarker1572"/>container ports. Host port <code class="inlineCode">8000</code> is mapped to container port <code class="inlineCode">8000</code>, on which the Django development server is running.</li>
<li class="bulletList"><code class="inlineCode">environment</code>: This <a id="_idIndexMarker1573"/>defines environment variables. You set the <code class="inlineCode">DJANGO_SETTINGS_MODULE</code> environment variable to use the production Django settings file <code class="inlineCode">educa.settings.prod</code>.</li>
</ul>
<p class="normal">Note that in the Docker Compose file definition, you are using the Django development server to <a id="_idIndexMarker1574"/>serve the application. The Django development server is not suitable for production use, so you will replace it later with a WSGI Python web server.</p>
<p class="normal">You can <a id="_idIndexMarker1575"/>find information about the Docker Compose specification at <a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a>.</p>
<p class="normal">At this point, assuming your parent directory is named <code class="inlineCode">Chapter17</code>, the file structure should look as follows:</p>
<pre class="programlisting con"><code class="hljs-con">Chapter17/
    Dockerfile
    docker-compose.yml
    educa/
        manage.py
        ...
    requirements.txt
</code></pre>
<p class="normal">Open a shell in the parent directory, where the <code class="inlineCode">docker-compose.yml</code> file is located, and run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose up
</code></pre>
<p class="normal">This will <a id="_idIndexMarker1576"/>start the Docker app defined in the Docker Compose file. You will see an output that includes the following lines:</p>
<pre class="programlisting con"><code class="hljs-con">chapter17-web-1  | Performing system checks...
chapter17-web-1  |
chapter17-web-1  | System check identified no issues (0 silenced).
chapter17-web-1  | March 10, 2024 - 12:03:28
chapter17-web-1  | Django version 5.0.4, using settings 'educa.settings.prod'
chapter17-web-1  | Starting ASGI/Daphne version 4.1.0 development server at http://0.0.0.0:8000/
chapter17-web-1  | Quit the server with CONTROL-C.
</code></pre>
<p class="normal">The Docker container for your Django project is running!</p>
<p class="normal">Open <code class="inlineCode">http://0.0.0.0:8000/admin/</code> with your browser. You should see the Django administration site login form. It should look like <em class="italic">Figure 17.2</em>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_02.png"/></figure>
<p class="packt_figref">Figure 17.2: The Django administration site login form with no CSS styles applied</p>
<p class="normal">CSS styles <a id="_idIndexMarker1577"/>are not loaded. You are using <code class="inlineCode">DEBUG=False</code>, so URL patterns for serving static files are not being included in the main <code class="inlineCode">urls.py</code> file of the project. Remember that the Django development server is not suitable for serving static files. You will configure a server for serving static files later in this chapter.</p>
<p class="normal">If you access any other URL of your site, you might get an HTTP <code class="inlineCode">500</code> error because you haven’t configured a database for the production environment yet.</p>
<p class="normal">Take a look at the Docker Desktop app. You will see the following containers:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_03.png"/></figure>
<p class="packt_figref">Figure 17.3: The chapter17 application and the web-1 container in Docker Desktop</p>
<p class="normal">The <code class="inlineCode">chapter17</code> Docker application is running and it has a single container named <code class="inlineCode">web-1</code>, which is running on port <code class="inlineCode">8000</code>. The name for the Docker application is generated dynamically <a id="_idIndexMarker1578"/>using the name of the directory where the Docker Compose file is located, in this case, <code class="inlineCode">chapter17</code>.</p>
<p class="normal">Under <strong class="screenText">Images</strong>, you will see the image built for the <code class="inlineCode">web</code> service, as in <em class="italic">Figure 17.4</em>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_04.png"/></figure>
<p class="packt_figref">Figure 17.4: The chapter17 application and the web-1 container in Docker Desktop</p>
<p class="normal">The <code class="inlineCode">chapter17-web</code> image has been built using the <code class="inlineCode">Dockerfile</code> you defined earlier and is used by the <code class="inlineCode">web-1</code> container.</p>
<p class="normal">Next, you are going to add a PostgreSQL service and a Redis service to your Docker application.</p>
<h2 class="heading-2" id="_idParaDest-457">Configuring the PostgreSQL service</h2>
<p class="normal">Throughout this book, you have mostly used the SQLite database. SQLite is simple and quick to <a id="_idIndexMarker1579"/>set up, but for a production environment, you will need a more powerful database, such as PostgreSQL, MySQL, or Oracle. You used Docker to install PostgreSQL in <em class="italic">Chapter 3</em>, <em class="italic">Extending Your Blog Application</em>. You can <a id="_idIndexMarker1580"/>find information about the official PostgreSQL Docker image at <a href="https://hub.docker.com/_/postgres">https://hub.docker.com/_/postgres</a>.</p>
<p class="normal">Edit the <code class="inlineCode">docker-compose.yml</code> file and add the following lines highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">services:
<strong class="hljs-slc">  db:</strong>
<strong class="hljs-slc">    image: postgres:</strong><strong class="hljs-number-slc">16.2</strong>
<strong class="hljs-slc">    restart: always</strong>
<strong class="hljs-slc">    volumes:</strong>
<strong class="hljs-slc">      - ./data/db:/var/lib/postgresql/data</strong>
<strong class="hljs-slc">    environment:</strong>
<strong class="hljs-slc">      - POSTGRES_DB=postgres</strong>
<strong class="hljs-slc">      - POSTGRES_USER=postgres</strong>
<strong class="hljs-slc">      - POSTGRES_PASSWORD=postgres</strong>
  web:
    build: .
    command: python /code/educa/manage.py runserver 0.0.0.0:8000
    restart: always
    volumes:
      - .:/code
    ports:
      - "8000:8000"
    environment:
      - DJANGO_SETTINGS_MODULE=educa.settings.prod
<strong class="hljs-slc">      - POSTGRES_DB=postgres</strong>
<strong class="hljs-slc">      - POSTGRES_USER=postgres</strong>
<strong class="hljs-slc">      - POSTGRES_PASSWORD=postgres</strong>
<strong class="hljs-slc">    depends_on:</strong>
<strong class="hljs-slc">      - db</strong>
</code></pre>
<p class="normal">With these <a id="_idIndexMarker1581"/>changes, you define a service named <code class="inlineCode">db</code> with the following subsections:</p>
<ul>
<li class="bulletList"><code class="inlineCode">image</code>: The service uses the base <code class="inlineCode">postgres</code> Docker image.</li>
<li class="bulletList"><code class="inlineCode">restart</code>: The restart policy is set to <code class="inlineCode">always</code>.</li>
<li class="bulletList"><code class="inlineCode">volumes</code>: You mount the <code class="inlineCode">./data/db</code> directory to the image directory <code class="inlineCode">/var/lib/postgresql/data</code> to persist the database so that data stored in the database is maintained after the Docker application is stopped. This will create the local <code class="inlineCode">data/db/</code> path.</li>
<li class="bulletList"><code class="inlineCode">environment</code>: You use the <code class="inlineCode">POSTGRES_DB</code> (database name), <code class="inlineCode">POSTGRES_USER</code>, and <code class="inlineCode">POSTGRES_PASSWORD</code> variables with default values.</li>
</ul>
<p class="normal">The definition for the <code class="inlineCode">web</code> service now includes the PostgreSQL environment variables for Django. You create a service dependency using <code class="inlineCode">depends_on</code> so that the <code class="inlineCode">web</code> service is started after the <code class="inlineCode">db</code> service. This will guarantee the order of the container initialization, but it won’t guarantee that PostgreSQL is fully initiated before the Django web server is started. To solve this, you need to use a script that will wait on the availability of the database host and its TCP port. Docker recommends that you use the <code class="inlineCode">wait-for-it</code> tool to control container initialization.</p>
<p class="normal">Download the <code class="inlineCode">wait-for-it.sh</code> bash script from <a href="https://github.com/vishnubob/wait-for-it/blob/master/wait-for-it.sh">https://github.com/vishnubob/wait-for-it/blob/master/wait-for-it.sh</a> and save the file next to the <code class="inlineCode">docker-compose.yml</code> file. Then, edit the <code class="inlineCode">docker-compose.yml</code> file and modify the <code class="inlineCode">web</code> service definition as follows. The new code is highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">web:
  build: .
  command: <strong class="hljs-slc">[</strong><strong class="hljs-string-slc">"</strong><strong class="hljs-string-slc">./wait-for-it.sh"</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">"db:5432"</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">"--"</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"python"</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">"/code/educa/manage.py"</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">"runserver"</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"0.0.0.0:8000"</strong><strong class="hljs-slc">]</strong>
  restart: always
  volumes:
      - .:/code
    environment:
      - DJANGO_SETTINGS_MODULE=educa.settings.prod
      - POSTGRES_DB=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    depends_on:
      - db
</code></pre>
<p class="normal">In this service definition, you use the <code class="inlineCode">wait-for-it.sh</code> bash script to wait for the <code class="inlineCode">db</code> host to be ready <a id="_idIndexMarker1582"/>and accept connections on port <code class="inlineCode">5432</code>, the default port for PostgreSQL, before starting the Django development server. You can read more <a id="_idIndexMarker1583"/>about the service startup order in Compose at <a href="https://docs.docker.com/compose/startup-order/">https://docs.docker.com/compose/startup-order/</a>.</p>
<p class="normal">Let’s edit the Django settings. Edit the <code class="inlineCode">educa/settings/prod.py</code> file and add the following code highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> decouple </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> config</strong>
from .base import *	
DEBUG = False
ADMINS = [
    ('Antonio M', 'email@mydomain.com'),
]
ALLOWED_HOSTS = ['*']
DATABASES = {
    'default': {
        'ENGINE': <strong class="hljs-string-slc">'django.db.backends.postgresql'</strong><strong class="hljs-slc">,</strong>
'NAME': <strong class="hljs-slc">config(</strong><strong class="hljs-string-slc">'POSTGRES_DB'</strong><strong class="hljs-slc">),</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'USER'</strong><strong class="hljs-slc">: config(</strong><strong class="hljs-string-slc">'POSTGRES_USER'</strong><strong class="hljs-slc">),</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'PASSWORD'</strong><strong class="hljs-slc">: config(</strong><strong class="hljs-string-slc">'POSTGRES_PASSWORD'</strong><strong class="hljs-slc">),</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'HOST'</strong><strong class="hljs-slc">: </strong><strong class="hljs-string-slc">'db'</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'PORT'</strong><strong class="hljs-slc">: </strong><strong class="hljs-number-slc">5432</strong><strong class="hljs-slc">,</strong>
    }
}
</code></pre>
<p class="normal">In the production settings file, you use the following settings:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ENGINE</code>: You use the Django database backend for PostgreSQL.</li>
<li class="bulletList"><code class="inlineCode">NAME</code>, <code class="inlineCode">USER</code>, and <code class="inlineCode">PASSWORD</code>: You use the <code class="inlineCode">config()</code> function of <code class="inlineCode">python-decouple</code> to retrieve the <code class="inlineCode">POSTGRES_DB</code> (database name), <code class="inlineCode">POSTGRES_USER</code>, and <code class="inlineCode">POSTGRES_PASSWORD</code> environment variables. You have set these environment variables in the Docker Compose file.</li>
<li class="bulletList"><code class="inlineCode">HOST</code>: You use <code class="inlineCode">db</code>, which is the container hostname for the database service defined in the Docker Compose file. A container hostname defaults to the container’s ID in Docker. That’s why you use the <code class="inlineCode">db</code> hostname.</li>
<li class="bulletList"><code class="inlineCode">PORT</code>: You use the <code class="inlineCode">5432</code> value, which is the default port for PostgreSQL.</li>
</ul>
<p class="normal">Stop the Docker application from the shell by pressing the <em class="italic">Ctrl</em> + <em class="italic">C</em> keys or using the stop button in the <a id="_idIndexMarker1584"/>Docker Desktop app. Then, start Compose again with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose up
</code></pre>
<p class="normal">The first execution after adding the <code class="inlineCode">db</code> service to the Docker Compose file will take longer because PostgreSQL needs to initialize the database. The output will contain the following two lines:</p>
<pre class="programlisting con"><code class="hljs-con">db-1   | ... database system is ready to accept connections
...
web-1  | Starting ASGI/Daphne version 4.1.0 development server at http://0.0.0.0:8000/
</code></pre>
<p class="normal">Both the PostgreSQL database and the Django application are ready. The production database is empty, so you need to apply database migrations.</p>
<h2 class="heading-2" id="_idParaDest-458">Applying database migrations and creating a superuser</h2>
<p class="normal">Open a <a id="_idIndexMarker1585"/>different shell in the parent <a id="_idIndexMarker1586"/>directory, where the <code class="inlineCode">docker-compose.yml</code> file is located, and run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose exec web python /code/educa/manage.py migrate
</code></pre>
<p class="normal">The <code class="inlineCode">docker compose exec</code> command allows you to execute commands in the container. You use this command to execute the <code class="inlineCode">migrate</code> management command in the <code class="inlineCode">web</code> Docker container.</p>
<p class="normal">Finally, create a superuser with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose exec web python /code/educa/manage.py createsuperuser
</code></pre>
<p class="normal">Migrations have been applied to the database and you have created a superuser. You can access <code class="inlineCode">http://localhost:8000/admin/</code> with the superuser credentials. CSS styles still won’t load because you haven’t configured serving static files yet.</p>
<p class="normal">You have defined services to serve Django and PostgreSQL using Docker Compose. Next, you will add a service to serve Redis in the production environment.</p>
<h2 class="heading-2" id="_idParaDest-459">Configuring the Redis service</h2>
<p class="normal">Let’s add <a id="_idIndexMarker1587"/>a Redis service to the Docker Compose file. For <a id="_idIndexMarker1588"/>this purpose, you will use the official <a id="_idIndexMarker1589"/>Redis Docker image. You can find information about the official Redis Docker image at <a href="https://hub.docker.com/_/redis">https://hub.docker.com/_/redis</a>.</p>
<p class="normal">Edit the <code class="inlineCode">docker-compose.yml</code> file and add the following lines highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">services:
  db:
    # ...
<strong class="hljs-slc">  cache:</strong>
<strong class="hljs-slc">    image: redis:</strong><strong class="hljs-number-slc">7.2.4</strong>
<strong class="hljs-slc">    restart: always</strong>
<strong class="hljs-slc">    volumes:</strong>
<strong class="hljs-slc">      - ./data/cache:/data</strong>
  web:
    # ...
    depends_on:
      - db
<strong class="hljs-slc">      - cache</strong>
</code></pre>
<p class="normal">In the previous code, you define the <code class="inlineCode">cache</code> service with the following subsections:</p>
<ul>
<li class="bulletList"><code class="inlineCode">image</code>: The service uses the base <code class="inlineCode">redis</code> Docker image.</li>
<li class="bulletList"><code class="inlineCode">restart</code>: The restart policy is set to <code class="inlineCode">always</code>.</li>
<li class="bulletList"><code class="inlineCode">volumes</code>: You mount the <code class="inlineCode">./data/cache</code> directory to the <code class="inlineCode">/data</code> image directory where any Redis writes will be persisted. This will create the local <code class="inlineCode">data/cache/</code> path.</li>
</ul>
<p class="normal">In the <code class="inlineCode">web</code> service definition, you add the <code class="inlineCode">cache</code> service as a dependency, so that the <code class="inlineCode">web</code> service <a id="_idIndexMarker1590"/>is started after the <code class="inlineCode">cache</code> service. The <a id="_idIndexMarker1591"/>Redis server initializes fast, so you don’t need to use the <code class="inlineCode">wait-for-it</code> tool in this case.</p>
<p class="normal">Edit the <code class="inlineCode">educa/settings/prod.py</code> file and add the following lines:</p>
<pre class="programlisting code"><code class="hljs-code">REDIS_URL = 'redis://cache:6379'
CACHES['default']['LOCATION'] = REDIS_URL
CHANNEL_LAYERS['default']['CONFIG']['hosts'] = [REDIS_URL]
</code></pre>
<p class="normal">In these settings, you use the <code class="inlineCode">cache</code> hostname that is automatically generated by Docker Compose using the name of the <code class="inlineCode">cache</code> service and port <code class="inlineCode">6379</code> used by Redis. You modify the Django <code class="inlineCode">CACHE</code> setting and the <code class="inlineCode">CHANNEL_LAYERS</code> setting used by Channels to use the production Redis URL.</p>
<p class="normal">Stop the Docker application from the shell by pressing the <em class="italic">Ctrl</em> + <em class="italic">C</em> keys or using the stop button in the Docker Desktop app. Then, start Compose again with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose up
cache-1   | ... Ready to accept connections tcp
</code></pre>
<p class="normal">Open the Docker Desktop application. You should see now the <code class="inlineCode">chapter17</code> Docker application running a container for each service defined in the Docker Compose file: <code class="inlineCode">db</code>, <code class="inlineCode">cache</code>, and <code class="inlineCode">web</code>, as in <em class="italic">Figure 17.4</em>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_05.png"/></figure>
<p class="packt_figref">Figure 17.5: The chapter17 application with the db-1, web-1, and cache-1 containers in Docker Desktop</p>
<p class="normal">You are <a id="_idIndexMarker1592"/>still serving Django with the Django development <a id="_idIndexMarker1593"/>server, which, as you know, is meant for development only and not optimized for production use. Let’s replace it with the WSGI Python web server.</p>
<h1 class="heading-1" id="_idParaDest-460">Serving Django through WSGI and NGINX</h1>
<p class="normal">Django’s <a id="_idIndexMarker1594"/>primary deployment platform is WSGI. <strong class="keyWord">WSGI</strong> stands for <strong class="keyWord">Web Server Gateway Interface </strong>, and it is the standard for serving Python <a id="_idIndexMarker1595"/>applications on the web.</p>
<p class="normal">When <a id="_idIndexMarker1596"/>you generate a new project using the <code class="inlineCode">startproject</code> command, Django creates a <code class="inlineCode">wsgi.py</code> file inside <a id="_idIndexMarker1597"/>your project directory. This file contains a WSGI <a id="_idIndexMarker1598"/>application callable, which is an access point to your application.</p>
<p class="normal">WSGI is used for both running your project with the Django development server and deploying your application with the server of your choice in a production environment. You can <a id="_idIndexMarker1599"/>learn more about WSGI at <a href="https://wsgi.readthedocs.io/en/latest/">https://wsgi.readthedocs.io/en/latest/</a>.</p>
<p class="normal">In the following <a id="_idIndexMarker1600"/>sections we will use <strong class="keyWord">uWSGI</strong>, an open source web server that implements the WSGI specification.</p>
<h2 class="heading-2" id="_idParaDest-461">Using uWSGI</h2>
<p class="normal">Throughout this book, you have been using the Django development server to run projects in your local environment. However, the development server is not designed for production use, and deploying your application in a production environment will require a standard web server.</p>
<p class="normal">uWSGI is an <a id="_idIndexMarker1601"/>extremely fast Python application server. It communicates with your Python application using the WSGI specification. uWSGI translates web requests into a format that your Django project can process.</p>
<p class="normal">Let’s configure uWSGI to serve the Django project. You already added <code class="inlineCode">uwsgi==2.0.20</code> to the <code class="inlineCode">requirements.txt</code> file of the project, so uWSGI is already being installed in the Docker image of the <code class="inlineCode">web</code> service.</p>
<p class="normal">Edit the <code class="inlineCode">docker-compose.yml</code> file and modify the <code class="inlineCode">web</code> service definition as follows. The new code is highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">web:
    build: .
    command: <strong class="hljs-slc">[</strong><strong class="hljs-string-slc">"./wait-for-it.sh"</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">"db:5432"</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">"--"</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"uwsgi"</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">"--ini"</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">"/code/config/uwsgi/uwsgi.ini"</strong><strong class="hljs-slc">]</strong>
    restart: always
    volumes:
      - .:/code
    environment:
      - DJANGO_SETTINGS_MODULE=educa.settings.prod
      - POSTGRES_DB=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    depends_on:
      - db
      - cache
</code></pre>
<p class="normal">Make sure to remove the <code class="inlineCode">ports</code> section. uWSGI will be reachable with a socket, so you don’t need to expose a port in the container.</p>
<p class="normal">The new <code class="inlineCode">command</code> for the image runs <code class="inlineCode">uwsgi</code> and passes the <code class="inlineCode">/code/config/uwsgi/uwsgi.ini</code> configuration file to it. Let’s create the configuration file for uWSGI.</p>
<h2 class="heading-2" id="_idParaDest-462">Configuring uWSGI</h2>
<p class="normal">uWSGI allows <a id="_idIndexMarker1602"/>you to define a custom configuration in an <code class="inlineCode">.ini</code> file. Next to the <code class="inlineCode">docker-compose.yml</code> file, create the <code class="inlineCode">config/uwsgi/uwsgi.ini</code> file path. Assuming your parent directory is named <code class="inlineCode">Chapter17</code>, the file structure should look as follows:</p>
<pre class="programlisting con"><code class="hljs-con">Chapter17/
    config/
        uwsgi/
            uwsgi.ini
    Dockerfile
    docker-compose.yml
    educa/
        manage.py
        ...
    requirements.txt
</code></pre>
<p class="normal">Edit the <code class="inlineCode">config/uwsgi/uwsgi.ini</code> file and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">[uwsgi]
socket=/code/educa/uwsgi_app.sock
chdir = /code/educa/
module=educa.wsgi:application
master=true
chmod-socket=666
uid=www-data
gid=www-data
vacuum=true
</code></pre>
<p class="normal">In the <code class="inlineCode">uwsgi.ini</code> file, you define the following options:</p>
<ul>
<li class="bulletList"><code class="inlineCode">socket</code>: This is the Unix/TCP socket to bind the server.</li>
<li class="bulletList"><code class="inlineCode">chdir</code>: This is the path to your project directory, so that uWSGI changes to that directory before loading the Python application.</li>
<li class="bulletList"><code class="inlineCode">module</code>: This is the WSGI module to use. You set this to the <code class="inlineCode">application</code> callable contained in the <code class="inlineCode">wsgi</code> module of your project.</li>
<li class="bulletList"><code class="inlineCode">master</code>: This enables the master process.</li>
<li class="bulletList"><code class="inlineCode">chmod-socket</code>: These are the file permissions to apply to the socket file. In this case, you use <code class="inlineCode">666</code> so that NGINX can read/write the socket.</li>
<li class="bulletList"><code class="inlineCode">uid</code>: This is the user ID of the process once it’s started.</li>
<li class="bulletList"><code class="inlineCode">gid</code>: This is the group ID of the process once it’s started.</li>
<li class="bulletList"><code class="inlineCode">vacuum</code>: Using <code class="inlineCode">true</code> instructs uWSGI to clean up any temporary files or UNIX sockets it creates.</li>
</ul>
<p class="normal">The <code class="inlineCode">socket</code> option is intended for communication with some kind of third-party router, such as NGINX. You <a id="_idIndexMarker1603"/>are going to run uWSGI using a socket and you are going to configure NGINX as your web server, which will communicate with uWSGI through the socket.</p>
<p class="normal">You can find <a id="_idIndexMarker1604"/>the list of available uWSGI options at <a href="https://uwsgi-docs.readthedocs.io/en/latest/Options.html">https://uwsgi-docs.readthedocs.io/en/latest/Options.html</a>.</p>
<p class="normal">You will not be able to access your uWSGI instance from your browser now, since it’s running through a socket. To complete the environment, we will use NGINX in front of uWSGI, to manage HTTP requests and pass application requests to uWSGI through the socket. Let’s complete the production environment.</p>
<h2 class="heading-2" id="_idParaDest-463">Using NGINX</h2>
<p class="normal">When you are serving a website, you have to serve dynamic content, but you also need to serve <a id="_idIndexMarker1605"/>static files, such as CSS style sheets, JavaScript files, and images. While uWSGI is capable of serving static files, it adds unnecessary overhead to HTTP requests and, therefore, it is encouraged to set up a web server, such as NGINX, in front of it.</p>
<p class="normal">NGINX is a web server focused on high concurrency, performance, and low memory usage. NGINX also acts as a reverse proxy, receiving HTTP and WebSocket requests and routing them to different backends.</p>
<p class="normal">Generally, you will use a web server, such as NGINX, in front of uWSGI for serving static files efficiently, and you will forward dynamic requests to uWSGI workers. By using NGINX, you can also apply different rules and benefit from its reverse proxy capabilities.</p>
<p class="normal">We will <a id="_idIndexMarker1606"/>add the NGINX service to the Docker Compose file using the official NGINX Docker image. You can find information about the official NGINX Docker image at <a href="https://hub.docker.com/_/nginx">https://hub.docker.com/_/nginx</a>.</p>
<p class="normal">Edit the <code class="inlineCode">docker-compose.yml</code> file and add the following lines highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">services:
  db:
    # ...
  cache:
    # ...
  web:
    # ...
<strong class="hljs-slc">  nginx:</strong>
<strong class="hljs-slc">    image: nginx:</strong><strong class="hljs-number-slc">1.25.5</strong>
<strong class="hljs-slc">    restart: always</strong>
<strong class="hljs-slc">    volumes:</strong>
<strong class="hljs-slc">      - ./config/nginx:/etc/nginx/templates</strong>
<strong class="hljs-slc">      - .:/code</strong>
<strong class="hljs-slc">    ports:</strong>
<strong class="hljs-slc">      - </strong><strong class="hljs-string-slc">"80:80"</strong>
</code></pre>
<p class="normal">You have <a id="_idIndexMarker1607"/>added the definition for the <code class="inlineCode">nginx</code> service with the following subsections:</p>
<ul>
<li class="bulletList"><code class="inlineCode">image</code>: The service uses the base <code class="inlineCode">nginx</code> Docker image.</li>
<li class="bulletList"><code class="inlineCode">restart</code>: The restart policy is set to <code class="inlineCode">always</code>.</li>
<li class="bulletList"><code class="inlineCode">volumes</code>: You mount the <code class="inlineCode">./config/nginx</code> volume to the <code class="inlineCode">/etc/nginx/templates</code> directory of the Docker image. This is where NGINX will look for a default configuration template. You also mount the local directory <code class="inlineCode">.</code> to the <code class="inlineCode">/code</code> directory of the image, so that NGINX can have access to static files.</li>
<li class="bulletList"><code class="inlineCode">ports</code>: You expose port <code class="inlineCode">80</code>, which is mapped to container port <code class="inlineCode">80</code>. This is the default port for HTTP.</li>
</ul>
<p class="normal">Let’s configure the NGINX web server.</p>
<h2 class="heading-2" id="_idParaDest-464">Configuring NGINX</h2>
<p class="normal">Create the <a id="_idIndexMarker1608"/>following file path highlighted in bold under the <code class="inlineCode">config/</code> directory:</p>
<pre class="programlisting con"><code class="hljs-con">config/
    uwsgi/
      uwsgi.ini
    <strong class="hljs-slc">nginx/</strong>
<strong class="hljs-slc">default.conf.template</strong>
</code></pre>
<p class="normal">Edit the <code class="inlineCode">nginx/default.conf.template</code> file and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code"># upstream for uWSGI
upstream uwsgi_app {
    server unix:/code/educa/uwsgi_app.sock;
}
server {
    listen       80;
    server_name  www.educaproject.com educaproject.com;
    error_log    stderr warn;
    access_log   /dev/stdout main;
    location / {
        include      /etc/nginx/uwsgi_params;
        uwsgi_pass   uwsgi_app;
    }
}
</code></pre>
<p class="normal">This is the <a id="_idIndexMarker1609"/>basic configuration for NGINX. In this configuration, you set up an <code class="inlineCode">upstream</code> component named <code class="inlineCode">uwsgi_app</code>, which points to the socket created by uWSGI. You use the <code class="inlineCode">server</code> block with the following configuration:</p>
<ul>
<li class="bulletList">You tell NGINX to listen on port <code class="inlineCode">80</code>.</li>
<li class="bulletList">You set the server name to both <code class="inlineCode">www.educaproject.com</code> and <code class="inlineCode">educaproject.com</code>. NGINX will serve incoming requests for both domains.</li>
<li class="bulletList">You use <code class="inlineCode">stderr</code> for the <code class="inlineCode">error_log</code> directive to get error logs written to the standard error file. The second parameter determines the logging level. You use <code class="inlineCode">warn</code> to get warnings and errors of higher severity.</li>
<li class="bulletList">You point <code class="inlineCode">access_log</code> to the standard output with <code class="inlineCode">/dev/stdout</code>.</li>
<li class="bulletList">You specify that any request under the <code class="inlineCode">/</code> path has to be routed with the <code class="inlineCode">uwsgi_app</code> socket to uWSGI.</li>
<li class="bulletList">You include the default uWSGI configuration parameters that come with NGINX. These are located at <code class="inlineCode">/etc/nginx/uwsgi_params</code>.</li>
</ul>
<p class="normal">NGINX is <a id="_idIndexMarker1610"/>now configured. You can find the NGINX documentation at <a href="https://nginx.org/en/docs/">https://nginx.org/en/docs/</a>.</p>
<p class="normal">Stop the Docker application from the shell by pressing the <em class="italic">Ctrl</em> + <em class="italic">C</em> keys or using the stop button in the Docker Desktop app. Then, start Compose again with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose up
</code></pre>
<p class="normal">Open the <code class="inlineCode">http://localhost/</code> URL in your browser. It’s not necessary to add a port to the URL because you are accessing the host through the standard HTTP port <code class="inlineCode">80</code>. You should see the course list page with no CSS styles, like <em class="italic">Figure 17.6</em>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_06.png"/></figure>
<p class="packt_figref">Figure 17.6: The course list page served with NGINX and uWSGI</p>
<p class="normal">The following <a id="_idIndexMarker1611"/>diagram shows the request/response cycle of the production environment that you have set up:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_07.png"/></figure>
<p class="packt_figref">Figure 17.7: The production environment request/response cycle</p>
<p class="normal">The following happens when the client browser sends an HTTP request:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">NGINX receives the HTTP request.</li>
<li class="numberedList">NGINX delegates the request to uWSGI through a socket.</li>
<li class="numberedList">uWSGI passes the request to Django for processing.</li>
<li class="numberedList">Django returns an HTTP response that is passed back to NGINX, which in turn passes it back to the client browser.</li>
</ol>
<p class="normal">If you <a id="_idIndexMarker1612"/>check the Docker Desktop application, you should see that there are four containers running:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">db</code> service is running PostgreSQL</li>
<li class="bulletList">The <code class="inlineCode">cache</code> service is running Redis</li>
<li class="bulletList">The <code class="inlineCode">web</code> service is running uWSGI and Django</li>
<li class="bulletList">The <code class="inlineCode">nginx</code> service is running NGINX</li>
</ul>
<p class="normal">Let’s continue with the production environment setup. Instead of accessing our project using <code class="inlineCode">localhost</code>, we will configure the project to use the <code class="inlineCode">educaproject.com</code> hostname.</p>
<h2 class="heading-2" id="_idParaDest-465">Using a hostname</h2>
<p class="normal">You will use the <code class="inlineCode">educaproject.com</code> hostname for your site. Since you are using a sample domain name, you need to redirect it to your local host.</p>
<p class="normal">If you are <a id="_idIndexMarker1613"/>using Linux or macOS, edit the <code class="inlineCode">/etc/hosts</code> file and add the following line to it:</p>
<pre class="programlisting con"><code class="hljs-con">127.0.0.1 educaproject.com www.educaproject.com
</code></pre>
<p class="normal">If you are using Windows, edit the <code class="inlineCode">C:\Windows\System32\drivers\etc</code> file and add the same line.</p>
<p class="normal">By doing so, you are routing the <code class="inlineCode">educaproject.com</code> and <code class="inlineCode">www.educaproject.com</code> hostnames to your local server. In a production server, you won’t need to do this, since you will have a fixed IP address and you will point your hostname to your server in your domain’s DNS configuration.</p>
<p class="normal">Open <code class="inlineCode">http://educaproject.com/</code> in your browser. You should be able to see your site, still without any static assets loaded. Your production environment is almost ready.</p>
<p class="normal">Now, you can restrict the hosts that can serve your Django project. Edit the <code class="inlineCode">educa/settings/prod.py</code> production settings file of your project and change the <code class="inlineCode">ALLOWED_HOSTS</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">ALLOWED_HOSTS = [<strong class="hljs-string-slc">'educaproject.com'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'www.educaproject.com'</strong>]
</code></pre>
<p class="normal">Django will only serve your application if it’s running under any of these hostnames. You can read <a id="_idIndexMarker1614"/>more about the <code class="inlineCode">ALLOWED_HOSTS</code> setting at <a href="https://docs.djangoproject.com/en/5.0/ref/settings/#allowed-hosts">https://docs.djangoproject.com/en/5.0/ref/settings/#allowed-hosts</a>.</p>
<p class="normal">The production <a id="_idIndexMarker1615"/>environment is almost ready. Let’s continue by configuring NGINX to serve static files.</p>
<h2 class="heading-2" id="_idParaDest-466">Serving static and media assets</h2>
<p class="normal">uWSGI is capable of serving static files flawlessly, but it is not as fast and effective as NGINX. For the <a id="_idIndexMarker1616"/>best performance, you will use NGINX to serve static <a id="_idIndexMarker1617"/>files in your production environment. You will set up NGINX to serve both the static files of your application (CSS style sheets, JavaScript files, and images) and media files uploaded by instructors for the course contents.</p>
<p class="normal">Edit the <code class="inlineCode">settings/base.py</code> file and add the following line just below the <code class="inlineCode">STATIC_URL</code> setting:</p>
<pre class="programlisting code"><code class="hljs-code">STATIC_ROOT = BASE_DIR / 'static'
</code></pre>
<p class="normal">This is the root directory for all static files of the project. Next, you are going to collect the static files from the different Django applications into the common directory.</p>
<h3 class="heading-3" id="_idParaDest-467">Collecting static files</h3>
<p class="normal">Each application in your Django project may contain static files in a <code class="inlineCode">static/</code> directory. Django provides <a id="_idIndexMarker1618"/>a command to collect static files from all applications into a single location. This simplifies the setup for serving static files in production. The <code class="inlineCode">collectstatic</code> command collects the static files from all applications of the project into the path defined with the <code class="inlineCode">STATIC_ROOT</code> setting.</p>
<p class="normal">Stop the Docker application from the shell by pressing the <em class="italic">Ctrl</em> + <em class="italic">C</em> keys or using the stop button in the Docker Desktop app. Then, start Compose again with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose up
</code></pre>
<p class="normal">Open another shell in the parent directory, where the <code class="inlineCode">docker-compose.yml</code> file is located, and run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose exec web python /code/educa/manage.py collectstatic
</code></pre>
<p class="normal">Note that you can alternatively run the following command in the shell, from the <code class="inlineCode">educa/</code> project directory:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py collectstatic --settings=educa.settings.local
</code></pre>
<p class="normal">Both commands will have the same effect since the base local directory is mounted to the Docker image. Django will ask whether you want to override any existing files in the root directory. Type <code class="inlineCode">yes</code> and press <em class="italic">Enter</em>. You will see the following output:</p>
<pre class="programlisting con"><code class="hljs-con">171 static files copied to '/code/educa/static'.
</code></pre>
<p class="normal">Files located <a id="_idIndexMarker1619"/>under the <code class="inlineCode">static/</code> directory of each application present in the <code class="inlineCode">INSTALLED_APPS</code> setting have been copied to the global <code class="inlineCode">/educa/static/</code> project directory.</p>
<h3 class="heading-3" id="_idParaDest-468">Serving static files with NGINX</h3>
<p class="normal">Edit <a id="_idIndexMarker1620"/>the <code class="inlineCode">config/nginx/default.conf.template</code> file and <a id="_idIndexMarker1621"/>add the following lines highlighted in bold to the <code class="inlineCode">server</code> block:</p>
<pre class="programlisting code"><code class="hljs-code">server {
    # ...
    location / {
        include      /etc/nginx/uwsgi_params;
        uwsgi_pass   uwsgi_app;
    }
<strong class="hljs-slc">    location /static/ {</strong>
<strong class="hljs-slc">        alias /code/educa/static/;</strong>
<strong class="hljs-slc">    }</strong>
<strong class="hljs-slc">    location /media/ {</strong>
<strong class="hljs-slc">        alias /code/educa/media/;</strong>
<strong class="hljs-slc">    }</strong>
}
</code></pre>
<p class="normal">These directives tell NGINX to serve static files located under the <code class="inlineCode">/static/</code> and <code class="inlineCode">/media/</code> paths directly. These paths are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">/static/</code>: This corresponds to the path of the <code class="inlineCode">STATIC_URL</code> setting. The target path corresponds to the value of the <code class="inlineCode">STATIC_ROOT</code> setting. You use it to serve the static files of your application from the directory mounted to the NGINX Docker image.</li>
<li class="bulletList"><code class="inlineCode">/media/</code>: This corresponds to the path of the <code class="inlineCode">MEDIA_URL</code> setting, and its target path corresponds to the value of the <code class="inlineCode">MEDIA_ROOT</code> setting. You use it to serve the <a id="_idIndexMarker1622"/>media files uploaded to the <a id="_idIndexMarker1623"/>course contents from the directory mounted to the NGINX Docker image.</li>
</ul>
<p class="normal"><em class="italic">Figure 17.8 </em>shows the current setup of the production environment:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_08.png"/></figure>
<p class="packt_figref">Figure 17.8: The production environment request/response cycle, including static files</p>
<p class="normal">Files under the <code class="inlineCode">/static/</code> and <code class="inlineCode">/media/</code> paths are now served by NGINX directly, instead of being forwarded to uWSGI. Requests to any other path are still passed by NGINX to uWSGI through the UNIX socket.</p>
<p class="normal">Stop the Docker application from the shell by pressing the <em class="italic">Ctrl</em> + <em class="italic">C</em> keys or using the stop button in the Docker Desktop app. Then, start Compose again with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose up
</code></pre>
<p class="normal">Open <code class="inlineCode">http://educaproject.com/</code> in your browser. You should see the following screen:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_09.png"/></figure>
<p class="packt_figref">Figure 17.9: The course list page served with NGINX and uWSGI</p>
<p class="normal">Static resources, such as CSS style sheets and images, are now loaded correctly. HTTP requests <a id="_idIndexMarker1624"/>for static files are now being served by NGINX directly, instead of being forwarded to uWSGI.</p>
<p class="normal">You have <a id="_idIndexMarker1625"/>successfully configured NGINX for serving static files. Next, you are going to perform some checks on your Django project to validate it for a production environment and you are going to serve your site under HTTPS.</p>
<h1 class="heading-1" id="_idParaDest-469">Securing your site with SSL/TLS</h1>
<p class="normal">The <strong class="keyWord">TLS</strong> protocol is <a id="_idIndexMarker1626"/>the standard for serving websites through a secure connection. The TLS predecessor is SSL. Although SSL is now deprecated, in multiple <a id="_idIndexMarker1627"/>libraries and online documentation, you will find <a id="_idIndexMarker1628"/>references to both the terms TLS and SSL. It’s strongly encouraged that you serve your websites over HTTPS.</p>
<p class="normal">In this section, you are going to check your Django project for any issues and validate it for a production deployment. You will also prepare the project to be served over HTTPS. Then, you are going to configure an SSL/TLS certificate in NGINX to serve your site securely.</p>
<h2 class="heading-2" id="_idParaDest-470">Checking your project for production</h2>
<p class="normal">Django includes a system check framework for validating your project at any time. The check framework <a id="_idIndexMarker1629"/>inspects the applications installed in your Django project and detects common problems. Checks are triggered implicitly when you run management commands like <code class="inlineCode">runserver</code> and <code class="inlineCode">migrate</code>. However, you can trigger checks explicitly with the <code class="inlineCode">check</code> management command.</p>
<p class="normal">You can <a id="_idIndexMarker1630"/>read more about Django’s system check framework at <a href="https://docs.djangoproject.com/en/5.0/topics/checks/">https://docs.djangoproject.com/en/5.0/topics/checks/</a>.</p>
<p class="normal">Let’s confirm that the check framework does not raise any issues for your project. Open the shell in the <code class="inlineCode">educa</code> project directory and run the following command to check your project:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py check --settings=educa.settings.prod
</code></pre>
<p class="normal">You will see the following output:</p>
<pre class="programlisting con"><code class="hljs-con">System check identified no issues (0 silenced).
</code></pre>
<p class="normal">The system check framework didn’t identify any issues. If you use the <code class="inlineCode">--deploy</code> option, the system check framework will perform additional checks that are relevant for a production deployment.</p>
<p class="normal">Run the following command from the <code class="inlineCode">educa</code> project directory:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py check --deploy --settings=educa.settings.prod
</code></pre>
<p class="normal">You will see an output like the following:</p>
<pre class="programlisting con"><code class="hljs-con">System check identified some issues:
WARNINGS:
(security.W004) You have not set a value for the SECURE_HSTS_SECONDS setting. ...
(security.W008) Your SECURE_SSL_REDIRECT setting is not set to True...
(security.W009) Your SECRET_KEY has less than 50 characters, less than 5 unique characters, or it's prefixed with 'django-insecure-'...
(security.W012) SESSION_COOKIE_SECURE is not set to True. ...
(security.W016) You have 'django.middleware.csrf.CsrfViewMiddleware' in your MIDDLEWARE, but you have not set CSRF_COOKIE_SECURE ...
System check identified 5 issues (0 silenced).
</code></pre>
<p class="normal">The check framework has identified five issues (zero errors and five warnings). All warnings are related to security-related settings.</p>
<p class="normal">Let’s address <a id="_idIndexMarker1631"/>the <code class="inlineCode">security.W009</code> issue. Edit the <code class="inlineCode">educa/settings/base.py</code> file and modify the <code class="inlineCode">SECRET_KEY</code> setting by removing the <code class="inlineCode">django-insecure-</code> prefix and adding additional random characters to generate a string with at least 50 characters.</p>
<p class="normal">Run the <code class="inlineCode">check</code> command again and verify that the <code class="inlineCode">security.W009</code> issue is not raised anymore. The rest of the warnings are related to SSL/TLS configuration. We will address them next.</p>
<h2 class="heading-2" id="_idParaDest-471">Configuring your Django project for SSL/TLS</h2>
<p class="normal">Django <a id="_idIndexMarker1632"/>comes with specific settings for SSL/TLS support. You are going to edit the production settings to serve your site over HTTPS.</p>
<p class="normal">Edit the <code class="inlineCode">educa/settings/prod.py</code> settings file and add the following settings to it:</p>
<pre class="programlisting code"><code class="hljs-code"># Security
CSRF_COOKIE_SECURE = True
SESSION_COOKIE_SECURE = True
SECURE_SSL_REDIRECT = True
</code></pre>
<p class="normal">These settings are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">CSRF_COOKIE_SECURE</code>: Use a secure cookie for <strong class="keyWord">cross-site request forgery</strong> (<strong class="keyWord">CSRF</strong>) protection. With <code class="inlineCode">True</code>, browsers will only transfer the cookie over HTTPS.</li>
<li class="bulletList"><code class="inlineCode">SESSION_COOKIE_SECURE</code>: Use a secure session cookie. With <code class="inlineCode">True</code>, browsers will only transfer the cookie over HTTPS.</li>
<li class="bulletList"><code class="inlineCode">SECURE_SSL_REDIRECT</code>: This indicates whether HTTP requests have to be redirected to HTTPS.</li>
</ul>
<p class="normal">Django will now redirect HTTP requests to HTTPS; session and CSRF cookies will be sent only over HTTPS.</p>
<p class="normal">Run the following command from the main directory of your project:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py check --deploy --settings=educa.settings.prod
</code></pre>
<p class="normal">Only one warning remains, <code class="inlineCode">security.W004</code>:</p>
<pre class="programlisting con"><code class="hljs-con">(security.W004) You have not set a value for the SECURE_HSTS_SECONDS setting. ...
</code></pre>
<p class="normal">This warning <a id="_idIndexMarker1633"/>is related to the <strong class="keyWord">HTTP Strict Transport Security</strong> (<strong class="keyWord">HSTS</strong>) policy. The HSTS policy prevents users from bypassing warnings and connecting to a site with an expired, self-signed, or otherwise invalid SSL certificate. In the next section, we will use a self-signed certificate for our site, so we will ignore this <a id="_idIndexMarker1634"/>warning. </p>
<p class="normal">When you own a real domain, you can apply for a trusted <strong class="keyWord">Certificate Authority</strong> (<strong class="keyWord">CA</strong>) to issue an SSL/TLS certificate for it, so that <a id="_idIndexMarker1635"/>browsers can verify its identity. In that case, you can give a value to <code class="inlineCode">SECURE_HSTS_SECONDS</code> higher than <code class="inlineCode">0</code>, which is the default value. You <a id="_idIndexMarker1636"/>can learn more about the HSTS policy at <a href="https://docs.djangoproject.com/en/5.0/ref/middleware/#http-strict-transport-security">https://docs.djangoproject.com/en/5.0/ref/middleware/#http-strict-transport-security</a>.</p>
<p class="normal">You have successfully fixed the rest of the issues raised by the check framework. You can read more about the Django deployment checklist at <a href="https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/">https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/</a>.</p>
<h2 class="heading-2" id="_idParaDest-472">Creating an SSL/TLS certificate</h2>
<p class="normal">Create a new <a id="_idIndexMarker1637"/>directory inside the <code class="inlineCode">educa</code> project directory and name it <code class="inlineCode">ssl</code>. Then, generate an SSL/TLS certificate from the command line with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">openssl req -x509 -newkey rsa:2048 -sha256 -days 3650 -nodes \
  -keyout ssl/educa.key -out ssl/educa.crt \
  -subj '/CN=*.educaproject.com' \
  -addext 'subjectAltName=DNS:*.educaproject.com'
</code></pre>
<p class="normal">This will generate a private key and a 2048-bit SSL/TLS certificate that is valid for 10 years. This certificate is issued for the <code class="inlineCode">*.educaproject.com</code> hostname. This is a wildcard certificate; by using the * wildcard character in the domain name, the certificate can be used for any subdomain of <code class="inlineCode">educaproject.com</code>, such as <code class="inlineCode">www.educaproject.com</code> or <code class="inlineCode">django.educaproject.com</code>. After generating the certificate, the <code class="inlineCode">educa/ssl/</code> directory will contain two files: <code class="inlineCode">educa.key</code> (the private key) and <code class="inlineCode">educa.crt</code> (the certificate).</p>
<p class="normal">You will need at least OpenSSL 1.1.1 or LibreSSL 3.1.0 to use the <code class="inlineCode">-addext</code> option. You can check the OpenSSL location in your machine with the <code class="inlineCode">which openssl</code> command and you can check <a id="_idIndexMarker1638"/>the version with the <code class="inlineCode">openssl version</code> command.</p>
<p class="normal">Alternatively, you can use the SSL/TLS certificate provided in the source code for this chapter. You will find the certificate at <a href="https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter17/educa/ssl/">https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter17/educa/ssl/</a>. Note that you should generate a private key and not use this certificate in production.</p>
<h2 class="heading-2" id="_idParaDest-473">Configuring NGINX to use SSL/TLS</h2>
<p class="normal">Edit <a id="_idIndexMarker1639"/>the <code class="inlineCode">docker-compose.yml</code> file and add the <a id="_idIndexMarker1640"/>following line highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">services:
  # ...
  nginx:
    #...
    ports:
      - "80:80"
<strong class="hljs-slc">      - </strong><strong class="hljs-string-slc">"443:443"</strong>
</code></pre>
<p class="normal">The NGINX container host will be accessible through port <code class="inlineCode">80</code> (HTTP) and port <code class="inlineCode">443</code> (HTTPS). The host port <code class="inlineCode">443</code> is mapped to the container port <code class="inlineCode">443</code>.</p>
<p class="normal">Edit the <code class="inlineCode">config/nginx/default.conf.template</code> file of the <code class="inlineCode">educa</code> project and edit the <code class="inlineCode">server</code> block to include SSL/TLS, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">server {
   listen               80;
<strong class="hljs-slc">   listen               </strong><strong class="hljs-number-slc">443</strong><strong class="hljs-slc"> ssl;</strong>
<strong class="hljs-slc">   ssl_certificate      /code/educa/ssl/educa.crt;</strong>
<strong class="hljs-slc">   ssl_certificate_key  /code/educa/ssl/educa.key;</strong>
   server_name          www.educaproject.com educaproject.com;
   # ...
}
</code></pre>
<p class="normal">With the preceding code, NGINX now listens both to HTTP over port <code class="inlineCode">80</code> and HTTPS over port <code class="inlineCode">443</code>. You indicate the path to the SSL/TLS certificate with <code class="inlineCode">ssl_certificate</code> and the certificate key with <code class="inlineCode">ssl_certificate_key</code>.</p>
<p class="normal">Stop the Docker application from the shell by pressing the <em class="italic">Ctrl</em> + <em class="italic">C</em> keys or using the stop button <a id="_idIndexMarker1641"/>in the Docker Desktop app. Then, start <a id="_idIndexMarker1642"/>Compose again with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose up
</code></pre>
<p class="normal">Open <code class="inlineCode">https://educaproject.com/</code> with your browser. You should see a warning message similar to the following one:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_10.png"/></figure>
<p class="packt_figref">Figure 17.10: An invalid certificate warning</p>
<p class="normal">This screen might vary depending on your browser. It alerts you that your site is not using a trusted or valid certificate; the browser can’t verify the identity of your site. This is because you signed your own certificate instead of obtaining one from a trusted CA. When you own a real domain, you can apply for a trusted CA to issue an SSL/TLS certificate for it, so that browsers can verify its identity. If you want to obtain a trusted certificate <a id="_idIndexMarker1643"/>for a real domain, you can refer to the Let’s Encrypt project created by the Linux Foundation. It is a nonprofit CA that simplifies <a id="_idIndexMarker1644"/>obtaining and renewing trusted SSL/TLS certificates for free. You can find more information at <a href="https://letsencrypt.org">https://letsencrypt.org</a>.</p>
<p class="normal">Click on the link or button that provides additional information and choose to visit the website, ignoring warnings. The browser might ask you to add an exception for this certificate or verify that you trust it. If you are using Chrome, you might not see any option to proceed to the website. If this is the case, type <code class="inlineCode">thisisunsafe</code> and press <em class="italic">Enter</em> directly in Chrome on the warning page. Chrome will then load the website. Note that you do this with your own issued certificate; don’t trust any unknown certificate or bypass the browser SSL/TLS certificate checks for other domains.</p>
<p class="normal">When you access the site, the browser will display a lock icon next to the URL like <em class="italic">Figure 17.11</em>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_11.png"/></figure>
<p class="packt_figref">Figure 17.11: The browser address bar, including a secure connection padlock icon</p>
<p class="normal">Other browsers might display a warning indicating that the certificate is not trusted, like <em class="italic">Figure 17.12</em>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_12.png"/></figure>
<p class="packt_figref">Figure 17.12: The browser address bar, including a warning message</p>
<p class="normal">Your browser might mark the certificate as unsafe, but you are using it for testing purposes only. You are now serving your site securely over HTTPS.</p>
<h2 class="heading-2" id="_idParaDest-474">Redirecting HTTP traffic over to HTTPS</h2>
<p class="normal">You <a id="_idIndexMarker1645"/>are redirecting HTTP requests to HTTPS with Django using the <code class="inlineCode">SECURE_SSL_REDIRECT</code> setting. Any request using <code class="inlineCode">http://</code> is redirected to the same URL using <code class="inlineCode">https://</code>. However, this can be handled in a more efficient manner using NGINX.</p>
<p class="normal">Edit the <code class="inlineCode">config/nginx/default.conf.template</code> file and add the following lines highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code"># upstream for uWSGI
upstream uwsgi_app {
    server unix:/code/educa/uwsgi_app.sock;
}
server {
    listen      80;
    <strong class="hljs-slc">server_name www.educaproject.com educaproject.com;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> </strong><strong class="hljs-number-slc">301</strong><strong class="hljs-slc"> https://$host$request_uri;</strong>
<strong class="hljs-slc">}</strong>
<strong class="hljs-slc">server {</strong>
    listen               443 ssl;
    ssl_certificate      /code/educa/ssl/educa.crt;
    ssl_certificate_key  /code/educa/ssl/educa.key;
    server_name   www.educaproject.com educaproject.com;
    # ...
}
</code></pre>
<p class="normal">In this code, you remove the directive <code class="inlineCode">listen 80;</code> from the original <code class="inlineCode">server</code> block, so that the platform is only available over HTTPS (port <code class="inlineCode">443</code>). On top of the original <code class="inlineCode">server</code> block, you add an additional <code class="inlineCode">server</code> block that only listens on port <code class="inlineCode">80</code> and redirects all HTTP requests to HTTPS. To achieve this, you return an HTTP response code <code class="inlineCode">301</code> (permanent redirect) that redirects to the <code class="inlineCode">https://</code> version of the requested URL using the <code class="inlineCode">$host</code> and <code class="inlineCode">$request_uri</code> variables.</p>
<p class="normal">Open a shell in the parent directory, where the <code class="inlineCode">docker-compose.yml</code> file is located, and run the following command to reload NGINX:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose exec nginx nginx -s reload
</code></pre>
<p class="normal">This runs the <code class="inlineCode">nginx -s reload</code> command in the <code class="inlineCode">nginx</code> container. You are now redirecting all HTTP traffic to HTTPS using NGINX.</p>
<p class="normal">Your <a id="_idIndexMarker1646"/>environment is now secured with TLS/SSL. To complete the production environment setup, the only remaining step is integrating Daphne to handle asynchronous requests, and get our course chat rooms running in production.</p>
<h1 class="heading-1" id="_idParaDest-475">Configuring Daphne for Django Channels</h1>
<p class="normal">In <em class="italic">Chapter 16</em>, <em class="italic">Building a Chat Server</em>, you used Django Channels to build a chat server using <a id="_idIndexMarker1647"/>WebSockets and you used Daphne to <a id="_idIndexMarker1648"/>serve asynchronous requests by replacing the standard Django <code class="inlineCode">runserver</code> command. We will add Daphne to our production environment.</p>
<p class="normal">Let’s create a new service in the Docker Compose file to run the Daphne web server.</p>
<p class="normal">Edit the <code class="inlineCode">docker-compose.yml</code> file and add the following lines inside the <code class="inlineCode">services</code> block:</p>
<pre class="programlisting code"><code class="hljs-code">daphne:
    build: .
    working_dir: /code/educa/
    command: ["../wait-for-it.sh", "db:5432", "--",
              "daphne", "-b", "0.0.0.0", "-p", "9001",
              "educa.asgi:application"]
    restart: always
    volumes:
      - .:/code
    environment:
      - DJANGO_SETTINGS_MODULE=educa.settings.prod
      - POSTGRES_DB=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    depends_on:
      - db
      - cache
</code></pre>
<p class="normal">The <code class="inlineCode">daphne</code> service definition is very similar to the <code class="inlineCode">web</code> service. The image for the <code class="inlineCode">daphne</code> service is also built with the <code class="inlineCode">Dockerfile</code> you previously created for the <code class="inlineCode">web</code> service. The main differences are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">working_dir</code> changes the working directory of the image to <code class="inlineCode">/code/educa/</code>.</li>
<li class="bulletList"><code class="inlineCode">command</code> runs the <code class="inlineCode">educa.asgi:application</code> application defined in the <code class="inlineCode">educa/asgi.py</code> file with <code class="inlineCode">daphne</code> in the <code class="inlineCode">0.0.0.0</code> hostname and port <code class="inlineCode">9001</code>. It also uses the <code class="inlineCode">wait-for-it</code> bash script to wait for the PostgreSQL database to be ready before initializing the web server.</li>
</ul>
<p class="normal">Since you <a id="_idIndexMarker1649"/>are running Django on production, Django checks the <code class="inlineCode">ALLOWED_HOSTS</code> when receiving HTTP requests. We will implement <a id="_idIndexMarker1650"/>the same validation for WebSocket connections.</p>
<p class="normal">Edit the <code class="inlineCode">educa/asgi.py</code> file of your project and add the following lines highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> channels.security.websocket </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> AllowedHostsOriginValidator</strong>
from channels.auth import AuthMiddlewareStack
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'educa.settings')
django_asgi_app = get_asgi_application()
from chat.routing import websocket_urlpatterns
application = ProtocolTypeRouter({
    'http': django_asgi_app,
    'websocket': <strong class="hljs-slc">AllowedHostsOriginValidator(</strong>
        AuthMiddlewareStack(
            URLRouter(websocket_urlpatterns)
        )
    <strong class="hljs-slc">)</strong>,
})
</code></pre>
<p class="normal">The Channels configuration is now ready for production.</p>
<h2 class="heading-2" id="_idParaDest-476">Using secure connections for WebSockets</h2>
<p class="normal">You <a id="_idIndexMarker1651"/>have configured NGINX <a id="_idIndexMarker1652"/>to use secure connections with SSL/TLS. You need to change <code class="inlineCode">ws</code> (WebSocket) connections to use the <code class="inlineCode">wss</code> (WebSocket Secure) protocol now, in the same way that HTTP connections are now being served over HTTPS.</p>
<p class="normal">Edit the <code class="inlineCode">chat/room.html</code> template of the <code class="inlineCode">chat</code> application and find the following line in the <code class="inlineCode">domready</code> block:</p>
<pre class="programlisting code"><code class="hljs-code">const url = 'ws://' + window.location.host +
</code></pre>
<p class="normal">Replace <a id="_idIndexMarker1653"/>that line with <a id="_idIndexMarker1654"/>the following one:</p>
<pre class="programlisting code"><code class="hljs-code">const url = 'ws<strong class="hljs-string-slc">s</strong>://' + window.location.host +
</code></pre>
<p class="normal">By using <code class="inlineCode">wss://</code> instead of <code class="inlineCode">ws://</code>, you are explicitly connecting to a secure WebSocket.</p>
<h2 class="heading-2" id="_idParaDest-477">Including Daphne in the NGINX configuration</h2>
<p class="normal">In your production setup, you will run Daphne on a UNIX socket and use NGINX in front of it. NGINX <a id="_idIndexMarker1655"/>will pass requests to Daphne based on the requested path. You will expose Daphne to NGINX through a UNIX socket interface, just like the uWSGI setup.</p>
<p class="normal">Edit the <code class="inlineCode">config/nginx/default.conf.template</code> file and make it look as follows:</p>
<pre class="programlisting code"><code class="hljs-code"># upstream for uWSGI
upstream uwsgi_app {
    server unix:/code/educa/uwsgi_app.sock;
}
<strong class="hljs-comment-slc"># upstream for Daphne</strong>
<strong class="hljs-slc">upstream daphne {</strong>
<strong class="hljs-slc">    server daphne:</strong><strong class="hljs-number-slc">9001</strong><strong class="hljs-slc">;</strong>
<strong class="hljs-slc">}</strong>
server {
    listen       80;
    server_name www.educaproject.com educaproject.com;
    return 301 https://$host$request_uri;
}
server {
    listen               443 ssl;
    ssl_certificate      /code/educa/ssl/educa.crt;
    ssl_certificate_key  /code/educa/ssl/educa.key;
    server_name  www.educaproject.com educaproject.com;
    error_log    stderr warn;
    access_log   /dev/stdout main;
    location / {
        include      /etc/nginx/uwsgi_params;
        uwsgi_pass   uwsgi_app;
    }
<strong class="hljs-slc">    location /ws/ {</strong>
<strong class="hljs-slc">        proxy_pass          http://daphne;</strong>
<strong class="hljs-slc">        proxy_http_version  </strong><strong class="hljs-number-slc">1.1</strong><strong class="hljs-slc">;</strong>
<strong class="hljs-slc">        proxy_set_header    Upgrade $http_upgrade;</strong>
<strong class="hljs-slc">        proxy_set_header    Connection </strong><strong class="hljs-string-slc">"upgrade"</strong><strong class="hljs-slc">;</strong>
<strong class="hljs-slc">        proxy_redirect      off;</strong>
<strong class="hljs-slc">    }</strong>
    location /static/ {
        alias /code/educa/static/;
    }
    location /media/ {
        alias /code/educa/media/;
    }
}
</code></pre>
<p class="normal">In this <a id="_idIndexMarker1656"/>configuration, you set up a new upstream named <code class="inlineCode">daphne</code>, which points to the <code class="inlineCode">daphne</code> host and port <code class="inlineCode">9001</code>. In the <code class="inlineCode">server</code> block, you configure the <code class="inlineCode">/ws/</code> location to forward requests to Daphne. You use the <code class="inlineCode">proxy_pass</code> directive to pass requests to Daphne and you include some additional proxy directives.</p>
<p class="normal">With this configuration, NGINX will pass any URL request that starts with the <code class="inlineCode">/ws/</code> prefix to Daphne and the rest to uWSGI, except for files under the <code class="inlineCode">/static/</code> or <code class="inlineCode">/media/</code> paths, which will be served directly by NGINX.</p>
<p class="normal"><em class="italic">Figure 17.13</em> shows the final production setup, including the Daphne server:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_13.png"/></figure>
<p class="packt_figref">Figure 17.13: The production environment request/response cycle, including Daphne</p>
<p class="normal">NGINX runs in front of uWSGI and Daphne as a reverse proxy server. NGINX faces the web <a id="_idIndexMarker1657"/>and passes requests to the application server (uWSGI or Daphne) based on their path prefix. Besides this, NGINX also serves static files and redirects non-secure requests to secure ones. This setup reduces downtime, consumes fewer server resources, and provides greater performance and security.</p>
<p class="normal">Stop the Docker application from the shell by pressing the <em class="italic">Ctrl</em> + <em class="italic">C</em> keys or using the stop button in the Docker Desktop app. Then, start Compose again with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose up
</code></pre>
<p class="normal">Use your browser to create a sample course with an instructor user, log in with a user who is enrolled in the course, and open <code class="inlineCode">https://educaproject.com/chat/room/1/</code> with your browser. You should be able to send and receive messages like the following example:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_14.png"/></figure>
<p class="packt_figref">Figure 17.14: Course chat room messages served with NGINX and Daphne</p>
<p class="normal">Daphne <a id="_idIndexMarker1658"/>is working correctly, and NGINX is passing WebSocket requests to it. All connections are secured with SSL/TLS.</p>
<p class="normal">Congratulations! You have built a custom production-ready stack using NGINX, uWSGI, and Daphne. You could do further optimization for additional performance and enhanced security through configuration settings in NGINX, uWSGI, and Daphne. However, this production setup is a great start!</p>
<p class="normal">You have used Docker Compose to define and run services in multiple containers. Note that you can use Docker Compose both for local development environments as well as production environments. You can find additional information on using Docker Compose in production at <a href="https://docs.docker.com/compose/production/">https://docs.docker.com/compose/production/</a>.</p>
<p class="normal">For more advanced production environments, you will need to dynamically distribute containers across a varying number of machines. For that, instead of Docker Compose, you will need an orchestrator like Docker Swarm mode or Kubernetes. You can find information about the Docker Swarm mode at <a href="https://docs.docker.com/engine/swarm/">https://docs.docker.com/engine/swarm/</a>, and about Kubernetes at <a href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a>.</p>
<p class="normal">Note that managing systems and cloud infrastructure demands expertise in configuration, optimization, and security. To ensure a secure and efficient production environment, consider bringing a systems/DevOps expert on board or enhancing your own expertise in these areas.</p>
<p class="normal">Now that <a id="_idIndexMarker1659"/>we have a complete environment that processes HTTP requests in a performant manner, it’s a good time to dive into middleware for request/response processing across our application.</p>
<h1 class="heading-1" id="_idParaDest-478">Creating a custom middleware</h1>
<p class="normal">You already know the <code class="inlineCode">MIDDLEWARE</code> setting, which contains the middleware for your project. You can think of it as a low-level plugin system, allowing you to implement hooks that <a id="_idIndexMarker1660"/>get executed in the request/response process. Each middleware is responsible for some specific action that will be executed for all HTTP requests or responses.</p>
<div><p class="normal">You should avoid adding expensive processing to middleware since they are executed in every single request.</p>
</div>
<p class="normal"><em class="italic">Figure 17.15</em> shows the middleware execution in Django:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_15.png"/></figure>
<p class="packt_figref">Figure 17.15: Middleware execution in Django</p>
<p class="normal">When an <a id="_idIndexMarker1661"/>HTTP request is received, middleware is executed in order of appearance in the <code class="inlineCode">MIDDLEWARE</code> setting. When an HTTP response has been generated by Django, the response passes through all middleware back in reverse order.</p>
<p class="normal"><em class="italic">Figure 17.16</em> shows the execution order of the middleware components included in the <code class="inlineCode">MIDDLEWARE</code> setting when creating a project with the <code class="inlineCode">startproject</code> management command:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_17_16.png"/></figure>
<p class="packt_figref">Figure 17.16: Execution order for default middleware components</p>
<p class="normal">Middleware <a id="_idIndexMarker1662"/>can be written as a function, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">def my_middleware(get_response):
    def middleware(request):
        # Code executed for each request before
# the view (and later middleware) are called.
        response = get_response(request)
        # Code executed for each request/response after
# the view is called.
return response
    return middleware
</code></pre>
<p class="normal">A middleware factory is a callable that takes a <code class="inlineCode">get_response</code> callable and returns middleware. The <code class="inlineCode">middleware</code> callable takes a request and returns a response, just like a view. The <code class="inlineCode">get_response</code> callable might be the next middleware in the chain or the actual view in the case of the last listed middleware.</p>
<p class="normal">If any <a id="_idIndexMarker1663"/>middleware returns a response without calling its <code class="inlineCode">get_response</code> callable, it short-circuits the process; no further middleware gets executed (nor does the view), and the response returns through the same layers that the request passed in through.</p>
<p class="normal">The order of middleware components in the <code class="inlineCode">MIDDLEWARE</code> setting is very important because each component may depend on the data set in the request by other middleware components executed previously.</p>
<p class="normal">When adding a new middleware to the <code class="inlineCode">MIDDLEWARE</code> setting, make sure to place it in the right position.</p>
<p class="normal">You can find more information about middleware at <a href="https://docs.djangoproject.com/en/5.0/topics/http/middleware/">https://docs.djangoproject.com/en/5.0/topics/http/middleware/</a>.</p>
<h2 class="heading-2" id="_idParaDest-479">Creating subdomain middleware</h2>
<p class="normal">You are going to create custom middleware to allow courses to be accessible through a custom <a id="_idIndexMarker1664"/>subdomain. Each course detail URL, which looks like <code class="inlineCode">https://educaproject.com/course/django/</code>, will also be accessible through the subdomain that makes use of the course slug, such as <code class="inlineCode">https://django.educaproject.com/</code>. Users will be able to use the subdomain as a shortcut to access the course details. Any requests to subdomains will be redirected to each corresponding course detail URL.</p>
<p class="normal">Middleware can reside anywhere within your project. However, it’s recommended that you create a <code class="inlineCode">middleware.py</code> file in your application directory.</p>
<p class="normal">Create a new file inside the <code class="inlineCode">courses</code> application directory and name it <code class="inlineCode">middleware.py</code>. Add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">from django.urls import reverse
from django.shortcuts import get_object_or_404, redirect
from .models import Course
def subdomain_course_middleware(get_response):
    """
    Subdomains for courses
    """
def middleware(request):
        host_parts = request.get_host().split('.')
        if len(host_parts) &gt; 2 and host_parts[0] != 'www':
            # get course for the given subdomain
            course = get_object_or_404(Course, slug=host_parts[0])
            course_url = reverse('course_detail', args=[course.slug])
            # redirect current request to the course_detail view
            url = '{}://{}{}'.format(
                request.scheme, '.'.join(host_parts[1:]), course_url
            )
            return redirect(url)
        response = get_response(request)
        return response
    return middleware
</code></pre>
<p class="normal">When an <a id="_idIndexMarker1665"/>HTTP request is received, you perform the following tasks:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">You get the hostname that is being used in the request and divide it into parts. For example, if the user is accessing <code class="inlineCode">mycourse.educaproject.com</code>, you generate the <code class="inlineCode">['mycourse', 'educaproject', 'com']</code> list.</li>
<li class="numberedList">You check whether the hostname includes a subdomain by checking whether the split generated more than two elements. If the hostname includes a subdomain, and this is not <code class="inlineCode">www</code>, you try to get the course with the slug provided in the subdomain.</li>
<li class="numberedList">If a course is not found, you raise an HTTP <code class="inlineCode">404</code> exception. Otherwise, you redirect the browser to the course detail URL.</li>
</ol>
<p class="normal">Edit the <code class="inlineCode">settings/base.py</code> file of the project and add <code class="inlineCode">'courses.middleware.subdomain_course_middleware'</code> at the bottom of the <code class="inlineCode">MIDDLEWARE</code> list, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">MIDDLEWARE = [
    # ...
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'courses.middleware.subdomain_course_middleware'</strong><strong class="hljs-slc">,</strong>
]
</code></pre>
<p class="normal">The middleware will now be executed in every request.</p>
<p class="normal">Remember <a id="_idIndexMarker1666"/>that the hostnames allowed to serve your Django project are specified in the <code class="inlineCode">ALLOWED_HOSTS</code> setting. Let’s change this setting so that any possible subdomain of <code class="inlineCode">educaproject.com</code> is allowed to serve your application.</p>
<p class="normal">Edit the <code class="inlineCode">educa/settings/prod.py</code> file and modify the <code class="inlineCode">ALLOWED_HOSTS</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">ALLOWED_HOSTS = [<strong class="hljs-string-slc">'</strong><strong class="hljs-string-slc">.educaproject.com'</strong>]
</code></pre>
<p class="normal">A value that begins with a period is used as a subdomain wildcard; <code class="inlineCode">'.educaproject.com'</code> will match <code class="inlineCode">educaproject.com</code> and any subdomain for this domain, for example, <code class="inlineCode">course.educaproject.com</code> and <code class="inlineCode">django.educaproject.com</code>.</p>
<h3 class="heading-3" id="_idParaDest-480">Serving multiple subdomains with NGINX</h3>
<p class="normal">You need <a id="_idIndexMarker1667"/>NGINX to be able to serve your site <a id="_idIndexMarker1668"/>with any possible subdomain. Edit the <code class="inlineCode">config/nginx/default.conf.template</code> file at these two occurrences:</p>
<pre class="programlisting code"><code class="hljs-code">server_name  www.educaproject.com educaproject.com;
</code></pre>
<p class="normal">Replace the occurences of the preceding line with the following one:</p>
<pre class="programlisting code"><code class="hljs-code">server_name  <strong class="hljs-slc">*</strong>.educaproject.com educaproject.com;
</code></pre>
<p class="normal">By using the asterisk, this rule applies to all subdomains of <code class="inlineCode">educaproject.com</code>. In order to test your middleware locally, you need to add any subdomains you want to test to <code class="inlineCode">/etc/hosts</code>. For testing the middleware with a <code class="inlineCode">Course</code> object with the slug <code class="inlineCode">django</code>, add the following line to your <code class="inlineCode">/etc/hosts</code> file:</p>
<pre class="programlisting con"><code class="hljs-con">127.0.0.1  django.educaproject.com
</code></pre>
<p class="normal">Stop the Docker application from the shell by pressing the <em class="italic">Ctrl</em> + <em class="italic">C</em> keys or using the stop button in the Docker Desktop app. Then, start Compose again with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose up
</code></pre>
<p class="normal">Then, open <code class="inlineCode">https://django.educaproject.com/</code> in your browser. The middleware will find the course by the subdomain and redirect your browser to <code class="inlineCode">https://educaproject.com/course/django/</code>.</p>
<p class="normal">Your <a id="_idIndexMarker1669"/>custom subdomain middleware is working!</p>
<p class="normal">Now, we will <a id="_idIndexMarker1670"/>delve into a final topic that is extremely useful for projects: automating tasks and making them available as commands.</p>
<h1 class="heading-1" id="_idParaDest-481">Implementing custom management commands</h1>
<p class="normal">Django allows your applications to register custom management commands for the <code class="inlineCode">manage.py</code> utility. For example, you used the <code class="inlineCode">makemessages</code> and <code class="inlineCode">compilemessages</code> management commands in <em class="italic">Chapter 11</em>, <em class="italic">Adding Internationalization to Your Shop</em>, to create and compile translation files.</p>
<p class="normal">A management <a id="_idIndexMarker1671"/>command consists of a Python module containing a <code class="inlineCode">Command</code> class that inherits from <code class="inlineCode">django.core.management.base.BaseCommand</code> or one of its subclasses. You can create simple commands or make them take positional and optional arguments as input.</p>
<p class="normal">Django looks for management commands in the <code class="inlineCode">management/commands/</code> directory for each active application in the <code class="inlineCode">INSTALLED_APPS</code> setting. Each module found is registered as a management command named after it.</p>
<p class="normal">You can <a id="_idIndexMarker1672"/>learn more about custom management commands at <a href="https://docs.djangoproject.com/en/5.0/howto/custom-management-commands/">https://docs.djangoproject.com/en/5.0/howto/custom-management-commands/</a>.</p>
<p class="normal">You are going to create a custom management command to remind students to enroll in at least one course. The command will send an email reminder to users who have been registered for longer than a specified period and who aren’t enrolled in any course yet.</p>
<p class="normal">Create <a id="_idIndexMarker1673"/>the following file structure inside the <code class="inlineCode">students</code> application directory:</p>
<pre class="programlisting con"><code class="hljs-con">management/
    __init__.py
    commands/
        __init__.py
        enroll_reminder.py
</code></pre>
<p class="normal">Edit the <code class="inlineCode">enroll_reminder.py</code> file and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">import datetime
from django.conf import settings
from django.contrib.auth.models import User
from django.core.mail import send_mass_mail
from django.core.management.base import BaseCommand
from django.db.models import Count
from django.utils import timezone
class Command(BaseCommand):
    help = 'Sends an e-mail reminder to users registered more' \
           'than N days that are not enrolled into any courses yet'
def add_arguments(self, parser):
        parser.add_argument('--days', dest='days', type=int)
    def handle(self, *args, **options):
        emails = []
        subject = 'Enroll in a course'
        date_joined = timezone.now().today() - datetime.timedelta(
            days=options['days'] or 0
        )
        users = User.objects.annotate(
            course_count=Count('courses_joined')
        ).filter(course_count=0, date_joined__date__lte=date_joined)
        for user in users:
            message = f"""Dear {user.first_name},
            We noticed that you didn't enroll in any courses yet.
            What are you waiting for?"""
            emails.append(
                (
                    subject,
                    message,
                    settings.DEFAULT_FROM_EMAIL,
                    [user.email]
                )
            )
        send_mass_mail(emails)
        self.stdout.write(f'Sent {len(emails)} reminders')
</code></pre>
<p class="normal">This is <a id="_idIndexMarker1674"/>your <code class="inlineCode">enroll_reminder</code> command. The preceding code is as follows:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">Command</code> class inherits from <code class="inlineCode">BaseCommand</code>.</li>
<li class="bulletList">You include a <code class="inlineCode">help</code> attribute. This attribute provides a short description of the command that is printed if you run the <code class="inlineCode">python manage.py help enroll_reminder</code> command.</li>
<li class="bulletList">You use the <code class="inlineCode">add_arguments()</code> method to add the <code class="inlineCode">--days</code> named argument. This argument is used to specify the minimum number of days a user has to be registered, without having enrolled in any course, in order to receive the reminder.</li>
<li class="bulletList">The <code class="inlineCode">handle()</code> command contains the actual command. You get the <code class="inlineCode">days</code> attribute parsed from the command line. If this is not set, you use <code class="inlineCode">0</code>, so that a reminder is sent to all users that haven’t enrolled on a course, regardless of when they registered. You use the <code class="inlineCode">timezone</code> utility provided by Django to retrieve the current timezone-aware date with <code class="inlineCode">timezone.now().date()</code>. (You can set the timezone for your project with the <code class="inlineCode">TIME_ZONE</code> setting.) You retrieve the users who have been registered for more than the specified days and are not enrolled in any courses yet. You achieve this by annotating the QuerySet with the total number of courses each user is enrolled in. You generate the reminder email for each user and append it to the <code class="inlineCode">emails</code> list. Finally, you send the emails using the <code class="inlineCode">send_mass_mail()</code> function, which is optimized to open a single SMTP connection for sending all emails, instead of opening one connection per email sent.</li>
</ul>
<p class="normal">You have created your first management command. Open the shell and run your command:</p>
<pre class="programlisting con"><code class="hljs-con">docker compose exec web python /code/educa/manage.py \
  enroll_reminder --days=20 --settings=educa.settings.prod
</code></pre>
<p class="normal">If you don’t have a local SMTP server running, you can look at <em class="italic">Chapter 2</em>, <em class="italic">Enhancing Your Blog with Advanced Features</em>, where you configured the SMTP settings for your first Django project. Alternatively, you can add the following setting to the <code class="inlineCode">base.py</code> file to make <a id="_idIndexMarker1675"/>Django output emails to the standard output during development:</p>
<pre class="programlisting code"><code class="hljs-code">EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
</code></pre>
<p class="normal">Django also includes a utility to call management commands using Python. You can run management commands from your code as follows:</p>
<pre class="programlisting code"><code class="hljs-code">from django.core import management
management.call_command('enroll_reminder', days=20)
</code></pre>
<p class="normal">Congratulations! You can now create custom management commands for your applications.</p>
<p class="normal">Django management commands can be scheduled to run automatically using tools like cron or Celery Beat. Cron is a time-based job scheduler in Unix-like operating systems that enables users to schedule scripts or commands to run at specified times and intervals. You <a id="_idIndexMarker1676"/>can read more about cron at <a href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a>. On the other hand, Celery Beat is a scheduler that works <a id="_idIndexMarker1677"/>with Celery to run functions at designated intervals. You can learn more about Celery Beat at <a href="https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html">https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html</a>. By using either cron or Celery Beat, you can ensure your tasks are executed regularly without manual intervention.</p>
<h1 class="heading-1" id="_idParaDest-482">Summary</h1>
<p class="normal">In this chapter, you created a production environment using Docker Compose. You configured NGINX, uWSGI, and Daphne to serve your application in production. You secured your environment using SSL/TLS. You also implemented custom middleware and you learned how to create custom management commands.</p>
<p class="normal">You have reached the end of this book. Congratulations! You have learned the skills required to build successful web applications with Django. This book has guided you through the process of developing real-life projects and integrating Django with other technologies. Now, you are ready to create your own Django project, whether it is a simple prototype or a large-scale web application.</p>
<p class="normal">Good luck with your next Django adventure!</p>
<h1 class="heading-1" id="_idParaDest-483">Expanding your project using AI</h1>
<p class="normal">In this section, you are presented with a task to extend your project, accompanied by a sample prompt for ChatGPT to assist you. To engage with ChatGPT, visit <a href="https://chat.openai.com/">https://chat.openai.com/</a>. If this is your first interaction with ChatGPT, you can revisit the <em class="italic">Expanding your project using AI</em> section in <em class="italic">Chapter 3, Extending Your Blog Application</em>.</p>
<p class="normal">We have developed a comprehensive e-learning platform. However, when students are enrolled in multiple courses, each containing several modules, it can be challenging for them to remember where they last left off. To address this, let’s use ChatGPT in conjunction with Redis to store and retrieve each student’s progress within a course. For guidance, refer to the prompt provided at <a href="https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter17/prompts/task.md">https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter17/prompts/task.md</a>.</p>
<div><p class="normal"> When you’re refining your Python code, ChatGPT can help you explore different refactoring strategies. Discuss your current approach, and ChatGPT can provide advice on making your code more Pythonic, utilizing principles like <strong class="keyWord">don’t repeat yourself</strong> (<strong class="keyWord">DRY</strong>) and modular design for cleaner, more maintainable code.</p>
</div>
<h1 class="heading-1" id="_idParaDest-484">Additional resources</h1>
<p class="normal">The following resources provide additional information related to the topics covered in this chapter:</p>
<ul>
<li class="bulletList">Source code for this chapter: <a href="https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter17">https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter17</a></li>
<li class="bulletList">Docker Compose overview: <a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></li>
<li class="bulletList">Installing Docker Compose: <a href="https://docs.docker.com/compose/install/compose-desktop/">https://docs.docker.com/compose/install/compose-desktop/</a></li>
<li class="bulletList">Official Python Docker image: <a href="https://hub.docker.com/_/python">https://hub.docker.com/_/python</a></li>
<li class="bulletList">Dockerfile reference: <a href="https://docs.docker.com/reference/dockerfile/">https://docs.docker.com/reference/dockerfile/</a></li>
<li class="bulletList"><code class="inlineCode">requirements.txt</code> file for this chapter: <a href="https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter17/requirements.txt">https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter17/requirements.txt</a></li>
<li class="bulletList">YAML file example: <a href="https://yaml.org/">https://yaml.org/</a></li>
<li class="bulletList"><code class="inlineCode">Dockerfile build</code> section: <a href="https://docs.docker.com/compose/compose-file/build/">https://docs.docker.com/compose/compose-file/build/</a></li>
<li class="bulletList">Docker restart policy: <a href="https://docs.docker.com/config/containers/start-containers-automatically/">https://docs.docker.com/config/containers/start-containers-automatically/</a></li>
<li class="bulletList">Docker volumes: <a href="https://docs.docker.com/storage/volumes/">https://docs.docker.com/storage/volumes/</a></li>
<li class="bulletList">Docker Compose specification: <a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></li>
<li class="bulletList">Official PostgreSQL Docker image: <a href="https://hub.docker.com/_/postgres">https://hub.docker.com/_/postgres</a></li>
<li class="bulletList"><code class="inlineCode">wait-for-it.sh</code> bash script for Docker: <a href="https://github.com/vishnubob/wait-for-it/blob/master/wait-for-it.sh">https://github.com/vishnubob/wait-for-it/blob/master/wait-for-it.sh</a></li>
<li class="bulletList">Service startup order in Compose: <a href="https://docs.docker.com/compose/startup-order/">https://docs.docker.com/compose/startup-order/</a></li>
<li class="bulletList">Official Redis Docker image: <a href="https://hub.docker.com/_/redis">https://hub.docker.com/_/redis</a></li>
<li class="bulletList">WSGI documentation: <a href="https://wsgi.readthedocs.io/en/latest/">https://wsgi.readthedocs.io/en/latest/</a></li>
<li class="bulletList">List of uWSGI options: <a href="https://uwsgi-docs.readthedocs.io/en/latest/Options.html">https://uwsgi-docs.readthedocs.io/en/latest/Options.html</a></li>
<li class="bulletList">Official NGINX Docker image: <a href="https://hub.docker.com/_/nginx">https://hub.docker.com/_/nginx</a></li>
<li class="bulletList">NGINX documentation: <a href="https://nginx.org/en/docs/">https://nginx.org/en/docs/</a></li>
<li class="bulletList"><code class="inlineCode">ALLOWED_HOSTS</code> setting: <a href="https://docs.djangoproject.com/en/5.0/ref/settings/#allowed-hosts">https://docs.djangoproject.com/en/5.0/ref/settings/#allowed-hosts</a></li>
<li class="bulletList">Django’s system check framework: <a href="https://docs.djangoproject.com/en/5.0/topics/checks/">https://docs.djangoproject.com/en/5.0/topics/checks/</a></li>
<li class="bulletList">HTTP Strict Transport Security policy with Django: <a href="https://docs.djangoproject.com/en/5.0/ref/middleware/#http-strict-transport-security">https://docs.djangoproject.com/en/5.0/ref/middleware/#http-strict-transport-security</a></li>
<li class="bulletList">Django deployment checklist: <a href="https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/">https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/</a></li>
<li class="bulletList">Self-generated SSL/TLS certificate directory: <a href="https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter17/educa/ssl/">https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter17/educa/ssl/</a></li>
<li class="bulletList">Let’s Encrypt Certificate Authority: <a href="https://letsencrypt.org/">https://letsencrypt.org/</a></li>
<li class="bulletList">Using Docker Compose in production: <a href="https://docs.docker.com/compose/production/">https://docs.docker.com/compose/production/</a></li>
<li class="bulletList">Docker Swarm mode: <a href="https://docs.docker.com/engine/swarm/ ">https://docs.docker.com/engine/swarm/</a></li>
<li class="bulletList">Kubernetes: <a href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a></li>
<li class="bulletList">Django middleware: <a href="https://docs.djangoproject.com/en/5.0/topics/http/middleware/">https://docs.djangoproject.com/en/5.0/topics/http/middleware/</a></li>
<li class="bulletList">Creating custom management commands: <a href="https://docs.djangoproject.com/en/5.0/howto/custom-management-commands/">https://docs.djangoproject.com/en/5.0/howto/custom-management-commands/</a></li>
<li class="bulletList"><code class="inlineCode">cron</code>: <a href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a>.</li>
<li class="bulletList"><code class="inlineCode">celery beat</code>: <a href="https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html">https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html</a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-485">Join us on Discord!</h1>
<p class="normal">Read this book alongside other users, Django development experts, and the author himself. Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more.Scan the QR code or visit the link to join the community.</p>
<p class="normal"><a href="https://packt.link/Django5ByExample">https://packt.link/Django5ByExample</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code287089408934129031.png"/></p>
</div>
</body></html>