["```py\n$  pip install –r requirements.txt\n```", "```py\n$ pip install fastapi uvicorn pytest\n```", "```py\n    from fastapi import FastAPI\n    app = FastAPI()\n    ```", "```py\n    from fastapi import HTTPException\n    def check_start_end_condition(start: date, end: date):\n        if end and end < start:\n            raise HTTPException(\n                status_code=400,\n                detail=(\n                    \"End date must be \"\n                    \"greater than start date\"\n                ),\n            )\n    ```", "```py\n    from datetime import date, timedelta\n    from fastapi import Query\n    def time_range(\n        start: date | None = Query(\n            default=date.today(),\n            description=(\n                \"If not provided the current date is used\"\n            ),\n            example=date.today().isoformat(),\n        ),\n        end: date | None = Query(\n            None,\n            example=date.today() + timedelta(days=7),\n        ),\n    ) -> Tuple[date, date | None]:\n        check_start_end_condition(start, end)\n        return start, end\n    ```", "```py\n    from fastapi import Depends\n    @app.get(\"/v1/trips\")\n    def get_tours(\n        time_range = Depends(time_range),\n    ):\n        start, end = time_range\n        message = f\"Request trips from {start}\"\n        if end:\n            return f\"{message} to {end}\"\n        return message\n    ```", "```py\n    from typing import Annotated\n    from fastapi import Depends\n    @app.get(\"/v1/trips\")\n    def get_tours(\n        time_range: Annotated[time_range, Depends()]\n    ):\n    ```", "```py\n[pytest]\npythonpath=.\n```", "```py\nfrom datetime import date\nfrom fastapi.testclient import TestClient\nfrom app.dependencies import time_range\nfrom app.main import app\ndef test_get_v1_trips_endpoint():\n    client = TestClient(app)\n    app.dependency_overrides[time_range] = lambda: (\n        date.fromisoformat(\"2024-02-01\"),\n        None,\n)\n    response = client.get(\"/v1/trips\")\n    assert (\n        response.json()\n        == \"Request trips from 2024-02-01\"\n    )\n```", "```py\n$ pytest tests\n```", "```py\ndef select_category(\n    category: Annotated[\n        str,\n        Path(\n            description=(\n                \"Kind of travel \"\n                \"you are interested in\"\n            ),\n            enum=[\n                \"Cruises\",\n                \"City Breaks\",\n                \"Resort Stay\",\n            ],\n        ),\n    ],\n) -> str:\n    return category\n```", "```py\ndef check_coupon_validity(\n    category: Annotated[select_category, Depends()],\n    code: str | None = Query(\n        None, description=\"Coupon code\"\n    ),\n) -> bool:\n    coupon_dict = {\n        \"cruises\": \"CRUISE10\",\n        \"city-breaks\": \"CITYBREAK15\",\n        \"resort-stays\": \"RESORT20\",\n    }\n    if (\n        code is not None\n        and coupon_dict.get(category, ...) == code\n    ):\n        return True\n    return False\n```", "```py\n@app.get(\"/v2/trips/{category}\")\ndef get_trips_by_category(\n    category: Annotated[select_category, Depends()],\n    discount_applicable: Annotated[\n        bool, Depends(check_coupon_validity)\n    ],\n):\n    category = category.replace(\"-\", \" \").title()\n    message = f\"You requested {category} trips.\"\n    if discount_applicable:\n        message += (\n            \"\\n. The coupon code is valid! \"\n            \"You will get a discount!\"\n        )\n    return message\n```", "```py\n    import logging\n    logger = logging.getLogger(\"uvicorn.error\")\n    ```", "```py\n    from fastapi import Request\n    from starlette.middleware.base import BaseHTTPMiddleware\n    class ClientInfoMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self, request: Request, call_next\n        ):\n            host_client = request.client.host\n            requested_path = request.url.path\n            method = request.method\n            logger.info(\n                f\"host client {host_client} \"\n                f\"requested {method} {requested_path} \"\n                \"endpoint\"\n            )\n            return await call_next(request)\n    ```", "```py\n    # main.py import modules\n    from app.middleware import ClientInfoMiddleware\n    app = FastAPI()\n    app.add_middleware(ClientInfoMiddleware)\n    # rest of the code\n    ```", "```py\nINFO:host client 127.0.0.1 requested GET /v1/trips endpoint\n```", "```py\n$ pip install babel\n```", "```py\nAccept-Language: en\nAccept-Language: en, fr\nAccept-Language: en-US\nAccept-Language: en-US;q=0.8, fr;q=0.5\nAccept-Language: en, *\nAccept-Language: en-US, en-GB\nAccept-Language: zh-Hans-CN\n```", "```py\n    SUPPORTED_LOCALES = [\n        \"en_US\",\n        \"fr_FR\",\n    ]\n    ```", "```py\n    from babel import Locale, negotiate_locale\n    def resolve_accept_language(\n        accept_language: str = Header(\"en-US\"),\n    ) -> Locale:\n    ```", "```py\n        client_locales = []\n        for language_q in accept_language.split(\",\"):\n            if \";q=\" in language_q:\n                language, q = language_q.split(\";q=\")\n            else:\n                language, q = (language_q, float(\"inf\"))\n            try:\n                Locale.parse(language, sep=\"-\")\n                client_locales.append(\n                    (language, float(q))\n                )\n            except ValueError:\n                continue\n    ```", "```py\n        client_locales.sort(\n            key=lambda x: x[1], reverse=True\n        )\n        locales = [locale for locale, _ in client_locales]\n    ```", "```py\n        locale = negotiate_locale(\n            [str(locale) for locale in locales],\n            SUPPORTED_LOCALES,\n        )\n    ```", "```py\n        if locale is None:\n            locale = \"en_US\"\n        return locale\n    ```", "```py\n    from fastapi import APIRouter\n    router = APIRouter(\n        tags=[\"Localizad Content Endpoints\"]\n    )\n    ```", "```py\n    home_page_content = {\n        \"en_US\": \"Welcome to Trip Platform\",\n        \"fr_FR\": \"Bienvenue sur Trip Platform\",\n    }\n    @router.get(\"/homepage\")\n    async def home(\n        request: Request,\n        language: Annotated[\n            resolve_accept_language, Depends()\n        ],\n    ):\n        return {\"message\": home_page_content[language]}\n    ```", "```py\n    async def get_currency(\n        language: Annotated[\n            resolve_accept_language, Depends()\n        ],\n    ):\n        currencies = {\n            \"en_US\": \"USD\",\n            \"fr_FR\": \"EUR\",\n        }\n        return currencies[language]\n    ```", "```py\n    from babel.numbers import get_currency_name\n    @router.get(\"/show/currency\")\n    async def show_currency(\n        currency: Annotated[get_currency, Depends()],\n        language: Annotated[\n            resolve_accept_language,\n            Depends(use_cache=True)\n        ],\n    ):\n        currency_name = get_currency_name(\n            currency, locale=language\n        )\n        return {\n            \"currency\": currency,\n            \"currency_name\": currency_name,\n        }\n    ```", "```py\n    from app import internationalization\n    # rest of the code\n    app.include_router(internationalization.router)\n    ```", "```py\nhttp:localhost:8000/docs, you will find the GET /homepage and GET /show/currency endpoints. Both accept the Accept-Language header to provide the language choice; if you don’t, it will get the default language from the browser. To test the implementation, try experimenting with different values for the header.\nYou have successfully implemented internationalization and localization from scratch for your API. Using the recipe provided, you have integrated i18n and l10n into your applications, making them easily understandable worldwide.\nSee also\nYou can find out more about the potential of `Babel` package on the official documentation page: [https://babel.pocoo.org/en/latest/](https://babel.pocoo.org/en/latest/).\nOptimizing application performance\nOptimizing FastAPI applications is crucial for ensuring high performance and scalability, especially under heavy loads.\nIn this recipe, we’ll see a technique to profile our FastAPI application and explore actionable strategies to optimize performances. By the end of the recipe, you will be able to detect code bottlenecks and optimize your application.\nGetting ready\nBefore starting the recipe, make sure to have a FastAPI application running with some endpoints already set up. You can follow along with our trip platform application.\nWe will be using the `pyinstrument` package to set up a profiler for the application. If you haven’t installed the packages with `requirements.txt`, you can install `pyinstrument` in your environment by running the following:\n\n```", "```py\n\n Also, it can be useful to have a look at the *Creating* *custom middleware* recipe from earlier in the chapter.\nHow to do it…\nLet's implement the profiler in simple steps.\n\n1.  Under the app folder, create a `profiler.py` module as follows:\n\n    ```", "```py\n\n    The `async_mode=\"enabled\"` parameter specifies that the profiler logs the time each time it encounters an `await` statement in the function being awaited, rather than observing other coroutines or the event loop. The `interval` specifies the time between two samples.\n\n     2.  Before using the profiler, we should plan what we want to profile. Let’s plan to profile only the code executed in the endpoints. To do this, we can create simple middleware in a separate module that starts and stops the profiler before and after each call, respectively. We can create the middleware in the same `profiler.py` module, as follows:\n\n    ```", "```py\n\n    The profiler is initiated every time an endpoint is requested, and it is terminated after the request is complete. However, since the server operates asynchronously, there is a possibility that the profiler may already be running, due to another endpoint request. This can result in errors during the start and stop of the profiler. To prevent this, we verify before each request whether the profiler is not already running. After the request, we check whether the profiler is running before terminating it.\n\n     3.  You can attach the profiler to the FastAPI server by adding the middleware in the `main.py` module, as we did in the *Creating custom* *middleware* recipe:\n\n    ```", "```py\n\nTo test the profiler, spin up the server by running `uvicorn app.main:app`. Once you start making some calls, you can do it from the interactive documentation at http://localhost:8000/docs. Then, a `profiler.xhtml` file will be created. You can open the file with a simple browser and check the status of the code.\nYou have just integrated a profiler into your FastAPI application.\nThere’s more...\nIntegrating a profiler is the first step that allows you to spot code bottlenecks and optimize the performance of your application.\nLet’s explore some techniques to optimize the performance of your FastAPI performances:\n\n*   `Starlette` library and supports asynchronous request handlers, using the `async` and `await` keywords. By leveraging asynchronous programming, you can maximize CPU and **input/output** (**I/O**) utilization, reducing response times and improving scalability.\n*   **Scaling Uvicorn workers**: Increasing the number of Uvicorn workers distributes incoming requests across multiple processes. However, it might not be always the best solution. For purely I/O operations, asynchronous programming massively reduces CPU usage, and additional workers remain idle. Before adding additional workers, check the CPU usage of the main process.\n*   **Caching**: Implement caching mechanisms to store and reuse frequently accessed data, reducing database queries and computation overhead. Use dedicated libraries l to integrate caching into your FastAPI applications.\n\nOther techniques are related to external libraries or tools, and whatever strategy you use, make sure to properly validate it with proper profiling configuration.\nAlso, for high-traffic testing, take a look at the *Performance testing for high traffic applications* recipe in [*Chapter 5*](B21025_05.xhtml#_idTextAnchor157), *Testing and Debugging* *FastAPI Applications*.\nExercise\nWe learned how to configure middleware to profile applications; however, it is more common to create tests to profile specific use cases. We learned how to configure middleware to profile applications; however, it is more common to create test scripts to profile specific use cases. Try to create one by yourself that attaches the profiler to the server, runs the server, makes API calls that reproduce the use case, and finally, writes the profiler output. The solution is provided on the GitHub repository in the `profiling_application.py` file. You can find it at [https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter08/trip_platform/profiling_application.py](https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter08/trip_platform/profiling_application.py).\nSee also\nYou can discover more about the potential of **pyinstrument** profiler on the official documentation:\n\n*   *pyinstrument* *documentation*: [https://pyinstrument.readthedocs.io/en/latest/](https://pyinstrument.readthedocs.io/en/latest/)\n\nAlso, you can find a different approach to profile FastAPI endpoints on the page:\n\n*   *pyinstrument – profiling FastAPI* *requests*: [https://pyinstrument.readthedocs.io/en/latest/guide.xhtml#profile-a-web-request-in-fastapi](https://pyinstrument.readthedocs.io/en/latest/guide.xhtml#profile-a-web-request-in-fastapi)\n\nImplementing rate limiting\n**Rate limiting** is an essential technique used to control and manage the flow of traffic to web applications, ensuring optimal performance, resource utilization, and protection against abuse or overload. In this recipe, we’ll explore how to implement rate limiting in FastAPI applications to safeguard against potential abuse, mitigate security risks, and optimize application responsiveness. By the end of this recipe, you’ll have a solid understanding of how to leverage rate limiting to enhance the security, reliability, and scalability of your FastAPI applications, ensuring optimal performance under varying traffic conditions and usage patterns.\nGetting ready\nTo follow the recipe, you need a running FastAPI application with some endpoints to use for rate limiting. To implement rate limiting, we will use the `slowapi` package; if you haven’t installed the packages with the `requirements.txt` file provided in the GitHub repository, you can install `slowapi` in your environment with `pip` by running the following:\n\n```", "```py\n\n Once the installation is completed, you are ready to start the recipe.\nHow to do it…\nWe will start by applying a rate limiter to a single endpoint in simple steps.\n\n1.  Let’s create the `rate_limiter.py` module under the `app` folder that contains our limiter object class defined as follows:\n\n    ```", "```py\n\n    The limiter is designed to restrict the number of requests from a client based on their IP address. It is possible to create a function that can detect a user’s credentials and limit their calls according to their specific user profile. However, for the purpose of this example, we will use the client’s IP address to implement the limiter.\n\n     2.  Now, we need to configure the FastAPI server to implement the limiter. In `main.py`, we have to add the following configuration:\n\n    ```", "```py\n\n     3.  Now, we will apply a rate limit of two requests per minute to the `GET /homepage` endpoint defined in the `internalization.py` module:\n\n    ```", "```py\n\n    The rate limit is applied as a decorator. Also, the request parameter needs to be added to make the limiter work.\n\nNow, spin up the server from the command line by running the following:\n\n```", "```py\n{\n    \"error\": \"Rate limit exceeded: 2 per 1 minute\"\n}\n```", "```py\n# rest of the code in main.py\nfrom slowapi.middleware import SlowAPIMiddleware\n# rest of the code\napp.add_exception_handler(\n    RateLimitExceeded, _rate_limit_exceeded_handler\n)\napp.add_middleware(SlowAPIMiddleware)\n```", "```py\nlimiter = Limiter(\n    key_func=get_remote_address,\ndefault_limits=[\"5/minute\"],\n)\n```", "```py\n    import asyncio\n    import logging\n    logger = logging.getLogger(\"uvicorn.error\")\n    async def store_query_to_external_db(message: str):\n        logger.info(f\"Storing message '{message}'.\")\n        await asyncio.sleep(2)\n        logger.info(f\"Message '{message}' stored!\")\n    ```", "```py\n    from fastapi import BackgroundTasks\n    @app.get(\"/v2/trips/{category}\")\n    def get_trips_by_category(\n        background_tasks: BackgroundTasks,\n        category: Annotated[select_category, Depends()],\n        discount_applicable: Annotated[\n            bool, Depends(check_coupon_validity)\n        ],\n    ):\n        category = category.replace(\"-\", \" \").title()\n        message = f\"You requested {category} trips.\"\n        if discount_applicable:\n            message += (\n                \"\\n. The coupon code is valid! \"\n                \"You will get a discount!\"\n            )\n        background_tasks.add_task(\n            store_query_to_external_db, message\n        )\n        logger.info(\n            \"Query sent to background task, \"\n            \"end of request.\"\n        )\n        return message\n    ```", "```py\nINFO:  Query sent to background task, end of request.\nINFO:  127.0.0.1:58544 - \"GET /v2/trips/cruises\nINFO:  Storing message 'You requested Cruises trips.'\nINFO:  Message 'You requested Cruises trips.' Stored!\n```", "```py\n\n```"]