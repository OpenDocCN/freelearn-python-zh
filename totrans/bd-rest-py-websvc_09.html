<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0; Developing RESTful APIs with Tornado"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9.  Developing RESTful APIs with Tornado </h1></div></div></div><p>In this chapter, we will work with Tornado to create a RESTful Web API and start working with this lightweight Web framework. We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing a RESTful API to interact with slow sensors and actuators</li><li class="listitem" style="list-style-type: disc">Understanding the tasks performed by each <code class="literal">HTTP</code> method</li><li class="listitem" style="list-style-type: disc">Setting up a virtual environment with Tornado</li><li class="listitem" style="list-style-type: disc">Declaring status codes for the responses</li><li class="listitem" style="list-style-type: disc">Creating the classes that represent a drone</li><li class="listitem" style="list-style-type: disc">Writing request handlers</li><li class="listitem" style="list-style-type: disc">Mapping URL patterns to request handlers</li><li class="listitem" style="list-style-type: disc">Making HTTP requests to the Tornado API</li><li class="listitem" style="list-style-type: disc">Working with command-line tools - curl and HTTPie</li><li class="listitem" style="list-style-type: disc">Working with GUI tools - Postman and others</li></ul></div><div class="section" title="Designing a RESTful API to interact with slow sensors and actuators"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec102"/>Designing a RESTful API to interact with slow sensors and actuators</h1></div></div></div><p>Imagine that we have to create a RESTful API to control a drone, also known as an <span class="strong"><strong>Unmanned Aerial Vehicle</strong></span> (<span class="strong"><strong>UAV</strong></span>). The drone is an IoT device that interacts with many sensors and actuators, including digital electronic speed controllers linked to engines, propellers, and servomotors.</p><p>The IoT device has limited resources, and therefore, we have to use a lightweight Web framework. Our API doesn't need to interact with a database. We don't need a heavyweight Web framework like Django, and we want to be able to process many requests without blocking the Web server. We need the Web server to provide us with good scalability while consuming limited resources. Thus, our choice is to use Tornado, the open source version of FriendFeed's Web server.</p><p>The IoT device is capable of running Python 3.5, Tornado, and other Python packages. Tornado is a Python Web framework and an asynchronous networking library that provides excellent scalability due to its non-blocking network I/O. In addition, Tornado will allow us to easily and quickly build a lightweight RESTful API.</p><p>We have chosen Tornado because it is more lightweight than Django and it makes it easy for us to create an API that takes advantage of the non-blocking network I/O. We don't need to use an ORM, and we want to start running the RESTful API on the IoT device as soon as possible to allow all the teams to interact with it.</p><p>We will interact with a library that allows us to run the slow I/O operations that interact with the sensors and actuators with an execution that happens outside the <span class="strong"><strong>Global Interpreter Lock</strong></span> (<span class="strong"><strong>GIL</strong></span>). Thus, we will be able to take advantage of the non-blocking feature in Tornado when a request needs to execute any of these slow I/O operations. In our first version of the API, we will work with a synchronous execution, and therefore, when an HTTP request to our API requires running a slow I/O operation, we will block the request processing queue until the slow I/O operation with either a sensor or an actuator provides a response. We will execute the I/O operation with a synchronous execution and Tornado won't be able to continue processing other incoming HTTP requests until a response is sent to the HTTP request.</p><p>Then, we will create a second version of our API that will take advantage of the non-blocking features included in Tornado, in combination with asynchronous operations. In the second version, when an HTTP request to our API requires running a slow I/O operation, we won't block the request processing queue until the slow I/O operation with either a sensor or an actuator provides a response. We will execute the I/O operation with an asynchronous execution, and Tornado will be able to continue processing other incoming HTTP requests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip63"/>Tip</h3><p>We will keep our example simple and we won't use a library to interact with sensors and actuators. We will just print information about the operations that will be performed by these sensors and actuators. However, in our second version of the API, we will write our code to make asynchronous calls in order to understand the advantages of the non-blocking features in Tornado. We will use a simplified set of sensors and actuators—bear in mind that drones usually have more sensors and actuators. Our goal is to learn how to work with Tornado to build a RESTful API; we don't want to become experts in building drones.</p></div></div><p>Each of the following sensors and actuators will be a resource in our RESTful API:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A hexacopter, that is, a 6-rotor helicopter</li><li class="listitem" style="list-style-type: disc">An altimeter (altitude sensor)</li><li class="listitem" style="list-style-type: disc">A blue <span class="strong"><strong>LED</strong></span> (<span class="strong"><strong>Light-Emitting Diode</strong></span>)</li><li class="listitem" style="list-style-type: disc">A white LED</li></ul></div><p>The following table shows the HTTP verbs, the scope, and the semantics for the methods that our first version of the API must support. Each method is composed by an HTTP verb and a scope and all the methods have a well-defined meaning for all sensors and actuators. In our API, each sensor or actuator has its own unique URL:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<span class="strong"><strong>HTTP verb</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Scope</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Semantics</strong></span>
</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Hexacopter</p>
</td><td>
<p>Retrieve the current hexacopter's motor speed in RPMs and its status (turned on or off)</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Hexacopter</p>
</td><td>
<p>Set the current hexacopter's motor speed in RPMs</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>LED</p>
</td><td>
<p>Retrieve the brightness level for a single LED</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>LED</p>
</td><td>
<p>Update the brightness level for a single LED</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Altimeter</p>
</td><td>
<p>Retrieve the current altitude in feet</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Understanding the tasks performed by each HTTP method"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec103"/>Understanding the tasks performed by each HTTP method</h1></div></div></div><p>Let's consider that <code class="literal">http://localhost:8888/hexacopters/1</code> is the URL that identifies the hexacopter for our drone.</p><p>We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">PATCH</code>) and request URL (<code class="literal">http://localhost:8888/hexacopters/1</code>) to set the hexacopter's motor speed in RPMs and its status. In addition, we have to provide the JSON key-value pairs with the necessary field name and the value to specify the desired speed. As a result of the request, the server will validate the provided values for the field, make sure that it is a valid speed and make the necessary calls to adjust the speed with an asynchronous execution. After the speed for the hexacopter is set, the server will return a <code class="literal">200 OK</code> status code and a JSON body with the recently updated hexacopter values serialized to JSON:</p><pre class="programlisting">PATCH http://localhost:8888/hexacopters/1 
</pre><p>We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">GET</code>) and request URL (<code class="literal">http://localhost:8888/hexacopter/1</code>) to retrieve the current values for the hexacopter. The server will make the necessary calls to retrieve the status and the speed for the hexacopter with an asynchronous execution. As a result of the request, the server will return a <code class="literal">200 OK</code> status code and a JSON body with the serialized key-value pairs that specify the status and speed for the hexacopter. If a number different than 1 is specified, the server will return just a <code class="literal">404 Not Found</code> status:</p><pre class="programlisting">GET http://localhost:8888/hexacopters/1 
</pre><p>We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">PATCH</code>) and request URL (<code class="literal">http://localhost:8888/led/{id}</code>) to set the brightness level for a specific LED whose id matches the specified numeric value in the place where <code class="literal">{id}</code> is written. For example, if we use the request URL <code class="literal">http://localhost:8888/led/1</code>, the server will set the brightness level for the led whose id matches 1. In addition, we have to provide the JSON key-value pairs with the necessary field name and the value to specify the desired brightness level. As a result of the request, the server will validate the provided values for the field, make sure that it is a valid brightness level and make the necessary calls to adjust the brightness level with an asynchronous execution. After the brightness level for the LED is set, the server will return a <code class="literal">200 OK</code> status code and a JSON body with the recently updated LED values serialized to JSON:</p><pre class="programlisting">PATCH http://localhost:8888/led/{id} 
</pre><p>We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">GET</code>) and request URL (<code class="literal">http://localhost:8888/led/{id}</code>) to retrieve the current values for the LED whose id matches the specified numeric value in the place where <code class="literal">{id}</code> is written. For example, if we use the request URL <code class="literal">http://localhost:8888/led/1</code>, the server will retrieve the LED whose id matches 1. The server will make the necessary calls to retrieve the values for the LED with an asynchronous execution. As a result of the request, the server will return a <code class="literal">200 OK</code> status code and a JSON body with the serialized key-value pairs that specify the values for the LED. If no LED matches the specified id, the server will return just a <code class="literal">404 Not Found</code> status:</p><pre class="programlisting">GET http://localhost:8888/led/{id} 
</pre><p>We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">GET</code>) and request URL (<code class="literal">http://localhost:8888/altimeter/1</code>) to retrieve the current values for the altimeter. The server will make the necessary calls to retrieve the values for the altimeter with an asynchronous execution. As a result of the request, the server will return a <code class="literal">200 OK</code> status code and a JSON body with the serialized key-value pairs that specify the values for the altimeter. If a number different than 1 is specified, the server will return just a <code class="literal">404 Not Found</code> status:</p><pre class="programlisting">GET http://localhost:8888/altimeter/1 
</pre></div>
<div class="section" title="Setting up a virtual environment with Tornado"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec104"/>Setting up a virtual environment with Tornado</h1></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>, <span class="emphasis"><em>Developing RESTful APIs with Django</em></span>, we learned that, throughout this book, we were going to work with the lightweight virtual environments introduced in Python 3.3 and improved in Python 3.4. Now, we will follow many steps create a new lightweight virtual environment to work with Tornado. It is highly recommended to read <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>, <span class="emphasis"><em>Developing RESTful APIs with Django</em></span>, in case you don't have experience with lightweight virtual environments in Python. The chapter includes all the detailed explanations about the effects of the steps we are going to follow.</p><p>First, we have to select the target folder or directory for our virtual environment. The following is the path we will use in the example for macOS and Linux. The target folder for the virtual environment will be the <code class="literal">PythonREST/Tornado01</code> folder within our home directory. For example, if our home directory in macOS or Linux is <code class="literal">/Users/gaston</code>, the virtual environment will be created within <code class="literal">/Users/gaston/PythonREST/Tornado01</code>. You can replace the specified path with your desired path in each command:</p><pre class="programlisting">
<span class="strong"><strong>~/PythonREST/Tornado01</strong></span>
</pre><p>We will use the following path in the example for Windows. The target folder for the virtual environment will be the <code class="literal">PythonREST\Tornado01</code> folder within our user profile folder. For example, if our user profile folder is <code class="literal">C:\Users\Gaston</code>, the virtual environment will be created within <code class="literal">C:\Users\gaston\PythonREST\Tornado01</code>. You can replace the specified path with your desired path in each command:</p><pre class="programlisting">
<span class="strong"><strong>%USERPROFILE%\PythonREST\Tornado01</strong></span>
</pre><p>Open a Terminal in macOS or Linux and execute the following command to create a virtual environment:</p><pre class="programlisting">
<span class="strong"><strong>python3 -m venv ~/PythonREST/Tornado01</strong></span>
</pre><p>In Windows, execute the following command to create a virtual environment:</p><pre class="programlisting">
<span class="strong"><strong>python -m venv %USERPROFILE%\PythonREST\Tornado01</strong></span>
</pre><p>The preceding command doesn't produce any output. Now that we have created a virtual environment, we will run a platform-specific script to activate it. After we activate the virtual environment, we will install packages that will only be available in this virtual environment.</p><p>If your Terminal is configured to use the <code class="literal">bash</code> shell in macOS or Linux, run the following command to activate the virtual environment. The command also works for the <code class="literal">zsh</code> shell:</p><pre class="programlisting">
<span class="strong"><strong>source ~/PythonREST/Torando01/bin/activate</strong></span>
</pre><p>If your Terminal is configured to use either the <code class="literal">csh</code> or <code class="literal">tcsh</code> shell, run the following command to activate the virtual environment:</p><pre class="programlisting">
<span class="strong"><strong>source ~/PythonREST/Torando01/bin/activate.csh</strong></span>
</pre><p>If your Terminal is configured to use either the <code class="literal">fish</code> shell, run the following command to activate the virtual environment:</p><pre class="programlisting">
<span class="strong"><strong>source ~/PythonREST/Tornado01/bin/activate.fish</strong></span>
</pre><p>In Windows, you can run either a batch file in the Command Prompt or a Windows PowerShell script to activate the virtual environment. If you prefer the command prompt, run the following command in the Windows command line to activate the virtual environment:</p><pre class="programlisting">
<span class="strong"><strong>%USERPROFILE%\PythonREST\Tornado01\Scripts\activate.bat</strong></span>
</pre><p>If you prefer the Windows PowerShell, launch it and run the following commands to activate the virtual environment. However, notice that you should have scripts execution enabled in Windows PowerShell to be able to run the script:</p><pre class="programlisting">
<span class="strong"><strong>cd $env:USERPROFILE</strong></span>
<span class="strong"><strong>PythonREST\Tornado01\Scripts\Activate.ps1</strong></span>
</pre><p>After you activate the virtual environment, the Command Prompt will display the virtual environment root folder name enclosed in parentheses as a prefix of the default prompt to remind us that we are working in the virtual environment. In this case, we will see (<code class="literal">Tornado01</code>) as a prefix for the Command Prompt because the root folder for the activated virtual environment is <code class="literal">Tornado01</code>.</p><p>We have created and activated a virtual environment. It is time to run many commands that will be the same for either macOS, Linux, or Windows. Now, we must run the following command to install Tornado with pip:</p><pre class="programlisting">
<span class="strong"><strong>pip install tornado</strong></span>
</pre><p>The last lines for the output will indicate all the packages that have been successfully installed, including <code class="literal">tornado</code>:</p><pre class="programlisting">
<span class="strong"><strong>Collecting tornado</strong></span>
<span class="strong"><strong>  Downloading tornado-4.4.1.tar.gz (456kB)</strong></span>
<span class="strong"><strong>Installing collected packages: tornado</strong></span>
<span class="strong"><strong>  Running setup.py install for tornado</strong></span>
<span class="strong"><strong>Successfully installed tornado-4.4.1</strong></span>
</pre></div>
<div class="section" title="Declaring status codes for the responses"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec105"/>Declaring status codes for the responses</h1></div></div></div><p>Tornado allows us to generate responses with any status code that is included in the <code class="literal">http.HTTPStatus</code> dictionary. We might use this dictionary to return easy to understand descriptions as the status codes, such as <code class="literal">HTTPStatus.OK</code> and <code class="literal">HTTPStatus.NOT_FOUND</code> after importing the <code class="literal">HTTPStatus</code> dictionary from the <code class="literal">http</code> module. These names are easy to understand but they don't include the status code number in their description.</p><p>We have been working with many different frameworks and micro-frameworks throughout the book, and therefore, we will borrow the code that declares very useful functions and variables related to HTTP status codes from the <code class="literal">status.py</code> file included in Django REST Framework, that is, the framework we have been using in the first chapters. The main advantage of using these variables for the HTTP status codes is that their names include both the number and the description. When we read the code, we will understand the status code number and their meaning. For example, instead of using <code class="literal">HTTPStatus.OK</code>, we will use <code class="literal">status.HTTP_200_OK</code>.</p><p>Create a new <code class="literal">status.py</code> file within the root folder for the recently created virtual environment. The following lines show the code that declares functions and variables with descriptive HTTP status codes in the <code class="literal">status.py</code> file, borrowed from the <code class="literal">rest_framework.status</code> module. We don't want to reinvent the wheel and the module provides everything we need to work with HTTP status codes in our Tornado-based API. The code file for the sample is included in the <code class="literal">restful_python_chapter_09_01</code> folder:</p><pre class="programlisting">def is_informational(code): 
    return code &gt;= 100 and code &lt;= 199 
 
 
def is_success(code): 
    return code &gt;= 200 and code &lt;= 299 
 
 
def is_redirect(code): 
    return code &gt;= 300 and code &lt;= 399 
 
 
def is_client_error(code): 
    return code &gt;= 400 and code &lt;= 499 
 
 
def is_server_error(code): 
    return code &gt;= 500 and code &lt;= 599 
 
 
HTTP_100_CONTINUE = 100 
HTTP_101_SWITCHING_PROTOCOLS = 101 
HTTP_200_OK = 200 
HTTP_201_CREATED = 201 
HTTP_202_ACCEPTED = 202 
HTTP_203_NON_AUTHORITATIVE_INFORMATION = 203 
HTTP_204_NO_CONTENT = 204 
HTTP_205_RESET_CONTENT = 205 
HTTP_206_PARTIAL_CONTENT = 206 
HTTP_300_MULTIPLE_CHOICES = 300 
HTTP_301_MOVED_PERMANENTLY = 301 
HTTP_302_FOUND = 302 
HTTP_303_SEE_OTHER = 303 
HTTP_304_NOT_MODIFIED = 304 
HTTP_305_USE_PROXY = 305 
HTTP_306_RESERVED = 306 
HTTP_307_TEMPORARY_REDIRECT = 307 
HTTP_400_BAD_REQUEST = 400 
HTTP_401_UNAUTHORIZED = 401 
HTTP_402_PAYMENT_REQUIRED = 402 
HTTP_403_FORBIDDEN = 403 
HTTP_404_NOT_FOUND = 404 
HTTP_405_METHOD_NOT_ALLOWED = 405 
HTTP_406_NOT_ACCEPTABLE = 406 
HTTP_407_PROXY_AUTHENTICATION_REQUIRED = 407 
HTTP_408_REQUEST_TIMEOUT = 408 
HTTP_409_CONFLICT = 409 
HTTP_410_GONE = 410 
HTTP_411_LENGTH_REQUIRED = 411 
HTTP_412_PRECONDITION_FAILED = 412 
HTTP_413_REQUEST_ENTITY_TOO_LARGE = 413 
HTTP_414_REQUEST_URI_TOO_LONG = 414 
HTTP_415_UNSUPPORTED_MEDIA_TYPE = 415 
HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE = 416 
HTTP_417_EXPECTATION_FAILED = 417 
HTTP_428_PRECONDITION_REQUIRED = 428 
HTTP_429_TOO_MANY_REQUESTS = 429 
HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE = 431 
HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS = 451 
HTTP_500_INTERNAL_SERVER_ERROR = 500 
HTTP_501_NOT_IMPLEMENTED = 501 
HTTP_502_BAD_GATEWAY = 502 
HTTP_503_SERVICE_UNAVAILABLE = 503 
HTTP_504_GATEWAY_TIMEOUT = 504 
HTTP_505_HTTP_VERSION_NOT_SUPPORTED = 505 
HTTP_511_NETWORK_AUTHENTICATION_REQUIRED = 511 
</pre><p>The code declares five functions that receive the HTTP status code in the code argument and determine to which of the following categories the status code belongs to: informational, success, redirect, and client error or server error categories. We will use the previous variables when we have to return a specific status code. For example, in case we have to return a <code class="literal">404 Not Found</code> status code, we will return <code class="literal">status.HTTP_404_NOT_FOUND</code>, instead of just <code class="literal">404</code> or <code class="literal">HTTPStatus.NOT_FOUND</code>.</p></div>
<div class="section" title="Creating the classes that represent a drone"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec106"/>Creating the classes that represent a drone</h1></div></div></div><p>We will create as many classes as we will use to represent the different components of a drone. In a real-life example, these classes will interact with a library that interacts with sensors and actuators. In order to keep our example simple, we will make calls to <code class="literal">time.sleep</code> to simulate interactions that take some time to set or get values to and from sensors and actuators.</p><p>First, we will create a <code class="literal">Hexacopter</code> class that we will use to represent the hexacopter and a <code class="literal">HexacopterStatus</code> class that we will use to store status data for the hexacopter. Create a new <code class="literal">drone.py</code> file. The following lines shows all the necessary imports for the classes that we will create and the code that declares the <code class="literal">Hexacopter</code> and <code class="literal">HexacopterStatus</code> classes in the <code class="literal">drone.py</code> file. The code file for the sample is included in the <code class="literal">restful_python_chapter_09_01</code> folder:</p><pre class="programlisting">from random import randint 
from time import sleep 
 
 
class HexacopterStatus: 
    def __init__(self, motor_speed, turned_on): 
        self.motor_speed = motor_speed 
        self.turned_on = turned_on 
 
 
class Hexacopter: 
    MIN_SPEED = 0 
    MAX_SPEED = 1000 
 
    def __init__(self): 
        self.motor_speed = self.__class__.MIN_SPEED 
        self.turned_on = False 
 
    def get_motor_speed(self): 
        return self.motor_speed 
     
    def set_motor_speed(self, motor_speed): 
        if motor_speed &lt; self.__class__.MIN_SPEED: 
            raise ValueError('The minimum speed is {0}'.format(self.__class__.MIN_SPEED)) 
        if motor_speed &gt; self.__class__.MAX_SPEED: 
            raise ValueError('The maximum speed is {0}'.format(self.__class__.MAX_SPEED)) 
        self.motor_speed = motor_speed 
        self.turned_on = (self.motor_speed is not 0) 
        sleep(2) 
        return HexacopterStatus(self.get_motor_speed(), self.is_turned_on()) 
 
    def is_turned_on(self): 
        return self.turned_on 
 
    def get_hexacopter_status(self): 
        sleep(3) 
        return HexacopterStatus(self.get_motor_speed(), self.is_turned_on()) 
</pre><p>The <code class="literal">HexacopterStatus</code> class just declares a constructor, that is, the <code class="literal">__init__</code> method. This method receives many arguments and uses them to initialize the attributes with the same names: <code class="literal">motor_speed</code> and <code class="literal">turned_on</code>.</p><p>The <code class="literal">Hexacopter</code> class declares two class attributes that specify the minimum and maximum speed values: <code class="literal">MIN_SPEED</code> and <code class="literal">MAX_SPEED</code>. The constructor, that is, the <code class="literal">__init__</code> method, initializes the <code class="literal">motor_speed</code> attribute with the <code class="literal">MIN_SPEED</code> value and sets the <code class="literal">turned_on</code> attribute to <code class="literal">False</code>.</p><p>The <code class="literal">get_motor_speed</code> method returns the value of the <code class="literal">motor_speed</code> attribute. The <code class="literal">set_motor_speed</code> method checks whether the value for the <code class="literal">motor_speed</code> argument is in the valid range. In case the validation fails, the method raises a <code class="literal">ValueError</code> exception. Otherwise, the method sets the value of the <code class="literal">motor_speed</code> attribute with the received value and sets the value for the <code class="literal">turned_on</code> attribute to <code class="literal">True</code> if the <code class="literal">motor_speed</code> is greater than 0. Finally, the method calls sleep to simulate it takes two seconds to retrieve the hexacopter status and then returns a <code class="literal">HexacopterStatus</code> instance initialized with the <code class="literal">motor_speed</code> and <code class="literal">turned_on</code> attribute values, retrieved through specific methods.</p><p>The <code class="literal">get_hexacopter_status</code> method calls sleep to simulate it takes three seconds to retrieve the hexacopter status and then returns a <code class="literal">HexacopterStatus</code> instance initialized with the <code class="literal">motor_speed</code> and <code class="literal">turned_on</code> attribute values.</p><p>Now, we will create a <code class="literal">LightEmittingDiode</code> class that we will use to represent each LED. Open the previously created <code class="literal">drone.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_09_01</code> folder:</p><pre class="programlisting">class LightEmittingDiode: 
    MIN_BRIGHTNESS_LEVEL = 0 
    MAX_BRIGHTNESS_LEVEL = 255 
 
    def __init__(self, identifier, description): 
        self.identifier = identifier 
        self.description = description 
        self.brightness_level = self.__class__.MIN_BRIGHTNESS_LEVEL 
 
    def get_brightness_level(self): 
        sleep(1) 
        return self.brightness_level 
 
    def set_brightness_level(self, brightness_level): 
        if brightness_level &lt; self.__class__.MIN_BRIGHTNESS_LEVEL: 
            raise ValueError('The minimum brightness level is {0}'.format(self.__class__.MIN_BRIGHTNESS_LEVEL)) 
        if brightness_level &gt; self.__class__.MAX_BRIGHTNESS_LEVEL: 
            raise ValueError('The maximum brightness level is {0}'.format(self.__class__.MAX_BRIGHTNESS_LEVEL)) 
        sleep(2) 
        self.brightness_level = brightness_level 
</pre><p>The <code class="literal">LightEmittingDiode</code> class declares two class attributes that specify the minimum and maximum brightness level values: <code class="literal">MIN_BRIGHTNESS_LEVEL</code> and <code class="literal">MAX_BRIGHTNESS_LEVEL</code>. The constructor, that is, the <code class="literal">__init__</code> method, initializes the <code class="literal">brightness_level</code> attribute with the <code class="literal">MIN_BRIGHTNESS_LEVEL</code> and the <code class="literal">id</code> and <code class="literal">description</code> attributes with the values received in the arguments with the same names.</p><p>The <code class="literal">get_brightness_level</code> method calls sleep to simulate, it takes 1 second to retrieve the brightness level for the wired LED and then returns the value of the <code class="literal">brightness_level</code> attribute.</p><p>The <code class="literal">set_brightness_level</code> method checks whether the value for the <code class="literal">brightness_level</code> argument is in the valid range. In case the validation fails, the method raises a <code class="literal">ValueError</code> exception. Otherwise, the method calls <code class="literal">sleep</code> to simulate it takes two seconds to set the new brightness level and finally sets the value of the <code class="literal">brightness_level</code> attribute with the received value.</p><p>Now, we will create an <code class="literal">Altimeter</code> class that we will use to represent the altimeter. Open the previously created <code class="literal">drone.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_09_01</code> folder:</p><pre class="programlisting">class Altimeter: 
    def get_altitude(self): 
        sleep(1) 
        return randint(0, 3000) 
</pre><p>The <code class="literal">Altimeter</code> class declares a <code class="literal">get_altitude</code> method that calls <code class="literal">sleep</code> to simulate it takes one second to retrieve the altitude from the altimeter and finally generates a random integer from 0 to <code class="literal">3000</code> (inclusive) and returns it.</p><p>Finally, we will create a <code class="literal">Drone</code> class that we will use to represent the drone with its sensors and actuators. Open the previously created <code class="literal">drone.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_09_01</code> folder</p><pre class="programlisting">class Drone: 
    def __init__(self): 
        self.hexacopter = Hexacopter() 
        self.altimeter = Altimeter() 
        self.blue_led = LightEmittingDiode(1, 'Blue LED') 
        self.white_led = LightEmittingDiode(2, 'White LED') 
        self.leds = { 
            self.blue_led.identifier: self.blue_led, 
            self.white_led.identifier: self.white_led 
            } 
</pre><p>The <code class="literal">Drone</code> class just declares a constructor, that is, the <code class="literal">__init__</code> method that creates instances of the previously declared classes that represent the different components for the drone. The <code class="literal">leds</code> attribute saves a dictionary that has a key-value pair for each <code class="literal">LightEmittingDiode</code> instance with its id and its instance.</p></div>
<div class="section" title="Writing request handlers"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec107"/>Writing request handlers</h1></div></div></div><p>The main building blocks for a RESTful API in tornado are subclasses of the <code class="literal">tornado.web.RequestHandler</code> class, that is, the base class for HTTP request handlers in Tornado. We just need to create a subclass of this class and declare the methods for each supported HTTP verb. We have to override the methods to handle HTTP requests. Then, we have to map the URL patterns to each subclass of <code class="literal">tornado.web.RequestHandler</code> in the <code class="literal">tornado.web.Application</code> instance that represents the Tornado Web application.</p><p>First, we will create a <code class="literal">HexacopterHandler</code> class that we will use to handle requests for the hexacopter resource. Create a new <code class="literal">api.py</code> file. The following lines show all the necessary imports for the classes that we will create and the code that declares the <code class="literal">HexacopterHandler</code> class in the <code class="literal">drone.py</code> file. Enter the next lines in the new <code class="literal">api.py</code> file. The code file for the sample is included in the <code class="literal">restful_python_chapter_09_01</code> folder:</p><pre class="programlisting">import status 
from datetime import date 
from tornado import web, escape, ioloop, httpclient, gen 
from drone import Altimeter, Drone, Hexacopter, LightEmittingDiode 
 
 
drone = Drone() 
 
 
class HexacopterHandler(web.RequestHandler): 
    SUPPORTED_METHODS = ("GET", "PATCH") 
    HEXACOPTER_ID = 1 
 
    def get(self, id): 
        if int(id) is not self.__class__.HEXACOPTER_ID: 
            self.set_status(status.HTTP_404_NOT_FOUND) 
            return 
        print("I've started retrieving hexacopter's status") 
        hexacopter_status = drone.hexacopter.get_hexacopter_status() 
        print("I've finished retrieving hexacopter's status") 
        response = {  
            'speed': hexacopter_status.motor_speed, 
            'turned_on': hexacopter_status.turned_on, 
            } 
        self.set_status(status.HTTP_200_OK) 
        self.write(response) 
     
    def patch(self, id): 
        if int(id) is not self.__class__.HEXACOPTER_ID: 
            self.set_status(status.HTTP_404_NOT_FOUND) 
            return 
        request_data = escape.json_decode(self.request.body)  
        if ('motor_speed' not in request_data.keys()) or \ 
            (request_data['motor_speed'] is None): 
            self.set_status(status.HTTP_400_BAD_REQUEST) 
            return 
        try: 
            motor_speed = int(request_data['motor_speed']) 
            print("I've started setting the hexacopter's motor speed") 
            hexacopter_status = drone.hexacopter.set_motor_speed(motor_speed) 
            print("I've finished setting the hexacopter's motor speed") 
            response = {  
                'speed': hexacopter_status.motor_speed, 
                'turned_on': hexacopter_status.turned_on, 
                } 
            self.set_status(status.HTTP_200_OK) 
            self.write(response) 
        except ValueError as e: 
            print("I've failed setting the hexacopter's motor speed") 
            self.set_status(status.HTTP_400_BAD_REQUEST) 
            response = { 
                'error': e.args[0] 
                } 
            self.write(response) 
</pre><p>The <code class="literal">HexacopterHandler</code> class is a subclass of <code class="literal">tornado.web.RequestHandler</code> and declares the following two methods that will be called when the HTTP method with the same name arrives as a request on this HTTP handler:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">get</code>: This method receives the <code class="literal">id</code> of the hexacopter whose status has to be retrieved in the <code class="literal">id</code> argument. If the received id doesn't match the value of the <code class="literal">HEXACOPTER_ID</code> class attribute, the code calls the <code class="literal">self.set_status</code> method with <code class="literal">status.HTTP_404_NOT_FOUND</code> as an argument to set the status code for the response to <code class="literal">HTTP 404 Not Found</code>. Otherwise, the code prints a message indicating that it started retrieving the hexacopter's status and calls the <code class="literal">drone.hexacopter.get_hexacopter_status</code> method with a synchronous execution and saves the result in the <code class="literal">hexacopter_status</code> variable. Then, the code writes a message indicating it finished retrieving the status and generates a <code class="literal">response</code> dictionary with the <code class="literal">'speed'</code> and <code class="literal">'turned_on'</code> keys and their values. Finally, the code calls the <code class="literal">self.set_status</code> method with <code class="literal">status.HTTP_200_OK</code> as an argument to set the status code for the response to <code class="literal">HTTP 200 OK</code> and calls the <code class="literal">self.write</code> method with the <code class="literal">response</code> dictionary as an argument. Because <code class="literal">response</code> is a dictionary, Tornado automatically writes the chunk as JSON and sets the value of the <code class="literal">Content-Type</code> header to <code class="literal">application/json</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">patch</code>: This method receives the <code class="literal">id</code> of the hexacopter that has to be updated or patched in the <code class="literal">id</code> argument. As it happened in the previously explained get method, the code returns an <code class="literal">HTTP 404 Not Found</code> in case the received id doesn't match the value of the <code class="literal">HEXACOPTER_ID</code> class attribute. Otherwise, the code calls the <code class="literal">tornado.escape.json_decode</code> method with <code class="literal">self.request.body</code> as an argument to generate Python objects for the JSON string of the request body and saves the generated dictionary in the <code class="literal">request_data</code> variable. If the dictionary doesn't include a key named <code class="literal">'motor_speed'</code>, the code returns an <code class="literal">HTTP 400 Bad Request</code> status code. In case there is a key, the code prints a message indicating that it started setting the hexacopter's speed, calls the <code class="literal">drone.hexacopter.set_motor_speed</code> method with a synchronous execution and saves the result in the <code class="literal">hexacopter_status</code> variable. If the value specified for the motor speed is not valid, a <code class="literal">ValueError</code> exception will be caught and the code will return an HTTP 400 Bad Request status code and the validation error messages as the response body. Otherwise, the code writes a message indicating it finished setting the motor speed and generates a <code class="literal">response</code> dictionary with the <code class="literal">'speed'</code> and <code class="literal">'turned_on'</code> keys and their values. Finally, the code calls the <code class="literal">self.set_status</code> method with <code class="literal">status.HTTP_200_OK</code> as an argument to set the status code for the response to HTTP 200 OK and calls the <code class="literal">self.write</code> method with the <code class="literal">response</code> dictionary as an argument. Since <code class="literal">response</code> is a dictionary, Tornado automatically writes the chunk as JSON and sets the value of the <code class="literal">Content-Type</code> header to <code class="literal">application/json</code>.</li></ul></div><p>The class overrides the <code class="literal">SUPPORTED_METHODS</code> class variable with a tuple that indicates the class just supports the <code class="literal">GET</code> and <code class="literal">PATCH</code> methods. This way, in case the handler is requested a method that isn't included in the <code class="literal">SUPPORTED_METHODS</code> tuple, the server will automatically return a <code class="literal">405 Method Not Allowed</code> status code.</p><p>Now, we will create a <code class="literal">LedHandler</code> class that we will use to represent the LED resources. Open the previously created <code class="literal">api.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_09_01</code> folder:</p><pre class="programlisting">class LedHandler(web.RequestHandler): 
    SUPPORTED_METHODS = ("GET", "PATCH") 
 
    def get(self, id): 
        int_id = int(id) 
        if int_id not in drone.leds.keys(): 
            self.set_status(status.HTTP_404_NOT_FOUND) 
            return 
        led = drone.leds[int_id] 
        print("I've started retrieving {0}'s status".format(led.description)) 
        brightness_level = led.get_brightness_level() 
        print("I've finished retrieving {0}'s status".format(led.description)) 
        response = { 
            'id': led.identifier, 
            'description': led.description, 
            'brightness_level': brightness_level 
            } 
        self.set_status(status.HTTP_200_OK) 
        self.write(response) 
 
    def patch(self, id): 
        int_id = int(id) 
        if int_id not in drone.leds.keys(): 
            self.set_status(status.HTTP_404_NOT_FOUND) 
            return 
        led = drone.leds[int_id] 
        request_data = escape.json_decode(self.request.body)  
        if ('brightness_level' not in request_data.keys()) or \ 
            (request_data['brightness_level'] is None): 
            self.set_status(status.HTTP_400_BAD_REQUEST) 
            return 
        try: 
            brightness_level = int(request_data['brightness_level']) 
            print("I've started setting the {0}'s brightness
            level".format(led.description)) 
            led.set_brightness_level(brightness_level) 
            print("I've finished setting the {0}'s brightness 
            level".format(led.description)) 
            response = { 
                'id': led.identifier, 
                'description': led.description, 
                'brightness_level': brightness_level 
                } 
            self.set_status(status.HTTP_200_OK) 
            self.write(response) 
        except ValueError as e: 
            print("I've failed setting the {0}'s brightness
            level".format(led.description)) 
            self.set_status(status.HTTP_400_BAD_REQUEST) 
            response = { 
                'error': e.args[0] 
                } 
            self.write(response) 
</pre><p>The <code class="literal">LedHandler</code> class is a subclass of <code class="literal">tornado.web.RequestHandler</code>. The class overrides the <code class="literal">SUPPORTED_METHODS</code> class variable with a tuple that indicates the class just supports the <code class="literal">GET</code> and <code class="literal">PATCH</code> methods. In addition, the class declares the following two methods that will be called when the HTTP method with the same name arrives as a request on this HTTP handler:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">get</code>: This method receives the <code class="literal">id</code> of the LED whose status has to be retrieved in the <code class="literal">id</code> argument. If the received id isn't one of the keys of the <code class="literal">drone.leds</code> dictionary, the code calls the <code class="literal">self.set_status</code> method with <code class="literal">status.HTTP_404_NOT_FOUND</code> as an argument to set the status code for the response to <code class="literal">HTTP 404 Not Found</code>. Otherwise, the code retrieves the value associated with the key whose value matches the id in the <code class="literal">drone.leds</code> dictionary and saves the retrieved <code class="literal">LightEmittingDiode</code> instance in the <code class="literal">led</code> variable. The code prints a message indicating that it started retrieving the LED's brightness level, calls the <code class="literal">led.get_brightness_level</code> method with a synchronous execution, and saves the result in the <code class="literal">brightness_level</code> variable. Then, the code writes a message indicating that it finished retrieving the brightness level and generates a <code class="literal">response</code> dictionary with the <code class="literal">'id'</code>, <code class="literal">'description'</code>, and <code class="literal">'brightness_level'</code> keys and their values. Finally, the code calls the <code class="literal">self.set_status</code> method with <code class="literal">status.HTTP_200_OK</code> as an argument to set the status code for the response to HTTP 200 OK and calls the <code class="literal">self.write</code> method with the <code class="literal">response</code> dictionary as an argument. Since <code class="literal">response</code> is a dictionary, Tornado automatically writes the chunk as JSON and sets the value of the <code class="literal">Content-Type</code> header to <code class="literal">application/json</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">patch</code>: This method receives the id of the LED that has to be updated or patched in the <code class="literal">id</code> argument. As happened in the previously explained get method, the code returns an <code class="literal">HTTP 404 Not Found</code> in case the received id doesn't match the any of the keys of the <code class="literal">drone.leds</code> dictionary. Otherwise, the code calls the <code class="literal">tornado.escape.json_decode</code> method with <code class="literal">self.request.body</code> as an argument to generate Python objects for the JSON string of the request body and saves the generated dictionary in the <code class="literal">request_data</code> variable. If the dictionary doesn't include a key named <code class="literal">'brightness_level'</code>, the code returns an <code class="literal">HTTP 400 Bad Request</code> status code. In case there is a key, the code prints a message indicating that it started setting the LED's brightness level, including the description for the LED, calls the <code class="literal">drone.hexacopter.set_brightness_level</code> method with a synchronous execution. If the value specified for the <code class="literal">brightness_level</code> is not valid, a <code class="literal">ValueError</code> exception will be caught and the code will return an <code class="literal">HTTP 400 Bad Request</code> status code and the validation error messages as the response body. Otherwise, the code writes a message indicating it finished setting the LED's brightness value and generates a <code class="literal">response</code> dictionary with the <code class="literal">'id'</code>, <code class="literal">'description'</code>, and <code class="literal">'brightness_level'</code> keys and their values. Finally, the code calls the <code class="literal">self.set_status</code> method with <code class="literal">status.HTTP_200_OK</code> as an argument to set the status code for the response to HTTP 200 OK and calls the <code class="literal">self.write</code> method with the <code class="literal">response</code> dictionary as an argument. Since <code class="literal">response</code> is a dictionary, Tornado automatically writes the chunk as JSON and sets the value of the <code class="literal">Content-Type</code> header to <code class="literal">application/json</code>.</li></ul></div><p>Now, we will create an <code class="literal">AltimeterHandler</code> class that we will use to represent the altimeter resource. Open the previously created <code class="literal">api.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_09_01</code> folder:</p><pre class="programlisting">class AltimeterHandler(web.RequestHandler): 
    SUPPORTED_METHODS = ("GET") 
    ALTIMETER_ID = 1 
 
    def get(self, id): 
        if int(id) is not self.__class__.ALTIMETER_ID: 
            self.set_status(status.HTTP_404_NOT_FOUND) 
            return 
        print("I've started retrieving the altitude") 
        altitude = drone.altimeter.get_altitude() 
        print("I've finished retrieving the altitude") 
        response = {  
            'altitude': altitude 
            } 
        self.set_status(status.HTTP_200_OK) 
        self.write(response) 
</pre><p>The <code class="literal">AltimeterHandler</code> class is a subclass of <code class="literal">tornado.web.RequestHandler</code>. The class overrides the <code class="literal">SUPPORTED_METHODS</code> class variable with a tuple that indicates the class just supports the <code class="literal">GET</code> method. In addition, the class declares the <code class="literal">get</code> method that will be called when the HTTP method with the same name arrives as a request on this HTTP handler.</p><p>The <code class="literal">get</code> method receives the <code class="literal">id</code> of the altimeter whose altitude has to be retrieved in the <code class="literal">id</code> argument. If the received id doesn't match the value of the <code class="literal">ALTIMETER_ID</code> class attribute, the code calls the <code class="literal">self.set_status</code> method with <code class="literal">status.HTTP_404_NOT_FOUND</code> as an argument to set the status code for the response to HTTP 404 Not Found. Otherwise, the code prints a message indicating that it started retrieving the altimeter's altitude, calls the <code class="literal">drone.hexacopter.get_altitude</code> method with a synchronous execution, and saves the result in the <code class="literal">altitude</code> variable. Then, the code writes a message indicating it finished retrieving the altitude and generates a <code class="literal">response</code> dictionary with the <code class="literal">'altitude'</code> key and its value. Finally, the code calls the <code class="literal">self.set_status</code> method with <code class="literal">status.HTTP_200_OK</code> as an argument to set the status code for the response to HTTP 200 OK and calls the <code class="literal">self.write</code> method with the <code class="literal">response</code> dictionary as an argument. Since <code class="literal">response</code> is a dictionary, Tornado automatically writes the chunk as JSON and sets the value of the <code class="literal">Content-Type</code> header to <code class="literal">application/json</code>.</p><p>The following table shows the method of our previously created HTTP handler classes that we want to be executed for each combination of HTTP verb and scope:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<span class="strong"><strong>HTTP verb</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Scope</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Class and method</strong></span>
</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Hexacopter</p>
</td><td>
<p>
<code class="literal">HexacopterHandler.get</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Hexacopter</p>
</td><td>
<p>
<code class="literal">HexacopterHandler.patch</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>LED</p>
</td><td>
<p>
<code class="literal">LedHandler.get</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>LED</p>
</td><td>
<p>
<code class="literal">LedHandler.patch</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Altimeter</p>
</td><td>
<p>
<code class="literal">AltimeterHandler.get</code>
</p>
</td></tr></tbody></table></div><p>If the request results in the invocation of an HTTP handler class with an unsupported HTTP method, Tornado will return a response with the HTTP <code class="literal">405 Method Not Allowed</code> status code.</p></div>
<div class="section" title="Mapping URL patterns to request handlers"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec108"/>Mapping URL patterns to request handlers</h1></div></div></div><p>We must map URL patterns to our previously coded subclasses of <code class="literal">tornado.web.RequestHandler</code>. The following lines create the main entry point for the application, initialize it with the URL patterns for the API, and starts listening for requests. Open the previously created <code class="literal">api.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_09_01</code> folder:</p><pre class="programlisting">application = web.Application([ 
    (r"/hexacopters/([0-9]+)", HexacopterHandler), 
    (r"/leds/([0-9]+)", LedHandler), 
    (r"/altimeters/([0-9]+)", AltimeterHandler), 
], debug=True) 
 
 
if __name__ == "__main__": 
    port = 8888 
    print("Listening at port {0}".format(port)) 
    application.listen(port) 
    ioloop.IOLoop.instance().start() 
</pre><p>The preceding code creates an instance of <code class="literal">tornado.web.Application</code> named <code class="literal">application</code> with the collection of request handlers that make up the Web application. The code passes a list of tuples to the <code class="literal">Application</code> constructor. The list is composed of a regular expression (<code class="literal">regexp</code>) and a <code class="literal">tornado.web.RequestHandler</code> subclass (<code class="literal">request_class</code>). In addition, the code sets the <code class="literal">debug</code> argument to <code class="literal">True</code> to enable debugging.</p><p>The <code class="literal">main</code> method calls the <code class="literal">application.listen</code> method to build an HTTP server for the application with the defined rules on the specified port. In this case, the code specifies <code class="literal">8888</code> as the port, saved in the <code class="literal">port</code> variable, which is the default port for Tornado HTTP servers. Then, the call to <code class="literal">tornado.ioloop.IOLoop.instance().start()</code> starts the server created with the previous call to the <code class="literal">application.listen</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip64"/>Tip</h3><p>As with any other Web framework, you should never enable debugging in a production environment.</p></div></div></div>
<div class="section" title="Making HTTP requests to the Tornado API"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec109"/>Making HTTP requests to the Tornado API</h1></div></div></div><p>Now, we can run the <code class="literal">api.py</code> script that launches Tornados's development server to compose and send HTTP requests to our unsecure and simple Web API. Execute the following command:</p><pre class="programlisting">
<span class="strong"><strong>python api.py</strong></span>
</pre><p>The following lines show the output after we execute the previous command. The Tornado HTTP development server is listening at port <code class="literal">8888</code>:</p><pre class="programlisting">
<span class="strong"><strong>Listening at port 8888</strong></span>
</pre><p>With the previous command, we will start the Tornado HTTP server and it will listen on every interface on port <code class="literal">8888</code>. Thus, if we want to make HTTP requests to our API from other computers or devices connected to our LAN, we don't need any additional configurations.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip65"/>Tip</h3><p>If you decide to compose and send HTTP requests from other computers or devices connected to the LAN, remember that you have to use the development computer's assigned IP address instead of <code class="literal">localhost</code>. For example, if the computer's assigned IPv4 IP address is <code class="literal">192.168.1.103</code>, instead of <code class="literal">localhost:8888</code>, you should use <code class="literal">192.168.1.103:8888</code>. Of course, you can also use the host name instead of the IP address. The previously explained configurations are very important because mobile devices might be the consumers of our RESTful APIs and we will always want to test the apps that make use of our APIs in our development environments.</p></div></div><p>The Tornado HTTP server is running on localhost (<code class="literal">127.0.0.1</code>), listening on port <code class="literal">8888</code>, and waiting for our HTTP requests. Now, we will compose and send HTTP requests locally in our development computer or from other computer or devices connected to our LAN.</p><div class="section" title="Working with command-line tools â curl and httpie"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec9"/>Working with command-line tools â curl and httpie</h2></div></div></div><p>We will start composing and sending HTTP requests with the command-line tools we have introduced in <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>, <span class="emphasis"><em>Developing RESTful APIs with Django</em></span>, curl and HTTPie. In case you haven't installed HTTPie, make sure you activate the virtual environment and then run the following command in the terminal or Command Prompt to install the HTTPie package:</p><pre class="programlisting">
<span class="strong"><strong>pip install --upgrade httpie</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip66"/>Tip</h3><p>In case you don't remember how to activate the virtual environment that we created for this example, read the following section in this chapter<span class="emphasis"><em>—Setting up the virtual environment with Django REST Framework</em></span>.</p></div></div><p>Open a Cygwin terminal in Windows or a Terminal in macOS or Linux and run the following command. We will compose and send an HTTP request to turn on the hexacopter and set its motor speed to 100 RPMs:</p><pre class="programlisting">
<span class="strong"><strong>http PATCH :8888/hexacopters/1 motor_speed=100</strong></span>
</pre><p>The following is the equivalent curl command. It is very important to use the <code class="literal">-H "Content-Type: application/json"</code> option to indicate curl to send the data specified after the <code class="literal">-d</code> option as <code class="literal">application/json</code> instead of the default <code class="literal">application/x-www-form-urlencoded</code>:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX PATCH -H "Content-Type: application/json" -d '{"motor_speed":100}' 
    :8888/hexacopters/1</strong></span>
</pre><p>The preceding commands will compose and send the following HTTP request, <code class="literal">PATCH http://localhost:8888/hexacopters/1</code>, with the following JSON key-value pair:</p><pre class="programlisting">{  
    "motor_speed": 100 
} 
</pre><p>The request specifies <code class="literal">/hexacopters/1</code>, and therefore, Tornado will iterate over the list of tuples with regular expressions and request classes and it will match <code class="literal">'/hexacopters/([0-9]+)'</code>. Tornado will create an instance of the <code class="literal">HexacopterHandler</code> class and run the <code class="literal">HexacopterHandler.patch</code> method with <code class="literal">1</code> as the value for the <code class="literal">id</code> argument. As the HTTP verb for the request is <code class="literal">PATCH</code>, Tornado calls the <code class="literal">patch</code> method. If the hexacopter's speed is successfully set, the method returns an <code class="literal">HTTP 200 OK</code> status code and the key-value pairs with the speed and status for the recently updated hexacopter serialized to JSON in the response body. The following lines show an example response for the HTTP request:</p><pre class="programlisting">
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Content-Length: 33</strong></span>
<span class="strong"><strong>Content-Type: application/json; charset=UTF-8</strong></span>
<span class="strong"><strong>Date: Thu, 08 Sep 2016 02:02:27 GMT</strong></span>
<span class="strong"><strong>Server: TornadoServer/4.4.1</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>    "speed": 100,</strong></span>
<span class="strong"><strong>    "turned_on": true</strong></span>
<span class="strong"><strong>}</strong></span>
</pre><p>We will compose and send an HTTP request to retrieve the status and the motor speed for the hexacopter. Go back to the Cygwin terminal in Windows or the Terminal in macOS or Linux, and run the following command:</p><pre class="programlisting">
<span class="strong"><strong>http :8888/hexacopters/1</strong></span>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX GET -H :8888/hexacopters/1</strong></span>
</pre><p>The preceding commands will compose and send the following HTTP request: <code class="literal">GET http://localhost:8888/hexacopters/1</code>. The request specifies <code class="literal">/hexacopters/1</code>, and therefore, it will match <code class="literal">'/hexacopters/([0-9]+)'</code> and run the <code class="literal">HexacopterHandler.get</code> method with <code class="literal">1</code> as the value for the <code class="literal">id</code> argument. As the HTTP verb for the request is <code class="literal">GET</code>, Tornado calls the <code class="literal">get</code> method. The method retrieves the hexacopter's status and generates a JSON response with the key-value pairs.</p><p>The following lines show an example response for the HTTP request. The first lines show the HTTP response headers, including the status (<code class="literal">200 OK</code>) and the <code class="literal">Content-type</code> as (<code class="literal">application/json</code>). After the HTTP response headers, we can see the details of the hexacopter's status in the JSON response:</p><pre class="programlisting">
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Content-Length: 33</strong></span>
<span class="strong"><strong>Content-Type: application/json; charset=UTF-8</strong></span>
<span class="strong"><strong>Date: Thu, 08 Sep 2016 02:26:00 GMT</strong></span>
<span class="strong"><strong>Etag: "ff152383ca6ebe97e5a136166f433fbe7f9b4434"</strong></span>
<span class="strong"><strong>Server: TornadoServer/4.4.1</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>    "speed": 100,</strong></span>
<span class="strong"><strong>    "turned_on": true</strong></span>
<span class="strong"><strong>}</strong></span>
</pre><p>After we run the three requests, we will see the following lines in the window that is running the Tornado HTTP server. The output shows the results of executing the print statements that describe when the code started setting or retrieving information and when it finished:</p><pre class="programlisting">
<span class="strong"><strong>I've started setting the hexacopter's motor speed</strong></span>
<span class="strong"><strong>I've finished setting the hexacopter's motor speed</strong></span>
<span class="strong"><strong>I've started retrieving hexacopter's status</strong></span>
<span class="strong"><strong>I've finished retrieving hexacopter's status</strong></span>
</pre><p>The different methods we coded in the request handler classes end up calling <code class="literal">time.sleep</code> to simulate it takes some time for the operations with the hexacopter. In this case, our code is running with a synchronous execution, and therefore, each time we compose and send a request, the Tornado server is blocked until the operation with the hexacopter finishes and the method sends the response. We will create a new version of this API that will use asynchronous execution later and we will understand the advantages of Tornado's non-blocking features. However, first, we will understand how the synchronous version of the API works.</p><p>The following image shows two Terminal windows side-by-side on macOS. The Terminal window on the left-hand side is running the Tornado HTTP server and displays the messages printed in the methods that process the HTTP requests. The Terminal window on the right-hand side is running <code class="literal">http</code> commands to generate the HTTP requests. It is a good idea to use a similar configuration to check the output while we compose and send the HTTP requests:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_001.jpg" alt="Working with command-line tools â curl and httpie"/></div><p>
</p><p>Now, we will compose and send an HTTP request to retrieve a hexacopter that doesn't exist. Remember that we just have one hexacopter in our drone. Run the following command to try to retrieve the status for an hexacopter with an invalid id. We must make sure that the utilities display the headers as part of the response to see the returned status code:</p><pre class="programlisting">
<span class="strong"><strong>http :8888/hexacopters/8</strong></span>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX GET :8888/hexacopters/8</strong></span>
</pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">GET http://localhost:8888/hexacopters/8</code>. The request is the same as the previous one we have analyzed, with a different number for the <code class="literal">id</code> parameter. The server will run the <code class="literal">HexacopterHandler.get</code> method with <code class="literal">8</code> as the value for the <code class="literal">id</code> argument. The <code class="literal">id</code> is not equal to 1, and therefore, the code will return an HTTP <code class="literal">404 Not Found</code> status code. The following lines show an example header response for the HTTP request:</p><pre class="programlisting">
<span class="strong"><strong>HTTP/1.1 404 Not Found</strong></span>
<span class="strong"><strong>Content-Length: 0</strong></span>
<span class="strong"><strong>Content-Type: text/html; charset=UTF-8</strong></span>
<span class="strong"><strong>Date: Thu, 08 Sep 2016 04:31:53 GMT</strong></span>
<span class="strong"><strong>Server: TornadoServer/4.4.1</strong></span>
</pre></div><div class="section" title="Working with GUI tools - Postman and others"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec10"/>Working with GUI tools - Postman and others</h2></div></div></div><p>So far, we have been working with two Terminal-based or command-line tools to compose and send HTTP requests to our Tornado HTTP server-cURL and HTTPie. Now, we will work with one of the GUI tools we used when composing and sending HTTP requests to the Django development server and the Flask development server: Postman.</p><p>Now, we will use the <span class="strong"><strong>Builder</strong></span> tab in Postman to easily compose and send HTTP requests to <code class="literal">localhost:8888</code> and test the RESTful API with this GUI tool. Remember that Postman doesn't support curl-like shorthands for localhost, and therefore, we cannot use the same shorthands we have been using when composing requests with curl and HTTPie.</p><p>Select <span class="strong"><strong>GET</strong></span> in the drop-down menu at the left-hand side of the <span class="strong"><strong>Enter request URL</strong></span> textbox and enter <code class="literal">localhost:8888/leds/1</code> in this textbox at the right-hand side of the dropdown. Now, click on <span class="strong"><strong>Send</strong></span> and Postman will display the status (<code class="literal">200 OK</code>), the time it took for the request to be processed and the response body with all the games formatted as JSON with syntax highlighting (<span class="strong"><strong>Pretty</strong></span> view).</p><p>The following screenshot shows the JSON response body in Postman for the HTTP GET request:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_002.jpg" alt="Working with GUI tools - Postman and others"/></div><p>
</p><p>Click on <span class="strong"><strong>Headers</strong></span> on the right-hand side of <span class="strong"><strong>Body</strong></span> and <span class="strong"><strong>Cookies</strong></span> to read the response headers. The following screenshot shows the layout for the response headers that Postman displays for the previous response. Note that Postman displays the <span class="strong"><strong>Status</strong></span> at the right-hand side of the response and doesn't include it as the first line of the Headers, as it happened when we worked with both the cURL and HTTPie utilities:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_003.jpg" alt="Working with GUI tools - Postman and others"/></div><p>
</p><p>Now, we will use the <span class="strong"><strong>Builder</strong></span> tab in Postman to compose and send an HTTP request to create a new message, specifically, a PATCH request. Follow the next steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select <span class="strong"><strong>PATCH</strong></span> from the drop-down menu on the left-hand side of the <span class="strong"><strong>Enter request URL</strong></span> textbox and enter <code class="literal">localhost:8888/leds/1</code> in this textbox at the right-hand side of the dropdown.</li><li class="listitem">Click on <span class="strong"><strong>Body</strong></span> on the right-hand side of <span class="strong"><strong>Authorization</strong></span> and <span class="strong"><strong>Headers</strong></span>, within the panel that composes the request.</li><li class="listitem">Activate the <span class="strong"><strong>raw</strong></span> radio button and select <code class="literal">JSON (application/json)</code> in the dropdown on the right-hand side of the <span class="strong"><strong>binary</strong></span> radio button. Postman will automatically add a <code class="literal">Content-type = application/json</code> header, and therefore, you will notice the <span class="strong"><strong>Headers</strong></span> tab will be renamed to <span class="strong"><strong>Headers (1)</strong></span>, indicating us that there is one key-value pair specified for the request headers.</li><li class="listitem">Enter the following lines in the textbox below the radio buttons, within the <span class="strong"><strong>Body</strong></span> tab:</li></ol></div><pre class="programlisting">{ 
   "brightness_level": 128 
} 
</pre><p>The following screenshot shows the request body in Postman:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_004.jpg" alt="Working with GUI tools - Postman and others"/></div><p>
</p><p>We followed the necessary steps to create an HTTP <code class="literal">PATCH</code> request with a JSON body that specifies the necessary key-value pairs to create a new game. Click on <span class="strong"><strong>Send</strong></span> and Postman will display the Status (<code class="literal">200 OK</code>), the time it took for the request to be processed, and the response body with the recently added game formatted as JSON with syntax highlighting (<span class="strong"><strong>Pretty</strong></span> view). The following screenshot shows the JSON response body in Postman for the HTTP POST request.</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_005.jpg" alt="Working with GUI tools - Postman and others"/></div><p>
</p><p>The Tornado HTTP server is listening on every interface on port <code class="literal">8888</code>, and therefore, we can also use apps that can compose and send HTTP requests from mobile devices to work with the RESTful API. For example, we can work with the previously introduced iCurlHTTP app on iOS devices such as iPad Pro and iPhone. In Android devices, we can work with the previously introduced HTTP Request App.</p><p>The following screenshot shows the results of composing and sending the following HTTP request with the iCurlHTTP appâ<code class="literal">GET http://192.168.2.3:8888/altimeters/1</code>. Remember that you have to perform the previously explained configurations in your LAN and router to be able to access the Flask development server from other devices connected to your LAN. In this case, the IP assigned to the computer running the Tornado HTTP server is <code class="literal">192.168.2.3</code>, and therefore, you must replace this IP with the IP assigned to your development computer:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_006.jpg" alt="Working with GUI tools - Postman and others"/></div><p>
</p></div></div>
<div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec110"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The main building blocks for a RESTful API in Tornado are subclasses of which the following classes:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">tornado.web.GenericHandler</code></li><li class="listitem"><code class="literal">tornado.web.RequestHandler</code></li><li class="listitem"><code class="literal">tornado.web.IncomingHTTPRequestHandler</code></li></ol></div><p>
</p></li><li class="listitem">If we just want to support the <code class="literal">GET</code> and <code class="literal">PATCH</code> methods, we can override the <code class="literal">SUPPORTED_METHODS</code> class variable with which of the following values:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">("GET", "PATCH")</code></li><li class="listitem"><code class="literal"> {0: "GET", 1: "PATCH"}</code></li><li class="listitem"><code class="literal">{"GET": True, "PATCH": True, "POST": False, "PUT": False}</code></li></ol></div><p>
</p></li><li class="listitem">The list of tuples for a the <code class="literal">tornado.Web.Application</code> constructor is composed of:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A regular expression (<code class="literal">regexp</code>) and a <code class="literal">tornado.web.RequestHandler</code> subclass (<code class="literal">request_class</code>).</li><li class="listitem">A regular expression (<code class="literal">regexp</code>) and a <code class="literal">tornado.web.GenericHandler</code> subclass (<code class="literal">request_class</code>).</li><li class="listitem">A regular expression (<code class="literal">regexp</code>) and a <code class="literal">tornado.web.IncomingHTTPRequestHandler</code> subclass (<code class="literal">request_class</code>).</li></ol></div><p>
</p></li><li class="listitem">When we call the <code class="literal">self.write</code> method with a dictionary as an argument in a request handler, Tornado:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Automatically writes the chunk as JSON but we have to manually set the value of the <code class="literal">Content-Type</code> header to <code class="literal">application/json</code>.</li><li class="listitem">Requires us to use the <code class="literal">json.dumps</code> method and set the value of the <code class="literal">Content-Type</code> header to <code class="literal">application/json</code>.</li><li class="listitem">Automatically writes the chunk as JSON and sets the value of the <code class="literal">Content-Type</code> header to <code class="literal">application/json</code>.</li></ol></div><p>
</p></li><li class="listitem">A calls to the <code class="literal">tornado.escape.json_decode</code> method with <code class="literal">self.request.body</code> as an argument in a request handler:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Generates Python objects for the JSON string of the request body and returns the generated tuple.</li><li class="listitem">Generates Python objects for the JSON string of the request body and returns the generated dictionary.</li><li class="listitem">Generates Python objects for the JSON string of the request body and returns the generated list.</li></ol></div><p>
</p></li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec111"/>Summary</h1></div></div></div><p>In this chapter, we designed a RESTful API to interact with slow sensors and actuators. We defined the requirements for our API, understood the tasks performed by each HTTP method, and set up a virtual environment with Tornado.</p><p>We created the classes that represent a drone and wrote code to simulate slow I/O operations that are called for each HTTP request method, wrote classes that represent request handlers and process the different HTTP requests, and configured the URL patterns to route URLs to request handlers and their methods.</p><p>Finally, we started Tornado development server, used command-line tools to compose and send HTTP requests to our RESTful API, and analyzed how each HTTP requests was processed in our code. We also worked with GUI tools to compose and send HTTP requests.</p><p>Now that we understand the basics of Tornado to create RESTful APIs, we will take advantage of the non-blocking features combined with asynchronous operations in Tornado in a new version for the API, which is what we are going to discuss in the next chapter.</p></div></body></html>