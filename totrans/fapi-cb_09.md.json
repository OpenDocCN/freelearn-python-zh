["```py\n    $ pip install fastapi[all]\n    ```", "```py\n$ pip install –r requirements.txt\n```", "```py\n$ pip install fastapi[all] websockets\n```", "```py\n    from fastapi import FastAPI\n    app = FastAPI()\n    ```", "```py\n    from fastapi import WebSocket\n    @app.websocket(\"/ws\")\n    async def ws_endpoint(websocket: WebSocket):\n        await websocket.accept()\n        await websocket.send_text(\n            \"Welcome to the chat room!\"\n        )\n        await websocket.close()\n    ```", "```py\nws://localhost:8000/ws and click on Connect.\nIn the **Response** panel, right below the URL form, you should see the list of events that happened during the connection. In particular, look for the message received by the server:\n\n```", "```py\n\n That means that the WebSocket endpoint has been created and works properly.\nHow it works…\nThe `websocket` parameter in the WebSocket endpoint represents an individual WebSocket connection. By awaiting `websocket.accept()`, the server establishes the connection with the client (technically called an `websocket.send_text()` sends a message to the client. Finally, `websocket.close()` closes the connection.\nThe three events are listed in the **Response** panel of Postman.\nAlthough not very useful from a practical point of view, this configuration is the bare minimum setup for a WebSocket connection. In the next recipe, we will see how to exchange messages between the client and the server through a WebSocket endpoint.\nSee also\nYou can check how to create a WebSocket endpoint on the FastAPI official documentation page:\n\n*   *FastAPI* *WebSockets*: [https://fastapi.tiangolo.com/advanced/websockets/](https://fastapi.tiangolo.com/advanced/websockets/)\n\nAt the time of writing, the Swagger documentation does not support WebSocket endpoints. If you spin up the server and open Swagger at `http://localhost:8000/docs`, you won’t see the endpoint we have just created. A discussion is ongoing on the FastAPI GitHub repository – you can follow it at the following URL:\n\n*   *FastAPI WebSocket Endpoints Documentation* *Discussion*: [https://github.com/tiangolo/fastapi/discussions/7713](https://github.com/tiangolo/fastapi/discussions/7713)\n\nSending and receiving messages over WebSockets\nWebSocket connections enable bidirectional communication between clients and servers, allowing the real-time exchange of messages. This recipe will bring us one step closer to creating our chat application by showing how to enable the FastAPI application to receive messages over WebSockets and print them to the terminal output.\nGetting ready\nBefore starting the recipe, make sure you know how to set up a **WebSocket** connection in **FastAPI**, as explained in the previous recipe. Also, you will need a tool to test WebSockets, such as **Postman**, on your machine.\nHow to do it…\nWe will enable our chatroom endpoint to receive messages from the client to print them to the standard output.\nLet’s start by defining the logger. We will use the logger from the `uvicorn` package (as we did in other recipes – see, for example, *Creating custom middlewares* in [*Chapter 8*](B21025_08.xhtml#_idTextAnchor262), *Advanced Features and Best Practices*), which is the one used by FastAPI as well. In `main.py`, let’s write the following:\n\n```", "```py\n\n Now let’s modify the `ws_endpoint` function endpoint:\n\n```", "```py\n    Hello FastAPI application.On the output terminal you will the following message:\n\n    ```", "```py\n\n    While in the messages section of the client request you will see the new message:\n\n    ```", "```py\n\n    ```", "```py\nfrom fastapi.websockets import WebSocketDisconnect\n@app.websocket(\"/ws\")\nasync def ws_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    await websocket.send_text(\n        \"Welcome to the chat room!\"\n    )\n    try:\n        while True:\n            data = await websocket.receive_text()\n            logger.info(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        logger.warning(\n            \"Connection closed by the client\"\n/ws, and then disconnect, you won’t see the error propagation anymore.\nServer-side disconnection\nIn this situation, the connection is closed by the server. Suppose the server will close the connection based on a specific message such as the `\"disconnect\"` text string, for example.\nLet’s implement it in the `/``ws` endpoint:\n\n```", "```py\nfrom fastapi import status\n@app.websocket(\"/ws\")\nasync def chatroom(websocket: WebSocket):\n    if not websocket.headers.get(\"Authorization\"):\n        return await websocket.close()\n    await websocket.accept()\n    await websocket.send_text(\n        \"Welcome to the chat room!\"\n    )\n    try:\n        while True:\n            data = await websocket.receive_text()\n            logger.info(f\"Message received: {data}\")\n            if data == \"disconnect\":\n                logger.warn(\"Disconnecting...\")\n                return await websocket.close(\n                    code=status.WS_1000_NORMAL_CLOSURE,\n                    reason=\"Disconnecting...\",\n                )\n    except WebSocketDisconnect:\n        logger.warn(\"Connection closed by the client\")\n```", "```py\nDisconnected from localhost:8000/ws 14:09:08\n1000 Normal Closure:  Disconnecting...\n```", "```py\n@app.websocket(\"/ws\")\nasync def ws_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    await websocket.send_text(\n        \"Welcome to the chat room!\"\n    )\n    try:\n        while True:\n            data = await websocket.receive_text()\n            logger.info(f\"Message received: {data}\")\n            if data == \"disconnect\":\n                logger.warn(\"Disconnecting...\")\n                return await websocket.close(\n                    code=status.WS_1000_NORMAL_CLOSURE,\n                    reason=\"Disconnecting...\",\n                )\n            if \"bad message\" in data:\n                raise WebSocketException(\n                    code=status.WS_1008_POLICY_VIOLATION,\n                    reason=\"Inappropriate message\"\n                )\n    except WebSocketDisconnect:\n        logger.warn(\"Connection closed by the client\")\n```", "```py\nDisconnected from localhost:8000/ws 14:51:40\n1008 Policy Violation: Inappropriate message\n```", "```py\n$ pip install jinja2\n```", "```py\n    import asyncio\n    from fastapi import WebSocket\n    class ConnectionManager:\n        def __init__(self):\n            self.active_connections: list[WebSocket] = []\n        async def connect(self, websocket: WebSocket):\n            await websocket.accept()\n            self.active_connections.append(websocket)\n        def disconnect(self, websocket: WebSocket):\n            self.active_connections.remove(websocket)\n        async def send_personal_message(\n            self, message: dict, websocket: WebSocket\n        ):\n            await websocket.send_json(message)\n        async def broadcast(\n            self, message: json, exclude: WebSocket = None\n        ):\n            tasks = [\n                connection.send_json(message)\n                for connection in self.active_connections\n                if connection != exclude\n            ]\n            await asyncio.gather(*tasks)\n    ```", "```py\n    from app.ws_manager import ConnectionManager\n    conn_manager = ConnectionManager()\n    ```", "```py\n    from fastapi import APIRouter\n    router = APIRouter()\n    ```", "```py\n    from fastapi import WebSocket, WebSocketDisconnect\n    @router.websocket(\"/chatroom/{username}\")\n    async def chatroom_endpoint(\n        websocket: WebSocket, username: str\n    ):\n        await conn_manager.connect(websocket)\n        await conn_manager.broadcast(\n            f\"{username} joined the chat\",\n            exclude=websocket,\n        )\n        try:\n            while True:\n                data = await websocket.receive_text()\n                await conn_manager.broadcast(\n                    {\"sender\": username, \"message\": data},\n                    exclude=websocket,\n                )\n                await conn_manager.send_personal_message(\n                    {\"sender\": \"You\", \"message\": data},\n                    websocket,\n                )\n        except WebSocketDisconnect:\n            conn_manager.disconnect(websocket)\n            await connection_manager.broadcast(\n                {\n                    \"sender\": \"system\",\n                    \"message\": f\"Client #{username} \"\n                    \"left the chat\",\n                }\n            )\n    ```", "```py\n    from app.chat import router as chat_router\n    # rest of the code\n    app = FastAPI()\n    chatroom.xhtml should be stored in a templates folder in the project root. We will keep the page simple with the JavaScript tag embedded.The HTML part will look like this:\n\n    ```", "```py\n\n    The `<script>` tag will contain the Javascript code that will connect to the WebSocket `/chatroom/{username}` endpoint with the client name as a parameter, send the message from the client page, receive messages from the server, and render the message text on the page in the messages list section.You can find an example in the GitHub repository, in the `templates/chatroom.xhtml` file. Feel free to make your own version or download it.\n    ```", "```py\n    from fastapi.responses import HTMLResponse\n    from fastapi.templating import Jinja2Templates\n    from app.ws_manager import ConnectionManager\n    conn_manager = ConnectionManager()\n    templates = Jinja2Templates(directory=\"templates\")\n    @router.get(\"/chatroom/{username}\")\n    async def chatroom_page_endpoint(\n        request: Request, username: str\n    ) -> HTMLResponse:\n        return templates.TemplateResponse(\n            request=request,\n            name=\"chatroom.xhtml\",\n            context={\"username\": username},\n        )\n    ```", "```py\nimport logging\nlogger = logging.getLogger(\"uvicorn\")\n@router.websocket(\"/chatroom/{username}\")\nasync def chatroom_endpoint(\n    websocket: WebSocket, username: str\n):\n    await conn_manager.connect(websocket)\n    await conn_manager.broadcast(\n        # method's parameters\n    )\n    logger.info(f\"{username} joined the chat\")\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await conn_manager.broadcast(\n                # method's parameters\n            )\n            await conn_manager.send_personal_message(\n                # method's parameters\n            )\n            logger.info(\n                f\"{username} says: {data}\"\n            )\n    except WebSocketDisconnect:\n        conn_manager.disconnect(websocket)\n        await conn_manager.broadcast(\n            # method's paramters\n        )\n        logger.info(f\"{username} left the chat\")\n```", "```py\n    import uvicorn\n    from app.main import app\n    def run_server():\n        uvicorn.run(app)\n    ```", "```py\n    import asyncio\n    from websockets import connect\n    async def connect_client(\n        n: int, n_messages: int = 3\n    ):\n        async with connect(\n            f\"ws://localhost:8000/chatroom/user{n}\",\n        ) as client:\n            for _ in range(n_messages):\n                await client.send(\n                    f\"Hello World from user{n}\"\n                )\n                await asyncio.sleep(n * 0.1)\n            await asyncio.sleep(2)\n    ```", "```py\n    import multiprocessing\n    async def main(n_clients: int = 10):\n        p = multiprocessing.Process(target=run_server)\n        p.start()\n        await asyncio.sleep(1)\n        connections = [\n            connect_client(n) for n in range(n_clients)\n        ]\n        await asyncio.gather(*connections)\n        await asyncio.sleep(1)\n        p.terminate()\n    ```", "```py\n    if __name__ == \"__main__\":\n        asyncio.run(main())\n    ```", "```py\nn_clients, you will probably see all the messages flowing on the terminal. However, by increasing n_clients, depending on your machine, at some point, the script will not be able to run anymore and you will see socket connection errors popping up. That means that you passed the limit to support new connections with your endpoint.\nWhat we did is the core of a basic script to benchmark. You can further expand the script based on your needs by adding timing or parametrization to have a broader view of your application’s capabilities.\nYou can also do the same by using dedicated test frameworks, similar to what we did in the *Performance testing for* *high traffic* *applications* recipe in [*Chapter 5*](B21025_05.xhtml#_idTextAnchor157), *Testing and Debugging FastAPI Applications*, for HTTP traffic.\nThere’s more…\nBenchmarking your WebSocket is only the first step to optimize your application performance. Here is a checklist of actions that you can take to improve your application performance and reduce errors:\n\n*   `TestClient` also supports WebSocket connections, so use it to ensure that the behavior of the endpoint is the one expected and does not change during the development process.\n*   `try/except` blocks to handle specific error conditions. Also, when possible, use `async for` over `while True` when managing message exchanges. This will automatically capture and treat disconnection errors.\n*   **Use connection pool managers**: Connection pool managers improve performance and code maintainability when handling multiple clients, such as in chat applications.\n\nSee also\nYou can see more on unit testing WebSockets with FastAPI in the official documentation:\n\n*   *Testing WebSockets in* *FastAPI*: [https://fastapi.tiangolo.com/advanced/testing-websockets/](https://fastapi.tiangolo.com/advanced/testing-websockets/)\n\nSecuring WebSocket connections with OAuth2\nSecuring WebSocket connections is paramount to safeguarding the privacy and security of user interactions in real-time applications. By implementing authentication and access control mechanisms, developers can mitigate risks associated with unauthorized access, eavesdropping, and data tampering. In this recipe, we will see how to create a secure WebSocket connection endpoint with OAuth2 token authorization in your FastAPI applications.\nGetting ready\nTo follow the recipe, you should already know how to set up a basic WebSocket endpoint – explained in the *Setting up WebSockets in FastAPI* recipe in this chapter.\nFurthermore, we are going to use **OAuth2** with a password and a bearer token. We will apply the same strategy we used to secure HTTP endpoints in the *Securing your API with OAuth2* recipe in [*Chapter 3*](B21025_03.xhtml#_idTextAnchor091), *Building RESTful APIs with FastAPI*. Feel free to have a look before starting the recipe.\nBefore starting the recipe, let’s create a simple WebSocket endpoint, `/secured-ws`, in the `main.py` module:\n\n```", "```py\n\n The endpoint will accept any connection with a parameter to specify the username. Then it will send a welcome message to the client and return each message received to the client.\nThe endpoint is insecure since it does not have any protection and can be easily reached. Let’s dive into the recipe to see how to protect it with OAuth2 authentication.\nHow to do it…\nAt the time of writing, there is no support for the `OAuth2PasswordBearer` class for WebSocket in FastAPI. This means that checking the bearer token in the headers for WebSocket is not as straightforward as it is for HTTP calls. However, we can create a WebSocket-specific class that is derived from the one used by HTTP to achieve the same functionality as follows.\n\n1.  Let’s do it in a dedicated module under the `app` folder called `ws_password_bearer.py`:\n\n    ```", "```py\n\n    We will use it to create a `get_username_from_token` function to retrieve the username from the token. You can create the function in a dedicated module – `security.py`.\n\n     2.  Let’s define the `oauth2_scheme_for_ws` object:\n\n    ```", "```py\n\n     3.  The `tokenUrl` argument specifies the callback endpoint to call to retrieve the token. This endpoint should be built according to the token resolution you use. After that, we can create a function that retrieves the username from the token:\n\n    ```", "```py\n\n    The purpose of the `fake_token_resolver` function is to simulate the process of resolving a token. This function can be found in the `security.py` file in the GitHub repository of the chapter. Furthermore, the example contains only two users, `johndoe` and `janedoe`, who can be used later for testing. Also, the `security.py` module from the GitHub repository contains the `POST /token` endpoint to be used to retrieve the token.\n\n    However, it is important to mention that this function does not provide any actual security and it is only used for example purposes. In a production environment, it is recommended to use a `/secured-ws`, in the `main.py` module:\n\n    ```", "```py\n\nThis is all you need to build a secured WebSocket endpoint.\nTo test it, spin up the server from the terminal by running the following:\n\n```", "```py\n\n When attempting to connect to the WebSocket endpoint using Postman or another tool to the address `ws://localhost:8000/secured-ws`, an authorization error will occur, and the connection will be rejected before the handshake.\nTo allow the connection, we need to retrieve the token and pass it through the headers of the WebSocket request in `tokenized` string to the username. For example, for `johndoe`, the token would be `tokenizedjohndoe`.\nLet’s pass it through the header. In Postman, you can pass the bearer token to the WebSocket request in the `Authorization` and value that will be `bearer tokenizedjohndoe`.\nNow, if you try to connect, it should connect and you will be able to exchange messages with the endpoint.\nYou have just secured a WebSocket endpoint in FastAPI. By implementing OAuth2 authorization, you can enhance the security posture of your FastAPI applications and safeguard WebSocket communication against potential threats and vulnerabilities.\nExercise\nTry to build a secure chat functionality where users need to log in to participate in the chat.\nTips: The endpoint that returns the HTML page should check for the bearer token in the cookies. If the cookie is not found or the bearer token is not valid, it should redirect the client to a login page that puts the token in the browser’s cookies.\nYou can use the `response.RedirectResponse` class from the `fastapi` package to handle redirections. The usage is quite straightforward and you can have a look at the documentation page at the link:\n[https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\nSee also\nIntegrating `OAuth2PasswordBearer`-like class is a current topic of interest, and it is expected to evolve quickly over time. You can follow the ongoing discussion in the FastAPI GitHub repository:\n\n*   *OAuth2PasswordBearer with WebSocket* *Discussion*: [https://github.com/tiangolo/fastapi/discussions/8983](https://github.com/tiangolo/fastapi/discussions/8983)\n\n```", "```py\n\n```", "```py\n\n```"]