- en: Chapter 4. Functions, the Building Blocks of Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"To create architecture is to put in order. Put what in order? Function
    and objects."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Le Corbusier* |'
  prefs: []
  type: TYPE_TB
- en: In this chapter, we're going to explore functions. We already said that everything
    is an object in Python, and functions are no exception to this. But, what exactly
    is a function? A **function** is a sequence of instructions that perform a task,
    bundled as a unit. This unit can then be imported and used wherever it's needed.
    There are many advantages to using functions in your code, as we'll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'I believe the saying, *a picture is worth one thousand words*, is particularly
    true when explaining functions to someone who is new to this concept, so please
    take a look at the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions, the Building Blocks of Code](img/4715_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a function is a block of instructions, packaged as a whole,
    like a box. Functions can accept input arguments and produce output values. Both
    of these are optional, as we'll see in the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A function in Python is defined by using the `def` keyword, after which the
    name of the function follows, terminated by a pair of braces (which may or may
    not contain input parameters) and, finally, a colon (`:`) signals the end of the
    function definition line. Immediately afterwards, indented by four spaces, we
    find the body of the function, which is the set of instructions that the function
    will execute when called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the indentation by four spaces is not mandatory, but it is the amount
    of spaces suggested by **PEP8**, and, in practice, it is the most widely used
    spacing measure.
  prefs: []
  type: TYPE_NORMAL
- en: A function may or may not return output. If a function wants to return output,
    it does so by using the `return` keyword, followed by the desired output. If you
    have an eagle eye, you may have noticed the little ***** after **Optional** in
    the output section of the preceding picture. This is because a function always
    returns something in Python, even if you don't explicitly use the `return` clause.
    If the function has no `return` statement in its body, it's return value is `None`.
    The reasons behind this design choice are out of the scope of an introductory
    chapter, so all you need to know is that this behavior will make your life easier,
    as always, thank you Python.
  prefs: []
  type: TYPE_NORMAL
- en: Why use functions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are among the most important concepts and constructs of any language,
    so let me give you a few reasons why we need them:'
  prefs: []
  type: TYPE_NORMAL
- en: They reduce code duplication in a program. By having a specific task taken care
    of by a nice block of packaged code that we can import and call whenever we want,
    we don't need to duplicate its implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They help in splitting a complex task or procedure into smaller blocks, each
    of which becomes a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They hide the implementation details from their users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They improve traceability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They improve readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at a few examples to get a better understanding of each point.
  prefs: []
  type: TYPE_NORMAL
- en: Reduce code duplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you are writing a piece of scientific software, and you need to
    calculate primes up to a limit, as we did in the previous chapter. You write several
    algorithms and prime numbers, being the basis of many different types of calculations,
    keep creeping into your code. Well, you have a nice algorithm to calculate them,
    so you copy and paste it to wherever you need. One day, though, your friend *Mister
    Smarty* gives you a better algorithm to calculate prime numbers, and this will
    save you a lot of time. At this point, you need to go over your whole codebase
    and replace the old code with the new code.
  prefs: []
  type: TYPE_NORMAL
- en: This is actually a very bad way to go about it. It's error-prone, you never
    know what lines you are chopping out or leaving there by mistake when you cut
    and paste code in other code, and you may also risk missing one of the places
    where prime calculation was done, leaving your software with different versions.
    Can you imagine if you discovered that the old way was buggy? You would have an
    undetected bug in your code, and bugs like this are quite hard to spot, especially
    in big codebases.
  prefs: []
  type: TYPE_NORMAL
- en: So, what should you do? Simple! You write a function, `get_prime_numbers(upto)`,
    and use it anywhere you need a list of primes. When *Mister Smarty* comes to you
    and gives you the new code, all you have to do is replace the body of that function
    with the new implementation, and you're done! The rest of the software will automatically
    adapt, since it's just calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: Your code will be shorter, it will not suffer from inconsistencies between old
    and new ways of performing a task, or undetected bugs due to copy and paste failures
    or oversights. Use functions, and you'll only gain from it, I promise.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a complex task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are very useful also to split a long or complex task into smaller
    pieces. The end result is that the code benefits from it in several ways, for
    example, readability, testability, and reuse. To give you a simple example, imagine
    that you're preparing a report. Your code needs to fetch data from a data source,
    parse it, filter it, polish it, and then a whole series of algorithms needs to
    be run against it, in order to produce the results which will feed the `Report`
    class. It's not uncommon to read procedures like this that are just one big function
    `do_report(data_source)`. There are tens or hundreds of lines of code which end
    with `return report`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Situations like this are common in code produced by scientists. They have brilliant
    minds and they care about the correctness of the end result but, unfortunately,
    sometimes they have no training in programming theory. It is not their fault,
    one cannot know everything. Now, picture in your head something like a few hundred
    lines of code. It''s very hard to follow through, to find the places where things
    are changing context (like finishing one task and starting the next one). Do you
    have the picture in your mind? Good. Don''t do it! Instead, look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data.science.example.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous example is fictitious, of course, but can you see how easy it would
    be to go through the code? If the end result looks wrong, it would be very easy
    to debug each of the single data outputs in the `do_report` function. Moreover,
    it's even easier to exclude part of the process temporarily from the whole procedure
    (you just need to comment out the parts you need to suspend). Code like this is
    easier to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Hide implementation details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's stay with the preceding example to talk about this point as well. You
    can see that, by going through the code of the `do_report` function, you can get
    a pretty good understanding without reading one single line of implementation.
    This is because functions hide the implementation details. This feature means
    that, if you don't need to delve into details, you are not forced to, in the way
    you would if `do_report` was just one big fat function. In order to understand
    what was going on, you would have to read the implementation details. You don't
    need to with functions. This reduces the time you spend reading the code and since,
    in a professional environment, reading code takes much more time than actually
    writing it, it's very important to reduce it as much as we can.
  prefs: []
  type: TYPE_NORMAL
- en: Improve readability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coders sometimes don't see the point in writing a function with a body of one
    or two lines of code, so let's look at an example that shows you why you should
    do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you need to multiply two matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Improve readability](img/4715_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Would you prefer to have to read this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`matrix.multiplication.nofunc.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or would you prefer this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`matrix.multiplication.func.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It's much easier to understand that `c` is the result of the multiplication
    between `a` and `b` in the second example. It's much easier to read through the
    code and, if you don't need to modify that part, you don't even need to go into
    the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, readability is improved here while, in the first snippet, you would
    have to spend time trying to understand what that complicated list comprehension
    was doing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't worry if you don't understand *list comprehensions*, we'll study them
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Improve traceability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you have written an e-commerce website. You have displayed the
    product prices all over the pages. Imagine that the prices in your database are
    stored with no VAT, but you want to display them on the website with VAT at 20%.
    Here's a few ways of calculating the VAT-inclusive price from the VAT-exclusive
    price.
  prefs: []
  type: TYPE_NORMAL
- en: '`vat.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All these four different ways of calculating a VAT-inclusive price are perfectly
    acceptable, and I promise you I have found them all in my colleagues' code, over
    the years. Now, imagine that you have started selling your products in different
    countries and some of them have different VAT rates so you need to refactor your
    code (throughout the website) in order to make that VAT calculation dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: How do you trace all the places in which you are performing a VAT calculation?
    Coding today is a collaborative task and you cannot be sure the VAT has been calculated
    using only one of those forms. It's going to be hell, believe me.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's write a function that takes the input values, `vat` and `price` (VAT-exclusive),
    and returns a VAT-inclusive price.
  prefs: []
  type: TYPE_NORMAL
- en: '`vat.function.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now you can import that function and apply it in any place of your website where
    you need to calculate a VAT-inclusive price and when you need to trace those calls,
    you can search for `calculate_price_with_vat`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, in the preceding example, `price` is assumed to be VAT-exclusive,
    and `vat` has a percentage value (for example, 19, 20, 23, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Scopes and name resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you remember when we talked about scopes and namespaces in the first chapter?
    We're going to expand on that concept now. Finally, we can talk about functions
    and this will make everything easier to understand. Let's start with a very simple
    example.
  prefs: []
  type: TYPE_NORMAL
- en: '`scoping.level.1.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I have defined the name `test` in two different places in the previous example.
    It is actually in two different scopes. One is the global scope (`test = 0`),
    and the other is the local scope of the function `my_function` (`test = 1`). If
    you execute the code, you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s clear that `test = 1` shadows the assignment `test = 0` in `my_function`.
    In the global context, `test` is still `0`, as you can see from the output of
    the program but we define the name `test` again in the function body, and we set
    it to point to an integer of value `1`. Both the two `test` names therefore exist,
    one in the global scope, pointing to an `int` object with value 0, the other in
    the `my_function` scope, pointing to an `int` object with value 1\. Let''s comment
    out the line with `test = 1`. Python goes and searches for the name `test` in
    the next enclosing namespace (recall the *LEGB* rule: *Local*, *Enclosing*, *Global*,
    *Built-in* described in [Chapter 1](ch01.html "Chapter 1. Introduction and First
    Steps – Take a Deep Breath"), *Introduction and First Steps – Take a Deep Breath*)
    and, in this case, we will see the value `0` printed twice. Try it in your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s raise the stakes here and level up:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scoping.level.2.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have two levels of shadowing. One level is in the
    function `outer`, and the other one is in the function `inner`. It is far from
    rocket science, but it can be tricky. If we run the code, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Try commenting out the line `test = 1`. What do you think the result will be?
    Well, when reaching the line `print('outer:', test)`, Python will have to look
    for `test` in the next enclosing scope, therefore it will find and print `0`,
    instead of `1`. Make sure you comment out `test = 2` as well, to see if you understand
    what happens, and if the LEGB rule is clear, before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that Python gives you the ability to define a function
    in another function. The inner function's name is defined within the namespace
    of the outer function, exactly as would happen with any other name.
  prefs: []
  type: TYPE_NORMAL
- en: The global and nonlocal statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going back to the preceding example, we can alter what happens to the shadowing
    of the test name by using one of these two special statements: `global` and `nonlocal`.
    As you can see from the previous example, when we define `test = 2` in the function
    `inner`, we overwrite `test` neither in the function `outer`, nor in the global
    scope. We can get read access to those names if we use them in a nested scope
    that doesn''t define them, but we cannot modify them because, when we write an
    assignment instruction, we''re actually defining a new name in the current scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we change this behavior? Well, we can use the `nonlocal` statement.
    According to the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The `nonlocal` statement causes the listed identifiers to refer to previously
    bound variables in the nearest enclosing scope excluding globals."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s introduce it in the function `inner`, and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scoping.level.2.nonlocal.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how in the body of the function `inner` I have declared the `test` name
    to be `nonlocal`. Running this code produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Wow, look at that result! It means that, by declaring `test` to be `nonlocal`
    in the function `inner`, we actually get to bind the name `test` to that declared
    in the function `outer`. If we removed the `nonlocal` `test` line from the function
    `inner` and tried the same trick in the function `outer`, we would get a `SyntaxError`,
    because the `nonlocal` statement works on enclosing scopes excluding the global
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a way to get to that `test = 0` in the global namespace then? Of course,
    we just need to use the `global` statement. Let's try it.
  prefs: []
  type: TYPE_NORMAL
- en: '`scoping.level.2.global.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have now declared the name `test` to be `global`, which will basically
    bind it to the one we defined in the global namespace (`test = 0`). Run the code
    and you should get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the name affected by the assignment `test = 2` is now the `global`
    one. This trick would also work in the `outer` function because, in this case,
    we're referring to the global scope. Try it for yourself and see what changes,
    get comfortable with scopes and name resolution, it's very important.
  prefs: []
  type: TYPE_NORMAL
- en: Input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw that a function can take input parameters.
    Before we delve into all possible type of parameters, let''s make sure you have
    a clear understanding of what passing a parameter to a function means. There are
    three key points to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Argument passing is nothing more than assigning an object to a local variable
    name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning an object to an argument name inside a function doesn't affect the
    caller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a mutable object argument in a function affects the caller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at an example for each of these points.
  prefs: []
  type: TYPE_NORMAL
- en: Argument passing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a look at the following code. We declare a name `x` in the global scope,
    then we declare a function `func(y)` and we call it, passing `x`. I highlighted
    the call in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '`key.points.argument.passing.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When `func` is called with `x`, what happens is that within its local scope,
    a name `y` is created, and it''s pointed to the same object `x` is pointing to.
    This is better clarified by the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Argument passing](img/4715_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The right part of the preceding picture depicts the state of the program when
    execution has reached the end, after `func` has returned (`None`). Take a look
    at the **Frames** column, and note that we have two names, **x** and **func**,
    in the global namespace (**Global frame)**, pointing to an **int** (with a value
    of three) and to a function object, respectively. Right below it, in the rectangle
    titled **func**, we can see the function''s local namespace, in which only one
    name has been defined: **y**. Because we have called **func** with **x** (line
    5 in the left part of the picture), **y** is pointing to the same object that
    **x** is pointing to. This is what happens under the hood when an argument is
    passed to a function. If we had used the name **x** instead of **y** in the function
    definition, things would have been exactly the same (only maybe a bit confusing
    at first), there would be a local **x** in the function, and a global **x** outside,
    as we saw in the *Scopes and name resolution* section.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in a nutshell, what really happens is that the function creates in its local
    scope the names defined as arguments and, when we call it, we basically tell Python
    which objects those names must be pointed towards.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment to argument names don't affect the caller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is something that can be tricky to understand at first, so let's look at
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: '`key.points.assignment.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, when the line `x = 7` is executed, what happens is that
    within the local scope of the function `func`, the name `x` is pointed to an integer
    with value 7, leaving the global `x` unaltered.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a mutable affects the caller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the final point, and it''s very important because Python apparently
    behaves differently with mutables (just apparently though). Let''s look at an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key.points.mutable.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Wow, we actually changed the original object! If you think about it, there is
    nothing weird in this behavior. The name `x` in the function is set to point to
    the caller object by the function call and within the body of the function, we're
    not changing `x`, in that we're not changing its reference, or, in other words,
    we are not changing the object `x` is pointing to. What we're doing is accessing
    that object's element at position 1, and changing its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember point #2: "*Assigning an object to an argument name within a function
    doesn''t affect the caller*". If that is clear to you, the following code should
    not be surprising.'
  prefs: []
  type: TYPE_NORMAL
- en: '`key.points.mutable.assignment.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the two lines I have highlighted. At first, we just access the
    caller object again, at position 1, and change its value to number 42\. Then,
    we reassign `x` to point to the string `''something else''`. This leaves the caller
    unaltered, according to point #2, and, in fact, the output is the same as that
    of the previous snippet.'
  prefs: []
  type: TYPE_NORMAL
- en: Take your time to play around with this concept and experiment with prints and
    calls to the `id` function until everything is clear in your mind. This is one
    of the key aspects of Python and it must be very clear, otherwise you risk introducing
    subtle bugs into your code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good understanding of input parameters and how they behave,
    let's see how we can specify them.
  prefs: []
  type: TYPE_NORMAL
- en: How to specify input parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are five different ways of specifying input parameters. Let's look at
    them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Positional arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Positional arguments are read from left to right and they are the most common
    type of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.positional.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There is not much else to say. They can be as numerous as you want and they
    are assigned by position. In the function call, `1` comes first, `2` comes second
    and `3` comes third, therefore they are assigned to `a`, `b` and `c` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword arguments and default values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Keyword arguments** are assigned by keyword using the `name=value` syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.keyword.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Keyword arguments act when calling the function instead of respecting the left-to-right
    positional assignment, k. Keyword arguments are matched by name, even when they
    don't respect the definition's original position (we'll see that there is a limitation
    to this behavior later, when we mix and match different types of arguments).
  prefs: []
  type: TYPE_NORMAL
- en: The counterpart of keyword arguments, on the definition side, is **default values**.
    The syntax is the same, `name=value`, and allows us to not have to provide an
    argument if we are happy with the given default.
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.default.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The are two things to notice, which are very important. First of all, you cannot
    specify a default argument on the left of a positional one. Second, note how in
    the examples, when an argument is passed without using the `argument_name=value`
    syntax, it must be the first one in the list,, and it is always assigned to `a`.
    Try and scramble those arguments and see what happens. Python error messages are
    very good at telling you what''s wrong. So, for example, if you tried something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You would get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This informs you that you've called the function incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Variable positional arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you may want to pass a variable number of positional arguments to
    a function and Python provides you with the ability to do it. Let's look at a
    very common use case, the `minimum` function. This is a function that calculates
    the minimum of its input values.
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.variable.positional.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we specify a parameter prepending a `*` to its name, we
    are telling Python that that parameter will be collecting a variable number of
    positional arguments, according to how the function is called. Within the function,
    `n` is a tuple. Uncomment the `print(n)` to see for yourself and play around with
    it for a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you noticed how we checked if `n` wasn't empty with a simple `if n:`? This
    is due to the fact that collection objects evaluate to `True` when non-empty,
    and otherwise `False` in Python. This is true for tuples, sets, lists, dictionaries,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One other thing to note is that we may want to throw an error when we call the
    function with no arguments, instead of silently doing nothing. In this context,
    we're not concerned about making this function robust, but in understanding variable
    positional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make another example to show you two things that, in my experience, are
    confusing to those who are new to this.
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.variable.positional.unpacking.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a good look at the last two lines of the preceding example. In the first
    one, we call `func` with one argument, a four elements tuple. In the second example,
    by using the `*` syntax, we''re doing something called **unpacking**, which means
    that the four elements tuple is unpacked, and the function is called with four
    arguments: `1, 3, -7, 9`.'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is part of the magic Python does to allow you to do amazing things
    when calling functions dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Variable keyword arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variable keyword arguments are very similar to variable positional arguments.
    The only difference is the syntax (`**` instead of `*`) and that they are collected
    in a dictionary. Collection and unpacking work in the same way, so let''s look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.variable.keyword.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All the calls are equivalent in the preceding example. You can see that adding
    a `**` in front of the parameter name in the function definition tells Python
    to use that name to collect a variable number of keyword parameters. On the other
    hand, when we call the function, we can either pass `name=value` arguments explicitly,
    or unpack a dictionary using the same `**` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why being able to pass a variable number of keyword parameters is
    so important may not be evident at the moment, so, how about a more realistic
    example? Let's define a function that connects to a database. We want to connect
    to a default database by simply calling this function with no parameters. We also
    want to connect to any other database by passing the function the appropriate
    arguments. Before you read on, spend a couple of minutes figuring out a solution
    by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.variable.db.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note in the function we can prepare a dictionary of connection parameters (`conn_params`)
    in the function using default values as fallback, allowing them to be overwritten
    if they are provided in the function call. There are better ways to do this with
    fewer lines of code but we''re not concerned with that now. Running the preceding
    code yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note the correspondence between the function calls and the output. Note how
    default values are either there or overridden, according to what was passed to
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword-only arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python 3 allows for a new type of parameter: the **keyword-only** parameter.
    We are going to study them only briefly as their use cases are not that frequent.
    There are two ways of specifying them, either after the variable positional arguments,
    or after a bare *. Let''s see an example of both.'
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.keyword.only.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As anticipated, the function, `kwo`, takes a variable number of positional arguments
    (`a`) and a keyword-only function, `c`. The results of the calls are straightforward
    and you can uncomment the third call to see what error Python returns.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to the function, `kwo2`, which differs from `kwo` in that it
    takes a positional argument `a`, a keyword argument `b`, and then a keyword-only
    argument, `c`. You can uncomment the third call to see the error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to specify different types of input parameters, let's
    see how you can combine them in function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Combining input parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can combine input parameters, as long as you follow these ordering rules:'
  prefs: []
  type: TYPE_NORMAL
- en: When defining a function, normal positional arguments come first (`name`), then
    any default arguments (`name=value`), then the variable positional arguments (`*name`,
    or simply `*`), then any keyword-only arguments (either `name` or `name=value`
    form is good), then any variable keyword arguments (`**name`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, when calling a function, arguments must be given in the
    following order: positional arguments first (`value`), then any combination of
    keyword arguments (`name=value`), variable positional arguments (`*name`), then
    variable keyword arguments (`**name`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this can be a bit tricky when left hanging in the theoretical world, let's
    look at a couple of quick examples.
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.all.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the order of the parameters in the function definition, and that the two
    calls are equivalent. In the first one, we''re using the unpacking operators for
    iterables and dictionaries, while in the second one we''re using a more explicit
    syntax. The execution of this yields (I printed only the result of one call):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's now look at an example with keyword-only arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.all.kwonly.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that I have highlighted the keyword-only arguments in the function declaration.
    They come after the variable positional argument `*args`, and it would be the
    same if they came right after a single `*` (in which case there wouldn''t be a
    variable positional argument). The execution of this yields (I printed only the
    result of one call):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'One other thing to note are the names I gave to the variable positional and
    keyword arguments. You''re free to choose differently, but be aware that `args`
    and `kwargs` are the conventional names given to these parameters, at least generically.
    Now that you know how to define a function in all possible flavors, let me show
    you something tricky: mutable defaults.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid the trap! Mutable defaults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One thing to be very aware of with Python is that default values are created
    at `def` time, therefore, subsequent calls to the same function will possibly
    behave differently according to the mutability of their default values. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.defaults.mutable.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters both have mutable default values. This means that, if you affect
    those objects, any modification will stick around in subsequent function calls.
    See if you can understand the output of those calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It's interesting, isn't it? While this behavior may seem very weird at first,
    it actually makes sense, and it's very handy, for example, when using memoization
    techniques (Google an example of that, if you're interested).
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more interesting is what happens when, between the calls, we introduce
    one that doesn''t use defaults, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.defaults.mutable.intermediate.call.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This output shows us that the defaults are retained even if we call the function
    with other values. One question that comes to mind is, how do I get a fresh empty
    value every time? Well, the convention is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments.defaults.mutable.no.trap.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that, by using the preceding technique, if `a` isn't passed when calling
    the function, you always get a brand new empty list.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, enough with the input, let's look at the other side of the coin, the output.
  prefs: []
  type: TYPE_NORMAL
- en: Return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Return values of functions are one of those things where Python is light years
    ahead of most other languages. Functions are usually allowed to return one object
    (one value) but, in Python, you can return a tuple, and this implies that you
    can return whatever you want. This feature allows a coder to write software that
    would be much harder to write in any other language, or certainly more tedious.
    We've already said that to return something from a function we need to use the
    `return` statement, followed by what we want to return. There can be as many return
    statements as needed in the body of a function.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if within the body of a function we don't return anything,
    the function will return `None`. This behavior is harmless and, even though I
    don't have the room here to go into detail explaining why Python was designed
    like this, let me just tell you that this feature allows for several interesting
    patterns, and confirms Python as a very consistent language.
  prefs: []
  type: TYPE_NORMAL
- en: 'I say it''s harmless because you are never forced to collect the result of
    a function call. I''ll show you what I mean with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`return.none.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that the whole body of the function is comprised only of the `pass` statement.
    As the official documentation tells us, `pass` is a null operation. When it is
    executed, nothing happens. It is useful as a placeholder when a statement is required
    syntactically, but no code needs to be executed. In other languages, we would
    probably just indicate that with a pair of curly braces (`{}`), which define an
    *empty scope* but in Python a scope is defined by indenting code, therefore a
    statement such as `pass` is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that the first call of the function `func` returns a value (`None`)
    which we don't collect. As I said before, collecting the return value of a function
    call is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, that''s good but not very interesting so, how about we write an interesting
    function? Remember that in [Chapter 1](ch01.html "Chapter 1. Introduction and
    First Steps – Take a Deep Breath"), *Introduction and First Steps – Take a Deep
    Breath*, we talked about the factorial of a function. Let''s write our own here
    (for simplicity, I will assume the function is always called correctly with appropriate
    values so I won''t sanity-check on the input argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '`return.single.value.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have two points of return. If `n` is either `0` or `1` (in Python
    it's common to use the `in` type of check as I did instead of the more verbose
    `if n ==0 or n == 1:`), we return `1`. Otherwise, we perform the required calculation,
    and we return `result`. Can we write this function a little bit more Pythonically?
    Yes, but I'll let you figure out that for yourself, as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '`return.single.value.2.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: I know what you're thinking, one line? Python is elegant, and concise! I think
    this function is readable even if you have never seen `reduce` or `mul`, but if
    you can't read it or understand it, set aside a few minutes and do some research
    on the Python documentation until its behavior is clear to you. Being able to
    look up functions in the documentation and understand code written by someone
    else is a task every developer needs to be able to perform, so think of this as
    a good exercise, and good luck!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To this end, make sure you look up the `help` function, which comes in very
    handy exploring with the console.
  prefs: []
  type: TYPE_NORMAL
- en: Returning multiple values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike in most other languages, in Python it''s very easy to return multiple
    objects from a function. This feature opens up a whole world of possibilities
    and allows you to code in a style that is hard to reproduce with other languages.
    Our thinking is limited by the tools we use, therefore when Python gives you more
    freedom than other languages, it is actually boosting your own creativity as well.
    To return multiple values is very easy, you just use tuples (either explicitly
    or implicitly). Let''s look at a simple example that mimics the `divmod` built-in
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`return.multiple.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: I could have wrapped the highlighted part in the preceding code in braces, making
    it an explicit tuple, but there's no need for that. The preceding function returns
    both the result and the remainder of the division, at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: A few useful tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing functions, it''s very useful to follow guidelines so that you
    write them well. I''ll quickly point some of them out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions should do one thing**: Functions that do one thing are easy to
    describe in one short sentence. Functions which do multiple things can be split
    into smaller functions which do one thing. These smaller functions are usually
    easier to read and understand. Remember the data science example we saw a few
    pages ago.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions should be small**: The smaller they are, the easier it is to test
    them and to write them so that they do one thing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The fewer input parameters, the better**: Functions which take a lot of arguments
    quickly become harder to manage (among other issues).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions should be consistent in their return values**: Returning `False`
    or `None` is not the same thing, even if within a Boolean context they both evaluate
    to `False`. `False` means that we have information (`False`), while `None` means
    that there is no information. Try writing functions which return in a consistent
    way, no matter what happens in their body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions shouldn''t have side effects**: In other words, functions should
    not affect the values you call them with. This is probably the hardest statement
    to understand at this point, so I''ll give you an example using lists. In the
    following code, note how `numbers` is not sorted by the `sorted` function, which
    actually returns a sorted copy of `numbers`. Conversely, the `list.sort()` method
    is acting on the `numbers` object itself, and that is fine because it is a method
    (a function that belongs to an object and therefore has the rights to modify it):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Follow these guidelines and you'll write better functions, which will serve
    you well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Functions* in *Clean Code* by Robert C. Martin, Prentice Hall
    is dedicated to functions and it''s probably the best set of guidelines I''ve
    ever read on the subject.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function calls itself to produce a result, it is said to be **recursive**.
    Sometimes recursive functions are very useful in that they make it easier to write
    code. Some algorithms are very easy to write using the recursive paradigm, while
    others are not. There is no recursive function that cannot be rewritten in an
    iterative fashion, so it's usually up to the programmer to choose the best approach
    for the case at hand.
  prefs: []
  type: TYPE_NORMAL
- en: A recursive function usually has a set of base cases for which the return value
    doesn't depend on a subsequent call to the function itself and a set of recursive
    cases, for which the return value is calculated with one or more calls to the
    function itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can consider the (hopefully familiar by now) `factorial`
    function *N!*. The base case is when *N* is either 0 or 1\. The function returns
    1 with no need for further calculation. On the other hand, in the general case,
    *N!* returns the product *1 * 2 * ... * (N-1) * N*. If you think about it, *N!*
    can be rewritten like this: *N! = (N-1)! * N*. As a practical example, consider
    *5! = 1 * 2 * 3 * 4 * 5 = (1 * 2 * 3 * 4) * 5 = 4! * 5*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write this down in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`recursive.factorial.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When writing recursive functions, always consider how many nested calls you
    make, there is a limit. For further information on this, check out `sys.getrecursionlimit()`
    and `sys.setrecursionlimit()`.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions are used a lot when writing algorithms and they can be really
    fun to write. As a good exercise, try to solve a couple of simple problems using
    both a recursive and an iterative approach.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One last type of functions that I want to talk about are **anonymous** functions.
    These functions, which are called **lambdas** in Python, are usually used when
    a fully-fledged function with its own name would be overkill, and all we want
    is a quick, simple one-liner that does the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you want a list of all the numbers up to *N* which are multiples
    of five. Imagine that you want to filter those out using the `filter` function,
    which takes a function and an iterable and constructs a filter object which you
    can iterate on, from those elements of iterable for which the function returns
    `True`. Without using an anonymous function, you would do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter.regular.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'I have highlighted the main logic of `get_multiples_of_five`. Note how the
    filter uses `is_multiple_of_five` to filter the first *n* natural numbers. This
    seems a bit excessive, the task is simple and we don''t need to keep the `is_multiple_of_five`
    function around for anything else. Let''s rewrite it using a lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter.lambda.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is exactly the same but the filtering function is now a lambda. Defining
    a lambda is very easy and follows this form: `func_name = lambda [parameter_list]:
    expression`. A function object is returned, which is equivalent to this: `def
    func_name([parameter_list]): return expression`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that optional parameters are indicated following the common syntax of wrapping
    them in square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another couple of examples of equivalent functions defined in
    the two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lambda.explained.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding examples are very simple. The first one adds two numbers, and
    the second one produces the uppercase version of a string. Note that I assigned
    what is returned by the `lambda` expressions to a name (`adder_lambda`, `to_upper_lambda`),
    but there is no need for that when you use lambdas in the way we did in the `filter`
    example before.
  prefs: []
  type: TYPE_NORMAL
- en: Function attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every function is a fully-fledged object and, as such, they have many attributes.
    Some of them are special and can be used in an introspective way to inspect the
    function object at runtime. The following script is an example that shows all
    of them and how to display their value for an example function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func.attributes.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'I used the built-in `getattr` function to get the value of those attributes.
    `getattr(obj, attribute)` is equivalent to `obj.attribute` and comes in handy
    when we need to get an attribute at runtime using its string name. Running this
    script yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: I have omitted the value of the `__globals__` attribute, it was too big. An
    explanation of the meaning of this attribute can be found in the *types* section
    of the *Python Data Model* documentation page.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python comes with a lot of built-in functions. They are available anywhere and
    you can get a list of them by inspecting the `builtin` module with `dir(__builtin__)`,
    or by going to the official Python documentation. Unfortunately, I don't have
    the room to go through all of them here. Some of them we've already seen, such
    as `any`, `bin`, `bool`, `divmod`, `filter`, `float`, `getattr`, `id`, `int`,
    `len`, `list`, `min`, `print`, `set`, `tuple`, `type`, and `zip`, but there are
    many more, which you should read at least once.
  prefs: []
  type: TYPE_NORMAL
- en: Get familiar with them, experiment, write a small piece of code for each of
    them, make sure you have them at the tip of your fingers so that you can use them
    when you need them.
  prefs: []
  type: TYPE_NORMAL
- en: One final example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish off this chapter, how about a final example? I was thinking
    we could write a function to generate a list of prime numbers up to a limit. We've
    already seen the code for this so let's make it a function and, to keep it interesting,
    let's optimize it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that you don''t need to divide it by all numbers from 2 to *N*-1
    to decide if a number *N* is prime. You can stop at ![One final example](img/4715_04_04.jpg).
    Moreover, you don''t need to test the division for all numbers from 2 to ![One
    final example](img/4715_04_04.jpg), you can just use the primes in that range.
    I''ll leave it to you to figure out why this works, if you''re interested. Let''s
    see how the code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`primes.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The code is the same as in the previous chapter. We have changed the division
    algorithm so that we only test divisibility using the previously calculated primes
    and we stopped once the testing divisor was greater than the root of the candidate.
    We used the result list `primelist` to get the primes for the division. We calculated
    the root value using a fancy formula, the integer value of the ceiling of the
    root of the candidate. While a simple `int(k ** 0.5) + 1` would have served our
    purpose as well, the formula I chose is cleaner and requires me to use a couple
    of imports, which I wanted to show you. Check out the functions in the `math`
    module, they are very interesting!
  prefs: []
  type: TYPE_NORMAL
- en: Documenting your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm a big fan of code that doesn't need documentation. When you program correctly,
    choose the right names and take care of the details, your code should come out
    as self-explanatory and documentation should not be needed. Sometimes a comment
    is very useful though, and so is some documentation. You can find the guidelines
    for documenting Python in *PEP257 – Docstring conventions*, but I'll show you
    the basics here.
  prefs: []
  type: TYPE_NORMAL
- en: Python is documented with strings, which are aptly called **docstrings**. Any
    object can be documented, and you can use either one-line or multi-line docstrings.
    One-liners are very simple. They should not provide another signature for the
    function, but clearly state its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '`docstrings.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Using triple double-quoted strings allows you to expand easily later on. Use
    sentences that end in a period, and don't leave blank lines before or after.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-line comments are structured in a similar way. There should be a one-liner
    that briefly gives you the gist of what the object is about, and then a more verbose
    description. As an example, I have documented a fictitious `connect` function,
    using the Sphinx notation, in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sphinx** is probably the most widely used tool for creating Python documentation.
    In fact, the official Python documentation was written with it. It''s definitely
    worth spending some time checking it out.'
  prefs: []
  type: TYPE_NORMAL
- en: '`docstrings.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Importing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you know a lot about functions, let''s see how to use them. The whole
    point of writing functions is to be able to later reuse them, and this in Python
    translates to importing them into the namespace in which you need them. There
    are many different ways to import objects into a namespace, but the most common
    ones are just two: `import module_name` and `from module_name import function_name`.
    Of course, these are quite simplistic examples, but bear with me for the time
    being.'
  prefs: []
  type: TYPE_NORMAL
- en: The form `import module_name` finds the module `module_name` and defines a name
    for it in the local namespace where the `import` statement is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The form `from module_name import identifier` is a little bit more complicated
    than that, but basically does the same thing. It finds `module_name` and searches
    for an attribute (or a submodule) and stores a reference to `identifier` in the
    local namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both forms have the option to change the name of the imported object using
    the `as` clause, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to give you a flavor of what importing looks like, here''s an example
    from a test module of a number theory library I wrote some years ago (it''s available
    on Bitbucket):'
  prefs: []
  type: TYPE_NORMAL
- en: '`karma/test_nt.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'I commented some of them and I hope it''s easy to follow. When you have a structure
    of files starting in the root of your project, you can use the dot notation to
    get to the object you want to import into your current namespace, be it a package,
    a module, a class, a function, or anything else. The `from module import` syntax
    also allows a catch-all clause `from module import *`, which is sometimes used
    to get all the names from a module into the current namespace at once, but it''s
    frowned upon for several reasons: performances, the risk of silently shadowing
    other names, and so on. You can read all that there is to know about imports in
    the official Python documentation but, before we leave the subject, let me give
    you a better example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have defined a couple of functions: `square(n)` and `cube(n)`
    in a module, `funcdef.py`, which is in the `lib` folder. You want to use them
    in a couple of modules which are at the same level of the `lib` folder, called
    `func_import.py`, and `func_from.py`. Showing the tree structure of that project
    produces something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Before I show you the code of each module, please remember that in order to
    tell Python that it is actually a package, we need to put a `__init__.py` module
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two things to note about the `__init__.py` file. First of all, it
    is a fully fledged Python module so you can put code into it as you would with
    any other module. Second, as of Python 3.3, its presence is no longer required
    to make a folder be interpreted as a Python package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`funcdef.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`func_import.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`func_from.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Both these files, when executed, print `100` and `1000`. You can see how differently
    we then access the `square` and `cube` functions, according to how and what we
    imported in the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: Relative imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The imports we''ve seen until now are called absolute, that is to say they
    define the whole path of the module that we want to import, or from which we want
    to import an object. There is another way of importing objects into Python, which
    is called relative import. It''s helpful in situations in which we want to rearrange
    the structure of large packages without having to edit sub-packages, or when we
    want to make a module inside a package able to import itself. Relative imports
    are done by adding as many leading dots in front of the module as the number of
    folders we need to backtrack, in order to find what we''re searching for. Simply
    put, it is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: For a complete explanation of relative imports, refer to **PEP328** ([https://www.python.org/dev/peps/pep-0328](https://www.python.org/dev/peps/pep-0328)).
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we'll create projects using different libraries and we'll
    use several different types of imports, including relative ones, so make sure
    you take a bit of time to read up about it in the official Python documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, finally we explored the world of functions. They are extremely
    important and, from now on, we'll use them basically everywhere. We talked about
    the main reasons for using them, the most important of which are code reuse and
    implementation hiding.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that a function object is like a box that takes optional input and produces
    output. We can feed input values to a function in many different ways, using positional
    and keyword arguments, and using variable syntax for both types.
  prefs: []
  type: TYPE_NORMAL
- en: Now you should know how to write a function, how to document it, import it into
    your code, and call it.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will force me to push my foot down on the throttle even more
    so I suggest you take any opportunity you get to consolidate and enrich the knowledge
    you've gathered until now by putting your nose into the Python official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Ready for the cool stuff? Let's go!
  prefs: []
  type: TYPE_NORMAL
