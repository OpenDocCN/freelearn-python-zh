- en: Chapter 6. Working with Analog Inputs and Local Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with analog inputs to transform quantitative
    values retrieved from the real environment into qualitative values that we will
    use to fire actions. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand how analog inputs work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the impact of the resolution of analog to digital converters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure a voltage with an analog pin and the `mraa` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include a photoresistor in a voltage divider and wire an analog input pin with
    a voltage source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform a variable resistor into a voltage source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the darkness level with analog input and the `mraa` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fire actions when the environment light changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control analog inputs with the wiring-x86 library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with different local storage options to log events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the analog inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Understanding and Setting up the Base IoT
    Hardware"), *Understanding and Setting up the Base IoT Hardware*, we learned that
    the Intel Galileo Gen 2 board provides six analog input pins numbered from **A0**
    to **A5** and located in the lower-right corner of the front-side of the board.
    It is possible to measure from 0V (ground) to the value configured with the **IOREF**
    jumper position (5V by default) and the board provides 12 bits of resolution for
    the analog to digital converter. Thus, we can detect 4096 different values (212
    = 4096), or 4096 units, with values ranging from zero to 4095 (inclusive), where
    0 represents 0V and 4095 means 5V.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you have an experience with other Arduino boards, you must take into
    account that the Intel Galileo Gen 2 board does not use the pin labeled **AREF**.
    In other Arduino boards, you can use this pin to set the analog reference voltage
    for the analog to digital conversion process. When we work with the Intel Galileo
    Gen 2 board, the maximum value for the analog pins is always going to be controlled
    by the **IOREF** jumper position (5V or 3.3V) and it is not possible to use any
    external reference for an analog input. In all our examples, we will work with
    the default position for the **IOREF** jumper, and therefore, the maximum value
    will be always 5V.
  prefs: []
  type: TYPE_NORMAL
- en: We just need to apply a linear function to convert the raw values read from
    the analog pin and map them to the input voltage values. If we use 12 bits of
    resolution, the detected values will have a minimum difference or step of 5V /
    4095 = 0.001220012 V, approximately 1.22 mV (milliVolts) or 1.22E-03 V. We just
    need to multiply the raw value read from the analog pin by five and divide it
    by 4095.
  prefs: []
  type: TYPE_NORMAL
- en: The following graph shows the read values from an analog pin in the abscissa
    axis (*x*-axis) and the corresponding floating-point voltage value that it represents
    in the ordinate axis (*y*-axis).
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the analog inputs](img/B05042_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The equation for the previous graph is `y = x / 4095 * 5`, specifically `voltage_value
    = analog_pin_read_value / 4095 * 5`. We can run the following code in our Python
    interpreter to see the output with all the voltage values that can be generated
    with the formula for each raw value read from the analog pin from `0` to `4095`
    (inclusive).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also work with a lower resolution, such as 10 bits of resolution and
    we would be able to detect less different values, specifically 1024 different
    values (2^(10) = 1024), or 1024 units, from 0 to 1023 (inclusive). In this case,
    the values will have a minimum difference or step of 5V / 1023 = 0.004887585V,
    approximately 4.89mV (milliVolts) or 4.89E-03 V. In case we decide to work with
    this lower resolution, we just need to multiply the raw value read from the analog
    pin by five and divide it by 1023.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring an analog input pin with a voltage source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to understand how to read the values from analog pins and map
    these values back to voltage values is to work with a very simple example. We
    will connect a power source to one of the analog input pins, specifically a pack
    with two AA or AAA 1.25 V rechargeable batteries in series. It is also possible
    to use AA or AAA 1.5 V standard batteries in series. Note that the maximum voltage
    with the two rechargeable batteries in series will be 2.5 V (1.25 V * 2), while
    the maximum voltage with the two standard batteries in series will be 3 V (1.5
    V * 2).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the analog pin labeled **A0** to connect to the positive side (+)
    of the battery pack. Don''t forget that the positive side (+) of the batter pack
    is connected to the battery''s nipple. After we finish the necessary wirings,
    we will write Python code to measure the batteries pack voltage. This way, we
    will read the result of converting an analog value to its digital representation
    and we will map it to the voltage value. We need the following parts to work with
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: Two AA or AAA 1.25 V rechargeable batteries or two AA or AAA 1.5 V standard
    batteries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An appropriate battery holder to plug the two selected batteries in series and
    simplify wirings. For example, in case you use two AA 1.25 rechargeable batteries,
    you will need a 2 x AA battery holder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 2200Ω (2k2Ω) resistor with 5% tolerance (red red red gold).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows the battery holder, the resistor connected to the
    breadboard, the necessary wirings, and the wirings from the Intel Galileo Gen
    2 board to the breadboard. The Fritzing file for the sample is `iot_fritzing_chapter_06_01.fzz`
    and the following image is the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring an analog input pin with a voltage source](img/B05042_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following schematic shows the schematic with the electronic components
    represented as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring an analog input pin with a voltage source](img/B05042_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the previous schematic, the analog input pin labeled **A0** in the
    board's symbol, is connected to the positive terminal of the power source through
    the resistor. The negative terminal of the power source is connected to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring voltage with analog inputs and the mraa library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new `VoltageInput` class to represent a voltage source connected
    to our board, specifically, to an analog input pin. The following lines show the
    code for the new `VoltageInput` class that works with the `mraa` library. The
    code file for the sample is `iot_python_chapter_06_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify the analog pin number to which the voltage source is connected
    when we create an instance of the `VoltageInput` class in the `analog_pin` required
    argument. The constructor, that is, the `__init__` method, creates a new `mraa.Aio`
    instance with the received `analog_pin` as its `pin` argument, saves its reference
    in the `aio` attribute and calls its `setBit` method to configure the analog to
    digital converter resolution to be of 12 bits, that is, to provide 4096 possible
    values to represent from 0 to 5V.
  prefs: []
  type: TYPE_NORMAL
- en: The class defines a `voltage` property that calls the `read` method for the
    related `mraa.Aio` instance (`self.aio`) to retrieve the raw value from the analog
    pin and saves it in the `raw_value` variable. Then, the code returns the result
    of dividing `raw_value` by `4095` and multiplying it by `5`. This way, the property
    returns the voltage value, converted from the raw value returned by the read function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can write code that uses the new `VoltageInput` class to create an instance
    for the battery pack and easily retrieve the voltage value. The new class makes
    the necessary calculations to map the read value into a voltage value, and therefore,
    we just need to check the value of the `voltage` property without worrying about
    the specific details about the analog to digital converter and its resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will write a loop that will retrieve the voltage value every second.
    The code file for the sample is `iot_python_chapter_06_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates an instance of the previously coded `VoltageInput` class
    with `0` as the value of the `analog_pin` argument. This way, the instance will
    read the analog values from the pin labeled **A0**, that is connected to the positive
    terminal of the power source through the resistor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code runs a loop forever, that is, until you interrupt the execution
    by pressing *Ctrl* + *C* or the button to stop the process in case you are using
    a Python IDE with remote development features to run the code in your board. The
    loop prints the voltage value at pin **A0** every two seconds. The following lines
    show a sample output line generated when the code is executed with two rechargeable
    batteries that have lost a bit of their charge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Wiring a photoresistor to an analog input pin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will use a photoresistor, that is, a light sensor, specifically, an
    electronic component that provides a variable resistor that changes the resistor
    value based on the incident light intensity. As the incident light intensity increases,
    the resistance of the photoresistor decreases, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A photoresistor is also known as an **LDR** (short for **Light-Dependent Resistor**)
    or photocell. Bear in mind that pohotoresistors are not the best components to
    sense light with great accuracy. However, they are extremely useful to easily
    determine whether we are in a dark environment when we don't have problems with
    latencies that can reach one second.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot measure a resistance value with our board. However, we can read voltage
    values, and therefore, we will use a voltage divider configuration that will include
    the photoresistor as one of its two resistors. The voltage divider will output
    a high voltage value when the photoresistor receives a high amount of light and
    it will output a low voltage value when the photoresistor is in a dark zone, that
    is, when it receives little or no light at all.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to read values from analog pins and map these values back to
    voltage values in the previous examples. We will use this knowledge to determine
    when it becomes dark using the photoresistor. Once we understand how the sensor
    works, we will react to the changes in the light conditions and we will log data
    about specific scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the analog pin labeled **A0** to connect the positive side (+)
    of the voltage divider that includes a photoresistor. After we finish the necessary
    wirings, we will write Python code to determine whether we are in a dark environment
    or not. This way, we will read the result of converting a resistance value into
    a voltage, and then converting this analog value into its digital representation.
    As we learned in our previous example, we will map the read digital value to a
    voltage value and then we will map this voltage value to a darkness measurement
    value. It sounds like a big mess, but it is really easier than it sounds. We need
    the following parts to work with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: A photoresistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 10,000Ω (10kΩ) resistor with 5% tolerance (brown black orange gold)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the photoresistor and the resistor connected to
    the breadboard, the necessary wirings and the wirings from the Intel Galileo Gen
    2 board to the breadboard. The Fritzing file for the sample is `iot_fritzing_chapter_06_02.fzz`
    and the following picture is the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a photoresistor to an analog input pin](img/B05042_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a photoresistor to an analog input pin](img/B05042_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the previous schematic, the GPIO pin labeled **A0** in the board's
    symbol is connected to the voltage divider built with the photoresistor named
    **LDR1** and a 10kΩ resistor with 5% tolerance named **R1**. The **LDR1** photoresistor
    is wired to the **IOREF** pin. We already know that the pin labeled **IOREF**
    provides us the IOREF voltage, that is, 5V in our actual configuration. The **R1**
    resistor is wired to **GND** (ground).
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the darkness level with analog inputs and the mraa library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new `DarknessSensor` class to represent the photoresistor included
    in the voltage divider and connected to our board, specifically, to an analog
    input pin. As we already wrote code to read and transform an analog input, we
    will use the previously created `VoltageInput` class. The following lines show
    the code for the new `DarknessSensor` class that works with the `mraa` library.
    The code file for the sample is `iot_python_chapter_06_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to specify the analog pin number to which the voltage divider, which
    includes the photoresistor, is connected when we create an instance of the `DarknessSensor`
    class in the `analog_pin` required argument. The constructor, that is, the `__init__`
    method, creates a new `VoltageInput` instance with the received `analog_pin` as
    its `analog_pin` argument and saves its reference in the `voltage_input` attribute.
    Then, the constructor creates and initializes two attributes: `voltage` and `ambient_light`.
    Finally, the constructor calls the `measure_light` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The class defines a `measure_light` method that saves the voltage value retrieved
    by checking the `self.voltage_input.voltage` property in the `voltage` attribute
    (`self.voltage`). This way, the code can check whether the value stored in the
    voltage attribute is lower than the three maximum voltage values that determine
    the light level and sets the appropriate value for the `ambient_light` attribute
    (`self.ambient_light`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The class defines the following three class attributes that determine the maximum
    voltage values that determine each light level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`extremely_dark_max_voltage`: If the retrieved voltage is lower than 2V, it
    means that the environment is extremely dark'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`very_dark_max_voltage`: If the retrieved voltage is lower than 3V, it means
    that the environment is very dark'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dark_max_voltage`. If the retrieved voltage is lower than 4V, it means that
    the environment is just dark'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The values are configured for a specific photoresistor and environment conditions.
    You might need to set different values based on the voltage values retrieved with
    the photoresistor included in the voltage divider. Once you run the sample, you
    can check the voltage values and make the necessary adjustments to the voltage
    values stored in the previously explained class attributes. Remember that the
    voltage value will be higher, that is, closer to 5V, when the incident light increases.
    Thus, the darkest environment, the lower the measured voltage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to convert a quantitative value, specifically, a voltage value,
    into a qualitative value, that is, a value that explains the real situation in
    a real environment. The class defines the following four class attributes that
    specify the light level descriptions and determine one of the four light levels
    in which a voltage value will be converted after we call the `measure_light` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`light_extremely_dark`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`light_very_dark`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`light_dark`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`light_no_need_for_a_flashlight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can write the code that uses the new `DarkSensor` class to create an
    instance for the photoresistor included in the voltage divider and easily print
    a description of the light conditions. The new class uses the previously created
    `VoltageInput` class to make the necessary calculations to map the read value
    into a voltage value, and then, transforms it into a qualitative value that provides
    us with a description of the light conditions. Now, we will write a loop that
    will check whether the light conditions changed every two seconds. The code file
    for the sample is `iot_python_chapter_06_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates an instance of the previously coded `DarknessSensor`
    class with `0` as the value of the `analog_pin` argument and saves the instance
    in the `darkness_sensor` local variable. This way, the instance will use an instance
    of the `VoltageInput` class to read the analog values from the pin labeled **A0**.
    Then, the code initializes the `last_ambient_light` local variable with an empty
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code runs a loop forever, that is, until you interrupt the execution
    by pressing *Ctrl* + *C* or the button to stop the process in case you are using
    a Python IDE with remote development features to run the code in your board. The
    loop calls the `darkness_sensor.measure_light` method to retrieve the current
    light conditions and saves the updated `darkness_sensor.ambient_light` value in
    the `new_ambient_light` local variable. Then, the code checks whether the `new_ambient_light`
    value is different from `last_ambient_light`. In case they are different, it means
    that the ambient light has changed, and therefore, it sets the value for `last_ambient_light`
    equal to `new_ambient_light`, and prints the ambient light description stored
    in `new_ambient_light`.
  prefs: []
  type: TYPE_NORMAL
- en: The loop prints the ambient light description only when it changes from the
    last printed value, and checks the ambient light every two seconds. The following
    line will start the example. Don't forget that you need to transfer the Python
    source code file to the Yocto Linux with an SFTP client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the example, perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a smartphone or a flashlight to induce light over the photoresistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use your hand to generate a shadow over the photoresistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the light in the environment, but not the minimum, just make it a bit
    dark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the light in the environment to the minimum, a complete dark environment
    with no light at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a result of the previous actions, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Firing actions when the environment light changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous examples, we worked with PWM to set the brightness level for the
    red, green, and blue components of an RGB LED. Now, we will add an RGB LED and
    we will set the brightness level for its three components based on the ambient
    light detected with the photoresistor. We will wire the RGB LED as we did in the
    example in which we worked with this component in [Chapter 4](ch04.html "Chapter 4. Working
    with a RESTful API and Pulse Width Modulation"), *Working with a RESTful API and
    Pulse Width Modulation*. We will use the following PWM output pins:'
  prefs: []
  type: TYPE_NORMAL
- en: Pin **~6** to connect the anode pin for red LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin **~5** to connect the anode pin for green LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin **~3** to connect the anode pin for blue LED.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need the following additional parts to work with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: One common cathode 5mm RGB LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three 270Ω resistors with 5% tolerance (red violet brown gold)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_06_03.fzz` and the following
    picture is the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Firing actions when the environment light changes](img/B05042_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Firing actions when the environment light changes](img/B05042_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the previous schematic, three PWM capable GPIO pins labeled **D3
    PWM**, **D5 PWM**, and **D6 PWM** in the board's symbol is connected to a 270Ω
    resistor, wired to an anode pin for each LED color, and the common cathode is
    connected to ground.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to insert the components in the breadboard and make all the
    necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the
    onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen
    2 board before adding or removing any wire from the board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: We will add the code for the `AnalogLed` class that represent an LED connected
    to our board that can have a brightness level from 0 to 255 inclusive. We created
    this class in [Chapter 4](ch04.html "Chapter 4. Working with a RESTful API and
    Pulse Width Modulation"), W*orking with a RESTful API and Pulse Width Modulation*
    and the code file for the sample was `iot_python_chapter_04_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new `BoardInteraction` class to create an instance of our
    `DarknessSensor` class and one instance for each component of the RGB LED and
    easily control their brightness levels. The following lines show the code for
    the `BoardInteraction` class. The code file for the sample is `iot_python_chapter_06_03.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BoardInteraction` class declares four class attributes: `darkness_sensor`,
    `red_led`, `green_led` and `blue_led`. The first class attribute saves a new instance
    of the `DarknessSensor` class and the last three class attributes save new instances
    of the previously imported `AnalogLed` class and represent the red, green, and
    blue LEDs connected to pins **~6**, **~5**, and **~3**. Then, the `BoardInteraction`
    class declares the following two class methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set_rgb_led_brightness`: Sets the same brightness level received in the `brightness_level`
    argument to the three components of the RGB LED.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_leds_brightness`: Sets the brightness level for the three components
    of the RGB LED based on the `ambient_light` value of the DarknessSensor instance
    (`cls.darkness_sensor`). If it is extremely dark, the brightness level will be
    255\. If it is very dark, the brightness level will be 128\. If it is dark, the
    brightness level will be 64\. Otherwise, the RGB LED will be completely turned
    off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can write a code that uses the new `BoardInteraction` class to measure
    the ambient light and set the brightness for the RGB LED based on the retrieved
    value. As in our previous example, we will only make changes when the ambient
    light value changes from the current value. We will write a loop that will check
    whether the light conditions changed every two seconds. The code file for the
    sample is `iot_python_chapter_06_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first line initializes the `last_ambient_light` local variable with an empty
    string. Then, the code runs a loop forever, that is, until you interrupt the execution.
    The loop calls the `BoardInteraction.darkness_sensor.measure_light` method to
    retrieve the current light conditions and saves the updated `BoardInteraction.darkness_sensor.ambient_light`
    value in the `new_ambient_light` local variable. Then, the code checks whether
    the `new_ambient_light` value is different from `last_ambient_light`. In case
    they are different, it means that the ambient light has changed, and therefore,
    it sets the value for `last_ambient_light` equal to `new_ambient_light`, prints
    the ambient light description stored in `new_ambient_light` and calls the `BoardInteraction.update_leds_brightness`
    method to set the brightness for the RGB LED based on the ambient light.
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the example. Don't forget that you need to transfer
    the Python source code file to the Yocto Linux with an SFTP client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the example, perform the following actions, and you will see
    the RGB LED changing its brightness level as explained:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a smartphone or a flashlight to induce light over the photoresistor. The
    RGB LED will stay turned off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use your hand to generate a shadow over the photoresistor. The RGB LED will
    turn on with a dimmed light.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the light in the environment, but not the minimum, just make it a bit
    dark. The RGB LED will increase its brightness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the light in the environment to the minimum, a complete dark environment
    with no light at all. The RBG LED will increase its brightness to the maximum
    level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a smartphone or a flashlight to induce light over the photoresistor, again.
    The RGB LED will turn off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a result of the previous actions, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We wrote object-oriented Python code that is easy to read and understand. With
    the help of the `mraa` library, we could easily fire actions when the environment
    light changes. We could control the brightness for an RGB LED when the ambient
    light changed. We worked with an analog input to determine the ambient light level
    and we used PWM to generate an analog output and control the RGB LED brightness
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling analog inputs with the wiring-x86 library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using the `mraa` library to work with analog inputs and
    retrieve the ambient light level. However, we have also been working with the
    `wiring-x86` library in our previous examples. We can change just a few lines
    of our object-oriented code to replace the `mraa` library with the `wiring-x86`
    one to read analog values.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to replace the code for the `AnalogLed` class with the version
    that works with the `wiring-x86` library. We created this version in [Chapter
    4](ch04.html "Chapter 4. Working with a RESTful API and Pulse Width Modulation"),
    *Working with a RESTful API and Pulse Width Modulation*, and the code file for
    the sample was `iot_python_chapter_04_04.py`. When we grab the code for the `AnalogLed`
    class, we will also have the `Board` class.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines shows the new version of the `VoltageInput` class that works
    with the `wiring-x86` library instead of using `mraa`. The code file for the sample
    is `iot_python_chapter_06_04.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We created a new version of the `VoltageInput` class that declares an `initial_analog_pin_number`
    class attribute set to `14`. The `wiring-x86` library uses Arduino compatible
    numbers to reference the analog input pins or ADC pins. Thus, analog input pin
    `0` is known as `14`, analog input pin `1` as `15`, and so on. As we don't want
    to make changes to the rest of our code, we use a class attribute to specify the
    number that we must sum to the received `analog_pin` value to convert it to a
    `wiring-x86` analog pin number.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor, that is, the `__init__` method, saves a reference to the `Board.gpio`
    class attribute in `self.gpio` and calls its `pinMode` method with the received
    `analog_pin` and the value specified in `initial_analog_pin_number` class attribute
    as its `pin` argument, and `self.gpio.ANALOG_INPUT` as its `mode` argument. This
    way, we configure the pin to be an analog input pin converting the analog input
    pin number into a `wiring-x86` compatible analog input pin number. The `wiring-x86`
    library doesn't make a difference between GPIO and analog I/O pins, and we can
    manage all of them through the `Board.gpio` class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: All the `VoltageInput` instances will save a reference to the same `Board.gpio`
    class attribute that created an instance of the `GPIO` class, specifically, the
    `wiringx86.GPIOGalileoGen2` class with its `debug` argument set to `False` to
    avoid unnecessary debug information for the low-level communications.
  prefs: []
  type: TYPE_NORMAL
- en: The class defines a `voltage` property that calls the `analogRead` method for
    the GPIO instance (`self.gpio`) to retrieve the raw value from the analog pin
    and saves it in the `raw_value` variable. The result of the `self.analog_pin`
    attribute plus the value specified in `initial_analog_pin_number` class attribute
    specifies the `pin` value for the `analogRead` method call. Then, the code returns
    the result of dividing `raw_value` by `1023` and multiplying it by `5`. This way,
    the property returns the voltage value, converted from the raw value returned
    by the `analogRead` function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unluckily, the `wiring-x86` library doesn't support 12 bit of resolution for
    the analog to digital converter. The library works with a fixed 10 bit of resolution,
    and therefore, we are only able to detect 1024 different values (2^(10) = 1024),
    or 1024 units, with values ranging from 0 to 1023 (inclusive), where 0 represents
    0V and 1023 means 5V. For this reason, we have to divide raw_value by `1023` instead
    of `4095` within the `voltage` property.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code remains the same one that we have used for the previous
    example. There is no need to make changes to the `DarknessSensor` class, the `BoardInteraction`
    class or the main loop because they will automatically work with the new `VoltageInput`
    class and there were no changes in the arguments for its constructor or its `voltage`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line will start the new version of the example that works with
    the `wiring-x86` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can make the same changes in the incident light over the photoresistor that
    we made in our previous example to check that we can achieve exactly the same
    results with the `wiring-x86` library. The only difference will be in the precision
    of the voltage values retrieved because we are working with 10 bits of resolution
    in the analog to digital converter in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Logging to files in the local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python provides a powerful and flexible logging API provided by a standard library
    module. We can use the logging module to track events that happen when our IoT
    applications run on the board and save them on a log file by taking advantage
    of the local storage options.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will make changes to our last version of our previous example that worked
    with the `mraa` library to log the voltage values read from the ambient light
    sensor. We only want to log the new voltage value when the ambient light changes,
    that is, when the value for `BoardInteraction.darkness_sensor.ambient_light` mutates.
    We will use the previous code as a baseline to add the new logging features. The
    code file for the sample was `iot_python_chapter_06_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We will replace the `__main__` method. The following lines show the new version
    that adds logging capabilities. The new lines of code are highlighted and the
    code file for the sample is `iot_python_chapter_06_05.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first line calls the `logging.basicConfig` method to do the basic configuration
    for the logging system. The `fileName` argument specifies `"iot_python_chapter_06_05.log"`
    as the file name we want to use for logging. As we don't specify a value for the
    `fileMode` argument, the default `'a'` mode is used and the messages from successive
    runs will be appended to the specified log file name, that is, the file will never
    be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We didn't specify any path in the `fileName` argument, and therefore, the log
    file will be created in the same folder in which the Python script runs, that
    is, the `/home/root` folder. In this case, the log file will be using the storage
    space available in the microSD card that boots the Yocto Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The `format` argument specifies `"%(asctime)s %(message)s"` because we want
    to store the date and time followed by a message. The `datefmt` argument specifies
    `"%m/%d/%Y %I:%M:%S %p"` as the date and time format we want to use for the date
    and time that will be included as a prefix for all the lines appended to the log.
    We want a short date (month/date/year) followed by a short time (hours/minutes/seconds
    AM/PM). We just want to log the information logs to the file, and therefore, the
    `level` argument specifies `logging.INFO` to set the root logger level to this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line calls the `logging.info` method to log the first event: the application
    that has started its execution. Before entering into the loop, the code declared
    a new `last_voltage` local variable and initializes it to `0.0`. We want to log
    the previous voltage and the new voltage whenever the ambient light changes, and
    therefore, it is necessary to save the last voltage in a new variable. When the
    ambient light changes, a call to the `logging.info` method logs the transition
    from the previous voltage to the new voltage value. However, it is very important
    to notice that the first time this method is called, the previous voltage will
    be equal to `0.0`. The next line saves the value for the `BoardInteraction.darkness_sensor.voltage`
    in the `last_voltage` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line will start the new version of the example that will create
    the `iot_python_chapter_06_05.log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Keep the Python script running for a few minutes and make many changes in the
    incident light over the photoresistor. This way, you will generate many lines
    in the log file. Then, you can use your favorite SFTP client to download the log
    file from `/home/root` and read it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show some sample lines generated in the log file after
    executing the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Working with USB attached storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log files that record events related to sensors can grow really fast, and therefore,
    storing log files in the the microSD storage space might become a problem. We
    can work with microSD cards up to 32 GB. Thus, one option is to create the Yocto
    Linux image on a bigger microSD card and continue working with a single storage.
    This would require us to expand the partition from the default image. The other
    option is to take advantage of the cloud and just keep a constrained log in our
    local storage. However, we will work with this option later. Now, we want to explore
    the additional options we have to use local storage.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in [Chapter 1](ch01.html "Chapter 1. Understanding and Setting
    up the Base IoT Hardware"), *Understanding and Setting up the Base IoT Hardware*,
    The Intel Galileo Gen 2 board provides a USB 2.0 host connector, labeled **USB
    HOST**. We can use this connector to plug a USB thumb drive for additional storage
    and save the log file in this new storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you plug any USB thumb drive, run the following command in the SSH terminal
    to list the partition tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show an example of the output generated by the previous
    command. Your output might be different because it depends on the microSD card
    that you are using to boot Yocto Linux. Notice that the `/dev/mmcblk0` disk identifies
    the microSD card and you have two partitions: `/dev/mmcblk0p1` and `/dev/mmcblk0p2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will plug a USB thumb drive to the board's USB 2.0 host connector, we
    will run the necessary commands to mount it, and then we will make change to the
    code to save the log in a folder within the USB thumb drive. You will need a preformatted
    USB thumb drive compatible with USB 2.0 to run this example.
  prefs: []
  type: TYPE_NORMAL
- en: The following picture shows a USB thumb drive plugged to the board's USB 2.0
    host connector, labeled **USB HOST**. Wait a few seconds after you plug the USB
    thumb drive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with USB attached storage](img/B05042_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Yocto Linux will add a new block device to the `/dev` folder. Run the following
    command in the SSH terminal to list the partition tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show an example of the output generated by the previous
    command. Your output might be different because it depends on the USB drive and
    also on the microSD card that you are using. Compare the output with the output
    generated when you executed the same command before you plugged the USB thumb
    drive. The additional lines provide information about the USB thumb drive, its
    disk name, and its partitions. The highlighted lines show the partition details
    for the USB thumb, identified as the `/dev/sda` disk and with a FAT32 partition
    `/dev/sda1`. We will use this partition name for one of our next steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is necessary to create a mount point. We have to create a new sub-folder
    in the `/media` folder. We will use `usb` as the name for the sub-folder, and
    therefore, the folder in which we will mount the drive will be `/media/usb`. Run
    the following command to create the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Run the following command to mount the partition in the recently created `/media/usb`
    folder. In the previous steps we retrieved the partition name and it was named
    `/dev/sda1`. Your partition name might be different, and therefore, you just need
    to replace `/dev/sda1` with your partition name listed when you executed the fdisk
    command that listed the disks and their partitions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can access the contents of the USB thumb drive through the `/media/usb`
    folder, that is, whenever we create a folder or file in this folder, we are writing
    to the USB thumb drive partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a new `/media/usb/log` folder in which
    we will store the log for our IoT application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will change the value we pass to the filename argument when we call
    the `logging.basicConfig` method within the `__main__` method. We want to save
    the log file within the `/media/usb/log` folder. This way, we will store it in
    the USB thumb drive, in the `log` folder. We will use the previous code as a baseline
    to change the log file name and its path. The code file for the sample was `iot_python_chapter_06_05.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the new code that calls the `logging.basicConfig` method
    and the code file for the sample is `iot_python_chapter_06_06.py`. The rest of
    the code remains the same we have used in our previous example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line will start the new version of the example that will create
    the `iot_python_chapter_06_06.log` file in the `/media/usb/log` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Keep the Python script running for a few minutes and make many changes in the
    incident light over the photoresistor. This way, you will generate many lines
    in the log file. Then, you can use your favorite SFTP client to download the log
    file from `/media/usb/log` and read it. However, don't forget to go back to the
    `home/root` folder in your SFTP client because this is the folder in which you
    upload the Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to unplug the USB thumb drive to plug it on another computer or
    device, first you must interrupt the execution of the Python script, and then,
    you must run the following command to unmount the partition. In the previous steps
    we retrieved the partition name and it was named `/dev/sda1`. Your partition name
    might be different, and therefore, you just need to replace `/dev/sda1` with your
    partition name listed when you executed the `fdisk` command that listed the disks
    and their partitions. Be careful and make sure you run this command on the terminal
    that is running the shell on the Yocto Linux. Make sure you see the `root@galileo:~#`
    prompt before you execute it. If you run the command in a computer that runs Linux
    or OS X, you might unmount one of your drives.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can remove the USB thumb drive from the USB 2.0 host connector.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Intel Galileo Gen 2 board provides the following resolution for the analog
    to digital converter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 32 bits.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 64 bits.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 12 bits.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The analog pins allow us to detect a maximum of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4,096 different values, with values ranging from 0 to 4095 (inclusive).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 16,384 different values, with values ranging from 0 to 16,383 (inclusive).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 256 different values, with values ranging from 0 to 255 (inclusive).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can configure the number of bits we want to use as the resolution by calling
    the following method of an `mraa.Aio` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setADCResolution`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setBit`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setResolutionBits`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A call to the `read` method for a `mraa.Aio` instance returns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A raw number of units based on the number of the resolution bits configured
    for the instance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A voltage value automatically converted from the raw number of units.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A resistance value measured in Ohms (Ω).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use analog pins to read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resistance values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Current values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Voltage values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to work with analog inputs to measure voltage
    values. We understood the impact of the different bits of resolution for the analog
    to digital converter and we wrote code that converted the raw units read into
    voltage values.
  prefs: []
  type: TYPE_NORMAL
- en: We measure voltages with an analog pin and both the mraa and the wiring-x86
    library. We were able to transform a variable resistor into a voltage source and
    make it possible to measure the darkness level with an analog input, a photoresistor
    and a voltage divider.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous chapters, we continued taking advantage of Python's object-oriented
    features and created classes to encapsulate voltage inputs, darkness sensors,
    and the necessary configurations with the mraa and wiring-x86 libraries. Our code
    is easy to read and understand and we can easily switch the underlying low-level
    library.
  prefs: []
  type: TYPE_NORMAL
- en: We fired actions when the environment light changed and we were able to work
    with both analog inputs and analog outputs. Finally, we registered events by taking
    advantage of the logging features included in the Python standard library. We
    also learned to take advantage of the USB 2.0 host connector included in the Intel
    Galileo Gen 2 board to plug a USB thumb and use it as an additional storage.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we were able to read the analog inputs in different ways and configurations
    that made it possible for our IoT device to read analog values generated by changed
    in the environment, we can work with a wider variety of sensors to retrieve data
    from the real world, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
