<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Introduction to Design Patterns</h1></div></div></div><p class="calibre6">In this chapter, we will go through the basics of object-oriented programming and discuss the object-oriented design principles in detail. This will get us prepared for the advanced topics covered later in the book. This chapter will also give a brief introduction to the concept of design patterns so that you will be able to appreciate the context and application of design patterns in software development. Here we also classify the design patterns under three main aspects—creational, structural, and Behavioral patterns. So, essentially, we will cover the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">Understanding object-oriented programming</li><li class="listitem">Discussing object-oriented design principles</li><li class="listitem">Understanding the concept of design patterns and their taxonomy and context</li><li class="listitem">Discussing patterns for dynamic languages</li><li class="listitem">Classifying patterns—creational pattern, structural pattern, and behavioral pattern</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Understanding object-oriented programming</h1></div></div></div><p class="calibre6">Before <a id="id0" class="calibre1"/>you start learning about design patterns, it's always good to cover the basics and go through object-oriented paradigms in Python. The object-oriented world presents the concept of <em class="calibre13">objects</em> that have attributes (data members) and procedures (member functions). These functions are responsible for manipulating the attributes. For instance, take an example of the <code class="email">Car</code> object. The <code class="email">Car</code> object will have attributes such as <code class="email">fuel level</code>, <code class="email">isSedan</code>, <code class="email">speed</code>, and <code class="email">steering wheel</code> and <code class="email">coordinates</code>, and the methods would be <code class="email">accelerate()</code> to increase the speed and <code class="email">takeLeft()</code> to make the car turn left. Python has been an object-oriented language since it was first released. As they say, <em class="calibre13">everything in Python is an object</em>. Each class instance or variable has its own memory address or identity. Objects, which are instances of classes, interact among each other to serve the purpose of an application under development. Understanding the core concepts of object-oriented programming involves understanding the concepts of objects, classes, and methods.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec07" class="calibre1"/>Objects</h2></div></div></div><p class="calibre6">The <a id="id1" class="calibre1"/>following points describe <a id="id2" class="calibre1"/>objects:</p><div><ul class="itemizedlist"><li class="listitem">They represent entities in your application under development.</li><li class="listitem">Entities interact among themselves to solve real-world problems.</li><li class="listitem">For example, Person is an entity and Car is an entity. Person drives Car to move from one location to the other.</li></ul></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec08" class="calibre1"/>Classes</h2></div></div></div><p class="calibre6">Classes<a id="id3" class="calibre1"/> help developers to represent <a id="id4" class="calibre1"/>real-world entities:</p><div><ul class="itemizedlist"><li class="listitem">Classes define objects in attributes and behaviors. Attributes are data members and behaviors are manifested by the member functions</li><li class="listitem">Classes consist of constructors that provide the initial state for these objects</li><li class="listitem">Classes are like templates and hence can be easily reused </li></ul></div><p class="calibre6">For example, class <code class="email">Person</code> will have attributes <code class="email">name</code> and <code class="email">age</code> and member function <code class="email">gotoOffice()</code> that defines his behavior for travelling to office for work.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec09" class="calibre1"/>Methods</h2></div></div></div><p class="calibre6">The<a id="id5" class="calibre1"/> following points<a id="id6" class="calibre1"/> talk about what methods<a id="id7" class="calibre1"/> do in the object-oriented world:</p><div><ul class="itemizedlist"><li class="listitem">They represent the behavior of the object</li><li class="listitem">Methods work on attributes and also implement the desired functionality</li></ul></div><p class="calibre6">A good example of a class and object created in Python v3.5 is given here:</p><div><pre class="programlisting">class Person(object):
    def __init__(self, name, age):  #constructor
        self.name = name    #data members/ attributes
        self.age = age
    def get_person(self,):   # member function
         return "&lt;Person (%s, %s)&gt;" % (self.name, self.age)


p = Person("John", 32)    # p is an object of type Person
print("Type of Object:", type(p), "Memory Address:", id(p))</pre></div><p class="calibre6">The output <a id="id8" class="calibre1"/>of the preceding <a id="id9" class="calibre1"/>code should look as follows:</p><div><img src="img/00002.jpeg" alt="Methods" class="calibre14"/></div><p class="calibre15"> </p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Major aspects of object-oriented programming</h1></div></div></div><p class="calibre6">Now that <a id="id10" class="calibre1"/>we have understood the basics of object-oriented programming, let's dive into the major aspects of OOP.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec10" class="calibre1"/>Encapsulation</h2></div></div></div><p class="calibre6">The <a id="id11" class="calibre1"/>key features<a id="id12" class="calibre1"/> of encapsulation are as follows:</p><div><ul class="itemizedlist"><li class="listitem">An object's <a id="id13" class="calibre1"/>behavior is kept hidden from the outside world or objects keep their state information private.</li><li class="listitem">Clients can't change the object's internal state by directly acting on them; rather, clients request the object by sending messages. Based on the type of requests, objects may respond by changing their internal state using special member functions such as <code class="email">get</code> and <code class="email">set</code>.</li><li class="listitem">In Python, the concept of encapsulation (data and method hiding) is not implicit, as it doesn't have keywords such as <a id="id14" class="calibre1"/><strong class="calibre7">public</strong>, <a id="id15" class="calibre1"/><strong class="calibre7">private</strong>, and <a id="id16" class="calibre1"/><strong class="calibre7">protected</strong> (in languages such as C++ or Java) that are required to support encapsulation. Of course, accessibility can be made private by prefixing <code class="email">__</code> in the variable or function name.</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec11" class="calibre1"/>Polymorphism</h2></div></div></div><p class="calibre6">The major<a id="id17" class="calibre1"/> features of polymorphism<a id="id18" class="calibre1"/> are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Polymorphism can be of two types:<div><ul class="itemizedlist1"><li class="listitem">An object provides <a id="id19" class="calibre1"/>different implementations of the method based on input parameters</li><li class="listitem">The same interface can be used by objects of different types</li></ul></div></li><li class="listitem">In Python, polymorphism is a feature built-in for the language. For example, the <code class="email">+</code> operator can act on two integers to add them or can work with strings to concatenate them</li></ul></div><p class="calibre6">In the following <a id="id20" class="calibre1"/>example, strings, tuples, or lists can all be accessed with an integer index. This<a id="id21" class="calibre1"/> shows how Python demonstrates polymorphism in built-in types:</p><div><pre class="programlisting">a = "John"
b = (1,2,3)
c = [3,4,6,8,9]
print(a[1], b[0], c[2])</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec12" class="calibre1"/>Inheritance</h2></div></div></div><p class="calibre6">The following points help us<a id="id22" class="calibre1"/> understand the inheritance<a id="id23" class="calibre1"/> process better:</p><div><ul class="itemizedlist"><li class="listitem">Inheritance indicates that one class derives (most of its) functionality from the parent class.</li><li class="listitem">Inheritance is described as an option to reuse functionality defined in the base class and allow independent extensions of the original software implementation.</li><li class="listitem">Inheritance creates hierarchy via the relationships among objects of different classes. Python, unlike Java, supports multiple inheritance (inheriting from multiple base classes).</li></ul></div><p class="calibre6">In the following code example, <code class="email">class A</code> is the base class and <code class="email">class B</code> derives its features from <code class="email">class A</code>. So, the methods of <code class="email">class A</code> can be accessed by the object of <code class="email">class B</code>:</p><div><pre class="programlisting">class A:
    def a1(self):
        print("a1")

class B(A):
    def b(self):
        print("b")


b = B()
b.a1()</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec13" class="calibre1"/>Abstraction</h2></div></div></div><p class="calibre6">The key features<a id="id24" class="calibre1"/> of<a id="id25" class="calibre1"/> abstraction<a id="id26" class="calibre1"/> are as follows:</p><div><ul class="itemizedlist"><li class="listitem">It provides you with a simple interface to the clients, where the clients can interact with class objects and call methods defined in the interface</li><li class="listitem">It abstracts the complexity of internal classes with an interface so that the client need not be aware of internal implementations</li></ul></div><p class="calibre6">In the following example, internal details of the <code class="email">Adder</code> class are abstracted with the <code class="email">add()</code> method:</p><div><pre class="programlisting">class Adder:
    def __init__(self):
        self.sum = 0
    def add(self, value):
        self.sum += value

acc = Adder()
for i in range(99):
    acc.add(i)


print(acc.sum)</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec14" class="calibre1"/>Composition</h2></div></div></div><p class="calibre6">Composition<a id="id27" class="calibre1"/> refers to the<a id="id28" class="calibre1"/> following points:</p><div><ul class="itemizedlist"><li class="listitem">It is a way to combine objects or classes into more complex data structures or software implementations</li><li class="listitem">In composition, an object is used to call member functions in other modules thereby making base functionality available across modules without inheritance</li></ul></div><p class="calibre6">In the following example, the object of <code class="email">class A</code> is composited under <code class="email">class B</code>:</p><div><pre class="programlisting">class A(object):
    def a1(self):
        print("a1")

class B(object):
    def b(self):
        print("b")
        A().a1()


objectB = B()
objectB.b()</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Object-oriented design principles</h1></div></div></div><p class="calibre6">Now, let's talk<a id="id29" class="calibre1"/> about another set of concepts that are going to be crucial for us. These are nothing but the object-oriented design principles that will act as a toolbox for us while learning design patterns in detail.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec15" class="calibre1"/>The open/close principle</h2></div></div></div><p class="calibre6">The<a id="id30" class="calibre1"/> open/close principle states that <em class="calibre13">classes or objects and methods should be open for extension but closed for modifications</em>.</p><p class="calibre6">What this <a id="id31" class="calibre1"/>means in simple language is, when you develop your software application, make sure that you write your classes or modules in a generic way so that whenever you feel the need to extend the behavior of the class or object, then you shouldn't have to change the class itself. Rather, a simple extension of the class should help you build the new behavior.</p><p class="calibre6">For example, the open/close principle is manifested in a case where a user has to create a class implementation by extending the abstract base class to implement the required behavior instead of changing the abstract class.</p><p class="calibre6">Advantages<a id="id32" class="calibre1"/> of this design principle are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Existing classes are not changed and hence the chances of regression are less</li><li class="listitem">It also helps maintain backward compatibility for the previous code</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec16" class="calibre1"/>The inversion of control principle</h2></div></div></div><p class="calibre6">The<a id="id33" class="calibre1"/> inversion of <a id="id34" class="calibre1"/>control principle states that <em class="calibre13">high-level modules shouldn't be dependent on low-level modules; they should both be dependent on abstractions. Details should depend on abstractions and not the other way round</em>.</p><p class="calibre6">This principle suggests that any two modules shouldn't be dependent on each other in a tight way. In fact, the base module and dependent module should be decoupled with an abstraction layer in between.</p><p class="calibre6">This principle also suggests that the details of your class should represent the abstractions. In some cases, the philosophy gets inverted and implementation details itself decide the abstraction, which should be avoided.</p><p class="calibre6">Advantages of the inversion<a id="id35" class="calibre1"/> of control principle are as follows:</p><div><ul class="itemizedlist"><li class="listitem">The tight coupling of <a id="id36" class="calibre1"/>modules is no more prevalent and hence no complexity/rigidity in the system</li><li class="listitem">As there is a clear abstraction layer between dependent modules (provided by a hook or parameter), it's easy to deal with dependencies across modules in a better way</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec17" class="calibre1"/>The interface segregation principle</h2></div></div></div><p class="calibre6">As the <a id="id37" class="calibre1"/>interface segregation principle states, <em class="calibre13">clients should not be forced to depend on interfaces they don't use</em>.</p><p class="calibre6">This principle talks <a id="id38" class="calibre1"/>about software developers writing their interfaces well. For instance, it reminds the developers/architects to develop methods that relate to the functionality. If there is any method that is not related to the interface, the class dependent on the interface has to implement it unnecessarily.</p><p class="calibre6">For example, a <code class="email">Pizza</code> interface shouldn't have a method called <code class="email">add_chicken()</code>. The <code class="email">Veg Pizza</code> class based on the <code class="email">Pizza</code> interface shouldn't be forced to implement this method.</p><p class="calibre6">Advantages of this <a id="id39" class="calibre1"/>design principle are as follows:</p><div><ul class="itemizedlist"><li class="listitem">It forces developers to write thin interfaces and have methods that are specific to the interface</li><li class="listitem">It helps you not to populate interfaces by adding unintentional methods</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec18" class="calibre1"/>The single responsibility principle</h2></div></div></div><p class="calibre6">As the<a id="id40" class="calibre1"/> single responsibility principle states, <em class="calibre13">a class should have only one reason to change</em>.</p><p class="calibre6">This principle says that <a id="id41" class="calibre1"/>when we develop classes, it should cater to the given functionality well. If a class is taking care of two functionalities, it is better to split them. It refers to functionality as a reason to change. For example, a class can undergo changes because of the difference in behavior expected from it, but if a class is getting changed for two reasons (basically, changes in two functionalities), then the class should be definitely split.</p><p class="calibre6">Advantages of this design principle are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Whenever <a id="id42" class="calibre1"/>there is a change in one functionality, this particular class needs to change, and nothing else</li><li class="listitem">Additionally, if a class has multiple functionalities, the dependent classes will have to undergo changes for multiple reasons, which gets avoided</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec19" class="calibre1"/>The substitution principle</h2></div></div></div><p class="calibre6">The <a id="id43" class="calibre1"/>substitution principle states that <em class="calibre13">derived classes must be able to completely substitute the base classes</em>.</p><p class="calibre6">This principle is pretty<a id="id44" class="calibre1"/> straightforward in the sense that it says when application developers write derived classes, they should extend the base classes. It also suggests that the derived class should be as close to the base class as possible so much so that the derived class itself should replace the base class without any code changes.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>The concept of design patterns</h1></div></div></div><p class="calibre6">Finally, now is the time<a id="id45" class="calibre1"/> that we start talking about design patterns! What are design patterns?</p><p class="calibre6">Design patterns were first introduced by <a id="id46" class="calibre1"/><strong class="calibre7">GoF</strong> (<strong class="calibre7">Gang of Four</strong>), where they mentioned them as being solutions to given problems. If you would like to know more, GoF refers to the four authors of the book, <em class="calibre13">Design Patterns: Elements of Reusable Object-Oriented Software</em>. The book's authors are <em class="calibre13">Erich Gamma</em>, <em class="calibre13">Richard Helm</em>, <em class="calibre13">Ralph Johnson</em>, and <em class="calibre13">John Vlissides</em>, with a foreword by <em class="calibre13">Grady Booch</em>. This book covers software engineering solutions to the commonly occurring problems in software design. There were 23 design patterns first identified, and the first implementation was done with respect to the Java program language. Design patterns are discoveries and not an invention in themselves.</p><p class="calibre6">The key features<a id="id47" class="calibre1"/> of design patterns are as follows:</p><div><ul class="itemizedlist"><li class="listitem">They are language-neutral and can be implemented across multiple languages</li><li class="listitem">They are dynamic, as new patterns get introduced every now and then</li><li class="listitem">They are open for customization and hence useful for developers</li></ul></div><p class="calibre6">Initially, when you hear about design patterns, you may feel the following:</p><div><ul class="itemizedlist"><li class="listitem">It's a panacea to all the design problems that you've had so far</li><li class="listitem">It's an extraordinary, specially clever way of solving a problem</li><li class="listitem">Many experts in software development world agree to these solutions</li><li class="listitem">There's something repeatable about the design, hence the word pattern</li></ul></div><p class="calibre6">You too must have attempted to solve the problems that a design patterns intends to, but maybe your solution was incomplete, and the completeness that we're looking for is inherent or implicit in the design pattern. When we say completeness, it can refer to many factors such as the design, scalability, reuse, memory utilization, and others. Essentially, a design pattern is about learning from others' successes rather than your own failures!</p><p class="calibre6">Another interesting discussion that comes up on design patterns is—when do I use them? Is it in the analysis or design phase of <a id="id48" class="calibre1"/><strong class="calibre7">Software Development Life Cycle</strong> (<strong class="calibre7">SDLC</strong>)?</p><p class="calibre6">Interestingly, design patterns are solutions to known issues. So they can be very much used in analysis or design, and as expected, in the development phase because of the direct relation in the application code.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec20" class="calibre1"/>Advantages of design patterns</h2></div></div></div><p class="calibre6">The advantages of <a id="id49" class="calibre1"/>design patterns are as follows:</p><div><ul class="itemizedlist"><li class="listitem">They are reusable across multiple projects</li><li class="listitem">The architectural level of problems can be solved</li><li class="listitem">They are time-tested and well-proven, which is the experience of developers and architects</li><li class="listitem">They have reliability and dependence</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec21" class="calibre1"/>Taxonomy of design patterns</h2></div></div></div><p class="calibre6">Not every piece of <a id="id50" class="calibre1"/>code or design can be termed as a design pattern. For example, a programming construct or data structure that solves one problem can't be termed as a pattern. Let's understand terms in a very simplistic way below:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre7">Snippet</strong>: This is code<a id="id51" class="calibre1"/> in some language for a certain purpose, for example, DB connectivity in Python can be a code snippet</li><li class="listitem"><strong class="calibre7">Design</strong>: A <a id="id52" class="calibre1"/>better solution to solve this particular problem</li><li class="listitem"><strong class="calibre7">Standard</strong>: This<a id="id53" class="calibre1"/> is a way to solve some kind of problems, and can be very generic and applicable to a situation at hand</li><li class="listitem"><strong class="calibre7">Pattern</strong>: This is a<a id="id54" class="calibre1"/> time-tested, efficient, and scalable solution that will resolve the entire class of known issues</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec22" class="calibre1"/>Context – the applicability of design patterns</h2></div></div></div><p class="calibre6">To use design<a id="id55" class="calibre1"/> patterns efficiently, application developers must be aware of the context where design patterns apply. We can classify the context into the following main categories:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre7">Participants</strong>: They<a id="id56" class="calibre1"/> are classes that are used in design patterns. Classes play different roles to accomplish multiple goals in the pattern.</li><li class="listitem"><strong class="calibre7">Non-functional requirements</strong>: Requirements such as memory optimization, usability, and performance fall under <a id="id57" class="calibre1"/>this category. These factors impact the complete software solution and are thus critical.</li><li class="listitem"><strong class="calibre7">Trade-offs</strong>: Not all <a id="id58" class="calibre1"/>design patterns fit in application development as it is, and trade-offs are necessary. These are decisions that you take while using a design pattern in an application.</li><li class="listitem"><strong class="calibre7">Results</strong>: Design patterns <a id="id59" class="calibre1"/>can have a negative impact on other parts of the code if the context is not appropriate. Developers should understand the consequences and use of design patterns.</li></ul></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Patterns for dynamic languages</h1></div></div></div><p class="calibre6">Python<a id="id60" class="calibre1"/> is a <a id="id61" class="calibre1"/>dynamic language like Lisp. The dynamic nature of Python can be represented as follows:</p><div><ul class="itemizedlist"><li class="listitem">Types or classes are objects at runtime.</li><li class="listitem">Variables can have type as a value and can be modified at runtime. For example, <code class="email">a = 5</code> and <code class="email">a = "John"</code>, the <code class="email">a</code> variable is assigned at runtime and type also gets changed.</li><li class="listitem">Dynamic languages have more flexibility in terms of class restrictions.</li><li class="listitem">For example, in Python, polymorphism is built into the language, there are no keywords such as <code class="email">private</code> and <code class="email">protected</code> and everything is public by default.</li><li class="listitem">Represents a case where design patterns can be easily implemented in dynamic languages.</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Classifying patterns</h1></div></div></div><p class="calibre6">The book by GoF on design <a id="id62" class="calibre1"/>patterns spoke about 23 design patterns and classified them under three main categories:</p><div><ul class="itemizedlist"><li class="listitem">Creational patterns</li><li class="listitem">Structural patterns</li><li class="listitem">Behavioral patterns</li></ul></div><p class="calibre6">The classification <a id="id63" class="calibre1"/>of patterns is done based primarily on how the objects get created, how classes and objects are structured in a software application, and also covers the way objects interact among themselves. Let's talk about each of the categories in detail in this section.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec23" class="calibre1"/>Creational patterns:</h2></div></div></div><p class="calibre6">The following are the <a id="id64" class="calibre1"/>properties of<a id="id65" class="calibre1"/> Creational patterns:</p><div><ul class="itemizedlist"><li class="listitem">They work on the basis of how objects can be created</li><li class="listitem">They isolate the details of object creation</li><li class="listitem">Code is independent of the type of object to be created</li></ul></div><p class="calibre6">An example of a creational pattern is the Singleton pattern.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec24" class="calibre1"/>Structural patterns</h2></div></div></div><p class="calibre6">The following are<a id="id66" class="calibre1"/> the properties of <a id="id67" class="calibre1"/>Structural patterns:</p><div><ul class="itemizedlist"><li class="listitem">They design the structure of objects and classes so that they can compose to achieve larger results</li><li class="listitem">The focus is on simplifying the structure and identifying the relationship between classes and objects</li><li class="listitem">They focus on class inheritance and composition</li></ul></div><p class="calibre6">An example of a behavior pattern is the Adapter pattern.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec25" class="calibre1"/>Behavioral patterns</h2></div></div></div><p class="calibre6">The <a id="id68" class="calibre1"/>following are the properties of Behavioral patterns:</p><div><ul class="itemizedlist"><li class="listitem">They are concerned with the <a id="id69" class="calibre1"/>interaction among objects and responsibility of objects</li><li class="listitem">Objects should be able to interact and still be loosely coupled</li></ul></div><p class="calibre6">An example of a behavioral pattern is the Observer pattern.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec14" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">In this chapter, you learned about the basic concepts of object-oriented programming, such as objects, classes, variables, and features such as polymorphism, inheritance, and abstraction with code examples.</p><p class="calibre6">We are also now aware of object-oriented design principles that we, as developers/architects, should consider while designing an application.</p><p class="calibre6">Finally, we went on to explore more about design patterns and their applications and context in which they can be applied and also discussed their classifications.</p><p class="calibre6">At the end of this chapter, we're now ready to take the next step and study design patterns in detail.</p></div></body></html>