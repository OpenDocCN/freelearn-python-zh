- en: Chapter 2. The Singleton Design Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 单例设计模式
- en: 'In the previous chapter, we explored design patterns and their classifications.
    As we are aware, design patterns can be classified under three main categories:
    structural, behavioral, and creational patterns.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了设计模式和它们的分类。正如我们所知，设计模式可以分为三大类：结构型、行为型和创建型模式。
- en: In this chapter, we will go through the Singleton design pattern—one of the
    simplest and well-known Creational design patterns used in application development.
    This chapter will give you a brief introduction to the Singleton pattern, take
    you through a real-world example where this pattern can be used, and explain it
    in detail with the help of Python implementations. You will learn about the Monostate
    (or Borg) design pattern that is a variant of the Singleton design pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨单例设计模式——这是在应用程序开发中使用的最简单和最知名创建型设计模式之一。本章将简要介绍单例模式，带您通过一个可以使用此模式的真实世界示例，并使用Python实现来详细解释它。您将了解单态（或Borg）模式，这是单例模式的变体。
- en: 'In this chapter, we will cover the following topics in brief:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍以下内容：
- en: An understanding of the Singleton design pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解单例设计模式
- en: A real-world example of the Singleton pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式的真实世界示例
- en: The Singleton pattern implementation in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的单例模式实现
- en: The Monostate (Borg) pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单态（Borg）模式
- en: At the end of the chapter, we have a short summary on Singletons. This will
    help you think independently about some of the aspects of the Singleton design
    pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们将对单例进行简要总结。这将帮助您独立思考单例设计模式的一些方面。
- en: Understanding the Singleton design pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单例设计模式
- en: Singleton provides you with a mechanism to have one, and only one, object of
    a given type and provides a global point of access. Hence, Singletons are typically
    used in cases such as logging or database operations, printer spoolers, and many
    others, where there is a need to have only one instance that is available across
    the application to avoid conflicting requests on the same resource. For example,
    we may want to use one database object to perform operations on the DB to maintain
    data consistency or one object of the logging class across multiple services to
    dump log messages in a particular log file sequentially.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 单例提供了一种机制，确保只有一个给定类型的对象被创建，并提供了一个全局访问点。因此，单例通常用于需要跨应用程序只有一个实例以避免对同一资源冲突请求的场景，例如日志记录或数据库操作、打印机打印队列等。例如，我们可能希望使用一个数据库对象来对数据库进行操作以维护数据一致性，或者在一个多服务中跨多个服务使用一个日志类对象来顺序地写入特定的日志文件。
- en: 'In brief, the intentions of the Singleton design pattern are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，单例设计模式的意图如下：
- en: Ensuring that one and only one object of the class gets created
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保只有一个类的对象被创建
- en: Providing an access point for an object that is global to the program
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为全局程序提供一个对象的访问点
- en: Controlling concurrent access to resources that are shared
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对共享资源的并发访问
- en: 'The following is the UML diagram for Singleton:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的UML图是单例的：
- en: '![Understanding the Singleton design pattern](img/00003.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![理解单例设计模式](img/00003.jpeg)'
- en: A simple way of implementing Singleton is by making the constructor private
    and creating a static method that does the object initialization. This way, one
    object gets created on the first call and the class returns the same object thereafter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实现单例的一种简单方法是通过使构造函数私有，并创建一个静态方法来完成对象初始化。这样，在第一次调用时创建一个对象，之后类返回相同的对象。
- en: In Python, we will implement it in a different way as there's no option to create
    private constructors. Let's take a look at how Singletons are implemented in the
    Python language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们将以不同的方式实现它，因为没有创建私有构造函数的选项。让我们看看Python语言中单例是如何实现的。
- en: Implementing a classical Singleton in Python
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中实现经典的单例
- en: 'Here is a sample code of the Singleton pattern in Python v3.5\. In this example,
    we will do two major things:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Python 3.5版本中单例模式的一个示例代码。在这个例子中，我们将做两件主要的事情：
- en: We will allow the creation of only one instance of the `Singleton` class.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将允许创建`Singleton`类的一个实例。
- en: If an instance exists, we will serve the same object again.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在实例，我们将再次提供相同的对象。
- en: 'The following code shows this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了这一点：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: override the `__new__` method (Python's special method to instantiate objects)
    to control the object creation. The s object gets created with the `__new__` method,
    but before this, it checks whether the object already exists. The `hasattr` method
    (Python's special method to know if an object has a certain property) is used
    to see if the `cls` object has the instance property, which checks whether the
    class already has an object. Till the time the `s1` object is requested, `hasattr()`
    detects that an object already exists and hence `s1` allocates the existing object
    instance (located at `0x102078ba8`).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过覆盖`__new__`方法（Python中用于实例化对象的特殊方法）来控制对象创建。`s`对象通过`__new__`方法创建，但在创建之前，它会检查对象是否已经存在。使用`hasattr`方法（Python中用于判断对象是否具有特定属性的特殊方法）来查看`cls`对象是否具有实例属性，这会检查类是否已经有一个对象。直到请求`s1`对象时，`hasattr()`会检测到已经存在一个对象，因此`s1`分配了现有的对象实例（位于`0x102078ba8`）。
- en: Lazy instantiation in the Singleton pattern
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式中的延迟实例化
- en: One of the use cases for the Singleton pattern is lazy instantiation. For example,
    in the case of module imports, we may accidently create an object even when it's
    not needed. Lazy instantiation makes sure that the object gets created when it's
    actually needed. Consider lazy instantiation as the way to work with reduced resources
    and create them only when needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的一个用例是延迟实例化。例如，在模块导入的情况下，我们可能会在不必要的时候意外创建一个对象。延迟实例化确保对象仅在真正需要时才被创建。将延迟实例化视为一种以减少资源使用并仅在需要时创建资源的方式。
- en: In the following code example, when we say `s=Singleton()`, it calls the `__init__`
    method but no new object gets created. However, actual object creation happens
    when we call `Singleton.getInstance()`. This is how lazy instantiation is achieved.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，当我们说`s=Singleton()`时，它调用`__init__`方法，但没有创建新的对象。然而，实际的对象创建发生在我们调用`Singleton.getInstance()`时。这就是如何实现延迟实例化的。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Module-level Singletons
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块级单例
- en: 'All modules are Singletons by default because of Python''s importing behavior.
    Python works in the following way:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的导入行为，所有模块默认都是单例。Python以以下方式工作：
- en: Checks whether a Python module has been imported.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Python模块是否已被导入。
- en: If imported, returns the object for the module. If not imported, imports and
    instantiates it.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已导入，则返回模块的对象。如果尚未导入，则导入并实例化它。
- en: So when a module gets imported, it is initialized. However, when the same module
    is imported again, it's not initialized again, which relates to the Singleton
    behavior of having only one object and returning the same object.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，当一个模块被导入时，它会被初始化。然而，当相同的模块再次被导入时，它不会被再次初始化，这与单例行为有关，即只有一个对象并返回相同的对象。
- en: The Monostate Singleton pattern
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单态单例模式
- en: We discussed the Gang of Four and their book in [Chapter 1](part0015_split_000.html#E9OE1-5ae934a69a004514b92177e2702ed0a9
    "Chapter 1. Introduction to Design Patterns"), *Introduction to Design Patterns*.
    GoF's Singleton design pattern says that there should be one and only one object
    of a class. However, as per Alex Martelli, typically what a programmer needs is
    to have instances sharing the same state. He suggests that developers should be
    bothered about the state and behavior rather than the identity. As the concept
    is based on all objects sharing the same state, it is also known as the Monostate
    pattern.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](part0015_split_000.html#E9OE1-5ae934a69a004514b92177e2702ed0a9 "第1章。设计模式简介")中讨论了四人帮及其书籍，《设计模式简介》。四人帮的单例设计模式指出，一个类应该只有一个对象。然而，根据亚历克斯·马尔蒂尼的观点，程序员通常需要的是具有相同状态的实例。他建议开发者应该关注状态和行为，而不是身份。由于这个概念基于所有对象共享相同的状态，它也被称为单态模式。
- en: 'The Monostate pattern can be achieved in a very simple way in Python. In the
    following code, we assign the `__dict__` variable (a special variable of Python)
    with the `__shared_state` class variable. Python uses `__dict__` to store the
    state of every object of a class. In the following code, we intentionally assign
    `__shared_state` to all the created instances. So when we create two instances,
    `''b''` and `''b1''`, we get two different objects unlike Singleton where we have
    just one object. However, the object states, `b.__dict__` and `b1.__dict__` are
    the same. Now, even if the object variable `x` changes for object `b`, the change
    is copied over to the `__dict__` variable that is shared by all objects and even
    `b1` gets this change of the `x` setting from one to four:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，单态模式可以通过非常简单的方式实现。在下面的代码中，我们将Python的特殊变量`__dict__`（一个特殊的Python变量）与`__shared_state`类变量关联。Python使用`__dict__`来存储类中每个对象的状态。在下面的代码中，我们故意将`__shared_state`分配给所有创建的实例。因此，当我们创建两个实例`'b'`和`'b1'`时，我们得到两个不同的对象，这与单例不同，我们只有一个对象。然而，对象状态`b.__dict__`和`b1.__dict__`是相同的。现在，即使对象变量`x`对对象`b`发生变化，这个变化也会复制到所有对象共享的`__dict__`变量中，甚至`b1`也会从`x`设置的一个变为四：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another way to implement the Borg pattern is by tweaking the `__new__` method
    itself. As we know, the `__new__` method is responsible for the creation of the
    object instance:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Borg模式的另一种方法是调整`__new__`方法本身。正如我们所知，`__new__`方法负责对象的创建：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Singletons and metaclasses
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例和元类
- en: Let's start with a brief introduction to metaclasses. A metaclass is a class
    of a class, which means that the class is an instance of its metaclass. With metaclasses,
    programmers get an opportunity to create classes of their own type from the predefined
    Python classes. For instance, if you have an object, `MyClass`, you can create
    a metaclass, `MyKls`, that redefines the behavior of `MyClass` to the way that
    you need. Let's understand them in detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对元类的简要介绍开始。元类是类的类，这意味着类是其元类的实例。通过元类，程序员有机会从预定义的Python类中创建他们自己的类型的类。例如，如果你有一个对象`MyClass`，你可以创建一个元类`MyKls`，它重新定义了`MyClass`的行为，使其符合你的需求。让我们详细了解一下。
- en: In Python, everything is an object. If we say `a=5`, then `type(a)` returns
    `<type 'int'>`, which means `a` is of the int type. However, `type(int)` returns
    `<type 'type'>`, which suggests the presence of a metaclass as int is a class
    of the `type` type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，一切都是对象。如果我们说`a=5`，那么`type(a)`返回`<type 'int'>`，这意味着`a`是int类型。然而，`type(int)`返回`<type
    'type'>`，这表明存在一个元类，因为int是`type`类型的类。
- en: 'The definition of class is decided by its metaclass, so when we create a class
    with `class A`, Python creates it by `A = type(name, bases, dict)`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 类的定义由其元类决定，因此当我们使用`class A`创建一个类时，Python通过`A = type(name, bases, dict)`来创建它：
- en: '`name`: This is the name of the class'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这是类的名称'
- en: '`base`: This is the base class'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base`: 这是基类'
- en: '`dict`: This is the attribute variable'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict`: 这是属性变量'
- en: Now, if a class has a predefined metaclass (by the name of `MetaKls`), Python
    creates the class by `A = MetaKls(name, bases, dict)`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一个类有一个预定义的元类（名为`MetaKls`），Python将通过`A = MetaKls(name, bases, dict)`来创建这个类。
- en: 'Let''s look at a sample metaclass implementation in Python 3.5:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Python 3.5中的一个示例元类实现：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the output of the preceding code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为上述代码的输出：
- en: '![Singletons and metaclasses](img/00006.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![单例和元类](img/00006.jpeg)'
- en: Python's special `__call__` method gets called when an object needs to be created
    for an already existing class. In this code, when we instantiate the `int` class
    with `int(4,5)`, the `__call__` method of the `MyInt` metaclass gets called, which
    means that the metaclass now controls the instantiation of the object. Wow, isn't
    this great?!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要为已存在的类创建对象时，Python的特殊`__call__`方法会被调用。在这段代码中，当我们使用`int(4,5)`实例化`int`类时，`MyInt`元类的`__call__`方法会被调用，这意味着元类现在控制了对象的实例化。哇，这不是很棒吗？！
- en: 'The preceding philosophy is used in the Singleton design pattern as well. As
    the metaclass has more control over class creation and object instantiation, it
    can be used to create Singletons. (Note: To control the creation and initialization
    of a class, metaclasses override the `__new__` and `__init__` method.)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述哲学也用于单例设计模式。由于元类对类创建和对象实例化有更多的控制，它可以用来创建单例。（注意：为了控制类的创建和初始化，元类会覆盖`__new__`和`__init__`方法。）
- en: 'The Singleton implementation with metclasses can be explained better with the
    following example code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元类实现的单例可以通过以下示例代码更好地解释：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A real-world scenario – the Singleton pattern, part 1
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实场景 - Singleton模式，第一部分
- en: As a practical use case, we will look at a database application to show the
    use of Singletons. Consider an example of a cloud service that involves multiple
    read and write operations on the database. The complete cloud service is split
    across multiple services that perform database operations. An action on the UI
    (web app) internally will call an API, which eventually results in a DB operation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实际用例，我们将通过一个数据库应用程序来展示Singleton的使用。考虑一个涉及数据库多次读写操作的云服务示例。完整的云服务被分割成多个执行数据库操作的服务。UI（Web应用程序）上的操作在内部会调用API，最终导致数据库操作。
- en: 'It''s clear that the shared resource across different services is the database
    itself. So, if we need to design the cloud service better, the following points
    must be taken care of:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，跨不同服务的共享资源是数据库本身。因此，如果我们需要更好地设计云服务，以下这些点必须注意：
- en: Consistency across operations in the database—one operation shouldn't result
    in conflicts with other operations
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库操作的一致性——一个操作不应该与其他操作发生冲突
- en: Memory and CPU utilization should be optimal for the handling of multiple operations
    on the database
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存和CPU利用率应该是最优的，以便处理数据库上的多个操作
- en: 'A sample Python implementation is given here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了一个Python实现的示例：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding code is given here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![A real-world scenario – the Singleton pattern, part 1](img/00007.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![真实场景 - Singleton模式，第一部分](img/00007.jpeg)'
- en: 'In the preceding code, we can see following points being covered:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到以下要点：
- en: We created a metaclass by the name of `MetaSingleton`. Like we explained in
    the previous section, the special `__call__` method of Python is used in the metaclass
    to create a Singleton.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`MetaSingleton`的元类。正如我们在上一节中解释的，Python的特殊`__call__`方法在元类中被用来创建Singleton。
- en: The `database` class is decorated by the `MetaSingleton` class and starts acting
    like a Singleton. So, when the `database` class is instantiated, it creates only
    one object.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`database`类被`MetaSingleton`类装饰，开始像Singleton一样工作。因此，当实例化`database`类时，它只会创建一个对象。'
- en: When the web app wants to perform certain operations on the DB, it instantiates
    the database class multiple times, but only one object gets created. As there
    is only one object, calls to the database are synchronized. Additionally, this
    is inexpensive on system resources and we can avoid the situation of memory or
    CPU resource.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Web应用程序想要在数据库上执行某些操作时，它会多次实例化数据库类，但实际上只创建了一个对象。由于只有一个对象，对数据库的调用是同步的。此外，这不会消耗太多系统资源，我们可以避免内存或CPU资源不足的情况。
- en: Consider that instead of having one webapp, we have a clustered setup with multiple
    web apps but only one DB. Now, this is not a good situation for Singletons because,
    with every web app addition, a new Singleton gets created and a new object gets
    added that queries the database. This results in unsynchronized database operations
    and is heavy on resources. In such cases, database connection pooling is better
    than implementing Singletons.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不是只有一个webapp，而是一个由多个webapp组成的集群设置，但只有一个数据库。现在，这并不是Singleton的好情况，因为随着每个webapp的增加，一个新的Singleton会被创建，并且会添加一个新的查询数据库的对象。这会导致数据库操作不同步，并且资源消耗很大。在这种情况下，数据库连接池比实现Singleton更好。
- en: A real-world scenario – the Singleton pattern, part 2
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实场景 - Singleton模式，第二部分
- en: Let's consider another scenario where we implement health check services (such
    as Nagios) for our infrastructure. We create the `HealthCheck` class, which is
    implemented as a Singleton. We also maintain a list of servers against which the
    health check needs to run. If a server is removed from this list, the health check
    software should detect it and remove it from the servers configured to check.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个场景，其中我们为我们的基础设施实现健康检查服务（如Nagios）。我们创建了一个`HealthCheck`类，它被实现为Singleton。我们还维护了一个需要运行健康检查的服务器列表。如果从该列表中删除服务器，健康检查软件应该检测到并将其从配置为检查的服务器中删除。
- en: In the following code, the `hc1` and `hc2` objects are the same as the class
    in Singleton.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`hc1`和`hc2`对象与Singleton中的类相同。
- en: Servers are added to the infrastructure for the health check with the `addServer()`
    method. First, the iteration of the health check runs against these servers. The
    `changeServer()` method removes the last server and adds a new one to the infrastructure
    scheduled for the health check. So, when the health check runs in the second iteration,
    it picks up the changed list of servers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addServer()`方法将服务器添加到基础设施中，以进行健康检查。首先，健康检查的迭代运行在这些服务器上。`changeServer()`方法移除最后一个服务器，并将一个新的服务器添加到为健康检查而计划的基础设施中。因此，当健康检查在第二次迭代中运行时，它会选择更改后的服务器列表。
- en: 'All this is possible with Singletons. When the servers get added or removed,
    the health check must be the same object that has the knowledge of the changes
    made to the infrastructure:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过Singleton实现。当服务器被添加或移除时，健康检查必须是知道对基础设施所做的更改的对象：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the code is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![A real-world scenario – the Singleton pattern, part 2](img/00008.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![现实世界场景 - Singleton模式，第2部分](img/00008.jpeg)'
- en: Drawbacks of the Singleton pattern
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Singleton模式的缺点
- en: 'While Singletons are used in multiple places to good effect, there can be a
    few gotchas with this pattern. As Singletons have a global point of access, the
    following issues can occur:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Singleton在多个地方被有效使用，但这个模式可能存在一些陷阱。由于Singleton具有全局访问点，以下问题可能会发生：
- en: Global variables can be changed by mistake at one place and, as the developer
    may think that they have remained unchanged, the variables get used elsewhere
    in the application.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量可能会在一个地方被错误地更改，由于开发者可能认为它们保持不变，变量在应用程序的其他地方被使用。
- en: Multiple references may get created to the same object. As Singleton creates
    only one object, multiple references can get created at this point to the same
    object.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会创建对同一对象的多个引用。由于Singleton只创建一个对象，因此此时可以创建对同一对象的多个引用。
- en: All classes that are dependent on global variables get tightly coupled as a
    change to the global data by one class can inadvertently impact the other class.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有依赖于全局变量的类都会紧密耦合，因为一个类对全局数据的更改可能会无意中影响其他类。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As part of this chapter, you learned a lot on Singletons. Here are a few points
    that we should remember about Singletons:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，你学习了关于Singleton的很多内容。以下是我们应该记住的关于Singleton的几个要点：
- en: There are many real-world applications where we need to create only one object,
    such as thread pools, caches, dialog boxes, registry settings, and so on. If we
    create multiple instances for each of these applications, it will result in the
    overuse of resources. Singletons work very well in such situations.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多现实世界的应用中，我们只需要创建一个对象，例如线程池、缓存、对话框、注册设置等。如果我们为每个这些应用创建多个实例，将导致资源的过度使用。Singleton在这种情况下工作得非常好。
- en: Singleton; a time-tested and proven method of presenting a global point of access
    without many downsides.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Singleton；这是一个经过时间考验且被证明的，在无需许多缺点的情况下提供全局访问点的方法。
- en: Of course, there are a few downsides; Singletons can have an inadvertent impact
    working with global variables or instantiating classes that are resource-intensive
    but end up not utilizing them.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，也有一些缺点；Singleton在与全局变量一起工作或实例化资源密集型类时可能会产生意外影响，而这些类最终没有使用这些资源。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the Singleton design pattern and the context
    in which it's used. We understood that Singletons are used when there is a need
    to have only one object for a class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Singleton设计模式及其使用上下文。我们了解到，当需要为类只有一个对象时，会使用Singleton。
- en: We also looked at various ways in which Singletons can be implemented in Python.
    The classical implementation allowed multiple instantiation attempts but returned
    the same object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了在Python中实现Singleton的各种方法。经典实现允许多次实例化尝试，但返回相同的对象。
- en: We also discussed the Borg or Monostate pattern, which is a variation of the
    Singleton pattern. Borg allows the creation of multiple objects that share the
    same state unlike the single pattern described by GoF.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了Borg或Monostate模式，这是Singleton模式的一种变体。Borg允许创建多个对象，这些对象共享相同的状态，与GoF描述的单例模式不同。
- en: We went on to explore the webapp application where Singleton can be applied
    for consistent database operations across multiple services.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续探索了在多个服务中应用Singleton以实现一致数据库操作的webapp应用。
- en: Finally, we also looked at situations where Singletons can go wrong and what
    situations developers need to avoid.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还探讨了Singleton可能出错的情况以及开发者需要避免的情况。
- en: At the end of this chapter, we're now comfortable enough to take the next step
    and study other creational patterns and benefit from them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们已经足够熟悉，可以继续下一步，研究其他创建型模式并从中受益。
- en: In the next chapter, we'll take a look at another creational pattern and the
    Factory design pattern. We'll cover the `Factory` method and Abstract Factory
    patterns and understand them in the Python implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一种创建型设计模式，即工厂设计模式。我们将介绍`Factory`方法和抽象工厂模式，并在Python实现中理解它们。
