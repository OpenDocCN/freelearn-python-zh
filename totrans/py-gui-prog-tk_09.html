<html><head></head><body>
  <div id="_idContainer170">
    <h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-216" class="chapterTitle">Improving the Look with Styles and Themes</h1>
    <p class="normal">While programs can be perfectly functional with plain text in shades of black, white, and gray, the subtle use of colors, fonts, and images can enhance the visual appeal and usability of even the most utilitarian applications. Your data entry application is no exception, and the current round of requests brought to you by your coworkers seems to require some retooling of the application's look and feel.</p>
    <p class="normal">Specifically, you've been asked to address these points:</p>
    <ul>
      <li class="bullet">Your manager has informed you that ABQ's corporate policy requires the company logo to be displayed on all in-house software. You've been provided with a corporate logo image to include in the application.</li>
      <li class="bullet">The data entry staff have some readability issues with the form. They want more visual distinction between the sections of the form and more visibility for error messages.</li>
      <li class="bullet">The data entry staff have also requested that you highlight records they've added or updated during a session to help them keep track of their work.</li>
    </ul>
    <p class="normal">In addition to the user's requests, you'd like to make your application look more professional by adding some icons to your buttons and menu.</p>
    <p class="normal">In this chapter, we're going to learn about some features of Tkinter that will help us to solve these issues:</p>
    <ul>
      <li class="bullet">In <em class="italic">Working with images in Tkinter</em>, we'll learn how to add pictures and icons to our Tkinter GUI.</li>
      <li class="bullet">In <em class="italic">Styling Tkinter widgets</em>, we'll learn how to adjust the colors and visual style of Tkinter widgets, both directly and using tags.</li>
      <li class="bullet">In <em class="italic">Working with fonts in Tkinter</em>, we'll learn the ins and outs of using fonts in Tkinter.</li>
      <li class="bullet">In <em class="italic">Styling Ttk widgets</em>, we'll learn how to adjust the look of Ttk widgets using styles and themes.</li>
    </ul>
    <h1 id="_idParaDest-217" class="title">Working with images in Tkinter</h1>
    <p class="normal">To solve the corporate<a id="_idIndexMarker745"/> logo issue and spruce up our application with some icons, we're going to need to understand how to work with images in Tkinter. Tkinter provides access to image files through two classes: the <code class="Code-In-Text--PACKT-">PhotoImage</code> class and the <code class="Code-In-Text--PACKT-">BitmapImage</code> class. Let's see how these classes can help us add graphics to our application.</p>
    <h2 id="_idParaDest-218" class="title">Tkinter PhotoImage</h2>
    <p class="normal">Many Tkinter widgets, including <code class="Code-In-Text--PACKT-">Label</code> and <code class="Code-In-Text--PACKT-">Button</code>, accept an <code class="Code-In-Text--PACKT-">image</code> argument that allows us to display an image<a id="_idIndexMarker746"/> on the widget. This argument requires that we create<a id="_idIndexMarker747"/> and pass in a <code class="Code-In-Text--PACKT-">PhotoImage</code> (or <code class="Code-In-Text--PACKT-">BitmapImage</code>) object.</p>
    <p class="normal">Making a <code class="Code-In-Text--PACKT-">PhotoImage</code> object is fairly simple:</p>
    <pre class="programlisting code"><code class="hljs-code">myimage = tk.PhotoImage(file=<span class="hljs-string">'my_image.png'</span>)
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">PhotoImage</code> is typically called with the keyword argument <code class="Code-In-Text--PACKT-">file</code>, which is pointed to a file path. Alternatively, you can use the <code class="Code-In-Text--PACKT-">data</code> argument to point to a <code class="Code-In-Text--PACKT-">bytes</code> object containing image data. In either case, the resulting object can now be used wherever an <code class="Code-In-Text--PACKT-">image</code> argument is accepted, such as in a <code class="Code-In-Text--PACKT-">Label</code> widget:</p>
    <pre class="programlisting code"><code class="hljs-code">mylabel = tk.Label(root, image=myimage)
</code></pre>
    <p class="normal">Note that if we pass both an <code class="Code-In-Text--PACKT-">image</code> and <code class="Code-In-Text--PACKT-">text</code> argument to the <code class="Code-In-Text--PACKT-">Label</code> initializer, only the image will be displayed by default. To display both, we need to also provide a value for the <code class="Code-In-Text--PACKT-">compound</code> argument, which determines how the image and text will be arranged with respect to one another. For example:</p>
    <pre class="programlisting code"><code class="hljs-code">mylabel_1 = tk.Label(root, text=<span class="hljs-string">'Banana'</span>, image=myimage)
mylabel_2 = tk.Label(
  root,
  text=<span class="hljs-string">'Plantain'</span>,
  image=myimage,
  compound=tk.LEFT
)
</code></pre>
    <p class="normal">In this situation, the first label would only show the <code class="Code-In-Text--PACKT-">image</code>; the <code class="Code-In-Text--PACKT-">text</code> will not be displayed. In the second, since<a id="_idIndexMarker748"/> we have specified a <code class="Code-In-Text--PACKT-">compound</code> value of <code class="Code-In-Text--PACKT-">tk.LEFT</code>, the <code class="Code-In-Text--PACKT-">image</code> will be displayed to the left of the <code class="Code-In-Text--PACKT-">text</code>. <code class="Code-In-Text--PACKT-">compound</code> can be any of <code class="Code-In-Text--PACKT-">LEFT</code>, <code class="Code-In-Text--PACKT-">RIGHT</code>, <code class="Code-In-Text--PACKT-">BOTTOM</code>, or <code class="Code-In-Text--PACKT-">TOP</code> (either lowercase strings or the Tkinter constants), and indicates where the image will be placed in relation to the text.</p>
    <h3 id="_idParaDest-219" class="title">PhotoImage and variable scope</h3>
    <p class="normal">When using a <code class="Code-In-Text--PACKT-">PhotoImage</code> object, it is critical to remember that your application must retain a reference to the object<a id="_idIndexMarker749"/> that will stay in scope for as long as the image<a id="_idIndexMarker750"/> is shown; otherwise, the image will not appear. To understand what this means, consider the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># image_scope_demo.py</span>
<span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">App</span><span class="hljs-class">(</span><span class="hljs-params">tk.Tk</span><span class="hljs-class">):</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__()
    smile = tk.PhotoImage(file=<span class="hljs-string">'smile.gif'</span>)
    tk.Label(self, image=smile).pack()
App().mainloop()
</code></pre>
    <p class="normal">If you run this example, you'll notice that no image gets displayed. That's because the variable holding the <code class="Code-In-Text--PACKT-">PhotoImage</code> object, <code class="Code-In-Text--PACKT-">smile</code>, is a local variable, and therefore destroyed as soon as the initializer returns. With no reference remaining to the <code class="Code-In-Text--PACKT-">PhotoImage</code> object, it is discarded and the image vanishes, even though we've packed it into the layout.</p>
    <p class="normal">Let's fix our script by making a simple change:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__()
    self.smile = tk.PhotoImage(file=<span class="hljs-string">'smile.gif'</span>)
    tk.Label(self, image=self.smile).pack()
</code></pre>
    <p class="normal">In this case, we've stored the <code class="Code-In-Text--PACKT-">PhotoImage</code> object in an instance variable, <code class="Code-In-Text--PACKT-">self.smile</code>. Instance variables continue to exist until the object itself is destroyed, so the picture remains on the screen.</p>
    <h2 id="_idParaDest-220" class="title">Using Pillow for extended image support</h2>
    <p class="normal">Image support in Tkinter is limited to GIF, PGM, PPM, and PNG files. If you're merely adding logos and icons to a GUI, these formats are probably sufficient, but for more graphics-heavy<a id="_idIndexMarker751"/> scenarios, the absence of such common formats<a id="_idIndexMarker752"/> as JPEG, SVG, and WebP becomes quite limiting. If you need support for any of these formats, you can use the <code class="Code-In-Text--PACKT-">Pillow</code> library.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">Pillow</code> is not part of the<a id="_idIndexMarker753"/> standard library, nor shipped with most Python distributions. To install it, follow the instructions at <a href="https://python-pillow.org/"><span class="url">https://python-pillow.org</span></a>; though in most cases, you can simply enter the following at a terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip install -U pillow
</code></pre>
    <p class="normal">This will install <code class="Code-In-Text--PACKT-">Pillow</code> from the <strong class="keyword">Python Package Index</strong> (<strong class="keyword">PyPI</strong>). Pillow provides us with a class called <code class="Code-In-Text--PACKT-">ImageTk</code>, which we can<a id="_idIndexMarker754"/> use to create <code class="Code-In-Text--PACKT-">PhotoImage</code> objects from a wide range of image file formats. To see how it works, let's build a small Tkinter-based image viewer with filters.</p>
    <p class="normal">Open a new file called <code class="Code-In-Text--PACKT-">image_viewer_demo.py</code> and start with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># image_viewer_demo.py</span>
<span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk
<span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> ttk
<span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> filedialog
<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image, ImageTk, ImageFilter
</code></pre>
    <p class="normal">Note that <code class="Code-In-Text--PACKT-">Pillow</code> is imported as <code class="Code-In-Text--PACKT-">PIL</code>. Pillow<a id="_idIndexMarker755"/> is actually a fork of a discontinued project called <code class="Code-In-Text--PACKT-">PIL</code> (Python Imaging Library). For backward compatibility, it continues to use the <code class="Code-In-Text--PACKT-">PIL</code> module name. From <code class="Code-In-Text--PACKT-">PIL</code> we're importing the <code class="Code-In-Text--PACKT-">Image</code> class, which is used to load images; the <code class="Code-In-Text--PACKT-">ImageTk</code> class, which is used to convert Pillow <code class="Code-In-Text--PACKT-">Image</code> objects for use in Tkinter; and <code class="Code-In-Text--PACKT-">ImageFilter</code>, which will provide some filters for transforming our images.</p>
    <p class="normal">Next, let's create our main application class for this app, <code class="Code-In-Text--PACKT-">PictureViewer</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PictureViewer</span><span class="hljs-class">(</span><span class="hljs-params">tk.Tk</span><span class="hljs-class">):</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, *args, **kwargs</span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)
    self.title(<span class="hljs-string">'My Image Viewer'</span>)
    self.geometry(<span class="hljs-string">'800x600'</span>)
    self.rowconfigure(<span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)
    self.columnconfigure(<span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)
</code></pre>
    <p class="normal">This class begins by subclassing <code class="Code-In-Text--PACKT-">Tk</code>, just as we did in our ABQ application, and the initializer starts with some basic window and grid layout configuration. Next, we'll create the GUI elements, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.image_display = ttk.Label(self)
    self.image_display.grid(columnspan=<span class="hljs-number">3</span>)
    ttk.Button(
      self, text=<span class="hljs-string">'Select image'</span>, command=self._choose_file
    ).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>, sticky=<span class="hljs-string">'w'</span>)
</code></pre>
    <p class="normal">So far, we just have a <code class="Code-In-Text--PACKT-">Label</code> widget for displaying<a id="_idIndexMarker756"/> the image and a <code class="Code-In-Text--PACKT-">Button</code> widget bound to an instance method, <code class="Code-In-Text--PACKT-">self._choose_file()</code>. Let's create that<a id="_idIndexMarker757"/> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_choose_file</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    filename = filedialog.askopenfilename(
      filetypes=(
        (<span class="hljs-string">'JPEG files'</span>, <span class="hljs-string">'*.jpg *.jpeg *.JPG *.JPEG'</span>),
        (<span class="hljs-string">'PNG files'</span>, <span class="hljs-string">'*.png *.PNG'</span>),
        (<span class="hljs-string">'All files'</span>, <span class="hljs-string">'*.*'</span>)
      ))
    <span class="hljs-keyword">if</span> filename:
      self.image = Image.<span class="hljs-built_in">open</span>(filename)
      self.photoimage = ImageTk.PhotoImage(self.image)
      self.image_display.config(image=self.photoimage)
</code></pre>
    <p class="normal">This method starts by asking the user for the filename with the <code class="Code-In-Text--PACKT-">filedialog.askopenfilename()</code> method we learned about in <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating Menus with Menu and Tkinter Dialogs</em>. If the user selects a file, we call the <code class="Code-In-Text--PACKT-">Image.open()</code> method to create a Pillow <code class="Code-In-Text--PACKT-">Image</code> object from the file. <code class="Code-In-Text--PACKT-">Image.open()</code> is a convenience method that simply takes a filename or path and returns an <code class="Code-In-Text--PACKT-">Image</code> object containing that file's image data. Next, we create a Tkinter <code class="Code-In-Text--PACKT-">PhotoImage</code> object by passing the <code class="Code-In-Text--PACKT-">Image</code> object to <code class="Code-In-Text--PACKT-">ImageTk.PhotoImage()</code>. Finally, we update our <code class="Code-In-Text--PACKT-">image_display</code> widget with the new <code class="Code-In-Text--PACKT-">PhotoImage</code> object.</p>
    <p class="normal">Using this approach, you can display a much wider variety of image formats in Tkinter — Pillow has full read support for over 40 different formats! However, Pillow offers far more than just image format conversions. We can also use it to edit or transform our images in a variety of ways. For example, we can apply filtering to our Pillow <code class="Code-In-Text--PACKT-">Image</code> objects. Let's add this feature to the demo application.</p>
    <p class="normal">Back up in <code class="Code-In-Text--PACKT-">PictureViewer.__init__()</code>, add the following GUI code:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.filtervar = tk.StringVar()
    filters =[
      <span class="hljs-string">'None'</span>, <span class="hljs-string">'BLUR'</span>, <span class="hljs-string">'CONTOUR'</span>, <span class="hljs-string">'DETAIL'</span>, <span class="hljs-string">'EDGE_ENHANCE'</span>,
      <span class="hljs-string">'EDGE_ENHANCE_MORE'</span>, <span class="hljs-string">'EMBOSS'</span>, <span class="hljs-string">'FIND_EDGES'</span>,
      <span class="hljs-string">'SHARPEN'</span>, <span class="hljs-string">'SMOOTH'</span>, <span class="hljs-string">'SMOOTH_MORE'</span>
    ]
    ttk.Label(self, text=<span class="hljs-string">'Filter: '</span>).grid(
      row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>, sticky=<span class="hljs-string">'e'</span>
    )
    ttk.OptionMenu(
      self, self.filtervar, <span class="hljs-string">'None'</span>, *filters
    ).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">2</span>)
    self.filtervar.trace_add(<span class="hljs-string">'write'</span>, self._apply_filter)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">filters</code> list contains the names of all the filter objects Pillow provides that we can apply to an <code class="Code-In-Text--PACKT-">Image</code> object (these can be found in the <code class="Code-In-Text--PACKT-">Pillow</code> documentation). We've added all these to an <code class="Code-In-Text--PACKT-">OptionMenu</code> along with the string <code class="Code-In-Text--PACKT-">None</code>. The <code class="Code-In-Text--PACKT-">OptionMenu</code> widget is then bound to the <code class="Code-In-Text--PACKT-">filtervar</code> control<a id="_idIndexMarker758"/> variable, on which we've added a trace<a id="_idIndexMarker759"/> that calls the <code class="Code-In-Text--PACKT-">_apply_filter()</code> method.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">_apply_filter()</code> method looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_apply_filter</span><span class="hljs-function">(</span><span class="hljs-params">self, *_</span><span class="hljs-function">):</span>
    filter_name = self.filtervar.get()
    <span class="hljs-keyword">if</span> filter_name == <span class="hljs-string">'None'</span>:
      self.filtered_image = self.image
    <span class="hljs-keyword">else</span>:
      filter_object = <span class="hljs-built_in">getattr</span>(ImageFilter, filter_name)
      self.filtered_image = self.image.<span class="hljs-built_in">filter</span>(filter_object)
    self.photoimage = ImageTk.PhotoImage(self.filtered_image)
    self.image_display.config(image=self.photoimage)
</code></pre>
    <p class="normal">First, this method retrieves the filter name from the control variable. If it's <code class="Code-In-Text--PACKT-">None</code>, we set <code class="Code-In-Text--PACKT-">self.filtered_image</code> to the current <code class="Code-In-Text--PACKT-">self.image</code> object. Otherwise, we retrieve the filter object from the <code class="Code-In-Text--PACKT-">ImageFilter</code> module using <code class="Code-In-Text--PACKT-">getattr()</code> and apply the filter to our Pillow <code class="Code-In-Text--PACKT-">Image</code> object using its <code class="Code-In-Text--PACKT-">filter()</code> method.</p>
    <p class="normal">Finally, we update the displayed image in the application by creating a new <code class="Code-In-Text--PACKT-">PhotoImage</code> object and updating the configuration of the <code class="Code-In-Text--PACKT-">Label</code> widget.</p>
    <p class="normal">To see this<a id="_idIndexMarker760"/> program in action, add the last<a id="_idIndexMarker761"/> two lines to the script:</p>
    <pre class="programlisting code"><code class="hljs-code">app = PictureViewer()
app.mainloop()
</code></pre>
    <p class="normal">You should see something that looks like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_01.png" alt="Figure 9.1: The image viewer application, filtering the Mona Lisa"/></figure>
    <p class="packt_figref">Figure 9.1: The image viewer application, filtering the Mona Lisa</p>
    <p class="normal">Now that we have a handle on using images in Tkinter, let's apply this knowledge to the ABQ Data Entry application.</p>
    <h2 id="_idParaDest-221" class="title">Adding the company logo to ABQ Data Entry</h2>
    <p class="normal">With our knowledge of <code class="Code-In-Text--PACKT-">PhotoImage</code>, adding the company logo to our program should be simple. We've been provided<a id="_idIndexMarker762"/> with several PNG files of the company logo in different sizes.</p>
    <p class="normal">You could simply copy one into the application root directory and add something<a id="_idIndexMarker763"/> like this to the <code class="Code-In-Text--PACKT-">Application</code> class's initializer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, in Application.__init__()</span>
    self.logo = tk.PhotoImage(file=<span class="hljs-string">'abq_logo_32x20.png'</span>)
    ttk.Label(
      self, text=<span class="hljs-string">"ABQ Data Entry Application"</span>,
      font=(<span class="hljs-string">"TkDefaultFont"</span>, <span class="hljs-number">16</span>),
      image=self.logo, compound=tk.LEFT
    ).grid(row=<span class="hljs-number">0</span>)
</code></pre>
    <p class="normal">In this snippet, we've created a <code class="Code-In-Text--PACKT-">PhotoImage</code> object from a file path, storing it as an instance variable so it does not go out of scope. Then, we've assigned this object to the <code class="Code-In-Text--PACKT-">image</code> argument of the application's title label, also adding the <code class="Code-In-Text--PACKT-">compound</code> argument so that the image is displayed to the left of the text.</p>
    <p class="normal">If you run the application from a terminal inside the application root directory, this approach works fine. However, if you run it from any other directory, the image won't appear. For example, try this from the command line in the directory containing your root:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> <span class="hljs-con-built_in">cd</span> ABQ_Data_Entry
<span class="hljs-con-meta">$</span> python3 abq_data_entry.py
<span class="hljs-con-comment"># the image will show when you run it this way.</span>
<span class="hljs-con-meta">$</span> <span class="hljs-con-built_in">cd</span> ..
<span class="hljs-con-meta">$</span> python3 ABQ_Data_Entry/abq_data_entry.py
<span class="hljs-con-comment"># the image will not show this way.</span>
</code></pre>
    <p class="normal">Why is this, and what can we do about it?</p>
    <h3 id="_idParaDest-222" class="title">Dealing with the image path problem</h3>
    <p class="normal">When you give Python only a filename (with no path) to open, it assumes the file is in the <strong class="keyword">current working directory</strong>. This is the directory the user was in when running the application. In the example<a id="_idIndexMarker764"/> above, when we ran the program the first time, our working<a id="_idIndexMarker765"/> directory was the application's root directory. The image was in that directory, so Python found it. The second time we ran it, our working directory was the parent directory of the application root. Python looked for the image in <em class="italic">that</em> directory, and it wasn't found.</p>
    <p class="normal">If you know where your file is on the system, you can provide an absolute path; for example, if you're on Windows 10 and the application root is on your home directory, you could do this:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.logo = tk.PhotoImage(
      file=<span class="hljs-string">r'C:\Users\myuser\ABQ_Data_Entry\abq_logo_32x20.png'</span>
    )
</code></pre>
    <p class="normal">The problem, though, is that this reference would break if we put the code anywhere else on the system. Remember, as well, that our application needs to run on Linux and Windows, so providing an absolute path like this won't work across different platforms.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">r</code> in front of the path string above makes it a raw string. When a string is marked as raw, Python<a id="_idIndexMarker766"/> does not interpret backslash escape sequences in the string. This makes raw strings useful for file paths on Windows, which uses the backslash for a path separator. See <em class="chapterRef">Chapter 10</em>, <em class="italic">Maintaining Cross-Platform Compatibility</em>, for more details on solving cross-platform path issues.</p>
    </div>
    <p class="normal">A more robust approach is to provide a relative path from some known point. Every Python script has access to a variable called <code class="Code-In-Text--PACKT-">__file__</code>, which is a string containing the path to the script file. We can use this variable in conjunction with the <code class="Code-In-Text--PACKT-">pathlib</code> module to locate files inside our application root directory.</p>
    <p class="normal">For example, we could rewrite our <code class="Code-In-Text--PACKT-">PhotoImage</code> object's configuration like this:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.logo = tk.PhotoImage(
      Path(__file__).parent.parent / <span class="hljs-string">'abq_logo_32x20.png'</span>
    )
</code></pre>
    <p class="normal">Since we are in <code class="Code-In-Text--PACKT-">application.py</code>, <code class="Code-In-Text--PACKT-">__file__</code> points to <code class="Code-In-Text--PACKT-">ABQ_Data_Entry/abq_data_entry/application.py</code>. We can use this reference point to find the parent of the parent directory, where the image files are located. This will enable Python to successfully find the images no matter what the current working directory is.</p>
    <p class="normal">This approach is functionally acceptable, but it's rather cluttered and clumsy to do these kinds of path manipulation every time we need to access an image file. Let's employ some of our organizational skills from <em class="chapterRef">Chapter 6</em>, <em class="italic">Planning for the Expansion of Our Application</em>, to put the images in their own module.</p>
    <p class="normal">Under the <code class="Code-In-Text--PACKT-">abq_data_entry</code> directory, create a new directory called <code class="Code-In-Text--PACKT-">images</code>, and place within it an appropriately sized PNG file<a id="_idIndexMarker767"/> that we can use in our<a id="_idIndexMarker768"/> application (the image in the example code has an 8x5 aspect ratio, so in this case, we're using 32x20).</p>
    <p class="normal">Next, create an <code class="Code-In-Text--PACKT-">__init__.py</code> file inside the <code class="Code-In-Text--PACKT-">images</code> folder, in which we'll add the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># images/__init__.py</span>
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
IMAGE_DIRECTORY = Path(__file__).parent
ABQ_LOGO_16 = IMAGE_DIRECTORY / <span class="hljs-string">'abq_logo-16x10.png'</span>
ABQ_LOGO_32 = IMAGE_DIRECTORY / <span class="hljs-string">'abq_logo-32x20.png'</span>
ABQ_LOGO_64 = IMAGE_DIRECTORY / <span class="hljs-string">'abq_logo-64x40.png'</span>
</code></pre>
    <p class="normal">In this case, <code class="Code-In-Text--PACKT-">__file__</code> points to <code class="Code-In-Text--PACKT-">ABQ_Data_Entry/abq_data_entry/images/__init__.py</code>, so we can use that point of reference to get paths to all the image files we put in <code class="Code-In-Text--PACKT-">ABQ_Data_Entry/abq_data_entry/images/</code>.</p>
    <p class="normal">Now, our <code class="Code-In-Text--PACKT-">application.py</code> module can import the <code class="Code-In-Text--PACKT-">images</code> module like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, at the top</span>
<span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> images
</code></pre>
    <p class="normal">Once imported, we can reference the image paths for our <code class="Code-In-Text--PACKT-">PhotoImage</code> object easily:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, inside Application.__init__()</span>
    self.logo = tk.PhotoImage(file=images.ABQ_LOGO_32)
    ttk.Label(
      self, text=<span class="hljs-string">"ABQ Data Entry Application"</span>,
      font=(<span class="hljs-string">"TkDefaultFont"</span>, <span class="hljs-number">16</span>),
      image=self.logo, compound=tk.LEFT
    ).grid(row=<span class="hljs-number">0</span>)
</code></pre>
    <p class="normal">Now, regardless of what working directory<a id="_idIndexMarker769"/> you run the script from, you should<a id="_idIndexMarker770"/> see the title looking something like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_02.png" alt="Figure 9.2: The ABQ Data Entry application sporting a company logo"/></figure>
    <p class="packt_figref">Figure 9.2: The ABQ Data Entry application sporting a company logo</p>
    <h2 id="_idParaDest-223" class="title">Setting a window icon</h2>
    <p class="normal">Currently, our application's window<a id="_idIndexMarker771"/> icon (the icon that shows up in both the window decorations and in the operating system's taskbar) is the Tkinter logo, which is the default for any Tkinter application. It would make more sense for us to use the company logo image for this icon. How can we make this happen?</p>
    <p class="normal">As a subclass of <code class="Code-In-Text--PACKT-">Tk</code>, our <code class="Code-In-Text--PACKT-">Application</code> object has a method called <code class="Code-In-Text--PACKT-">iconphoto()</code> which should, given a path to an icon file, set the window icon appropriately. Unfortunately, this method is a bit inconsistent in its results across platforms. Let's go ahead and add it to our initializer as follows and see what happens. Add this code just after the call to <code class="Code-In-Text--PACKT-">super().__init__()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, inside Application.__init__()</span>
    self.taskbar_icon = tk.PhotoImage(file=images.ABQ_LOGO_64)
    self.iconphoto(<span class="hljs-literal">True</span>, self.taskbar_icon)
</code></pre>
    <p class="normal">The first line creates another <code class="Code-In-Text--PACKT-">PhotoImage</code> object, referencing a larger version of the logo. Next, we execute <code class="Code-In-Text--PACKT-">self.iconphoto()</code>. The first argument indicates whether we want this icon to be the default across all new windows, or whether it's only for this window. Passing <code class="Code-In-Text--PACKT-">True</code> here makes it the default for all. The second argument is our <code class="Code-In-Text--PACKT-">PhotoImage</code> object.</p>
    <p class="normal">Now, when you run the application, you should see an ABQ icon being used as the window icon; how it is used depends on the platform. For example, on Windows, it shows up in the window decorations, as seen here:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_03.png" alt="Figure 9.3: The ABQ Logo as a taskbar icon"/></figure>
    <p class="packt_figref">Figure 9.3: The ABQ logo as a taskbar icon</p>
    <p class="normal">Here's a summary<a id="_idIndexMarker772"/> of how the <code class="Code-In-Text--PACKT-">iconphoto</code> is used on<a id="_idIndexMarker773"/> different platforms:</p>
    <ul>
      <li class="bullet">On Linux, it will depend on your desktop environment, but typically, it will show up in both the taskbar or dock and on the window decorations</li>
      <li class="bullet">On macOS, it will show up as the icon in the dock, but not in the global menu or on the window itself</li>
      <li class="bullet">On Windows 10, it will appear on the window decorations, but not on the taskbar</li>
    </ul>
    <p class="normal">Part of the reason for this inconsistency is that our application is a script being executed by Python, so from the operating system's point of view, the program we're running isn't ABQ Data Entry, but rather Python. For that reason, you may see the Python logo appearing instead of the ABQ logo on your platform. We'll address this further when we package our application in <em class="chapterRef">Chapter 16</em>, <em class="italic">Packaging with setuptools and cxFreeze </em>.</p>
    <h2 id="_idParaDest-224" class="title">Adding icons to buttons and menus</h2>
    <p class="normal">While not required by the users or company, you feel your application would look a little more impressive with some simple icons<a id="_idIndexMarker774"/> accompanying the text on your buttons and menu<a id="_idIndexMarker775"/> items. Unfortunately, Tkinter does not ship with<a id="_idIndexMarker776"/> any icon themes, nor is it able to access the operating<a id="_idIndexMarker777"/> system's built-in icon themes. So, in order to use icons, we'll have to first acquire some PNG or GIF images to use. These can be acquired from a number of sources online or, of course, you can create your own.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The example code comes<a id="_idIndexMarker778"/> with some icons taken from the <strong class="keyword">Open-Iconic</strong> project, which features a large selection of standard application icons released under an MIT license. You can find this project at <a href="https://useiconic.com/open"><span class="url">https://useiconic.com/open</span></a>.</p>
    </div>
    <p class="normal">Assuming you have obtained some icon files, let's add them to the <code class="Code-In-Text--PACKT-">images</code> folder and then update <code class="Code-In-Text--PACKT-">images/__init__.py</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">SAVE_ICON = IMAGE_DIRECTORY / <span class="hljs-string">'file-2x.png'</span>
RESET_ICON = IMAGE_DIRECTORY / <span class="hljs-string">'reload-2x.png'</span>
LIST_ICON = IMAGE_DIRECTORY / <span class="hljs-string">'list-2x.png'</span>
FORM_ICON = IMAGE_DIRECTORY / <span class="hljs-string">'browser-2x.png'</span>
</code></pre>
    <p class="normal">Here, we've added images for the <strong class="screenText">Save</strong> and <strong class="screenText">Reset</strong> buttons, as well as images to represent the Record List and Data Entry Form<a id="_idIndexMarker779"/> portions of the GUI. We can now begin adding these<a id="_idIndexMarker780"/> to our application; for example, let's add them to the<a id="_idIndexMarker781"/> buttons in the <code class="Code-In-Text--PACKT-">DataRecordForm</code> frame. Start<a id="_idIndexMarker782"/> by importing <code class="Code-In-Text--PACKT-">images</code> into <code class="Code-In-Text--PACKT-">views.py</code>, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, at the top</span>
<span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> images
</code></pre>
    <p class="normal">Now, in the initializer, let's update the buttons in the <code class="Code-In-Text--PACKT-">DataRecordForm</code> with image icons:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, inside DataRecordForm.__init__()</span>
    <span class="code-highlight"><strong class="hljs-slc">self.save_button_logo = tk.PhotoImage(file=images.SAVE_ICON)</strong></span>
    self.savebutton = ttk.Button(
      buttons, text=<span class="hljs-string">"Save"</span>, command=self._on_save,
      <span class="code-highlight"><strong class="hljs-slc">image=self.save_button_logo, compound=tk.LEFT</strong></span>
    )
    <span class="hljs-comment">#...</span>
    <span class="code-highlight"><strong class="hljs-slc">self.reset_button_logo = tk.PhotoImage(file=images.RESET_ICON)</strong></span>
    self.resetbutton = ttk.Button(
      buttons, text=<span class="hljs-string">"Reset"</span>, command=self.reset,
      <span class="code-highlight"><strong class="hljs-slc">image=self.reset_button_logo, compound=tk.LEFT</strong></span>
    )
</code></pre>
    <p class="normal">Now, the form should look something like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_04.png" alt="Figure 9.4: The buttons in the Data Record Form, now with icons"/></figure>
    <p class="packt_figref">Figure 9.4: The buttons in the Data Record Form, now with icons</p>
    <p class="normal">Remember that we can also add images<a id="_idIndexMarker783"/> to the <code class="Code-In-Text--PACKT-">Notebook</code> widget's tabs. Back in <code class="Code-In-Text--PACKT-">application.py</code>, locate<a id="_idIndexMarker784"/> the code in <code class="Code-In-Text--PACKT-">__init__()</code> that creates<a id="_idIndexMarker785"/> the notebook tabs and let's update<a id="_idIndexMarker786"/> it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, inside Application.__init__()</span>
    <span class="code-highlight"><strong class="hljs-slc">self.recordform_icon = tk.PhotoImage(file=images.FORM_ICON)</strong></span>
    self.recordform = v.DataRecordForm(
      self, self.model, self.settings
    )
    self.notebook.add(
      self.recordform, text=<span class="hljs-string">'Entry Form'</span>,
      <span class="code-highlight"><strong class="hljs-slc">image=self.recordform_icon, compound=tk.LEFT</strong></span>
    )
    <span class="hljs-comment">#...</span>
    <span class="code-highlight"><strong class="hljs-slc">self.recordlist_icon = tk.PhotoImage(file=images.LIST_ICON)</strong></span>
    self.recordlist = v.RecordList(self)
    self.notebook.insert(
      <span class="hljs-number">0</span>, self.recordlist, text=<span class="hljs-string">'Records'</span>,
      <span class="code-highlight"><strong class="hljs-slc">image=self.recordlist_icon, compound=tk.LEFT</strong></span>
    )
</code></pre>
    <p class="normal">It's as simple as adding an <code class="Code-In-Text--PACKT-">image</code> argument to the notebook's <code class="Code-In-Text--PACKT-">add()</code> and <code class="Code-In-Text--PACKT-">insert()</code> method calls. As with buttons and labels, be sure to include the <code class="Code-In-Text--PACKT-">compound</code> argument, or else only the icon will be displayed. Now, when we run the application, the tabs should look like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_05.png" alt="Figure 9.5: The notebook tabs with icons"/></figure>
    <p class="packt_figref">Figure 9.5: The notebook tabs with icons</p>
    <p class="normal">As you can see, the workflow for using the icons<a id="_idIndexMarker787"/> is fairly consistent:</p>
    <ol>
      <li class="numbered">Create a <code class="Code-In-Text--PACKT-">PhotoImage</code> object, making sure a reference to it will stay in scope.</li>
      <li class="numbered">Pass the object to the <code class="Code-In-Text--PACKT-">image</code> argument of the widget you want it to appear on.</li>
      <li class="numbered">Pass the widget's <code class="Code-In-Text--PACKT-">compound</code> argument to specify the layout for widgets that will display both text and the image.</li>
    </ol>
    <p class="normal">Rather than creating an individual class<a id="_idIndexMarker788"/> attribute for every icon, you may find it more efficient<a id="_idIndexMarker789"/> to store them in a dictionary<a id="_idIndexMarker790"/> object. For example, we should do this<a id="_idIndexMarker791"/> in the <code class="Code-In-Text--PACKT-">MainMenu</code> class, where we'll need a lot of icons. Import <code class="Code-In-Text--PACKT-">images</code> into <code class="Code-In-Text--PACKT-">mainmenu.py</code>, just as you did in the other two files, and let's create a new <code class="Code-In-Text--PACKT-">_create_icons()</code> instance method in <code class="Code-In-Text--PACKT-">MainMenu</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, in the MainMenu class</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_create_icons</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.icons = {
      <span class="hljs-string">'file_open'</span>: tk.PhotoImage(file=images.SAVE_ICON),
      <span class="hljs-string">'record_list'</span>: tk.PhotoImage(file=images.LIST_ICON),
      <span class="hljs-string">'new_record'</span>: tk.PhotoImage(file=images.FORM_ICON),
    }
</code></pre>
    <p class="normal">Here, we're using an instance method to create a dictionary of <code class="Code-In-Text--PACKT-">PhotoImage</code> objects and storing it as an instance attribute, <code class="Code-In-Text--PACKT-">self.icons</code>. You might wonder why we don't create <code class="Code-In-Text--PACKT-">MainMenu.icons</code> as a class attribute, similar to the <code class="Code-In-Text--PACKT-">fields</code> dictionaries we created for our models. </p>
    <p class="normal">The reason is that <code class="Code-In-Text--PACKT-">PhotoImage</code> objects, like all Tkinter objects, cannot be created until an instance of <code class="Code-In-Text--PACKT-">Tk</code> has been created (in our case, the <code class="Code-In-Text--PACKT-">Application</code> object). </p>
    <p class="normal">Class definitions, and therefore class attributes, are executed by Python before the main thread of execution begins, so there would be no <code class="Code-In-Text--PACKT-">Application</code> object when this class is defined.</p>
    <p class="normal">We can call this method inside<a id="_idIndexMarker792"/> the initializer to make sure <code class="Code-In-Text--PACKT-">self.icons</code> is populated before<a id="_idIndexMarker793"/> we define the menu; add that code like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside the MainMenu class</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, parent, settings, **kwargs</span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__(parent, **kwargs)
    self.settings = settings
    <span class="code-highlight"><strong class="hljs-slc">self._create_icons()</strong></span>
</code></pre>
    <p class="normal">Now, each menu item can access its <code class="Code-In-Text--PACKT-">PhotoImage</code> object via the dictionary, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside MainMenu.__init__()</span>
    file_menu.add_command(
      label=<span class="hljs-string">"Select file…"</span>, command=self._event(<span class="hljs-string">'&lt;&lt;FileSelect&gt;&gt;'</span>),
      <span class="code-highlight"><strong class="hljs-slc">image=self.icons['file_open'], compound=tk.LEFT</strong></span>
    )
    <span class="hljs-comment">#...</span>
    go_menu.add_command(
      label=<span class="hljs-string">"Record List"</span>, command=self._event(<span class="hljs-string">'&lt;&lt;ShowRecordlist&gt;&gt;'</span>),
      <span class="code-highlight"><strong class="hljs-slc">image=self.icons['record_list'], compound=tk.LEFT</strong></span>
    )
    go_menu.add_command(
      label=<span class="hljs-string">"New Record"</span>, command=self._event(<span class="hljs-string">'&lt;&lt;NewRecord&gt;&gt;'</span>),
      <span class="code-highlight"><strong class="hljs-slc">image=self.icons['new_record'], compound=tk.LEFT</strong></span>
    )
</code></pre>
    <p class="normal">Now our menu<a id="_idIndexMarker794"/> boasts some professional-looking<a id="_idIndexMarker795"/> icons, as shown here:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_06.png" alt="Figure 9.6: The &quot;Go&quot; menu, with some nice icons"/></figure>
    <p class="packt_figref">Figure 9.6: The Go menu, with some nice icons</p>
    <h3 id="_idParaDest-225" class="title">Using BitmapImage</h3>
    <p class="normal">Using <code class="Code-In-Text--PACKT-">PhotoImage</code> with PNG files<a id="_idIndexMarker796"/> is more than sufficient for our application, but there is one other option for images in Tkinter that bears mentioning: <code class="Code-In-Text--PACKT-">BitmapImage</code>. The <code class="Code-In-Text--PACKT-">BitmapImage</code> object is similar to <code class="Code-In-Text--PACKT-">PhotoImage</code>, but works exclusively with <strong class="keyword">XBM</strong> (X11 Bitmap) files. This is a very old image format that only allows for monochromatic<a id="_idIndexMarker797"/> images. Despite being monochromatic, XBM images are not compressed, and therefore not smaller than PNG files of equivalent size. The only real advantage to a <code class="Code-In-Text--PACKT-">BitmapImage</code> object is that we can tell Tkinter to render it with any colors we wish.</p>
    <p class="normal">To see how this works, let's add a few XBM files to our <code class="Code-In-Text--PACKT-">images</code> module; copy in some XBM files and then add them to <code class="Code-In-Text--PACKT-">__init__.py</code>, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">QUIT_BMP = IMAGE_DIRECTORY / <span class="hljs-string">'x-2x.xbm'</span>
ABOUT_BMP = IMAGE_DIRECTORY / <span class="hljs-string">'question-mark-2x.xbm'</span>
</code></pre>
    <div class="note">
      <p class="Information-Box--PACKT-">Some XBM files are included in the sample code; alternatively, you can convert your own image files to XBM using image editing software like the GNU Image Manipulation Program from <a href="https://www.gimp.org"><span class="url">https://www.gimp.org</span></a>.</p>
    </div>
    <p class="normal">Now, back in <code class="Code-In-Text--PACKT-">mainmenu.py</code>, let's add them to our <code class="Code-In-Text--PACKT-">icons</code> dictionary, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, in MainMenu._create_icons()</span>
    self.icons = {
      <span class="hljs-comment">#...</span>
      <span class="code-highlight"><strong class="hljs-slc">'quit': tk.BitmapImage(</strong></span>
        <span class="code-highlight"><strong class="hljs-slc">file=images.QUIT_BMP, foreground='red'</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">),</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">'about': tk.BitmapImage(</strong></span>
        <span class="code-highlight"><strong class="hljs-slc">file=images.ABOUT_BMP,</strong></span>
        <span class="code-highlight"><strong class="hljs-slc">foreground='#CC0', background='#A09'</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">)</strong></span>
    }
</code></pre>
    <p class="normal">As you can see, creating a <code class="Code-In-Text--PACKT-">BitmapImage</code> is identical to creating a <code class="Code-In-Text--PACKT-">PhotoImage</code> object, but with the possibility of specifying <code class="Code-In-Text--PACKT-">foreground</code> and <code class="Code-In-Text--PACKT-">background</code> colors for the image. Once created, adding them to the menu<a id="_idIndexMarker798"/> item is identical to using <code class="Code-In-Text--PACKT-">PhotoImage</code>, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside MainMenu.__init__()</span>
    help_menu.add_command(
      label=<span class="hljs-string">'About…'</span>, command=self.show_about,
      <span class="code-highlight"><strong class="hljs-slc">image=self.icons['about'], compound=tk.LEFT</strong></span>
    )
    <span class="hljs-comment">#...</span>
    file_menu.add_command(
      label=<span class="hljs-string">"Quit"</span>, command=self._event(<span class="hljs-string">'&lt;&lt;FileQuit&gt;&gt;'</span>),
      <span class="code-highlight"><strong class="hljs-slc">image=self.icons['quit'], compound=tk.LEFT</strong></span>
    )
</code></pre>
    <p class="normal">Now the <strong class="screenText">Help</strong> menu should have a colorful icon, as shown here:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_07.png" alt="Figure 9.7: The now colorful About icon"/></figure>
    <p class="packt_figref">Figure 9.7: The now colorful About icon</p>
    <p class="normal">You may find <code class="Code-In-Text--PACKT-">BitmapImage</code> objects useful if you want to reuse a single file with different colors, or perhaps dynamically change the color scheme of your icons to fit with a theme or indicate some kind<a id="_idIndexMarker799"/> of state. Most of the time, though, using <code class="Code-In-Text--PACKT-">PhotoImage</code> objects will be preferable.</p>
    <p class="normal">These images have dramatically changed the look of our application, but the rest of it is still a rather drab gray. In the next sections, we'll work on updating its colors.</p>
    <h1 id="_idParaDest-226" class="title">Styling Tkinter widgets</h1>
    <p class="normal">Tkinter has<a id="_idIndexMarker800"/> essentially two styling systems: the old Tkinter widgets system, and the newer Ttk system. Although we are using Ttk widgets wherever possible, there are still situations where regular Tkinter widgets are required, so it's good to know both systems. Let's take a look first at the older Tkinter system and apply some styling to the Tkinter widgets in our application.</p>
    <h2 id="_idParaDest-227" class="title">Widget color properties</h2>
    <p class="normal">As you saw in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Tkinter</em>, basic Tkinter widgets allow you to change two color values: the foreground<a id="_idIndexMarker801"/> color, meaning mainly the color of text<a id="_idIndexMarker802"/> and borders, and the background color, meaning the rest of the widget. These can be set using the <code class="Code-In-Text--PACKT-">foreground</code> and <code class="Code-In-Text--PACKT-">background</code> arguments, or their aliases, <code class="Code-In-Text--PACKT-">fg</code> and <code class="Code-In-Text--PACKT-">bg</code>.</p>
    <p class="normal">For example, we can set the colors of a label like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># tkinter_color_demo.py</span>
<span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk
l = tk.Label(text=<span class="hljs-string">'Hot Dog Stand!'</span>, fg=<span class="hljs-string">'yellow'</span>, bg=<span class="hljs-string">'red'</span>)
</code></pre>
    <p class="normal">The values for the colors can be color name strings or CSS-style RGB hex strings.</p>
    <p class="normal">For example, this code produces the same effect:</p>
    <pre class="programlisting code"><code class="hljs-code">l2 = tk.Label(
  text=<span class="hljs-string">'Also Hot Dog Stand!'</span>,
  foreground=<span class="hljs-string">'#FFFF00'</span>,
  background=<span class="hljs-string">'#FF0000'</span>
)
</code></pre>
    <div class="note">
      <p class="Information-Box--PACKT-">There are over 700 named colors<a id="_idIndexMarker803"/> recognized by Tkinter, roughly corresponding to those recognized by the X11 display server used on Linux and Unix, or the CSS named colors used by web designers. For a complete list, see <a href="https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm"><span class="url">https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm</span></a>.</p>
    </div>
    <h3 id="_idParaDest-228" class="title">Using widget properties on the MainMenu</h3>
    <p class="normal">We aren't using many Tkinter widgets in our views, preferring Ttk as much as possible. One place where we <em class="italic">are</em> using a Tkinter widget is our application's main menu. We can use the main menu<a id="_idIndexMarker804"/> to demonstrate how Tkinter widget colors can be configured.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that setting colors and other appearance options on the menu system <em class="italic">only</em> works consistently on Linux or BSD. The effect on Windows or macOS is incomplete, so readers on those platforms may see incomplete results. In <em class="chapterRef">Chapter 10</em>, <em class="italic">Maintaining Cross-Platform Compatibility</em>, we'll redesign our menu so that these differences in compatibility are accounted for. </p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">tk.Menu</code> widget accepts<a id="_idIndexMarker805"/> the following appearance-related arguments:</p>
    <table id="table001-5" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Argument</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Values</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Description</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">background</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Color string</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The color of the background under normal conditions</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">foreground</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Color string</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The color of the foreground (text) under normal conditions</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">borderwidth</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Integer</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The width of the widget border, in pixels, under normal conditions</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">activebackground</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Color string</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The background color when the widget is active (being hovered over or selected via the keyboard)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">activeforeground</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Color string</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The foreground (text) color when the widget is active</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">activeborderwidth</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Integer</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The border width, in pixels, of the widget when active</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">disabledforeground</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Color string</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The foreground (text) color when the widget is disabled</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">relief</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">One of the Tkinter constants <code class="Code-In-Text--PACKT-">RAISED</code>, <code class="Code-In-Text--PACKT-">SUNKEN</code>, <code class="Code-In-Text--PACKT-">FLAT</code>, <code class="Code-In-Text--PACKT-">RIDGE</code>, <code class="Code-In-Text--PACKT-">SOLID</code>, or <code class="Code-In-Text--PACKT-">GROOVE</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The style of the border drawn around the widget</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Note that there are versions of <code class="Code-In-Text--PACKT-">background</code>, <code class="Code-In-Text--PACKT-">foreground</code>, and <code class="Code-In-Text--PACKT-">borderwidth</code> for both the normal and active states, and a version of <code class="Code-In-Text--PACKT-">foreground</code> for the disabled state. Depending on what is applicable<a id="_idIndexMarker806"/> to the widget, many Tkinter widgets support additional arguments for certain states, conditions, or features; for example, widgets with selectable text like the <code class="Code-In-Text--PACKT-">Entry</code> widget support <code class="Code-In-Text--PACKT-">highlightbackground</code> and <code class="Code-In-Text--PACKT-">highlightforeground</code> arguments to specify the colors used when text is selected.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The Tcl/Tk documentation at <a href="https://www.tcl.tk/man/"><span class="url">https://www.tcl.tk/man/</span></a> provides the most complete<a id="_idIndexMarker807"/> reference for widget-specific options, including styling options.</p>
    </div>
    <p class="normal">Open up the <code class="Code-In-Text--PACKT-">mainmenu.py</code> file and let's add some styles to our menu inside the initializer method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside MainMenu.__init__()</span>
    self.configure(
      background=<span class="hljs-string">'#333'</span>,
      foreground=<span class="hljs-string">'white'</span>,
      activebackground=<span class="hljs-string">'#777'</span>,
      activeforeground=<span class="hljs-string">'white'</span>,
      <span class="hljs-string">'relief'</span>=tk.GROOVE
    )
</code></pre>
    <p class="normal">Execute the application, and note the menu's appearance. On Linux or BSD, it should look something like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_08.png" alt="Figure 9.8: A styled Tkinter menu on Ubuntu Linux"/></figure>
    <p class="packt_figref">Figure 9.8: A styled Tkinter menu on Ubuntu Linux</p>
    <p class="normal">Note that the styling does not go past the main menu; the sub-menus are still the default black-on-gray. To make the menu consistent, we'll need to apply these styles to all the sub-menus<a id="_idIndexMarker808"/> as well. To avoid a lot of repetition, let's change our code so that the styles are stored in a dictionary, which we can then unpack in each call to <code class="Code-In-Text--PACKT-">tk.Menu</code>. Update the code like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside MainMenu.__init__()</span>
    self.styles = {
      <span class="hljs-string">'background'</span>: <span class="hljs-string">'#333'</span>,
      <span class="hljs-string">'foreground'</span>: <span class="hljs-string">'white'</span>,
      <span class="hljs-string">'activebackground'</span>: <span class="hljs-string">'#777'</span>,
      <span class="hljs-string">'activeforeground'</span>: <span class="hljs-string">'white'</span>,
      <span class="hljs-string">'relief'</span>: tk.GROOVE
    }
    self.configure(**self.styles)
</code></pre>
    <p class="normal">Now, to add the styling to each sub-menu, we just need to add <code class="Code-In-Text--PACKT-">**self.styles</code> to each sub-menu initialization, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside MainMenu.__init__()</span>
    help_menu = tk.Menu(self, tearoff=<span class="hljs-literal">False</span>, <span class="code-highlight"><strong class="hljs-slc">**self.styles</strong></span>)
    <span class="hljs-comment">#...</span>
    file_menu = tk.Menu(self, tearoff=<span class="hljs-literal">False</span>, <span class="code-highlight"><strong class="hljs-slc">**self.styles</strong></span>)
    <span class="hljs-comment">#...</span>
    options_menu = tk.Menu(self, tearoff=<span class="hljs-literal">False</span>, <span class="code-highlight"><strong class="hljs-slc">**self.styles</strong></span>)
    <span class="hljs-comment">#...</span>
    go_menu = tk.Menu(self, tearoff=<span class="hljs-literal">False</span>, <span class="code-highlight"><strong class="hljs-slc">**self.styles</strong></span>)
</code></pre>
    <p class="normal">Assuming your platform supports menu styling, you should now see the styles applied to the sub-menus as well.</p>
    <h2 id="_idParaDest-229" class="title">Styling widget content with tags</h2>
    <p class="normal">Foreground and background<a id="_idIndexMarker809"/> colors are sufficient for simple widgets<a id="_idIndexMarker810"/> such as buttons and labels, but more<a id="_idIndexMarker811"/> complex Tkinter widgets like the <code class="Code-In-Text--PACKT-">Text</code> widget or the Ttk <code class="Code-In-Text--PACKT-">Treeview</code> widget rely on a <strong class="keyword">tag</strong>-based system for more detailed styling. A <strong class="keyword">tag</strong> in Tkinter is a named region of a widget's content to which color and font settings<a id="_idIndexMarker812"/> can be applied. To see how this works, let's build a crude, but pretty, Python<a id="_idIndexMarker813"/> terminal emulator.</p>
    <p class="normal">Open a new file called <code class="Code-In-Text--PACKT-">tags_demo.py</code>, and we'll start by creating a <code class="Code-In-Text--PACKT-">Text</code> widget to store the terminal input and output:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># tags_demo.py</span>
<span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk
text = tk.Text(width=<span class="hljs-number">50</span>, height=<span class="hljs-number">20</span>, bg=<span class="hljs-string">'black'</span>, fg=<span class="hljs-string">'lightgreen'</span>)
text.pack()
</code></pre>
    <p class="normal">Here, we've used the <code class="Code-In-Text--PACKT-">fg</code> and <code class="Code-In-Text--PACKT-">bg</code> arguments to set up a green-on-black terminal theme, a classic combination popular with programmers. Rather than having only green text, though, let's configure different colors for our prompt and our interpreter output.</p>
    <p class="normal">To do this, we'll define some tags:</p>
    <pre class="programlisting code"><code class="hljs-code">text.tag_configure(<span class="hljs-string">'prompt'</span>, foreground=<span class="hljs-string">'magenta'</span>)
text.tag_configure(<span class="hljs-string">'output'</span>, foreground=<span class="hljs-string">'yellow'</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">tag_configure()</code> method allows us to declare and configure tags on the <code class="Code-In-Text--PACKT-">Text</code> widget. We've created one called <code class="Code-In-Text--PACKT-">prompt</code> with magenta text for the shell prompt, and another called <code class="Code-In-Text--PACKT-">output</code> with yellow text for the Python output. Note that we aren't restricted to a single configuration argument here; we could conceivably pass a <code class="Code-In-Text--PACKT-">font</code> or <code class="Code-In-Text--PACKT-">background</code> argument as well, if we wished.</p>
    <p class="normal">To insert text with a given tag applied, we do the following:</p>
    <pre class="programlisting code"><code class="hljs-code">text.insert(<span class="hljs-string">'end'</span>, <span class="hljs-string">'&gt;&gt;&gt; '</span>, (<span class="hljs-string">'prompt'</span>,))
</code></pre>
    <p class="normal">As you may remember, the <code class="Code-In-Text--PACKT-">Text.insert()</code> method takes an index and string as its first two arguments. Notice the third argument: this is a tuple of the tags with which we want to mark the inserted text. This value must be a tuple, even if you're only using one tag; naturally, you can include as many tags as you wish.</p>
    <p class="normal">If you add <code class="Code-In-Text--PACKT-">text.mainloop()</code> to the end of the code and run it, you'll see that we have a black text entry window with a magenta prompt; however, if you type anything, your text will show up in green (the widget's default foreground color). So far so good; now, let's make it execute some Python.</p>
    <p class="normal">Create a function just before the <code class="Code-In-Text--PACKT-">mainloop()</code> call:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">on_return</span><span class="hljs-function">(</span><span class="hljs-params">*args</span><span class="hljs-function">):</span>
  cmd = text.get(<span class="hljs-string">'prompt.last'</span>, <span class="hljs-string">'end'</span>).strip()
</code></pre>
    <p class="normal">Recall that, when retrieving text from a <code class="Code-In-Text--PACKT-">Text</code> widget, we're required to supply start and end indices for the text<a id="_idIndexMarker814"/> we want to retrieve. We can utilize tag names<a id="_idIndexMarker815"/> in our index values, as we've done here: <code class="Code-In-Text--PACKT-">prompt.last</code> tells Tkinter to fetch the text starting <em class="italic">after</em> the end of the region tagged <code class="Code-In-Text--PACKT-">prompt</code>.</p>
    <p class="normal">Next, let's execute the entered command:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> cmd:
    <span class="hljs-keyword">try</span>:
      output = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(cmd))
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
      output = <span class="hljs-built_in">str</span>(e)
</code></pre>
    <p class="normal">If the <code class="Code-In-Text--PACKT-">cmd</code> variable actually contains anything, we'll try to execute it with <code class="Code-In-Text--PACKT-">eval()</code>, and then store a string of the response value as output. If it raises an exception, we'll cast our exception to a string and set that as the output.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Note that <code class="Code-In-Text--PACKT-">eval()</code> only works on expressions, so our "shell" won't be able to handle loops, conditionals, or other statements.</p>
    </div>
    <p class="normal">Then, we'll just show our output, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-comment"># (still in the if block)</span>
    text.insert(<span class="hljs-string">'end'</span>, <span class="hljs-string">'\n'</span> + output, (<span class="hljs-string">'output'</span>,))
</code></pre>
    <p class="normal">Here, we've inserted our <code class="Code-In-Text--PACKT-">output</code> string, prefixed with a newline and tagged as <code class="Code-In-Text--PACKT-">output</code>.</p>
    <p class="normal">We'll finish off the function by giving the user back a prompt:</p>
    <pre class="programlisting code"><code class="hljs-code">  text.insert(<span class="hljs-string">'end'</span>, <span class="hljs-string">'\n&gt;&gt;&gt; '</span>, (<span class="hljs-string">'prompt'</span>,))
  <span class="hljs-keyword">return</span> <span class="hljs-string">'break'</span>
</code></pre>
    <p class="normal">Note that we also return the string <code class="Code-In-Text--PACKT-">break</code> here. This tells Tkinter to ignore the original event that triggered the callback. Since we're going to trigger this from a <span class="keyStroke">Return</span>/<span class="keyStroke">Enter</span> keystroke, we want to ignore that keystroke after we're finished. If we don't, the keystroke will be executed <em class="italic">after</em> our function returns, inserting the newline after the display of the prompt and leaving the user on the line under the prompt.</p>
    <p class="normal">Finally, we need to bind our function to the <span class="keyStroke">Return</span> key:</p>
    <pre class="programlisting code"><code class="hljs-code">text.bind(<span class="hljs-string">'&lt;Return&gt;'</span>, on_return)
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Note that the event for the <span class="keyStroke">Enter</span>/<span class="keyStroke">Return</span> key is always <code class="Code-In-Text--PACKT-">&lt;Return&gt;</code>, even on non-Apple hardware (where the key is more commonly labeled "Enter").</p>
    </div>
    <p class="normal">Make sure to add<a id="_idIndexMarker816"/> a call to <code class="Code-In-Text--PACKT-">text.mainloop()</code> at the end of the script, and then launch<a id="_idIndexMarker817"/> the application. You should get something like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_09.png" alt="Figure 9.9: The colorful Python shell"/></figure>
    <p class="packt_figref">Figure 9.9: The colorful Python shell</p>
    <p class="normal">While this shell won't be supplanting IDLE any time soon, it does look rather nice, don't you think?</p>
    <h3 id="_idParaDest-230" class="title">Styling our record list with tags</h3>
    <p class="normal">Although <code class="Code-In-Text--PACKT-">Treeview</code> is a Ttk widget, it uses tags to control the styling of individual rows. We can use this capability to address<a id="_idIndexMarker818"/> another of the requests you've gotten from<a id="_idIndexMarker819"/> the data entry staff – specifically, that they'd like the record list to highlight the records updated and inserted during the current session.</p>
    <p class="normal">The first thing we'll need<a id="_idIndexMarker820"/> to do is have our <code class="Code-In-Text--PACKT-">RecordList</code> object keep track<a id="_idIndexMarker821"/> of which rows have been updated or inserted during the session.</p>
    <p class="normal">We'll start in <code class="Code-In-Text--PACKT-">RecordList.__init__()</code> by creating a couple of instance variables to store the updated or inserted rows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, inside RecordList.__init__()</span>
    <span class="hljs-built_in">super</span>().__init__(parent, *args, **kwargs)
    <span class="code-highlight"><strong class="hljs-slc">self._inserted = list()</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">self._updated = list()</strong></span>
</code></pre>
    <p class="normal">When a record is inserted or updated, we'll need to append its row number to the appropriate list. Since <code class="Code-In-Text--PACKT-">RecordList</code> doesn't know when a record is updated or inserted, we'll have to create some public methods that the <code class="Code-In-Text--PACKT-">Application</code> object can call to append to the lists. Create these two methods in the <code class="Code-In-Text--PACKT-">RecordList</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, inside RecordList</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">add_updated_row</span><span class="hljs-function">(</span><span class="hljs-params">self, row</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">if</span> row <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._updated:
      self._updated.append(row)
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">add_inserted_row</span><span class="hljs-function">(</span><span class="hljs-params">self, row</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">if</span> row <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._inserted:
      self._inserted.append(row)
</code></pre>
    <p class="normal">Each method takes a row number and appends it to the corresponding list. To avoid duplicates, we only do so if the row is not in the list. Now, to use these methods, we'll have to update the <code class="Code-In-Text--PACKT-">Application._on_save()</code> method so that it calls the appropriate update method <em class="italic">after</em> the record is saved, but <em class="italic">before</em> we repopulate the record list.</p>
    <p class="normal">In <code class="Code-In-Text--PACKT-">_on_save()</code>, right after calling <code class="Code-In-Text--PACKT-">self.model.save_record()</code>, add these lines:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, in Application._on_save()</span>
    <span class="hljs-keyword">if</span> rownum <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
      self.recordlist.add_updated_row(rownum)
</code></pre>
    <p class="normal">Updates have a <code class="Code-In-Text--PACKT-">rownum</code> value that is not <code class="Code-In-Text--PACKT-">None</code>, but could be <code class="Code-In-Text--PACKT-">0</code>, so we explicitly test for <code class="Code-In-Text--PACKT-">None</code> here rather than just using <code class="Code-In-Text--PACKT-">if rownum:</code>. If <code class="Code-In-Text--PACKT-">rownum</code> is not <code class="Code-In-Text--PACKT-">None</code>, we'll append it to the updated list.</p>
    <p class="normal">Now, we need to deal with inserts:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">else</span>:
      rownum = <span class="hljs-built_in">len</span>(self.model.get_all_records()) -<span class="hljs-number">1</span>
      self.recordlist.add_inserted_row(rownum)
</code></pre>
    <p class="normal">Inserted records are a little more troublesome in that we don't have a row number readily available to record. We<a id="_idIndexMarker822"/> do know that an insert is always appended to the<a id="_idIndexMarker823"/> end of the file, though, so its row number should be one smaller than the number of rows in the file.</p>
    <p class="normal">Our inserted and updated records will be kept until the end of the program session (when the user exits the program) or until the user selects a new file to work on. If the user selects a new file, we will need to clear out the lists since we're working with a completely new set of records.</p>
    <p class="normal">Once again, since <code class="Code-In-Text--PACKT-">RecordList</code> doesn't know when this happens, we'll need to create a public method that clears the lists. Add the following <code class="Code-In-Text--PACKT-">clear_tags()</code> method to the <code class="Code-In-Text--PACKT-">RecordList</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, inside RecordList</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">clear_tags</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self._inserted.clear()
    self._updated.clear()
</code></pre>
    <p class="normal">Now we need the <code class="Code-In-Text--PACKT-">Application</code> class to call this whenever a new file is selected for saving, which happens in <code class="Code-In-Text--PACKT-">Application._on_file_select()</code>. Add a call to the method just before repopulating the record list:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py inside Application._on_file_select()</span>
    <span class="hljs-keyword">if</span> filename:
      self.model = m.CSVModel(filename=filename)
      <span class="code-highlight"><strong class="hljs-slc">self.recordlist.clear_tags()</strong></span>
      self._populate_recordlist()
</code></pre>
    <p class="normal">Now that we have these lists updating correctly, we need to use them to color-code the list items.</p>
    <p class="normal">To do this, we first need to configure tags with appropriate colors. Our data entry staff feel that light green would be a sensible color for inserted records, and light blue for updated.</p>
    <p class="normal">Add the following code at the end of <code class="Code-In-Text--PACKT-">RecordList.__init__()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, inside RecordList.__init__()    </span>
    self.treeview.tag_configure(
      <span class="hljs-string">'inserted'</span>, background=<span class="hljs-string">'lightgreen'</span>
    
    self.treeview.tag_configure(<span class="hljs-string">'updated'</span>, background=<span class="hljs-string">'lightblue'</span>)
</code></pre>
    <p class="normal">Just as we did with the <code class="Code-In-Text--PACKT-">Text</code> widget earlier, we call the <code class="Code-In-Text--PACKT-">TreeView</code> object's <code class="Code-In-Text--PACKT-">tag_configure()</code> method<a id="_idIndexMarker824"/> to connect <code class="Code-In-Text--PACKT-">background</code> color settings with our tag names. To add<a id="_idIndexMarker825"/> the tags to our <code class="Code-In-Text--PACKT-">TreeView</code> rows, we'll need to update the <code class="Code-In-Text--PACKT-">populate()</code> method so that as rows are inserted, the appropriate tag (if any) is added.</p>
    <p class="normal">Inside the <code class="Code-In-Text--PACKT-">populate()</code> method's <code class="Code-In-Text--PACKT-">for</code> loop, just before inserting the row, we'll add this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, inside RecordList.populate()</span>
    <span class="hljs-keyword">for</span> rownum, rowdata <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(rows):
      values = [rowdata[cid] <span class="hljs-keyword">for</span> cid <span class="hljs-keyword">in</span> cids]
      <span class="hljs-keyword">if</span> rownum <span class="hljs-keyword">in</span> self._inserted:
        tag = <span class="hljs-string">'inserted'</span>
      <span class="hljs-keyword">elif</span> rownum <span class="hljs-keyword">in</span> self._updated:
        tag = <span class="hljs-string">'updated'</span>
      <span class="hljs-keyword">else</span>:
        tag = <span class="hljs-string">''</span>
</code></pre>
    <p class="normal">Now, our <code class="Code-In-Text--PACKT-">treeview.insert()</code> call just needs to be amended with this tag value:</p>
    <pre class="programlisting code"><code class="hljs-code">      self.treeview.insert(
        <span class="hljs-string">''</span>, <span class="hljs-string">'end'</span>, iid=<span class="hljs-built_in">str</span>(rownum),
        text=<span class="hljs-built_in">str</span>(rownum), values=values, <span class="code-highlight"><strong class="hljs-slc">tag=tag</strong></span>
      )
</code></pre>
    <p class="normal">Run the application and try to insert and update some records.</p>
    <p class="normal">You should get something like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_10.png" alt="Figure 9.10: The treeview with styled rows"/></figure>
    <p class="packt_figref">Figure 9.10: The treeview with styled rows. The light blue corresponds to updated rows (row 0) and the light green to inserted rows (row 1). Note that the dark blue row is just the selected row (row 2).</p>
    <div class="note">
      <p class="Information-Box--PACKT-">In addition to the <code class="Code-In-Text--PACKT-">Text</code> and <code class="Code-In-Text--PACKT-">Treeview</code> widgets, tags are also used with the Tkinter <code class="Code-In-Text--PACKT-">Canvas</code> widget, which we'll learn more about in <em class="chapterRef">Chapter 15</em>, <em class="italic">Visualizing Data Using the Canvas Widget</em>.</p>
    </div>
    <h1 id="_idParaDest-231" class="title">Working with fonts in Tkinter</h1>
    <p class="normal">Some of our data<a id="_idIndexMarker826"/> entry users have complained that the font of the application is just a little too small to read easily, but others dislike the idea of you increasing it because it makes the application too big for the screen. To accommodate all the users, we can add a configuration option that allows them to set a preferred font size and family.</p>
    <h2 id="_idParaDest-232" class="title">Configuring Tkinter fonts</h2>
    <p class="normal">Any widget in Tkinter that displays text allows us to specify a font, typically through its <code class="Code-In-Text--PACKT-">font</code> configuration<a id="_idIndexMarker827"/> property. For widgets that support tags, we can also specify font settings for each tag. We've been using the <code class="Code-In-Text--PACKT-">font</code> argument as far back as <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Tkinter</em>, but now it's time to take a deeper look into what Tkinter allows us to do with fonts.</p>
    <p class="normal">There are three ways of specifying a widget's font in Tkinter: using a string, using a tuple, and using a <code class="Code-In-Text--PACKT-">Font</code> object. Let's take a look at each one.</p>
    <h3 id="_idParaDest-233" class="title">Configuring fonts with strings and tuples</h3>
    <p class="normal">The simplest<a id="_idIndexMarker828"/> way to configure a font in Tkinter<a id="_idIndexMarker829"/> is to just use a font<a id="_idIndexMarker830"/> specification string:</p>
    <pre class="programlisting code"><code class="hljs-code">tk.Label(text=<span class="hljs-string">"Format with a string"</span>, font=<span class="hljs-string">"Times 20 italic bold"</span>)
</code></pre>
    <p class="normal">The string<a id="_idIndexMarker831"/> takes the format <code class="Code-In-Text--PACKT-">font-family size styles</code>, where:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">font-family</code> is the name of the font family. It can only be a single word; no spaces are allowed.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">size</code> is an integer describing the size. A positive integer indicates a size in <em class="italic">points</em>, a negative indicates a size in <em class="italic">pixels</em>. Float values are not supported.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">styles</code> can be any valid combination of text style keywords.</li>
    </ul>
    <p class="normal">Everything but the font family is optional, though you need to specify a size if you want to specify any of the styling keywords. The keywords that can be used for styles include:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">bold</code> for boldface text, or <code class="Code-In-Text--PACKT-">normal</code> for normal weight</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">italic</code> for italicized text, or <code class="Code-In-Text--PACKT-">roman</code> for regular slant</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">underline</code> for underlined text</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">overstrike</code> for struck-out text</li>
    </ul>
    <p class="normal">The ordering of style keywords doesn't matter, but the weight and slant keywords are mutually exclusive (that is, you can't have <code class="Code-In-Text--PACKT-">bold normal</code> or <code class="Code-In-Text--PACKT-">italic roman</code>).</p>
    <p class="normal">While quick and<a id="_idIndexMarker832"/> simple, the string approach has its shortcomings; for one, it can't handle fonts with spaces in the name, something that is fairly common on modern systems.</p>
    <p class="normal">To handle fonts like that, you can use the tuple format:</p>
    <pre class="programlisting code"><code class="hljs-code">tk.Label(
  text=<span class="hljs-string">"Tuple font format"</span>,
  font=(<span class="hljs-string">'Noto sans'</span>, <span class="hljs-number">15</span>, <span class="hljs-string">'overstrike'</span>)
)
</code></pre>
    <p class="normal">This format is exactly like the string format, except that the different components are written as items in a tuple. </p>
    <p class="normal">The size component can be an integer or a string containing digits, which provides some flexibility depending on where the value comes from.</p>
    <h3 id="_idParaDest-234" class="title">The font module</h3>
    <p class="normal">The string or tuple approach works fine for setting up a handful of font changes at launch time, but for situations where we need to dynamically manipulate font settings, Tkinter offers the <code class="Code-In-Text--PACKT-">font</code> module. This module offers us a few font-related functions as well as a <code class="Code-In-Text--PACKT-">Font</code> class, whose<a id="_idIndexMarker833"/> instances can be assigned to widgets and dynamically changed.</p>
    <p class="normal">To use the <code class="Code-In-Text--PACKT-">font</code> module, it must first be imported:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> font
</code></pre>
    <p class="normal">Now, we can create a custom <code class="Code-In-Text--PACKT-">Font</code> object and assign it to some widgets:</p>
    <pre class="programlisting code"><code class="hljs-code">labelfont = font.Font(
  family=<span class="hljs-string">'Courier'</span>, size=<span class="hljs-number">30</span>,
  weight=<span class="hljs-string">'bold'</span>, slant=<span class="hljs-string">'roman'</span>,
  underline=<span class="hljs-literal">False</span>, overstrike=<span class="hljs-literal">False</span>
)
tk.Label(text=<span class="hljs-string">'Using the Font class'</span>, font=labelfont).pack()
</code></pre>
    <p class="normal">As you can see, the values passed to the <code class="Code-In-Text--PACKT-">Font</code> initializer arguments correlate with the weight and slant values used in string and tuple font specifications. The <code class="Code-In-Text--PACKT-">weight</code> argument also supports the use of the constants <code class="Code-In-Text--PACKT-">font.NORMAL</code> or <code class="Code-In-Text--PACKT-">font.BOLD</code>, while <code class="Code-In-Text--PACKT-">slant</code> supports the use of <code class="Code-In-Text--PACKT-">font.ITALIC</code> or <code class="Code-In-Text--PACKT-">font.ROMAN</code>.</p>
    <p class="normal">Once we've created a <code class="Code-In-Text--PACKT-">Font</code> object and assigned it to one or more widgets, we can dynamically alter aspects of it at runtime. For example, we could create a button that will toggle the <code class="Code-In-Text--PACKT-">overstrike</code> property of our font:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">toggle_overstrike</span><span class="hljs-function">():</span>
  labelfont[<span class="hljs-string">'overstrike'</span>] = <span class="hljs-keyword">not</span> labelfont[<span class="hljs-string">'overstrike'</span>]
tk.Button(text=<span class="hljs-string">'Toggle Overstrike'</span>, command=toggle_overstrike).pack()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Font</code> object is a Python interface to a Tcl/Tk feature called <strong class="keyword">named fonts</strong>. In Tcl/Tk, a named font is just a collection<a id="_idIndexMarker834"/> of font properties associated with a name. </p>
    <p class="normal"><code class="Code-In-Text--PACKT-">Tk</code> comes with several named fonts already configured, as shown in the following table:</p>
    <table id="table002-5" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Font name</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Defaults to</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Used for</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">TkCaptionFont</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">System title font</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Window and dialog caption bars</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">TkDefaultFont</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">System default font</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Items not otherwise specified</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">TkFixedFont</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">System fixed-width font</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Text</code> widget</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">TkHeadingFont</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">System heading font</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Column headings in lists and tables</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">TkIconFont</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">System icon font</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Icon captions</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">TkMenuFont</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">System menu font</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Menu labels</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">TkSmallCaptionFont</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">System title</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Subwindows, tool dialogs</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">TkTextFont</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">System input font</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Input widgets: <code class="Code-In-Text--PACKT-">Entry</code>, <code class="Code-In-Text--PACKT-">Spinbox</code>, and so on</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">TkTooltipFont</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">System tooltip font</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Tooltips</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">The <code class="Code-In-Text--PACKT-">font</code> module includes<a id="_idIndexMarker835"/> a function called <code class="Code-In-Text--PACKT-">names()</code> that returns a list of the current named fonts on the system, including those that you create yourself (by creating <code class="Code-In-Text--PACKT-">Font</code> objects). We can use the <code class="Code-In-Text--PACKT-">font.nametofont()</code> function to generate a <code class="Code-In-Text--PACKT-">Font</code> object from a given name.</p>
    <p class="normal">For example, we can create a small program to demonstrate all the named fonts included with Tkinter, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># named_font_demo.py</span>
<span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk
<span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> font
root = tk.Tk()
<span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> font.names():
  font_obj = font.nametofont(name)
  tk.Label(root, text=name, font=font_obj).pack()
root.mainloop()
</code></pre>
    <p class="normal">In this script, we retrieve a list of all the named fonts using <code class="Code-In-Text--PACKT-">font.names()</code> and iterate through it. For each name, we create a <code class="Code-In-Text--PACKT-">Font</code> object using <code class="Code-In-Text--PACKT-">font.nametofont()</code>, and then create a label showing the named font name and using the <code class="Code-In-Text--PACKT-">Font</code> object as its font.</p>
    <p class="normal">This script will show what all the built-in named fonts look like on your system. </p>
    <p class="normal">For example, on Ubuntu Linux, they look like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_11.png" alt="Figure 9.11: The Tkinter named fonts on Ubuntu Linux"/></figure>
    <p class="packt_figref">Figure 9.11: The Tkinter named fonts on Ubuntu Linux</p>
    <p class="normal">Since Tkinter uses its built-in named fonts by default, we can change the overall look of the whole application<a id="_idIndexMarker836"/> by creating <code class="Code-In-Text--PACKT-">Font</code> objects for these default named fonts and overriding their properties. The changes we make will get applied across all widgets that don't otherwise have an explicit font configuration.</p>
    <p class="normal">For example, we could add some code to the preceding script, just before <code class="Code-In-Text--PACKT-">root.mainloop()</code>, to allow us to customize the built-in fonts:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># named_font_demo.py</span>
namedfont = tk.StringVar()
family = tk.StringVar()
size = tk.IntVar()
tk.OptionMenu(root, namedfont, *font.names()).pack()
tk.OptionMenu(root, family, *font.families()).pack()
tk.Spinbox(root, textvariable=size, from_=<span class="hljs-number">6</span>, to=<span class="hljs-number">128</span>).pack()
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">setFont</span><span class="hljs-function">():</span>
  font_obj = font.nametofont(namedfont.get())
  font_obj.configure(family=family.get(), size=size.get())
tk.Button(root, text=<span class="hljs-string">'Change'</span>, command=setFont).pack()
</code></pre>
    <p class="normal">In this code, we set up three control variables to hold the named font name, family, and size values, and then set up three widgets to select them. The first <code class="Code-In-Text--PACKT-">OptionMenu</code> widget uses <code class="Code-In-Text--PACKT-">font.names()</code> to retrieve a list of all the named fonts, and the second uses the <code class="Code-In-Text--PACKT-">font.families()</code> function to retrieve a list of the available font families on the operating system (this is likely to be a very long list on most modern systems). Then we have a <code class="Code-In-Text--PACKT-">Spinbox</code> for selecting a font size.</p>
    <p class="normal">The callback function, <code class="Code-In-Text--PACKT-">setFont()</code>, creates a font object from the selected named font and then<a id="_idIndexMarker837"/> configures it with the selected family and size. This function is then bound to a button.</p>
    <p class="normal">If you run the script now, you should be able to select any named font and edit its family and size. When you click <strong class="screenText">Change</strong>, you should see the associated label change according to your selections. You may also note that changing certain named fonts affects your <code class="Code-In-Text--PACKT-">OptionMenu</code>, <code class="Code-In-Text--PACKT-">Spinbox</code>, and <code class="Code-In-Text--PACKT-">Button</code> widgets as well.</p>
    <p class="normal">For example, on Ubuntu Linux, it looks like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_12.png" alt="Figure 9.12: The named font editor on Ubuntu Linux"/></figure>
    <p class="packt_figref">Figure 9.12: The named font editor on Ubuntu Linux</p>
    <h2 id="_idParaDest-235" class="title">Giving users font options in ABQ Data Entry</h2>
    <p class="normal">Now that we understand how to work with fonts in Tkinter, let's add the ability for our users to configure fonts<a id="_idIndexMarker838"/> in the application. We'll allow them<a id="_idIndexMarker839"/> to choose a size and a font family that will be used for all the widgets and data displayed in the application.</p>
    <p class="normal">Since users will want to persist this value between sessions, we should begin by adding keys for <code class="Code-In-Text--PACKT-">font size</code> and <code class="Code-In-Text--PACKT-">font family</code> to our settings model. Open <code class="Code-In-Text--PACKT-">models.py</code> and append these to the <code class="Code-In-Text--PACKT-">fields</code> dictionary, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside SettingsModel</span>
  fields = {
    <span class="hljs-comment"># ...</span>
    <span class="code-highlight"><strong class="hljs-slc">'font size': {'type': 'int', 'value': 9}</strong></span>,
    <span class="code-highlight"><strong class="hljs-slc">'font family': {'type': 'str', 'value': ''}</strong></span>
  }
</code></pre>
    <p class="normal">We have set the size default to 9 points, but the family default to a blank string. Configuring a font with a blank family value will cause Tkinter to use its own default font family.</p>
    <p class="normal">Recall that the <code class="Code-In-Text--PACKT-">Application</code> object will read the <code class="Code-In-Text--PACKT-">fields</code> dictionary and set up a control variable for each setting, and that a dictionary<a id="_idIndexMarker840"/> of these control variables will be passed to our <code class="Code-In-Text--PACKT-">MainMenu</code> object. So, our next task will be to create menu<a id="_idIndexMarker841"/> items for setting the size and family values of these variables.</p>
    <p class="normal">Open <code class="Code-In-Text--PACKT-">mainmenu.py</code> and let's begin by importing the <code class="Code-In-Text--PACKT-">font</code> module:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, at the top</span>
<span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> font
</code></pre>
    <p class="normal">Now, inside the <code class="Code-In-Text--PACKT-">MainMenu</code> initializer method, let's create some sub-menus for the <code class="Code-In-Text--PACKT-">options_menu</code> cascade:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside MainMenu.__init__(), </span>
<span class="hljs-comment"># after creating options_menu</span>
    size_menu = tk.Menu(
      options_menu, tearoff=<span class="hljs-literal">False</span>, **self.styles
    )
    options_menu.add_cascade(label=<span class="hljs-string">'Font Size'</span>, menu=size_menu)
    <span class="hljs-keyword">for</span> size <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>, <span class="hljs-number">17</span>, <span class="hljs-number">1</span>):
      size_menu.add_radiobutton(
        label=size, value=size,
        variable=self.settings[<span class="hljs-string">'font size'</span>]
      )
    family_menu = tk.Menu(
      options_menu, tearoff=<span class="hljs-literal">False</span>, **self.styles
    )
    options_menu.add_cascade(
      label=<span class="hljs-string">'Font Family'</span>, menu=family_menu
    )
    <span class="hljs-keyword">for</span> family <span class="hljs-keyword">in</span> font.families():
      family_menu.add_radiobutton(
        label=family, value=family,
        variable=self.settings[<span class="hljs-string">'font family'</span>]
      )
</code></pre>
    <p class="normal">This should look familiar, since we created a nearly identical font size menu when learning about the Tkinter <code class="Code-In-Text--PACKT-">Menu</code> widget in <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating Menus with Menu and Tkinter Dialogs</em>. We're allowing font sizes from 6 to 16, which should provide plenty of range for our users.</p>
    <p class="normal">The font family menu<a id="_idIndexMarker842"/> is nearly identical, except we're pulling<a id="_idIndexMarker843"/> the list of possible values from <code class="Code-In-Text--PACKT-">font.families()</code>, just as we did in our demonstration script earlier in this chapter.</p>
    <p class="normal">Now that the user can select fonts and store their selection, let's actually make those settings change the fonts in the application. To do that, we'll first need to add a method to the <code class="Code-In-Text--PACKT-">Application</code> class that will read the values and alter the appropriate named fonts accordingly.</p>
    <p class="normal">Open <code class="Code-In-Text--PACKT-">application.py</code>; add an import statement for <code class="Code-In-Text--PACKT-">font</code> at the top, and then let's add this new <code class="Code-In-Text--PACKT-">_set_font()</code> method to the <code class="Code-In-Text--PACKT-">Application</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, inside the Application class</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_set_font</span><span class="hljs-function">(</span><span class="hljs-params">self, *_</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Set the application's font"""</span>
    font_size = self.settings[<span class="hljs-string">'font size'</span>].get()
    font_family = self.settings[<span class="hljs-string">'font family'</span>].get()
    font_names = (
      <span class="hljs-string">'TkDefaultFont'</span>, <span class="hljs-string">'TkMenuFont'</span>, <span class="hljs-string">'TkTextFont'</span>, <span class="hljs-string">'TkFixedFont'</span>
    )
    <span class="hljs-keyword">for</span> font_name <span class="hljs-keyword">in</span> font_names:
      tk_font = font.nametofont(font_name)
      tk_font.config(size=font_size, family=font_family)
</code></pre>
    <p class="normal">This method begins by retrieving the size and family settings from their respective control variables. Next, we're going to loop through a tuple of built-in named fonts that we want to change. <code class="Code-In-Text--PACKT-">TkDefaultFont</code> will change most of the widgets, <code class="Code-In-Text--PACKT-">TkMenuFont</code> will affect the main menu, <code class="Code-In-Text--PACKT-">TkTextFont</code> will change the text-input widgets, and <code class="Code-In-Text--PACKT-">TkFixedFont</code> will set the default for our <code class="Code-In-Text--PACKT-">Text</code> widget.</p>
    <p class="normal">For each one, we retrieve a <code class="Code-In-Text--PACKT-">Font</code> object using <code class="Code-In-Text--PACKT-">nametofont()</code> and reconfigure it with the values retrieved from <code class="Code-In-Text--PACKT-">settings</code>.</p>
    <p class="normal">This method needs to be called after the settings are initially loaded, and whenever the size or family values are changed. So, let's add the following lines to the end of <code class="Code-In-Text--PACKT-">Application._load_settings()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, in Application._load_settings()</span>
    self._set_font()
    self.settings[<span class="hljs-string">'font size'</span>].trace_add(<span class="hljs-string">'write'</span>, self._set_font)
    self.settings[<span class="hljs-string">'font family'</span>].trace_add(
      <span class="hljs-string">'write'</span>, self._set_font
    )
</code></pre>
    <p class="normal">Now, whenever <code class="Code-In-Text--PACKT-">Application()</code> creates new settings control variables, it will set up the font and add a trace<a id="_idIndexMarker844"/> to reconfigure the application<a id="_idIndexMarker845"/> fonts whenever these values are changed.</p>
    <p class="normal">Run the application and try out the font menu. It should look something like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_13.png" alt="Figure 9.13: Switching our ABQ Data Entry to Comic Sans"/></figure>
    <p class="packt_figref">Figure 9.13: Switching our ABQ Data Entry to Comic Sans</p>
    <h1 id="_idParaDest-236" class="title">Styling Ttk widgets</h1>
    <p class="normal">The final user<a id="_idIndexMarker846"/> requests we need to address involve the styles and colors of our <code class="Code-In-Text--PACKT-">Ttk</code> widgets; users have asked for more visual distinction between the form sections, and more visibility for error messages.</p>
    <p class="normal">After some thought and discussion, you decide to color-code the sections of the form as follows:</p>
    <ul>
      <li class="bullet">The Record Information section will use khaki, suggesting the classic manila folders used for paper records</li>
      <li class="bullet">The Environment Data section will use light blue, symbolic of water and air</li>
      <li class="bullet">The Plant Data will have a light green background, symbolic of plants</li>
      <li class="bullet">The Notes input is distinctive enough, so it will remain the same default gray</li>
    </ul>
    <p class="normal">To improve the visibility of error messages, we'd like to make the background of the fields turn red when they have errors, and the error text itself display in a dark red color. To accomplish this, we're going to need to understand how to style <code class="Code-In-Text--PACKT-">Ttk</code> widgets.</p>
    <h2 id="_idParaDest-237" class="title">TTk styling breakdown</h2>
    <p class="normal">Ttk widgets represent a major improvement over standard Tkinter widgets in terms of the power and flexibility with which they can be styled. This flexibility is what gives Ttk widgets the ability<a id="_idIndexMarker847"/> to mimic native UI controls across platforms, but it comes at a cost: Ttk styling is confusing, complicated, poorly documented, and occasionally inconsistent.</p>
    <p class="normal">To understand Ttk styling, let's start with some vocabulary, from the most basic parts to the most complex:</p>
    <ul>
      <li class="bullet">Ttk starts with <strong class="keyword">elements</strong>. An element<a id="_idIndexMarker848"/> is one piece of a widget, such as a border, an arrow, or a field where text can be typed.</li>
      <li class="bullet">Each element<a id="_idIndexMarker849"/> has a set of <strong class="keyword">options</strong> that define properties such as color, size, and font.</li>
      <li class="bullet">Elements<a id="_idIndexMarker850"/> are composed using <strong class="keyword">layouts</strong> into a complete widget (a <code class="Code-In-Text--PACKT-">Combobox</code> or <code class="Code-In-Text--PACKT-">Treeview</code>, for example).</li>
      <li class="bullet"><strong class="keyword">Styles</strong> are collections of element option settings that are applied to widgets. A style is identified<a id="_idIndexMarker851"/> by its name. Usually, the name is "T" plus the name of the widget, such as <code class="Code-In-Text--PACKT-">TButton</code> or <code class="Code-In-Text--PACKT-">TEntry</code>, although there are some exceptions to this.</li>
      <li class="bullet">Widgets also have<a id="_idIndexMarker852"/> a number of <strong class="keyword">states</strong>, which are flags that can be turned on or off:<ul>
          <li class="bullet-l2">Styles can<a id="_idIndexMarker853"/> be configured with a <strong class="keyword">map</strong> that associates element option values with states or combinations of states.</li>
        </ul>
      </li>
      <li class="bullet">A collection of layouts and their associated styles is called a <strong class="keyword">theme</strong>. Ttk comes with a<a id="_idIndexMarker854"/> different set of themes on different platforms, and each platform has a default that aims to match the look of its native widget set. Because each theme may contain elements with different style options, not every option is available, nor has the same effect, in every theme. For example, a <code class="Code-In-Text--PACKT-">ttk.Button</code> on the default macOS theme may contain a different set of elements, applying<a id="_idIndexMarker855"/> style settings differently compared to a <code class="Code-In-Text--PACKT-">ttk.Button</code> using the default theme in Windows.</li>
    </ul>
    <p class="normal">If you're confused at this point, that's understandable. To make things clearer, let's take a deep dive into the anatomy of a <code class="Code-In-Text--PACKT-">ttk.Combobox</code>.</p>
    <h3 id="_idParaDest-238" class="title">Exploring a Ttk widget</h3>
    <p class="normal">To get a better picture<a id="_idIndexMarker856"/> of how a Ttk widget is built, open a shell in IDLE and import <code class="Code-In-Text--PACKT-">tkinter</code>, <code class="Code-In-Text--PACKT-">ttk</code>, and <code class="Code-In-Text--PACKT-">pprint</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> tkinter <span class="hljs-con-keyword">as</span> tk
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> tkinter <span class="hljs-con-keyword">import</span> ttk
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> pprint <span class="hljs-con-keyword">import</span> pprint
</code></pre>
    <p class="normal">Now, create a <code class="Code-In-Text--PACKT-">root</code> window, <code class="Code-In-Text--PACKT-">Combobox</code>, and <code class="Code-In-Text--PACKT-">Style</code> object:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> root = tk.Tk()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> cb = ttk.Combobox(root)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> cb.pack()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> style = ttk.Style()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Style</code> object is, perhaps, slightly misnamed; it doesn't point to a single <em class="italic">style</em>, but rather gives us a point of access to examine and alter the styles, layouts, and maps for the current <em class="italic">theme</em>.</p>
    <p class="normal">In order to examine our <code class="Code-In-Text--PACKT-">Combobox</code>, we'll first get its style name using the <code class="Code-In-Text--PACKT-">winfo_class()</code> method:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> cb_stylename = cb.winfo_class()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(cb_stylename)
TCombobox
</code></pre>
    <p class="normal">As expected, the name is <code class="Code-In-Text--PACKT-">TCombobox</code>, which is just <code class="Code-In-Text--PACKT-">T</code> plus the widget name. We can use this name to find out more about this <code class="Code-In-Text--PACKT-">Combobox</code> widget.</p>
    <p class="normal">For example, we can examine<a id="_idIndexMarker857"/> its layout by passing the name to the <code class="Code-In-Text--PACKT-">Style.layout()</code> method, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> cb_layout = style.layout(cb_stylename)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pprint(cb_layout)
[(
  'Combobox.field',
  {
    'children': [
      (
        'Combobox.downarrow',
        {'side': 'right', 'sticky': 'ns'}
      ),
      (
        'Combobox.padding',
       {
        'children': [
          ('Combobox.textarea', {'sticky': 'nswe'})
        ],
        'expand': '1',
        'sticky': 'nswe'
      }
      )
    ],
    'sticky': 'nswe'
   }
)]
</code></pre>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that the output of <code class="Code-In-Text--PACKT-">layout()</code> may be different on your system, as the layout contents depend on the theme. Different operating systems use a different default theme. </p>
    </div>
    <p class="normal">The returned layout specification shows the hierarchy of elements used to construct this widget. The elements, in this case, are <code class="Code-In-Text--PACKT-">"Combobox.field"</code>, <code class="Code-In-Text--PACKT-">"Combobox.downarrow"</code>, <code class="Code-In-Text--PACKT-">"Combobox.padding"</code>, and <code class="Code-In-Text--PACKT-">"Combobox.textarea"</code>. As you can see, each element has associated positioning properties similar to what you'd pass into a geometry manager method.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">layout()</code> method can also be used to replace a style's layout by passing in a new specification<a id="_idIndexMarker858"/> as a second argument. Unfortunately, since styles are built using immutable tuples, this requires replacing the <em class="italic">entire</em> layout specification – you can't just adjust or replace a single element in place.</p>
    </div>
    <p class="normal">To see what options<a id="_idIndexMarker859"/> are available for the elements in this layout, we can use the <code class="Code-In-Text--PACKT-">style.element_options()</code> method. This method takes an element name and returns a list of options that can be used to alter it.</p>
    <p class="normal">For example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> pprint(style.element_options(<span class="hljs-con-string">'Combobox.downarrow'</span>))
('background', 'relief', 'borderwidth', 'arrowcolor', 'arrowsize')
</code></pre>
    <div class="note">
      <p class="Information-Box--PACKT-">Once again, this list may be different (or even empty) depending on your operating system and theme settings.</p>
    </div>
    <p class="normal">This tells us that the <code class="Code-In-Text--PACKT-">downarrow</code> element of the <code class="Code-In-Text--PACKT-">Combobox</code> widget offers the <code class="Code-In-Text--PACKT-">background</code>, <code class="Code-In-Text--PACKT-">relief</code>, <code class="Code-In-Text--PACKT-">borderwidth</code>, <code class="Code-In-Text--PACKT-">arrowcolor</code>, and <code class="Code-In-Text--PACKT-">arrowsize</code> style properties to adjust its appearance. To change these properties, we can use the <code class="Code-In-Text--PACKT-">style.configure()</code> method.</p>
    <p class="normal">For instance, let's change the color of the arrow to red:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> style.configure(<span class="hljs-con-string">'TCombobox'</span>, arrowcolor=<span class="hljs-con-string">'red'</span>)
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">If your operating system doesn't support the <code class="Code-In-Text--PACKT-">arrowcolor</code> option, feel free to try a different option or switch to the alt theme. See the next section on how to switch themes.</p>
    </div>
    <p class="normal">You should see that the arrow's color has changed to red. This is all we need to know to configure widgets for static changes, but what about dynamic changes, such as when an input is disabled or invalid?</p>
    <p class="normal">To make dynamic changes, we'll need to work with our widget's state and map. We can inspect or alter the state of our <code class="Code-In-Text--PACKT-">Combobox</code> using the <code class="Code-In-Text--PACKT-">state()</code> method, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(cb.state())
()
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">state()</code> with no arguments will return a tuple with the currently set state flags; as you can see, the <code class="Code-In-Text--PACKT-">Combobox</code> widget<a id="_idIndexMarker860"/> had no state flags by default. We can also set the state by passing in a sequence of strings, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> cb.state([<span class="hljs-con-string">'active'</span>, <span class="hljs-con-string">'invalid'</span>])
('!active', '!invalid')
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(cb.state())
('active', 'invalid')
<span class="hljs-con-meta">&gt;&gt;&gt;</span> cb.state([<span class="hljs-con-string">'!invalid'</span>])
('invalid',)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(cb.state())
('active',)
</code></pre>
    <p class="normal">Notice that in order to turn off a state flag, we prefix the flag name with a <code class="Code-In-Text--PACKT-">!</code>. When you call <code class="Code-In-Text--PACKT-">state()</code> with an argument to change the value, the return value is a tuple containing a set of states (or negated states) that would, if applied, <em class="italic">undo the state change you just set</em>. So, in this case, when we passed in the list that turned on <code class="Code-In-Text--PACKT-">active</code> and <code class="Code-In-Text--PACKT-">invalid</code>, the method returned a tuple that would turn these states off again. Likewise, when we passed in the negated <code class="Code-In-Text--PACKT-">invalid</code> state, we got back a tuple containing <code class="Code-In-Text--PACKT-">invalid</code>. This might be useful in a situation where you want to temporarily set a widget's state and then return it to its previous (possibly unknown) state.</p>
    <p class="normal">You can't just use any arbitrary strings for <code class="Code-In-Text--PACKT-">state()</code>; they must be one of the supported values, listed here in this table:</p>
    <table id="table003-4" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">State</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Indicates</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">active</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Widget element is being hovered on by the mouse</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">disabled</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Interaction with the widget is turned off</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">focus</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Widget will receive keyboard events</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">pressed</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Widget is currently being clicked on</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">selected</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Widget has been selected by the user (for example, a radio button)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">background</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Widget is on a window that is not the foreground window</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">readonly</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Widget will not allow modification</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">alternate</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Different things, depending on the widget</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">invalid</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Widget contains invalid data (that is, the validate command has returned <code class="Code-In-Text--PACKT-">False</code>)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">hover</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Like <code class="Code-In-Text--PACKT-">active</code>, but referring to the whole widget rather than an element</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Exactly how different widgets use each of these states depends on the widget and the theme; not every state is configured by default to have an effect on every widget. For example, <code class="Code-In-Text--PACKT-">readonly</code> has no effect on a <code class="Code-In-Text--PACKT-">Label</code> widget, since it is not editable to begin with.</p>
    <p class="normal">Widget states interact with the theme's widget style through the use of a <strong class="keyword">style map</strong>. We can use the <code class="Code-In-Text--PACKT-">style.map()</code> method<a id="_idIndexMarker861"/> to inspect or set the map for each style.</p>
    <p class="normal">Take a look<a id="_idIndexMarker862"/> at the default map for <code class="Code-In-Text--PACKT-">TCombobox</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> pprint(style.<span class="hljs-con-built_in">map</span>(cb_stylename))
{
  'arrowcolor': [
    ('disabled', '#a3a3a3')
  ],
  'fieldbackground': [
    ('readonly', '#d9d9d9'),
    ('disabled', '#d9d9d9')
  ]
}
</code></pre>
    <p class="normal">As you can see, <code class="Code-In-Text--PACKT-">TCombobox</code> has style maps for the <code class="Code-In-Text--PACKT-">arrowcolor</code> and <code class="Code-In-Text--PACKT-">fieldbackground</code> options by default. Each style map is a list of tuples, and each tuple is one or more state flags followed by a value for the element option. When all of the state flags match the current state of the widget, the value (that is, the last string in the tuple) takes effect.</p>
    <p class="normal">The default map turns<a id="_idIndexMarker863"/> the arrow color to a light gray color when the <code class="Code-In-Text--PACKT-">disabled</code> flag is set, and turns the field background to a different light gray color when either the <code class="Code-In-Text--PACKT-">disabled</code> or <code class="Code-In-Text--PACKT-">readonly</code> flags are set.</p>
    <p class="normal">We can set our own style mapping using the same method:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> style.<span class="hljs-con-built_in">map</span>(
  'TCombobox',
  arrowcolor=[('!invalid', 'blue'), ('invalid', 'focus', 'red')]
)
{}
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pprint(style.<span class="hljs-con-built_in">map</span>(<span class="hljs-con-string">'TCombobox'</span>))
{
  'arrowcolor': [
    ('!invalid', 'blue'), ('invalid', 'focus', 'red')
  ],
  'fieldbackground': [
    ('readonly', '#d9d9d9'), ('disabled', '#d9d9d9')
  ]
}
</code></pre>
    <p class="normal">Here, we've configured the <code class="Code-In-Text--PACKT-">arrowcolor</code> property to be <code class="Code-In-Text--PACKT-">blue</code> when the invalid flag is not set, and <code class="Code-In-Text--PACKT-">red</code> when both the <code class="Code-In-Text--PACKT-">invalid</code> and <code class="Code-In-Text--PACKT-">focus</code> flags are set. Notice that while our call to <code class="Code-In-Text--PACKT-">map()</code> completely overwrote the <code class="Code-In-Text--PACKT-">arrowcolor</code> style map, the <code class="Code-In-Text--PACKT-">fieldbackground</code> map was unaffected. You can replace style mappings individually for each option without affecting other options, though whatever mapping you do specify for the option overwrites the whole mapping for that option.</p>
    <p class="normal">So far, we've been<a id="_idIndexMarker864"/> operating on the <code class="Code-In-Text--PACKT-">TCombobox</code> style, which is the default style for all <code class="Code-In-Text--PACKT-">Combobox</code> widgets. Any changes we made would impact every <code class="Code-In-Text--PACKT-">Combobox</code> widget in the application. What if we only want to change a particular widget, or a particular set of widgets? We can do this by creating <strong class="keyword">custom styles</strong>. Custom styles must be derived from the existing<a id="_idIndexMarker865"/> style by prefixing a name and a dot to an existing style name.</p>
    <p class="normal">For example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> style.configure(<span class="hljs-con-string">'Blue.TCombobox'</span>, fieldbackground=<span class="hljs-con-string">'blue'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> cb.configure(style=<span class="hljs-con-string">'Blue.TCombobox'</span>)
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">Blue.TCombobox</code> inherits all of the properties of <code class="Code-In-Text--PACKT-">TCombobox</code> (including the dynamically colored down arrow we previously configured), but can add or override them with settings of its own that won't affect <code class="Code-In-Text--PACKT-">TCombobox</code>. This allows you to create custom styles for some widgets without affecting other widgets of the same type.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">We can even customize our custom styles by adding more prefixes; for example, the style <code class="Code-In-Text--PACKT-">MyCB.Blue.TCombobox</code> would inherit all the styles of <code class="Code-In-Text--PACKT-">TCombobox</code> and <code class="Code-In-Text--PACKT-">Blue.TCombobox</code>, along with whatever additional settings we wanted to add or override in it.</p>
    </div>
    <h3 id="_idParaDest-239" class="title">Using themes</h3>
    <p class="normal">We can alter<a id="_idIndexMarker866"/> the look of all the Ttk widgets in our application at once by changing the theme. Remember that a theme is a collection of styles <em class="italic">and layouts</em>; so changing a theme doesn't just change the appearance, it may also change the available styling options as well.</p>
    <p class="normal">Ttk comes with a different set of themes on each OS platform; to see the themes available on your platform, use the <code class="Code-In-Text--PACKT-">Style.theme_names()</code> method:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> style.theme_names()
('clam', 'alt', 'default', 'classic')
</code></pre>
    <p class="normal">(These are the themes available on Debian Linux; yours may differ.)</p>
    <p class="normal">To query the current theme, or to set a new theme, use the <code class="Code-In-Text--PACKT-">Style.theme_use()</code> method:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> style.theme_use()
'default'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> style.theme_use(<span class="hljs-con-string">'alt'</span>)
</code></pre>
    <p class="normal">With no arguments, the method<a id="_idIndexMarker867"/> returns the name of the current theme. With an argument, it sets the theme to the given theme name. Notice how the previous styling is gone when you change the theme. If you switch back to the default, however, you'll see that your changes were retained. That's because any changes we make using <code class="Code-In-Text--PACKT-">Style.configure()</code> <em class="italic">only affect the currently running theme</em>.</p>
    <h2 id="_idParaDest-240" class="title">Adding some color to ABQ Data Entry</h2>
    <p class="normal">Now that you have a firmer<a id="_idIndexMarker868"/> grasp of Ttk themes and styling, let's add some color<a id="_idIndexMarker869"/> to our data entry form. To begin, we will set a different background color for each <code class="Code-In-Text--PACKT-">LabelFrame</code> widget in the data record form. Since we want to configure three widgets of the same type differently, we'll need to use custom styles. For each frame, we will create a custom style, configure it with the proper color, and then assign it to the frame.</p>
    <p class="normal">Start by opening <code class="Code-In-Text--PACKT-">views.py</code> and let's add the following code to the <code class="Code-In-Text--PACKT-">DataRecordForm</code> initializer method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, inside DataRecordForm.__init__()</span>
    style = ttk.Style()
    <span class="hljs-comment"># Frame styles</span>
    style.configure(
      <span class="hljs-string">'RecordInfo.TLabelframe'</span>,
      background=<span class="hljs-string">'khaki'</span>, padx=<span class="hljs-number">10</span>, pady=<span class="hljs-number">10</span>
    )
    style.configure(
      <span class="hljs-string">'EnvironmentInfo.TLabelframe'</span>, background=<span class="hljs-string">'lightblue'</span>,
      padx=<span class="hljs-number">10</span>, pady=<span class="hljs-number">10</span>
    )
    style.configure(
      <span class="hljs-string">'PlantInfo.TLabelframe'</span>,
      background=<span class="hljs-string">'lightgreen'</span>, padx=<span class="hljs-number">10</span>, pady=<span class="hljs-number">10</span>
    )
</code></pre>
    <p class="normal">We begin by creating a <code class="Code-In-Text--PACKT-">Style</code> object, which we can use to access and modify the widget styles. We then use the <code class="Code-In-Text--PACKT-">style.configure()</code> method to set up three custom styles based on <code class="Code-In-Text--PACKT-">TLabelframe</code>, the default style for Ttk <code class="Code-In-Text--PACKT-">Labelframe</code> widgets. We've set the colors according<a id="_idIndexMarker870"/> to our plan, and also added some padding to the style.</p>
    <p class="normal">Now, we need to assign<a id="_idIndexMarker871"/> these styles to each frame. Remember that our <code class="Code-In-Text--PACKT-">LabelFrame</code> widgets are being created in an instance method called <code class="Code-In-Text--PACKT-">_add_frame()</code>. We'll need to update this method to take a <code class="Code-In-Text--PACKT-">style</code> argument that we can pass to the widget. Update the method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, inside the DataRecordForm class</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_add_frame</span><span class="hljs-function">(</span><span class="hljs-params">self, label, </span><span class="code-highlight"><strong class="hljs-slc">style=''</strong></span><span class="hljs-params">, cols=</span><span class="hljs-number">3</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Add a labelframe to the form"""</span>
    frame = ttk.LabelFrame(self, text=label)
    <span class="code-highlight"><strong class="hljs-slc">if style:</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">frame.configure(style=style)</strong></span>
    frame.grid(sticky=tk.W + tk.E)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):
      frame.columnconfigure(i, weight=<span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> frame
</code></pre>
    <p class="normal">In this version, we take a string for the style, and if one is passed, we'll configure our <code class="Code-In-Text--PACKT-">LabelFrame</code> widget to use it. Now, let's update our calls to <code class="Code-In-Text--PACKT-">_add_frame()</code> in the initializer to pass in the custom styles we've created, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, in DataRecordForm.__init__()</span>
    r_info = self._add_frame(
      <span class="hljs-string">"Record Information"</span>, <span class="hljs-string">'RecordInfo.TLabelframe'</span>
    )
    <span class="hljs-comment">#...</span>
    e_info = self._add_frame(
      <span class="hljs-string">"Environment Data"</span>, <span class="hljs-string">'EnvironmentInfo.TLabelframe'</span>
    )
    <span class="hljs-comment">#...</span>
    p_info = self._add_frame(<span class="hljs-string">"Plant Data"</span>, <span class="hljs-string">'PlantInfo.TLabelframe'</span>)
</code></pre>
    <p class="normal">Now, execute<a id="_idIndexMarker872"/> the application and let's take a look at the form. It should look<a id="_idIndexMarker873"/> something like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_14.png" alt="Figure 9.14: Our first attempt at coloring our record form frames"/></figure>
    <p class="packt_figref">Figure 9.14: Our first attempt at coloring our record form frames</p>
    <p class="normal">As you can see, that's far from ideal. While there is a small amount of color peeking out from behind the widgets, the widgets in each section are still the default drab color, and even the label portion of the <code class="Code-In-Text--PACKT-">LabelFrame</code> widgets is still gray. Styles do <em class="italic">not</em> propagate to child widgets, so we're going<a id="_idIndexMarker874"/> to have to set each widget individually<a id="_idIndexMarker875"/> to get the full effect.</p>
    <h3 id="_idParaDest-241" class="title">Adding styles to individual form widgets</h3>
    <p class="normal">The first thing we can quickly fix is the label portion of each <code class="Code-In-Text--PACKT-">LabelFrame</code> widget. Although each widget<a id="_idIndexMarker876"/> has been assigned to the custom style, the label<a id="_idIndexMarker877"/> element of the widget needs to be explicitly styled. We can do that merely by adding the following code to the <code class="Code-In-Text--PACKT-">DataRecordForm</code> initializer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, inside DataRecordForm.__init__()</span>
    style.configure(
      <span class="hljs-string">'RecordInfo.TLabelframe.Label'</span>, background=<span class="hljs-string">'khaki'</span>,
      padx=<span class="hljs-number">10</span>, pady=<span class="hljs-number">10</span>
    )
    style.configure(
      <span class="hljs-string">'EnvironmentInfo.TLabelframe.Label'</span>,
      background=<span class="hljs-string">'lightblue'</span>, padx=<span class="hljs-number">10</span>, pady=<span class="hljs-number">10</span>
    )
    style.configure(
      <span class="hljs-string">'PlantInfo.TLabelframe.Label'</span>,
      background=<span class="hljs-string">'lightgreen'</span>, padx=<span class="hljs-number">10</span>, pady=<span class="hljs-number">10</span>
    )
</code></pre>
    <p class="normal">This is exactly the same thing we did to create the custom <code class="Code-In-Text--PACKT-">TLabelframe</code> styles, except that we have added the name of the individual element we want to style (in this case, <code class="Code-In-Text--PACKT-">Label</code>). If you run the program again, you'll see now that each frame's label also shares the background color of the frame. We're still not finished though, because we need all our widget labels to show the background color of the frame.</p>
    <p class="normal">Let's consider which widgets<a id="_idIndexMarker878"/> we need to create a custom style for:</p>
    <ul>
      <li class="bullet">We need a style for the <code class="Code-In-Text--PACKT-">Label</code> widgets for each section, since we'll need different colors for these widgets in Record Information, Environment Data, and Plant Data.</li>
      <li class="bullet">We'll need to style our <code class="Code-In-Text--PACKT-">Checkbutton</code>, since it uses its own built-in label rather than a separate label widget. Since there's only one right now, we only need one style for it.</li>
      <li class="bullet">We'll need to style the <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets, since they also use a built-in label. We only need<a id="_idIndexMarker879"/> one style, though, since they also appear in only one form section.</li>
    </ul>
    <p class="normal">Let's create those styles:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># views.py, inside DataRecordForm.__init__()</span>
    style.configure(<span class="hljs-string">'RecordInfo.TLabel'</span>, background=<span class="hljs-string">'khaki'</span>)
    style.configure(<span class="hljs-string">'RecordInfo.TRadiobutton'</span>, background=<span class="hljs-string">'khaki'</span>)
    style.configure(<span class="hljs-string">'EnvironmentInfo.TLabel'</span>, background=<span class="hljs-string">'lightblue'</span>)
    style.configure(
      <span class="hljs-string">'EnvironmentInfo.TCheckbutton'</span>,
      background=<span class="hljs-string">'lightblue'</span>
    )
    style.configure(<span class="hljs-string">'PlantInfo.TLabel'</span>, background=<span class="hljs-string">'lightgreen'</span>)
</code></pre>
    <p class="normal">Now that we've created<a id="_idIndexMarker880"/> the styles, we need to add them<a id="_idIndexMarker881"/> to each widget in the form. Remember that the <code class="Code-In-Text--PACKT-">LabelInput</code> initializer takes a <code class="Code-In-Text--PACKT-">label_args</code> dictionary for keywords that need to be passed to its <code class="Code-In-Text--PACKT-">Label</code> widget, so we'll need to add the label styles there.</p>
    <p class="normal">For example, here's what the first line should look like:</p>
    <pre class="programlisting code"><code class="hljs-code">    w.LabelInput(
      r_info, <span class="hljs-string">"Date"</span>,
      field_spec=fields[<span class="hljs-string">'Date'</span>],
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Date'</span>],
      <span class="code-highlight"><strong class="hljs-slc">label_args={'style': 'RecordInfo.TLabel'}</strong></span>
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>)
    w.LabelInput(
      r_info, <span class="hljs-string">"Time"</span>,
      field_spec=fields[<span class="hljs-string">'Time'</span>],
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Time'</span>],
      <span class="code-highlight"><strong class="hljs-slc">label_args={'style': 'RecordInfo.TLabel'}</strong></span>
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>)
    w.LabelInput(
      r_info, <span class="hljs-string">"Technician"</span>,
      field_spec=fields[<span class="hljs-string">'Technician'</span>],
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Technician'</span>],
      <span class="code-highlight"><strong class="hljs-slc">label_args={'style': 'RecordInfo.TLabel'}</strong></span>
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">2</span>)
</code></pre>
    <p class="normal">For the <code class="Code-In-Text--PACKT-">Lab</code> input, remember that we're using our <code class="Code-In-Text--PACKT-">ValidatedRadioGroup</code> widget, which takes a <code class="Code-In-Text--PACKT-">button_args</code> dictionary<a id="_idIndexMarker882"/> for arguments that need to be<a id="_idIndexMarker883"/> passed to the radio buttons. We will have to specify both a <code class="Code-In-Text--PACKT-">label_args</code> argument and an <code class="Code-In-Text--PACKT-">input_args</code> argument to get our styles set on these widgets, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    w.LabelInput(
      r_info, <span class="hljs-string">"Lab"</span>,
      field_spec=fields[<span class="hljs-string">'Lab'</span>],
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Lab'</span>],
      <span class="code-highlight"><strong class="hljs-slc">label_args={'style': 'RecordInfo.TLabel'}</strong></span>,
      <span class="code-highlight"><strong class="hljs-slc">input_args={</strong></span>
        <span class="code-highlight"><strong class="hljs-slc">'button_args':{'style': 'RecordInfo.TRadiobutton'}</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
    ).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>)
</code></pre>
    <p class="normal">Continue adding these styles to the rest of the <code class="Code-In-Text--PACKT-">LabelInput</code> widgets; if you get stuck, refer to the code example included with the book. When you're finished, the application should look like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_15.png" alt="Figure 9.15: The application with colored labels"/></figure>
    <p class="packt_figref">Figure 9.15: The application with colored labels</p>
    <p class="normal">This is a marked improvement, but it's not quite there yet; the error labels are still the old, default color. Let's address that next.</p>
    <h3 id="_idParaDest-242" class="title">Fixing the error colors</h3>
    <p class="normal">To fix the error labels, we need to edit our <code class="Code-In-Text--PACKT-">LabelInput</code> widget so that, when it creates the <code class="Code-In-Text--PACKT-">Label</code> widget<a id="_idIndexMarker884"/> for the error, it uses the style value passed in with the <code class="Code-In-Text--PACKT-">label_args</code> dictionary. However, we have a complication: we want to make our error text dark red. How can we honor the background color of the style passed in, but also customize the foreground just for this widget?</p>
    <p class="normal">The answer is that we can further prefix our custom style to create a new style that inherits all the traits of the custom, while adding or overriding its own. In other words, if we were to create a style called <code class="Code-In-Text--PACKT-">Error.RecordInfo.TLabel</code>, it would inherit all the properties of <code class="Code-In-Text--PACKT-">RecordInfo.TLabel</code> but allow us to make additional changes.</p>
    <p class="normal">Open the <code class="Code-In-Text--PACKT-">widgets.py</code> file, and let's see if we can implement this in the <code class="Code-In-Text--PACKT-">LabelInput</code> initializer method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># widgets.py, inside LabelInput.__init__()</span>
    error_style = <span class="hljs-string">'Error.'</span> + label_args.get(<span class="hljs-string">'style'</span>, <span class="hljs-string">'TLabel'</span>)
    ttk.Style().configure(error_style, foreground=<span class="hljs-string">'darkred'</span>)
    self.error = <span class="hljs-built_in">getattr</span>(self.<span class="hljs-built_in">input</span>, <span class="hljs-string">'error'</span>, tk.StringVar())
    ttk.Label(
      self, textvariable=self.error, style=error_style
    ).grid(row=<span class="hljs-number">2</span>, column=<span class="hljs-number">0</span>, sticky=(tk.W + tk.E))
</code></pre>
    <p class="normal">In this code, we've extracted the <code class="Code-In-Text--PACKT-">style</code> value from the <code class="Code-In-Text--PACKT-">label_args</code> dictionary, defaulting to <code class="Code-In-Text--PACKT-">TLabel</code> if no style<a id="_idIndexMarker885"/> was passed. Then, we create a new style name by prefixing the given style with <code class="Code-In-Text--PACKT-">Error.</code> (note the dot, that's important!). Then, we call <code class="Code-In-Text--PACKT-">Style.configure()</code> to set the text color of our new style to a dark red. Note that we don't give the <code class="Code-In-Text--PACKT-">Style</code> object a name here; since we're only making one change, it's OK to just call <code class="Code-In-Text--PACKT-">configure()</code> directly on the created object and then let the object get thrown away.</p>
    <p class="normal">Now, you should see that the error display widgets match the color of your background, but also display in dark red.</p>
    <h3 id="_idParaDest-243" class="title">Styling input widgets on error</h3>
    <p class="normal">Setting the error text to dark red is a minor improvement on the error visibility issue, but for our color-blind users in particular, the improvement is subtle at best, if it's even noticeable. We can use<a id="_idIndexMarker886"/> our knowledge of styling to take things a bit farther, though. Rather<a id="_idIndexMarker887"/> than just changing the color of the text, let's invert the colors of the input so that we have light text on a dark background.</p>
    <p class="normal">To do this, we will want to update the <code class="Code-In-Text--PACKT-">ValidatedMixin</code> class. Recall that we previously implemented a <code class="Code-In-Text--PACKT-">_toggle_error()</code> method that sets the foreground color to red when the widget is invalid on focus-out. We could update that command to apply a different style to the widget instead, so that the background color would change as well. However, there's a better way.</p>
    <p class="normal">Earlier in this chapter, we learned that widgets get flagged with an <code class="Code-In-Text--PACKT-">invalid</code> state when validation fails, and that Ttk styles can have colors and other properties tied to different widget states by means of a style map. Rather than explicitly changing styles or colors when validation fails, we can create a style map that changes colors automatically in response to a failed validation.</p>
    <p class="normal">To begin, go ahead<a id="_idIndexMarker888"/> and remove any calls to <code class="Code-In-Text--PACKT-">self._toggle_error()</code> in the <code class="Code-In-Text--PACKT-">ValidatedMixin</code> class, which<a id="_idIndexMarker889"/> can be found in the <code class="Code-In-Text--PACKT-">_validate()</code> method and the <code class="Code-In-Text--PACKT-">_focusout_invalid()</code> method. That will leave the <code class="Code-In-Text--PACKT-">_focusout_invalid()</code> method empty, so replace it with <code class="Code-In-Text--PACKT-">pass</code>, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># widget.py, inside the ValidatedMixin class</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_focusout_invalid</span><span class="hljs-function">(</span><span class="hljs-params">self, **kwargs</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Handle invalid data on a focus event"""</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">Although the method now does nothing, we're leaving it in place because it's part of the mixin class's API that child classes can override. You can actually delete the <code class="Code-In-Text--PACKT-">_toggle_error()</code> method, however, since its functionality will be handled by a style map.</p>
    <p class="normal">Now, in the initializer, let's configure a style and style map for our widget:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># widget.py, inside ValidatedMixin.__init__()</span>
    style = ttk.Style()
    widget_class = self.winfo_class()
    validated_style = <span class="hljs-string">'ValidatedInput.'</span> + widget_class
    style.<span class="hljs-built_in">map</span>(
      validated_style,
      foreground=[(<span class="hljs-string">'invalid'</span>, <span class="hljs-string">'white'</span>), (<span class="hljs-string">'!invalid'</span>, <span class="hljs-string">'black'</span>)],
      fieldbackground=[
        (<span class="hljs-string">'invalid'</span>, <span class="hljs-string">'darkred'</span>), 
        (<span class="hljs-string">'!invalid'</span>, <span class="hljs-string">'white'</span>)
      ]
    )
    self.configure(style=validated_style)
</code></pre>
    <p class="normal">Since this is a mixin class, we don't know the original style name of the widget we're mixing with, so we've fetched that using the <code class="Code-In-Text--PACKT-">winfo_class()</code> method. After getting the widget class, we're creating a custom style by prefixing the class with <code class="Code-In-Text--PACKT-">ValidatedInput</code>. Then, we call <code class="Code-In-Text--PACKT-">style.map()</code> to configure the foreground and background colors of this style in both invalid and not-invalid states: an <code class="Code-In-Text--PACKT-">invalid</code> state will cause the widget to have white text on dark red<a id="_idIndexMarker890"/> background, and a <code class="Code-In-Text--PACKT-">!invalid</code> state (that is, if the widget<a id="_idIndexMarker891"/> doesn't have an invalid flag) black on white. Finally, we apply the style to the widget using <code class="Code-In-Text--PACKT-">self.configure()</code>.</p>
    <p class="normal">If you try the application now, you might see that fields with errors now turn a dark red color with white text:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_16.png" alt="Figure 9.16: Our new validation styles at work"/></figure>
    <p class="packt_figref">Figure 9.16: Our new validation styles at work</p>
    <p class="normal">That is to say, you will see this on Linux or macOS; on Microsoft Windows, the field background will remain unchanged. What's going on here?</p>
    <p class="normal">Remember that from our earlier discussion in <em class="italic">Exploring a Ttk widget</em>, each platform comes with its own set of distinct themes, and each theme defines a unique layout for its widgets. These layouts define the individual elements of each widget and what properties can be defined for them. That means that some style properties might work on one theme, but not on another.</p>
    <p class="normal">In this case, the default Ttk theme for Windows (the <code class="Code-In-Text--PACKT-">vista</code> theme) does not allow the background color of our input widgets to be altered. Our target users for ABQ Data Entry are on Debian Linux, so this won't impact them. But it would be nice if we could see this feature working on other platforms.</p>
    <h2 id="_idParaDest-244" class="title">Setting themes</h2>
    <p class="normal">Generally speaking, the default Ttk theme on any given platform is probably the best one to use on that<a id="_idIndexMarker892"/> platform, but looks are subjective and sometimes we might feel that Tkinter gets it wrong. And sometimes, as we saw in the previous section, features we require for an application may not work in the default theme. Having a way to switch the theme might help to smooth out some rough edges and make some users feel more comfortable with the look of the application.</p>
    <p class="normal">As we've already seen, querying available themes and setting a new theme is fairly simple. Let's create a configuration option to change the theme of our application.</p>
    <h3 id="_idParaDest-245" class="title">Building a theme selector</h3>
    <p class="normal">Themes aren't something users are going to need to change often, and as we've seen, changing the theme<a id="_idIndexMarker893"/> can undo style changes we've made to our widgets. In light of this, we'll play it safe by designing our theme changer in such a way that it requires a restart of the program to make the actual change.</p>
    <p class="normal">We'll start by adding a <code class="Code-In-Text--PACKT-">theme</code> option to our <code class="Code-In-Text--PACKT-">SettingsModel</code> class's <code class="Code-In-Text--PACKT-">fields</code> dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside the SettingsModel class</span>
  fields = {
    <span class="hljs-comment">#...</span>
    <span class="code-highlight"><strong class="hljs-slc">'theme': {'type': 'str', 'value': 'default'}</strong></span>
    }
</code></pre>
    <p class="normal">Every platform has a theme aliased to <code class="Code-In-Text--PACKT-">default</code>, so this is a safe and sensible default value.</p>
    <p class="normal">Next, our <code class="Code-In-Text--PACKT-">Application</code> object will need to check this value when the settings are loaded and apply it. Add this code to the end of the <code class="Code-In-Text--PACKT-">Application._load_settings()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-comment"># application.py, in Application._load_settings()</span>
    style = ttk.Style()
    theme = self.settings.get(<span class="hljs-string">'theme'</span>).get()
    <span class="hljs-keyword">if</span> theme <span class="hljs-keyword">in</span> style.theme_names():
      style.theme_use(theme)
</code></pre>
    <p class="normal">This code will create a <code class="Code-In-Text--PACKT-">Style</code> object, retrieve the theme, and then set the theme using the <code class="Code-In-Text--PACKT-">theme_use()</code> method. If we should happen to give Tkinter a theme that doesn't exist, it will raise a <code class="Code-In-Text--PACKT-">TCLError</code> exception; to avoid this, we have added an <code class="Code-In-Text--PACKT-">if</code> statement to make sure the given theme is in the list returned by <code class="Code-In-Text--PACKT-">theme_names()</code>.</p>
    <p class="normal">What remains now is to create the UI elements required. As we did with our font options, we will add a sub-menu to our <code class="Code-In-Text--PACKT-">Options</code> menu for selecting a theme.</p>
    <p class="normal">To do this, open <code class="Code-In-Text--PACKT-">mainmenu.py</code> and add an import statement for <code class="Code-In-Text--PACKT-">ttk</code> at the top. Then, add the following code to the initializer method just after the font menus:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside MainMenu.__init__()</span>
    style = ttk.Style()
    themes_menu = tk.Menu(self, tearoff=<span class="hljs-literal">False</span>, **self.styles)
    <span class="hljs-keyword">for</span> theme <span class="hljs-keyword">in</span> style.theme_names():
      themes_menu.add_radiobutton(
        label=theme, value=theme,
        variable=self.settings[<span class="hljs-string">'theme'</span>]
      )
    options_menu.add_cascade(label=<span class="hljs-string">'Theme'</span>, menu=themes_menu)
</code></pre>
    <p class="normal">Here, as we did with our font settings, we simply loop through the available themes retrieved from <code class="Code-In-Text--PACKT-">theme_names()</code> and add a <code class="Code-In-Text--PACKT-">Radiobutton</code> item for each theme, tying it to our <code class="Code-In-Text--PACKT-">settings['theme']</code> variable.</p>
    <p class="normal">It may not be obvious<a id="_idIndexMarker894"/> to users that changing the theme requires a restart, so let's make sure to let them know.</p>
    <p class="normal">We can do that using a variable trace, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.settings[<span class="hljs-string">'theme'</span>].trace_add(
      <span class="hljs-string">'write'</span>, self._on_theme_change
    )
</code></pre>
    <p class="normal">Whenever the theme is changed, this trace will call the <code class="Code-In-Text--PACKT-">self._on_theme_change()</code> method; let's add this method to the end of the <code class="Code-In-Text--PACKT-">MainMenu</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside MainMenu</span>
<span class="hljs-meta">  @staticmethod</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_on_theme_change</span><span class="hljs-function">(</span><span class="hljs-params">*_</span><span class="hljs-function">):</span>
    message = <span class="hljs-string">"Change requires restart"</span>
    detail = (
      <span class="hljs-string">"Theme changes do not take effect"</span>
      <span class="hljs-string">" until application restart"</span>
    )
    messagebox.showwarning(
      title=<span class="hljs-string">'Warning'</span>,
      message=message,
      detail=detail
    )
</code></pre>
    <p class="normal">Note that we don't actually take any action here to change the theme; this method simply displays the warning message box and nothing else. The actual change to the setting is handled by the control variable bound to the menu checkboxes, so we don't really need to explicitly do anything. Also, because this method doesn't require access to the instance or class, we've made it a static method.</p>
    <p class="normal">Now, you can run the application<a id="_idIndexMarker895"/> and try changing the theme, and then restart the application. You should notice a change in the application's appearance. For example, here's the application using the "clam" theme:</p>
    <figure class="mediaobject"><img src="../Images/B17578_09_17.png" alt="Figure 9.17: ABQ Data Entry using the &quot;clam&quot; theme on Windows"/></figure>
    <p class="packt_figref">Figure 9.17: ABQ Data Entry using the "clam" theme on Windows</p>
    <p class="normal">As you can see, not every theme looks so good with our changes. Try the different themes available<a id="_idIndexMarker896"/> on your platform. Which theme looks best on your platform? Which ones work best with our style changes? Try them all out and see.</p>
    <h1 id="_idParaDest-246" class="title">Summary</h1>
    <p class="normal">In this chapter, we overhauled the look and feel of our application for both aesthetic and usability improvements. You learned how to use images and icons in your application using PhotoImage and BitmapImage, and how to extend image format support using Pillow. You learned to assign fonts to widgets, and to change the settings for built-in fonts. You learned how to work with color and font settings for default Tkinter widgets and how to use tags to style individual <code class="Code-In-Text--PACKT-">Treeview</code> items and <code class="Code-In-Text--PACKT-">Text</code> widget contents. We explored the intricate world of Ttk styles and learned to create custom styles based on the built-in defaults. Finally, we applied our knowledge of styling to the ABQ Data Entry application to make it more aesthetically pleasing and user-friendly.</p>
    <p class="normal">In the next chapter, we'll take steps to make sure our program runs effectively across major desktop platforms. You'll learn strategies to avoid cross-platform pitfalls in both general Python programming and Tkinter programming in particular. We'll also explore the various guidelines platform vendors offer to developers targeting their platforms.</p>
  </div>
</body></html>