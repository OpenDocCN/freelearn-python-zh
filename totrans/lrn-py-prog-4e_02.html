<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer057">
   <h1 class="chapterNumber">
    <span class="koboSpan" id="kobo.1.1">
     2
    </span>
   </h1>
   <h1 class="chapterTitle" id="_idParaDest-55">
    <span class="koboSpan" id="kobo.2.1">
     Built-In Data Types
    </span>
   </h1>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.3.1">
      ”Data!
     </span>
     <span class="koboSpan" id="kobo.3.2">
      Data!
     </span>
     <span class="koboSpan" id="kobo.3.3">
      Data!”
     </span>
     <span class="koboSpan" id="kobo.3.4">
      he cried impatiently.
     </span>
     <span class="koboSpan" id="kobo.3.5">
      “I can’t make bricks without clay.”
     </span>
    </p>
    <p class="cite">
     <span class="koboSpan" id="kobo.4.1">
      —Sherlock Holmes, in The Adventure of the Copper Beeches
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.5.1">
     Everything you do with a computer is managing data.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     Data
    </span>
    <a id="_idIndexMarker127">
    </a>
    <span class="koboSpan" id="kobo.6.1">
     comes in many different shapes and flavors.
    </span>
    <span class="koboSpan" id="kobo.6.2">
     It is the music you listen to, the movies you stream, the PDFs you open.
    </span>
    <span class="koboSpan" id="kobo.6.3">
     Even the source of the chapter you’re reading at this very moment is just a file, which is data.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.7.1">
     Data can be simple, whether it is an integer number to represent an age, or a complex structure, like an order placed on a website.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     It can be about a single object or about a collection of them.
    </span>
    <span class="koboSpan" id="kobo.7.3">
     Data can even be about data—that
    </span>
    <a id="_idIndexMarker128">
    </a>
    <span class="koboSpan" id="kobo.8.1">
     is,
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.9.1">
      metadata
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     .
    </span>
    <span class="koboSpan" id="kobo.10.2">
     This is data that describes the design of other data structures, or data that describes application data or its context.
    </span>
    <span class="koboSpan" id="kobo.10.3">
     In Python,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.11.1">
      objects are an abstraction for data
     </span>
    </em>
    <span class="koboSpan" id="kobo.12.1">
     , and Python has an amazing variety of data structures that you can use to represent data or combine them to create your own custom data.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.13.1">
     In this chapter, we are going to cover the following:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.14.1">
      Python objects’ structures
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.15.1">
      Mutability and immutability
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.16.1">
      Built-in data types: numbers, strings, dates and times, sequences, collections, and mapping types
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.17.1">
      The
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.18.1">
       collections
      </span>
     </code>
     <span class="koboSpan" id="kobo.19.1">
      module, briefly
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.20.1">
      Enumerations
     </span>
    </li>
   </ul>
   <h1 class="heading-1" id="_idParaDest-56">
    <span class="koboSpan" id="kobo.21.1">
     Everything is an object
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.22.1">
     Before we delve into the specifics, we want you to be very clear about objects in Python, so let us talk a little bit more about them.
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.23.1">
      Everything in Python is an object
     </span>
    </em>
    <span class="koboSpan" id="kobo.24.1">
     , and every object has an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.25.1">
      identity
     </span>
    </code>
    <span class="koboSpan" id="kobo.26.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.27.1">
      ID
     </span>
    </code>
    <span class="koboSpan" id="kobo.28.1">
     ), a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.29.1">
      type
     </span>
    </code>
    <span class="koboSpan" id="kobo.30.1">
     , and a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.31.1">
      value
     </span>
    </code>
    <span class="koboSpan" id="kobo.32.1">
     .
    </span>
    <span class="koboSpan" id="kobo.32.2">
     But what really happens when you type an instruction like
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.33.1">
      age = 42
     </span>
    </code>
    <span class="koboSpan" id="kobo.34.1">
     in a Python module?
    </span>
   </p>
   <div class="packt_tip">
    <p class="normal">
     <span class="koboSpan" id="kobo.35.1">
      If you go to
     </span>
     <a href="https://pythontutor.com/">
      <span class="url">
       <span class="koboSpan" id="kobo.36.1">
        https://pythontutor.com/
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.37.1">
      , you can type that instruction into a text box and get its visual representation.
     </span>
     <span class="koboSpan" id="kobo.37.2">
      Keep this website in mind; it is very useful to consolidate your understanding of what goes on behind the scenes.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.38.1">
     So, what happens is that
    </span>
    <a id="_idIndexMarker129">
    </a>
    <span class="koboSpan" id="kobo.39.1">
     an
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.40.1">
      object
     </span>
    </strong>
    <span class="koboSpan" id="kobo.41.1">
     is created.
    </span>
    <span class="koboSpan" id="kobo.41.2">
     It gets an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.42.1">
      id
     </span>
    </code>
    <span class="koboSpan" id="kobo.43.1">
     , the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.44.1">
      type
     </span>
    </code>
    <span class="koboSpan" id="kobo.45.1">
     is set to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.46.1">
      int
     </span>
    </code>
    <span class="koboSpan" id="kobo.47.1">
     (integer number), and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.48.1">
      value
     </span>
    </code>
    <span class="koboSpan" id="kobo.49.1">
     to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.50.1">
      42
     </span>
    </code>
    <span class="koboSpan" id="kobo.51.1">
     .
    </span>
    <span class="koboSpan" id="kobo.51.2">
     A name,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.52.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.53.1">
     , is placed in the global namespace, pointing to that object.
    </span>
    <span class="koboSpan" id="kobo.53.2">
     Therefore, whenever we are in the global namespace, after the execution of that line, we can retrieve that object by simply accessing it through its name:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.54.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.55.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.56.1">
     If you were to move house, you would put all the knives, forks, and spoons in a box and label it
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.57.1">
      cutlery
     </span>
    </em>
    <span class="koboSpan" id="kobo.58.1">
     .
    </span>
    <span class="koboSpan" id="kobo.58.2">
     This is exactly the same concept.
    </span>
    <span class="koboSpan" id="kobo.58.3">
     Here is a screenshot of what it may look like (you may have to tweak the settings to get the same view):
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.59.1">
     <img alt="img" src="../Images/B30996_02_01.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.60.1">
     Figure 2.1 – A name pointing to an object
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.61.1">
     So, for the rest of this chapter, whenever you read something such as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.62.1">
      name = some_value
     </span>
    </code>
    <span class="koboSpan" id="kobo.63.1">
     , think of a name placed in the namespace that is tied to the scope in which the instruction was written, with a nice arrow pointing to an object that has an
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.64.1">
      id
     </span>
    </em>
    <span class="koboSpan" id="kobo.65.1">
     , a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.66.1">
      type
     </span>
    </em>
    <span class="koboSpan" id="kobo.67.1">
     , and a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.68.1">
      value
     </span>
    </em>
    <span class="koboSpan" id="kobo.69.1">
     .
    </span>
    <span class="koboSpan" id="kobo.69.2">
     There is a little bit more to say about this mechanism, but it is much easier to talk about it using an example, so we will come back to this later.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-57">
    <span class="koboSpan" id="kobo.70.1">
     Mutability
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.71.1">
     The first fundamental distinction
    </span>
    <a id="_idIndexMarker130">
    </a>
    <span class="koboSpan" id="kobo.72.1">
     that Python makes about data is whether the value of an object can change.
    </span>
    <span class="koboSpan" id="kobo.72.2">
     If the value can change, the object is
    </span>
    <a id="_idIndexMarker131">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.74.1">
      mutable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     , otherwise the object is
    </span>
    <a id="_idIndexMarker132">
    </a>
    <span class="koboSpan" id="kobo.76.1">
     called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.77.1">
      immutable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.78.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.79.1">
     It is important that you understand the distinction between mutable and immutable because it affects the code you write.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     Let us look at the following example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.80.1">&gt;&gt;&gt; age = 42
&gt;&gt;&gt; age
42
&gt;&gt;&gt; age = 43  #A
&gt;&gt;&gt; age
43
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.81.1">
     In the preceding code, on line
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.82.1">
      #A
     </span>
    </code>
    <span class="koboSpan" id="kobo.83.1">
     , have we changed the value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.84.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.85.1">
     ?
    </span>
    <span class="koboSpan" id="kobo.85.2">
     Well, no.
    </span>
    <span class="koboSpan" id="kobo.85.3">
     But now it is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.86.1">
      43
     </span>
    </code>
    <span class="koboSpan" id="kobo.87.1">
     (we hear you say...).
    </span>
    <span class="koboSpan" id="kobo.87.2">
     Yes, it is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.88.1">
      43
     </span>
    </code>
    <span class="koboSpan" id="kobo.89.1">
     , but
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.90.1">
      42
     </span>
    </code>
    <span class="koboSpan" id="kobo.91.1">
     was an integer number, of the type
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.92.1">
      int
     </span>
    </em>
    <span class="koboSpan" id="kobo.93.1">
     , which is immutable.
    </span>
    <span class="koboSpan" id="kobo.93.2">
     So, what happened is really that on the first line,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.94.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.95.1">
     is a name that is set to point to an
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.96.1">
      int
     </span>
    </em>
    <span class="koboSpan" id="kobo.97.1">
     object, whose value is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.98.1">
      42
     </span>
    </code>
    <span class="koboSpan" id="kobo.99.1">
     .
    </span>
    <span class="koboSpan" id="kobo.99.2">
     When we type
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.100.1">
      age = 43
     </span>
    </code>
    <span class="koboSpan" id="kobo.101.1">
     , what happens is that another
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.102.1">
      int
     </span>
    </em>
    <span class="koboSpan" id="kobo.103.1">
     object is created, with the value
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.104.1">
      43
     </span>
    </code>
    <span class="koboSpan" id="kobo.105.1">
     (also, the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.106.1">
      id
     </span>
    </em>
    <span class="koboSpan" id="kobo.107.1">
     will be different), and the name
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.108.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.109.1">
     is set to point to it.
    </span>
    <span class="koboSpan" id="kobo.109.2">
     So, in fact, we did not change
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.110.1">
      42
     </span>
    </code>
    <span class="koboSpan" id="kobo.111.1">
     to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.112.1">
      43
     </span>
    </code>
    <span class="koboSpan" id="kobo.113.1">
     —we just pointed the name
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.114.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.115.1">
     to a different location, which is the new
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.116.1">
      int
     </span>
    </em>
    <span class="koboSpan" id="kobo.117.1">
     object whose value is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.118.1">
      43
     </span>
    </code>
    <span class="koboSpan" id="kobo.119.1">
     .
    </span>
    <span class="koboSpan" id="kobo.119.2">
     Let us see the IDs of the objects:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.120.1">&gt;&gt;&gt; age = 42
&gt;&gt;&gt; id(age)
4377553168
&gt;&gt;&gt; age = 43
&gt;&gt;&gt; id(age)
4377553200
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.121.1">
     Notice that we call the built-in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.122.1">
      id()
     </span>
    </code>
    <span class="koboSpan" id="kobo.123.1">
     function to print the IDs.
    </span>
    <span class="koboSpan" id="kobo.123.2">
     As you can see, they are different, as expected.
    </span>
    <span class="koboSpan" id="kobo.123.3">
     Bear in mind that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.124.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.125.1">
     points to one object at a time:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.126.1">
      42
     </span>
    </code>
    <span class="koboSpan" id="kobo.127.1">
     first, then
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.128.1">
      43
     </span>
    </code>
    <span class="koboSpan" id="kobo.129.1">
     —never together.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.130.1">
      If you reproduce these examples on your computer, you will notice that the IDs you get will be different.
     </span>
     <span class="koboSpan" id="kobo.130.2">
      This is of course expected, as they are generated randomly by Python and will be different every time.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.131.1">
     Now, let us see the same example using a mutable object.
    </span>
    <span class="koboSpan" id="kobo.131.2">
     For this example, we will use the built-in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.132.1">
      set
     </span>
    </code>
    <span class="koboSpan" id="kobo.133.1">
     type:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.134.1">&gt;&gt;&gt; numbers = set()
&gt;&gt;&gt; id(numbers)
4368427136
&gt;&gt;&gt; numbers
set()
&gt;&gt;&gt; numbers.add(3)
&gt;&gt;&gt; numbers.add(7)
&gt;&gt;&gt; id(numbers)
4368427136
&gt;&gt;&gt; numbers
{3, 7}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.135.1">
     In this case, we set up an object,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.136.1">
      numbers
     </span>
    </code>
    <span class="koboSpan" id="kobo.137.1">
     , which represents a mathematical set.
    </span>
    <span class="koboSpan" id="kobo.137.2">
     We can see its
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.138.1">
      id
     </span>
    </code>
    <span class="koboSpan" id="kobo.139.1">
     being printed and the fact that it is empty (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.140.1">
      set()
     </span>
    </code>
    <span class="koboSpan" id="kobo.141.1">
     ), right after creation.
    </span>
    <span class="koboSpan" id="kobo.141.2">
     We then proceed to add two numbers to it:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.142.1">
      3
     </span>
    </code>
    <span class="koboSpan" id="kobo.143.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.144.1">
      7
     </span>
    </code>
    <span class="koboSpan" id="kobo.145.1">
     .
    </span>
    <span class="koboSpan" id="kobo.145.2">
     We print the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.146.1">
      id
     </span>
    </code>
    <span class="koboSpan" id="kobo.147.1">
     again (which shows it is the same object) and its value, which
    </span>
    <a id="_idIndexMarker133">
    </a>
    <span class="koboSpan" id="kobo.148.1">
     now shows it contains the two numbers.
    </span>
    <span class="koboSpan" id="kobo.148.2">
     So the object’s value has changed, but its
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.149.1">
      id
     </span>
    </code>
    <span class="koboSpan" id="kobo.150.1">
     is still the same.
    </span>
    <span class="koboSpan" id="kobo.150.2">
     This shows the typical behavior of a mutable object.
    </span>
    <span class="koboSpan" id="kobo.150.3">
     We will explore sets in more detail later in this chapter.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.151.1">
     Mutability is a very important concept.
    </span>
    <span class="koboSpan" id="kobo.151.2">
     We will remind you about it throughout the rest of the chapter.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-58">
    <span class="koboSpan" id="kobo.152.1">
     Numbers
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.153.1">
     Let us start by exploring Python’s
    </span>
    <a id="_idIndexMarker134">
    </a>
    <span class="koboSpan" id="kobo.154.1">
     built-in data types for numbers.
    </span>
    <span class="koboSpan" id="kobo.154.2">
     Python was designed by a man with a master’s degree in mathematics and computer science, so it is only logical that it has extensive support for numbers.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.155.1">
     Numbers are immutable objects.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-59">
    <span class="koboSpan" id="kobo.156.1">
     Integers
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.157.1">
     Python integers
    </span>
    <a id="_idIndexMarker135">
    </a>
    <span class="koboSpan" id="kobo.158.1">
     have an unlimited
    </span>
    <a id="_idIndexMarker136">
    </a>
    <span class="koboSpan" id="kobo.159.1">
     range, subject only to the available virtual memory.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     This means that it doesn’t really matter how big the number you want to store is—as long as it can fit in your computer’s memory, Python will take care of it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.160.1">
     Integer numbers can be positive, negative, or 0 (zero).
    </span>
    <span class="koboSpan" id="kobo.160.2">
     Their type is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.161.1">
      int
     </span>
    </em>
    <span class="koboSpan" id="kobo.162.1">
     .
    </span>
    <span class="koboSpan" id="kobo.162.2">
     They support all the basic mathematical operations, as shown in the following example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.163.1">&gt;&gt;&gt; a = 14
&gt;&gt;&gt; b = 3
&gt;&gt;&gt; a + b  # addition
17
&gt;&gt;&gt; a - b  # subtraction
11
&gt;&gt;&gt; a * b  # multiplication
42
&gt;&gt;&gt; a / b  # true division
4.666666666666667
&gt;&gt;&gt; a // b  # integer division
4
&gt;&gt;&gt; a % b  # modulo operation (remainder of division)
2
&gt;&gt;&gt; a ** b  # power operation
2744
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.164.1">
     The preceding
    </span>
    <a id="_idIndexMarker137">
    </a>
    <span class="koboSpan" id="kobo.165.1">
     code should be easy
    </span>
    <a id="_idIndexMarker138">
    </a>
    <span class="koboSpan" id="kobo.166.1">
     to understand.
    </span>
    <span class="koboSpan" id="kobo.166.2">
     Just notice one important thing: Python has two division operators, one performs the so-called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.167.1">
      true division
     </span>
    </strong>
    <span class="koboSpan" id="kobo.168.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.169.1">
      /
     </span>
    </code>
    <span class="koboSpan" id="kobo.170.1">
     ), which
    </span>
    <a id="_idIndexMarker139">
    </a>
    <span class="koboSpan" id="kobo.171.1">
     returns the quotient of the operands, and another one, the
    </span>
    <a id="_idIndexMarker140">
    </a>
    <span class="koboSpan" id="kobo.172.1">
     so-called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.173.1">
      integer division
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.175.1">
      //
     </span>
    </code>
    <span class="koboSpan" id="kobo.176.1">
     ), which
    </span>
    <a id="_idIndexMarker141">
    </a>
    <span class="koboSpan" id="kobo.177.1">
     returns the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.178.1">
      floored
     </span>
    </em>
    <span class="koboSpan" id="kobo.179.1">
     quotient of the operands.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.180.1">
      As historical information, in Python 2, the division operator
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.181.1">
       /
      </span>
     </code>
     <span class="koboSpan" id="kobo.182.1">
      behaves differently than in Python 3.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.183.1">
     Let us see how division behaves differently when we introduce negative numbers:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.184.1">&gt;&gt;&gt; 7 / 4  # true division
1.75
&gt;&gt;&gt; 7 // 4  # integer division, truncation returns 1
1
&gt;&gt;&gt; -7 / 4  # true division again, result is opposite of previous
-1.75
&gt;&gt;&gt; -7 // 4  # integer div., result not the opposite of previous
-2
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.185.1">
     This is an interesting example.
    </span>
    <span class="koboSpan" id="kobo.185.2">
     If you were expecting
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.186.1">
      -1
     </span>
    </code>
    <span class="koboSpan" id="kobo.187.1">
     on the last line, don’t feel bad, it is just the way Python works.
    </span>
    <span class="koboSpan" id="kobo.187.2">
     Integer division in Python is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.188.1">
      always rounded toward minus infinity
     </span>
    </em>
    <span class="koboSpan" id="kobo.189.1">
     .
    </span>
    <span class="koboSpan" id="kobo.189.2">
     If, instead of flooring, you want to truncate a number to an integer, you can use the built-in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.190.1">
      int()
     </span>
    </code>
    <span class="koboSpan" id="kobo.191.1">
     function, as shown in the following example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.192.1">&gt;&gt;&gt; int(1.75)
1
&gt;&gt;&gt; int(-1.75)
-1
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.193.1">
     Notice that the truncation is done toward 0 instead.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.194.1">
      The
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.195.1">
       int()
      </span>
     </code>
     <span class="koboSpan" id="kobo.196.1">
      function can also return integer numbers from string representation in a given base:
     </span>
    </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.197.1">&gt;&gt;&gt; int('10110', base=2)
22
</span></code></pre>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.198.1">
     It is worth
    </span>
    <a id="_idIndexMarker142">
    </a>
    <span class="koboSpan" id="kobo.199.1">
     noting that the
    </span>
    <a id="_idIndexMarker143">
    </a>
    <span class="koboSpan" id="kobo.200.1">
     power operator,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.201.1">
      **
     </span>
    </code>
    <span class="koboSpan" id="kobo.202.1">
     , also has a built-in function counterpart,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.203.1">
      pow()
     </span>
    </code>
    <span class="koboSpan" id="kobo.204.1">
     , shown in the example below:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.205.1">&gt;&gt;&gt; pow(10, 3)
1000
&gt;&gt;&gt; 10 ** 3
1000
&gt;&gt;&gt; pow(10, -3)
0.001
&gt;&gt;&gt; 10 ** -3
0.001
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.206.1">
     There is also an operator to calculate the remainder of a division.
    </span>
    <span class="koboSpan" id="kobo.206.2">
     It is called the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.207.1">
      modulo operator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.208.1">
     , and it is represented by a percentage symbol (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.209.1">
      %
     </span>
    </code>
    <span class="koboSpan" id="kobo.210.1">
     ):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.211.1">&gt;&gt;&gt; 10 % 3  # remainder of the division 10 // 3
1
&gt;&gt;&gt; 10 % 4  # remainder of the division 10 // 4
2
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.212.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.213.1">
      pow()
     </span>
    </code>
    <span class="koboSpan" id="kobo.214.1">
     function allows a third argument to
    </span>
    <a id="_idIndexMarker144">
    </a>
    <span class="koboSpan" id="kobo.215.1">
     perform
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.216.1">
      modular exponentiation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.217.1">
     .
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.218.1">
      The form with three arguments also accepts a negative exponent in the case where the base is relatively prime to the modulus.
     </span>
     <span class="koboSpan" id="kobo.218.2">
      The result is the
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.219.1">
       modular multiplicative inverse
      </span>
     </strong>
     <span class="koboSpan" id="kobo.220.1">
      of
     </span>
     <a id="_idIndexMarker145">
     </a>
     <span class="koboSpan" id="kobo.221.1">
      the base (or a suitable power of that, when the exponent is negative, but not -1), modulo the third argument.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.222.1">
     Here’s an example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.223.1">&gt;&gt;&gt; pow(123, 4)
228886641
&gt;&gt;&gt; pow(123, 4, 100)
41  # notice: 228886641 % 100 == 41
&gt;&gt;&gt; pow(37, -1, 43)  # modular inverse of 37 mod 43
7
&gt;&gt;&gt; (7 * 37) % 43  # proof the above is correct
1
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.224.1">
     One nice
    </span>
    <a id="_idIndexMarker146">
    </a>
    <span class="koboSpan" id="kobo.225.1">
     feature introduced in Python 3.6 is the ability to add underscores within number literals (between digits or base specifiers, but not leading or trailing).
    </span>
    <span class="koboSpan" id="kobo.225.2">
     The purpose is to help make
    </span>
    <a id="_idIndexMarker147">
    </a>
    <span class="koboSpan" id="kobo.226.1">
     some numbers more readable, such as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.227.1">
      1_000_000_000
     </span>
    </code>
    <span class="koboSpan" id="kobo.228.1">
     :
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.229.1">&gt;&gt;&gt; n = 1_024
&gt;&gt;&gt; n
1024
&gt;&gt;&gt; hex_n = 0x_4_0_0  # 0x400 == 1024
&gt;&gt;&gt; hex_n
1024
</span></code></pre>
   <h2 class="heading-2" id="_idParaDest-60">
    <span class="koboSpan" id="kobo.230.1">
     Booleans
    </span>
   </h2>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.231.1">
      Boolean
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     algebra is that
    </span>
    <a id="_idIndexMarker148">
    </a>
    <span class="koboSpan" id="kobo.233.1">
     subset of algebra in which the values of the variables are the truth values,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.234.1">
      true
     </span>
    </em>
    <span class="koboSpan" id="kobo.235.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.236.1">
      false
     </span>
    </em>
    <span class="koboSpan" id="kobo.237.1">
     .
    </span>
    <span class="koboSpan" id="kobo.237.2">
     In Python,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.238.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.239.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.240.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.241.1">
     are two keywords that are used to
    </span>
    <a id="_idIndexMarker149">
    </a>
    <span class="koboSpan" id="kobo.242.1">
     represent truth values.
    </span>
    <span class="koboSpan" id="kobo.242.2">
     Booleans are a subclass of integers, so
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.243.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.244.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.245.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.246.1">
     behave respectively like
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.247.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.248.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.249.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.250.1">
     .
    </span>
    <span class="koboSpan" id="kobo.250.2">
     The equivalent of the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.251.1">
      int
     </span>
    </em>
    <span class="koboSpan" id="kobo.252.1">
     type for Booleans is the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.253.1">
      bool
     </span>
    </em>
    <span class="koboSpan" id="kobo.254.1">
     type, which returns either
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.255.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.256.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.257.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.258.1">
     .
    </span>
    <span class="koboSpan" id="kobo.258.2">
     Every built-in Python object has a value in the Boolean context, which means they evaluate to either
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.259.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.260.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.261.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.262.1">
     when fed to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.263.1">
      bool
     </span>
    </code>
    <span class="koboSpan" id="kobo.264.1">
     function.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.265.1">
     Boolean values can be combined in Boolean expressions using the logical operators
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.266.1">
      and
     </span>
    </code>
    <span class="koboSpan" id="kobo.267.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.268.1">
      or
     </span>
    </code>
    <span class="koboSpan" id="kobo.269.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.270.1">
      not
     </span>
    </code>
    <span class="koboSpan" id="kobo.271.1">
     .
    </span>
    <span class="koboSpan" id="kobo.271.2">
     Let us see a simple example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.272.1">&gt;&gt;&gt; int(True)  # True behaves like 1
1
&gt;&gt;&gt; int(False)  # False behaves like 0
0
&gt;&gt;&gt; bool(1)  # 1 evaluates to True in a Boolean context
True
&gt;&gt;&gt; bool(-42)  # and so does every non-zero number
True
&gt;&gt;&gt; bool(0)  # 0 evaluates to False
False
&gt;&gt;&gt; # quick peek at the operators (and, or, not)
&gt;&gt;&gt; not True
False
&gt;&gt;&gt; not False
True
&gt;&gt;&gt; True and True
True
&gt;&gt;&gt; False or True
True
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.273.1">
     Booleans are most used in conditional programming, which we will discuss in detail in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.274.1">
      Chapter 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.275.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.276.1">
      Conditionals and Iteration.
     </span>
    </em>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.277.1">
     You can see
    </span>
    <a id="_idIndexMarker150">
    </a>
    <span class="koboSpan" id="kobo.278.1">
     that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.279.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.280.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.281.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.282.1">
     are subclasses of integers when you try to add them.
    </span>
    <span class="koboSpan" id="kobo.282.2">
     Python
    </span>
    <a id="_idIndexMarker151">
    </a>
    <span class="koboSpan" id="kobo.283.1">
     upcasts them to integers and performs the addition:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.284.1">&gt;&gt;&gt; 1 + True
2
&gt;&gt;&gt; False + 42
42
&gt;&gt;&gt; 7 - True
6
</span></code></pre>
   <div class="note">
    <p class="normal">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.285.1">
       Upcasting
      </span>
     </strong>
     <span class="koboSpan" id="kobo.286.1">
      is a
     </span>
     <a id="_idIndexMarker152">
     </a>
     <span class="koboSpan" id="kobo.287.1">
      type conversion operation that goes from a subclass to its parent.
     </span>
     <span class="koboSpan" id="kobo.287.2">
      In this example,
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.288.1">
       True
      </span>
     </code>
     <span class="koboSpan" id="kobo.289.1">
      and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.290.1">
       False
      </span>
     </code>
     <span class="koboSpan" id="kobo.291.1">
      , which belong to a class derived from the integer class, are converted back to integers when needed.
     </span>
     <span class="koboSpan" id="kobo.291.2">
      This topic is about inheritance and will be explained in detail in
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.292.1">
       Chapter 6
      </span>
     </em>
     <span class="koboSpan" id="kobo.293.1">
      ,
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.294.1">
       OOP, Decorators, and Iterators
      </span>
     </em>
     <span class="koboSpan" id="kobo.295.1">
      .
     </span>
    </p>
   </div>
   <h2 class="heading-2" id="_idParaDest-61">
    <span class="koboSpan" id="kobo.296.1">
     Real numbers
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.297.1">
     Real
    </span>
    <a id="_idIndexMarker153">
    </a>
    <span class="koboSpan" id="kobo.298.1">
     numbers, or
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.299.1">
      floating point numbers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.300.1">
     , are
    </span>
    <a id="_idIndexMarker154">
    </a>
    <span class="koboSpan" id="kobo.301.1">
     represented in Python
    </span>
    <a id="_idIndexMarker155">
    </a>
    <span class="koboSpan" id="kobo.302.1">
     according to the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.303.1">
      IEEE 754
     </span>
    </strong>
    <span class="koboSpan" id="kobo.304.1">
     double-precision binary floating point format, which stores them in 64 bits of information divided into three sections: sign, exponent, and mantissa.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.305.1">
      Quench your thirst for knowledge
     </span>
     <a id="_idIndexMarker156">
     </a>
     <span class="koboSpan" id="kobo.306.1">
      about this format on Wikipedia:
     </span>
     <a href="http://en.wikipedia.org/wiki/Double-precision_floating-point_format">
      <span class="url">
       <span class="koboSpan" id="kobo.307.1">
        http://en.wikipedia.org/wiki/Double-precision_floating-point_format
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.308.1">
      .
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.309.1">
     Several
    </span>
    <a id="_idIndexMarker157">
    </a>
    <span class="koboSpan" id="kobo.310.1">
     programming languages offer two different formats: single and double precision.
    </span>
    <span class="koboSpan" id="kobo.310.2">
     The former takes up
    </span>
    <a id="_idIndexMarker158">
    </a>
    <span class="koboSpan" id="kobo.311.1">
     32 bits of memory, the latter 64.
    </span>
    <span class="koboSpan" id="kobo.311.2">
     Python supports only the double format.
    </span>
    <span class="koboSpan" id="kobo.311.3">
     Let us see a simple example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.312.1">&gt;&gt;&gt; pi = 3.1415926536  # how many digits of PI can you remember?
</span><span class="koboSpan" id="kobo.312.2">&gt;&gt;&gt; radius = 4.5
&gt;&gt;&gt; area = pi * (radius ** 2)
&gt;&gt;&gt; area
63.617251235400005
</span></code></pre>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.313.1">
      In the calculation of the area, we wrapped the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.314.1">
       radius ** 2
      </span>
     </code>
     <span class="koboSpan" id="kobo.315.1">
      within parentheses.
     </span>
     <span class="koboSpan" id="kobo.315.2">
      Even though that wasn’t necessary because the power operator has higher precedence than the multiplication one, we think the formula reads more easily like that.
     </span>
     <span class="koboSpan" id="kobo.315.3">
      Moreover, should you get a slightly different result for the area, don’t worry.
     </span>
     <span class="koboSpan" id="kobo.315.4">
      It might depend on your OS, how Python was compiled, and so on.
     </span>
     <span class="koboSpan" id="kobo.315.5">
      As long as the first few decimal digits are correct, you know it is the correct result.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.316.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.317.1">
      sys.float_info
     </span>
    </code>
    <span class="koboSpan" id="kobo.318.1">
     sequence holds information about how floating point numbers will behave on your system.
    </span>
    <span class="koboSpan" id="kobo.318.2">
     This is an example of what you might see:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.319.1">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.float_info
sys.float_info(
    max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308,
    min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307,
    dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2,
    rounds=1
)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.320.1">
     Let us make a few considerations here: we have 64 bits to represent floating point numbers.
    </span>
    <span class="koboSpan" id="kobo.320.2">
     This means we can represent at most
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.321.1">
      2
     </span>
    </em>
    <sup class="superscript">
     <span class="koboSpan" id="kobo.322.1">
      64
     </span>
    </sup>
    <span class="koboSpan" id="kobo.323.1">
     (that is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.324.1">
      18,446,744,073,709,551,616
     </span>
    </em>
    <span class="koboSpan" id="kobo.325.1">
     ) distinct numbers.
    </span>
    <span class="koboSpan" id="kobo.325.2">
     Take a look at the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.326.1">
      max
     </span>
    </code>
    <span class="koboSpan" id="kobo.327.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.328.1">
      epsilon
     </span>
    </code>
    <span class="koboSpan" id="kobo.329.1">
     values for floating point numbers, and you will realize that it is impossible to represent them all.
    </span>
    <span class="koboSpan" id="kobo.329.2">
     There is just not enough space, so they are approximated to the closest representable number.
    </span>
    <span class="koboSpan" id="kobo.329.3">
     You probably think that only extremely big or extremely small numbers suffer from this issue.
    </span>
    <span class="koboSpan" id="kobo.329.4">
     If so, the next example will surprise you:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.330.1">&gt;&gt;&gt; 0.3 - 0.1 * 3  # this should be 0!!!
</span><span class="koboSpan" id="kobo.330.2">-5.551115123125783e-17
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.331.1">
     What
    </span>
    <a id="_idIndexMarker159">
    </a>
    <span class="koboSpan" id="kobo.332.1">
     does this tell you?
    </span>
    <span class="koboSpan" id="kobo.332.2">
     It
    </span>
    <a id="_idIndexMarker160">
    </a>
    <span class="koboSpan" id="kobo.333.1">
     tells you that double precision numbers suffer from approximation issues even when it comes to simple numbers like 0.1 or 0.3.
    </span>
    <span class="koboSpan" id="kobo.333.2">
     Why is this important?
    </span>
    <span class="koboSpan" id="kobo.333.3">
     It can be a big problem if you are handling prices, financial calculations, or any kind of data that requires precision.
    </span>
    <span class="koboSpan" id="kobo.333.4">
     Don’t worry, Python gives you
    </span>
    <a id="_idIndexMarker161">
    </a>
    <span class="koboSpan" id="kobo.334.1">
     the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.335.1">
      Decimal
     </span>
    </strong>
    <span class="koboSpan" id="kobo.336.1">
     type, which doesn’t suffer from these issues; we’ll look at that in a moment.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-62">
    <span class="koboSpan" id="kobo.337.1">
     Complex numbers
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.338.1">
     Python supports
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.339.1">
      complex numbers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.340.1">
     out of
    </span>
    <a id="_idIndexMarker162">
    </a>
    <span class="koboSpan" id="kobo.341.1">
     the box.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     If you do not know what complex numbers
    </span>
    <a id="_idIndexMarker163">
    </a>
    <span class="koboSpan" id="kobo.342.1">
     are, they are numbers that can be expressed in the form
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.343.1">
      a + ib
     </span>
    </em>
    <span class="koboSpan" id="kobo.344.1">
     , where
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.345.1">
      a
     </span>
    </em>
    <span class="koboSpan" id="kobo.346.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.347.1">
      b
     </span>
    </em>
    <span class="koboSpan" id="kobo.348.1">
     are real numbers, and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.349.1">
      i
     </span>
    </em>
    <span class="koboSpan" id="kobo.350.1">
     (or
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.351.1">
      j
     </span>
    </em>
    <span class="koboSpan" id="kobo.352.1">
     , if you use the engineering notation) is the imaginary unit; that is, the square root of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.353.1">
      -1
     </span>
    </em>
    <span class="koboSpan" id="kobo.354.1">
     .
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.355.1">
      a
     </span>
    </em>
    <span class="koboSpan" id="kobo.356.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.357.1">
      b
     </span>
    </em>
    <span class="koboSpan" id="kobo.358.1">
     are called, respectively, the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.359.1">
      real
     </span>
    </em>
    <span class="koboSpan" id="kobo.360.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.361.1">
      imaginary
     </span>
    </em>
    <span class="koboSpan" id="kobo.362.1">
     parts of the number.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.363.1">
     It is perhaps unlikely that you will use them, but nevertheless, let us see a small example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.364.1">&gt;&gt;&gt; c = 3.14 + 2.73j
&gt;&gt;&gt; c = complex(3.14, 2.73)  # same as above
&gt;&gt;&gt; c.real  # real part
3.14
&gt;&gt;&gt; c.imag  # imaginary part
2.73
&gt;&gt;&gt; c.conjugate()  # conjugate of A + Bj is A - Bj
(3.14-2.73j)
&gt;&gt;&gt; c * 2  # multiplication is allowed
(6.28+5.46j)
&gt;&gt;&gt; c ** 2  # power operation as well
(2.406700000000001+17.1444j)
&gt;&gt;&gt; d = 1 + 1j  # addition and subtraction as well
&gt;&gt;&gt; c - d
(2.14+1.73j)
</span></code></pre>
   <h2 class="heading-2" id="_idParaDest-63">
    <span class="koboSpan" id="kobo.365.1">
     Fractions and decimals
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.366.1">
     Let us finish the tour of the number department with a look at fractions and decimals.
    </span>
    <span class="koboSpan" id="kobo.366.2">
     Fractions
    </span>
    <a id="_idIndexMarker164">
    </a>
    <span class="koboSpan" id="kobo.367.1">
     hold a rational
    </span>
    <a id="_idIndexMarker165">
    </a>
    <span class="koboSpan" id="kobo.368.1">
     numerator and denominator in their lowest forms.
    </span>
    <span class="koboSpan" id="kobo.368.2">
     Let us see a quick example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.369.1">&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; Fraction(10, 6)  # mad hatter?
</span><span class="koboSpan" id="kobo.369.2">Fraction(5, 3)  # notice it has been simplified
&gt;&gt;&gt; Fraction(1, 3) + Fraction(2, 3)  # 1/3 + 2/3 == 3/3 == 1/1
Fraction(1, 1)
&gt;&gt;&gt; f = Fraction(10, 6)
&gt;&gt;&gt; f.numerator
5
&gt;&gt;&gt; f.denominator
3
&gt;&gt;&gt; f.as_integer_ratio()
(5, 3)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.370.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.371.1">
      as_integer_ratio()
     </span>
    </code>
    <span class="koboSpan" id="kobo.372.1">
     method has also been added to integers and Booleans.
    </span>
    <span class="koboSpan" id="kobo.372.2">
     This is helpful, as it allows you to use it without needing to worry about what type of number is being worked with.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.373.1">
     Other than passing the numerator and denominator, fractions can also be initialized by passing strings, decimals, floats, and of course fractions.
    </span>
    <span class="koboSpan" id="kobo.373.2">
     Let us see an example with floats and strings:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.374.1">&gt;&gt;&gt; Fraction(0.125)  
Fraction(1, 8)
&gt;&gt;&gt; Fraction("3 / 7")
Fraction(3, 7)
&gt;&gt;&gt; Fraction("-.250")
Fraction(-1, 4)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.375.1">
     Although
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.376.1">
      Fraction
     </span>
    </code>
    <span class="koboSpan" id="kobo.377.1">
     objects can be very useful at times, it is not that common to spot them in commercial software.
    </span>
    <span class="koboSpan" id="kobo.377.2">
     Instead, it is much more common to see decimal numbers being used in all those contexts where precision is everything, for example, in scientific and financial calculations.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.378.1">
      It is important to remember that arbitrary precision decimal numbers come at a price in terms of performance, of course.
     </span>
     <span class="koboSpan" id="kobo.378.2">
      The amount of data to be stored for each number is greater than it is for fractions or floats.
     </span>
     <span class="koboSpan" id="kobo.378.3">
      The way they are handled also requires the Python interpreter to work harder behind the scenes.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.379.1">
     Let us see a
    </span>
    <a id="_idIndexMarker166">
    </a>
    <span class="koboSpan" id="kobo.380.1">
     quick example with decimal
    </span>
    <a id="_idIndexMarker167">
    </a>
    <span class="koboSpan" id="kobo.381.1">
     numbers:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.382.1">&gt;&gt;&gt; from decimal import Decimal as D  # rename for brevity
&gt;&gt;&gt; D(3.14)  # pi, from float, so approximation issues
Decimal('3.140000000000000124344978758017532527446746826171875')
&gt;&gt;&gt; D("3.14")  # pi, from a string, so no approximation issues
Decimal('3.14')
&gt;&gt;&gt; D(0.1) * D(3) - D(0.3)  # from float, we still have the issue
Decimal('2.775557561565156540423631668E-17')
&gt;&gt;&gt; D("0.1") * D(3) - D("0.3")  # from string, all perfect
Decimal('0.0')
&gt;&gt;&gt; D("1.4").as_integer_ratio()  # 7/5 = 1.4 (isn't this cool?!)
(7, 5)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.383.1">
     Notice that when we construct a decimal number from a float, it takes on all the approximation issues a float may come with.
    </span>
    <span class="koboSpan" id="kobo.383.2">
     On the other hand, when we create a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.384.1">
      decimal
     </span>
    </code>
    <span class="koboSpan" id="kobo.385.1">
     from an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.386.1">
      integer
     </span>
    </code>
    <span class="koboSpan" id="kobo.387.1">
     or a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.388.1">
      string
     </span>
    </code>
    <span class="koboSpan" id="kobo.389.1">
     representation of a number, then the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.390.1">
      decimal
     </span>
    </code>
    <span class="koboSpan" id="kobo.391.1">
     will have no approximation issues, and therefore no quirky behavior.
    </span>
    <span class="koboSpan" id="kobo.391.2">
     When it comes to currency or situations in which precision is of utmost importance, use decimals.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.392.1">
     This concludes our introduction to built-in numeric types.
    </span>
    <span class="koboSpan" id="kobo.392.2">
     Let us now look at sequences.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-64">
    <span class="koboSpan" id="kobo.393.1">
     Immutable sequences
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.394.1">
     Let us explore immutable sequences: strings, tuples, and bytes.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-65">
    <span class="koboSpan" id="kobo.395.1">
     Strings and bytes
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.396.1">
     Textual data in Python is
    </span>
    <a id="_idIndexMarker168">
    </a>
    <span class="koboSpan" id="kobo.397.1">
     handled with
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.398.1">
      str
     </span>
    </strong>
    <span class="koboSpan" id="kobo.399.1">
     objects, more commonly
    </span>
    <a id="_idIndexMarker169">
    </a>
    <span class="koboSpan" id="kobo.400.1">
     known as
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.401.1">
      strings
     </span>
    </strong>
    <span class="koboSpan" id="kobo.402.1">
     .
    </span>
    <span class="koboSpan" id="kobo.402.2">
     They are immutable sequences of
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.403.1">
      Unicode code points
     </span>
    </strong>
    <span class="koboSpan" id="kobo.404.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.405.1">
     Unicode code points
    </span>
    <a id="_idIndexMarker170">
    </a>
    <span class="koboSpan" id="kobo.406.1">
     are the numbers assigned to each character in the Unicode standard, which is a universal character encoding scheme used to represent text in computers.
    </span>
    <span class="koboSpan" id="kobo.406.2">
     The Unicode standard provides a unique number for every character, regardless of the platform, program, or language, thereby enabling the consistent representation and manipulation of text across different systems.
    </span>
    <span class="koboSpan" id="kobo.406.3">
     Unicode covers a wide range of characters, including letters from the Latin alphabet, ideographs from Chinese, Japanese, and Korean writing systems, symbols, emojis, and more.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.407.1">
     Unlike other languages, Python does not have a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.408.1">
      char
     </span>
    </strong>
    <span class="koboSpan" id="kobo.409.1">
     type, so a single character is represented by a string of
    </span>
    <a id="_idIndexMarker171">
    </a>
    <span class="koboSpan" id="kobo.410.1">
     length 1.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.411.1">
     Unicode
    </span>
    <a id="_idIndexMarker172">
    </a>
    <span class="koboSpan" id="kobo.412.1">
     should be used for the internals of any application.
    </span>
    <span class="koboSpan" id="kobo.412.2">
     When it comes to storing textual data though, or sending it on the network, you will usually need to encode it, using an appropriate encoding for the medium you are using.
    </span>
    <span class="koboSpan" id="kobo.412.3">
     The result of an encoding produces
    </span>
    <a id="_idIndexMarker173">
    </a>
    <span class="koboSpan" id="kobo.413.1">
     a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.414.1">
      bytes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.415.1">
     object, whose
    </span>
    <a id="_idIndexMarker174">
    </a>
    <span class="koboSpan" id="kobo.416.1">
     syntax and behavior are similar to that of
    </span>
    <a id="_idIndexMarker175">
    </a>
    <span class="koboSpan" id="kobo.417.1">
     strings.
    </span>
    <span class="koboSpan" id="kobo.417.2">
     String literals are written in Python using single, double, or triple quotes (either single or double).
    </span>
    <span class="koboSpan" id="kobo.417.3">
     If built with triple quotes, a string can span multiple lines.
    </span>
    <span class="koboSpan" id="kobo.417.4">
     An example will clarify this:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.418.1">&gt;&gt;&gt; # 4 ways to make a string
&gt;&gt;&gt; str1 = 'This is a string. </span><span class="koboSpan" id="kobo.418.2">We built it with single quotes.'
</span><span class="koboSpan" id="kobo.418.3">&gt;&gt;&gt; str2 = "This is also a string, but built with double quotes."
</span><span class="koboSpan" id="kobo.418.4">&gt;&gt;&gt; str3 = '''This is built using triple quotes,
... </span><span class="koboSpan" id="kobo.418.5">so it can span multiple lines.'''
</span><span class="koboSpan" id="kobo.418.6">&gt;&gt;&gt; str4 = """This too
... </span><span class="koboSpan" id="kobo.418.7">is a multiline one
... </span><span class="koboSpan" id="kobo.418.8">built with triple double-quotes."""
</span><span class="koboSpan" id="kobo.418.9">&gt;&gt;&gt; str4  #A
'This too\nis a multiline one\nbuilt with triple double-quotes.'
</span><span class="koboSpan" id="kobo.418.10">&gt;&gt;&gt; print(str4)  #B
This too
is a multiline one
built with triple double-quotes.
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.419.1">
     In
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.420.1">
      #A
     </span>
    </code>
    <span class="koboSpan" id="kobo.421.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.422.1">
      #B
     </span>
    </code>
    <span class="koboSpan" id="kobo.423.1">
     , we print
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.424.1">
      str4
     </span>
    </code>
    <span class="koboSpan" id="kobo.425.1">
     , first implicitly, and then explicitly, using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.426.1">
      print()
     </span>
    </code>
    <em class="italic">
    </em>
    <span class="koboSpan" id="kobo.427.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.427.2">
     A good exercise would be to find out why they are different.
    </span>
    <span class="koboSpan" id="kobo.427.3">
     Are you up to the challenge?
    </span>
    <span class="koboSpan" id="kobo.427.4">
     (Hint: look up the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.428.1">
      str()
     </span>
    </code>
    <span class="koboSpan" id="kobo.429.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.430.1">
      repr()
     </span>
    </code>
    <span class="koboSpan" id="kobo.431.1">
     functions.)
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.432.1">
     Strings, like any sequence, have a length.
    </span>
    <span class="koboSpan" id="kobo.432.2">
     You can get this by calling the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.433.1">
      len()
     </span>
    </code>
    <span class="koboSpan" id="kobo.434.1">
     function:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.435.1">&gt;&gt;&gt; len(str1)
49
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.436.1">
     Python 3.9 has introduced two new methods that deal with the prefixes
    </span>
    <a id="_idIndexMarker176">
    </a>
    <span class="koboSpan" id="kobo.437.1">
     and suffixes
    </span>
    <a id="_idIndexMarker177">
    </a>
    <span class="koboSpan" id="kobo.438.1">
     of strings.
    </span>
    <span class="koboSpan" id="kobo.438.2">
     Here’s an example that explains the way they work:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.439.1">&gt;&gt;&gt; s = "Hello There"
&gt;&gt;&gt; s.removeprefix("Hell")
'o There'
&gt;&gt;&gt; s.removesuffix("here")
'Hello T'
&gt;&gt;&gt; s.removeprefix("Ooops")
'Hello There'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.440.1">
     The nice thing about them is shown by the last instruction: when we attempt to remove a prefix or suffix that is not there, the method simply returns a copy of the original string.
    </span>
    <span class="koboSpan" id="kobo.440.2">
     Behind the scenes, these methods check if the string has a prefix or suffix that matches the argument of the call, and if that is the case, they remove it.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-66">
    <span class="koboSpan" id="kobo.441.1">
     Encoding and decoding strings
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.442.1">
     Using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.443.1">
      encode/decode
     </span>
    </code>
    <span class="koboSpan" id="kobo.444.1">
     methods, we can
    </span>
    <a id="_idIndexMarker178">
    </a>
    <span class="koboSpan" id="kobo.445.1">
     encode Unicode strings and decode bytes objects.
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.446.1">
      UTF-8
     </span>
    </strong>
    <span class="koboSpan" id="kobo.447.1">
     is a
    </span>
    <a id="_idIndexMarker179">
    </a>
    <span class="koboSpan" id="kobo.448.1">
     variable-length
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.449.1">
      character encoding
     </span>
    </strong>
    <span class="koboSpan" id="kobo.450.1">
     , capable
    </span>
    <a id="_idIndexMarker180">
    </a>
    <span class="koboSpan" id="kobo.451.1">
     of encoding all possible Unicode code points.
    </span>
    <span class="koboSpan" id="kobo.451.2">
     It is the most widely used
    </span>
    <a id="_idIndexMarker181">
    </a>
    <span class="koboSpan" id="kobo.452.1">
     encoding for the web.
    </span>
    <span class="koboSpan" id="kobo.452.2">
     Also notice that by adding the literal
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.453.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.454.1">
     in front of a string declaration, we are creating a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.455.1">
      bytes
     </span>
    </code>
    <span class="koboSpan" id="kobo.456.1">
     object:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.457.1">&gt;&gt;&gt; s = "This is üŋíc0de"  # unicode string: code points
&gt;&gt;&gt; type(s)
&lt;class 'str'&gt;
&gt;&gt;&gt; encoded_s = s.encode("utf-8")  # utf-8 encoded version of s
&gt;&gt;&gt; encoded_s
b'This is \xc3\xbc\xc5\x8b\xc3\xadc0de'  # result: bytes object
&gt;&gt;&gt; type(encoded_s)  # another way to verify it
&lt;class 'bytes'&gt;
&gt;&gt;&gt; encoded_s.decode("utf-8")  # let us revert to the original
'This is üŋíc0de'
&gt;&gt;&gt; bytes_obj = b"A bytes object"  # a bytes object
&gt;&gt;&gt; type(bytes_obj)
&lt;class 'bytes'&gt;
</span></code></pre>
   <h3 class="heading-3" id="_idParaDest-67">
    <span class="koboSpan" id="kobo.458.1">
     Indexing and slicing strings
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.459.1">
     When manipulating
    </span>
    <a id="_idIndexMarker182">
    </a>
    <span class="koboSpan" id="kobo.460.1">
     sequences, it is very common to access them at one precise
    </span>
    <a id="_idIndexMarker183">
    </a>
    <span class="koboSpan" id="kobo.461.1">
     position (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.462.1">
      indexing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.463.1">
     ) or to
    </span>
    <a id="_idIndexMarker184">
    </a>
    <span class="koboSpan" id="kobo.464.1">
     get a sub-sequence out of them (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.465.1">
      slicing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.466.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.466.2">
     When dealing with
    </span>
    <a id="_idIndexMarker185">
    </a>
    <span class="koboSpan" id="kobo.467.1">
     immutable sequences, both operations are read-only.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.468.1">
     While indexing comes in one form—zero-based access to any position within the sequence—slicing comes in different forms.
    </span>
    <span class="koboSpan" id="kobo.468.2">
     When you get a slice of a sequence, you can specify the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.469.1">
      start
     </span>
    </em>
    <span class="koboSpan" id="kobo.470.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.471.1">
      stop
     </span>
    </em>
    <span class="koboSpan" id="kobo.472.1">
     positions, along with the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.473.1">
      step
     </span>
    </em>
    <span class="koboSpan" id="kobo.474.1">
     .
    </span>
    <span class="koboSpan" id="kobo.474.2">
     They are separated with a colon (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.475.1">
      :
     </span>
    </code>
    <span class="koboSpan" id="kobo.476.1">
     ) like this:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.477.1">
      my_sequence[start:stop:step]
     </span>
    </code>
    <span class="koboSpan" id="kobo.478.1">
     .
    </span>
    <span class="koboSpan" id="kobo.478.2">
     All the arguments are optional;
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.479.1">
      start
     </span>
    </code>
    <span class="koboSpan" id="kobo.480.1">
     is inclusive, and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.481.1">
      stop
     </span>
    </code>
    <span class="koboSpan" id="kobo.482.1">
     is exclusive.
    </span>
    <span class="koboSpan" id="kobo.482.2">
     It is probably better to see an example, rather than trying to explain them any further with words:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.483.1">&gt;&gt;&gt; s = "The trouble is you think you have time."
</span><span class="koboSpan" id="kobo.483.2">&gt;&gt;&gt; s[0]  # indexing at position 0, which is the first char
'T'
&gt;&gt;&gt; s[5]  # indexing at position 5, which is the sixth char
'r'
&gt;&gt;&gt; s[:4]  # slicing, we specify only the stop position
'The '
&gt;&gt;&gt; s[4:]  # slicing, we specify only the start position
'trouble is you think you have time.'
</span><span class="koboSpan" id="kobo.483.3">&gt;&gt;&gt; s[2:14]  # slicing, both start and stop positions
'e trouble is'
&gt;&gt;&gt; s[2:14:3]  # slicing, start, stop and step (every 3 chars)
'erb '
&gt;&gt;&gt; s[:]  # quick way of making a copy
'The trouble is you think you have time.'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.484.1">
     The last line is quite interesting.
    </span>
    <span class="koboSpan" id="kobo.484.2">
     If you don’t specify any of the parameters, Python will fill in the defaults for you.
    </span>
    <span class="koboSpan" id="kobo.484.3">
     In this case,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.485.1">
      start
     </span>
    </em>
    <span class="koboSpan" id="kobo.486.1">
     will be the start of the string,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.487.1">
      stop
     </span>
    </em>
    <span class="koboSpan" id="kobo.488.1">
     will be the end of the string, and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.489.1">
      step
     </span>
    </em>
    <span class="koboSpan" id="kobo.490.1">
     will be the default: 1.
    </span>
    <span class="koboSpan" id="kobo.490.2">
     This is an easy and quick way of obtaining a copy of the string
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.491.1">
      s
     </span>
    </code>
    <span class="koboSpan" id="kobo.492.1">
     (the same value, but a different object).
    </span>
    <span class="koboSpan" id="kobo.492.2">
     Can you think of a way to get the reversed copy of a string using slicing (do not look it up—find it for yourself)?
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-68">
    <span class="koboSpan" id="kobo.493.1">
     String formatting
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.494.1">
     One useful feature of strings is that they can be
    </span>
    <a id="_idIndexMarker186">
    </a>
    <span class="koboSpan" id="kobo.495.1">
     used as templates.
    </span>
    <span class="koboSpan" id="kobo.495.2">
     This means that they can contain placeholders that can be replaced by arbitrary values using formatting operations.
    </span>
    <span class="koboSpan" id="kobo.495.3">
     There are several ways of formatting a string.
    </span>
    <span class="koboSpan" id="kobo.495.4">
     For the full list of possibilities, we encourage you to look up the documentation.
    </span>
    <span class="koboSpan" id="kobo.495.5">
     Here are some common examples:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.496.1">&gt;&gt;&gt; greet_old = "Hello %s!"
</span><span class="koboSpan" id="kobo.496.2">&gt;&gt;&gt; greet_old % 'Fabrizio'
'Hello Fabrizio!'
</span><span class="koboSpan" id="kobo.496.3">&gt;&gt;&gt; greet_positional = "Hello {}!"
</span><span class="koboSpan" id="kobo.496.4">&gt;&gt;&gt; greet_positional.format("Fabrizio")
'Hello Fabrizio!'
</span><span class="koboSpan" id="kobo.496.5">&gt;&gt;&gt; greet_positional = "Hello {} {}!"
</span><span class="koboSpan" id="kobo.496.6">&gt;&gt;&gt; greet_positional.format("Fabrizio", "Romano")
'Hello Fabrizio Romano!'
</span><span class="koboSpan" id="kobo.496.7">&gt;&gt;&gt; greet_positional_idx = "This is {0}! </span><span class="koboSpan" id="kobo.496.8">{1} loves {0}!"
</span><span class="koboSpan" id="kobo.496.9">&gt;&gt;&gt; greet_positional_idx.format("Python", "Heinrich")
'This is Python! </span><span class="koboSpan" id="kobo.496.10">Heinrich loves Python!'
</span><span class="koboSpan" id="kobo.496.11">&gt;&gt;&gt; greet_positional_idx.format("Coffee", "Fab")
'This is Coffee! </span><span class="koboSpan" id="kobo.496.12">Fab loves Coffee!'
</span><span class="koboSpan" id="kobo.496.13">&gt;&gt;&gt; keyword = "Hello, my name is {name} {last_name}"
&gt;&gt;&gt; keyword.format(name="Fabrizio", last_name="Romano")
'Hello, my name is Fabrizio Romano'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.497.1">
     In the previous example, you can see four different ways of formatting strings.
    </span>
    <span class="koboSpan" id="kobo.497.2">
     The first one, which relies on the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.498.1">
      %
     </span>
    </code>
    <span class="koboSpan" id="kobo.499.1">
     operator, can lead to unexpected errors and should be used with care.
    </span>
    <span class="koboSpan" id="kobo.499.2">
     A more modern way to format a string is by using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.500.1">
      format()
     </span>
    </code>
    <span class="koboSpan" id="kobo.501.1">
     string method.
    </span>
    <span class="koboSpan" id="kobo.501.2">
     You can see, from the different examples, that a pair of curly braces acts as a placeholder within the string.
    </span>
    <span class="koboSpan" id="kobo.501.3">
     When we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.502.1">
      format()
     </span>
    </code>
    <span class="koboSpan" id="kobo.503.1">
     , we feed it data that replaces the placeholders.
    </span>
    <span class="koboSpan" id="kobo.503.2">
     We can specify indexes (and much more) within the curly braces, and even names, which implies we must call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.504.1">
      format()
     </span>
    </code>
    <span class="koboSpan" id="kobo.505.1">
     using keyword arguments instead of positional ones.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.506.1">
     Notice how
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.507.1">
      greet_positional_idx
     </span>
    </code>
    <span class="koboSpan" id="kobo.508.1">
     is rendered
    </span>
    <a id="_idIndexMarker187">
    </a>
    <span class="koboSpan" id="kobo.509.1">
     differently by feeding different data to the call to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.510.1">
      format
     </span>
    </code>
    <span class="koboSpan" id="kobo.511.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.512.1">
     One feature we want to show you was added to Python in version 3.6, and it is called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.513.1">
      formatted string literals
     </span>
    </strong>
    <span class="koboSpan" id="kobo.514.1">
     .
    </span>
    <span class="koboSpan" id="kobo.514.2">
     This feature is
    </span>
    <a id="_idIndexMarker188">
    </a>
    <span class="koboSpan" id="kobo.515.1">
     quite cool (and it is faster than using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.516.1">
      format()
     </span>
    </code>
    <span class="koboSpan" id="kobo.517.1">
     method): strings are prefixed with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.518.1">
      f
     </span>
    </code>
    <span class="koboSpan" id="kobo.519.1">
     , and contain replacement fields surrounded by curly braces.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.520.1">
     Replacement fields are expressions evaluated at runtime, and then formatted using the format protocol:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.521.1">&gt;&gt;&gt; name = "Fab"
&gt;&gt;&gt; age = 48
&gt;&gt;&gt; f"Hello! </span><span class="koboSpan" id="kobo.521.2">My name is {name} and I'm {age}"
"Hello! </span><span class="koboSpan" id="kobo.521.3">My name is Fab and I'm 48"
&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; f"No arguing with {pi}, it's irrational..."
</span><span class="koboSpan" id="kobo.521.4">"No arguing with 3.141592653589793, it's irrational..."
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.522.1">
     An interesting addition to f-strings, which was introduced in Python 3.8, is the ability to add an equal sign specifier within the f-string clause; this causes the expression to expand to the text of the expression, an equal sign, then the representation of the evaluated expression.
    </span>
    <span class="koboSpan" id="kobo.522.2">
     This is great for self-documenting and debugging purposes.
    </span>
    <span class="koboSpan" id="kobo.522.3">
     Here’s an example that shows the difference in behavior:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.523.1">&gt;&gt;&gt; user = "heinrich"
&gt;&gt;&gt; password = "super-secret"
&gt;&gt;&gt; f"Log in with: {user} and {password}"
'Log in with: heinrich and super-secret'
&gt;&gt;&gt; f"Log in with: {user=} and {password=}"
"Log in with: user='heinrich' and password='super-secret'"
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.524.1">
     In version 3.12, the f-string syntactic
    </span>
    <a id="_idIndexMarker189">
    </a>
    <span class="koboSpan" id="kobo.525.1">
     formalization has been upgraded with a few features, which
    </span>
    <a id="_idIndexMarker190">
    </a>
    <span class="koboSpan" id="kobo.526.1">
     are outlined in PEP 701 (
    </span>
    <a href="https://peps.python.org/pep-0701/">
     <span class="url">
      <span class="koboSpan" id="kobo.527.1">
       https://peps.python.org/pep-0701/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.528.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.528.2">
     One of these features is quote reuse:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.529.1">&gt;&gt;&gt; languages = ["Python", "Javascript"]
&gt;&gt;&gt; f"Two very popular languages: {", ".join(languages)}"
'Two very popular languages: Python, Javascript'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.530.1">
     Notice how we have reused double quotes within the curly braces, and this hasn’t broken our code.
    </span>
    <span class="koboSpan" id="kobo.530.2">
     Here we are using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.531.1">
      join()
     </span>
    </code>
    <span class="koboSpan" id="kobo.532.1">
     method of the string
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.533.1">
      ","
     </span>
    </code>
    <span class="koboSpan" id="kobo.534.1">
     to join together the strings from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.535.1">
      languages
     </span>
    </code>
    <span class="koboSpan" id="kobo.536.1">
     list using a comma and a space.
    </span>
    <span class="koboSpan" id="kobo.536.2">
     In previous versions of Python, we would have had to delimit the string inside the curly braces using single quotes:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.537.1">
      ', '
     </span>
    </code>
    <span class="koboSpan" id="kobo.538.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.539.1">
     Another feature is the ability to write multiline expressions and comments, and also to use backslashes (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.540.1">
      \
     </span>
    </code>
    <span class="koboSpan" id="kobo.541.1">
     ), which wasn’t allowed before.
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.542.1">&gt;&gt;&gt; f"Who knew f-strings could be so powerful? </span><span class="koboSpan" id="kobo.542.2">{"\N{shrug}"}"
'Who knew f-strings could be so powerful? </span><span class="koboSpan" id="kobo.542.3">🤷'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.543.1">
     Check out the official documentation to learn everything about string formatting and how powerful it can be.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-69">
    <span class="koboSpan" id="kobo.544.1">
     Tuples
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.545.1">
     The last immutable sequence type
    </span>
    <a id="_idIndexMarker191">
    </a>
    <span class="koboSpan" id="kobo.546.1">
     we are going to look at here is the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.547.1">
      tuple
     </span>
    </strong>
    <span class="koboSpan" id="kobo.548.1">
     .
    </span>
    <span class="koboSpan" id="kobo.548.2">
     A tuple is a sequence of arbitrary Python
    </span>
    <a id="_idIndexMarker192">
    </a>
    <span class="koboSpan" id="kobo.549.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.549.2">
     In a tuple declaration, items are separated by commas.
    </span>
    <span class="koboSpan" id="kobo.549.3">
     Tuples are used everywhere in Python.
    </span>
    <span class="koboSpan" id="kobo.549.4">
     They allow patterns that are quite hard to reproduce in other languages.
    </span>
    <span class="koboSpan" id="kobo.549.5">
     Sometimes tuples are used without parentheses; for example, to set up multiple variables on one line, or to allow a function to return multiple objects (in several languages, it is common for functions to only be able to return one object), and in the Python console, tuples can be used implicitly to print multiple elements with one single instruction.
    </span>
    <span class="koboSpan" id="kobo.549.6">
     We will see examples for all these cases:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.550.1">&gt;&gt;&gt; t = ()  # empty tuple
&gt;&gt;&gt; type(t)
&lt;class 'tuple'&gt;
&gt;&gt;&gt; one_element_tuple = (42, )  # you need the comma!
</span><span class="koboSpan" id="kobo.550.2">&gt;&gt;&gt; three_elements_tuple = (1, 3, 5)  # braces are optional here
&gt;&gt;&gt; a, b, c = 1, 2, 3  # tuple for multiple assignment
&gt;&gt;&gt; a, b, c  # implicit tuple to print with one instruction
(1, 2, 3)
&gt;&gt;&gt; 3 in three_elements_tuple  # membership test
True
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.551.1">
     We use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.552.1">
      in
     </span>
    </code>
    <span class="koboSpan" id="kobo.553.1">
     operator to check whether a value is a member of a tuple.
    </span>
    <span class="koboSpan" id="kobo.553.2">
     This membership operator can also be used with lists, strings, and dictionaries, and with collection and sequence objects, in general.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.554.1">
      To create a tuple with one item, we need to put a comma after the item.
     </span>
     <span class="koboSpan" id="kobo.554.2">
      The reason is that, without the comma, that item is wrapped in braces on its own, in what can be considered a redundant expression.
     </span>
     <span class="koboSpan" id="kobo.554.3">
      Notice also that, on assignment, braces are optional, so
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.555.1">
       my_tuple = 1, 2, 3
      </span>
     </code>
     <span class="koboSpan" id="kobo.556.1">
      is the same as
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.557.1">
       my_tuple = (1, 2, 3)
      </span>
     </code>
     <span class="koboSpan" id="kobo.558.1">
      .
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.559.1">
     One thing that tuple assignment allows us to do is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.560.1">
      one-line swaps
     </span>
    </em>
    <span class="koboSpan" id="kobo.561.1">
     , with no need for a third temporary variable.
    </span>
    <span class="koboSpan" id="kobo.561.2">
     Let us first see the traditional way of doing it:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.562.1">&gt;&gt;&gt; a, b = 1, 2
&gt;&gt;&gt; c = a  # we need three lines and a temporary var c
&gt;&gt;&gt; a = b
&gt;&gt;&gt; b = c
&gt;&gt;&gt; a, b  # a and b have been swapped
(2, 1)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.563.1">
     Now let us see how we would do it in Python:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.564.1">&gt;&gt;&gt; a, b = 0, 1
&gt;&gt;&gt; a, b = b, a  # this is the Pythonic way to do it
&gt;&gt;&gt; a, b
(1, 0)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.565.1">
     Look at the line that shows you the Pythonic way of swapping two values.
    </span>
    <span class="koboSpan" id="kobo.565.2">
     Do you remember what we wrote in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.566.1">
      Chapter 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.567.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.568.1">
      A Gentle Introduction to Python
     </span>
    </em>
    <span class="koboSpan" id="kobo.569.1">
     ?
    </span>
    <span class="koboSpan" id="kobo.569.2">
     A Python program is typically one-fifth to one-third the size of equivalent Java or C++ code and features like one-line swaps contribute to this.
    </span>
    <span class="koboSpan" id="kobo.569.3">
     Python is elegant, where elegance in this context also means economy.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.570.1">
     Because they
    </span>
    <a id="_idIndexMarker193">
    </a>
    <span class="koboSpan" id="kobo.571.1">
     are immutable, tuples
    </span>
    <a id="_idIndexMarker194">
    </a>
    <span class="koboSpan" id="kobo.572.1">
     can be used as keys for dictionaries (we will see this shortly).
    </span>
    <span class="koboSpan" id="kobo.572.2">
     To us, tuples are Python’s built-in data that most closely represent a mathematical vector.
    </span>
    <span class="koboSpan" id="kobo.572.3">
     This does not mean that this was the reason for which they were created, though.
    </span>
    <span class="koboSpan" id="kobo.572.4">
     Tuples usually contain a heterogeneous sequence of elements while, on the other hand, lists are, most of the time, homogeneous.
    </span>
    <span class="koboSpan" id="kobo.572.5">
     Moreover, tuples are normally accessed via unpacking or indexing, while lists are usually iterated over.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-70">
    <span class="koboSpan" id="kobo.573.1">
     Mutable sequences
    </span>
   </h1>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.574.1">
      Mutable sequences
     </span>
    </strong>
    <span class="koboSpan" id="kobo.575.1">
     differ from their immutable
    </span>
    <a id="_idIndexMarker195">
    </a>
    <span class="koboSpan" id="kobo.576.1">
     counterparts in that they can be
    </span>
    <a id="_idIndexMarker196">
    </a>
    <span class="koboSpan" id="kobo.577.1">
     changed after creation.
    </span>
    <span class="koboSpan" id="kobo.577.2">
     There are
    </span>
    <a id="_idIndexMarker197">
    </a>
    <span class="koboSpan" id="kobo.578.1">
     two mutable
    </span>
    <a id="_idIndexMarker198">
    </a>
    <span class="koboSpan" id="kobo.579.1">
     sequence types in
    </span>
    <a id="_idIndexMarker199">
    </a>
    <span class="koboSpan" id="kobo.580.1">
     Python:
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.581.1">
      lists
     </span>
    </strong>
    <span class="koboSpan" id="kobo.582.1">
     and
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.583.1">
      bytearrays
     </span>
    </strong>
    <span class="koboSpan" id="kobo.584.1">
     .
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-71">
    <span class="koboSpan" id="kobo.585.1">
     Lists
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.586.1">
     Python lists
    </span>
    <a id="_idIndexMarker200">
    </a>
    <span class="koboSpan" id="kobo.587.1">
     are similar to
    </span>
    <a id="_idIndexMarker201">
    </a>
    <span class="koboSpan" id="kobo.588.1">
     tuples, but they do not have the restrictions of immutability.
    </span>
    <span class="koboSpan" id="kobo.588.2">
     Lists are commonly used for storing collections of homogeneous objects, but there is nothing preventing you from storing heterogeneous collections as well.
    </span>
    <span class="koboSpan" id="kobo.588.3">
     Lists can be created in many different ways.
    </span>
    <span class="koboSpan" id="kobo.588.4">
     Let us see an example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.589.1">&gt;&gt;&gt; []  # empty list
[]
&gt;&gt;&gt; list()  # same as []
[]
&gt;&gt;&gt; [1, 2, 3]  # as with tuples, items are comma separated
[1, 2, 3]
&gt;&gt;&gt; [x + 5 for x in [2, 3, 4]]  # Python is magic
[7, 8, 9]
&gt;&gt;&gt; list((1, 3, 5, 7, 9))  # list from a tuple
[1, 3, 5, 7, 9]
&gt;&gt;&gt; list("hello")  # list from a string
['h', 'e', 'l', 'l', 'o']
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.590.1">
     In the previous
    </span>
    <a id="_idIndexMarker202">
    </a>
    <span class="koboSpan" id="kobo.591.1">
     example, we
    </span>
    <a id="_idIndexMarker203">
    </a>
    <span class="koboSpan" id="kobo.592.1">
     showed you how to create a list using various techniques.
    </span>
    <span class="koboSpan" id="kobo.592.2">
     We would like you to take a good look at the line with the comment
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.593.1">
      Python is magic
     </span>
    </em>
    <span class="koboSpan" id="kobo.594.1">
     , which we do not expect you to fully understand at this point—especially if you are unfamiliar with Python.
    </span>
    <span class="koboSpan" id="kobo.594.2">
     That is called a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.595.1">
      list comprehension
     </span>
    </strong>
    <span class="koboSpan" id="kobo.596.1">
     : a powerful
    </span>
    <a id="_idIndexMarker204">
    </a>
    <span class="koboSpan" id="kobo.597.1">
     functional feature of Python, which we will see in detail in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.598.1">
      Chapter 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.599.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.600.1">
      Comprehensions and Generators
     </span>
    </em>
    <span class="koboSpan" id="kobo.601.1">
     .
    </span>
    <span class="koboSpan" id="kobo.601.2">
     We just wanted to spark your curiosity at this point.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.602.1">
     Creating lists is good, but the real fun begins when we use them, so let us see the main methods they offer:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.603.1">&gt;&gt;&gt; a = [1, 2, 1, 3]
&gt;&gt;&gt; a.append(13)  # we can append anything at the end
&gt;&gt;&gt; a
[1, 2, 1, 3, 13]
&gt;&gt;&gt; a.count(1)  # how many `1` are there in the list?
</span><span class="koboSpan" id="kobo.603.2">2
&gt;&gt;&gt; a.extend([5, 7])  # extend the list by another (or sequence)
&gt;&gt;&gt; a
[1, 2, 1, 3, 13, 5, 7]
&gt;&gt;&gt; a.index(13)  # position of `13` in the list (0-based indexing)
4
&gt;&gt;&gt; a.insert(0, 17)  # insert `17` at position 0
&gt;&gt;&gt; a
[17, 1, 2, 1, 3, 13, 5, 7]
&gt;&gt;&gt; a.pop()  # pop (remove and return) last element
7
&gt;&gt;&gt; a.pop(3)  # pop element at position 3
1
&gt;&gt;&gt; a
[17, 1, 2, 3, 13, 5]
&gt;&gt;&gt; a.remove(17)  # remove `17` from the list
&gt;&gt;&gt; a
[1, 2, 3, 13, 5]
&gt;&gt;&gt; a.reverse()  # reverse the order of the elements in the list
&gt;&gt;&gt; a
[5, 13, 3, 2, 1]
&gt;&gt;&gt; a.sort()  # sort the list
&gt;&gt;&gt; a
[1, 2, 3, 5, 13]
&gt;&gt;&gt; a.clear()  # remove all elements from the list
&gt;&gt;&gt; a
[]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.604.1">
     The preceding code gives you a roundup of a list’s main methods.
    </span>
    <span class="koboSpan" id="kobo.604.2">
     We want to show you how powerful they are using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.605.1">
      extend()
     </span>
    </code>
    <span class="koboSpan" id="kobo.606.1">
     method as an example.
    </span>
    <span class="koboSpan" id="kobo.606.2">
     You can extend lists using any sequence type:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.607.1">&gt;&gt;&gt; a = list("hello")  # makes a list from a string
&gt;&gt;&gt; a
['h', 'e', 'l', 'l', 'o']
&gt;&gt;&gt; a.append(100)  # append 100, heterogeneous type
&gt;&gt;&gt; a
['h', 'e', 'l', 'l', 'o', 100]
&gt;&gt;&gt; a.extend((1, 2, 3))  # extend using tuple
&gt;&gt;&gt; a
['h', 'e', 'l', 'l', 'o', 100, 1, 2, 3]
&gt;&gt;&gt; a.extend('...')  # extend using string
&gt;&gt;&gt; a
['h', 'e', 'l', 'l', 'o', 100, 1, 2, 3, '.', '.', '.']
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.608.1">
     Now, let us
    </span>
    <a id="_idIndexMarker205">
    </a>
    <span class="koboSpan" id="kobo.609.1">
     see some common
    </span>
    <a id="_idIndexMarker206">
    </a>
    <span class="koboSpan" id="kobo.610.1">
     operations you can do with lists:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.611.1">&gt;&gt;&gt; a = [1, 3, 5, 7]
&gt;&gt;&gt; min(a)  # minimum value in the list
1
&gt;&gt;&gt; max(a)  # maximum value in the list
7
&gt;&gt;&gt; sum(a)  # sum of all values in the list
16
&gt;&gt;&gt; from math import prod
&gt;&gt;&gt; prod(a)  # product of all values in the list
105
&gt;&gt;&gt; len(a)  # number of elements in the list
4
&gt;&gt;&gt; b = [6, 7, 8]
&gt;&gt;&gt; a + b  # `+` with list means concatenation
[1, 3, 5, 7, 6, 7, 8]
&gt;&gt;&gt; a * 2  # `*` has also a special meaning
[1, 3, 5, 7, 1, 3, 5, 7]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.612.1">
     Notice how
    </span>
    <a id="_idIndexMarker207">
    </a>
    <span class="koboSpan" id="kobo.613.1">
     easily we can perform
    </span>
    <a id="_idIndexMarker208">
    </a>
    <span class="koboSpan" id="kobo.614.1">
     the sum and the product of all values in a list.
    </span>
    <span class="koboSpan" id="kobo.614.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.615.1">
      prod() function
     </span>
    </code>
    <span class="koboSpan" id="kobo.616.1">
     , from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.617.1">
      math
     </span>
    </code>
    <span class="koboSpan" id="kobo.618.1">
     module, is just one of the many additions introduced in Python 3.8.
    </span>
    <span class="koboSpan" id="kobo.618.2">
     Even if you do not plan to use it that often, it is a good idea to check out the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.619.1">
      math
     </span>
    </code>
    <span class="koboSpan" id="kobo.620.1">
     module and be familiar with its functions, as they can be quite helpful.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.621.1">
     The last two lines in the preceding code are also
    </span>
    <a id="_idIndexMarker209">
    </a>
    <span class="koboSpan" id="kobo.622.1">
     quite interesting, as they introduce us to a concept called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.623.1">
      operator overloading
     </span>
    </strong>
    <span class="koboSpan" id="kobo.624.1">
     .
    </span>
    <span class="koboSpan" id="kobo.624.2">
     In short, this means that operators, such as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.625.1">
      +
     </span>
    </code>
    <span class="koboSpan" id="kobo.626.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.627.1">
      -
     </span>
    </code>
    <span class="koboSpan" id="kobo.628.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.629.1">
      *
     </span>
    </code>
    <span class="koboSpan" id="kobo.630.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.631.1">
      %
     </span>
    </code>
    <span class="koboSpan" id="kobo.632.1">
     , and so on, may represent different operations according to the context they are used in.
    </span>
    <span class="koboSpan" id="kobo.632.2">
     It does not make any sense to sum two lists, right?
    </span>
    <span class="koboSpan" id="kobo.632.3">
     Therefore, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.633.1">
      +
     </span>
    </code>
    <span class="koboSpan" id="kobo.634.1">
     sign is used to concatenate them.
    </span>
    <span class="koboSpan" id="kobo.634.2">
     Hence, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.635.1">
      *
     </span>
    </code>
    <span class="koboSpan" id="kobo.636.1">
     sign is used to concatenate the list to itself a number of times specified by the right operand.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.637.1">
     Now, let us take a step further and see something a little more interesting.
    </span>
    <span class="koboSpan" id="kobo.637.2">
     We want to show you how powerful the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.638.1">
      sorted
     </span>
    </code>
    <span class="koboSpan" id="kobo.639.1">
     method can be and how easy it is in Python to achieve results that may require a great deal of effort in other languages:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.640.1">&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; a = [(5, 3), (1, 3), (1, 2), (2, -1), (4, 9)]
&gt;&gt;&gt; sorted(a)
[(1, 2), (1, 3), (2, -1), (4, 9), (5, 3)]
&gt;&gt;&gt; sorted(a, key=itemgetter(0))
[(1, 3), (1, 2), (2, -1), (4, 9), (5, 3)]
&gt;&gt;&gt; sorted(a, key=itemgetter(0, 1))
[(1, 2), (1, 3), (2, -1), (4, 9), (5, 3)]
&gt;&gt;&gt; sorted(a, key=itemgetter(1))
[(2, -1), (1, 2), (5, 3), (1, 3), (4, 9)]
&gt;&gt;&gt; sorted(a, key=itemgetter(1), reverse=True)
[(4, 9), (5, 3), (1, 3), (1, 2), (2, -1)]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.641.1">
     The preceding code deserves a little explanation.
    </span>
    <span class="koboSpan" id="kobo.641.2">
     Note that,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.642.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.643.1">
     is a list of tuples.
    </span>
    <span class="koboSpan" id="kobo.643.2">
     This means each element in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.644.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.645.1">
     is a tuple (a 2-tuple in this case).
    </span>
    <span class="koboSpan" id="kobo.645.2">
     When we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.646.1">
      sorted(my_list)
     </span>
    </code>
    <span class="koboSpan" id="kobo.647.1">
     , we get a sorted version of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.648.1">
      my_list
     </span>
    </code>
    <span class="koboSpan" id="kobo.649.1">
     .
    </span>
    <span class="koboSpan" id="kobo.649.2">
     In this case, the sorting on a 2-tuple works by sorting them on the first item in the tuple, and on the second when the first one is the same.
    </span>
    <span class="koboSpan" id="kobo.649.3">
     You can see this behavior in the result of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.650.1">
      sorted(a)
     </span>
    </code>
    <span class="koboSpan" id="kobo.651.1">
     , which yields
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.652.1">
      [(1, 2), (1, 3), ...]
     </span>
    </code>
    <span class="koboSpan" id="kobo.653.1">
     .
    </span>
    <span class="koboSpan" id="kobo.653.2">
     Python also gives us the ability to control which element(s) of the tuple the sorting must be run against.
    </span>
    <span class="koboSpan" id="kobo.653.3">
     Notice that when we instruct the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.654.1">
      sorted
     </span>
    </code>
    <span class="koboSpan" id="kobo.655.1">
     function, to work on the first element of each tuple (with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.656.1">
      key=itemgetter(0)
     </span>
    </code>
    <span class="koboSpan" id="kobo.657.1">
     ), the result is different:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.658.1">
      [(1, 3), (1, 2), ...]
     </span>
    </code>
    <span class="koboSpan" id="kobo.659.1">
     .
    </span>
    <span class="koboSpan" id="kobo.659.2">
     The sorting is done only on the first element of each tuple (which is the one at position 0).
    </span>
    <span class="koboSpan" id="kobo.659.3">
     If we want to replicate the default behavior of a simple
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.660.1">
      sorted(a)
     </span>
    </code>
    <span class="koboSpan" id="kobo.661.1">
     call, we need to use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.662.1">
      key=itemgetter(0, 1)
     </span>
    </code>
    <span class="koboSpan" id="kobo.663.1">
     , which tells Python to sort first on the elements at position 0 within the tuples, and then on those at position 1.
    </span>
    <span class="koboSpan" id="kobo.663.2">
     Compare the results and you will see that they match.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.664.1">
     For completeness, we included an example of sorting only on the elements at position 1, and then again, with the same sorting but in reverse order.
    </span>
    <span class="koboSpan" id="kobo.664.2">
     If you have ever seen sorting in other languages, you should be quite impressed at this moment.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.665.1">
     The Python sorting algorithm is very powerful, and it
    </span>
    <a id="_idIndexMarker210">
    </a>
    <span class="koboSpan" id="kobo.666.1">
     was written by Tim Peters (the author of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.667.1">
      The Zen of Python
     </span>
    </em>
    <span class="koboSpan" id="kobo.668.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.668.2">
     It is aptly named
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.669.1">
      Timsort
     </span>
    </strong>
    <span class="koboSpan" id="kobo.670.1">
     , and it is a blend between
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.671.1">
      merge
     </span>
    </strong>
    <span class="koboSpan" id="kobo.672.1">
     and
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.673.1">
      insertion sort
     </span>
    </strong>
    <span class="koboSpan" id="kobo.674.1">
     and has
    </span>
    <a id="_idIndexMarker211">
    </a>
    <span class="koboSpan" id="kobo.675.1">
     better time performance than most other algorithms used for
    </span>
    <a id="_idIndexMarker212">
    </a>
    <span class="koboSpan" id="kobo.676.1">
     mainstream programming languages.
    </span>
    <span class="koboSpan" id="kobo.676.2">
     Timsort is a stable sorting algorithm, which means that when multiple records score the same in the comparison, their original order is preserved.
    </span>
    <span class="koboSpan" id="kobo.676.3">
     We have seen this in the result of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.677.1">
      sorted(a, key=itemgetter(0))
     </span>
    </code>
    <span class="koboSpan" id="kobo.678.1">
     , which yielded
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.679.1">
      [(1, 3), (1, 2), ...]
     </span>
    </code>
    <span class="koboSpan" id="kobo.680.1">
     , in which the order of those two tuples was preserved because they had the same value at position 0.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-72">
    <span class="koboSpan" id="kobo.681.1">
     Bytearrays
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.682.1">
     To conclude our
    </span>
    <a id="_idIndexMarker213">
    </a>
    <span class="koboSpan" id="kobo.683.1">
     overview of mutable sequence types, let us spend a moment on the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.684.1">
      bytearray
     </span>
    </strong>
    <span class="koboSpan" id="kobo.685.1">
     type.
    </span>
    <span class="koboSpan" id="kobo.685.2">
     Bytearrays
    </span>
    <a id="_idIndexMarker214">
    </a>
    <span class="koboSpan" id="kobo.686.1">
     are the mutable version of bytes objects.
    </span>
    <span class="koboSpan" id="kobo.686.2">
     They expose most of the usual methods of mutable sequences as well as most of the methods of the bytes type.
    </span>
    <span class="koboSpan" id="kobo.686.3">
     Items in a bytearray are integers in the range [0, 256).
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.687.1">
      To represent intervals, we are going to use the standard notation for open/closed ranges.
     </span>
     <span class="koboSpan" id="kobo.687.2">
      A square bracket on one end means that the value is included, while a round bracket means that it is excluded.
     </span>
     <span class="koboSpan" id="kobo.687.3">
      The granularity is usually inferred by the type of the edge elements so, for example, the interval [3, 7] means all integers between 3 and 7, inclusive.
     </span>
     <span class="koboSpan" id="kobo.687.4">
      On the other hand, (3, 7) means all integers between 3 and 7, exclusive (4, 5, and 6).
     </span>
     <span class="koboSpan" id="kobo.687.5">
      Items in a bytearray type are integers between 0 and 256; 0 is included, 256 is not.
     </span>
    </p>
    <p class="normal">
     <span class="koboSpan" id="kobo.688.1">
      One reason that intervals are often expressed like this is to ease coding.
     </span>
     <span class="koboSpan" id="kobo.688.2">
      If we break a range [a, b) into N consecutive ranges, we can easily represent the original one as a concatenation like this:
     </span>
    </p>
    <p class="normal">
     <span class="koboSpan" id="kobo.689.1">
      [a,k
     </span>
     <sub class="subscript">
      <span class="koboSpan" id="kobo.690.1">
       1
      </span>
     </sub>
     <span class="koboSpan" id="kobo.691.1">
      ) + [k
     </span>
     <sub class="subscript">
      <span class="koboSpan" id="kobo.692.1">
       1
      </span>
     </sub>
     <span class="koboSpan" id="kobo.693.1">
      ,k
     </span>
     <sub class="subscript">
      <span class="koboSpan" id="kobo.694.1">
       2
      </span>
     </sub>
     <span class="koboSpan" id="kobo.695.1">
      ) + [k
     </span>
     <sub class="subscript">
      <span class="koboSpan" id="kobo.696.1">
       2
      </span>
     </sub>
     <span class="koboSpan" id="kobo.697.1">
      ,k
     </span>
     <sub class="subscript">
      <span class="koboSpan" id="kobo.698.1">
       3
      </span>
     </sub>
     <span class="koboSpan" id="kobo.699.1">
      ) + ...
     </span>
     <span class="koboSpan" id="kobo.699.2">
      + [k
     </span>
     <sub class="subscript">
      <span class="koboSpan" id="kobo.700.1">
       N-1
      </span>
     </sub>
     <span class="koboSpan" id="kobo.701.1">
      ,b)
     </span>
    </p>
    <p class="normal">
     <span class="koboSpan" id="kobo.702.1">
      The middle points (k
     </span>
     <sub class="subscript">
      <span class="koboSpan" id="kobo.703.1">
       i
      </span>
     </sub>
     <span class="koboSpan" id="kobo.704.1">
      ) being excluded on one end, and included on the other end, allows easy concatenation and splitting.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.705.1">
     Let us see an
    </span>
    <a id="_idIndexMarker215">
    </a>
    <span class="koboSpan" id="kobo.706.1">
     example
    </span>
    <a id="_idIndexMarker216">
    </a>
    <span class="koboSpan" id="kobo.707.1">
     with the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.708.1">
      bytearray
     </span>
    </code>
    <span class="koboSpan" id="kobo.709.1">
     type:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.710.1">&gt;&gt;&gt; bytearray()  # empty bytearray object
bytearray(b'')
&gt;&gt;&gt; bytearray(10)  # zero-filled instance with given length
bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
&gt;&gt;&gt; bytearray(range(5))  # bytearray from iterable of integers
bytearray(b'\x00\x01\x02\x03\x04')
&gt;&gt;&gt; name = bytearray(b"Lina")  #A - bytearray from bytes
&gt;&gt;&gt; name.replace(b"L", b"l")
bytearray(b'lina')
&gt;&gt;&gt; name.endswith(b'na')
True
&gt;&gt;&gt; name.upper()
bytearray(b'LINA')
&gt;&gt;&gt; name.count(b'L')
1
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.711.1">
     As you can see, there are a few ways to create a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.712.1">
      bytearray
     </span>
    </code>
    <span class="koboSpan" id="kobo.713.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.713.2">
     They can be useful in many situations; for example, when receiving data through a socket, they eliminate the need to concatenate data while polling, hence they can prove to be very handy.
    </span>
    <span class="koboSpan" id="kobo.713.3">
     On line
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.714.1">
      #A
     </span>
    </code>
    <span class="koboSpan" id="kobo.715.1">
     , we created a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.716.1">
      bytearray
     </span>
    </code>
    <span class="koboSpan" id="kobo.717.1">
     named
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.718.1">
      name
     </span>
    </code>
    <span class="koboSpan" id="kobo.719.1">
     from the bytes literal
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.720.1">
      b'Lina'
     </span>
    </code>
    <span class="koboSpan" id="kobo.721.1">
     to show you how the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.722.1">
      bytearray
     </span>
    </code>
    <span class="koboSpan" id="kobo.723.1">
     object exposes methods from both sequences and strings, which is extremely handy.
    </span>
    <span class="koboSpan" id="kobo.723.2">
     If you think about it, they can be considered mutable strings.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-73">
    <span class="koboSpan" id="kobo.724.1">
     Set types
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.725.1">
     Python also provides two
    </span>
    <a id="_idIndexMarker217">
    </a>
    <span class="koboSpan" id="kobo.726.1">
     set types,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.727.1">
      set
     </span>
    </code>
    <span class="koboSpan" id="kobo.728.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.729.1">
      frozenset
     </span>
    </code>
    <span class="koboSpan" id="kobo.730.1">
     .
    </span>
    <span class="koboSpan" id="kobo.730.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.731.1">
      set
     </span>
    </code>
    <span class="koboSpan" id="kobo.732.1">
     type is mutable, while
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.733.1">
      frozenset
     </span>
    </code>
    <span class="koboSpan" id="kobo.734.1">
     is immutable.
    </span>
    <span class="koboSpan" id="kobo.734.2">
     They
    </span>
    <a id="_idIndexMarker218">
    </a>
    <span class="koboSpan" id="kobo.735.1">
     are unordered
    </span>
    <a id="_idIndexMarker219">
    </a>
    <span class="koboSpan" id="kobo.736.1">
     collections of immutable
    </span>
    <a id="_idIndexMarker220">
    </a>
    <span class="koboSpan" id="kobo.737.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.737.2">
     When printed, they are usually represented as comma-separated values, within a pair of curly braces.
    </span>
   </p>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.738.1">
      Hashability
     </span>
    </strong>
    <span class="koboSpan" id="kobo.739.1">
     is a
    </span>
    <a id="_idIndexMarker221">
    </a>
    <span class="koboSpan" id="kobo.740.1">
     characteristic that allows an object to be used as a set member as well as a key for a dictionary, as we will see very soon.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.741.1">
     From the official
    </span>
    <a id="_idIndexMarker222">
    </a>
    <span class="koboSpan" id="kobo.742.1">
     documentation (
    </span>
    <a href="https://docs.python.org/3.12/glossary.html#term-hashable">
     <span class="url">
      <span class="koboSpan" id="kobo.743.1">
       https://docs.python.org/3.12/glossary.html#term-hashable
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.744.1">
     ):
    </span>
   </p>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.745.1">
      ”An object is
     </span>
     <em class="italic">
     </em>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.746.1">
       hashable
      </span>
     </strong>
     <em class="italic">
     </em>
     <span class="koboSpan" id="kobo.747.1">
      if it has a hash value which never changes during its lifetime, and can be compared to other objects.
     </span>
     <span class="koboSpan" id="kobo.747.2">
      […] Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.
     </span>
     <span class="koboSpan" id="kobo.747.3">
      Most of Python’s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable.
     </span>
     <span class="koboSpan" id="kobo.747.4">
      Objects which are instances of user-defined classes are hashable by default.
     </span>
     <span class="koboSpan" id="kobo.747.5">
      They all compare unequal (except with themselves), and their hash value is derived from their
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.748.1">
       id()
      </span>
     </code>
     <span class="koboSpan" id="kobo.749.1">
      .”
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.750.1">
     Objects that
    </span>
    <a id="_idIndexMarker223">
    </a>
    <span class="koboSpan" id="kobo.751.1">
     compare equal must have the same hash value.
    </span>
    <span class="koboSpan" id="kobo.751.2">
     Sets are very commonly used to test for membership; let us introduce the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.752.1">
      in
     </span>
    </code>
    <span class="koboSpan" id="kobo.753.1">
     operator in the following example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.754.1">&gt;&gt;&gt; small_primes = set()  # empty set
&gt;&gt;&gt; small_primes.add(2)  # adding one element at a time
&gt;&gt;&gt; small_primes.add(3)
&gt;&gt;&gt; small_primes.add(5)
&gt;&gt;&gt; small_primes
{2, 3, 5}
&gt;&gt;&gt; small_primes.add(1)  # 1 is not a prime!
</span><span class="koboSpan" id="kobo.754.2">&gt;&gt;&gt; small_primes
{1, 2, 3, 5}
&gt;&gt;&gt; small_primes.remove(1)  # so let us remove it
&gt;&gt;&gt; 3 in small_primes  # membership test
True
&gt;&gt;&gt; 4 in small_primes
False
&gt;&gt;&gt; 4 not in small_primes  # negated membership test
True
&gt;&gt;&gt; small_primes.add(3)  # trying to add 3 again
&gt;&gt;&gt; small_primes
{2, 3, 5}  # no change, duplication is not allowed
&gt;&gt;&gt; bigger_primes = set([5, 7, 11, 13])  # faster creation
&gt;&gt;&gt; small_primes | bigger_primes  # union operator `|`
{2, 3, 5, 7, 11, 13}
&gt;&gt;&gt; small_primes &amp; bigger_primes  # intersection operator `&amp;`
{5}
&gt;&gt;&gt; small_primes - bigger_primes  # difference operator `-`
{2, 3}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.755.1">
     In the preceding code, you can see two ways to create a set.
    </span>
    <span class="koboSpan" id="kobo.755.2">
     One creates an empty set and then adds
    </span>
    <a id="_idIndexMarker224">
    </a>
    <span class="koboSpan" id="kobo.756.1">
     elements one at
    </span>
    <a id="_idIndexMarker225">
    </a>
    <span class="koboSpan" id="kobo.757.1">
     a time.
    </span>
    <span class="koboSpan" id="kobo.757.2">
     The other creates the set using a list of numbers as an argument to the constructor, which does all the work for us.
    </span>
    <span class="koboSpan" id="kobo.757.3">
     Of course, you can create a set from a list or tuple (or any iterable) and then you can add and remove members from the set as you please.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.758.1">
      We will look at
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.759.1">
       iterable
      </span>
     </strong>
     <span class="koboSpan" id="kobo.760.1">
      objects and iteration in the next chapter.
     </span>
     <span class="koboSpan" id="kobo.760.2">
      For now, just know that iterable objects are objects you can iterate on in a direction.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.761.1">
     Another way of creating a set is by simply using the curly braces notation, like this:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.762.1">&gt;&gt;&gt; small_primes = {2, 3, 5, 5, 3}
&gt;&gt;&gt; small_primes
{2, 3, 5}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.763.1">
     Notice we added some duplication to emphasize that the resulting set will not have any.
    </span>
    <span class="koboSpan" id="kobo.763.2">
     Let us see an example using the immutable counterpart of the set type,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.764.1">
      frozenset
     </span>
    </code>
    <span class="koboSpan" id="kobo.765.1">
     :
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.766.1">&gt;&gt;&gt; small_primes = frozenset([2, 3, 5, 7])
&gt;&gt;&gt; bigger_primes = frozenset([5, 7, 11])
&gt;&gt;&gt; small_primes.add(11)  # we cannot add to a frozenset
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'frozenset' object has no attribute 'add'
&gt;&gt;&gt; small_primes.remove(2)  # neither we can remove
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'frozenset' object has no attribute 'remove'
&gt;&gt;&gt; small_primes &amp; bigger_primes  # intersect, union, etc. </span><span class="koboSpan" id="kobo.766.2">allowed
frozenset({5, 7})
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.767.1">
     As you can see,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.768.1">
      frozenset
     </span>
    </code>
    <span class="koboSpan" id="kobo.769.1">
     objects are
    </span>
    <a id="_idIndexMarker226">
    </a>
    <span class="koboSpan" id="kobo.770.1">
     quite limited with respect to their mutable counterpart.
    </span>
    <span class="koboSpan" id="kobo.770.2">
     They still prove
    </span>
    <a id="_idIndexMarker227">
    </a>
    <span class="koboSpan" id="kobo.771.1">
     very effective for membership tests, union, intersection, and difference operations, and for performance reasons.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-74">
    <span class="koboSpan" id="kobo.772.1">
     Mapping types: dictionaries
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.773.1">
     Of all the built-in Python data types, the dictionary is easily the most interesting.
    </span>
    <span class="koboSpan" id="kobo.773.2">
     It is the only standard mapping type, and it is the backbone of every Python object.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.774.1">
     A dictionary maps keys to values.
    </span>
    <span class="koboSpan" id="kobo.774.2">
     Keys need to be hashable objects, while values can be of any arbitrary type.
    </span>
    <span class="koboSpan" id="kobo.774.3">
     Dictionaries
    </span>
    <a id="_idIndexMarker228">
    </a>
    <span class="koboSpan" id="kobo.775.1">
     are also mutable objects.
    </span>
    <span class="koboSpan" id="kobo.775.2">
     There are quite a few ways to create a dictionary, so let us give you a simple example of five ways to create a dictionary:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.776.1">&gt;&gt;&gt; a = dict(A=1, Z=-1)
&gt;&gt;&gt; b = {"A": 1, "Z": -1}
&gt;&gt;&gt; c = dict(zip(["A", "Z"], [1, -1]))
&gt;&gt;&gt; d = dict([("A", 1), ("Z", -1)])
&gt;&gt;&gt; e = dict({"Z": -1, "A": 1})
&gt;&gt;&gt; a == b == c == d == e  # are they all the same?
</span><span class="koboSpan" id="kobo.776.2">True  # They are indeed
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.777.1">
     All these dictionaries map the key
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.778.1">
      A
     </span>
    </code>
    <span class="koboSpan" id="kobo.779.1">
     to the value
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.780.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.781.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.782.1">
      Z
     </span>
    </code>
    <span class="koboSpan" id="kobo.783.1">
     to the value
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.784.1">
      -1
     </span>
    </code>
    <span class="koboSpan" id="kobo.785.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.786.1">
     Did you notice those double equals?
    </span>
    <span class="koboSpan" id="kobo.786.2">
     Assignment is done with one equal, while to check whether an object is the same as another one (or five in one go, in this case), we use double equals.
    </span>
    <span class="koboSpan" id="kobo.786.3">
     There is also another way to compare objects, which involves the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.787.1">
      is
     </span>
    </code>
    <span class="koboSpan" id="kobo.788.1">
     operator, and checks whether the two objects are the same (that is, that they have the same ID, not just the same value), but unless you have a good reason to use it, you should use the double equals instead.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.789.1">
     In the preceding code, we also used one nice function:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.790.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.791.1">
     .
    </span>
    <span class="koboSpan" id="kobo.791.2">
     It is named after the real-life zip, which glues together two parts, taking one element from each part at a time.
    </span>
    <span class="koboSpan" id="kobo.791.3">
     Let us show you an example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.792.1">&gt;&gt;&gt; list(zip(["h", "e", "l", "l", "o"], [1, 2, 3, 4, 5]))
[('h', 1), ('e', 2), ('l', 3), ('l', 4), ('o', 5)]
&gt;&gt;&gt; list(zip("hello", range(1, 6)))  # equivalent, more pythonic
[('h', 1), ('e', 2), ('l', 3), ('l', 4), ('o', 5)]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.793.1">
     In the preceding example, we have created the same list in two different ways, one more explicit, and the other a little bit more Pythonic.
    </span>
    <span class="koboSpan" id="kobo.793.2">
     Forget for a moment that we had to wrap the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.794.1">
      list()
     </span>
    </code>
    <span class="koboSpan" id="kobo.795.1">
     constructor around the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.796.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.797.1">
     call (the reason is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.798.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.799.1">
     returns an iterator, not a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.800.1">
      list
     </span>
    </code>
    <span class="koboSpan" id="kobo.801.1">
     , so if we want to see the result, we need to exhaust that iterator into something—a list in this case), and concentrate on the result.
    </span>
    <span class="koboSpan" id="kobo.801.2">
     See how
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.802.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.803.1">
     has coupled the first elements of its two arguments together, then the second ones, then the third ones, and so on?
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.804.1">
     Take a look at the zip of a
    </span>
    <a id="_idIndexMarker229">
    </a>
    <span class="koboSpan" id="kobo.805.1">
     suitcase, a purse, or the cover of a pillow, and you will see it works exactly like the one in Python.
    </span>
    <span class="koboSpan" id="kobo.805.2">
     But let us go back to dictionaries and see how many useful methods they expose for allowing us to manipulate them as we want.
    </span>
    <span class="koboSpan" id="kobo.805.3">
     Let us start with the basic operations:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.806.1">&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d["a"] = 1  # let us set a couple of (key, value) pairs
&gt;&gt;&gt; d["b"] = 2
&gt;&gt;&gt; len(d)  # how many pairs?
</span><span class="koboSpan" id="kobo.806.2">2
&gt;&gt;&gt; d["a"]  # what is the value of "a"?
</span><span class="koboSpan" id="kobo.806.3">1
&gt;&gt;&gt; d  # how does `d` look now?
</span><span class="koboSpan" id="kobo.806.4">{'a': 1, 'b': 2}
&gt;&gt;&gt; del d["a"]  # let us remove `a`
&gt;&gt;&gt; d
{'b': 2}
&gt;&gt;&gt; d["c"] = 3  # let us add "c": 3
&gt;&gt;&gt; "c" in d  # membership is checked against the keys
True
&gt;&gt;&gt; 3 in d  # not the values
False
&gt;&gt;&gt; "e" in d
False
&gt;&gt;&gt; d.clear()  # let us clean everything from this dictionary
&gt;&gt;&gt; d
{}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.807.1">
     Notice how accessing keys of a dictionary, regardless of the type of operation we are performing, is done using square brackets.
    </span>
    <span class="koboSpan" id="kobo.807.2">
     Do you remember strings, lists, and tuples?
    </span>
    <span class="koboSpan" id="kobo.807.3">
     We were accessing elements at some position through square brackets as well, which is yet another example of Python’s consistency.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.808.1">
     Let us now look at three special objects
    </span>
    <a id="_idIndexMarker230">
    </a>
    <span class="koboSpan" id="kobo.809.1">
     called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.810.1">
      dictionary views
     </span>
    </strong>
    <span class="koboSpan" id="kobo.811.1">
     :
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.812.1">
      keys
     </span>
    </code>
    <span class="koboSpan" id="kobo.813.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.814.1">
      values
     </span>
    </code>
    <span class="koboSpan" id="kobo.815.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.816.1">
      items
     </span>
    </code>
    <span class="koboSpan" id="kobo.817.1">
     .
    </span>
    <span class="koboSpan" id="kobo.817.2">
     These objects provide a dynamic view of the dictionary entries.
    </span>
    <span class="koboSpan" id="kobo.817.3">
     They change when the dictionary changes.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.818.1">
      keys()
     </span>
    </code>
    <span class="koboSpan" id="kobo.819.1">
     returns all the keys in the dictionary,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.820.1">
      values()
     </span>
    </code>
    <span class="koboSpan" id="kobo.821.1">
     returns all the values in the dictionary, and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.822.1">
      items()
     </span>
    </code>
    <span class="koboSpan" id="kobo.823.1">
     returns all the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.824.1">
      (key, value)
     </span>
    </em>
    <span class="koboSpan" id="kobo.825.1">
     pairs in the dictionary, as a list of 2-tuples.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.826.1">
     Let us exercise all this with some code:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.827.1">&gt;&gt;&gt; d = dict(zip("hello", range(5)))
&gt;&gt;&gt; d
{'h': 0, 'e': 1, 'l': 3, 'o': 4}
&gt;&gt;&gt; d.keys()
dict_keys(['h', 'e', 'l', 'o'])
&gt;&gt;&gt; d.values()
dict_values([0, 1, 3, 4])
&gt;&gt;&gt; d.items()
dict_items([('h', 0), ('e', 1), ('l', 3), ('o', 4)])
&gt;&gt;&gt; 3 in d.values()
True
&gt;&gt;&gt; ("o", 4) in d.items()
True
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.828.1">
     There are a few
    </span>
    <a id="_idIndexMarker231">
    </a>
    <span class="koboSpan" id="kobo.829.1">
     things to note here.
    </span>
    <span class="koboSpan" id="kobo.829.2">
     First, notice how we are creating a dictionary by iterating over the zipped version of the string
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.830.1">
      'hello'
     </span>
    </code>
    <span class="koboSpan" id="kobo.831.1">
     and the numbers
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.832.1">
      0, 1, 2, 3, 4
     </span>
    </code>
    <span class="koboSpan" id="kobo.833.1">
     .
    </span>
    <span class="koboSpan" id="kobo.833.2">
     The string
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.834.1">
      'hello'
     </span>
    </code>
    <span class="koboSpan" id="kobo.835.1">
     has two
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.836.1">
      'l'
     </span>
    </code>
    <span class="koboSpan" id="kobo.837.1">
     characters inside, and they are paired up with the values 2 and 3 by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.838.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.839.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.839.2">
     Notice how in the dictionary, the second occurrence of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.840.1">
      'l'
     </span>
    </code>
    <span class="koboSpan" id="kobo.841.1">
     key (the one with the value 3), overwrites the first one (the one with the value 2).
    </span>
    <span class="koboSpan" id="kobo.841.2">
     This is because every key in a dictionary must be unique.
    </span>
    <span class="koboSpan" id="kobo.841.3">
     Another thing to notice is that when asking for any view, the original order in which items were added is preserved.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.842.1">
     We will see how these views are fundamental tools when we discuss iterating over collections.
    </span>
    <span class="koboSpan" id="kobo.842.2">
     For now, let us look at some other useful methods exposed by Python’s dictionaries:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.843.1">&gt;&gt;&gt; d
{'h': 0, 'e': 1, 'l': 3, 'o': 4}
&gt;&gt;&gt; d.popitem()  # removes the last item added
('o', 4)
&gt;&gt;&gt; d
{'h': 0, 'e': 1, 'l': 3}
&gt;&gt;&gt; d.pop("l")  # remove item with key `l`
3
&gt;&gt;&gt; d.pop("not-a-key")  # remove a key not in dictionary: KeyError
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'not-a-key'
&gt;&gt;&gt; d.pop("not-a-key", "default-value")  # with a default value?
</span><span class="koboSpan" id="kobo.843.2">'default-value'  # we get the default value
&gt;&gt;&gt; d.update({"another": "value"})  # we can update dict this way
&gt;&gt;&gt; d.update(a=13)  # or this way (like a function call)
&gt;&gt;&gt; d
{'h': 0, 'e': 1, 'another': 'value', 'a': 13}
&gt;&gt;&gt; d.get("a")  # same as d['a'] but if key is missing no KeyError
13
&gt;&gt;&gt; d.get("a", 177)  # default value used if key is missing
13
&gt;&gt;&gt; d.get("b", 177)  # like in this case
177
&gt;&gt;&gt; d.get("b")  # key is not there, so None is returned
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.844.1">
     All these methods are quite
    </span>
    <a id="_idIndexMarker232">
    </a>
    <span class="koboSpan" id="kobo.845.1">
     simple to understand, but it is worth talking about that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.846.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.847.1">
     for a moment.
    </span>
    <span class="koboSpan" id="kobo.847.2">
     Every function in Python returns
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.848.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.849.1">
     unless the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.850.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.851.1">
     statement is explicitly used to return something else.
    </span>
    <span class="koboSpan" id="kobo.851.2">
     We will see this in depth when we explore functions in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.852.1">
      Chapter 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.853.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.854.1">
      Functions, the Building Blocks of Code
     </span>
    </em>
    <span class="koboSpan" id="kobo.855.1">
     .
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.856.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.857.1">
     is frequently used to represent the absence of a value, and it is quite commonly used as a default value for arguments in function declarations.
    </span>
    <span class="koboSpan" id="kobo.857.2">
     Inexperienced coders may sometimes write functions that return either
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.858.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.859.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.860.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.861.1">
     .
    </span>
    <span class="koboSpan" id="kobo.861.2">
     Both
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.862.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.863.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.864.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.865.1">
     evaluate to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.866.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.867.1">
     in a Boolean context, so it may seem that there is not much difference between them.
    </span>
    <span class="koboSpan" id="kobo.867.2">
     But actually, we would argue that there is an important difference:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.868.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.869.1">
     means that we have information, and the information we have is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.870.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.871.1">
     .
    </span>
   </p>
   <p class="normal">
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.872.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.873.1">
     means
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.874.1">
      no information
     </span>
    </em>
    <span class="koboSpan" id="kobo.875.1">
     ; no information is very different from information that is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.876.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.877.1">
     .
    </span>
    <span class="koboSpan" id="kobo.877.2">
     In plain language, if you ask your mechanic
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.878.1">
      Is my car ready?
     </span>
    </em>
    <span class="koboSpan" id="kobo.879.1">
     , there is a big difference between the answer
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.880.1">
      No, it is not
     </span>
    </em>
    <span class="koboSpan" id="kobo.881.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.882.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.883.1">
     ) and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.884.1">
      I have no idea
     </span>
    </em>
    <span class="koboSpan" id="kobo.885.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.886.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.887.1">
     ).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.888.1">
     One last method we really like about dictionaries is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.889.1">
      setdefault()
     </span>
    </code>
    <span class="koboSpan" id="kobo.890.1">
     .
    </span>
    <span class="koboSpan" id="kobo.890.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.891.1">
      setdefault()
     </span>
    </code>
    <span class="koboSpan" id="kobo.892.1">
     method behaves like the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.893.1">
      get()
     </span>
    </code>
    <span class="koboSpan" id="kobo.894.1">
     one.
    </span>
    <span class="koboSpan" id="kobo.894.2">
     When called, it will also set the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.895.1">
      key/value
     </span>
    </code>
    <span class="koboSpan" id="kobo.896.1">
     pair into the dictionary.
    </span>
    <span class="koboSpan" id="kobo.896.2">
     Let us see an example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.897.1">&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d.setdefault("a", 1)  # "a" is missing, we get default value
1
&gt;&gt;&gt; d
{'a': 1}  # also, the key/value pair ("a", 1) has now been added
&gt;&gt;&gt; d.setdefault("a", 5)  # let us try to override the value
1
&gt;&gt;&gt; d
{'a': 1}  # no override, as expected
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.898.1">
     This brings us to the end of this tour of dictionaries.
    </span>
    <span class="koboSpan" id="kobo.898.2">
     Test your knowledge about them by trying to predict what
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.899.1">
      d
     </span>
    </code>
    <span class="koboSpan" id="kobo.900.1">
     looks like after this line:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.901.1">&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d.setdefault("a", {}).setdefault("b", []).append(1)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.902.1">
     Do not worry if it is not immediately obvious to you.
    </span>
    <span class="koboSpan" id="kobo.902.2">
     We just want to encourage you to experiment with dictionaries.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.903.1">
     Python 3.9 added a new union operator, available for
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.904.1">
      dict
     </span>
    </code>
    <span class="koboSpan" id="kobo.905.1">
     objects, which was introduced by
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.906.1">
      PEP 584
     </span>
    </strong>
    <span class="koboSpan" id="kobo.907.1">
     .
    </span>
    <span class="koboSpan" id="kobo.907.2">
     When it
    </span>
    <a id="_idIndexMarker233">
    </a>
    <span class="koboSpan" id="kobo.908.1">
     comes to applying union to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.909.1">
      dict
     </span>
    </code>
    <span class="koboSpan" id="kobo.910.1">
     objects, we need to remember that union for them is not commutative.
    </span>
    <span class="koboSpan" id="kobo.910.2">
     This becomes evident when the two
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.911.1">
      dict
     </span>
    </code>
    <span class="koboSpan" id="kobo.912.1">
     objects we are merging have one or more keys in common.
    </span>
    <span class="koboSpan" id="kobo.912.2">
     Check out this example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.913.1">&gt;&gt;&gt; d = {"a": "A", "b": "B"}
&gt;&gt;&gt; e = {"b": 8, "c": "C"}
&gt;&gt;&gt; d | e
{'a': 'A', 'b': 8, 'c': 'C'}
&gt;&gt;&gt; e | d
{'b': 'B', 'c': 'C', 'a': 'A'}
&gt;&gt;&gt; {**d, **e}
{'a': 'A', 'b': 8, 'c': 'C'}
&gt;&gt;&gt; {**e, **d}
{'b': 'B', 'c': 'C', 'a': 'A'}
&gt;&gt;&gt; d |= e
&gt;&gt;&gt; d
{'a': 'A', 'b': 8, 'c': 'C'}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.914.1">
     Here, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.915.1">
      dict
     </span>
    </code>
    <span class="koboSpan" id="kobo.916.1">
     objects
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.917.1">
      d
     </span>
    </code>
    <span class="koboSpan" id="kobo.918.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.919.1">
      e
     </span>
    </code>
    <span class="koboSpan" id="kobo.920.1">
     have the key
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.921.1">
      'b'
     </span>
    </code>
    <span class="koboSpan" id="kobo.922.1">
     in common.
    </span>
    <span class="koboSpan" id="kobo.922.2">
     In
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.923.1">
      d
     </span>
    </code>
    <span class="koboSpan" id="kobo.924.1">
     , the value associated with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.925.1">
      'b'
     </span>
    </code>
    <span class="koboSpan" id="kobo.926.1">
     is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.927.1">
      'B'
     </span>
    </code>
    <span class="koboSpan" id="kobo.928.1">
     ; whereas, in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.929.1">
      e
     </span>
    </code>
    <span class="koboSpan" id="kobo.930.1">
     , it is the number 8.
    </span>
    <span class="koboSpan" id="kobo.930.2">
     This means that when we merge the two, with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.931.1">
      e
     </span>
    </code>
    <span class="koboSpan" id="kobo.932.1">
     on the righthand side of the union operator,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.933.1">
      |
     </span>
    </code>
    <span class="koboSpan" id="kobo.934.1">
     , the value in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.935.1">
      e
     </span>
    </code>
    <span class="koboSpan" id="kobo.936.1">
     overrides the one in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.937.1">
      d
     </span>
    </code>
    <span class="koboSpan" id="kobo.938.1">
     .
    </span>
    <span class="koboSpan" id="kobo.938.2">
     The opposite happens, of course, when we swap the positions of those objects in relation to the union operator.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.939.1">
     In this example, you can also see how the
    </span>
    <a id="_idIndexMarker234">
    </a>
    <span class="koboSpan" id="kobo.940.1">
     union can be performed by using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.941.1">
      **
     </span>
    </code>
    <span class="koboSpan" id="kobo.942.1">
     operator to produce a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.943.1">
      dictionary unpacking
     </span>
    </strong>
    <span class="koboSpan" id="kobo.944.1">
     .
    </span>
    <span class="koboSpan" id="kobo.944.2">
     It is worth noting that union can also be performed as an augmented assignment operation (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.945.1">
      d |= e
     </span>
    </code>
    <span class="koboSpan" id="kobo.946.1">
     ), which works in place.
    </span>
    <span class="koboSpan" id="kobo.946.2">
     Please refer to PEP 584 for more information about this feature.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.947.1">
     This completes our tour of built-in data types.
    </span>
    <span class="koboSpan" id="kobo.947.2">
     Before we conclude this chapter, we want to take a brief look at other data types provided by the standard library.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-75">
    <span class="koboSpan" id="kobo.948.1">
     Data types
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.949.1">
     Python provides a variety of
    </span>
    <a id="_idIndexMarker235">
    </a>
    <span class="koboSpan" id="kobo.950.1">
     specialized data types, such as dates and times, container types, and enumerations.
    </span>
    <span class="koboSpan" id="kobo.950.2">
     There is a whole section in the Python standard library titled
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.951.1">
      Data Types
     </span>
    </em>
    <span class="koboSpan" id="kobo.952.1">
     , which deserves to be explored; it is filled with interesting and useful tools for every programmer’s needs.
    </span>
    <span class="koboSpan" id="kobo.952.2">
     You can find it here:
    </span>
    <a href="https://docs.python.org/3/library/datatypes.html">
     <span class="url">
      <span class="koboSpan" id="kobo.953.1">
       https://docs.python.org/3/library/datatypes.html
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.954.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.955.1">
     In this section, we will give you a brief introduction to dates and times, collections, and enumerations.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-76">
    <span class="koboSpan" id="kobo.956.1">
     Dates and times
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.957.1">
     The Python standard library provides several
    </span>
    <a id="_idIndexMarker236">
    </a>
    <span class="koboSpan" id="kobo.958.1">
     data types that can be used to deal with dates and times.
    </span>
    <span class="koboSpan" id="kobo.958.2">
     This may seem like a simple topic at first, but time zones, daylight saving time, leap years, and other quirks can easily trip up an unwary programmer.
    </span>
    <span class="koboSpan" id="kobo.958.3">
     There are also a huge number of ways to format and localize date and time information.
    </span>
    <span class="koboSpan" id="kobo.958.4">
     This, in turn, makes it challenging to parse dates and times.
    </span>
    <span class="koboSpan" id="kobo.958.5">
     This is probably why it is quite common for professional Python programmers to also rely on various third-party libraries to provide some much-needed extra power when working with dates and times.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-77">
    <span class="koboSpan" id="kobo.959.1">
     The standard library
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.960.1">
     We will start with the standard library
    </span>
    <a id="_idIndexMarker237">
    </a>
    <span class="koboSpan" id="kobo.961.1">
     and finish the session with a little overview of what is out there in terms of the third-party libraries you can use.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.962.1">
     From the standard library, the main modules that are used to handle dates and times are
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.963.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.964.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.965.1">
      calendar
     </span>
    </code>
    <span class="koboSpan" id="kobo.966.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.967.1">
      zoneinfo
     </span>
    </code>
    <span class="koboSpan" id="kobo.968.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.969.1">
      time
     </span>
    </code>
    <span class="koboSpan" id="kobo.970.1">
     .
    </span>
    <span class="koboSpan" id="kobo.970.2">
     Let us start with the imports you will need for this whole section:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.971.1">&gt;&gt;&gt; from datetime import date, datetime, timedelta, timezone, UTC
&gt;&gt;&gt; import time
&gt;&gt;&gt; import calendar as cal
&gt;&gt;&gt; from zoneinfo import ZoneInfo
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.972.1">
     The first example deals with dates.
    </span>
    <span class="koboSpan" id="kobo.972.2">
     Let us see how they look:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.973.1">&gt;&gt;&gt; today = date.today()
&gt;&gt;&gt; today
datetime.date(2024, 3, 19)
&gt;&gt;&gt; today.ctime()
'Tue Mar 19 00:00:00 2024'
&gt;&gt;&gt; today.isoformat()
'2024-03-19'
&gt;&gt;&gt; today.weekday()
1
&gt;&gt;&gt; cal.day_name[today.weekday()]
'Tuesday'
&gt;&gt;&gt; today.day, today.month, today.year
(19, 3, 2024)
&gt;&gt;&gt; today.timetuple()
time.struct_time(
    tm_year=2024, tm_mon=3, tm_mday=19,
    tm_hour=0, tm_min=0, tm_sec=0,
    tm_wday=1, tm_yday=79, tm_isdst=-1
)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.974.1">
     We start by fetching the date for today.
    </span>
    <span class="koboSpan" id="kobo.974.2">
     We can see that it is an instance of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.975.1">
      datetime.date
     </span>
    </code>
    <span class="koboSpan" id="kobo.976.1">
     class.
    </span>
    <span class="koboSpan" id="kobo.976.2">
     Then we get two different representations for it, following the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.977.1">
      C
     </span>
    </strong>
    <span class="koboSpan" id="kobo.978.1">
     and the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.979.1">
      ISO 8601
     </span>
    </strong>
    <span class="koboSpan" id="kobo.980.1">
     format standards, respectively.
    </span>
    <span class="koboSpan" id="kobo.980.2">
     After that, we ask what day of the week it is, and we get the number 1.
    </span>
    <span class="koboSpan" id="kobo.980.3">
     Days are numbered 0 to 6 (representing Monday to Sunday), so we grab the value of the sixth element in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.981.1">
      calendar.day_name
     </span>
    </code>
    <span class="koboSpan" id="kobo.982.1">
     (notice in the code that we have aliased
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.983.1">
      calendar
     </span>
    </code>
    <span class="koboSpan" id="kobo.984.1">
     with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.985.1">
      cal
     </span>
    </code>
    <span class="koboSpan" id="kobo.986.1">
     for brevity).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.987.1">
     The last two instructions
    </span>
    <a id="_idIndexMarker238">
    </a>
    <span class="koboSpan" id="kobo.988.1">
     show how to get detailed information out of a date object.
    </span>
    <span class="koboSpan" id="kobo.988.2">
     We can inspect its
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.989.1">
      day
     </span>
    </code>
    <span class="koboSpan" id="kobo.990.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.991.1">
      month
     </span>
    </code>
    <span class="koboSpan" id="kobo.992.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.993.1">
      year
     </span>
    </code>
    <span class="koboSpan" id="kobo.994.1">
     attributes, or call the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.995.1">
      timetuple()
     </span>
    </code>
    <span class="koboSpan" id="kobo.996.1">
     method and get a whole wealth of information.
    </span>
    <span class="koboSpan" id="kobo.996.2">
     Since we are dealing with a date object, notice that all the information about time has been set to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.997.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.998.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.999.1">
     Let us now play with time:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1000.1">&gt;&gt;&gt; time.ctime()
'Tue Mar 19 21:15:23 2024'
&gt;&gt;&gt; time.daylight
1
&gt;&gt;&gt; time.gmtime()
time.struct_time(
    tm_year=2024, tm_mon=3, tm_mday=19,
    tm_hour=21, tm_min=15, tm_sec=53,
    tm_wday=1, tm_yday=79, tm_isdst=0
)
&gt;&gt;&gt; time.gmtime(0)
time.struct_time(
    tm_year=1970, tm_mon=1, tm_mday=1,
    tm_hour=0, tm_min=0, tm_sec=0,
    tm_wday=3, tm_yday=1, tm_isdst=0
)
&gt;&gt;&gt; time.localtime()
time.struct_time(
    tm_year=2024, tm_mon=3, tm_mday=19,
    tm_hour=21, tm_min=16, tm_sec=6,
    tm_wday=1, tm_yday=79, tm_isdst=0
)
&gt;&gt;&gt; time.time()
1710882970.789991
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1001.1">
     This example is quite similar to the one before, only here, we are dealing with time.
    </span>
    <span class="koboSpan" id="kobo.1001.2">
     We can see how to get a printed representation of time according to the C format standard, and then how to check if daylight saving time is in effect.
    </span>
    <span class="koboSpan" id="kobo.1001.3">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1002.1">
      gmtime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1003.1">
     function converts a given number of seconds from the epoch to a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1004.1">
      struct_time
     </span>
    </code>
    <span class="koboSpan" id="kobo.1005.1">
     object in UTC.
    </span>
    <span class="koboSpan" id="kobo.1005.2">
     If we don’t feed it a number, it
    </span>
    <a id="_idIndexMarker239">
    </a>
    <span class="koboSpan" id="kobo.1006.1">
     will use the current time.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1007.1">
      The
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1008.1">
       epoch
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1009.1">
      is a date and time
     </span>
     <a id="_idIndexMarker240">
     </a>
     <span class="koboSpan" id="kobo.1010.1">
      from which a computer system measures system time.
     </span>
     <span class="koboSpan" id="kobo.1010.2">
      You can see that, on the machine used to run this code, the epoch is January 1
     </span>
     <sup class="superscript">
      <span class="koboSpan" id="kobo.1011.1">
       st
      </span>
     </sup>
     <span class="koboSpan" id="kobo.1012.1">
      , 1970.
     </span>
     <span class="koboSpan" id="kobo.1012.2">
      This is the point in time used by both Unix and POSIX.Coordinated Universal Time
     </span>
     <a id="_idIndexMarker241">
     </a>
     <span class="koboSpan" id="kobo.1013.1">
      or
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1014.1">
       UTC
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1015.1">
      is the primary time standard by which the world regulates clocks and time.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.1016.1">
     We finish the example by getting the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1017.1">
      struct_time
     </span>
    </code>
    <span class="koboSpan" id="kobo.1018.1">
     object for the current local time and the number of seconds from the epoch expressed as a float number (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1019.1">
      time.time()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1020.1">
     ).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1021.1">
     Let us now see an example using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1022.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1023.1">
     objects, which combine dates and times.
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1024.1">&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; utcnow = datetime.now(UTC)
&gt;&gt;&gt; now
datetime.datetime(2024, 3, 19, 21, 16, 56, 931429)
&gt;&gt;&gt; utcnow
datetime.datetime(
    2024, 3, 19, 21, 17, 53, 241072,
    tzinfo=datetime.timezone.utc
)
&gt;&gt;&gt; now.date()
datetime.date(2024, 3, 19)
&gt;&gt;&gt; now.day, now.month, now.year
(19, 3, 2024)
&gt;&gt;&gt; now.date() == date.today()
True
&gt;&gt;&gt; now.time()
datetime.time(21, 16, 56, 931429)
&gt;&gt;&gt; now.hour, now.minute, now.second, now.microsecond
(21, 16, 56, 931429)
&gt;&gt;&gt; now.ctime()
'Tue Mar 19 21:16:56 2024'
&gt;&gt;&gt; now.isoformat()
'2024-03-19T21:16:56.931429'
&gt;&gt;&gt; now.timetuple()
time.struct_time(
    tm_year=2024, tm_mon=3, tm_mday=19,
    tm_hour=21, tm_min=16, tm_sec=56,
    tm_wday=1, tm_yday=79, tm_isdst=-1
)
&gt;&gt;&gt; now.tzinfo
&gt;&gt;&gt; utcnow.tzinfo
datetime.timezone.utc
&gt;&gt;&gt; now.weekday()
1
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1025.1">
     The preceding example is rather self-explanatory.
    </span>
    <span class="koboSpan" id="kobo.1025.2">
     We start by setting up two instances that represent the current time.
    </span>
    <span class="koboSpan" id="kobo.1025.3">
     One is related to UTC (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1026.1">
      utcnow
     </span>
    </code>
    <span class="koboSpan" id="kobo.1027.1">
     ), and the other one is a local representation (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1028.1">
      now
     </span>
    </code>
    <span class="koboSpan" id="kobo.1029.1">
     ).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1030.1">
     You can get
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1031.1">
      date
     </span>
    </code>
    <span class="koboSpan" id="kobo.1032.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1033.1">
      time
     </span>
    </code>
    <span class="koboSpan" id="kobo.1034.1">
     , and
    </span>
    <a id="_idIndexMarker242">
    </a>
    <span class="koboSpan" id="kobo.1035.1">
     specific attributes from a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1036.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1037.1">
     object in a similar way to what we have already seen.
    </span>
    <span class="koboSpan" id="kobo.1037.2">
     It is also worth noting that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1038.1">
      now
     </span>
    </code>
    <span class="koboSpan" id="kobo.1039.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1040.1">
      utcnow
     </span>
    </code>
    <span class="koboSpan" id="kobo.1041.1">
     have different values for the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1042.1">
      tzinfo
     </span>
    </code>
    <span class="koboSpan" id="kobo.1043.1">
     attribute.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1044.1">
      now
     </span>
    </code>
    <span class="koboSpan" id="kobo.1045.1">
     is a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1046.1">
      naïve
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1047.1">
     object, while
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1048.1">
      utcnow
     </span>
    </code>
    <span class="koboSpan" id="kobo.1049.1">
     is not.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1050.1">
      Date and time objects may be categorized as
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1051.1">
       aware
      </span>
     </em>
     <span class="koboSpan" id="kobo.1052.1">
      if they include time zone information, or
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1053.1">
       naïve
      </span>
     </em>
     <span class="koboSpan" id="kobo.1054.1">
      if they don’t.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.1055.1">
     Let us now see how a duration is represented in this context:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1056.1">&gt;&gt;&gt; f_bday = datetime(
    1975, 12, 29, 12, 50, tzinfo=ZoneInfo('Europe/Rome')
)
&gt;&gt;&gt; h_bday = datetime(
    1981, 10, 7, 15, 30, 50, tzinfo=timezone(timedelta(hours=2))
)
&gt;&gt;&gt; diff = h_bday - f_bday
&gt;&gt;&gt; type(diff)
&lt;class 'datetime.timedelta'&gt;
&gt;&gt;&gt; diff.days
2109
&gt;&gt;&gt; diff.total_seconds()
182223650.0
&gt;&gt;&gt; today + timedelta(days=49)
datetime.date(2024, 5, 7)
&gt;&gt;&gt; now + timedelta(weeks=7)
datetime.datetime(2024, 5, 7, 21, 16, 56, 931429)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1057.1">
     Two objects have been created that represent Fabrizio and Heinrich’s birthdays.
    </span>
    <span class="koboSpan" id="kobo.1057.2">
     This time, in order to show you an alternative, we have created
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1058.1">
      aware
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1059.1">
     objects.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1060.1">
     There are several ways to include time zone information when creating a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1061.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1062.1">
     object, and in this example, we are showing you two of them.
    </span>
    <span class="koboSpan" id="kobo.1062.2">
     One uses the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1063.1">
      ZoneInfo
     </span>
    </code>
    <span class="koboSpan" id="kobo.1064.1">
     object from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1065.1">
      zoneinfo
     </span>
    </code>
    <span class="koboSpan" id="kobo.1066.1">
     module, introduced in Python 3.9.
    </span>
    <span class="koboSpan" id="kobo.1066.2">
     The second one uses a simple
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1067.1">
      timedelta
     </span>
    </code>
    <span class="koboSpan" id="kobo.1068.1">
     , an object that represents a duration.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1069.1">
     We then create the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1070.1">
      diff
     </span>
    </code>
    <span class="koboSpan" id="kobo.1071.1">
     object, which
    </span>
    <a id="_idIndexMarker243">
    </a>
    <span class="koboSpan" id="kobo.1072.1">
     is assigned as the subtraction of them.
    </span>
    <span class="koboSpan" id="kobo.1072.2">
     The result of that operation is an instance of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1073.1">
      timedelta
     </span>
    </code>
    <span class="koboSpan" id="kobo.1074.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1074.2">
     You can see how we can interrogate the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1075.1">
      diff
     </span>
    </code>
    <span class="koboSpan" id="kobo.1076.1">
     object to tell us how many days Fabrizio and Heinrich’s birthdays are apart, and even the number of seconds that represent that whole duration.
    </span>
    <span class="koboSpan" id="kobo.1076.2">
     Notice that we need to use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1077.1">
      total_seconds()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1078.1">
     , which expresses the whole duration in seconds.
    </span>
    <span class="koboSpan" id="kobo.1078.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1079.1">
      seconds
     </span>
    </code>
    <span class="koboSpan" id="kobo.1080.1">
     attribute represents the number of seconds assigned to that duration.
    </span>
    <span class="koboSpan" id="kobo.1080.2">
     So, a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1081.1">
      timedelta(days=1)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1082.1">
     will have seconds equal to 0 and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1083.1">
      total_seconds()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1084.1">
     equal to 86,400 (which is the number of seconds in a day).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1085.1">
     Combining a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1086.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1087.1">
     with a duration adds or subtracts that duration from the original date and time information.
    </span>
    <span class="koboSpan" id="kobo.1087.2">
     In the last few lines of the example, we can see how adding a duration to a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1088.1">
      date
     </span>
    </code>
    <span class="koboSpan" id="kobo.1089.1">
     object produces a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1090.1">
      date
     </span>
    </code>
    <span class="koboSpan" id="kobo.1091.1">
     as a result, whereas adding it to a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1092.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1093.1">
     produces a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1094.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1095.1">
     , as it is fair to expect.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1096.1">
     One of the more difficult undertakings to carry out using dates and times is parsing.
    </span>
    <span class="koboSpan" id="kobo.1096.2">
     Let us see a short example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1097.1">&gt;&gt;&gt; datetime.fromisoformat('1977-11-24T19:30:13+01:00')
datetime.datetime(
    1977, 11, 24, 19, 30, 13,
    tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))
)
&gt;&gt;&gt; datetime.fromtimestamp(time.time())
datetime.datetime(2024, 3, 19, 21, 26, 56, 785166)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1098.1">
     We can easily
    </span>
    <a id="_idIndexMarker244">
    </a>
    <span class="koboSpan" id="kobo.1099.1">
     create
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1100.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1101.1">
     objects from ISO-formatted strings, as well as from timestamps.
    </span>
    <span class="koboSpan" id="kobo.1101.2">
     However, in general, parsing a date from unknown formats can prove to be a difficult task.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-78">
    <span class="koboSpan" id="kobo.1102.1">
     Third-party libraries
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1103.1">
     To finish off this subsection, we would like to
    </span>
    <a id="_idIndexMarker245">
    </a>
    <span class="koboSpan" id="kobo.1104.1">
     mention a few third-party libraries that you will very likely come across when dealing with dates and times in your code:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1105.1">
       dateutil
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1106.1">
      : Powerful
     </span>
     <a id="_idIndexMarker246">
     </a>
     <span class="koboSpan" id="kobo.1107.1">
      extensions to
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1108.1">
       datetime
      </span>
     </code>
     <span class="koboSpan" id="kobo.1109.1">
      (
     </span>
     <a href="https://dateutil.readthedocs.io/">
      <span class="url">
       <span class="koboSpan" id="kobo.1110.1">
        https://dateutil.readthedocs.io/
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1111.1">
      )
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1112.1">
       Arrow
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1113.1">
      : Better dates and
     </span>
     <a id="_idIndexMarker247">
     </a>
     <span class="koboSpan" id="kobo.1114.1">
      times for Python (
     </span>
     <a href="https://arrow.readthedocs.io/">
      <span class="url">
       <span class="koboSpan" id="kobo.1115.1">
        https://arrow.readthedocs.io/
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1116.1">
      )
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1117.1">
       Pendulum
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1118.1">
      : Python
     </span>
     <a id="_idIndexMarker248">
     </a>
     <span class="koboSpan" id="kobo.1119.1">
      datetimes made easy (
     </span>
     <a href="https://pendulum.eustace.io/">
      <span class="url">
       <span class="koboSpan" id="kobo.1120.1">
        https://pendulum.eustace.io/
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1121.1">
      )
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1122.1">
       Maya
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1123.1">
      : Datetimes
     </span>
     <a id="_idIndexMarker249">
     </a>
     <span class="koboSpan" id="kobo.1124.1">
      for humans
     </span>
     <sup class="superscript">
      <span class="koboSpan" id="kobo.1125.1">
       TM
      </span>
     </sup>
     <span class="koboSpan" id="kobo.1126.1">
      (
     </span>
     <a href="https://github.com/kennethreitz/maya">
      <span class="url">
       <span class="koboSpan" id="kobo.1127.1">
        https://github.com/kennethreitz/maya
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1128.1">
      )
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1129.1">
       Delorean
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1130.1">
      : Time
     </span>
     <a id="_idIndexMarker250">
     </a>
     <span class="koboSpan" id="kobo.1131.1">
      Travel Made Easy (
     </span>
     <a href="https://delorean.readthedocs.io/">
      <span class="url">
       <span class="koboSpan" id="kobo.1132.1">
        https://delorean.readthedocs.io/
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1133.1">
      )
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1134.1">
       pytz
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1135.1">
      : World time
     </span>
     <a id="_idIndexMarker251">
     </a>
     <span class="koboSpan" id="kobo.1136.1">
      zone definitions for Python (
     </span>
     <a href="https://pythonhosted.org/pytz/">
      <span class="url">
       <span class="koboSpan" id="kobo.1137.1">
        https://pythonhosted.org/pytz/
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1138.1">
      )
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.1139.1">
     These are some of the most common, and they are worth exploring.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1140.1">
     Let us take a look at one final example, this time using the Arrow third-party library:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1141.1">&gt;&gt;&gt; import arrow
&gt;&gt;&gt; arrow.utcnow()
&lt;Arrow [2024-03-19T21:29:15.076737+00:00]&gt;
&gt;&gt;&gt; arrow.now()
&lt;Arrow [2024-03-19T21:29:26.354786+00:00]&gt;
&gt;&gt;&gt; local = arrow.now("Europe/Rome")
&gt;&gt;&gt; local
&lt;Arrow [2024-03-19T22:29:40.282730+01:00]&gt;
&gt;&gt;&gt; local.to("utc")
&lt;Arrow [2024-03-19T21:29:40.282730+00:00]&gt;
&gt;&gt;&gt; local.to("Europe/Moscow")
&lt;Arrow [2024-03-20T00:29:40.282730+03:00]&gt;
&gt;&gt;&gt; local.to("Asia/Tokyo")
&lt;Arrow [2024-03-20T06:29:40.282730+09:00]&gt;
&gt;&gt;&gt; local.datetime
datetime.datetime(
    2024, 3, 19, 22, 29, 40, 282730,
    tzinfo=tzfile('/usr/share/zoneinfo/Europe/Rome')
)
&gt;&gt;&gt; local.isoformat()
'2024-03-19T22:29:40.282730+01:00'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1142.1">
     Arrow
    </span>
    <a id="_idIndexMarker252">
    </a>
    <span class="koboSpan" id="kobo.1143.1">
     provides a wrapper
    </span>
    <a id="_idIndexMarker253">
    </a>
    <span class="koboSpan" id="kobo.1144.1">
     around the data structures of the standard library, plus a whole set of methods and helpers that simplify the task of dealing with dates and times.
    </span>
    <span class="koboSpan" id="kobo.1144.2">
     You can see from this example how easy it is to get the local date and time in the Italian time zone (
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1145.1">
      Europe/Rome
     </span>
    </em>
    <span class="koboSpan" id="kobo.1146.1">
     ), as well as to convert it to UTC, or to the Russian or Japanese time zones.
    </span>
    <span class="koboSpan" id="kobo.1146.2">
     The last two instructions show how you can get the underlying
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1147.1">
      datetime
     </span>
    </code>
    <span class="koboSpan" id="kobo.1148.1">
     object from an Arrow one, and the very useful ISO-formatted representation of a date and time.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-79">
    <span class="koboSpan" id="kobo.1149.1">
     The collections module
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1150.1">
     When Python
    </span>
    <a id="_idIndexMarker254">
    </a>
    <span class="koboSpan" id="kobo.1151.1">
     general-purpose built-in containers (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1152.1">
      tuple
     </span>
    </code>
    <span class="koboSpan" id="kobo.1153.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1154.1">
      list
     </span>
    </code>
    <span class="koboSpan" id="kobo.1155.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1156.1">
      set
     </span>
    </code>
    <span class="koboSpan" id="kobo.1157.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1158.1">
      dict
     </span>
    </code>
    <span class="koboSpan" id="kobo.1159.1">
     ) aren’t enough, we can find specialized container data types in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1160.1">
      collections
     </span>
    </code>
    <span class="koboSpan" id="kobo.1161.1">
     module.
    </span>
    <span class="koboSpan" id="kobo.1161.2">
     They are described in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1162.1">
      Table 2.1
     </span>
    </em>
    <span class="koboSpan" id="kobo.1163.1">
     .
    </span>
   </p>
   <table class="table-container" id="table001">
    <tbody>
     <tr>
      <td class="table-cell">
       <p class="normal">
        <strong class="keyWord">
         <span class="koboSpan" id="kobo.1164.1">
          Data type
         </span>
        </strong>
       </p>
      </td>
      <td class="table-cell">
       <p class="normal">
        <strong class="keyWord">
         <span class="koboSpan" id="kobo.1165.1">
          Description
         </span>
        </strong>
       </p>
      </td>
     </tr>
     <tr>
      <td class="table-cell">
       <p class="normal">
        <code class="inlineCode">
         <span class="koboSpan" id="kobo.1166.1">
          namedtuple()
         </span>
        </code>
       </p>
      </td>
      <td class="table-cell">
       <p class="normal">
        <span class="koboSpan" id="kobo.1167.1">
         Factory function for creating tuple subclasses with named fields
        </span>
       </p>
      </td>
     </tr>
     <tr>
      <td class="table-cell">
       <p class="normal">
        <code class="inlineCode">
         <span class="koboSpan" id="kobo.1168.1">
          deque
         </span>
        </code>
       </p>
      </td>
      <td class="table-cell">
       <p class="normal">
        <span class="koboSpan" id="kobo.1169.1">
         List-like container with fast appends and pops on either end
        </span>
       </p>
      </td>
     </tr>
     <tr>
      <td class="table-cell">
       <p class="normal">
        <code class="inlineCode">
         <span class="koboSpan" id="kobo.1170.1">
          ChainMap
         </span>
        </code>
       </p>
      </td>
      <td class="table-cell">
       <p class="normal">
        <span class="koboSpan" id="kobo.1171.1">
         Dictionary-like class for creating a single view of multiple mappings
        </span>
       </p>
      </td>
     </tr>
     <tr>
      <td class="table-cell">
       <p class="normal">
        <code class="inlineCode">
         <span class="koboSpan" id="kobo.1172.1">
          Counter
         </span>
        </code>
       </p>
      </td>
      <td class="table-cell">
       <p class="normal">
        <span class="koboSpan" id="kobo.1173.1">
         Dictionary subclass for counting hashable objects
        </span>
       </p>
      </td>
     </tr>
     <tr>
      <td class="table-cell">
       <p class="normal">
        <code class="inlineCode">
         <span class="koboSpan" id="kobo.1174.1">
          OrderedDict
         </span>
        </code>
       </p>
      </td>
      <td class="table-cell">
       <p class="normal">
        <span class="koboSpan" id="kobo.1175.1">
         Dictionary subclass with methods that allow for re-ordering entries
        </span>
       </p>
      </td>
     </tr>
     <tr>
      <td class="table-cell">
       <p class="normal">
        <code class="inlineCode">
         <span class="koboSpan" id="kobo.1176.1">
          defaultdict
         </span>
        </code>
       </p>
      </td>
      <td class="table-cell">
       <p class="normal">
        <span class="koboSpan" id="kobo.1177.1">
         Dictionary subclass that calls a factory function to supply missing values
        </span>
       </p>
      </td>
     </tr>
     <tr>
      <td class="table-cell">
       <p class="normal">
        <code class="inlineCode">
         <span class="koboSpan" id="kobo.1178.1">
          UserDict
         </span>
        </code>
       </p>
      </td>
      <td class="table-cell">
       <p class="normal">
        <span class="koboSpan" id="kobo.1179.1">
         Wrapper around dictionary objects for easier dictionary subclassing
        </span>
       </p>
      </td>
     </tr>
     <tr>
      <td class="table-cell">
       <p class="normal">
        <code class="inlineCode">
         <span class="koboSpan" id="kobo.1180.1">
          UserList
         </span>
        </code>
       </p>
      </td>
      <td class="table-cell">
       <p class="normal">
        <span class="koboSpan" id="kobo.1181.1">
         Wrapper around list objects for easier list subclassing
        </span>
       </p>
      </td>
     </tr>
     <tr>
      <td class="table-cell">
       <p class="normal">
        <code class="inlineCode">
         <span class="koboSpan" id="kobo.1182.1">
          UserString
         </span>
        </code>
       </p>
      </td>
      <td class="table-cell">
       <p class="normal">
        <span class="koboSpan" id="kobo.1183.1">
         Wrapper around string objects for easier string subclassing
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.1184.1">
     Table 2.1: Collections module data types
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1185.1">
     There is not
    </span>
    <a id="_idIndexMarker255">
    </a>
    <span class="koboSpan" id="kobo.1186.1">
     enough space here to cover them all, but you can find plenty of examples in the official documentation; here, we will just give a small example to show you
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1187.1">
      namedtuple
     </span>
    </code>
    <span class="koboSpan" id="kobo.1188.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1189.1">
      defaultdict
     </span>
    </code>
    <span class="koboSpan" id="kobo.1190.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1191.1">
      ChainMap
     </span>
    </code>
    <span class="koboSpan" id="kobo.1192.1">
     .
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-80">
    <span class="koboSpan" id="kobo.1193.1">
     namedtuple
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1194.1">
     A
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1195.1">
      namedtuple
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1196.1">
     is a tuple-like
    </span>
    <a id="_idIndexMarker256">
    </a>
    <span class="koboSpan" id="kobo.1197.1">
     object that has fields accessible by attribute lookup, as
    </span>
    <a id="_idIndexMarker257">
    </a>
    <span class="koboSpan" id="kobo.1198.1">
     well as being indexable and iterable (it is actually a subclass of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1199.1">
      tuple
     </span>
    </code>
    <span class="koboSpan" id="kobo.1200.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1200.2">
     This is a compromise between a fully-fledged object and a tuple, and it can be useful in those cases where you do not need the full power of a custom object but only want your code to be more readable by avoiding positional indexing.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1201.1">
     Another use case is when there is a chance that items in the tuple will need to change their position after refactoring, forcing the programmer to also refactor all the logic involved, which can be tricky.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1202.1">
     For example, say we are handling data about the left and right eyes of a patient.
    </span>
    <span class="koboSpan" id="kobo.1202.2">
     We save one value for the left eye (position 0) and one for the right eye (position 1) in a regular tuple.
    </span>
    <span class="koboSpan" id="kobo.1202.3">
     Here is how that may look:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1203.1">&gt;&gt;&gt; vision = (9.5, 8.8)
&gt;&gt;&gt; vision
(9.5, 8.8)
&gt;&gt;&gt; vision[0]  # left eye (implicit positional reference)
9.5
&gt;&gt;&gt; vision[1]  # right eye (implicit positional reference)
8.8
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1204.1">
     Now let us pretend we handle
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1205.1">
      vision
     </span>
    </code>
    <span class="koboSpan" id="kobo.1206.1">
     objects all of the time, and, at some point, the designer decides to enhance them by adding information for the combined vision, so that a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1207.1">
      vision
     </span>
    </code>
    <span class="koboSpan" id="kobo.1208.1">
     object stores data in this format
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1209.1">
      (left eye, combined, right eye)
     </span>
    </em>
    <span class="koboSpan" id="kobo.1210.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1211.1">
     Do you see the trouble we’re in now?
    </span>
    <span class="koboSpan" id="kobo.1211.2">
     We may have a lot of code that depends on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1212.1">
      vision[0]
     </span>
    </code>
    <span class="koboSpan" id="kobo.1213.1">
     being the left eye information (which it still is) and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1214.1">
      vision[1]
     </span>
    </code>
    <span class="koboSpan" id="kobo.1215.1">
     being the right eye information (which is no longer the case).
    </span>
    <span class="koboSpan" id="kobo.1215.2">
     We have to refactor our code wherever we handle these objects, changing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1216.1">
      vision[1]
     </span>
    </code>
    <span class="koboSpan" id="kobo.1217.1">
     to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1218.1">
      vision[2]
     </span>
    </code>
    <span class="koboSpan" id="kobo.1219.1">
     , and that can be painful.
    </span>
    <span class="koboSpan" id="kobo.1219.2">
     We could have probably approached this a bit better from the beginning, by using a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1220.1">
      namedtuple
     </span>
    </code>
    <span class="koboSpan" id="kobo.1221.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1221.2">
     Let us show you what we mean:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1222.1">&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Vision = namedtuple('Vision', ['left', 'right'])
&gt;&gt;&gt; vision = Vision(9.5, 8.8)
&gt;&gt;&gt; vision[0]
9.5
&gt;&gt;&gt; vision.left  # same as vision[0], but explicit
9.5
&gt;&gt;&gt; vision.right  # same as vision[1], but explicit
8.8
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1223.1">
     If, within our code, we refer to the left and right eyes using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1224.1">
      vision.left
     </span>
    </code>
    <span class="koboSpan" id="kobo.1225.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1226.1">
      vision.right
     </span>
    </code>
    <span class="koboSpan" id="kobo.1227.1">
     , all we need to do to fix the new design issue is change our factory and the way we create instances—the rest of the code won’t need to change:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1228.1">&gt;&gt;&gt; Vision = namedtuple('Vision', ['left', 'combined', 'right'])
&gt;&gt;&gt; vision = Vision(9.5, 9.2, 8.8)
&gt;&gt;&gt; vision.left  # still correct
9.5
&gt;&gt;&gt; vision.right  # still correct (though now is vision[2])
8.8
&gt;&gt;&gt; vision.combined  # the new vision[1]
9.2
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1229.1">
     You can see how
    </span>
    <a id="_idIndexMarker258">
    </a>
    <span class="koboSpan" id="kobo.1230.1">
     convenient it is to refer to those values by name rather than by position.
    </span>
    <span class="koboSpan" id="kobo.1230.2">
     After all, as a wise man once wrote,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1231.1">
      Explicit is better than implicit
     </span>
    </em>
    <span class="koboSpan" id="kobo.1232.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1232.2">
     This
    </span>
    <a id="_idIndexMarker259">
    </a>
    <span class="koboSpan" id="kobo.1233.1">
     example may be a little extreme; of course, it is not likely that a decent programmer would choose to represent data in a simple tuple in the first place, but you’d be amazed to know how frequently issues similar to this one occur in a professional environment, and how complicated it is to refactor in such cases.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-81">
    <span class="koboSpan" id="kobo.1234.1">
     defaultdict
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1235.1">
     The
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1236.1">
      defaultdict
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1237.1">
     data type is one of
    </span>
    <a id="_idIndexMarker260">
    </a>
    <span class="koboSpan" id="kobo.1238.1">
     our favorites.
    </span>
    <span class="koboSpan" id="kobo.1238.2">
     It allows you to avoid checking whether a key is in a
    </span>
    <a id="_idIndexMarker261">
    </a>
    <span class="koboSpan" id="kobo.1239.1">
     dictionary by simply inserting it for you on your first access attempt, with a default value whose type you pass on creation.
    </span>
    <span class="koboSpan" id="kobo.1239.2">
     In some cases, this tool can be very handy and shorten your code a little.
    </span>
    <span class="koboSpan" id="kobo.1239.3">
     Let us see a quick example.
    </span>
    <span class="koboSpan" id="kobo.1239.4">
     Say we are updating the value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1240.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.1241.1">
     by adding one year to it.
    </span>
    <span class="koboSpan" id="kobo.1241.2">
     If
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1242.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.1243.1">
     is not there, we assume it was
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1244.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.1245.1">
     and we update it to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1246.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1247.1">
     :
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1248.1">&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d["age"] = d.get("age", 0) + 1  # age not there, we get 0 + 1
&gt;&gt;&gt; d
{'age': 1}
&gt;&gt;&gt; d = {"age": 39}
&gt;&gt;&gt; d["age"] = d.get("age", 0) + 1  # age is there, we get 40
&gt;&gt;&gt; d
{'age': 40}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1249.1">
     Now let us see how we could further simplify the first part of the code above, using a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1250.1">
      defaultdict
     </span>
    </code>
    <span class="koboSpan" id="kobo.1251.1">
     data type:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1252.1">&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; dd = defaultdict(int)  # int is the default type (0 the value)
&gt;&gt;&gt; dd["age"] += 1  # short for dd['age'] = dd['age'] + 1
&gt;&gt;&gt; dd
defaultdict(&lt;class 'int'&gt;, {'age': 1})  # 1, as expected
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1253.1">
     Notice how we just need to instruct the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1254.1">
      defaultdict
     </span>
    </code>
    <span class="koboSpan" id="kobo.1255.1">
     factory that we want an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1256.1">
      int
     </span>
    </code>
    <span class="koboSpan" id="kobo.1257.1">
     number to be used if the key is missing (we will get 0, which is the default for the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1258.1">
      int
     </span>
    </code>
    <span class="koboSpan" id="kobo.1259.1">
     type).
    </span>
    <span class="koboSpan" id="kobo.1259.2">
     Also notice that even
    </span>
    <a id="_idIndexMarker262">
    </a>
    <span class="koboSpan" id="kobo.1260.1">
     though in this example there is no gain in the number of lines, there is
    </span>
    <a id="_idIndexMarker263">
    </a>
    <span class="koboSpan" id="kobo.1261.1">
     definitely a gain in readability, which is very important.
    </span>
    <span class="koboSpan" id="kobo.1261.2">
     You can also use your own functions to customize what value will be assigned to missing keys.
    </span>
    <span class="koboSpan" id="kobo.1261.3">
     To learn more, please refer to the official documentation.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-82">
    <span class="koboSpan" id="kobo.1262.1">
     ChainMap
    </span>
   </h3>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1263.1">
      ChainMap
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1264.1">
     is a
    </span>
    <a id="_idIndexMarker264">
    </a>
    <span class="koboSpan" id="kobo.1265.1">
     useful data type which was introduced in Python 3.3.
    </span>
    <span class="koboSpan" id="kobo.1265.2">
     It
    </span>
    <a id="_idIndexMarker265">
    </a>
    <span class="koboSpan" id="kobo.1266.1">
     behaves like a normal dictionary but, according to the Python documentation,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1267.1">
      is provided for quickly linking a number of mappings so they can be treated as a single unit
     </span>
    </em>
    <span class="koboSpan" id="kobo.1268.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1268.2">
     This is usually much faster than creating one dictionary and running multiple
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1269.1">
      update
     </span>
    </code>
    <span class="koboSpan" id="kobo.1270.1">
     calls on it.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1271.1">
      ChainMap
     </span>
    </code>
    <span class="koboSpan" id="kobo.1272.1">
     can be used to simulate nested scopes and is useful in templating.
    </span>
    <span class="koboSpan" id="kobo.1272.2">
     The underlying mappings are stored in a list.
    </span>
    <span class="koboSpan" id="kobo.1272.3">
     That list is public and can be accessed or updated using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1273.1">
      maps
     </span>
    </code>
    <span class="koboSpan" id="kobo.1274.1">
     attribute.
    </span>
    <span class="koboSpan" id="kobo.1274.2">
     Lookups search the underlying mappings successively until a key is found.
    </span>
    <span class="koboSpan" id="kobo.1274.3">
     By contrast, writes, updates, and deletions only operate on the first mapping.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1275.1">
     A very common use case is providing defaults, so let us see an example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1276.1">&gt;&gt;&gt; from collections import ChainMap
&gt;&gt;&gt; default_connection = {'host': 'localhost', 'port': 4567}
&gt;&gt;&gt; connection = {'port': 5678}
&gt;&gt;&gt; conn = ChainMap(connection, default_connection) # map creation
&gt;&gt;&gt; conn['port']  # port is found in the first dictionary
5678
&gt;&gt;&gt; conn['host']  # host is fetched from the second dictionary
'localhost'
&gt;&gt;&gt; conn.maps  # we can see the mapping objects
[{'port': 5678}, {'host': 'localhost', 'port': 4567}]
&gt;&gt;&gt; conn['host'] = 'packtpub.com'  # let's add host
&gt;&gt;&gt; conn.maps
[{'port': 5678, 'host': 'packtpub.com'},
 {'host': 'localhost', 'port': 4567}]
&gt;&gt;&gt; del conn['port']  # let's remove the port information
&gt;&gt;&gt; conn.maps
[{'host': 'packtpub.com'}, {'host': 'localhost', 'port': 4567}]
&gt;&gt;&gt; conn['port']  # now port is fetched from the second dictionary
4567
&gt;&gt;&gt; dict(conn)  # easy to merge and convert to regular dictionary
{'host': 'packtpub.com', 'port': 4567}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1277.1">
     This is yet another example of how Python simplifies things for us.
    </span>
    <span class="koboSpan" id="kobo.1277.2">
     You work on a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1278.1">
      ChainMap
     </span>
    </code>
    <span class="koboSpan" id="kobo.1279.1">
     object, configure the first mapping as you want, and when you need a complete dictionary
    </span>
    <a id="_idIndexMarker266">
    </a>
    <span class="koboSpan" id="kobo.1280.1">
     with all the defaults as well as the customized items, you
    </span>
    <a id="_idIndexMarker267">
    </a>
    <span class="koboSpan" id="kobo.1281.1">
     can just feed the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1282.1">
      ChainMap
     </span>
    </code>
    <span class="koboSpan" id="kobo.1283.1">
     object to a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1284.1">
      dict
     </span>
    </code>
    <span class="koboSpan" id="kobo.1285.1">
     constructor.
    </span>
    <span class="koboSpan" id="kobo.1285.2">
     If you have ever coded in other languages, such as Java or C++, you probably will be able to appreciate how precious this is, and how well Python simplifies some tasks.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-83">
    <span class="koboSpan" id="kobo.1286.1">
     Enums
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1287.1">
     Living in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1288.1">
      enum
     </span>
    </code>
    <span class="koboSpan" id="kobo.1289.1">
     module, and definitely worth
    </span>
    <a id="_idIndexMarker268">
    </a>
    <span class="koboSpan" id="kobo.1290.1">
     mentioning, are
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1291.1">
      enumerations
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1292.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1292.2">
     They were introduced in Python 3.4, and we thought it would be a good idea to give you an example on them for the sake of completeness.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1293.1">
     The official definition of an enumeration is that it is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1294.1">
      a set of symbolic names (members) bound to unique, constant values.
     </span>
     <span class="koboSpan" id="kobo.1294.2">
      Within an enumeration, the members can be compared by identity, and the enumeration itself can be iterated over
     </span>
    </em>
    <span class="koboSpan" id="kobo.1295.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1296.1">
     Say you need to represent traffic lights; in your code, you might resort to the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1297.1">&gt;&gt;&gt; GREEN = 1
&gt;&gt;&gt; YELLOW = 2
&gt;&gt;&gt; RED = 4
&gt;&gt;&gt; TRAFFIC_LIGHTS = (GREEN, YELLOW, RED)
&gt;&gt;&gt; # or with a dict
&gt;&gt;&gt; traffic_lights = {"GREEN": 1, "YELLOW": 2, "RED": 4}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1298.1">
     There’s nothing special about this code.
    </span>
    <span class="koboSpan" id="kobo.1298.2">
     It is something, in fact, that is very common to find.
    </span>
    <span class="koboSpan" id="kobo.1298.3">
     But, consider doing this instead:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1299.1">&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class TrafficLight(Enum):
...     </span><span class="koboSpan" id="kobo.1299.2">GREEN = 1
...     </span><span class="koboSpan" id="kobo.1299.3">YELLOW = 2
...     </span><span class="koboSpan" id="kobo.1299.4">RED = 4
...
</span><span class="koboSpan" id="kobo.1299.5">&gt;&gt;&gt; TrafficLight.GREEN
&lt;TrafficLight.GREEN: 1&gt;
&gt;&gt;&gt; TrafficLight.GREEN.name
'GREEN'
&gt;&gt;&gt; TrafficLight.GREEN.value
1
&gt;&gt;&gt; TrafficLight(1)
&lt;TrafficLight.GREEN: 1&gt;
&gt;&gt;&gt; TrafficLight(4)
&lt;TrafficLight.RED: 4&gt;
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1300.1">
     Ignoring for a
    </span>
    <a id="_idIndexMarker269">
    </a>
    <span class="koboSpan" id="kobo.1301.1">
     moment the (relative) complexity of a class definition, you can appreciate how advantageous this approach may be.
    </span>
    <span class="koboSpan" id="kobo.1301.2">
     The data structure is much cleaner, and the API it provides is much more powerful.
    </span>
    <span class="koboSpan" id="kobo.1301.3">
     We encourage you to check out the official documentation to explore all the features you can find in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1302.1">
      enum
     </span>
    </code>
    <span class="koboSpan" id="kobo.1303.1">
     module.
    </span>
    <span class="koboSpan" id="kobo.1303.2">
     We think it is worth exploring, at least once.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-84">
    <span class="koboSpan" id="kobo.1304.1">
     Final considerations
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1305.1">
     That is it.
    </span>
    <span class="koboSpan" id="kobo.1305.2">
     Now you have seen a very good proportion of the data structures that you will use in Python.
    </span>
    <span class="koboSpan" id="kobo.1305.3">
     We encourage you to experiment further with every data type we have seen in this chapter.
    </span>
    <span class="koboSpan" id="kobo.1305.4">
     We also suggest that you skim through the official documentation, just to get an idea of what is available to you when writing Python.
    </span>
    <span class="koboSpan" id="kobo.1305.5">
     That working knowledge can be quite useful when you find it difficult to properly represent data using the most common types.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1306.1">
     Before we leap into
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.1307.1">
      Chapter 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.1308.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.1309.1">
      Conditionals and Iteration
     </span>
    </em>
    <span class="koboSpan" id="kobo.1310.1">
     , we would like to share some final considerations about some aspects that, to our minds, are important and not to be neglected.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-85">
    <span class="koboSpan" id="kobo.1311.1">
     Small value caching
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1312.1">
     While discussing objects at the beginning of this chapter, we saw that when we assign a name to an object, Python creates the object, sets its value, and then points the name to it.
    </span>
    <span class="koboSpan" id="kobo.1312.2">
     We can assign different names to the same value, and we expect different objects to be created, like this:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1313.1">&gt;&gt;&gt; a = 1000000
&gt;&gt;&gt; b = 1000000
&gt;&gt;&gt; id(a) == id(b)
False
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1314.1">
     In the preceding example,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1315.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1316.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1317.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.1318.1">
     are assigned to two
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1319.1">
      int
     </span>
    </code>
    <span class="koboSpan" id="kobo.1320.1">
     objects, which have the same value, but they are not the same object—as you can see, their
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1321.1">
      id
     </span>
    </code>
    <span class="koboSpan" id="kobo.1322.1">
     is not the same.
    </span>
    <span class="koboSpan" id="kobo.1322.2">
     Let us try with a smaller value:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1323.1">&gt;&gt;&gt; a = 5
&gt;&gt;&gt; b = 5
&gt;&gt;&gt; id(a) == id(b)
True
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1324.1">
     Uh-oh!
    </span>
    <span class="koboSpan" id="kobo.1324.2">
     This, we didn’t expect!
    </span>
    <span class="koboSpan" id="kobo.1324.3">
     Why are the two objects the same now?
    </span>
    <span class="koboSpan" id="kobo.1324.4">
     We didn’t do
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1325.1">
      a = b = 5
     </span>
    </code>
    <span class="koboSpan" id="kobo.1326.1">
     ; we set them up separately.
    </span>
    <span class="koboSpan" id="kobo.1326.2">
     The answer is something called object interning.
    </span>
   </p>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1327.1">
      Object interning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1328.1">
     is a memory
    </span>
    <a id="_idIndexMarker270">
    </a>
    <span class="koboSpan" id="kobo.1329.1">
     optimization technique that is used primarily for immutable data types, such as strings and integers in Python.
    </span>
    <span class="koboSpan" id="kobo.1329.2">
     The idea is to reuse existing objects instead of creating new ones every time an object with the same value is required.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1330.1">
     This can lead to significant memory savings and performance improvements because it reduces the load on the garbage collector and speeds up comparisons since they can be done by comparing object identities.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1331.1">
     Everything is handled properly, under the hood, so you do not need to worry, but it’s important to know about this feature for those cases where we deal directly with IDs.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-86">
    <span class="koboSpan" id="kobo.1332.1">
     How to choose data structures
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1333.1">
     As we’ve seen, Python
    </span>
    <a id="_idIndexMarker271">
    </a>
    <span class="koboSpan" id="kobo.1334.1">
     provides you with several built-in data types and, sometimes, if you’re not that experienced, choosing the one that serves you best can be tricky, especially when it comes to collections.
    </span>
    <span class="koboSpan" id="kobo.1334.2">
     For example, say you have many dictionaries to store, each of which represents a customer.
    </span>
    <span class="koboSpan" id="kobo.1334.3">
     Within each customer dictionary, there’s a unique identification code with the key
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1335.1">
      "id"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1336.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1336.2">
     In what kind of collection would you place them?
    </span>
    <span class="koboSpan" id="kobo.1336.3">
     Well, unless we know more about these customers, it might be hard to produce an answer.
    </span>
    <span class="koboSpan" id="kobo.1336.4">
     We need to ask questions.
    </span>
    <span class="koboSpan" id="kobo.1336.5">
     What kind of access do we need?
    </span>
    <span class="koboSpan" id="kobo.1336.6">
     What sort of operations do we need to perform on each item?
    </span>
    <span class="koboSpan" id="kobo.1336.7">
     How many times?
    </span>
    <span class="koboSpan" id="kobo.1336.8">
     Will the collection change over time?
    </span>
    <span class="koboSpan" id="kobo.1336.9">
     Will we need to modify the customer dictionaries in any way?
    </span>
    <span class="koboSpan" id="kobo.1336.10">
     What is going to be the most frequent operation we have to perform on the collection?
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1337.1">
     If you can answer those
    </span>
    <a id="_idIndexMarker272">
    </a>
    <span class="koboSpan" id="kobo.1338.1">
     questions, then you will know what to choose.
    </span>
    <span class="koboSpan" id="kobo.1338.2">
     If the collection never shrinks or grows (in other words, it won’t need to add/delete any customer object after creation) or shuffles, then tuples are a possible choice.
    </span>
    <span class="koboSpan" id="kobo.1338.3">
     Otherwise, lists are a good candidate.
    </span>
    <span class="koboSpan" id="kobo.1338.4">
     Every customer dictionary has a unique identifier though, so even a dictionary could work.
    </span>
    <span class="koboSpan" id="kobo.1338.5">
     Let us draft these options for you:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1339.1">customer1 = {"id": "abc123", "full_name": "Master Yoda"}
customer2 = {"id": "def456", "full_name": "Obi-Wan Kenobi"}
customer3 = {"id": "ghi789", "full_name": "Anakin Skywalker"}
# collect them in a tuple
customers = (customer1, customer2, customer3)
# or collect them in a list
customers = [customer1, customer2, customer3]
# or maybe within a dictionary, they have a unique id after all
customers = {
    "abc123": customer1,
    "def456": customer2,
    "ghi789": customer3,
}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1340.1">
     Some customers we have there, right?
    </span>
    <span class="koboSpan" id="kobo.1340.2">
     We probably would not go with the tuple option, unless we wanted to highlight that the collection is not going to change or to suggest it shouldn’t be modified.
    </span>
    <span class="koboSpan" id="kobo.1340.3">
     We would say that, usually, a list is better, as it allows for more flexibility.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1341.1">
     Another factor to keep in mind is that tuples and lists are ordered collections.
    </span>
    <span class="koboSpan" id="kobo.1341.2">
     If you use a set, for example, you would lose the ordering, so you need to know if ordering is important in your application.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1342.1">
     What about performance?
    </span>
    <span class="koboSpan" id="kobo.1342.2">
     For example, in a list, operations such as insertion and membership testing can take
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1343.1">
      O(n)
     </span>
    </em>
    <span class="koboSpan" id="kobo.1344.1">
     time, while they are
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1345.1">
      O(1)
     </span>
    </em>
    <span class="koboSpan" id="kobo.1346.1">
     for a dictionary.
    </span>
    <span class="koboSpan" id="kobo.1346.2">
     It is not always possible to use dictionaries though, if we don’t have the guarantee that we can uniquely identify each item of the collection by means of one of its properties and that the property in question is hashable (so it can be a key in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1347.1">
      dict
     </span>
    </code>
    <span class="koboSpan" id="kobo.1348.1">
     ).
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1349.1">
      If you’re wondering what
     </span>
     <em class="keystroke">
      <span class="koboSpan" id="kobo.1350.1">
       O
      </span>
     </em>
     <em class="italic">
      <span class="koboSpan" id="kobo.1351.1">
       (n)
      </span>
     </em>
     <span class="koboSpan" id="kobo.1352.1">
      and
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1353.1">
       O(1)
      </span>
     </em>
     <span class="koboSpan" id="kobo.1354.1">
      mean, please research
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1355.1">
       big O notation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1356.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1356.2">
      In this context, let us just say that if performing an operation
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1357.1">
       Op
      </span>
     </em>
     <span class="koboSpan" id="kobo.1358.1">
      on a data structure takes
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1359.1">
       O(f(n))
      </span>
     </em>
     <span class="koboSpan" id="kobo.1360.1">
      , it would mean that
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1361.1">
       Op
      </span>
     </em>
     <span class="koboSpan" id="kobo.1362.1">
      takes at most time
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1363.1">
       t ≤ c * f(n)
      </span>
     </em>
     <span class="koboSpan" id="kobo.1364.1">
      to complete, where
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1365.1">
       c
      </span>
     </em>
     <span class="koboSpan" id="kobo.1366.1">
      is
     </span>
     <a id="_idIndexMarker273">
     </a>
     <span class="koboSpan" id="kobo.1367.1">
      some positive constant,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1368.1">
       n
      </span>
     </em>
     <span class="koboSpan" id="kobo.1369.1">
      is the size of the input, and
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1370.1">
       f
      </span>
     </em>
     <span class="koboSpan" id="kobo.1371.1">
      is some function.
     </span>
     <span class="koboSpan" id="kobo.1371.2">
      So, think of
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1372.1">
       O(...)
      </span>
     </em>
     <span class="koboSpan" id="kobo.1373.1">
      as an upper bound for the running time of an operation (it can also be used to size other measurable quantities, of course).
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.1374.1">
     Another way of
    </span>
    <a id="_idIndexMarker274">
    </a>
    <span class="koboSpan" id="kobo.1375.1">
     understanding whether you have chosen the right data structure is by looking at the code you have to write in order to manipulate it.
    </span>
    <span class="koboSpan" id="kobo.1375.2">
     If writing the logic comes easily and flows naturally, then you probably have chosen correctly, but if you find yourself thinking your code is getting unnecessarily complicated, then you may need to reconsider your choices.
    </span>
    <span class="koboSpan" id="kobo.1375.3">
     It is quite hard to give advice without a practical case though, so when you choose a data structure for your data, try to keep ease of use and performance in mind, and give precedence to what matters most in the context you are in.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-87">
    <span class="koboSpan" id="kobo.1376.1">
     About indexing and slicing
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1377.1">
     At the beginning of this chapter, we saw slicing applied to strings.
    </span>
    <span class="koboSpan" id="kobo.1377.2">
     Slicing, in general, applies to a sequence: tuples, lists, strings, and so on.
    </span>
    <span class="koboSpan" id="kobo.1377.3">
     With
    </span>
    <a id="_idIndexMarker275">
    </a>
    <span class="koboSpan" id="kobo.1378.1">
     lists, slicing can also be used for assignment, although in practice this technique is rarely used—at least in our experience.
    </span>
    <span class="koboSpan" id="kobo.1378.2">
     Dictionaries and sets cannot be sliced, of course.
    </span>
    <span class="koboSpan" id="kobo.1378.3">
     Let us discuss indexing a bit more in depth.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1379.1">
     There is one characteristic regarding Python indexing
    </span>
    <a id="_idIndexMarker276">
    </a>
    <span class="koboSpan" id="kobo.1380.1">
     that we haven’t mentioned before.
    </span>
    <span class="koboSpan" id="kobo.1380.2">
     We will show you by way of an example.
    </span>
    <span class="koboSpan" id="kobo.1380.3">
     How do you address the last element of a collection?
    </span>
    <span class="koboSpan" id="kobo.1380.4">
     Let us see:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1381.1">&gt;&gt;&gt; a = list(range(10))  # `a` has 10 elements. </span><span class="koboSpan" id="kobo.1381.2">Last one is 9.
</span><span class="koboSpan" id="kobo.1381.3">&gt;&gt;&gt; a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; len(a)  # its length is 10 elements
10
&gt;&gt;&gt; a[len(a) - 1]  # position of last one is len(a) - 1
9
&gt;&gt;&gt; a[-1]  # but we don't need len(a)! </span><span class="koboSpan" id="kobo.1381.4">Python rocks!
</span><span class="koboSpan" id="kobo.1381.5">9
&gt;&gt;&gt; a[-2]  # equivalent to len(a) - 2
8
&gt;&gt;&gt; a[-3]  # equivalent to len(a) - 3
7
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1382.1">
     If list
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1383.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1384.1">
     has 10 elements, then due to the 0-index positioning system of Python, the first one is at position 0 and the last one is at position 9.
    </span>
    <span class="koboSpan" id="kobo.1384.2">
     In the preceding example, the elements are conveniently placed in a position equal to their value:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1385.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.1386.1">
     is at position 0,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1387.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1388.1">
     at position 1, and so on.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1389.1">
     So, in order to fetch the last element, we need to know the length of the whole list (or tuple, string, and so on) and then subtract 1, hence
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1390.1">
      len(a) - 1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1391.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1391.2">
     This is so common an operation that Python provides you with a way to retrieve elements using
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1392.1">
      negative indexing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1393.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1393.2">
     This
    </span>
    <a id="_idIndexMarker277">
    </a>
    <span class="koboSpan" id="kobo.1394.1">
     proves quite useful as it simplifies the code.
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1395.1">
      Figure 2.2
     </span>
    </em>
    <span class="koboSpan" id="kobo.1396.1">
     displays a neat diagram about how indexing works on the string
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1397.1">
      "HelloThere"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1398.1">
     (which is Obi-Wan Kenobi sarcastically greeting General Grievous in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1399.1">
      Star Wars: Episode III—Revenge of the Sith
     </span>
    </em>
    <span class="koboSpan" id="kobo.1400.1">
     ):
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.1401.1">
     <img alt="img" src="../Images/B30996_02_02.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.1402.1">
     Figure 2.2: Python indexing
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1403.1">
     Trying to address indexes greater than 9 or smaller than -10 will raise an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1404.1">
      IndexError
     </span>
    </code>
    <span class="koboSpan" id="kobo.1405.1">
     , as expected.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-88">
    <span class="koboSpan" id="kobo.1406.1">
     About names
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1407.1">
     You may have noticed that, in order to keep the
    </span>
    <a id="_idIndexMarker278">
    </a>
    <span class="koboSpan" id="kobo.1408.1">
     examples as short as possible, we have named many objects using simple letters, like
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1409.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1410.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1411.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.1412.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1413.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.1414.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1415.1">
      d
     </span>
    </code>
    <span class="koboSpan" id="kobo.1416.1">
     , and so on.
    </span>
    <span class="koboSpan" id="kobo.1416.2">
     This is perfectly fine when debugging on the console, or showing that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1417.1">
      a + b == 7
     </span>
    </code>
    <span class="koboSpan" id="kobo.1418.1">
     , but it is bad practice when it comes to professional code (or any type of code, for that matter).
    </span>
    <span class="koboSpan" id="kobo.1418.2">
     We hope you will indulge us where we have done it; the reason is to present the code in a more compact way.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1419.1">
     In a real environment though, when you choose names for your data, you should choose them carefully—they should reflect what the data is about.
    </span>
    <span class="koboSpan" id="kobo.1419.2">
     So, if you have a collection of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1420.1">
      Customer
     </span>
    </code>
    <span class="koboSpan" id="kobo.1421.1">
     objects,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1422.1">
      customers
     </span>
    </code>
    <span class="koboSpan" id="kobo.1423.1">
     is a perfectly good name for it.
    </span>
    <span class="koboSpan" id="kobo.1423.2">
     Would
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1424.1">
      customers_list
     </span>
    </code>
    <span class="koboSpan" id="kobo.1425.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1426.1">
      customers_tuple
     </span>
    </code>
    <span class="koboSpan" id="kobo.1427.1">
     , or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1428.1">
      customers_collection
     </span>
    </code>
    <span class="koboSpan" id="kobo.1429.1">
     work as well?
    </span>
    <span class="koboSpan" id="kobo.1429.2">
     Think about it for a second.
    </span>
    <span class="koboSpan" id="kobo.1429.3">
     Is it good to tie the name of the collection to the datatype?
    </span>
    <span class="koboSpan" id="kobo.1429.4">
     We do not think so unless there is a compelling reason.
    </span>
    <span class="koboSpan" id="kobo.1429.5">
     The reasoning behind this is that once
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1430.1">
      customers_tuple
     </span>
    </code>
    <span class="koboSpan" id="kobo.1431.1">
     starts being used in different parts of your code, and you realize you actually want to use a list instead of a tuple, you have a name tied to the wrong data type, which means you will have to refactor.
    </span>
    <span class="koboSpan" id="kobo.1431.2">
     Names for data should be nouns, and names for functions should be verbs.
    </span>
    <span class="koboSpan" id="kobo.1431.3">
     Names
    </span>
    <a id="_idIndexMarker279">
    </a>
    <span class="koboSpan" id="kobo.1432.1">
     should be as expressive as possible.
    </span>
    <span class="koboSpan" id="kobo.1432.2">
     Python is actually a very good example when it comes to names.
    </span>
    <span class="koboSpan" id="kobo.1432.3">
     Most of the time, you can just guess what a function is called if you know what it does.
    </span>
   </p>
   <div class="packt_tip">
    <p class="normal">
     <em class="italic">
      <span class="koboSpan" id="kobo.1433.1">
       Chapter 2
      </span>
     </em>
     <span class="koboSpan" id="kobo.1434.1">
      of the book
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1435.1">
       Clean Code
      </span>
     </em>
     <span class="koboSpan" id="kobo.1436.1">
      by
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1437.1">
       Robert C.
      </span>
      <span class="koboSpan" id="kobo.1437.2">
       Martin
      </span>
     </em>
     <span class="koboSpan" id="kobo.1438.1">
      is entirely dedicated to names.
     </span>
     <span class="koboSpan" id="kobo.1438.2">
      It is a great book that helped us improve our coding style in many different ways—a must-read, if you want to take your skills to the next level.
     </span>
    </p>
   </div>
   <h1 class="heading-1" id="_idParaDest-89">
    <span class="koboSpan" id="kobo.1439.1">
     Summary
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1440.1">
     In this chapter, we explored Python’s built-in data types.
    </span>
    <span class="koboSpan" id="kobo.1440.2">
     We have seen how many there are and how much can be achieved just by using them in different combinations.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1441.1">
     We have seen number types, sequences, sets, mappings, dates, times, collections, and enumerations.
    </span>
    <span class="koboSpan" id="kobo.1441.2">
     We have also seen that everything is an object and learned the difference between mutable and immutable.
    </span>
    <span class="koboSpan" id="kobo.1441.3">
     We also learned about slicing and indexing.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1442.1">
     We presented the cases with simple examples, but there is much more that you can learn about this subject, so stick your nose into the official documentation and go exploring!
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1443.1">
     Most of all, we encourage you to try out all the exercises by yourself—get your fingers used to that code, build some muscle memory, and experiment, experiment, experiment.
    </span>
    <span class="koboSpan" id="kobo.1443.2">
     Learn what happens when you divide by zero, when you combine different number types, and when you work with strings.
    </span>
    <span class="koboSpan" id="kobo.1443.3">
     Play with all data types.
    </span>
    <span class="koboSpan" id="kobo.1443.4">
     Exercise them, break them, discover all their methods, enjoy them, and learn them very, very well.
    </span>
    <span class="koboSpan" id="kobo.1443.5">
     If your foundation is not rock solid, how good can your code be?
    </span>
    <span class="koboSpan" id="kobo.1443.6">
     Data is the foundation for everything; data shapes what dances around it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1444.1">
     The more you progress with the book, the more likely it is that you will find some discrepancies or a small typo here and there in our code (or yours).
    </span>
    <span class="koboSpan" id="kobo.1444.2">
     You will get an error message or something will break.
    </span>
    <span class="koboSpan" id="kobo.1444.3">
     That is wonderful!
    </span>
    <span class="koboSpan" id="kobo.1444.4">
     When you code, things break and you have to debug them, all the time, so consider errors as useful exercises to learn something new about the language you’re using, and not as failures or problems.
    </span>
    <span class="koboSpan" id="kobo.1444.5">
     Errors will keep coming up, that is certain, so you may as well start making your peace with them now.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1445.1">
     The next chapter is about conditionals and iteration.
    </span>
    <span class="koboSpan" id="kobo.1445.2">
     We will see how to actually put collections to use and make decisions based on the data that we are presented with.
    </span>
    <span class="koboSpan" id="kobo.1445.3">
     We will start to go a little faster now that your knowledge is building up, so make sure you are comfortable with the contents of this chapter before you move on to the next one.
    </span>
    <span class="koboSpan" id="kobo.1445.4">
     Once more, have fun, explore, and break things—it is a very good way to learn.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-90">
    <span class="koboSpan" id="kobo.1446.1">
     Join our community on Discord
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1447.1">
     Join our community’s Discord space for discussions with the authors and other readers:
    </span>
   </p>
   <p class="normal">
    <a href="Chapter_2.xhtml">
     <span class="url">
      <span class="koboSpan" id="kobo.1448.1">
       https://discord.com/invite/uaKmaz7FEC
      </span>
     </span>
    </a>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1449.1">
     <img alt="img" src="../Images/QR_Code119001106417026468.png"/>
    </span>
   </p>
  </div>
 </body></html>