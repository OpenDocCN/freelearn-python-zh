<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer097">
   <h1 class="chapterNumber">
    <span class="koboSpan" id="kobo.1.1">
     4
    </span>
   </h1>
   <h1 class="chapterTitle" id="_idParaDest-120">
    <span class="koboSpan" id="kobo.2.1">
     Functions, the Building Blocks of Code
    </span>
   </h1>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.3.1">
      ”To create architecture is to put in order.
     </span>
     <span class="koboSpan" id="kobo.3.2">
      Put what in order?
     </span>
     <span class="koboSpan" id="kobo.3.3">
      Functions and objects.”
     </span>
    </p>
    <p class="cite">
     <span class="koboSpan" id="kobo.4.1">
      —Le Corbusier
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.5.1">
     In the previous chapters, we have seen that everything is an object in Python, and functions are no exception.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     But what exactly is a function?
    </span>
    <span class="koboSpan" id="kobo.5.3">
     A function
    </span>
    <a id="_idIndexMarker377">
    </a>
    <span class="koboSpan" id="kobo.6.1">
     is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.7.1">
      a block of reusable code designed to perform a specific task or a related group of tasks
     </span>
    </em>
    <span class="koboSpan" id="kobo.8.1">
     .
    </span>
    <span class="koboSpan" id="kobo.8.2">
     This unit can then be imported and used wherever it is needed.
    </span>
    <span class="koboSpan" id="kobo.8.3">
     There are many advantages to using functions in your code, as we will see shortly.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.9.1">
     In this chapter, we are going to cover the following:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.10.1">
      Functions—what they are and why we should use them
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.11.1">
      Scopes and name resolution
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.12.1">
      Function signatures—input parameters and return values
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.13.1">
      Recursive and anonymous functions
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.14.1">
      Importing objects for code reuse
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.15.1">
     We believe the saying
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.16.1">
      a picture is worth a thousand words
     </span>
    </em>
    <span class="koboSpan" id="kobo.17.1">
     is particularly true when explaining functions to someone who is new to this concept, so please take a look at the following figure:
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.18.1">
     <img alt="img" src="../Images/B30992_04_01.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.19.1">
     Figure 4.1: An example of a function
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.20.1">
     As you can see, a
    </span>
    <a id="_idIndexMarker378">
    </a>
    <span class="koboSpan" id="kobo.21.1">
     function is a block of instructions, packaged as a whole, like a box.
    </span>
    <span class="koboSpan" id="kobo.21.2">
     Functions can accept input parameters and produce output values.
    </span>
    <span class="koboSpan" id="kobo.21.3">
     Both of these are optional, as we will see in the examples in this chapter.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.22.1">
     A function in Python is defined using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.23.1">
      def
     </span>
    </code>
    <span class="koboSpan" id="kobo.24.1">
     keyword, after which the name of the function follows, terminated by a pair of parentheses (which may or may not contain input parameters); a colon (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.25.1">
      :
     </span>
    </code>
    <span class="koboSpan" id="kobo.26.1">
     ) then signals the end of the function definition.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     Immediately afterward, indented by four spaces, we find the body of the function, which is the set of instructions that the function will execute when called.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.27.1">
      Note that the indentation by four spaces is not mandatory, but it is the number of spaces suggested by PEP 8, and, in practice, it is the most widely used spacing measure.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.28.1">
     A function may or may not return an output.
    </span>
    <span class="koboSpan" id="kobo.28.2">
     If a function wants to return an output, it does so by using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.29.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.30.1">
     keyword, followed by the desired output.
    </span>
    <span class="koboSpan" id="kobo.30.2">
     You may have noticed the little
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.31.1">
      *
     </span>
    </code>
    <span class="koboSpan" id="kobo.32.1">
     after
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.33.1">
      Optional
     </span>
    </em>
    <span class="koboSpan" id="kobo.34.1">
     in the output section of the preceding diagram.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     This is because a function always returns something in Python, even if you do not explicitly use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.35.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.36.1">
     statement.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     If the function has no
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.37.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.38.1">
     statement in its body, or no value is given to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.39.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.40.1">
     statement itself, the function returns
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.41.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.42.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.43.1">
     This design choice is rooted in several reasons, the most important of which are:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.44.1">
       Simplicity and consistency
      </span>
     </strong>
     <span class="koboSpan" id="kobo.45.1">
      : Whether the function is explicitly returning a value or not, its behavior is consistent.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.46.1">
       Complexity reduction
      </span>
     </strong>
     <span class="koboSpan" id="kobo.47.1">
      : Several languages make a
     </span>
     <a id="_idIndexMarker379">
     </a>
     <span class="koboSpan" id="kobo.48.1">
      distinction between functions (which return a value) and
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.49.1">
       procedures
      </span>
     </strong>
     <span class="koboSpan" id="kobo.50.1">
      (which do not).
     </span>
     <span class="koboSpan" id="kobo.50.2">
      Functions in Python can act as both, with no need for separate constructs.
     </span>
     <span class="koboSpan" id="kobo.50.3">
      This minimizes the number of concepts a programmer must learn.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.51.1">
       Consistency for multiple pathways
      </span>
     </strong>
     <span class="koboSpan" id="kobo.52.1">
      : Functions with multiple conditional branches will return
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.53.1">
       None
      </span>
     </code>
     <span class="koboSpan" id="kobo.54.1">
      when no other return statement is executed.
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.55.1">
       None
      </span>
     </code>
     <span class="koboSpan" id="kobo.56.1">
      , therefore, is a useful default value.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.57.1">
     The list provided demonstrates the multitude of factors that can influence an apparently simple design decision.
    </span>
    <span class="koboSpan" id="kobo.57.2">
     It is the careful and deliberate choices underpinning Python’s design that contribute to its elegance, simplicity, and versatility.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-121">
    <span class="koboSpan" id="kobo.58.1">
     Why use functions?
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.59.1">
     Functions are among
    </span>
    <a id="_idIndexMarker380">
    </a>
    <span class="koboSpan" id="kobo.60.1">
     the most important concepts and constructs of any language, so let us give you a few reasons why we need them:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.61.1">
      They reduce code duplication in a program.
     </span>
     <span class="koboSpan" id="kobo.61.2">
      Encapsulating the instructions for a task in a function that we can import and call whenever we want allows us to avoid duplicating the implementation.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.62.1">
      They help in splitting a complex task or procedure into smaller blocks, each of which becomes a function.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.63.1">
      They hide the implementation details from their users.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.64.1">
      They improve traceability.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.65.1">
      They improve readability.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.66.1">
     Let us now look at a few examples to get a better understanding of each point.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-122">
    <span class="koboSpan" id="kobo.67.1">
     Reducing code duplication
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.68.1">
     Imagine that you are writing a piece
    </span>
    <a id="_idIndexMarker381">
    </a>
    <span class="koboSpan" id="kobo.69.1">
     of scientific software, and you need to calculate prime numbers up to a certain limit—as we did in the previous chapter.
    </span>
    <span class="koboSpan" id="kobo.69.2">
     You have an algorithm to calculate them, so you copy it and paste it to wherever you need to use it.
    </span>
    <span class="koboSpan" id="kobo.69.3">
     One day, though, a colleague gives you a more performant algorithm to calculate primes.
    </span>
    <span class="koboSpan" id="kobo.69.4">
     At this point, you need to go over your whole code base and replace the old code with the new one.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.70.1">
     This procedure is quite error-prone.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     You can easily remove parts of the surrounding code by mistake or fail to remove some of the code you meant to replace.
    </span>
    <span class="koboSpan" id="kobo.70.3">
     You also risk missing some of the places where the prime calculation is done, leaving your software in an inconsistent state where the same action is performed in different ways.
    </span>
    <span class="koboSpan" id="kobo.70.4">
     What if, instead of replacing code with a better version of it, you need to fix a bug and you miss a spot.
    </span>
    <span class="koboSpan" id="kobo.70.5">
     That would be even worse.
    </span>
    <span class="koboSpan" id="kobo.70.6">
     What if the names of the variables in the old algorithm are different from those used in the new one?
    </span>
    <span class="koboSpan" id="kobo.70.7">
     That will also complicate things.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.71.1">
     To avoid all that, you write a function,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.72.1">
      get_prime_numbers(upto)
     </span>
    </code>
    <span class="koboSpan" id="kobo.73.1">
     , and use it anywhere you need to calculate a list of primes.
    </span>
    <span class="koboSpan" id="kobo.73.2">
     When your colleague gives you a better implementation, all you need to do is replace the body of that function with the new code.
    </span>
    <span class="koboSpan" id="kobo.73.3">
     The rest of the software will automatically adapt since it is just calling the function.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.74.1">
     Your code will be
    </span>
    <a id="_idIndexMarker382">
    </a>
    <span class="koboSpan" id="kobo.75.1">
     shorter and free from inconsistencies between old and new ways of performing a task.
    </span>
    <span class="koboSpan" id="kobo.75.2">
     You are also less likely to leave behind undetected bugs that arise from copy-and-paste failures or oversights.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-123">
    <span class="koboSpan" id="kobo.76.1">
     Splitting a complex task
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.77.1">
     Functions are also
    </span>
    <a id="_idIndexMarker383">
    </a>
    <span class="koboSpan" id="kobo.78.1">
     useful for splitting long or complex tasks into smaller ones.
    </span>
    <span class="koboSpan" id="kobo.78.2">
     The result is that the code benefits from it in several ways, including readability, testability, and reusability.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.79.1">
     To give you a simple example, imagine that you are preparing a report.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     Your code needs to fetch data from a data source, parse it, filter it, and polish it, and then a whole series of algorithms needs to be run against it, to produce the results that will be written into the report.
    </span>
    <span class="koboSpan" id="kobo.79.3">
     It is common to see procedures like this that are just one big
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.80.1">
      do_report(data_source)
     </span>
    </code>
    <span class="koboSpan" id="kobo.81.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.81.2">
     There might be hundreds of lines of code that run before we finally produce the report.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.82.1">
     Inexperienced programmers, not well versed in the art of crafting simple, well structured code, may produce functions with hundreds of lines of code.
    </span>
    <span class="koboSpan" id="kobo.82.2">
     They are hard to follow through, to find the places where things are changing context (such as finishing one task and starting the next one).
    </span>
    <span class="koboSpan" id="kobo.82.3">
     Let us show you a better approach instead:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.83.1"># data.science.example.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.84.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.85.1">do_report</span></span><span class="koboSpan" id="kobo.86.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.87.1">data_source</span></span><span class="koboSpan" id="kobo.88.1">):
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.89.1"># fetch and prepare data</span></span><span class="koboSpan" id="kobo.90.1">
    data = fetch_data(data_source)
    parsed_data = parse_data(data)
    filtered_data = filter_data(parsed_data)
    polished_data = polish_data(filtered_data)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.91.1"># run algorithms on data</span></span><span class="koboSpan" id="kobo.92.1">
    final_data = analyse(polished_data)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.93.1"># create and return report</span></span><span class="koboSpan" id="kobo.94.1">
    report = Report(final_data)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.95.1">return</span></span><span class="koboSpan" id="kobo.96.1"> report
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.97.1">
     The previous
    </span>
    <a id="_idIndexMarker384">
    </a>
    <span class="koboSpan" id="kobo.98.1">
     example is fictitious, of course, but can you see how easy it would be to go through the code?
    </span>
    <span class="koboSpan" id="kobo.98.2">
     If the end result looks wrong, it would be easy to debug each of the single data outputs in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.99.1">
      do_report()
     </span>
    </code>
    <span class="koboSpan" id="kobo.100.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.100.2">
     Moreover, it is even easier to exclude part of the process temporarily from the whole procedure (you just need to comment out the parts that you need to suspend).
    </span>
    <span class="koboSpan" id="kobo.100.3">
     Code like this is easier to deal with.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-124">
    <span class="koboSpan" id="kobo.101.1">
     Hiding implementation details
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.102.1">
     Let us stay with the
    </span>
    <a id="_idIndexMarker385">
    </a>
    <span class="koboSpan" id="kobo.103.1">
     preceding example to talk about this point as well.
    </span>
    <span class="koboSpan" id="kobo.103.2">
     We can see that, by going through the code of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.104.1">
      do_report()
     </span>
    </code>
    <span class="koboSpan" id="kobo.105.1">
     function, we can get a surprisingly good understanding without reading one single line of implementation.
    </span>
    <span class="koboSpan" id="kobo.105.2">
     This is because functions hide the implementation details.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.106.1">
     This feature means that, if we do not need to delve into the details, we are not forced to, in the way that we would be if
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.107.1">
      do_report()
     </span>
    </code>
    <span class="koboSpan" id="kobo.108.1">
     was just one big, long function.
    </span>
    <span class="koboSpan" id="kobo.108.2">
     To understand what was going on, we would have to read and understand every single line of its code.
    </span>
    <span class="koboSpan" id="kobo.108.3">
     When it is broken down into smaller functions, we do not necessarily need to read every line of every one of them to understand what the code does.
    </span>
    <span class="koboSpan" id="kobo.108.4">
     This reduces the time we spend reading the code and, since in a professional environment reading code takes much more time than writing it, it is important to reduce it to a minimum.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-125">
    <span class="koboSpan" id="kobo.109.1">
     Improving readability
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.110.1">
     Programmers sometimes do not see
    </span>
    <a id="_idIndexMarker386">
    </a>
    <span class="koboSpan" id="kobo.111.1">
     the point in writing a function with a body of one or two lines of code, so let us look at an example that shows you why you should probably still do it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.112.1">
     Imagine that you need to multiply two matrices, like in the example below:
    </span>
   </p>
   <p class="center">
    <span class="koboSpan" id="kobo.113.1">
     <img alt="img" src="../Images/B30992_04_001.png"/>
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.114.1">
     Would you prefer to have to read this code:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.115.1"># matrix.multiplication.nofunc.py</span></span><span class="koboSpan" id="kobo.116.1">
a = [[</span><span class="hljs-number"><span class="koboSpan" id="kobo.117.1">1</span></span><span class="koboSpan" id="kobo.118.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.119.1">2</span></span><span class="koboSpan" id="kobo.120.1">], [</span><span class="hljs-number"><span class="koboSpan" id="kobo.121.1">3</span></span><span class="koboSpan" id="kobo.122.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.123.1">4</span></span><span class="koboSpan" id="kobo.124.1">]]
b = [[</span><span class="hljs-number"><span class="koboSpan" id="kobo.125.1">5</span></span><span class="koboSpan" id="kobo.126.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.127.1">1</span></span><span class="koboSpan" id="kobo.128.1">], [</span><span class="hljs-number"><span class="koboSpan" id="kobo.129.1">2</span></span><span class="koboSpan" id="kobo.130.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.131.1">1</span></span><span class="koboSpan" id="kobo.132.1">]]
c = [
    [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.133.1">sum</span></span><span class="koboSpan" id="kobo.134.1">(i * j </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.135.1">for</span></span><span class="koboSpan" id="kobo.136.1"> i, j </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.137.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.138.1">zip</span></span><span class="koboSpan" id="kobo.139.1">(r, c)) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.140.1">for</span></span><span class="koboSpan" id="kobo.141.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.142.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.143.1">zip</span></span><span class="koboSpan" id="kobo.144.1">(*b)] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.145.1">for</span></span><span class="koboSpan" id="kobo.146.1"> r </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.147.1">in</span></span><span class="koboSpan" id="kobo.148.1"> a
]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.149.1">
     Or, would you prefer this:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.150.1"># matrix.multiplication.func.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.151.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.152.1">matrix_mul</span></span><span class="koboSpan" id="kobo.153.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.154.1">a, b</span></span><span class="koboSpan" id="kobo.155.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.156.1">return</span></span><span class="koboSpan" id="kobo.157.1"> [
        [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.158.1">sum</span></span><span class="koboSpan" id="kobo.159.1">(i * j </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.160.1">for</span></span><span class="koboSpan" id="kobo.161.1"> i, j </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.162.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.163.1">zip</span></span><span class="koboSpan" id="kobo.164.1">(r, c)) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.165.1">for</span></span><span class="koboSpan" id="kobo.166.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.167.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.168.1">zip</span></span><span class="koboSpan" id="kobo.169.1">(*b)]
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.170.1">for</span></span><span class="koboSpan" id="kobo.171.1"> r </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.172.1">in</span></span><span class="koboSpan" id="kobo.173.1"> a
    ]
a = [[</span><span class="hljs-number"><span class="koboSpan" id="kobo.174.1">1</span></span><span class="koboSpan" id="kobo.175.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.176.1">2</span></span><span class="koboSpan" id="kobo.177.1">], [</span><span class="hljs-number"><span class="koboSpan" id="kobo.178.1">3</span></span><span class="koboSpan" id="kobo.179.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.180.1">4</span></span><span class="koboSpan" id="kobo.181.1">]]
b = [[</span><span class="hljs-number"><span class="koboSpan" id="kobo.182.1">5</span></span><span class="koboSpan" id="kobo.183.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.184.1">1</span></span><span class="koboSpan" id="kobo.185.1">], [</span><span class="hljs-number"><span class="koboSpan" id="kobo.186.1">2</span></span><span class="koboSpan" id="kobo.187.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.188.1">1</span></span><span class="koboSpan" id="kobo.189.1">]]
c = matrix_mul(a, b)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.190.1">
     It is much easier to understand that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.191.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.192.1">
     is the result of the multiplication of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.193.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.194.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.195.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.196.1">
     in the second example, and it is much easier to read the code.
    </span>
    <span class="koboSpan" id="kobo.196.2">
     If we do not need to modify that multiplication logic, we do not even need to go into the implementation details of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.197.1">
      matrix_mul()
     </span>
    </code>
    <span class="koboSpan" id="kobo.198.1">
     .
    </span>
    <span class="koboSpan" id="kobo.198.2">
     Therefore, readability is improved here while, in the first snippet, we would have to
    </span>
    <a id="_idIndexMarker387">
    </a>
    <span class="koboSpan" id="kobo.199.1">
     spend time trying to understand what that complicated list comprehension is doing.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.200.1">
      Do not worry if you do not understand list comprehensions, as we will study them in
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.201.1">
       Chapter 5
      </span>
     </em>
     <span class="koboSpan" id="kobo.202.1">
      ,
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.203.1">
       Comprehensions and Generators
      </span>
     </em>
     <span class="koboSpan" id="kobo.204.1">
      .
     </span>
    </p>
   </div>
   <h2 class="heading-2" id="_idParaDest-126">
    <span class="koboSpan" id="kobo.205.1">
     Improving traceability
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.206.1">
     Imagine that we have written some
    </span>
    <a id="_idIndexMarker388">
    </a>
    <span class="koboSpan" id="kobo.207.1">
     code for an e-commerce website.
    </span>
    <span class="koboSpan" id="kobo.207.2">
     We display the product prices on several pages.
    </span>
    <span class="koboSpan" id="kobo.207.3">
     Imagine that the prices in the database are stored with no VAT (sales tax), but we want to display them on the website with VAT at 20%.
    </span>
    <span class="koboSpan" id="kobo.207.4">
     Here are a few ways of calculating the VAT-inclusive price from the VAT-exclusive price:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.208.1"># vat.nofunc.py</span></span><span class="koboSpan" id="kobo.209.1">
price = </span><span class="hljs-number"><span class="koboSpan" id="kobo.210.1">100</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.211.1"># GBP, no VAT</span></span><span class="koboSpan" id="kobo.212.1">
final_price1 = price * </span><span class="hljs-number"><span class="koboSpan" id="kobo.213.1">1.2</span></span><span class="koboSpan" id="kobo.214.1">
final_price2 = price + price / </span><span class="hljs-number"><span class="koboSpan" id="kobo.215.1">5.0</span></span><span class="koboSpan" id="kobo.216.1">
final_price3 = price * (</span><span class="hljs-number"><span class="koboSpan" id="kobo.217.1">100</span></span><span class="koboSpan" id="kobo.218.1"> + </span><span class="hljs-number"><span class="koboSpan" id="kobo.219.1">20</span></span><span class="koboSpan" id="kobo.220.1">) / </span><span class="hljs-number"><span class="koboSpan" id="kobo.221.1">100.0</span></span><span class="koboSpan" id="kobo.222.1">
final_price4 = price + price * </span><span class="hljs-number"><span class="koboSpan" id="kobo.223.1">0.2</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.224.1">
     These four different ways of calculating a VAT-inclusive price are all perfectly acceptable; we have encountered all of them in the professional code that we have worked on over the years.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.225.1">
     Now, imagine that we start selling products in different countries, and some of them have different VAT rates, so we need to refactor the code (throughout the website) in order to make that VAT calculation dynamic.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.226.1">
     How do we trace all the places in which we are performing a VAT calculation?
    </span>
    <span class="koboSpan" id="kobo.226.2">
     Coding today is a collaborative task and we cannot be sure that the VAT has been calculated using only one of those forms.
    </span>
    <span class="koboSpan" id="kobo.226.3">
     It is going to be difficult.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.227.1">
     So, let us
    </span>
    <a id="_idIndexMarker389">
    </a>
    <span class="koboSpan" id="kobo.228.1">
     write a function that takes the input values
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.229.1">
      vat
     </span>
    </code>
    <span class="koboSpan" id="kobo.230.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.231.1">
      price
     </span>
    </code>
    <span class="koboSpan" id="kobo.232.1">
     (VAT-exclusive) and returns a VAT-inclusive price:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.233.1"># vat.function.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.234.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.235.1">calculate_price_with_vat</span></span><span class="koboSpan" id="kobo.236.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.237.1">price, vat</span></span><span class="koboSpan" id="kobo.238.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.239.1">return</span></span><span class="koboSpan" id="kobo.240.1"> price * (</span><span class="hljs-number"><span class="koboSpan" id="kobo.241.1">100</span></span><span class="koboSpan" id="kobo.242.1"> + vat) / </span><span class="hljs-number"><span class="koboSpan" id="kobo.243.1">100</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.244.1">
     Now we can import that function and use it in any place on the website where we need to calculate a VAT-inclusive price, and when we need to trace those calls, we can search for
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.245.1">
      calculate_price_with_vat
     </span>
    </code>
    <span class="koboSpan" id="kobo.246.1">
     .
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.247.1">
      Note that, in the preceding example,
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.248.1">
       price
      </span>
     </code>
     <span class="koboSpan" id="kobo.249.1">
      is assumed to be VAT-exclusive, and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.250.1">
       vat
      </span>
     </code>
     <span class="koboSpan" id="kobo.251.1">
      is a percentage value (for example, 19, 20, or 23).
     </span>
    </p>
   </div>
   <h1 class="heading-1" id="_idParaDest-127">
    <span class="koboSpan" id="kobo.252.1">
     Scopes and name resolution
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.253.1">
     In
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.254.1">
      Chapter 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.255.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.256.1">
      A Gentle Introduction to Python
     </span>
    </em>
    <span class="koboSpan" id="kobo.257.1">
     , we discussed scopes
    </span>
    <a id="_idIndexMarker390">
    </a>
    <span class="koboSpan" id="kobo.258.1">
     and namespaces.
    </span>
    <span class="koboSpan" id="kobo.258.2">
     We are going to expand on that concept now.
    </span>
    <span class="koboSpan" id="kobo.258.3">
     Finally, we can talk in terms of functions, and
    </span>
    <a id="_idIndexMarker391">
    </a>
    <span class="koboSpan" id="kobo.259.1">
     this will make everything easier to understand.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     Let us start with a simple example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.260.1"># scoping.level.1.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.261.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.262.1">my_function</span></span><span class="koboSpan" id="kobo.263.1">():
    test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.264.1">1</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.265.1"># this is defined in the local scope of the function</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.266.1">print</span></span><span class="koboSpan" id="kobo.267.1">("my_function:", test)
test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.268.1">0</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.269.1"># this is defined in the global scope</span></span><span class="koboSpan" id="kobo.270.1">
my_function()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.271.1">print</span></span><span class="koboSpan" id="kobo.272.1">("</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.273.1">global</span></span><span class="koboSpan" id="kobo.274.1">:", test)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.275.1">
     We defined the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.276.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.277.1">
     name in two different places in the previous example—it is actually in two different scopes.
    </span>
    <span class="koboSpan" id="kobo.277.2">
     One is the global scope (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.278.1">
      test = 0
     </span>
    </code>
    <span class="koboSpan" id="kobo.279.1">
     ), and the other is the local scope of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.280.1">
      my_function()
     </span>
    </code>
    <span class="koboSpan" id="kobo.281.1">
     function (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.282.1">
      test = 1
     </span>
    </code>
    <span class="koboSpan" id="kobo.283.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.283.2">
     If we execute the code, we will see this:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.284.1">$ python scoping.level.1.py
my_function: 1
global: 0
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.285.1">
     It is clear that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.286.1">
      test = 1
     </span>
    </code>
    <span class="koboSpan" id="kobo.287.1">
     shadows the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.288.1">
      test = 0
     </span>
    </code>
    <span class="koboSpan" id="kobo.289.1">
     assignment in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.290.1">
      my_function()
     </span>
    </code>
    <span class="koboSpan" id="kobo.291.1">
     .
    </span>
    <span class="koboSpan" id="kobo.291.2">
     In the global context,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.292.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.293.1">
     is still
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.294.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.295.1">
     , as you can see from the output of the program, but we define the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.296.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.297.1">
     name again in the function body, and we set it to point to the integer
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.298.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.299.1">
     .
    </span>
    <span class="koboSpan" id="kobo.299.2">
     Both of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.300.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.301.1">
     names therefore exist: one in the global scope, pointing to an int object with a value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.302.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.303.1">
     , and the other in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.304.1">
      my_function()
     </span>
    </code>
    <span class="koboSpan" id="kobo.305.1">
     scope, pointing to an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.306.1">
      int
     </span>
    </code>
    <span class="koboSpan" id="kobo.307.1">
     object with a value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.308.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.309.1">
     .
    </span>
    <span class="koboSpan" id="kobo.309.2">
     Let
    </span>
    <a id="_idIndexMarker392">
    </a>
    <span class="koboSpan" id="kobo.310.1">
     us comment out the line with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.311.1">
      test = 1
     </span>
    </code>
    <span class="koboSpan" id="kobo.312.1">
     .
    </span>
    <span class="koboSpan" id="kobo.312.2">
     Python searches for
    </span>
    <a id="_idIndexMarker393">
    </a>
    <span class="koboSpan" id="kobo.313.1">
     the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.314.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.315.1">
     name in the next enclosing namespace (recall
    </span>
    <a id="_idIndexMarker394">
    </a>
    <span class="koboSpan" id="kobo.316.1">
     the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.317.1">
      LEGB
     </span>
    </strong>
    <span class="koboSpan" id="kobo.318.1">
     rule:
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.319.1">
      local
     </span>
    </strong>
    <span class="koboSpan" id="kobo.320.1">
     ,
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.321.1">
      enclosing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.322.1">
     ,
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.323.1">
      global
     </span>
    </strong>
    <span class="koboSpan" id="kobo.324.1">
     ,
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.325.1">
      built-in
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     , described in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.327.1">
      Chapter 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.328.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.329.1">
      A Gentle Introduction to Python
     </span>
    </em>
    <span class="koboSpan" id="kobo.330.1">
     ) and, in this case, we will see the value
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.331.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.332.1">
     printed twice.
    </span>
    <span class="koboSpan" id="kobo.332.2">
     Try it in your code.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.333.1">
     Now, let us give you a more complex example with nested functions:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.334.1"># scoping.level.2.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.335.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.336.1">outer</span></span><span class="koboSpan" id="kobo.337.1">():
    test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.338.1">1</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.339.1"># outer scope</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.340.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.341.1">inner</span></span><span class="koboSpan" id="kobo.342.1">():
        test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.343.1">2</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.344.1"># inner scope</span></span>
        <span class="hljs-built_in"><span class="koboSpan" id="kobo.345.1">print</span></span><span class="koboSpan" id="kobo.346.1">("inner:", test)
    inner()
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.347.1">print</span></span><span class="koboSpan" id="kobo.348.1">("outer:", test)
test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.349.1">0</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.350.1"># global scope</span></span><span class="koboSpan" id="kobo.351.1">
outer()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.352.1">print</span></span><span class="koboSpan" id="kobo.353.1">("</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.354.1">global</span></span><span class="koboSpan" id="kobo.355.1">:", test)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.356.1">
     In the preceding code, we have two levels of shadowing.
    </span>
    <span class="koboSpan" id="kobo.356.2">
     One level is in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.357.1">
      outer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.358.1">
     function, and the other one is in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.359.1">
      inner()
     </span>
    </code>
    <span class="koboSpan" id="kobo.360.1">
     function.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.361.1">
     If we run the code, we get:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.362.1">$ python scoping.level.2.py
inner: 2
outer: 1
global: 0
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.363.1">
     Try commenting out the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.364.1">
      test = 1
     </span>
    </code>
    <span class="koboSpan" id="kobo.365.1">
     line.
    </span>
    <span class="koboSpan" id="kobo.365.2">
     Can you figure out what the result will be?
    </span>
    <span class="koboSpan" id="kobo.365.3">
     When reaching the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.366.1">
      print('outer:', test)
     </span>
    </code>
    <span class="koboSpan" id="kobo.367.1">
     line, Python will have to look for
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.368.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.369.1">
     in the next enclosing scope; therefore it will find and print
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.370.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.371.1">
     , instead of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.372.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.373.1">
     .
    </span>
    <span class="koboSpan" id="kobo.373.2">
     Make sure you comment out
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.374.1">
      test = 2
     </span>
    </code>
    <span class="koboSpan" id="kobo.375.1">
     as well, to see whether you understand what happens and whether the LEGB rule is clear to you, before proceeding.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.376.1">
     Another thing to note
    </span>
    <a id="_idIndexMarker395">
    </a>
    <span class="koboSpan" id="kobo.377.1">
     is that Python gives us the ability to define a function in another
    </span>
    <a id="_idIndexMarker396">
    </a>
    <span class="koboSpan" id="kobo.378.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.378.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.379.1">
      inner()
     </span>
    </code>
    <span class="koboSpan" id="kobo.380.1">
     function’s name is defined within the namespace of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.381.1">
      outer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.382.1">
     function, exactly as would happen with any other name.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-128">
    <span class="koboSpan" id="kobo.383.1">
     The global and nonlocal statements
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.384.1">
     In the preceding example, we can alter what happens to the shadowing of the test name by using one of these two special
    </span>
    <a id="_idIndexMarker397">
    </a>
    <span class="koboSpan" id="kobo.385.1">
     statements:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.386.1">
      global
     </span>
    </code>
    <span class="koboSpan" id="kobo.387.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.388.1">
      nonlocal
     </span>
    </code>
    <span class="koboSpan" id="kobo.389.1">
     .
    </span>
    <span class="koboSpan" id="kobo.389.2">
     As you can see, when we define
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.390.1">
      test = 2
     </span>
    </code>
    <span class="koboSpan" id="kobo.391.1">
     in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.392.1">
      inner()
     </span>
    </code>
    <span class="koboSpan" id="kobo.393.1">
     function, we do not overwrite
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.394.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.395.1">
     in
    </span>
    <a id="_idIndexMarker398">
    </a>
    <span class="koboSpan" id="kobo.396.1">
     the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.397.1">
      outer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.398.1">
     function or in the global scope.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.399.1">
     We can get read access to those names if we use them in a nested scope that does not define them, but we cannot modify them because when we write an assignment instruction, we are actually defining a new name in the current scope.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.400.1">
     We can use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.401.1">
      nonlocal
     </span>
    </code>
    <span class="koboSpan" id="kobo.402.1">
     statement
    </span>
    <a id="_idIndexMarker399">
    </a>
    <span class="koboSpan" id="kobo.403.1">
     to change this behavior.
    </span>
    <span class="koboSpan" id="kobo.403.2">
     According
    </span>
    <a id="_idIndexMarker400">
    </a>
    <span class="koboSpan" id="kobo.404.1">
     to the official documentation:
    </span>
   </p>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.405.1">
      ”The
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.406.1">
       nonlocal
      </span>
     </code>
     <span class="koboSpan" id="kobo.407.1">
      statement causes the listed identifiers to refer to previously bound variables in the nearest enclosing scope excluding globals.”
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.408.1">
     Let us introduce it in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.409.1">
      inner()
     </span>
    </code>
    <span class="koboSpan" id="kobo.410.1">
     function and see what happens:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.411.1"># scoping.level.2.nonlocal.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.412.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.413.1">outer</span></span><span class="koboSpan" id="kobo.414.1">():
    test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.415.1">1</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.416.1"># outer scope</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.417.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.418.1">inner</span></span><span class="koboSpan" id="kobo.419.1">():
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.420.1">nonlocal</span></span><span class="koboSpan" id="kobo.421.1"> test
        test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.422.1">2</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.423.1"># nearest enclosing scope (which is 'outer')</span></span>
        <span class="hljs-built_in"><span class="koboSpan" id="kobo.424.1">print</span></span><span class="koboSpan" id="kobo.425.1">("inner:", test)
    inner()
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.426.1">print</span></span><span class="koboSpan" id="kobo.427.1">("outer:", test)
test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.428.1">0</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.429.1"># global scope</span></span><span class="koboSpan" id="kobo.430.1">
outer()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.431.1">print</span></span><span class="koboSpan" id="kobo.432.1">("</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.433.1">global</span></span><span class="koboSpan" id="kobo.434.1">:", test)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.435.1">
     Notice how in the body of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.436.1">
      inner()
     </span>
    </code>
    <span class="koboSpan" id="kobo.437.1">
     function we have declared the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.438.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.439.1">
     name to be
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.440.1">
      nonlocal
     </span>
    </code>
    <span class="koboSpan" id="kobo.441.1">
     .
    </span>
    <span class="koboSpan" id="kobo.441.2">
     Running this
    </span>
    <a id="_idIndexMarker401">
    </a>
    <span class="koboSpan" id="kobo.442.1">
     code produces
    </span>
    <a id="_idIndexMarker402">
    </a>
    <span class="koboSpan" id="kobo.443.1">
     the following result:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.444.1">$ python scoping.level.2.nonlocal.py
inner: 2
outer: 2
global: 0
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.445.1">
     By declaring
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.446.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.447.1">
     to be
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.448.1">
      nonlocal
     </span>
    </code>
    <span class="koboSpan" id="kobo.449.1">
     in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.450.1">
      inner()
     </span>
    </code>
    <span class="koboSpan" id="kobo.451.1">
     function, we actually bind the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.452.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.453.1">
     name to the one declared in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.454.1">
      outer
     </span>
    </code>
    <span class="koboSpan" id="kobo.455.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.455.2">
     If we removed the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.456.1">
      nonlocal test
     </span>
    </code>
    <span class="koboSpan" id="kobo.457.1">
     line from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.458.1">
      inner()
     </span>
    </code>
    <span class="koboSpan" id="kobo.459.1">
     function and tried it inside
    </span>
    <a id="_idIndexMarker403">
    </a>
    <span class="koboSpan" id="kobo.460.1">
     the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.461.1">
      outer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.462.1">
     function, we would get a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.463.1">
      SyntaxError
     </span>
    </code>
    <span class="koboSpan" id="kobo.464.1">
     , because the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.465.1">
      nonlocal
     </span>
    </code>
    <span class="koboSpan" id="kobo.466.1">
     statement works on enclosing scopes, but not in the global one.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.467.1">
     Is there a way to get write access
    </span>
    <a id="_idIndexMarker404">
    </a>
    <span class="koboSpan" id="kobo.468.1">
     to that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.469.1">
      test = 0
     </span>
    </code>
    <span class="koboSpan" id="kobo.470.1">
     in the global namespace?
    </span>
    <span class="koboSpan" id="kobo.470.2">
     Yes, we just need to use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.471.1">
      global
     </span>
    </code>
    <span class="koboSpan" id="kobo.472.1">
     statement:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.473.1"># scoping.level.2.global.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.474.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.475.1">outer</span></span><span class="koboSpan" id="kobo.476.1">():
    test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.477.1">1</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.478.1"># outer scope</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.479.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.480.1">inner</span></span><span class="koboSpan" id="kobo.481.1">():
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.482.1">global</span></span><span class="koboSpan" id="kobo.483.1"> test
        test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.484.1">2</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.485.1"># global scope</span></span>
        <span class="hljs-built_in"><span class="koboSpan" id="kobo.486.1">print</span></span><span class="koboSpan" id="kobo.487.1">("inner:", test)
    inner()
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.488.1">print</span></span><span class="koboSpan" id="kobo.489.1">("outer:", test)
test = </span><span class="hljs-number"><span class="koboSpan" id="kobo.490.1">0</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.491.1"># global scope</span></span><span class="koboSpan" id="kobo.492.1">
outer()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.493.1">print</span></span><span class="koboSpan" id="kobo.494.1">("</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.495.1">global</span></span><span class="koboSpan" id="kobo.496.1">:", test)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.497.1">
     Note that we have now declared the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.498.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.499.1">
     name to be
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.500.1">
      global
     </span>
    </code>
    <span class="koboSpan" id="kobo.501.1">
     , which will bind it to the one we defined in the global namespace (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.502.1">
      test = 0
     </span>
    </code>
    <span class="koboSpan" id="kobo.503.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.503.2">
     Run the code and you should get the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.504.1">$ python scoping.level.2.global.py
inner: 2
outer: 1
global: 2
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.505.1">
     This shows that the name affected by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.506.1">
      test = 2
     </span>
    </code>
    <span class="koboSpan" id="kobo.507.1">
     assignment is now the one in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.508.1">
      global
     </span>
    </code>
    <span class="koboSpan" id="kobo.509.1">
     scope.
    </span>
    <span class="koboSpan" id="kobo.509.2">
     This would also work in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.510.1">
      outer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.511.1">
     function because, in this case, we are referring to the global scope.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.512.1">
     Try it for yourself and see what
    </span>
    <a id="_idIndexMarker405">
    </a>
    <span class="koboSpan" id="kobo.513.1">
     changes.
    </span>
    <span class="koboSpan" id="kobo.513.2">
     Spend some time to get comfortable with scopes and
    </span>
    <a id="_idIndexMarker406">
    </a>
    <span class="koboSpan" id="kobo.514.1">
     name resolution—it is very important.
    </span>
    <span class="koboSpan" id="kobo.514.2">
     As a bonus
    </span>
    <a id="_idIndexMarker407">
    </a>
    <span class="koboSpan" id="kobo.515.1">
     question, can you tell what would happen if you
    </span>
    <a id="_idIndexMarker408">
    </a>
    <span class="koboSpan" id="kobo.516.1">
     defined
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.517.1">
      inner()
     </span>
    </code>
    <span class="koboSpan" id="kobo.518.1">
     outside
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.519.1">
      outer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.520.1">
     in the preceding examples?
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-129">
    <span class="koboSpan" id="kobo.521.1">
     Input parameters
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.522.1">
     At the
    </span>
    <a id="_idIndexMarker409">
    </a>
    <span class="koboSpan" id="kobo.523.1">
     beginning of this chapter, we saw that a function can take input
    </span>
    <a id="_idIndexMarker410">
    </a>
    <span class="koboSpan" id="kobo.524.1">
     parameters.
    </span>
    <span class="koboSpan" id="kobo.524.2">
     Before we delve into all the possible types of parameters, let us make sure you have a clear understanding of what passing an argument to a function means.
    </span>
    <span class="koboSpan" id="kobo.524.3">
     There are three key points to keep in mind:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.525.1">
      Argument-passing is nothing more than assigning an object to a local variable name
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.526.1">
      Assigning an object to an argument name inside a function does not affect the caller
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.527.1">
      Changing a mutable object argument in a function does affect the caller
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.528.1">
     Before we explore the topic of arguments any further, please allow us to clarify the terminology a little.
    </span>
    <span class="koboSpan" id="kobo.528.2">
     According to the official Python documentation:
    </span>
   </p>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.529.1">
      ”Parameters are defined by the names that appear in a function definition, whereas arguments are the values actually passed to a function when calling it.
     </span>
     <span class="koboSpan" id="kobo.529.2">
      Parameters define what types of arguments a function can accept.”
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.530.1">
     We will try to be precise when referring to parameters and arguments, but it is worth noting that they are sometimes used synonymously as well.
    </span>
    <span class="koboSpan" id="kobo.530.2">
     Let us now look at some examples.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-130">
    <span class="koboSpan" id="kobo.531.1">
     Argument-passing
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.532.1">
     Take a look at the following
    </span>
    <a id="_idIndexMarker411">
    </a>
    <span class="koboSpan" id="kobo.533.1">
     code.
    </span>
    <span class="koboSpan" id="kobo.533.2">
     We declare a name,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.534.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.535.1">
     , in the global scope, then we declare a function,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.536.1">
      func(y)
     </span>
    </code>
    <span class="koboSpan" id="kobo.537.1">
     , and finally, we call it, passing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.538.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.539.1">
     :
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.540.1"># key.points.argument.passing.py</span></span><span class="koboSpan" id="kobo.541.1">
x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.542.1">3</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.543.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.544.1">func</span></span><span class="koboSpan" id="kobo.545.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.546.1">y</span></span><span class="koboSpan" id="kobo.547.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.548.1">print</span></span><span class="koboSpan" id="kobo.549.1">(y)
func(x)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.550.1"># prints: 3</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.551.1">
     When
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.552.1">
      func()
     </span>
    </code>
    <span class="koboSpan" id="kobo.553.1">
     is called with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.554.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.555.1">
     , within its local scope, a name,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.556.1">
      y
     </span>
    </code>
    <span class="koboSpan" id="kobo.557.1">
     , is created, and it is pointed to the same object that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.558.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.559.1">
     is pointing to.
    </span>
    <span class="koboSpan" id="kobo.559.2">
     This is better clarified in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.560.1">
      Figure 4.2
     </span>
    </em>
    <span class="koboSpan" id="kobo.561.1">
     (do not worry about the fact that this example was run with Python 3.11—this is a feature that has not changed).
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.562.1">
     <img alt="img" src="../Images/B30992_04_02.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.563.1">
     Figure 4.2: Understanding argument-passing with Python Tutor
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.564.1">
     The
    </span>
    <a id="_idIndexMarker412">
    </a>
    <span class="koboSpan" id="kobo.565.1">
     right-hand side of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.566.1">
      Figure 4.2
     </span>
    </em>
    <span class="koboSpan" id="kobo.567.1">
     depicts the state of the program when execution has reached the end, after
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.568.1">
      func()
     </span>
    </code>
    <span class="koboSpan" id="kobo.569.1">
     has returned (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.570.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.571.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.571.2">
     Take a look at the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.572.1">
      Frames
     </span>
    </strong>
    <span class="koboSpan" id="kobo.573.1">
     column, and note that we have two names,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.574.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.575.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.576.1">
      func()
     </span>
    </code>
    <span class="koboSpan" id="kobo.577.1">
     , in the global namespace (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.578.1">
      Global frame
     </span>
    </strong>
    <span class="koboSpan" id="kobo.579.1">
     ), pointing respectively to an
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.580.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.581.1">
     (with a value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.582.1">
      3
     </span>
    </code>
    <span class="koboSpan" id="kobo.583.1">
     ) and to a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.584.1">
      function
     </span>
    </code>
    <span class="koboSpan" id="kobo.585.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.585.2">
     Right beneath it, in the rectangle titled
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.586.1">
      func
     </span>
    </strong>
    <span class="koboSpan" id="kobo.587.1">
     , we can see the function’s local namespace, in which only one name has been defined:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.588.1">
      y
     </span>
    </code>
    <span class="koboSpan" id="kobo.589.1">
     .
    </span>
    <span class="koboSpan" id="kobo.589.2">
     Because we have called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.590.1">
      func()
     </span>
    </code>
    <span class="koboSpan" id="kobo.591.1">
     with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.592.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.593.1">
     (line 6 on the left side of the figure),
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.594.1">
      y
     </span>
    </code>
    <span class="koboSpan" id="kobo.595.1">
     is pointing to the same object that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.596.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.597.1">
     is.
    </span>
    <span class="koboSpan" id="kobo.597.2">
     This is what happens under the hood when an argument is passed to a function.
    </span>
    <span class="koboSpan" id="kobo.597.3">
     If we had used the name
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.598.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.599.1">
     instead of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.600.1">
      y
     </span>
    </code>
    <span class="koboSpan" id="kobo.601.1">
     in the function definition, things would have been exactly the same (but perhaps a bit confusing at first)—there would be a local
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.602.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.603.1">
     in the function, and a global
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.604.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.605.1">
     outside, as we saw in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.606.1">
      Scopes and name resolution
     </span>
    </em>
    <span class="koboSpan" id="kobo.607.1">
     section previously in this chapter.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.608.1">
     So, in a nutshell, what really happens is that the function creates, in its local scope, the names defined as parameters and, when we call it, we tell Python which objects those names must be pointed toward.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-131">
    <span class="koboSpan" id="kobo.609.1">
     Assignment to parameter names
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.610.1">
     Assignment
    </span>
    <a id="_idIndexMarker413">
    </a>
    <span class="koboSpan" id="kobo.611.1">
     to parameter names does not affect the caller.
    </span>
    <span class="koboSpan" id="kobo.611.2">
     This is something that can be tricky to understand at first, so let us look at an example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.612.1"># key.points.assignment.py</span></span><span class="koboSpan" id="kobo.613.1">
x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.614.1">3</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.615.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.616.1">func</span></span><span class="koboSpan" id="kobo.617.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.618.1">x</span></span><span class="koboSpan" id="kobo.619.1">):
    x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.620.1">7</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.621.1"># defining a local x, not changing the global one</span></span><span class="koboSpan" id="kobo.622.1">
func(x)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.623.1">print</span></span><span class="koboSpan" id="kobo.624.1">(x)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.625.1"># prints: 3</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.626.1">
     In the preceding code, when we call the function with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.627.1">
      func(x)
     </span>
    </code>
    <span class="koboSpan" id="kobo.628.1">
     , the instruction
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.629.1">
      x = 7
     </span>
    </code>
    <span class="koboSpan" id="kobo.630.1">
     is executed within the local scope of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.631.1">
      func()
     </span>
    </code>
    <span class="koboSpan" id="kobo.632.1">
     function; the name
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.633.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.634.1">
     is pointed to an integer with a value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.635.1">
      7
     </span>
    </code>
    <span class="koboSpan" id="kobo.636.1">
     , leaving the global
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.637.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.638.1">
     unaltered.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-132">
    <span class="koboSpan" id="kobo.639.1">
     Changing a mutable object
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.640.1">
     Changing a mutable
    </span>
    <a id="_idIndexMarker414">
    </a>
    <span class="koboSpan" id="kobo.641.1">
     object does affect the caller.
    </span>
    <span class="koboSpan" id="kobo.641.2">
     This is important because although Python
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.642.1">
      appears to
     </span>
    </em>
    <span class="koboSpan" id="kobo.643.1">
     behave differently with mutable objects, the behavior is, in fact, perfectly consistent.
    </span>
    <span class="koboSpan" id="kobo.643.2">
     Let us look at an example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.644.1"># key.points.mutable.py</span></span><span class="koboSpan" id="kobo.645.1">
x = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.646.1">1</span></span><span class="koboSpan" id="kobo.647.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.648.1">2</span></span><span class="koboSpan" id="kobo.649.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.650.1">3</span></span><span class="koboSpan" id="kobo.651.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.652.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.653.1">func</span></span><span class="koboSpan" id="kobo.654.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.655.1">x</span></span><span class="koboSpan" id="kobo.656.1">):
    x[</span><span class="hljs-number"><span class="koboSpan" id="kobo.657.1">1</span></span><span class="koboSpan" id="kobo.658.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.659.1">42</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.660.1"># this affects the `x` argument!</span></span><span class="koboSpan" id="kobo.661.1">
func(x)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.662.1">print</span></span><span class="koboSpan" id="kobo.663.1">(x)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.664.1"># prints: [1, 42, 3]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.665.1">
     As you can see, we changed the original object.
    </span>
    <span class="koboSpan" id="kobo.665.2">
     If you think about it, there is nothing weird in this behavior.
    </span>
    <span class="koboSpan" id="kobo.665.3">
     When we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.666.1">
      func(x)
     </span>
    </code>
    <span class="koboSpan" id="kobo.667.1">
     , name
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.668.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.669.1">
     in the function’s namespace is set to point to the same object as the global
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.670.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.671.1">
     .
    </span>
    <span class="koboSpan" id="kobo.671.2">
     Within the body of the function, we are not changing the global
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.672.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.673.1">
     , in that we are not changing which object it points to.
    </span>
    <span class="koboSpan" id="kobo.673.2">
     We are merely accessing the element at position 1 in that object and changing its value.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.674.1">
     Remember
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.675.1">
      point 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.676.1">
     in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.677.1">
      Input parameters
     </span>
    </em>
    <span class="koboSpan" id="kobo.678.1">
     section:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.679.1">
      Assigning an object to a parameter name within a function does not affect the caller
     </span>
    </em>
    <span class="koboSpan" id="kobo.680.1">
     .
    </span>
    <span class="koboSpan" id="kobo.680.2">
     If that is clear to you, the following code should not be
    </span>
    <a id="_idIndexMarker415">
    </a>
    <span class="koboSpan" id="kobo.681.1">
     surprising:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.682.1"># key.points.mutable.assignment.py</span></span><span class="koboSpan" id="kobo.683.1">
x = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.684.1">1</span></span><span class="koboSpan" id="kobo.685.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.686.1">2</span></span><span class="koboSpan" id="kobo.687.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.688.1">3</span></span><span class="koboSpan" id="kobo.689.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.690.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.691.1">func</span></span><span class="koboSpan" id="kobo.692.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.693.1">x</span></span><span class="koboSpan" id="kobo.694.1">):
    x[</span><span class="hljs-number"><span class="koboSpan" id="kobo.695.1">1</span></span><span class="koboSpan" id="kobo.696.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.697.1">42</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.698.1"># this changes the original `x` argument!</span></span><span class="koboSpan" id="kobo.699.1">
    x = "something </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.700.1">else</span></span><span class="koboSpan" id="kobo.701.1">"  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.702.1"># this points x to a new string object</span></span><span class="koboSpan" id="kobo.703.1">
func(x)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.704.1">print</span></span><span class="koboSpan" id="kobo.705.1">(x)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.706.1"># still prints: [1, 42, 3]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.707.1">
     Look at the two lines we have highlighted.
    </span>
    <span class="koboSpan" id="kobo.707.2">
     At first, like before, we just access the caller object again, at position 1, and change that value to number
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.708.1">
      42
     </span>
    </code>
    <span class="koboSpan" id="kobo.709.1">
     .
    </span>
    <span class="koboSpan" id="kobo.709.2">
     Then, we reassign
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.710.1">
      x
     </span>
    </code>
    <span class="koboSpan" id="kobo.711.1">
     to point to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.712.1">
      'something else'
     </span>
    </code>
    <span class="koboSpan" id="kobo.713.1">
     string.
    </span>
    <span class="koboSpan" id="kobo.713.2">
     This leaves the caller unaltered and, in fact, the output is the same as that of the previous snippet.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.714.1">
     Take your time to play around with this concept, and experiment with prints and calls to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.715.1">
      id()
     </span>
    </code>
    <span class="koboSpan" id="kobo.716.1">
     function until everything is clear in your mind.
    </span>
    <span class="koboSpan" id="kobo.716.2">
     This is one of the key aspects of Python and it must be very clear, otherwise you risk introducing subtle bugs into your code.
    </span>
    <span class="koboSpan" id="kobo.716.3">
     Once again, the Python Tutor
    </span>
    <a id="_idIndexMarker416">
    </a>
    <span class="koboSpan" id="kobo.717.1">
     website (
    </span>
    <a href="http://www.pythontutor.com/">
     <span class="url">
      <span class="koboSpan" id="kobo.718.1">
       http://www.pythontutor.com/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.719.1">
     ) will help you a lot by giving you a visual representation of these concepts.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.720.1">
     Now that we have a good understanding of input parameters and how they behave, let us look at the different ways of passing arguments to functions.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-133">
    <span class="koboSpan" id="kobo.721.1">
     Passing arguments
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.722.1">
     There are four different ways of passing
    </span>
    <a id="_idIndexMarker417">
    </a>
    <span class="koboSpan" id="kobo.723.1">
     arguments to a function:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.724.1">
      Positional arguments
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.725.1">
      Keyword arguments
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.726.1">
      Iterable unpacking
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.727.1">
      Dictionary unpacking
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.728.1">
     Let us look at them one by one.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-134">
    <span class="koboSpan" id="kobo.729.1">
     Positional arguments
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.730.1">
     When we call a
    </span>
    <a id="_idIndexMarker418">
    </a>
    <span class="koboSpan" id="kobo.731.1">
     function, each positional argument
    </span>
    <a id="_idIndexMarker419">
    </a>
    <span class="koboSpan" id="kobo.732.1">
     is assigned to the parameter in the corresponding
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.733.1">
      position
     </span>
    </em>
    <span class="koboSpan" id="kobo.734.1">
     in the function definition:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.735.1"># arguments.positional.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.736.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.737.1">func</span></span><span class="koboSpan" id="kobo.738.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.739.1">a, b, c</span></span><span class="koboSpan" id="kobo.740.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.741.1">print</span></span><span class="koboSpan" id="kobo.742.1">(a, b, c)
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.743.1">1</span></span><span class="koboSpan" id="kobo.744.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.745.1">2</span></span><span class="koboSpan" id="kobo.746.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.747.1">3</span></span><span class="koboSpan" id="kobo.748.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.749.1"># prints: 1 2 3</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.750.1">
     This is the most common way of passing arguments to functions (in some programming languages, this is the only way of passing arguments).
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-135">
    <span class="koboSpan" id="kobo.751.1">
     Keyword arguments
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.752.1">
     Keyword arguments
    </span>
    <a id="_idIndexMarker420">
    </a>
    <span class="koboSpan" id="kobo.753.1">
     in a
    </span>
    <a id="_idIndexMarker421">
    </a>
    <span class="koboSpan" id="kobo.754.1">
     function call are assigned to parameters using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.755.1">
      name=value
     </span>
    </code>
    <span class="koboSpan" id="kobo.756.1">
     syntax:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.757.1"># arguments.keyword.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.758.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.759.1">func</span></span><span class="koboSpan" id="kobo.760.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.761.1">a, b, c</span></span><span class="koboSpan" id="kobo.762.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.763.1">print</span></span><span class="koboSpan" id="kobo.764.1">(a, b, c)
func(a=</span><span class="hljs-number"><span class="koboSpan" id="kobo.765.1">1</span></span><span class="koboSpan" id="kobo.766.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.767.1">2</span></span><span class="koboSpan" id="kobo.768.1">, b=</span><span class="hljs-number"><span class="koboSpan" id="kobo.769.1">3</span></span><span class="koboSpan" id="kobo.770.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.771.1"># prints: 1 3 2</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.772.1">
     When we use keyword arguments, the order of the arguments does not need to match the order of the parameters in the function definition.
    </span>
    <span class="koboSpan" id="kobo.772.2">
     This can make our code easier to read and debug.
    </span>
    <span class="koboSpan" id="kobo.772.3">
     We do not need to remember (or look up) the order of parameters in a function definition.
    </span>
    <span class="koboSpan" id="kobo.772.4">
     We can look at a function call and immediately know which argument corresponds to which parameter.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.773.1">
     You can also use both positional and keyword arguments at the same time:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.774.1"># arguments.positional.keyword.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.775.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.776.1">func</span></span><span class="koboSpan" id="kobo.777.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.778.1">a, b, c</span></span><span class="koboSpan" id="kobo.779.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.780.1">print</span></span><span class="koboSpan" id="kobo.781.1">(a, b, c)
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.782.1">42</span></span><span class="koboSpan" id="kobo.783.1">, b=</span><span class="hljs-number"><span class="koboSpan" id="kobo.784.1">1</span></span><span class="koboSpan" id="kobo.785.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.786.1">2</span></span><span class="koboSpan" id="kobo.787.1">)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.788.1">
     Keep in
    </span>
    <a id="_idIndexMarker422">
    </a>
    <span class="koboSpan" id="kobo.789.1">
     mind, however, that
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.790.1">
      positional arguments always have to be listed before any keyword arguments
     </span>
    </strong>
    <span class="koboSpan" id="kobo.791.1">
     .
    </span>
    <span class="koboSpan" id="kobo.791.2">
     For example, if you try something
    </span>
    <a id="_idIndexMarker423">
    </a>
    <span class="koboSpan" id="kobo.792.1">
     like this:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.793.1"># arguments.positional.keyword.py</span></span><span class="koboSpan" id="kobo.794.1">
func(b=</span><span class="hljs-number"><span class="koboSpan" id="kobo.795.1">1</span></span><span class="koboSpan" id="kobo.796.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.797.1">2</span></span><span class="koboSpan" id="kobo.798.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.799.1">42</span></span><span class="koboSpan" id="kobo.800.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.801.1"># positional arg after keyword args</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.802.1">
     You will get the following error:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.803.1">$ python arguments.positional.keyword.py
  File "arguments.positional.keyword.py", line 7
    func(b=1, c=2, 42)  # positional arg after keyword args
                     ^
SyntaxError: positional argument follows keyword argument
</span></code></pre>
   <h3 class="heading-3" id="_idParaDest-136">
    <span class="koboSpan" id="kobo.804.1">
     Iterable unpacking
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.805.1">
     Iterable unpacking
    </span>
    <a id="_idIndexMarker424">
    </a>
    <span class="koboSpan" id="kobo.806.1">
     uses the syntax
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.807.1">
      *iterable_name
     </span>
    </code>
    <span class="koboSpan" id="kobo.808.1">
     to pass the elements of an
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.809.1">
      iterable
     </span>
    </em>
    <span class="koboSpan" id="kobo.810.1">
     as positional arguments to a function:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.811.1"># arguments.unpack.iterable.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.812.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.813.1">func</span></span><span class="koboSpan" id="kobo.814.1">(a, b, c):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.815.1">print</span></span><span class="koboSpan" id="kobo.816.1">(a, b, c)
values = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.817.1">1</span></span><span class="koboSpan" id="kobo.818.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.819.1">3</span></span><span class="koboSpan" id="kobo.820.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.821.1">-7</span></span><span class="koboSpan" id="kobo.822.1">)
</span><span class="hljs-title"><span class="koboSpan" id="kobo.823.1">func</span></span><span class="koboSpan" id="kobo.824.1">(*values)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.825.1"># equivalent to: func(1, 3, -7)</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.826.1">
     This is a very useful feature, particularly when we need to programmatically generate arguments for a function.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-137">
    <span class="koboSpan" id="kobo.827.1">
     Dictionary unpacking
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.828.1">
     Dictionary unpacking is to
    </span>
    <a id="_idIndexMarker425">
    </a>
    <span class="koboSpan" id="kobo.829.1">
     keyword arguments what iterable unpacking is to positional arguments.
    </span>
    <span class="koboSpan" id="kobo.829.2">
     We use the syntax
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.830.1">
      **dictionary_name
     </span>
    </code>
    <span class="koboSpan" id="kobo.831.1">
     to pass keyword arguments, constructed from the keys and values of a dictionary, to a function:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.832.1"># arguments.unpack.dict.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.833.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.834.1">func</span></span><span class="koboSpan" id="kobo.835.1">(a, b, c):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.836.1">print</span></span><span class="koboSpan" id="kobo.837.1">(a, b, c)
values = {"b": </span><span class="hljs-number"><span class="koboSpan" id="kobo.838.1">1</span></span><span class="koboSpan" id="kobo.839.1">, "c": </span><span class="hljs-number"><span class="koboSpan" id="kobo.840.1">2</span></span><span class="koboSpan" id="kobo.841.1">, "a": </span><span class="hljs-number"><span class="koboSpan" id="kobo.842.1">42</span></span><span class="koboSpan" id="kobo.843.1">}
</span><span class="hljs-title"><span class="koboSpan" id="kobo.844.1">func</span></span><span class="koboSpan" id="kobo.845.1">(**values)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.846.1"># equivalent to func(b=1, c=2, a=42)</span></span>
</code></pre>
   <h3 class="heading-3" id="_idParaDest-138">
    <span class="koboSpan" id="kobo.847.1">
     Combining argument types
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.848.1">
     We have already seen that positional and
    </span>
    <a id="_idIndexMarker426">
    </a>
    <span class="koboSpan" id="kobo.849.1">
     keyword arguments can be used together, as long as they are passed in the proper order.
    </span>
    <span class="koboSpan" id="kobo.849.2">
     We can also combine unpacking (of both kinds) with normal positional and keyword arguments.
    </span>
    <span class="koboSpan" id="kobo.849.3">
     We can even combine unpacking multiple iterables and dictionaries.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.850.1">
     Arguments must be passed in the following order:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.851.1">
      First, positional arguments: both ordinary (
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.852.1">
       name
      </span>
     </code>
     <span class="koboSpan" id="kobo.853.1">
      ) and iterable unpacking (
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.854.1">
       *name
      </span>
     </code>
     <span class="koboSpan" id="kobo.855.1">
      )
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.856.1">
      Next come keyword arguments (
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.857.1">
       name=value
      </span>
     </code>
     <span class="koboSpan" id="kobo.858.1">
      ), which can be mixed with iterable unpacking
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.859.1">
       (*name
      </span>
     </code>
     <span class="koboSpan" id="kobo.860.1">
      )
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.861.1">
      Finally, there is dictionary unpacking (
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.862.1">
       **name
      </span>
     </code>
     <span class="koboSpan" id="kobo.863.1">
      ), which can be mixed with keyword arguments (
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.864.1">
       name=value
      </span>
     </code>
     <span class="koboSpan" id="kobo.865.1">
      )
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.866.1">
     This will be much easier to understand with an example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.867.1"># arguments.combined.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.868.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.869.1">func</span></span><span class="koboSpan" id="kobo.870.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.871.1">a, b, c, d, e, f</span></span><span class="koboSpan" id="kobo.872.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.873.1">print</span></span><span class="koboSpan" id="kobo.874.1">(a, b, c, d, e, f)
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.875.1">1</span></span><span class="koboSpan" id="kobo.876.1">, *(</span><span class="hljs-number"><span class="koboSpan" id="kobo.877.1">2</span></span><span class="koboSpan" id="kobo.878.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.879.1">3</span></span><span class="koboSpan" id="kobo.880.1">), f=</span><span class="hljs-number"><span class="koboSpan" id="kobo.881.1">6</span></span><span class="koboSpan" id="kobo.882.1">, *(</span><span class="hljs-number"><span class="koboSpan" id="kobo.883.1">4</span></span><span class="koboSpan" id="kobo.884.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.885.1">5</span></span><span class="koboSpan" id="kobo.886.1">))
func(*(</span><span class="hljs-number"><span class="koboSpan" id="kobo.887.1">1</span></span><span class="koboSpan" id="kobo.888.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.889.1">2</span></span><span class="koboSpan" id="kobo.890.1">), e=</span><span class="hljs-number"><span class="koboSpan" id="kobo.891.1">5</span></span><span class="koboSpan" id="kobo.892.1">, *(</span><span class="hljs-number"><span class="koboSpan" id="kobo.893.1">3</span></span><span class="koboSpan" id="kobo.894.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.895.1">4</span></span><span class="koboSpan" id="kobo.896.1">), f=</span><span class="hljs-number"><span class="koboSpan" id="kobo.897.1">6</span></span><span class="koboSpan" id="kobo.898.1">)
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.899.1">1</span></span><span class="koboSpan" id="kobo.900.1">, **{"b": </span><span class="hljs-number"><span class="koboSpan" id="kobo.901.1">2</span></span><span class="koboSpan" id="kobo.902.1">, "c": </span><span class="hljs-number"><span class="koboSpan" id="kobo.903.1">3</span></span><span class="koboSpan" id="kobo.904.1">}, d=</span><span class="hljs-number"><span class="koboSpan" id="kobo.905.1">4</span></span><span class="koboSpan" id="kobo.906.1">, **{"e": </span><span class="hljs-number"><span class="koboSpan" id="kobo.907.1">5</span></span><span class="koboSpan" id="kobo.908.1">, "f": </span><span class="hljs-number"><span class="koboSpan" id="kobo.909.1">6</span></span><span class="koboSpan" id="kobo.910.1">})
func(c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.911.1">3</span></span><span class="koboSpan" id="kobo.912.1">, *(</span><span class="hljs-number"><span class="koboSpan" id="kobo.913.1">1</span></span><span class="koboSpan" id="kobo.914.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.915.1">2</span></span><span class="koboSpan" id="kobo.916.1">), **{"d": </span><span class="hljs-number"><span class="koboSpan" id="kobo.917.1">4</span></span><span class="koboSpan" id="kobo.918.1">}, e=</span><span class="hljs-number"><span class="koboSpan" id="kobo.919.1">5</span></span><span class="koboSpan" id="kobo.920.1">, **{"f": </span><span class="hljs-number"><span class="koboSpan" id="kobo.921.1">6</span></span><span class="koboSpan" id="kobo.922.1">})
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.923.1">
     All the above calls to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.924.1">
      func()
     </span>
    </code>
    <span class="koboSpan" id="kobo.925.1">
     are equivalent and print
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.926.1">
      1 2 3 4 5 6
     </span>
    </code>
    <span class="koboSpan" id="kobo.927.1">
     .
    </span>
    <span class="koboSpan" id="kobo.927.2">
     Play around with this example until you are sure you understand it.
    </span>
    <span class="koboSpan" id="kobo.927.3">
     Pay close attention to the errors you get when you get the order wrong.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.928.1">
      The ability to unpack multiple iterables and dictionaries was introduced to Python by PEP 448.
     </span>
     <span class="koboSpan" id="kobo.928.2">
      This PEP also introduced the ability to use unpacking in contexts other than just
     </span>
     <a id="_idIndexMarker427">
     </a>
     <span class="koboSpan" id="kobo.929.1">
      function calls.
     </span>
     <span class="koboSpan" id="kobo.929.2">
      You can read all about it at
     </span>
     <a href="https://peps.python.org/pep-0448/">
      <span class="url">
       <span class="koboSpan" id="kobo.930.1">
        https://peps.python.org/pep-0448/
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.931.1">
      .
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.932.1">
     When combining positional and keyword arguments, it is important to remember that each parameter can only appear once in the argument list:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.933.1"># arguments.multiple.value.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.934.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.935.1">func</span></span><span class="koboSpan" id="kobo.936.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.937.1">a, b, c</span></span><span class="koboSpan" id="kobo.938.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.939.1">print</span></span><span class="koboSpan" id="kobo.940.1">(a, b, c)
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.941.1">2</span></span><span class="koboSpan" id="kobo.942.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.943.1">3</span></span><span class="koboSpan" id="kobo.944.1">, a=</span><span class="hljs-number"><span class="koboSpan" id="kobo.945.1">1</span></span><span class="koboSpan" id="kobo.946.1">)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.947.1">
     Here, we are passing
    </span>
    <a id="_idIndexMarker428">
    </a>
    <span class="koboSpan" id="kobo.948.1">
     two values for parameter
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.949.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.950.1">
     : the positional argument
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.951.1">
      2
     </span>
    </code>
    <span class="koboSpan" id="kobo.952.1">
     and the keyword argument
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.953.1">
      a=1
     </span>
    </code>
    <span class="koboSpan" id="kobo.954.1">
     .
    </span>
    <span class="koboSpan" id="kobo.954.2">
     This is illegal, so we get an error when we try to run it:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.955.1">$ python arguments.multiple.value.py
Traceback (most recent call last):
  File "arguments.multiple.value.py", line 5, in &lt;module&gt;
    func(2, 3, a=1)
TypeError: func() got multiple values for argument 'a'
</span></code></pre>
   <h2 class="heading-2" id="_idParaDest-139">
    <span class="koboSpan" id="kobo.956.1">
     Defining parameters
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.957.1">
     Function parameters
    </span>
    <a id="_idIndexMarker429">
    </a>
    <span class="koboSpan" id="kobo.958.1">
     can be classified into five groups.
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.959.1">
      Positional or keyword parameters: allow both positional and keyword arguments
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.960.1">
      Variable positional parameters: collect an arbitrary number of positional arguments in a tuple
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.961.1">
      Variable keyword parameters: collect an arbitrary number of keyword arguments in a dictionary
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.962.1">
      Positional-only parameters: can only be passed as positional arguments
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.963.1">
      Keyword-only parameters: can only be passed as keyword arguments
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.964.1">
     All the parameters in
    </span>
    <a id="_idIndexMarker430">
    </a>
    <span class="koboSpan" id="kobo.965.1">
     the examples we have seen so far in this chapter are regular positional or keyword parameters.
    </span>
    <span class="koboSpan" id="kobo.965.2">
     We have seen how they can be passed as both positional and keyword arguments.
    </span>
    <span class="koboSpan" id="kobo.965.3">
     There is not much more to say about them, so let us look at the other categories.
    </span>
    <span class="koboSpan" id="kobo.965.4">
     Before we do, though, let us briefly look at optional parameters.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-140">
    <span class="koboSpan" id="kobo.966.1">
     Optional parameters
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.967.1">
     Apart from the categories
    </span>
    <a id="_idIndexMarker431">
    </a>
    <span class="koboSpan" id="kobo.968.1">
     we have
    </span>
    <a id="_idIndexMarker432">
    </a>
    <span class="koboSpan" id="kobo.969.1">
     looked at here, parameters can also be classified as either
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.970.1">
      required
     </span>
    </em>
    <span class="koboSpan" id="kobo.971.1">
     or
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.972.1">
      optional
     </span>
    </em>
    <span class="koboSpan" id="kobo.973.1">
     .
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.974.1">
      Optional parameters
     </span>
    </strong>
    <span class="koboSpan" id="kobo.975.1">
     have a default value specified in the function definition.
    </span>
    <span class="koboSpan" id="kobo.975.2">
     The syntax is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.976.1">
      name=value
     </span>
    </code>
    <span class="koboSpan" id="kobo.977.1">
     :
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.978.1"># parameters.default.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.979.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.980.1">func</span></span><span class="koboSpan" id="kobo.981.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.982.1">a, b=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.983.1">4</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.984.1">, c=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.985.1">88</span></span><span class="koboSpan" id="kobo.986.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.987.1">print</span></span><span class="koboSpan" id="kobo.988.1">(a, b, c)
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.989.1">1</span></span><span class="koboSpan" id="kobo.990.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.991.1"># prints: 1 4 88</span></span><span class="koboSpan" id="kobo.992.1">
func(b=</span><span class="hljs-number"><span class="koboSpan" id="kobo.993.1">5</span></span><span class="koboSpan" id="kobo.994.1">, a=</span><span class="hljs-number"><span class="koboSpan" id="kobo.995.1">7</span></span><span class="koboSpan" id="kobo.996.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.997.1">9</span></span><span class="koboSpan" id="kobo.998.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.999.1"># prints: 7 5 9</span></span><span class="koboSpan" id="kobo.1000.1">
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1001.1">42</span></span><span class="koboSpan" id="kobo.1002.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1003.1">9</span></span><span class="koboSpan" id="kobo.1004.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1005.1"># prints: 42 4 9</span></span><span class="koboSpan" id="kobo.1006.1">
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1007.1">42</span></span><span class="koboSpan" id="kobo.1008.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1009.1">43</span></span><span class="koboSpan" id="kobo.1010.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1011.1">44</span></span><span class="koboSpan" id="kobo.1012.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1013.1"># prints: 42, 43, 44</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1014.1">
     Here,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1015.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1016.1">
     is required, while
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1017.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.1018.1">
     has the default value
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1019.1">
      4
     </span>
    </code>
    <span class="koboSpan" id="kobo.1020.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1021.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.1022.1">
     has the default value
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1023.1">
      88
     </span>
    </code>
    <span class="koboSpan" id="kobo.1024.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1024.2">
     It is important to note that, with the exception of keyword-only parameters, required parameters must always be to the left of all optional parameters in the function definition.
    </span>
    <span class="koboSpan" id="kobo.1024.3">
     Try removing the default value from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1025.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.1026.1">
     in the above example and see what happens.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-141">
    <span class="koboSpan" id="kobo.1027.1">
     Variable positional parameters
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1028.1">
     Sometimes you may
    </span>
    <a id="_idIndexMarker433">
    </a>
    <span class="koboSpan" id="kobo.1029.1">
     prefer not to
    </span>
    <a id="_idIndexMarker434">
    </a>
    <span class="koboSpan" id="kobo.1030.1">
     specify the exact number of positional parameters to a function; Python provides you with the ability to do this by using
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1031.1">
      variable positional parameters
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1032.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1032.2">
     Let us look at a very common use case, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1033.1">
      minimum()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1034.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1034.2">
     This is a function that calculates the minimum of its input values:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1035.1"># parameters.variable.positional.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1036.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1037.1">minimum</span></span><span class="koboSpan" id="kobo.1038.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1039.1">*n</span></span><span class="koboSpan" id="kobo.1040.1">):
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1041.1"># print(type(n))  # n is a tuple</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1042.1">if</span></span><span class="koboSpan" id="kobo.1043.1"> n:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1044.1"># explained after the code</span></span><span class="koboSpan" id="kobo.1045.1">
        mn = n[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1046.1">0</span></span><span class="koboSpan" id="kobo.1047.1">]
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1048.1">for</span></span><span class="koboSpan" id="kobo.1049.1"> value </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1050.1">in</span></span><span class="koboSpan" id="kobo.1051.1"> n[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1052.1">1</span></span><span class="koboSpan" id="kobo.1053.1">:]:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1054.1">if</span></span><span class="koboSpan" id="kobo.1055.1"> value &lt; mn:
                mn = value
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1056.1">print</span></span><span class="koboSpan" id="kobo.1057.1">(mn)
minimum(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1058.1">1</span></span><span class="koboSpan" id="kobo.1059.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1060.1">3</span></span><span class="koboSpan" id="kobo.1061.1">, -</span><span class="hljs-number"><span class="koboSpan" id="kobo.1062.1">7</span></span><span class="koboSpan" id="kobo.1063.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1064.1">9</span></span><span class="koboSpan" id="kobo.1065.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1066.1"># n = (1, 3, -7, 9) - prints: -7</span></span><span class="koboSpan" id="kobo.1067.1">
minimum()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1068.1"># n = () - prints: nothing</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1069.1">
     As you can see, when we define a parameter with an asterisk,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1070.1">
      *
     </span>
    </code>
    <span class="koboSpan" id="kobo.1071.1">
     , prepended to its name, we are telling Python that this parameter will collect a variable number of positional arguments when the function is called.
    </span>
    <span class="koboSpan" id="kobo.1071.2">
     Within the function,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1072.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1073.1">
     is a tuple.
    </span>
    <span class="koboSpan" id="kobo.1073.2">
     Uncomment
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1074.1">
      print(type(n))
     </span>
    </code>
    <span class="koboSpan" id="kobo.1075.1">
     to see for yourself, and play around with it for a bit.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1076.1">
     Note that a function can have at most one variable positional parameter—it would not make sense to have more.
    </span>
    <span class="koboSpan" id="kobo.1076.2">
     Python would have no way of deciding how to divide up the arguments between them.
    </span>
    <span class="koboSpan" id="kobo.1076.3">
     You also cannot specify a default value for a variable positional parameter.
    </span>
    <span class="koboSpan" id="kobo.1076.4">
     The
    </span>
    <a id="_idIndexMarker435">
    </a>
    <span class="koboSpan" id="kobo.1077.1">
     default value is always an empty
    </span>
    <a id="_idIndexMarker436">
    </a>
    <span class="koboSpan" id="kobo.1078.1">
     tuple.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1079.1">
      Have you noticed how we checked whether
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1080.1">
       n
      </span>
     </code>
     <span class="koboSpan" id="kobo.1081.1">
      was not empty with a simple
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1082.1">
       if n:
      </span>
     </code>
     <span class="koboSpan" id="kobo.1083.1">
      ?
     </span>
     <span class="koboSpan" id="kobo.1083.2">
      This is because collection objects evaluate to
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1084.1">
       True
      </span>
     </code>
     <span class="koboSpan" id="kobo.1085.1">
      when non-empty, and otherwise
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1086.1">
       False
      </span>
     </code>
     <span class="koboSpan" id="kobo.1087.1">
      , in Python.
     </span>
     <span class="koboSpan" id="kobo.1087.2">
      This is the case for tuples, sets, lists, dictionaries, and so on.
     </span>
    </p>
    <p class="normal">
     <span class="koboSpan" id="kobo.1088.1">
      One other thing to note is that we may want to throw an error when we call the function with no parameters, instead of silently doing nothing.
     </span>
     <span class="koboSpan" id="kobo.1088.2">
      In this context, we are not concerned about making this function robust, but rather understanding variable positional parameters.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.1089.1">
     Did you notice that the syntax for defining variable positional parameters looks very much like the syntax for iterable unpacking?
    </span>
    <span class="koboSpan" id="kobo.1089.2">
     This is no coincidence.
    </span>
    <span class="koboSpan" id="kobo.1089.3">
     After all, the two features mirror each other.
    </span>
    <span class="koboSpan" id="kobo.1089.4">
     They are also frequently used together, since variable positional parameters save you from worrying about whether the length of the iterable you are unpacking matches the number of parameters in the function definition.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-142">
    <span class="koboSpan" id="kobo.1090.1">
     Variable keyword parameters
    </span>
   </h3>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1091.1">
      Variable keyword parameters
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1092.1">
     are
    </span>
    <a id="_idIndexMarker437">
    </a>
    <span class="koboSpan" id="kobo.1093.1">
     very similar
    </span>
    <a id="_idIndexMarker438">
    </a>
    <span class="koboSpan" id="kobo.1094.1">
     to variable positional parameters.
    </span>
    <span class="koboSpan" id="kobo.1094.2">
     The only difference is the syntax (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1095.1">
      **
     </span>
    </code>
    <span class="koboSpan" id="kobo.1096.1">
     instead of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1097.1">
      *
     </span>
    </code>
    <span class="koboSpan" id="kobo.1098.1">
     ) and the fact that they are collected in a dictionary:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1099.1"># parameters.variable.keyword.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1100.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1101.1">func</span></span><span class="koboSpan" id="kobo.1102.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1103.1">**kwargs</span></span><span class="koboSpan" id="kobo.1104.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1105.1">print</span></span><span class="koboSpan" id="kobo.1106.1">(kwargs)
func(a=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1107.1">1</span></span><span class="koboSpan" id="kobo.1108.1">, b=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1109.1">42</span></span><span class="koboSpan" id="kobo.1110.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1111.1"># prints {'a': 1, 'b': 42}</span></span><span class="koboSpan" id="kobo.1112.1">
func()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1113.1"># prints {}</span></span><span class="koboSpan" id="kobo.1114.1">
func(a=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1115.1">1</span></span><span class="koboSpan" id="kobo.1116.1">, b=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1117.1">46</span></span><span class="koboSpan" id="kobo.1118.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1119.1">99</span></span><span class="koboSpan" id="kobo.1120.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1121.1"># prints {'a': 1, 'b': 46, 'c': 99}</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1122.1">
     You can see that adding
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1123.1">
      **
     </span>
    </code>
    <span class="koboSpan" id="kobo.1124.1">
     in front of the parameter name in the function definition tells Python to use that name to collect a variable number of keyword parameters.
    </span>
    <span class="koboSpan" id="kobo.1124.2">
     As in the case of variable positional parameters, each function can have at most one variable keyword parameter—and you cannot specify a default value.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1125.1">
     Just like variable positional parameters resemble iterable unpacking, variable keyword parameters resemble dictionary unpacking.
    </span>
    <span class="koboSpan" id="kobo.1125.2">
     Dictionary unpacking is also often used to pass arguments to functions with variable keyword parameters.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1126.1">
     The reason why being able to pass a variable number of keyword arguments is so important may not be evident at the moment, so how about a more realistic example?
    </span>
    <span class="koboSpan" id="kobo.1126.2">
     Let us define a function that connects to a database: we want to connect to a default database by simply calling this function with no parameters.
    </span>
    <span class="koboSpan" id="kobo.1126.3">
     We also want to connect to any other database by passing to the function the appropriate parameters.
    </span>
    <span class="koboSpan" id="kobo.1126.4">
     Before you read on, try to spend a couple of minutes figuring out a solution by yourself:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1127.1"># parameters.variable.db.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1128.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1129.1">connect</span></span><span class="koboSpan" id="kobo.1130.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1131.1">**options</span></span><span class="koboSpan" id="kobo.1132.1">):
    conn_params = {
        "host": options.get("host", "</span><span class="hljs-number"><span class="koboSpan" id="kobo.1133.1">127.0.0.1</span></span><span class="koboSpan" id="kobo.1134.1">"),
        "port": options.get("port", </span><span class="hljs-number"><span class="koboSpan" id="kobo.1135.1">5432</span></span><span class="koboSpan" id="kobo.1136.1">),
        "user": options.get("user", ""),
        "pwd": options.get("pwd", ""),
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1137.1">print</span></span><span class="koboSpan" id="kobo.1138.1">(conn_params)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1139.1"># we then connect to the db (commented out)</span></span>
    <span class="hljs-comment"><span class="koboSpan" id="kobo.1140.1"># db.connect(**conn_params)</span></span><span class="koboSpan" id="kobo.1141.1">
connect()
connect(host="</span><span class="hljs-number"><span class="koboSpan" id="kobo.1142.1">127.0.0.42</span></span><span class="koboSpan" id="kobo.1143.1">", port=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1144.1">5433</span></span><span class="koboSpan" id="kobo.1145.1">)
connect(port=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1146.1">5431</span></span><span class="koboSpan" id="kobo.1147.1">, user="fab", pwd="gandalf")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1148.1">
     Note that, in
    </span>
    <a id="_idIndexMarker439">
    </a>
    <span class="koboSpan" id="kobo.1149.1">
     the function, we can prepare a dictionary of connection parameters (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1150.1">
      conn_params
     </span>
    </code>
    <span class="koboSpan" id="kobo.1151.1">
     ) using default values as fallbacks, allowing
    </span>
    <a id="_idIndexMarker440">
    </a>
    <span class="koboSpan" id="kobo.1152.1">
     them to be overwritten if they are provided in the function call.
    </span>
    <span class="koboSpan" id="kobo.1152.2">
     There are better ways to do this with fewer lines of code, but we are not concerned with that right now.
    </span>
    <span class="koboSpan" id="kobo.1152.3">
     Running the preceding code yields the following result:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1153.1">$ python parameters.variable.db.py
{'host': '127.0.0.1', 'port': 5432, 'user': '', 'pwd': ''}
{'host': '127.0.0.42', 'port': 5433, 'user': '', 'pwd': ''}
{'host': '127.0.0.1', 'port': 5431, 'user': 'fab', 'pwd': 'gandalf'}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1154.1">
     Note the correspondence between the function calls and the output, and how default values are overridden according to what was passed to the function.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-143">
    <span class="koboSpan" id="kobo.1155.1">
     Positional-only parameters
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1156.1">
     Starting from
    </span>
    <a id="_idIndexMarker441">
    </a>
    <span class="koboSpan" id="kobo.1157.1">
     Python 3.8, PEP 570 (
    </span>
    <a href="https://peps.python.org/pep-0570/">
     <span class="url">
      <span class="koboSpan" id="kobo.1158.1">
       https://peps.python.org/pep-0570/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1159.1">
     ) introduced
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1160.1">
      positional-only parameters
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1161.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1161.2">
     There is a
    </span>
    <a id="_idIndexMarker442">
    </a>
    <span class="koboSpan" id="kobo.1162.1">
     new function parameter syntax,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1163.1">
      /
     </span>
    </code>
    <span class="koboSpan" id="kobo.1164.1">
     , indicating that a
    </span>
    <a id="_idIndexMarker443">
    </a>
    <span class="koboSpan" id="kobo.1165.1">
     set of the function parameters must be specified positionally and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1166.1">
      cannot
     </span>
    </em>
    <span class="koboSpan" id="kobo.1167.1">
     be passed as keyword arguments.
    </span>
    <span class="koboSpan" id="kobo.1167.2">
     Let us see a simple example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1168.1"># parameters.positional.only.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1169.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1170.1">func</span></span><span class="koboSpan" id="kobo.1171.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1172.1">a, b, /, c</span></span><span class="koboSpan" id="kobo.1173.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1174.1">print</span></span><span class="koboSpan" id="kobo.1175.1">(a, b, c)
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1176.1">1</span></span><span class="koboSpan" id="kobo.1177.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1178.1">2</span></span><span class="koboSpan" id="kobo.1179.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1180.1">3</span></span><span class="koboSpan" id="kobo.1181.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1182.1"># prints: 1 2 3</span></span><span class="koboSpan" id="kobo.1183.1">
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1184.1">1</span></span><span class="koboSpan" id="kobo.1185.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1186.1">2</span></span><span class="koboSpan" id="kobo.1187.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1188.1">3</span></span><span class="koboSpan" id="kobo.1189.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1190.1"># prints 1 2 3</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1191.1">
     In the preceding example, we define a function,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1192.1">
      func()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1193.1">
     , which specifies three parameters:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1194.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1195.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1196.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.1197.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1198.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.1199.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1199.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1200.1">
      /
     </span>
    </code>
    <span class="koboSpan" id="kobo.1201.1">
     in the function signature indicates that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1202.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1203.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1204.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.1205.1">
     must be passed positionally, that is, not by keyword.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1206.1">
     The last two lines in the example show that we can call the function passing all three arguments positionally, or we can pass
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1207.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.1208.1">
     by keyword.
    </span>
    <span class="koboSpan" id="kobo.1208.2">
     Both cases work fine, as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1209.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.1210.1">
     is defined after the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1211.1">
      /
     </span>
    </code>
    <span class="koboSpan" id="kobo.1212.1">
     in the function signature.
    </span>
    <span class="koboSpan" id="kobo.1212.2">
     If we try to call the function by passing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1213.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1214.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1215.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.1216.1">
     by keyword, like so:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1217.1">func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1218.1">1</span></span><span class="koboSpan" id="kobo.1219.1">, b=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1220.1">2</span></span><span class="koboSpan" id="kobo.1221.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1222.1">3</span></span><span class="koboSpan" id="kobo.1223.1">)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1224.1">
     This produces the following traceback:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1225.1">Traceback (most recent call last):
  File "arguments.positional.only.py", line 7, in &lt;module&gt;
    func(1, b=2, c=3)
TypeError: func() got some positional-only arguments
passed as keyword arguments: 'b'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1226.1">
     The preceding example shows us that Python is now complaining about how we called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1227.1">
      func()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1228.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1228.2">
     We have passed
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1229.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.1230.1">
     by keyword, but we are not allowed to do that.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1231.1">
     Positional-only parameters can also be optional:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1232.1"># parameters.positional.only.optional.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1233.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1234.1">func</span></span><span class="koboSpan" id="kobo.1235.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1236.1">a, b=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1237.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1238.1">, /</span></span><span class="koboSpan" id="kobo.1239.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1240.1">print</span></span><span class="koboSpan" id="kobo.1241.1">(a, b)
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1242.1">4</span></span><span class="koboSpan" id="kobo.1243.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1244.1">5</span></span><span class="koboSpan" id="kobo.1245.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1246.1"># prints 4 5</span></span><span class="koboSpan" id="kobo.1247.1">
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1248.1">3</span></span><span class="koboSpan" id="kobo.1249.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1250.1"># prints 3 2</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1251.1">
     Let us see what
    </span>
    <a id="_idIndexMarker444">
    </a>
    <span class="koboSpan" id="kobo.1252.1">
     this feature brings to the language with a few examples
    </span>
    <a id="_idIndexMarker445">
    </a>
    <span class="koboSpan" id="kobo.1253.1">
     borrowed from the official documentation.
    </span>
    <span class="koboSpan" id="kobo.1253.2">
     One advantage is the ability to fully emulate behaviors of existing C-coded functions:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1254.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1255.1">divmod</span></span><span class="koboSpan" id="kobo.1256.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1257.1">a, b, /</span></span><span class="koboSpan" id="kobo.1258.1">):
    "Emulate the built </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1259.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1260.1">divmod</span></span><span class="koboSpan" id="kobo.1261.1">() function"
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1262.1">return</span></span><span class="koboSpan" id="kobo.1263.1"> (a // b, a % b)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1264.1">
     Another important use case is to preclude keyword arguments when the parameter name is not helpful:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1265.1">len</span></span><span class="koboSpan" id="kobo.1266.1">(obj='hello')
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1267.1">
     In the preceding example, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1268.1">
      obj
     </span>
    </code>
    <span class="koboSpan" id="kobo.1269.1">
     keyword argument impairs readability.
    </span>
    <span class="koboSpan" id="kobo.1269.2">
     Moreover, if we wish to refactor the internals of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1270.1">
      len
     </span>
    </code>
    <span class="koboSpan" id="kobo.1271.1">
     function, and rename
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1272.1">
      obj
     </span>
    </code>
    <span class="koboSpan" id="kobo.1273.1">
     to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1274.1">
      the_object
     </span>
    </code>
    <span class="koboSpan" id="kobo.1275.1">
     (or any other name), the change is guaranteed not to break any client code, because there will not be any call to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1276.1">
      len()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1277.1">
     function involving the now stale
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1278.1">
      obj
     </span>
    </code>
    <span class="koboSpan" id="kobo.1279.1">
     parameter name.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1280.1">
     Finally, using positional-only parameters implies that whatever is on the left of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1281.1">
      /
     </span>
    </code>
    <span class="koboSpan" id="kobo.1282.1">
     remains available for use in variable keyword arguments, as shown by the following example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1283.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1284.1">func_name</span></span><span class="koboSpan" id="kobo.1285.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1286.1">name, /, **kwargs</span></span><span class="koboSpan" id="kobo.1287.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1288.1">print</span></span><span class="koboSpan" id="kobo.1289.1">(name)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1290.1">print</span></span><span class="koboSpan" id="kobo.1291.1">(kwargs)
func_name("Positional-only name", name="Name </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1292.1">in</span></span><span class="koboSpan" id="kobo.1293.1"> **kwargs")
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1294.1"># Prints:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1295.1"># Positional-only name</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1296.1"># {'name': 'Name in **kwargs'}</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1297.1">
     The ability to
    </span>
    <a id="_idIndexMarker446">
    </a>
    <span class="koboSpan" id="kobo.1298.1">
     retain parameter names in function signatures for
    </span>
    <a id="_idIndexMarker447">
    </a>
    <span class="koboSpan" id="kobo.1299.1">
     use in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1300.1">
      **kwargs
     </span>
    </code>
    <span class="koboSpan" id="kobo.1301.1">
     can lead to simpler and cleaner code.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1302.1">
     Let us now explore the mirror version of positional-only: keyword-only parameters.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-144">
    <span class="koboSpan" id="kobo.1303.1">
     Keyword-only parameters
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1304.1">
     Python 3 introduced
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1305.1">
      keyword-only parameters
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1306.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1306.2">
     We are going to study them only briefly, as their use cases are
    </span>
    <a id="_idIndexMarker448">
    </a>
    <span class="koboSpan" id="kobo.1307.1">
     not that frequent.
    </span>
    <span class="koboSpan" id="kobo.1307.2">
     There are two ways of specifying
    </span>
    <a id="_idIndexMarker449">
    </a>
    <span class="koboSpan" id="kobo.1308.1">
     them, either after the variable positional parameters or after a bare
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1309.1">
      *
     </span>
    </code>
    <span class="koboSpan" id="kobo.1310.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1310.2">
     Let us see an example of both:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1311.1"># parameters.keyword.only.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1312.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1313.1">kwo</span></span><span class="koboSpan" id="kobo.1314.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1315.1">*a, c</span></span><span class="koboSpan" id="kobo.1316.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1317.1">print</span></span><span class="koboSpan" id="kobo.1318.1">(a, c)
kwo(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1319.1">1</span></span><span class="koboSpan" id="kobo.1320.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1321.1">2</span></span><span class="koboSpan" id="kobo.1322.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1323.1">3</span></span><span class="koboSpan" id="kobo.1324.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1325.1">7</span></span><span class="koboSpan" id="kobo.1326.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1327.1"># prints: (1, 2, 3) 7</span></span><span class="koboSpan" id="kobo.1328.1">
kwo(c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1329.1">4</span></span><span class="koboSpan" id="kobo.1330.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1331.1"># prints: () 4</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1332.1"># kwo(1, 2)  # breaks, invalid syntax, with the following error</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1333.1"># TypeError: kwo() missing 1 required keyword-only argument: 'c'</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1334.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1335.1">kwo2</span></span><span class="koboSpan" id="kobo.1336.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1337.1">a, b=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1338.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1339.1">, *, c</span></span><span class="koboSpan" id="kobo.1340.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1341.1">print</span></span><span class="koboSpan" id="kobo.1342.1">(a, b, c)
kwo2(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1343.1">3</span></span><span class="koboSpan" id="kobo.1344.1">, b=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1345.1">7</span></span><span class="koboSpan" id="kobo.1346.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1347.1">99</span></span><span class="koboSpan" id="kobo.1348.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1349.1"># prints: 3 7 99</span></span><span class="koboSpan" id="kobo.1350.1">
kwo2(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1351.1">3</span></span><span class="koboSpan" id="kobo.1352.1">, c=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1353.1">13</span></span><span class="koboSpan" id="kobo.1354.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1355.1"># prints: 3 42 13</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1356.1"># kwo2(3, 23)  # breaks, invalid syntax, with the following error</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1357.1"># TypeError: kwo2() missing 1 required keyword-only argument: 'c'</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1358.1">
     As anticipated, the function
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1359.1">
      kwo()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1360.1">
     takes a variable number of positional parameters (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1361.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1362.1">
     ) and a keyword-only one,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1363.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.1364.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1364.2">
     The results of the calls are straightforward and you can uncomment the third call to see what error Python returns.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1365.1">
     The
    </span>
    <a id="_idIndexMarker450">
    </a>
    <span class="koboSpan" id="kobo.1366.1">
     same applies to the function
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1367.1">
      kwo2()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1368.1">
     , which differs from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1369.1">
      kwo
     </span>
    </code>
    <span class="koboSpan" id="kobo.1370.1">
     in that
    </span>
    <a id="_idIndexMarker451">
    </a>
    <span class="koboSpan" id="kobo.1371.1">
     it takes a positional argument,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1372.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1373.1">
     , a keyword argument,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1374.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.1375.1">
     , and then a keyword-only one,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1376.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.1377.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1377.2">
     You can uncomment the third call to see the error that is produced.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1378.1">
     Now that you know how to specify different types of input parameters, let us see how you can combine them in function definitions.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-145">
    <span class="koboSpan" id="kobo.1379.1">
     Combining input parameters
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1380.1">
     You can combine different
    </span>
    <a id="_idIndexMarker452">
    </a>
    <span class="koboSpan" id="kobo.1381.1">
     parameter types in the same function (in fact, it is often very useful to do so).
    </span>
    <span class="koboSpan" id="kobo.1381.2">
     As in the case of combining different types of arguments in the same function call, there are some restrictions on ordering:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.1382.1">
      Positional-only parameters come first, followed by a
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1383.1">
       /
      </span>
     </code>
     <span class="koboSpan" id="kobo.1384.1">
      .
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.1385.1">
      Normal parameters go after any positional-only parameters.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.1386.1">
      Variable positional parameters go after normal parameters.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.1387.1">
      Keyword-only parameters go after variable positional parameters.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.1388.1">
      Variable keyword parameters always go last.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.1389.1">
      For positional-only and normal parameters, any required parameters must be defined before any optional parameters.
     </span>
     <span class="koboSpan" id="kobo.1389.2">
      This means that if you have an optional positional-only parameter, all your normal parameters must be optional too.
     </span>
     <span class="koboSpan" id="kobo.1389.3">
      This rule does not affect keyword-only parameters.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.1390.1">
     These rules can be a bit tricky to understand without an example, so let us look at a couple of them:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1391.1"># parameters.all.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1392.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1393.1">func</span></span><span class="koboSpan" id="kobo.1394.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1395.1">a, b, c=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1396.1">7</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1397.1">, *args, **kwargs</span></span><span class="koboSpan" id="kobo.1398.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1399.1">print</span></span><span class="koboSpan" id="kobo.1400.1">("a, b, c:", a, b, c)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1401.1">print</span></span><span class="koboSpan" id="kobo.1402.1">("args:", args)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1403.1">print</span></span><span class="koboSpan" id="kobo.1404.1">("kwargs:", kwargs)
func(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1405.1">1</span></span><span class="koboSpan" id="kobo.1406.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1407.1">2</span></span><span class="koboSpan" id="kobo.1408.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1409.1">3</span></span><span class="koboSpan" id="kobo.1410.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1411.1">5</span></span><span class="koboSpan" id="kobo.1412.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1413.1">7</span></span><span class="koboSpan" id="kobo.1414.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1415.1">9</span></span><span class="koboSpan" id="kobo.1416.1">, A="a", B="b")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1417.1">
     Note the order of the parameters in the function definition.
    </span>
    <span class="koboSpan" id="kobo.1417.2">
     The execution of this yields the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1418.1">$ python parameters.all.py
a, b, c: 1 2 3
args: (5, 7, 9)
kwargs: {'A': 'a', 'B': 'b'}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1419.1">
     Let us now
    </span>
    <a id="_idIndexMarker453">
    </a>
    <span class="koboSpan" id="kobo.1420.1">
     look at an example with keyword-only parameters:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1421.1"># parameters.all.pkwonly.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1422.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1423.1">allparams</span></span><span class="koboSpan" id="kobo.1424.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1425.1">a, /, b, c=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1426.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1427.1">, *args, d=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1428.1">256</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1429.1">, e, **kwargs</span></span><span class="koboSpan" id="kobo.1430.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1431.1">print</span></span><span class="koboSpan" id="kobo.1432.1">("a, b, c:", a, b, c)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1433.1">print</span></span><span class="koboSpan" id="kobo.1434.1">("d, e:", d, e)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1435.1">print</span></span><span class="koboSpan" id="kobo.1436.1">("args:", args)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1437.1">print</span></span><span class="koboSpan" id="kobo.1438.1">("kwargs:", kwargs)
allparams(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1439.1">1</span></span><span class="koboSpan" id="kobo.1440.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1441.1">2</span></span><span class="koboSpan" id="kobo.1442.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1443.1">3</span></span><span class="koboSpan" id="kobo.1444.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1445.1">4</span></span><span class="koboSpan" id="kobo.1446.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1447.1">5</span></span><span class="koboSpan" id="kobo.1448.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1449.1">6</span></span><span class="koboSpan" id="kobo.1450.1">, e=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1451.1">7</span></span><span class="koboSpan" id="kobo.1452.1">, f=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1453.1">9</span></span><span class="koboSpan" id="kobo.1454.1">, g=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1455.1">10</span></span><span class="koboSpan" id="kobo.1456.1">)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1457.1">
     Note that we have both positional-only and keyword-only parameters in the function declaration:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1458.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1459.1">
     is positional-only, while
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1460.1">
      d
     </span>
    </code>
    <span class="koboSpan" id="kobo.1461.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1462.1">
      e
     </span>
    </code>
    <span class="koboSpan" id="kobo.1463.1">
     are keyword-only.
    </span>
    <span class="koboSpan" id="kobo.1463.2">
     They come after the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1464.1">
      *args
     </span>
    </code>
    <span class="koboSpan" id="kobo.1465.1">
     variable positional argument, and it would be the same if they came right after a single
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1466.1">
      *
     </span>
    </code>
    <span class="koboSpan" id="kobo.1467.1">
     (in which case there would not be any variable positional parameter).
    </span>
    <span class="koboSpan" id="kobo.1467.2">
     The execution of this yields the following:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1468.1">$ python parameters.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1469.1">all</span></span><span class="koboSpan" id="kobo.1470.1">.pkwonly.py
a, b, c: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1471.1">1</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1472.1">2</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1473.1">3</span></span><span class="koboSpan" id="kobo.1474.1">
d, e: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1475.1">256</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1476.1">7</span></span><span class="koboSpan" id="kobo.1477.1">
args: (</span><span class="hljs-number"><span class="koboSpan" id="kobo.1478.1">4</span></span><span class="koboSpan" id="kobo.1479.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1480.1">5</span></span><span class="koboSpan" id="kobo.1481.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1482.1">6</span></span><span class="koboSpan" id="kobo.1483.1">)
kwargs: {'f': </span><span class="hljs-number"><span class="koboSpan" id="kobo.1484.1">9</span></span><span class="koboSpan" id="kobo.1485.1">, 'g': </span><span class="hljs-number"><span class="koboSpan" id="kobo.1486.1">10</span></span><span class="koboSpan" id="kobo.1487.1">}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1488.1">
     One other thing to note is the names we gave to the variable positional and keyword parameters.
    </span>
    <span class="koboSpan" id="kobo.1488.2">
     You are free to choose differently but be aware that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1489.1">
      args
     </span>
    </code>
    <span class="koboSpan" id="kobo.1490.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1491.1">
      kwargs
     </span>
    </code>
    <span class="koboSpan" id="kobo.1492.1">
     are the conventional names given to these parameters, at least generically.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-146">
    <span class="koboSpan" id="kobo.1493.1">
     More signature examples
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1494.1">
     To briefly recap on function signatures
    </span>
    <a id="_idIndexMarker454">
    </a>
    <span class="koboSpan" id="kobo.1495.1">
     that use the positional- and keyword-only specifiers, here are some further examples.
    </span>
    <span class="koboSpan" id="kobo.1495.2">
     Omitting the variable positional and keyword parameters, for brevity, we are left with the following syntax:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1496.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1497.1">func_name</span></span><span class="koboSpan" id="kobo.1498.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1499.1">positional_only_parameters, /,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1500.1">    positional_or_keyword_parameters, *,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1501.1">    keyword_only_parameters</span></span><span class="koboSpan" id="kobo.1502.1">):
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1503.1">
     First, we have positional-only, then positional or keyword parameters, and finally keyword-only ones.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1504.1">
     Some other valid signatures are presented below:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1505.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1506.1">func_name</span></span><span class="koboSpan" id="kobo.1507.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1508.1">p1, p2, /, p_or_kw, *, kw</span></span><span class="koboSpan" id="kobo.1509.1">):
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1510.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1511.1">func_name</span></span><span class="koboSpan" id="kobo.1512.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1513.1">p1, p2=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1514.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1515.1">, /, p_or_kw=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1516.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1517.1">, *, kw</span></span><span class="koboSpan" id="kobo.1518.1">):
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1519.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1520.1">func_name</span></span><span class="koboSpan" id="kobo.1521.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1522.1">p1, p2=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1523.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1524.1">, /, *, kw</span></span><span class="koboSpan" id="kobo.1525.1">):
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1526.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1527.1">func_name</span></span><span class="koboSpan" id="kobo.1528.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1529.1">p1, p2=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1530.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1531.1">, /</span></span><span class="koboSpan" id="kobo.1532.1">):
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1533.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1534.1">func_name</span></span><span class="koboSpan" id="kobo.1535.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1536.1">p1, p2, /, p_or_kw</span></span><span class="koboSpan" id="kobo.1537.1">):
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1538.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1539.1">func_name</span></span><span class="koboSpan" id="kobo.1540.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1541.1">p1, p2, /</span></span><span class="koboSpan" id="kobo.1542.1">):
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1543.1">
     All of the above are
    </span>
    <a id="_idIndexMarker455">
    </a>
    <span class="koboSpan" id="kobo.1544.1">
     valid signatures, while the following would be invalid:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1545.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1546.1">func_name</span></span><span class="koboSpan" id="kobo.1547.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1548.1">p1, p2=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1549.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1550.1">, /, p_or_kw, *, kw</span></span><span class="koboSpan" id="kobo.1551.1">):
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1552.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1553.1">func_name</span></span><span class="koboSpan" id="kobo.1554.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1555.1">p1=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1556.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1557.1">, p2, /, p_or_kw=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1558.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1559.1">, *, kw</span></span><span class="koboSpan" id="kobo.1560.1">):
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1561.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1562.1">func_name</span></span><span class="koboSpan" id="kobo.1563.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1564.1">p1=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1565.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1566.1">, p2, /</span></span><span class="koboSpan" id="kobo.1567.1">):
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1568.1">
     You can read about the grammar specifications in the official documentation:
    </span>
   </p>
   <p class="normal">
    <a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions">
     <span class="url">
      <span class="koboSpan" id="kobo.1569.1">
       https://docs.python.org/3/reference/compound_stmts.html#function-definitions
      </span>
     </span>
    </a>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1570.1">
     A useful exercise for you at this point would be to implement any of the above example signatures, print out the values of those parameters, like we have done in previous exercises, and play around passing arguments in different ways.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-147">
    <span class="koboSpan" id="kobo.1571.1">
     Avoid the trap!
    </span>
    <span class="koboSpan" id="kobo.1571.2">
     Mutable defaults
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1572.1">
     One thing to be aware of, in Python, is that
    </span>
    <a id="_idIndexMarker456">
    </a>
    <span class="koboSpan" id="kobo.1573.1">
     default values are created at definition time; therefore, subsequent calls to the same function will possibly behave differently according to the mutability of their default values.
    </span>
    <span class="koboSpan" id="kobo.1573.2">
     Let us look at an example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1574.1"># parameters.defaults.mutable.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1575.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1576.1">func</span></span><span class="koboSpan" id="kobo.1577.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1578.1">a=[], b={}</span></span><span class="koboSpan" id="kobo.1579.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1580.1">print</span></span><span class="koboSpan" id="kobo.1581.1">(a)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1582.1">print</span></span><span class="koboSpan" id="kobo.1583.1">(b)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1584.1">print</span></span><span class="koboSpan" id="kobo.1585.1">("#" * 12)
    a.append(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1586.1">len</span></span><span class="koboSpan" id="kobo.1587.1">(a))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1588.1"># this will affect a's default value</span></span><span class="koboSpan" id="kobo.1589.1">
    b[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1590.1">len</span></span><span class="koboSpan" id="kobo.1591.1">(a)] = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1592.1">len</span></span><span class="koboSpan" id="kobo.1593.1">(a)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1594.1"># and this will affect b's one</span></span>
<span class="hljs-title"><span class="koboSpan" id="kobo.1595.1">func</span></span><span class="koboSpan" id="kobo.1596.1">()
</span><span class="hljs-title"><span class="koboSpan" id="kobo.1597.1">func</span></span><span class="koboSpan" id="kobo.1598.1">()
</span><span class="hljs-title"><span class="koboSpan" id="kobo.1599.1">func</span></span><span class="koboSpan" id="kobo.1600.1">()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1601.1">
     Both parameters have mutable default values.
    </span>
    <span class="koboSpan" id="kobo.1601.2">
     This means that, if you affect those objects, any modification will stick around in subsequent function calls.
    </span>
    <span class="koboSpan" id="kobo.1601.3">
     See if you can understand the output of those calls:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1602.1">$ python parameters.defaults.mutable.py
[]
{}
############
[0]
{1: 1}
############
[0, 1]
{1: 1, 2: 2}
############
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1603.1">
     While this
    </span>
    <a id="_idIndexMarker457">
    </a>
    <span class="koboSpan" id="kobo.1604.1">
     behavior may seem weird at first, it actually makes sense, and it is very handy—when using
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1605.1">
      memoization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1606.1">
     techniques, for example.
    </span>
    <span class="koboSpan" id="kobo.1606.2">
     Even more interesting is what happens
    </span>
    <a id="_idIndexMarker458">
    </a>
    <span class="koboSpan" id="kobo.1607.1">
     when, between the calls, we introduce one that does not use defaults, such as this:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1608.1"># parameters.defaults.mutable.intermediate.call.py</span></span><span class="koboSpan" id="kobo.1609.1">
func()
func(a=[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1610.1">1</span></span><span class="koboSpan" id="kobo.1611.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1612.1">2</span></span><span class="koboSpan" id="kobo.1613.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1614.1">3</span></span><span class="koboSpan" id="kobo.1615.1">], b={"B": </span><span class="hljs-number"><span class="koboSpan" id="kobo.1616.1">1</span></span><span class="koboSpan" id="kobo.1617.1">})
func()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1618.1">
     When we run this code, this is the output:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1619.1">$ python parameters.defaults.mutable.intermediate.call.py
[]
{}
############
[1, 2, 3]
{'B': 1}
############
[0]
{1: 1}
############
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1620.1">
     This output shows us that the defaults are retained even if we call the function with other values.
    </span>
    <span class="koboSpan" id="kobo.1620.2">
     One question that comes to mind is, how do I get a fresh empty value every time?
    </span>
    <span class="koboSpan" id="kobo.1620.3">
     Well, the convention is the following:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1621.1"># parameters.defaults.mutable.no.trap.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1622.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1623.1">func</span></span><span class="koboSpan" id="kobo.1624.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1625.1">a=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1626.1">None</span></span><span class="koboSpan" id="kobo.1627.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1628.1">if</span></span><span class="koboSpan" id="kobo.1629.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1630.1">is</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1631.1">None</span></span><span class="koboSpan" id="kobo.1632.1">:
        a = []
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1633.1"># do whatever you want with `a` ...</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1634.1">
     Note that, by using the
    </span>
    <a id="_idIndexMarker459">
    </a>
    <span class="koboSpan" id="kobo.1635.1">
     preceding technique, if
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1636.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.1637.1">
     is not passed when calling the function, we always get a brand new, empty list.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1638.1">
     After a thorough exposition of input parameters, it is now time to look at the other side of the coin, returning output values.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-148">
    <span class="koboSpan" id="kobo.1639.1">
     Return values
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1640.1">
     We have already said that to return
    </span>
    <a id="_idIndexMarker460">
    </a>
    <span class="koboSpan" id="kobo.1641.1">
     something from a function we need to use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1642.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.1643.1">
     statement, followed by what we want to return.
    </span>
    <span class="koboSpan" id="kobo.1643.2">
     There can be as many
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1644.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.1645.1">
     statements as needed in the body of a function.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1646.1">
     On the other hand, if within the body of a function we do not return anything, or we invoke a bare
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1647.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.1648.1">
     statement, the function will return
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1649.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.1650.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1650.2">
     This behavior is harmless when it is not needed, but allows for interesting patterns, and confirms Python as a very consistent language.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1651.1">
     We say it is harmless because you are never forced to collect the result of a function call.
    </span>
    <span class="koboSpan" id="kobo.1651.2">
     We will show you what we mean with an example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1652.1"># return.none.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1653.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1654.1">func</span></span><span class="koboSpan" id="kobo.1655.1">():
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1656.1">pass</span></span><span class="koboSpan" id="kobo.1657.1">
func()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1658.1"># the return of this call won't be collected. </span><span class="koboSpan" id="kobo.1658.2">It's lost.</span></span><span class="koboSpan" id="kobo.1659.1">
a = func()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1660.1"># the return of this one instead is collected into `a`</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1661.1">print</span></span><span class="koboSpan" id="kobo.1662.1">(a)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1663.1"># prints: None</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1664.1">
     Note that the whole body of the function is composed only of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1665.1">
      pass
     </span>
    </code>
    <span class="koboSpan" id="kobo.1666.1">
     statement.
    </span>
    <span class="koboSpan" id="kobo.1666.2">
     As the official documentation tells us,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1667.1">
      pass
     </span>
    </code>
    <span class="koboSpan" id="kobo.1668.1">
     is a null operation, as, when it is executed, nothing happens.
    </span>
    <span class="koboSpan" id="kobo.1668.2">
     It is useful as a placeholder when a statement is required syntactically but no code needs to be executed.
    </span>
    <span class="koboSpan" id="kobo.1668.3">
     In other languages, we would probably just indicate that with a pair of curly brackets (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1669.1">
      {}
     </span>
    </code>
    <span class="koboSpan" id="kobo.1670.1">
     ), which define an
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1671.1">
      empty scope
     </span>
    </em>
    <span class="koboSpan" id="kobo.1672.1">
     ; but in Python, a scope is defined by indenting code, therefore a statement such as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1673.1">
      pass
     </span>
    </code>
    <span class="koboSpan" id="kobo.1674.1">
     is necessary.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1675.1">
     Notice also that the first call to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1676.1">
      func()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1677.1">
     returns a value (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1678.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.1679.1">
     ) that we do not collect.
    </span>
    <span class="koboSpan" id="kobo.1679.2">
     As we mentioned before, collecting the return value of a function call is not mandatory.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1680.1">
     Let us see a more interesting example.
    </span>
    <span class="koboSpan" id="kobo.1680.2">
     Remember that, in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.1681.1">
      Chapter 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.1682.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.1683.1">
      A Gentle Introduction to Python
     </span>
    </em>
    <span class="koboSpan" id="kobo.1684.1">
     , we talked about the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1685.1">
      factorial
     </span>
    </em>
    <span class="koboSpan" id="kobo.1686.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1686.2">
     Let us write our own implementation here (for simplicity, we will assume the function is always called correctly with appropriate values, so we do not need to sanity-check the input argument):
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1687.1"># return.single.value.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1688.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1689.1">factorial</span></span><span class="koboSpan" id="kobo.1690.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1691.1">n</span></span><span class="koboSpan" id="kobo.1692.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1693.1">if</span></span><span class="koboSpan" id="kobo.1694.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1695.1">in</span></span><span class="koboSpan" id="kobo.1696.1"> (</span><span class="hljs-number"><span class="koboSpan" id="kobo.1697.1">0</span></span><span class="koboSpan" id="kobo.1698.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1699.1">1</span></span><span class="koboSpan" id="kobo.1700.1">):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1701.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1702.1">1</span></span><span class="koboSpan" id="kobo.1703.1">
    result = n
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1704.1">for</span></span><span class="koboSpan" id="kobo.1705.1"> k </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1706.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1707.1">range</span></span><span class="koboSpan" id="kobo.1708.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1709.1">2</span></span><span class="koboSpan" id="kobo.1710.1">, n):
        result *= k
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1711.1">return</span></span><span class="koboSpan" id="kobo.1712.1"> result
f5 = factorial(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1713.1">5</span></span><span class="koboSpan" id="kobo.1714.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1715.1"># f5 = 120</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1716.1">
     Note that we have
    </span>
    <a id="_idIndexMarker461">
    </a>
    <span class="koboSpan" id="kobo.1717.1">
     two points of return.
    </span>
    <span class="koboSpan" id="kobo.1717.2">
     If
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1718.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1719.1">
     is either
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1720.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.1721.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1722.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1723.1">
     , we return
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1724.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1725.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1725.2">
     Otherwise, we perform the required calculation and return
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1726.1">
      result
     </span>
    </code>
    <span class="koboSpan" id="kobo.1727.1">
     .
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1728.1">
      In Python, it is common to use the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1729.1">
       in
      </span>
     </code>
     <span class="koboSpan" id="kobo.1730.1">
      operator to do a membership check, as we did in the preceding example, instead of the more verbose:
     </span>
    </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1731.1">if</span></span><span class="koboSpan" id="kobo.1732.1"> n == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1733.1">0</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1734.1">or</span></span><span class="koboSpan" id="kobo.1735.1"> n == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1736.1">1</span></span><span class="koboSpan" id="kobo.1737.1">:
    ...
</span></code></pre>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.1738.1">
     Let us now try to write this function a little bit more succinctly:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1739.1"># return.single.value.2.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1740.1">from</span></span><span class="koboSpan" id="kobo.1741.1"> functools </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1742.1">import</span></span><span class="koboSpan" id="kobo.1743.1"> reduce
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1744.1">from</span></span><span class="koboSpan" id="kobo.1745.1"> operator </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1746.1">import</span></span><span class="koboSpan" id="kobo.1747.1"> mul
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1748.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1749.1">factorial</span></span><span class="koboSpan" id="kobo.1750.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1751.1">n</span></span><span class="koboSpan" id="kobo.1752.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1753.1">return</span></span><span class="koboSpan" id="kobo.1754.1"> reduce(mul, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1755.1">range</span></span><span class="koboSpan" id="kobo.1756.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1757.1">1</span></span><span class="koboSpan" id="kobo.1758.1">, n + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1759.1">1</span></span><span class="koboSpan" id="kobo.1760.1">), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1761.1">1</span></span><span class="koboSpan" id="kobo.1762.1">)
f5 = factorial(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1763.1">5</span></span><span class="koboSpan" id="kobo.1764.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1765.1"># f5 = 120</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1766.1">
     This simple example shows how Python is both elegant and concise.
    </span>
    <span class="koboSpan" id="kobo.1766.2">
     This implementation is readable even if we have never seen
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1767.1">
      reduce()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1768.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1769.1">
      mul()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1770.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1770.2">
     If you cannot read or understand it, set aside a few minutes, and do some research in the Python documentation until its behavior is clear to you.
    </span>
    <span class="koboSpan" id="kobo.1770.3">
     Being able to look up functions in the documentation
    </span>
    <a id="_idIndexMarker462">
    </a>
    <span class="koboSpan" id="kobo.1771.1">
     and understand code written by someone else is a task that every developer needs to be able to perform.
    </span>
   </p>
   <div class="packt_tip">
    <p class="normal">
     <span class="koboSpan" id="kobo.1772.1">
      To this end, make sure you look up the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1773.1">
       help()
      </span>
     </code>
     <span class="koboSpan" id="kobo.1774.1">
      function, which proves quite helpful when exploring with the console.
     </span>
    </p>
   </div>
   <h2 class="heading-2" id="_idParaDest-149">
    <span class="koboSpan" id="kobo.1775.1">
     Returning multiple values
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1776.1">
     To return multiple values is easy: you
    </span>
    <a id="_idIndexMarker463">
    </a>
    <span class="koboSpan" id="kobo.1777.1">
     just use tuples.
    </span>
    <span class="koboSpan" id="kobo.1777.2">
     Let us look at a simple example that mimics the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1778.1">
      divmod()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1779.1">
     built-in function:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1780.1"># return.multiple.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1781.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1782.1">moddiv</span></span><span class="koboSpan" id="kobo.1783.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1784.1">a, b</span></span><span class="koboSpan" id="kobo.1785.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1786.1">return</span></span><span class="koboSpan" id="kobo.1787.1"> a // b, a % b
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1788.1">print</span></span><span class="koboSpan" id="kobo.1789.1">(moddiv(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1790.1">20</span></span><span class="koboSpan" id="kobo.1791.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1792.1">7</span></span><span class="koboSpan" id="kobo.1793.1">))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1794.1"># prints (2, 6)</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1795.1">
     We could have wrapped the part that is highlighted in the preceding code within brackets, but there is no need for that.
    </span>
    <span class="koboSpan" id="kobo.1795.2">
     The preceding function returns both the result and the remainder of the division, at the same time.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1796.1">
      In the source code for this example, we have left a simple example of a test function to make sure the code is doing the correct calculation.
     </span>
    </p>
   </div>
   <h1 class="heading-1" id="_idParaDest-150">
    <span class="koboSpan" id="kobo.1797.1">
     A few useful tips
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1798.1">
     When writing functions, it is very useful to follow guidelines
    </span>
    <a id="_idIndexMarker464">
    </a>
    <span class="koboSpan" id="kobo.1799.1">
     so that you write them well.
    </span>
    <span class="koboSpan" id="kobo.1799.2">
     We will quickly point some of them out:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1800.1">
       Functions should do one thing
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1801.1">
      : Functions
     </span>
     <a id="_idIndexMarker465">
     </a>
     <span class="koboSpan" id="kobo.1802.1">
      that do one thing are easy to describe in one short sentence; functions that do multiple things can be split into smaller functions that do one thing.
     </span>
     <span class="koboSpan" id="kobo.1802.2">
      These smaller functions are usually easier to read and understand.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1803.1">
       Functions should be small
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1804.1">
      : The smaller they are, the easier it is to test and write them so that they do one thing.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1805.1">
       The fewer input parameters, the better
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1806.1">
      : Functions that take a lot of parameters quickly become hard to manage (among other issues).
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1807.1">
       Functions should be consistent in their return values
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1808.1">
      : Returning
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1809.1">
       False
      </span>
     </code>
     <span class="koboSpan" id="kobo.1810.1">
      and returning
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1811.1">
       None
      </span>
     </code>
     <span class="koboSpan" id="kobo.1812.1">
      are not the same thing, even if, within a Boolean context, they both evaluate to
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1813.1">
       False
      </span>
     </code>
     <span class="koboSpan" id="kobo.1814.1">
      .
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1815.1">
       False
      </span>
     </code>
     <span class="koboSpan" id="kobo.1816.1">
      means that we have information (
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1817.1">
       False
      </span>
     </code>
     <span class="koboSpan" id="kobo.1818.1">
      ), while
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1819.1">
       None
      </span>
     </code>
     <span class="koboSpan" id="kobo.1820.1">
      means that there is no information.
     </span>
     <span class="koboSpan" id="kobo.1820.2">
      Try writing functions that return in a consistent way, no matter what happens in their logic.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1821.1">
       Functions should have no side effects
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1822.1">
      : In functional programming, there is the concept of
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1823.1">
       pure functions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1824.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1824.2">
      This type of function adheres to two main principles:
     </span>
     <ul>
      <li class="bulletList level-2">
       <strong class="keyWord">
        <span class="koboSpan" id="kobo.1825.1">
         Deterministic output
        </span>
       </strong>
       <span class="koboSpan" id="kobo.1826.1">
        : This means that given the same set of inputs, the output produced will always be the same.
       </span>
       <span class="koboSpan" id="kobo.1826.2">
        In other words, the function’s behavior is not dependent on any external or global state that might change during execution.
       </span>
      </li>
      <li class="bulletList level-2">
       <strong class="keyWord">
        <span class="koboSpan" id="kobo.1827.1">
         No side effects
        </span>
       </strong>
       <span class="koboSpan" id="kobo.1828.1">
        : This means that pure functions do not cause any observable side effects in the system.
       </span>
       <span class="koboSpan" id="kobo.1828.2">
        That is, they do not alter any external state, like modifying global variables or performing I/O operations like reading from or writing to a file or the display.
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.1829.1">
     While you should aim to write pure functions whenever possible, it is important that those you write should at least have no side effects.
    </span>
    <span class="koboSpan" id="kobo.1829.2">
     They should not affect the value of the arguments they are called with.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1830.1">
     This is probably the hardest statement to understand at this point, so we will give you an example using lists.
    </span>
    <span class="koboSpan" id="kobo.1830.2">
     In the following code, note how
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1831.1">
      numbers
     </span>
    </code>
    <span class="koboSpan" id="kobo.1832.1">
     is not sorted by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1833.1">
      sorted()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1834.1">
     function, which returns a sorted copy of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1835.1">
      numbers
     </span>
    </code>
    <span class="koboSpan" id="kobo.1836.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1836.2">
     Conversely, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1837.1">
      list.sort()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1838.1">
     method is acting on the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1839.1">
      numbers
     </span>
    </code>
    <span class="koboSpan" id="kobo.1840.1">
     object itself, and that is fine because it is a method (a function that belongs to an object and therefore has the right to modify it):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1841.1">&gt;&gt;&gt; numbers = [4, 1, 7, 5]
&gt;&gt;&gt; sorted(numbers)  # won't sort the original `numbers` list
[1, 4, 5, 7]
&gt;&gt;&gt; numbers  # let's verify
[4, 1, 7, 5]  # good, untouched
&gt;&gt;&gt; numbers.sort()  # this will act on the list
&gt;&gt;&gt; numbers
[1, 4, 5, 7]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1842.1">
     Follow these guidelines and you will automatically shield yourself from certain types of bugs.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.1843.1">
       Chapter 3
      </span>
     </em>
     <span class="koboSpan" id="kobo.1844.1">
      of
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1845.1">
       Clean Code
      </span>
     </em>
     <span class="koboSpan" id="kobo.1846.1">
      , by Robert C.
     </span>
     <span class="koboSpan" id="kobo.1846.2">
      Martin, is dedicated to functions, and it is one of the best sets of guidelines we have ever read on the subject.
     </span>
    </p>
   </div>
   <h1 class="heading-1" id="_idParaDest-151">
    <span class="koboSpan" id="kobo.1847.1">
     Recursive functions
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1848.1">
     When a function calls itself to
    </span>
    <a id="_idIndexMarker466">
    </a>
    <span class="koboSpan" id="kobo.1849.1">
     produce a result, it is said to be
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1850.1">
      recursive
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1851.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1851.2">
     Sometimes recursive functions
    </span>
    <a id="_idIndexMarker467">
    </a>
    <span class="koboSpan" id="kobo.1852.1">
     are very useful, in that they make it easier to write the logic.
    </span>
    <span class="koboSpan" id="kobo.1852.2">
     Some algorithms are very easy to write using recursion, while others are not.
    </span>
    <span class="koboSpan" id="kobo.1852.3">
     There is no recursive function that cannot be rewritten in an iterative fashion, so it is usually up to the programmer to choose the best approach for the case at hand.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1853.1">
     The body of a recursive function usually has two sections: one where the return value depends on a subsequent call to itself, and one where it does not (called the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1854.1">
      base case
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1855.1">
     ).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1856.1">
     As an example, we can consider the (hopefully now familiar)
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1857.1">
      factorial
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1858.1">
     function,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1859.1">
      N!
     </span>
    </em>
    <span class="koboSpan" id="kobo.1860.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1860.2">
     The base case is when
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1861.1">
      N
     </span>
    </em>
    <span class="koboSpan" id="kobo.1862.1">
     is either 0 or 1—the function returns
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1863.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1864.1">
     with no need for further calculation.
    </span>
    <span class="koboSpan" id="kobo.1864.2">
     On the other hand, in the general case,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1865.1">
      N!
     </span>
    </em>
    <span class="koboSpan" id="kobo.1866.1">
     returns the product:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-number"><span class="koboSpan" id="kobo.1867.1">1</span></span><span class="koboSpan" id="kobo.1868.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1869.1">2</span></span><span class="koboSpan" id="kobo.1870.1"> * ... </span><span class="koboSpan" id="kobo.1870.2">* (N-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1871.1">1</span></span><span class="koboSpan" id="kobo.1872.1">) * N 
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1873.1">
     If you think about it,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1874.1">
      N!
     </span>
    </em>
    <span class="koboSpan" id="kobo.1875.1">
     can be rewritten like this:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1876.1">
      N!
     </span>
     <span class="koboSpan" id="kobo.1876.2">
      = (N-1)!
     </span>
     <span class="koboSpan" id="kobo.1876.3">
      * N
     </span>
    </em>
    <span class="koboSpan" id="kobo.1877.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1877.2">
     As a practical example, consider this:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-number"><span class="koboSpan" id="kobo.1878.1">5</span></span><span class="koboSpan" id="kobo.1879.1">! </span><span class="koboSpan" id="kobo.1879.2">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1880.1">1</span></span><span class="koboSpan" id="kobo.1881.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1882.1">2</span></span><span class="koboSpan" id="kobo.1883.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1884.1">3</span></span><span class="koboSpan" id="kobo.1885.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1886.1">4</span></span><span class="koboSpan" id="kobo.1887.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1888.1">5</span></span><span class="koboSpan" id="kobo.1889.1"> = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.1890.1">1</span></span><span class="koboSpan" id="kobo.1891.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1892.1">2</span></span><span class="koboSpan" id="kobo.1893.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1894.1">3</span></span><span class="koboSpan" id="kobo.1895.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1896.1">4</span></span><span class="koboSpan" id="kobo.1897.1">) * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1898.1">5</span></span><span class="koboSpan" id="kobo.1899.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1900.1">4</span></span><span class="koboSpan" id="kobo.1901.1">! </span><span class="koboSpan" id="kobo.1901.2">* </span><span class="hljs-number"><span class="koboSpan" id="kobo.1902.1">5</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1903.1">
     Let us write this down in code:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1904.1"># recursive.factorial.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1905.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1906.1">factorial</span></span><span class="koboSpan" id="kobo.1907.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1908.1">n</span></span><span class="koboSpan" id="kobo.1909.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1910.1">if</span></span><span class="koboSpan" id="kobo.1911.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1912.1">in</span></span><span class="koboSpan" id="kobo.1913.1"> (</span><span class="hljs-number"><span class="koboSpan" id="kobo.1914.1">0</span></span><span class="koboSpan" id="kobo.1915.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1916.1">1</span></span><span class="koboSpan" id="kobo.1917.1">):  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1918.1"># base case</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.1919.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1920.1">1</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1921.1">return</span></span><span class="koboSpan" id="kobo.1922.1"> factorial(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1923.1">1</span></span><span class="koboSpan" id="kobo.1924.1">) * n  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1925.1"># recursive case</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1926.1">
     Recursive functions are often used when writing algorithms, and they can be really fun to write.
    </span>
    <span class="koboSpan" id="kobo.1926.2">
     As an exercise, try to solve a couple of simple problems using both a recursive and an iterative approach.
    </span>
    <span class="koboSpan" id="kobo.1926.3">
     Good candidates for practice might be calculating Fibonacci numbers or the length of a string—things like that.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1927.1">
      When writing recursive functions, always consider how many nested calls you make, since there is a limit.
     </span>
     <span class="koboSpan" id="kobo.1927.2">
      For further information on this, check out
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1928.1">
       sys.getrecursionlimit()
      </span>
     </code>
     <span class="koboSpan" id="kobo.1929.1">
      and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1930.1">
       sys.setrecursionlimit()
      </span>
     </code>
     <span class="koboSpan" id="kobo.1931.1">
      .
     </span>
    </p>
   </div>
   <h1 class="heading-1" id="_idParaDest-152">
    <span class="koboSpan" id="kobo.1932.1">
     Anonymous functions
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1933.1">
     One last type of function that we
    </span>
    <a id="_idIndexMarker468">
    </a>
    <span class="koboSpan" id="kobo.1934.1">
     want to talk about is
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1935.1">
      anonymous
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1936.1">
     functions.
    </span>
    <span class="koboSpan" id="kobo.1936.2">
     These
    </span>
    <a id="_idIndexMarker469">
    </a>
    <span class="koboSpan" id="kobo.1937.1">
     functions, which are
    </span>
    <a id="_idIndexMarker470">
    </a>
    <span class="koboSpan" id="kobo.1938.1">
     called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1939.1">
      lambdas
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1940.1">
     in Python, are usually used when a fully-fledged function with its own name would be overkill, and all we want is a quick, simple one-liner.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1941.1">
     Imagine that we wanted a list of all the numbers up to a certain value of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1942.1">
      N
     </span>
    </em>
    <span class="koboSpan" id="kobo.1943.1">
     that are also multiples of five.
    </span>
    <span class="koboSpan" id="kobo.1943.2">
     We could use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1944.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1945.1">
     function for this, which will require a function and an iterable as input.
    </span>
    <span class="koboSpan" id="kobo.1945.2">
     The return value is a filter object that, when iterated over, yields the elements from the input iterable for which the function returns
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1946.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.1947.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1947.2">
     Without using an anonymous function, we might do something like this:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1948.1"># filter.regular.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1949.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1950.1">is_multiple_of_five</span></span><span class="koboSpan" id="kobo.1951.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1952.1">n</span></span><span class="koboSpan" id="kobo.1953.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1954.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1955.1">not</span></span><span class="koboSpan" id="kobo.1956.1"> n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.1957.1">5</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1958.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1959.1">get_multiples_of_five</span></span><span class="koboSpan" id="kobo.1960.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1961.1">n</span></span><span class="koboSpan" id="kobo.1962.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1963.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1964.1">list</span></span><span class="koboSpan" id="kobo.1965.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1966.1">filter</span></span><span class="koboSpan" id="kobo.1967.1">(is_multiple_of_five, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1968.1">range</span></span><span class="koboSpan" id="kobo.1969.1">(n)))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1970.1">
     Note how we use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1971.1">
      is_multiple_of_five()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1972.1">
     to filter through the first
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1973.1">
      n
     </span>
    </em>
    <span class="koboSpan" id="kobo.1974.1">
     natural numbers.
    </span>
    <span class="koboSpan" id="kobo.1974.2">
     This seems a bit excessive—the task is simple and we do not need to keep the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1975.1">
      is_multiple_of_five()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1976.1">
     function around for anything else.
    </span>
    <span class="koboSpan" id="kobo.1976.2">
     Let us rewrite it using a lambda function:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1977.1"># filter.lambda.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1978.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1979.1">get_multiples_of_five</span></span><span class="koboSpan" id="kobo.1980.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1981.1">n</span></span><span class="koboSpan" id="kobo.1982.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1983.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1984.1">list</span></span><span class="koboSpan" id="kobo.1985.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1986.1">filter</span></span><span class="koboSpan" id="kobo.1987.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1988.1">lambda</span></span><span class="koboSpan" id="kobo.1989.1"> k: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1990.1">not</span></span><span class="koboSpan" id="kobo.1991.1"> k % </span><span class="hljs-number"><span class="koboSpan" id="kobo.1992.1">5</span></span><span class="koboSpan" id="kobo.1993.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1994.1">range</span></span><span class="koboSpan" id="kobo.1995.1">(n)))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1996.1">
     The logic is the same, but the filtering function is now a lambda.
    </span>
    <span class="koboSpan" id="kobo.1996.2">
     Defining a lambda is very easy and follows this form:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1997.1">func_name = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1998.1">lambda</span></span><span class="koboSpan" id="kobo.1999.1"> [parameter_list]: expression
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2000.1">
     A function object is returned, which is equivalent to this:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2001.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2002.1">func_name</span></span><span class="koboSpan" id="kobo.2003.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2004.1">[parameter_list]</span></span><span class="koboSpan" id="kobo.2005.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2006.1">return</span></span><span class="koboSpan" id="kobo.2007.1"> expression
</span></code></pre>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.2008.1">
      Note that optional parameters are indicated following the common syntax of wrapping them in square brackets.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.2009.1">
     Let us
    </span>
    <a id="_idIndexMarker471">
    </a>
    <span class="koboSpan" id="kobo.2010.1">
     look at
    </span>
    <a id="_idIndexMarker472">
    </a>
    <span class="koboSpan" id="kobo.2011.1">
     another couple of examples of equivalent functions, defined in both forms:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2012.1"># lambda.explained.py</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2013.1"># example 1: adder</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2014.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2015.1">adder</span></span><span class="koboSpan" id="kobo.2016.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2017.1">a, b</span></span><span class="koboSpan" id="kobo.2018.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2019.1">return</span></span><span class="koboSpan" id="kobo.2020.1"> a + b
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2021.1"># is equivalent to:</span></span><span class="koboSpan" id="kobo.2022.1">
adder_lambda = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2023.1">lambda</span></span><span class="koboSpan" id="kobo.2024.1"> a, b: a + b
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2025.1"># example 2: to uppercase</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2026.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2027.1">to_upper</span></span><span class="koboSpan" id="kobo.2028.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2029.1">s</span></span><span class="koboSpan" id="kobo.2030.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2031.1">return</span></span><span class="koboSpan" id="kobo.2032.1"> s.upper()
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2033.1"># is equivalent to:</span></span><span class="koboSpan" id="kobo.2034.1">
to_upper_lambda = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2035.1">lambda</span></span><span class="koboSpan" id="kobo.2036.1"> s: s.upper()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2037.1">
     The preceding examples are very simple.
    </span>
    <span class="koboSpan" id="kobo.2037.2">
     The first one adds two numbers, and the second one produces the uppercase version of a string.
    </span>
    <span class="koboSpan" id="kobo.2037.3">
     Note that we assigned what is returned by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2038.1">
      lambda
     </span>
    </code>
    <span class="koboSpan" id="kobo.2039.1">
     expressions to a name (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2040.1">
      adder_lambda
     </span>
    </code>
    <span class="koboSpan" id="kobo.2041.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2042.1">
      to_upper_lambda
     </span>
    </code>
    <span class="koboSpan" id="kobo.2043.1">
     ), but there is no need for that when you use lambdas in the way we did in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2044.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2045.1">
     example.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-153">
    <span class="koboSpan" id="kobo.2046.1">
     Function attributes
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2047.1">
     Every function
    </span>
    <a id="_idIndexMarker473">
    </a>
    <span class="koboSpan" id="kobo.2048.1">
     is a fully fledged object and, as such, it has several attributes.
    </span>
    <span class="koboSpan" id="kobo.2048.2">
     Some of them are special and can be used in an introspective way to inspect the function object at runtime.
    </span>
    <span class="koboSpan" id="kobo.2048.3">
     The following script is an example that shows a few of them and how to display their value for an example function:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2049.1"># func.attributes.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2050.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2051.1">multiplication</span></span><span class="koboSpan" id="kobo.2052.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2053.1">a, b=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.2054.1">1</span></span><span class="koboSpan" id="kobo.2055.1">):
    """Return a multiplied by b."""
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2056.1">return</span></span><span class="koboSpan" id="kobo.2057.1"> a * b
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2058.1">if</span></span><span class="koboSpan" id="kobo.2059.1"> __name__ == "__main__":
    special_attributes = [
        "__doc__",
        "__name__",
        "__qualname__",
        "__module__",
        "__defaults__",
        "__code__",
        "__globals__",
        "__dict__",
        "__closure__",
        "__annotations__",
        "__kwdefaults__",
    ]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2060.1">for</span></span><span class="koboSpan" id="kobo.2061.1"> attribute </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2062.1">in</span></span><span class="koboSpan" id="kobo.2063.1"> special_attributes:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2064.1">print</span></span><span class="koboSpan" id="kobo.2065.1">(attribute, "-&gt;", </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2066.1">getattr</span></span><span class="koboSpan" id="kobo.2067.1">(multiplication, attribute))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2068.1">
     We used the built-in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2069.1">
      getattr()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2070.1">
     function to get the value of those attributes.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2071.1">
      getattr(obj, attribute)
     </span>
    </code>
    <span class="koboSpan" id="kobo.2072.1">
     is equivalent to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2073.1">
      obj.attribute
     </span>
    </code>
    <span class="koboSpan" id="kobo.2074.1">
     and comes in handy when we need to dynamically get an attribute at runtime, taking the name of the attribute from a variable (as in this example).
    </span>
    <span class="koboSpan" id="kobo.2074.2">
     Running this script yields:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2075.1">$ python func.attributes.py
__doc__ -&gt; Return a multiplied by b.
</span><span class="koboSpan" id="kobo.2075.2">__name__ -&gt; multiplication
__qualname__ -&gt; multiplication
__module__ -&gt; __main__
__defaults__ -&gt; (1,)
__code__ -&gt; &lt;code object multiplication at 0x102ce1550,
             file "func.attributes.py", line 2&gt;
__globals__ -&gt; {... </span><span class="koboSpan" id="kobo.2075.3">omitted ...}
__dict__ -&gt; {}
__closure__ -&gt; None
__annotations__ -&gt; {}
__kwdefaults__ -&gt; None
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2076.1">
     We have omitted
    </span>
    <a id="_idIndexMarker474">
    </a>
    <span class="koboSpan" id="kobo.2077.1">
     the value of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2078.1">
      __globals__
     </span>
    </code>
    <span class="koboSpan" id="kobo.2079.1">
     attribute, as it was too big.
    </span>
    <span class="koboSpan" id="kobo.2079.2">
     An explanation of the meaning of this attribute can be found in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2080.1">
      Callable types
     </span>
    </em>
    <span class="koboSpan" id="kobo.2081.1">
     section of the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2082.1">
      Python Data Model
     </span>
    </em>
    <span class="koboSpan" id="kobo.2083.1">
     documentation page:
    </span>
   </p>
   <p class="normal">
    <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy">
     <span class="url">
      <span class="koboSpan" id="kobo.2084.1">
       https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
      </span>
     </span>
    </a>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.2085.1">
      You can use the built-in
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.2086.1">
       dir()
      </span>
     </code>
     <span class="koboSpan" id="kobo.2087.1">
      function to get a list of all the attributes of any object.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.2088.1">
     One thing to notice in the previous example is the use of this clause:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2089.1">if</span></span><span class="koboSpan" id="kobo.2090.1"> __name__ == "__main__":
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2091.1">
     This line makes sure that whatever follows is only executed when the module is run directly.
    </span>
    <span class="koboSpan" id="kobo.2091.2">
     When you run a Python script, Python sets the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2092.1">
      __name__
     </span>
    </code>
    <span class="koboSpan" id="kobo.2093.1">
     variable to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2094.1">
      "__main__"
     </span>
    </code>
    <span class="koboSpan" id="kobo.2095.1">
     in that script.
    </span>
    <span class="koboSpan" id="kobo.2095.2">
     Conversely, when you import a Python script as a module into another script, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2096.1">
      __name__
     </span>
    </code>
    <span class="koboSpan" id="kobo.2097.1">
     variable is set to the name of the script/module being imported.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-154">
    <span class="koboSpan" id="kobo.2098.1">
     Built-in functions
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2099.1">
     Python comes with a lot of
    </span>
    <a id="_idIndexMarker475">
    </a>
    <span class="koboSpan" id="kobo.2100.1">
     built-in functions.
    </span>
    <span class="koboSpan" id="kobo.2100.2">
     They are available anywhere, and you can get a list
    </span>
    <a id="_idIndexMarker476">
    </a>
    <span class="koboSpan" id="kobo.2101.1">
     of them by inspecting the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2102.1">
      builtins
     </span>
    </code>
    <span class="koboSpan" id="kobo.2103.1">
     module with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2104.1">
      dir(__builtins__)
     </span>
    </code>
    <span class="koboSpan" id="kobo.2105.1">
     , or by going to the official Python documentation.
    </span>
    <span class="koboSpan" id="kobo.2105.2">
     Unfortunately, we do not have the room to go through all of them here.
    </span>
    <span class="koboSpan" id="kobo.2105.3">
     We have already seen some of them, such as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2106.1">
      any
     </span>
    </code>
    <span class="koboSpan" id="kobo.2107.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2108.1">
      bin
     </span>
    </code>
    <span class="koboSpan" id="kobo.2109.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2110.1">
      bool
     </span>
    </code>
    <span class="koboSpan" id="kobo.2111.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2112.1">
      divmod
     </span>
    </code>
    <span class="koboSpan" id="kobo.2113.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2114.1">
      filter
     </span>
    </code>
    <span class="koboSpan" id="kobo.2115.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2116.1">
      float
     </span>
    </code>
    <span class="koboSpan" id="kobo.2117.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2118.1">
      getattr
     </span>
    </code>
    <span class="koboSpan" id="kobo.2119.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2120.1">
      id
     </span>
    </code>
    <span class="koboSpan" id="kobo.2121.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2122.1">
      int
     </span>
    </code>
    <span class="koboSpan" id="kobo.2123.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2124.1">
      len
     </span>
    </code>
    <span class="koboSpan" id="kobo.2125.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2126.1">
      list
     </span>
    </code>
    <span class="koboSpan" id="kobo.2127.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2128.1">
      min
     </span>
    </code>
    <span class="koboSpan" id="kobo.2129.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2130.1">
      print
     </span>
    </code>
    <span class="koboSpan" id="kobo.2131.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2132.1">
      set
     </span>
    </code>
    <span class="koboSpan" id="kobo.2133.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2134.1">
      tuple
     </span>
    </code>
    <span class="koboSpan" id="kobo.2135.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2136.1">
      type
     </span>
    </code>
    <span class="koboSpan" id="kobo.2137.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2138.1">
      zip
     </span>
    </code>
    <span class="koboSpan" id="kobo.2139.1">
     , but there are many more, which you should read about at least once.
    </span>
    <span class="koboSpan" id="kobo.2139.2">
     Get familiar with them, experiment, write a small piece of code for each of them, and make sure you have them at your fingertips so that you can use them when needed.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2140.1">
     You can find a list of built-in functions in the official documentation, here:
    </span>
    <a href="https://docs.python.org/3/library/functions.html">
     <span class="url">
      <span class="koboSpan" id="kobo.2141.1">
       https://docs.python.org/3/library/functions.html
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.2142.1">
     .
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-155">
    <span class="koboSpan" id="kobo.2143.1">
     Documenting your code
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2144.1">
     We are big fans of code that
    </span>
    <a id="_idIndexMarker477">
    </a>
    <span class="koboSpan" id="kobo.2145.1">
     does not need documentation.
    </span>
    <span class="koboSpan" id="kobo.2145.2">
     When we write elegant code, following established principles, the code should come out as self-explanatory, with documentation being almost unnecessary.
    </span>
    <span class="koboSpan" id="kobo.2145.3">
     Nevertheless, adding a docstring to a function, or a comment with important information, can be very useful.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2146.1">
     You can find the guidelines for documenting Python in PEP 257 – Docstring conventions at
    </span>
    <a href="https://peps.python.org/pep-0257/">
     <span class="url">
      <span class="koboSpan" id="kobo.2147.1">
       https://peps.python.org/pep-0257/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.2148.1">
     , but we will show you the basics here.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2149.1">
     Python is documented with strings, which are aptly
    </span>
    <a id="_idIndexMarker478">
    </a>
    <span class="koboSpan" id="kobo.2150.1">
     called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.2151.1">
      docstrings
     </span>
    </strong>
    <span class="koboSpan" id="kobo.2152.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2152.2">
     Any object can be documented, and we can use either one-line or multi-line docstrings.
    </span>
    <span class="koboSpan" id="kobo.2152.3">
     One-liners are very simple.
    </span>
    <span class="koboSpan" id="kobo.2152.4">
     They should not provide another signature for the function, but instead state its purpose:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2153.1"># docstrings.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2154.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2155.1">square</span></span><span class="koboSpan" id="kobo.2156.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2157.1">n</span></span><span class="koboSpan" id="kobo.2158.1">):
    """Return the square of a number n."""
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2159.1">return</span></span><span class="koboSpan" id="kobo.2160.1"> n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2161.1">2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2162.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2163.1">get_username</span></span><span class="koboSpan" id="kobo.2164.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2165.1">userid</span></span><span class="koboSpan" id="kobo.2166.1">):
    """Return the username of a user given their </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2167.1">id</span></span><span class="koboSpan" id="kobo.2168.1">."""
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2169.1">return</span></span><span class="koboSpan" id="kobo.2170.1"> db.get(user_id=userid).username
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2171.1">
     Using triple double-quoted strings allows you to expand easily later.
    </span>
    <span class="koboSpan" id="kobo.2171.2">
     Use sentences that end in a period, and do not leave blank lines before or after.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2172.1">
     Multiline comments are structured in a similar way.
    </span>
    <span class="koboSpan" id="kobo.2172.2">
     There should be a one-liner that briefly gives you the gist of what the object is about, and then a more verbose description.
    </span>
    <span class="koboSpan" id="kobo.2172.3">
     As an example, we have documented a fictitious
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2173.1">
      connect()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2174.1">
     function, using the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.2175.1">
      Sphinx
     </span>
    </strong>
    <span class="koboSpan" id="kobo.2176.1">
     notation, in the following example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2177.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2178.1">connect</span></span><span class="koboSpan" id="kobo.2179.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2180.1">host, port, user, password</span></span><span class="koboSpan" id="kobo.2181.1">):
    """Connect to a database.
    </span><span class="koboSpan" id="kobo.2181.2">Connect to a PostgreSQL database directly, using the given
    parameters.
    </span><span class="koboSpan" id="kobo.2181.3">:param host: The host IP.
    </span><span class="koboSpan" id="kobo.2181.4">:param port: The desired port.
    </span><span class="koboSpan" id="kobo.2181.5">:param user: The connection username.
    </span><span class="koboSpan" id="kobo.2181.6">:param password: The connection password.
    </span><span class="koboSpan" id="kobo.2181.7">:</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2182.1">return</span></span><span class="koboSpan" id="kobo.2183.1">: The connection </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2184.1">object</span></span><span class="koboSpan" id="kobo.2185.1">.
    </span><span class="koboSpan" id="kobo.2185.2">"""
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2186.1"># body of the function here...</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.2187.1">return</span></span><span class="koboSpan" id="kobo.2188.1"> connection
</span></code></pre>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.2189.1">
      Sphinx is one of the most widely used tools for creating Python documentation—in fact, the official Python documentation was written with it.
     </span>
     <span class="koboSpan" id="kobo.2189.2">
      It is definitely worth spending some time checking it out.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.2190.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2191.1">
      help()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2192.1">
     built-in function, which is intended for interactive use, creates a documentation page for an object using its docstring.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-156">
    <span class="koboSpan" id="kobo.2193.1">
     Importing objects
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2194.1">
     Now that we know a lot
    </span>
    <a id="_idIndexMarker479">
    </a>
    <span class="koboSpan" id="kobo.2195.1">
     about functions, let us look at how to use them.
    </span>
    <span class="koboSpan" id="kobo.2195.2">
     The whole point of writing functions is to be able to reuse them later and, in Python, this translates to importing them into the namespace where they are needed.
    </span>
    <span class="koboSpan" id="kobo.2195.3">
     There are many ways to import objects into a namespace, but the most common ones are
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2196.1">
      import module_name
     </span>
    </code>
    <span class="koboSpan" id="kobo.2197.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2198.1">
      from module_name import function_name
     </span>
    </code>
    <span class="koboSpan" id="kobo.2199.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2199.2">
     Of course, these are quite simplistic examples, but bear with us for the time being.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2200.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2201.1">
      import module_name
     </span>
    </code>
    <span class="koboSpan" id="kobo.2202.1">
     form finds the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2203.1">
      module_name
     </span>
    </code>
    <span class="koboSpan" id="kobo.2204.1">
     module and defines a name for it in the local namespace, where the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2205.1">
      import
     </span>
    </code>
    <span class="koboSpan" id="kobo.2206.1">
     statement is executed.
    </span>
    <span class="koboSpan" id="kobo.2206.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2207.1">
      from module_name import identifier
     </span>
    </code>
    <span class="koboSpan" id="kobo.2208.1">
     form is a little bit more complicated than that but basically does the same thing.
    </span>
    <span class="koboSpan" id="kobo.2208.2">
     It finds
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2209.1">
      module_name
     </span>
    </code>
    <span class="koboSpan" id="kobo.2210.1">
     and searches for an attribute (or a submodule) and stores a reference to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2211.1">
      identifier
     </span>
    </code>
    <span class="koboSpan" id="kobo.2212.1">
     in the local namespace.
    </span>
    <span class="koboSpan" id="kobo.2212.2">
     Both forms have the option to change the name of the imported object using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2213.1">
      as
     </span>
    </code>
    <span class="koboSpan" id="kobo.2214.1">
     clause:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2215.1">from</span></span><span class="koboSpan" id="kobo.2216.1"> mymodule </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2217.1">import</span></span><span class="koboSpan" id="kobo.2218.1"> myfunc </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2219.1">as</span></span><span class="koboSpan" id="kobo.2220.1"> better_named_func
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2221.1">
     Just to give you a flavor of what importing looks like, here is an example from a test module of one of Fabrizio’s projects (notice that the blank lines between blocks of imports follow the guidelines from PEP 8 at
    </span>
    <a href="https://peps.python.org/pep-0008/#imports">
     <span class="url">
      <span class="koboSpan" id="kobo.2222.1">
       https://peps.python.org/pep-0008/#imports
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.2223.1">
     : standard library first, then third party, and finally local code):
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2224.1"># imports.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2225.1">from</span></span><span class="koboSpan" id="kobo.2226.1"> datetime </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2227.1">import</span></span><span class="koboSpan" id="kobo.2228.1"> datetime, timezone  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2229.1"># two imports, same line</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2230.1">from</span></span><span class="koboSpan" id="kobo.2231.1"> unittest.mock </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2232.1">import</span></span><span class="koboSpan" id="kobo.2233.1"> patch  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2234.1"># single import</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2235.1">import</span></span><span class="koboSpan" id="kobo.2236.1"> pytest  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2237.1"># third party library</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2238.1">from</span></span><span class="koboSpan" id="kobo.2239.1"> core.models </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2240.1">import</span></span><span class="koboSpan" id="kobo.2241.1"> (  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2242.1"># multiline import</span></span><span class="koboSpan" id="kobo.2243.1">
    Exam,
    Exercise,
    Solution,
)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2244.1">
     When we have a structure of files starting in the root of our project, we can use the dot notation to get to the object we want to import into our current namespace, be it a package, a module, a class, a function, or anything else.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2245.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2246.1">
      from module import
     </span>
    </code>
    <span class="koboSpan" id="kobo.2247.1">
     syntax also allows a catch-all clause,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2248.1">
      from module import *
     </span>
    </code>
    <span class="koboSpan" id="kobo.2249.1">
     , which is sometimes used to get all the names from a module into the current namespace at once.
    </span>
    <span class="koboSpan" id="kobo.2249.2">
     This practice is frowned upon for several reasons, relating to performance and the risk of silently shadowing other names.
    </span>
    <span class="koboSpan" id="kobo.2249.3">
     You can read all that there is to know about imports in the official Python documentation but, before we leave the subject, let us give you a better example.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2250.1">
     Imagine that we have
    </span>
    <a id="_idIndexMarker480">
    </a>
    <span class="koboSpan" id="kobo.2251.1">
     defined a couple of functions,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2252.1">
      square(n)
     </span>
    </code>
    <span class="koboSpan" id="kobo.2253.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2254.1">
      cube(n)
     </span>
    </code>
    <span class="koboSpan" id="kobo.2255.1">
     , in a module,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2256.1">
      funcdef.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.2257.1">
     , which is in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2258.1">
      util
     </span>
    </code>
    <span class="koboSpan" id="kobo.2259.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.2259.2">
     We want to use them in a couple of modules that are at the same level as the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2260.1">
      util
     </span>
    </code>
    <span class="koboSpan" id="kobo.2261.1">
     folder, called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2262.1">
      func_import.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.2263.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2264.1">
      func_from.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.2265.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2265.2">
     Showing the tree structure of that project produces something like this:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2266.1">├── func_from.py
├── func_import.py
├── util
│   ├── __init__.py
│   └── funcdef.py
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2267.1">
     Before we show you the code of each module, please remember that in order to tell Python that it is actually a package, we need to put an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2268.1">
      __init__.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.2269.1">
     module in it.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.2270.1">
      There are two things to note about the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.2271.1">
       __init__.py
      </span>
     </code>
     <span class="koboSpan" id="kobo.2272.1">
      file.
     </span>
     <span class="koboSpan" id="kobo.2272.2">
      First, it is a fully fledged Python module so you can put code into it as you would with any other module.
     </span>
     <span class="koboSpan" id="kobo.2272.3">
      Second, as of Python 3.3, its presence is no longer required to make a folder be interpreted as a Python package.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.2273.1">
     The code is as follows:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2274.1"># util/funcdef.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2275.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2276.1">square</span></span><span class="koboSpan" id="kobo.2277.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2278.1">n</span></span><span class="koboSpan" id="kobo.2279.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2280.1">return</span></span><span class="koboSpan" id="kobo.2281.1"> n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2282.1">2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2283.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2284.1">cube</span></span><span class="koboSpan" id="kobo.2285.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2286.1">n</span></span><span class="koboSpan" id="kobo.2287.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2288.1">return</span></span><span class="koboSpan" id="kobo.2289.1"> n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2290.1">3</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2291.1"># func_import.py</span></span><span class="koboSpan" id="kobo.2292.1">
import util.funcdef
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2293.1">print</span></span><span class="koboSpan" id="kobo.2294.1">(util.funcdef.square(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2295.1">10</span></span><span class="koboSpan" id="kobo.2296.1">))
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2297.1">print</span></span><span class="koboSpan" id="kobo.2298.1">(util.funcdef.cube(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2299.1">10</span></span><span class="koboSpan" id="kobo.2300.1">))
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2301.1"># func_from.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2302.1">from</span></span><span class="koboSpan" id="kobo.2303.1"> util.funcdef </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2304.1">import</span></span><span class="koboSpan" id="kobo.2305.1"> square, cube
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2306.1">print</span></span><span class="koboSpan" id="kobo.2307.1">(square(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2308.1">10</span></span><span class="koboSpan" id="kobo.2309.1">))
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2310.1">print</span></span><span class="koboSpan" id="kobo.2311.1">(cube(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2312.1">10</span></span><span class="koboSpan" id="kobo.2313.1">))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2314.1">
     Both these files, when executed, print
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2315.1">
      100
     </span>
    </code>
    <span class="koboSpan" id="kobo.2316.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2317.1">
      1000
     </span>
    </code>
    <span class="koboSpan" id="kobo.2318.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2318.2">
     You can see how differently we then access the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2319.1">
      square
     </span>
    </code>
    <span class="koboSpan" id="kobo.2320.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2321.1">
      cube
     </span>
    </code>
    <span class="koboSpan" id="kobo.2322.1">
     functions, according to how and what we imported in the current scope.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-157">
    <span class="koboSpan" id="kobo.2323.1">
     Relative imports
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.2324.1">
     The type of import we have seen so far is called
    </span>
    <a id="_idIndexMarker481">
    </a>
    <span class="koboSpan" id="kobo.2325.1">
     an
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.2326.1">
      absolute import
     </span>
    </strong>
    <span class="koboSpan" id="kobo.2327.1">
     ; that is, it defines the whole path of either the module that we want to import or from which we want to import an object.
    </span>
    <span class="koboSpan" id="kobo.2327.2">
     There is another way of importing objects into Python, which is called a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.2328.1">
      relative import
     </span>
    </strong>
    <span class="koboSpan" id="kobo.2329.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2329.2">
     Relative imports are done by adding as many leading dots in front of the
    </span>
    <a id="_idIndexMarker482">
    </a>
    <span class="koboSpan" id="kobo.2330.1">
     module as the number of folders we need to backtrack, to find what we are searching for.
    </span>
    <span class="koboSpan" id="kobo.2330.2">
     Simply put, it is something such as this:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2331.1">from</span></span><span class="koboSpan" id="kobo.2332.1"> .mymodule </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2333.1">import</span></span><span class="koboSpan" id="kobo.2334.1"> myfunc
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2335.1">
     Relative imports are quite useful when restructuring projects.
    </span>
    <span class="koboSpan" id="kobo.2335.2">
     Not having the full path in the imports allows the developer to move things around without having to rename too many of those paths.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2336.1">
     For a complete
    </span>
    <a id="_idIndexMarker483">
    </a>
    <span class="koboSpan" id="kobo.2337.1">
     explanation of relative imports, refer to PEP 328:
    </span>
    <a href="https://peps.python.org/pep-0328/">
     <span class="url">
      <span class="koboSpan" id="kobo.2338.1">
       https://peps.python.org/pep-0328/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.2339.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2340.1">
     In later chapters, we will create projects using different libraries and use several different types of imports, including relative ones, so make sure you take a bit of time to read up about them in the official Python documentation.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-158">
    <span class="koboSpan" id="kobo.2341.1">
     One final example
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2342.1">
     Before we finish
    </span>
    <a id="_idIndexMarker484">
    </a>
    <span class="koboSpan" id="kobo.2343.1">
     off this chapter, let us go through one last example.
    </span>
    <span class="koboSpan" id="kobo.2343.2">
     We could write a function to generate a list of prime numbers up to a limit; we have already seen the code for this in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.2344.1">
      Chapter 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.2345.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.2346.1">
      Conditionals and Iteration
     </span>
    </em>
    <span class="koboSpan" id="kobo.2347.1">
     , so let us make it a function and, to keep it interesting, let us optimize it a bit.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2348.1">
     First of all, we do not need to divide by all the numbers from
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2349.1">
      2
     </span>
    </em>
    <span class="koboSpan" id="kobo.2350.1">
     to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2351.1">
      N-1
     </span>
    </em>
    <span class="koboSpan" id="kobo.2352.1">
     to decide whether a number,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2353.1">
      N
     </span>
    </em>
    <span class="koboSpan" id="kobo.2354.1">
     , is prime.
    </span>
    <span class="koboSpan" id="kobo.2354.2">
     We can stop at
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2355.1">
      √N
     </span>
    </em>
    <span class="koboSpan" id="kobo.2356.1">
     (the square root of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2357.1">
      N
     </span>
    </em>
    <span class="koboSpan" id="kobo.2358.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.2358.2">
     Moreover, we do not need to test the division for all the numbers from
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2359.1">
      2
     </span>
    </em>
    <span class="koboSpan" id="kobo.2360.1">
     to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2361.1">
      √N
     </span>
    </em>
    <span class="koboSpan" id="kobo.2362.1">
     , as we can just use the primes in that range.
    </span>
    <span class="koboSpan" id="kobo.2362.2">
     We leave it up to you to figure out the math for why this works, if you are interested.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2363.1">
     Let us see how the code changes:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2364.1"># primes.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2365.1">from</span></span><span class="koboSpan" id="kobo.2366.1"> math </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2367.1">import</span></span><span class="koboSpan" id="kobo.2368.1"> sqrt, ceil
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2369.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2370.1">get_primes</span></span><span class="koboSpan" id="kobo.2371.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2372.1">n</span></span><span class="koboSpan" id="kobo.2373.1">):
    """Calculate a </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2374.1">list</span></span><span class="koboSpan" id="kobo.2375.1"> of primes up to n (included)."""
    </span><span class="koboSpan" id="kobo.2375.2">primelist = []
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2376.1">for</span></span><span class="koboSpan" id="kobo.2377.1"> candidate </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2378.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2379.1">range</span></span><span class="koboSpan" id="kobo.2380.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2381.1">2</span></span><span class="koboSpan" id="kobo.2382.1">, n + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2383.1">1</span></span><span class="koboSpan" id="kobo.2384.1">):
        is_prime = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2385.1">True</span></span><span class="koboSpan" id="kobo.2386.1">
        root = ceil(sqrt(candidate))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2387.1"># division limit</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.2388.1">for</span></span><span class="koboSpan" id="kobo.2389.1"> prime </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2390.1">in</span></span><span class="koboSpan" id="kobo.2391.1"> primelist:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2392.1"># we try only the primes</span></span>
            <span class="hljs-keyword"><span class="koboSpan" id="kobo.2393.1">if</span></span><span class="koboSpan" id="kobo.2394.1"> prime &gt; root:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2395.1"># no need to check any further</span></span>
                <span class="hljs-keyword"><span class="koboSpan" id="kobo.2396.1">break</span></span>
            <span class="hljs-keyword"><span class="koboSpan" id="kobo.2397.1">if</span></span><span class="koboSpan" id="kobo.2398.1"> candidate % prime == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2399.1">0</span></span><span class="koboSpan" id="kobo.2400.1">:
                is_prime = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2401.1">False</span></span>
                <span class="hljs-keyword"><span class="koboSpan" id="kobo.2402.1">break</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.2403.1">if</span></span><span class="koboSpan" id="kobo.2404.1"> is_prime:
            primelist.append(candidate)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2405.1">return</span></span><span class="koboSpan" id="kobo.2406.1"> primelist
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2407.1">
     The code is the same as that in the previous chapter.
    </span>
    <span class="koboSpan" id="kobo.2407.2">
     We have changed the division algorithm so that we only test divisibility using the previously calculated primes, and we stopped once the testing divisor was greater than the root of the candidate.
    </span>
    <span class="koboSpan" id="kobo.2407.3">
     We used the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2408.1">
      primelist
     </span>
    </code>
    <span class="koboSpan" id="kobo.2409.1">
     result list to get the primes for the division and calculated the root value using a fancy formula, the integer value of the ceiling of the root of the candidate.
    </span>
    <span class="koboSpan" id="kobo.2409.2">
     While a simple
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2410.1">
      int(k ** 0.5) + 1
     </span>
    </code>
    <span class="koboSpan" id="kobo.2411.1">
     would have also served our purpose, the formula we chose is cleaner and requires a
    </span>
    <a id="_idIndexMarker485">
    </a>
    <span class="koboSpan" id="kobo.2412.1">
     couple of imports, which is what we wanted to show.
    </span>
    <span class="koboSpan" id="kobo.2412.2">
     Check out the functions in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2413.1">
      math
     </span>
    </code>
    <span class="koboSpan" id="kobo.2414.1">
     module—they are very interesting!
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-159">
    <span class="koboSpan" id="kobo.2415.1">
     Summary
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2416.1">
     In this chapter, we explored the world of functions.
    </span>
    <span class="koboSpan" id="kobo.2416.2">
     They are very important and, from now on, we will use them in virtually everything we do.
    </span>
    <span class="koboSpan" id="kobo.2416.3">
     We talked about the main reasons for using them, the most important of which are code reuse and implementation hiding.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2417.1">
     We saw that a function object is like a box that takes optional inputs and may produce outputs.
    </span>
    <span class="koboSpan" id="kobo.2417.2">
     We can feed input arguments to a function in many different ways, using positional and keyword arguments, and using variable syntax for both types.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2418.1">
     You should now know how to write a function, document it, import it into your code, and call it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2419.1">
     In the next chapter, we will be picking up the pace a little bit, so we suggest you spend a bit of time consolidating and enriching the knowledge you have gathered so far by experimenting with code and reading the Python official documentation.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-160">
    <span class="koboSpan" id="kobo.2420.1">
     Join our community on Discord
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2421.1">
     Join our community’s Discord space for discussions with the authors and other readers:
    </span>
   </p>
   <p class="normal">
    <a href="Chapter_4.xhtml">
     <span class="url">
      <span class="koboSpan" id="kobo.2422.1">
       https://discord.com/invite/uaKmaz7FEC
      </span>
     </span>
    </a>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2423.1">
     <img alt="img" src="../Images/QR_Code119001106417026468.png"/>
    </span>
   </p>
  </div>
 </body></html>