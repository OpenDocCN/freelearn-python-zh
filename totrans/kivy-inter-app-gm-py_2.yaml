- en: Chapter 2. Graphics – the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any Kivy `Widget` contains a **`Canvas`** object. A Kivy **`Canvas`** is a set
    of drawing instructions that define the graphical representation of `Widget`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful with the name because it tends to be confusing! A **`Canvas`** object
    is not what we draw on (for example, as it is in HTML5); it is a set of instructions
    to draw in the **coordinate space**.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate space refers to the place in which we draw. All the Kivy widgets
    share the same coordinate space, and a `Canvas` instance, the instructions to
    draw on it. A coordinate space is not restricted to the size of the window or
    the application screen, which means that we can draw outside of the visible area.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss how to draw and manipulate the representation of the widgets
    through the instructions we add to the `Canvas` object. Here is a list of the
    most important skills that we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing basic geometric shapes (straight and curve lines, ellipses, and polygons)
    through **vertex instructions**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using colors, and rotating, translating, and scaling the coordinate space through
    the **context instructions**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between vertex and context instructions and how they complement
    each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three different sets of instructions of `Canvas` that we can use to modify
    the order of execution of the graphics instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving the current coordinate space context through `PushMatrix`
    and `PopMatrix`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Kivy canvas brings with it some technical challenges because Kivy
    integrates graphic processing with efficiency in mind. These challenges are not
    initially obvious, but there is nothing particularly difficult about them if we
    understand the underlying problem. This is why the next section is dedicated to
    introduce the main considerations that we face when we use the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before studying the examples of this chapter, it is important to recapitulate
    the following particularities related to the graphics display:'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate space refers to the place in which we draw, which is not restricted
    to the windows size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Canvas` object is a set of instructions to draw in the coordinate space,
    not the place we draw in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All `Widget` objects contain their own `Canvas` (canvases, which we will see
    later) but all of them share the same coordinate space, the one in the `App` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if we add a rotation instruction to a specific `Canvas` instance
    (for example, the canvas of a button), then this will also affect all the subsequent
    graphics instructions that are going to display graphics in the coordinate space.
    It doesn't matter if the graphics belong to canvases of different widgets; they
    all share the same coordinate space.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we need to learn techniques to leave the coordinate space context
    in its original state after modifying it with graphics instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the graphics instructions added to different `Canvas` objects, which at
    the same time belong to different `Widget` objects, affect the same coordinate
    space. It is our task to make sure that the coordinate space is in its original
    state after modifying it with the graphics instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept that we need to extend is the one of the **`Widget`**.
    We already know that widgets are the blocks that allow us to build interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **`Widget`** is also a place marker (with its position and size), but not
    necessarily a placeholder. The instructions of the canvas of a widget are not
    restricted to the specific area of the widget but to the whole coordinate space.
  prefs: []
  type: TYPE_NORMAL
- en: This directly adds to the previous problem of sharing a coordinate space. Not
    only do we need to control the fact that we share a coordinate space, but also,
    we have no restrictions on where to draw. On one hand, this makes Kivy very efficient
    and gives us a lot of flexibility. On the other hand, this seems to be a lot to
    control. Fortunately, Kivy provides the necessary tools to easily work around
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will present the available graphics instructions that can be
    added to the canvas in order to draw basic shapes. After this, we will explore
    graphic instructions that change the coordinate space context and exemplify the
    problems of sharing the coordinate space. The final section concentrates on illustrating
    the acquired knowledge inside the **Comic Creator**, where we learn the most common
    techniques to master the use of the canvas considering its particularities. By
    the end of this chapter, we will be in complete control of the graphics that are
    displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing basic shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting, let''s introduce the Python code that we will reuse in all
    the examples of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We created the subclass `DrawingSpace` from `RelativeLayout`. It could have
    been inherited from any `Widget` but using `RelativeLayout` is generally a good
    choice for graphics because we usually want to draw inside the widget, and that
    means relative to its position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the canvas. There are basically two types of instructions
    that we can add to a canvas: vertex instructions and context instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **vertex instructions** inherit from the **`VertexInstruction`** base class,
    and allow us to draw vector shapes in the coordinate space.
  prefs: []
  type: TYPE_NORMAL
- en: The **context instructions** (`Color`, `Rotate`, `Translate`, and `Scale`) inherit
    from the **`ContextInstruction`** base class, and let us apply transformations
    to the **coordinate space context**. By **coordinate space context**, we mean
    the conditions in which the shapes (specified in the vertex instructions) are
    drawn in the coordinate space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, **vertex instructions** are what we draw and **context instructions**
    affect where and how we draw. The following is the screenshot for the first example
    of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing basic shapes](img/B04244_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, the gray grid will simplify reading the coordinates
    that appear in the code. Also, the white letters associated with each cell will
    be used to refer to the shapes. Neither the grid nor the letters are part of the
    Kivy example. The preceding screenshot illustrates 10 basic figures that we learn
    to draw with vertex instructions. Almost all the available Kivy classes are represented
    in this example and we can create any 2D geometric shape with them. Since the
    vertex instructions use fixed coordinates, it is important to run this example
    with a screen size of 500 x 200 (`python drawing.py --size=500x200`) in order
    to visualize the shapes correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will study the Kivy language (`drawing.kv`) with small code fragments associated
    to the respective figure (and coordinates) next to it, so it would be easier to
    follow. Let''s start with the shape **A** (rectangle):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing basic shapes](img/B04244_02_01a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Following is the code snippet for shape **A**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**`Rectangle`** is a good starting point because it resembles the way we set
    properties in widgets. We just have to set the **`pos`** and **`size`** properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **`pos`** and **`size`** properties of the vertex instructions are different
    from the `pos` and `size` properties of `Widget`, since they belong to the `VertexInstruction`
    base class. All the values to specify the properties of the vertex instructions
    are given in fixed values.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we cannot use the `size_hint` or `pos_hint` properties as we
    did with the widgets in [Chapter 1](ch01.html "Chapter 1. GUI Basics – Building
    an Interface"), *GUI Basics – Building an Interface*. However, we can use the
    properties of `self` to achieve similar results (Line 18 and 19).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed with the shape **B** (Pac-Man-like figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing basic shapes](img/B04244_02_01b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Following is the code snippet for shape **B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The **`Ellipse`** works very similar to `Rectangle`, but it has three new properties:
    **`angle_start`**, **`angle_end`**, and **`segments`**. The first two properties
    specify the initial and final angle of the ellipse. The angle 0° is North (or
    12 o''clock) and they add up in the clockwise direction. So, the `angle_start`
    is 120° (90° + 30°), which is the lower jaw of the Pac-Man-like figure (Line 21).
    The `angle_end` value is 420° (360° + (90°-30°)), which is bigger than `angle_start`
    because we need Kivy to follow the clockwise direction to paint the `Ellipse`.
    If we specify a lower value than `angle_start`, Kivy will follow a counter clockwise
    direction, painting where the mouth of the Pac-Man is, instead of its body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with the shape **C** (triangle):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing basic shapes](img/B04244_02_01c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The triangle of shape **C** is actually another **`Ellipse`** that we obtain
    thanks to the **`segments`** property (Line 26). Let''s put it this way: if you
    have to draw an ellipse with three lines, the best you would end up with is a
    triangle. If you have four lines, you would end up with a rectangle. You actually
    need infinite lines for a perfect `Ellipse`, but a computer cannot process that
    (neither the screen has enough resolution to support this), so we need to stop
    at some point. The default `segments` are 180\. Notice that if you have a circle
    (that is, size: x,x), you will always get equilateral polygons (for example, a
    square if you specify just four `segments`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can analyze shapes **D**, **E**, **F**, and **G** together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing basic shapes](img/B04244_02_01d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**`Triangle`** (shape **D**), **`Quad`** (shape **E**), and **`Line`** (shape
    **F**) work similarly. Their **`points`** property (Lines 30, 32, and 34) indicates
    the corners of a triangle, quadrilateral, and a line, respectively. The **`points`**
    property is a sequence of coordinates in the format `(x1, y1, x2, y2)`. `Point`
    is also similar to these three shapes. It uses the **`points`** property (Line
    36) but in this case to indicate a sequence of points (shape **G**). It also uses
    the **`pointsize`** (Line 37) property to indicate the size of the `Points`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed with the shape **H**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing basic shapes](img/B04244_02_01e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**`Bezier`** is a curved line that uses the **`points`** property as a set
    of ''attractors'' of the curve line (there is a math formalism behind Bézier curves
    that we are not going to cover in this book because it is out of its scope, but
    you can find enough information in Wikipedia [http://en.wikipedia.org/wiki/Bézier_curve](http://en.wikipedia.org/wiki/B%C3%A9zier_curve)).
    The points are attractors because the line does not touch all of them (just the
    first and the last of them). The points of `Bezier` (Line 39) are at the same
    distance from each other as the points of the `Line` (Line 34), or the `Point`
    (Line 36); they were just translated 100 pixels to the right. You can visually
    compare the result of the Bezier curve (shape **H**), with the results of the
    `Line` (shape **G**) or the `Point` (shape **H**). We included two other properties
    **`dash_length`** (Line 41), for the length of the dashes of the discontinuous
    line, and **`dash_offset`** (Line 42) for the distance between the dashes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cover the last shapes **I** and **J**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing basic shapes](img/B04244_02_01f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We added two **`Mesh`** instructions (Lines 43 and 47). A **`Mesh`** instruction
    is a compound of triangles and has many applications in computer graphics and
    games. There is not enough space in this book to cover the advanced techniques
    to use this instruction, but at the very least we will understand its basics and
    be able to draw flat polygons. The **`mode`** property is set to `triangle_fan`
    (Line 44), which means that the triangles of the mesh are filled with color, instead
    of, for example, just drawing the border.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **`vertices`** property is a tuple of coordinates. For the purpose of this
    example, we will just ignore all the 0s. This will leave us with four coordinates
    (or vertices) in line 45\. These points are relatively the same as shapes **F**,
    **G**, and **H**. Let''s imagine for the shape I how the triangles are created
    as we traverse them, left to right on the vertex list using three vertex points
    each time. The shape **I** is composed of two triangles. The first triangle uses
    the first, second, and third vertices; and the second triangle uses the first,
    third, and fourth vertices. In general, if we are in the i^(th) vertex of the
    list, a triangle is drawn using the first vertex, the (i-1)^(th) vertex, and the
    i^(th) vertex. The final mesh (shape **J**) presents another example. It contains
    three triangles that are surrounded by a blue line in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing basic shapes](img/B04244_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **`indexes`** property contains a list with the same number of vertices
    (not counting the 0s) and instructs the order in which the vertices list is traversed,
    altering the triangles that compose the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all the polygons that we studied have been colored in. If we need to
    draw the border of the polygon, we should use **`Line`** instead. In principle,
    this seems easy for a basic shape such as a triangle, but how do we draw a circle
    with just points? Fortunately, `Line` has the appropriate properties to make things
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example will show how you can build the figures in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing basic shapes](img/B04244_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Line examples
  prefs: []
  type: TYPE_NORMAL
- en: 'We have kept the gray coordinates and the letter to identify each cell in the
    screenshot. The Python code should be run in a screen size of 400 x 100: `python
    drawing.py --size=400x100`. The following is the `drawing.kv` code for the previous
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we added four **`Line`** instructions using specific properties.
    The first `Line` instruction (in line 54, shape **A**) is similar to our Pac-Man
    (line 20). The **`ellipse`** property (line 55) specifies `x`, `y`, `width`, `height`,
    `angle_start`, `angle_end`, and `segments`, respectively. The order of the parameters
    is difficult to remember so we should always keep the Kivy API next to us ([http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html](http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html)).
    We also set **`width`** of `Line` to make it thicker (line 56).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second `Line` instruction (line 57, shape **B**) introduces a property
    that has no counterpart in the vertex instructions: **`circle`**. The difference
    with the `ellipse` property is that the first three parameters (line 58) define
    the center (150, 50) and radius (40) of `Circle`. The rest remains the same. The
    third `Line` (line 59, shape **C**) is defined by **`rectangle`** (line 60) and
    the parameters are simply `x`, `y`, `width`, and `height`. The last `Line` (line
    61, shape **D**) is the most flexible way to define polygons. We specified the
    points (line 62), as many as we want. The **`close`** property (line 63) connects
    the first and last points.'
  prefs: []
  type: TYPE_NORMAL
- en: We covered most of the instructions and properties related to vertex instructions.
    We should be able to draw any geometrical shape in two dimensions with Kivy. If
    you want more details about each of the instructions, you should visit the Kivy
    API ([http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html](http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html)).
    Now, it is the turn of context instructions to decorate these boring black and
    white polygons.
  prefs: []
  type: TYPE_NORMAL
- en: Adding images, colors, and backgrounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss how to add images and colors to our graphics
    and how to control which graphic comes on top of which one. We continue using
    the same Python code of the first section. This time, we run it with a 400 x 100
    screen size: `python drawing.py --size=400x100`. The following screenshot shows
    the final result of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding images, colors, and backgrounds](img/B04244_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Images and Colors
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the corresponding `drawing.kv` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code starts with `Ellipse` (line 67) and `Rectangle` (line 71). We used
    the **`source`** property, which inserts an image to decorate each polygon. The
    `kivy.png` image is 80 x 80 pixels with a white background (without any alpha/transparency
    channel). The result is shown in the first two columns of the "Images and Colors"
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line 75, we used the context instruction **`Color`** to change the color
    (with the **`rgba`** property: red, green, blue, and alpha) of the coordinate
    space context. This means that the next vertex instruction will be drawn with
    the color changed by `rgba`. A context instruction basically changes the current
    coordinate space context. In the screenshot, you can see the thin blue bar (or
    very dark gray bar in the printed version of this book) at the bottom (line 77)
    that appears as transparent blue (line 76) instead of the default white (`1,1,1,1`)
    of the previous examples. We set the ends shape of the line, to a square with
    the **`cap`** property (line 80).'
  prefs: []
  type: TYPE_NORMAL
- en: We changed the color again in line 81\. After this, we drew two more rectangles,
    one with the `kivy.png` image and another without it. In the preceding screenshot,
    you can see that the white part of the image has become as green, or light gray
    in the printed version of this book, as the basic `Rectangle` on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Color` instruction acts as a light that illuminates the `kivy.png` image,
    it doesn't simply paint over it.
  prefs: []
  type: TYPE_NORMAL
- en: There is another important detail to notice in the screenshot. The blue (dark
    gray in the printed version) line at the bottom goes over the first two polygons
    and goes under the last two. The instructions are executed in order and this might
    bring some unwanted results. Kivy provides a solution to make this execution more
    flexible, and structured, which we will introduce in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring graphic instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from the `canvas` instance, a Widget includes two other canvas instances:
    **`canvas.before`** and **`canvas.after`**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Widget` class has three sets of instructions (**`canvas.before`**, **`canvas`**,
    and **`canvas.after`**) to organize the order of execution. With them, we can
    control which elements will go to the background or stay on the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `drawing.kv` file shows an example of these three sets (lines
    92, 98, and 104) of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In each set, a rectangle of different color is drawn (lines 95, 101, and 107).
    Here is a diagram that illustrates the execution order of the canvases. The numbers
    on the top-left margin of each code block indicates the order of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structuring graphic instructions](img/B04244_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Execution order of the canvas
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we didn''t define any `canvas`, `canvas.before`, or `canvas.after`
    for `Button` but Kivy does internally. Since `Button` displays graphics on the
    screen (for example, it contains `Rectangle` associated with the **`background_color`**
    property), then it has instructions in its canvas sets. The final result is shown
    in the following screenshot (executed with: `python drawing.py --size=300x100`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structuring graphic instructions](img/B04244_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before and after canvas
  prefs: []
  type: TYPE_NORMAL
- en: The graphics of `Button` (the child) are covered up by the set of instructions
    in `canvas.after`. It is clear that the instructions of `canvas.before` and `canvas`
    are executed before the displaying `Button`, but what is executed between them?
    It is necessary when we work with inheritance, and we want to add instructions
    in the subclass that should be executed before the `canvas` set of instructions
    of the base class. Also, it is a convenience when we mix Python code and Kivy
    language rules. We will study some practical examples in the last section of this
    chapter related to the *Comic Creator*, and review the topic in [Chapter 4](ch04.html
    "Chapter 4. Improving the User Experience"), *Improving the User Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: For now, it is good enough to understand that we have three sets of instructions
    (`Canvas`) that provide some flexibility when we display graphics on the screen.
    Let's now explore some more context instructions related to transformations of
    the vertex instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating, translating, and scaling the coordinate space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**`Rotate`**, **`Translate`**, and **`Scale`** are context instructions that
    are applied to the vertex instructions, which are displayed in the coordinate
    space. They could bring unexpected results if we forget that the coordinate space
    is shared among all widgets, and it occupies the size of the window (actually
    bigger than that because there is no restriction on the coordinates and we can
    draw outside the window). First, we are going to understand the behavior of this
    instruction in this section and, in the next section, we can analyze the problems
    they bring in a deeper way, and learn techniques to make things easier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the new `drawing.kv` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the first thing we did is position the coordinates (0, 0) of `DrawingSpace`
    (`RelativeLayout`) in the center of the screen (line 116). We created `Rectangle`
    with the `kivi.png` figure, which we had previously modified to indicate the original
    **x** axis and **y** axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is presented in the top-right of the following screenshot (executed
    with `python drawing.py --size=200x200`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rotating, translating, and scaling the coordinate space](img/B04244_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rotate, Translate and Scale
  prefs: []
  type: TYPE_NORMAL
- en: In the line 120, we applied the **`Rotate`** instruction by 90° on the z axis
    (line 122). The value is (x, y, z), which means we can use any vector in the 3D
    space. Think of this as nailing a pin to the bottom-left corner of `DrawingSpace`,
    which we then rotate in the counter clockwise direction.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the pin nail of the rotation is always the coordinates (0, 0) but
    we can alter this behavior with the **`origin`** property.
  prefs: []
  type: TYPE_NORMAL
- en: The top-left section of the screenshot ("Rotate, Translate, and Scale") shows
    the result after the rotation. We drew the same rectangle with red color (using
    the **`rgb`** property instead of the `rgba` property) to highlight it. After
    adding a rotation to the coordinate space context, we also modified the relative
    X-axis and Y-axis. Line 128 considers that the axes are rotated, and in order
    to translate the coordinate space down (usually Y-axis), it sets -100px to the
    X-axis. We drew the same `Rectangle` with green `Color` in the bottom left corner.
    Notice that the image still rotates and it will rotate as long as we don't bring
    the coordinate space context to its original angle.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Context instructions are persistent until we change them back again. Another
    way to avoid this is working inside `RelativeLayout`. If you remember from the
    previous chapter, it allows us to work with coordinates relative to the widget.
  prefs: []
  type: TYPE_NORMAL
- en: To scale or zoom out the image, we translated the coordinate space context (line
    133) to use the bottom-right section of the screenshot. Notice that we use the
    Y-axis instead of the X-axis, since the context is still rotated. The scaling
    is done in line 135, where the image will be reduced to half the width and half
    the height. The `Scale` instruction reduces towards the (0, 0) coordinate, which
    initially is at the bottom-left corner. However, after all these modifications
    of the context, we need to think where this coordinate is. First, we rotated the
    axis (line 120) so the X-axis is vertical and the Y-axis is horizontal. After
    translating the coordinate space down (line 127) and then right (line 133), the
    (0, 0) coordinate is in the bottom-right corner with the X-axis being the vertical
    one and the Y-axis being the horizontal one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**`Scale`** uses proportions to the current size of the coordinate space context
    and not the original size. For example, to recover the original size, we should
    use `xyz: (2,2,0)` and not just `xyz: (1,1,0)`.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, in this chapter, we have discussed that a `Canvas` instance is a set
    of instructions that contains context instructions and vertex instructions. The
    context instructions apply changes (colors or transformation) to the coordinate
    space context that affects the conditions in which the vertex instructions are
    displayed in the coordinate space.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use some of the knowledge to add *Stickman* to our project in the next
    and final section of this chapter. We will introduce two important context instructions
    to deal with the issues of sharing the same coordinate space between widgets:
    `PushMatrix` and `PopMatrix`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comic Creator: PushMatrix and PopMatrix'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s insert some graphics to the project we started in [Chapter 1](ch01.html
    "Chapter 1. GUI Basics – Building an Interface"), *GUI Basics – Building an Interface*.
    Before this, we need to recapitulate two important lessons of this chapter related
    to the coordinate space:'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate space is not restricted to any position or size. It normally
    has its origin in the bottom-left corner of the screen. To avoid this, we use
    `RelativeLayout`, which internally performs a translation to the position of the
    `Widget`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the coordinate space context is transformed by any instruction, it stays
    like that until we specify something different. `RelativeLayout` also addresses
    this problem with two contextual instructions, which we will study in this section:
    **`PushMatrix`** and **`PopMatrix`**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use `RelativeLayout` in this section to avoid the problems of the shared
    coordinate space, but we will also explain the alternatives to it when we are
    inside any other type of `Widget`. We will add a new file (`comicwidgets.kv`)
    to our project. In `comicreator.py`, we need to add our new file to `Builder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The file `comicwidgets.kv` will contain special widgets, which we will create
    for the project. In this chapter, we will add the `StickMan` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 142, the `StickMan` subclass inherits from `RelativeLayout` to facilitate
    the positioning and use of context instructions. We defined `StickMan` of size
    48 x 48\. `StickMan` is composed of six lines that define the head, body, left
    leg, right leg, left arm, and right arm (line 147 to 163). You can see the result
    of `StickMan` three times in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comic Creator: PushMatrix and PopMatrix](img/B04244_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Comic Creator
  prefs: []
  type: TYPE_NORMAL
- en: The first `StickMan` is part of the design of the last `ToolButton` and the
    other two appear in the *drawing space*; one of them is scaled. Notice that the
    code of the legs (lines 151 to 154) is exactly the same as the arms (lines 160
    to 163); the difference is that we translated the coordinate space upwards (lines
    155 and 156) and rotated it 180° in the x-axis (lines 157 to 159). With this,
    we saved ourselves some math to draw the *stickman*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We translated and rotated the coordinate space context; therefore, we should
    undo these context changes so everything will remain as it was at the beginning.
    Instead of adding more instructions to `Translate` and `Rotate` back to the coordinate
    space context, we used two convenient Kivy instructions: **`PushMatrix`** and
    **`PopMatrix`**. At the beginning, we used a `PushMatrix` (line 146), which will
    save the current coordinate space context and, at the end, we used a `PopMatrix`
    (line 164) to return the context to its original state.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**`PushMatrix`** saves the current coordinate space context and **`PopMatrix`**
    retrieves the last saved coordinate space context. Therefore, the transformation
    instructions (`Scale`, `Rotate`, and `Translate`) surrounded by **`PushMatrix`**
    and **`PopMatrix`** won''t affect the rest of the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will extend this approach to add shapes to the other two instances of `ToolButton`
    (circle and line) in the top-left corner of `ToolBox`. We add this code in `toolbox.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the `ToolButton` class (line 166), we used a `PushMatrix` (line 171) in the
    `canvas` set of instructions to save the current state of the coordinate space.
    Then, `Translate` (line 172) moves the graphic instructions to the position of
    `ToolButton` so we can use relative coordinates on each `ToolButton` (line 180
    to 190). Finally, `PopMatrix` (line 175) was added to `canvas.after` to restore
    the coordinate space.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to follow the execution order of the different canvases (instruction
    sets). For example, let''s slowly follow the execution order of the canvases of
    `ToolButton` that contains the circle (line 180): first, `canvas` of the `ToolButton`
    class that has `PushMatrix` and `Translate` (line 170); second, `canvas` of the
    `ToolButton` instance, which has the circle (line 181), and third, `canvas.after`
    of the base class, which has `PopMatrix` (line 174). We just implemented the same
    technique used for `RelativeLayout`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**`RelativeLayout`** internally contains `PushMatrix` and `PopMatrix`. Therefore,
    we can add instructions safely inside it, which won''t affect the rest of the
    interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s conclude this chapter by scaling our *stickman* in the *drawing space*
    and illustrate one more particularity of the execution order of the canvases.
    The following is the code of `drawingspace.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first `StickMan` was translated and rotated (lines 193 to 199), but not
    the second one (line 200). We discussed that the context instructions affect the
    coordinate space globally, but when we see the result in the screenshot ("Comic
    Creator"), we realize that the second instance was neither scaled nor translated
    by the lines 196 and 198\. What happened? The answer is not obvious. Is the answer
    related to `PushMatrix` and `PopMatrix` inside the canvas of the `StickMan` class
    (lines 146 and 164)? No, it isn't, because both of them are inside the same set
    of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The way we implemented `ToolButton` follows the way the `RelativeLayout` class
    is implemented. `StickMan` inherits from `RelativeLayout`, so there is actually
    another `PushMatrix` in `canvas.before` and its respective `PopMatrix` in `canvas.after`
    of the `StickMan` class (inherited from `RelativeLayout`). The instructions from
    lines 196 to 199 are executed after `PopMatrix` is executed in `canvas.before`
    of `RelativeLayout` and, therefore, the context is restored on the respective
    `PushMatrix` of `RelativeLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, notice that the instructions must be in `canvas.before` because they
    are added before the existent instructions, the ones that actually draw the *stickman*.
    In other words, if we simply add them in the canvas, then the *stickman* would
    be drawn before the translation and scaling.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the files of the *Comic Creator* `comiccreator.kv`, `generaloptions.kv`,
    and `statusbar.kv` were not modified, so we are not presenting them again. The
    context and vertex instructions are easy to understand. However, we must be very
    careful with the order of execution and make sure to leave the coordinate space
    context in its normal state after executing the desired vertex instructions. Finally,
    take into account that everything you see in the screen is displayed by an instruction
    (or instructions) inside the canvas, including, for example, `Label` texts and
    the `Button` backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter explained the necessary concepts to understand the use of the
    canvas. We covered the use of vertex and context instructions, and how to manipulate
    the order of the execution of instructions. We covered how to deal with the transformation
    of `canvas`, either reversing all the transformations or using `RelativeLayout`.
    The following is the whole set of components we learnt to use, in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex instructions (and many of their respective properties): `Rectangle`
    (`pos`, `size`), `Ellipse` (`pos`, `size`, `angle_start`, `angle_end`, `segments`),
    `Triangle` (`points`), `Quad` (`points`), `Point` (`points`, `pointsize`), `Line`
    (`points`, `ellipse`, `circle`, `rectangle`, `width`, `close`, `dash_lenght`,
    `dash_offset`, and `cap`), `Bezier` (`points`, `segments`, `dash_lenght`, and
    `dash_offset`,), and `Mesh` (`mode`, `vertices`, `indices`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `source` property that applies to all the vertex instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The three set of canvas instructions: `canvas.before`, `canvas`, and `canvas.after`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The context instructions (and some of their properties): `Color` (`rgba`, `rgb`),
    `Rotate` (`angle`, `axis`,`origin`), `Translate` (`x`, `y`, `xy`), `Scale` (`xyz`),
    `PushMatrix`, and `PopMatrix`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list is quite comprehensive, but of course there are some remaining components
    that we can find in the Kivy API. The important part is that we discussed the
    concepts behind the use of the canvas. Feel free to play with the provided examples
    to reinforce the important concepts of this chapter. You should feel comfortable
    to put things together and enliven your interface, so you can actually draw with
    it. The next chapter will focus on event handling and manipulating Kivy objects
    directly from Python.
  prefs: []
  type: TYPE_NORMAL
