- en: Chapter 6. Further Reading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 进一步阅读
- en: So far in this book, we have looked into both the basic and advanced topics
    of using Cython. But, it does not stop here; there are further topics that you
    can explore.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们已经探讨了使用 Cython 的基本和高级主题。但，这并没有结束；还有更多您可以探索的主题。
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Other topics we will discuss in this chapter are OpenMP support, Cython's preprocessor
    and other related projects. Consider other implementations of Python such as PyPy
    or making it work with Python 3\. Not only that but what are the Cython alter-natives
    and related Cython tools that are available. We will look at numba and Parakeet
    and look at numpy the flag ship usage of Cython.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的其他主题包括 OpenMP 支持、Cython 预处理器以及其他相关项目。考虑其他 Python 实现，如 PyPy 或使其与 Python
    3 兼容。不仅如此，还有哪些 Cython 替代方案和相关 Cython 工具可供使用。我们将探讨 numba 和 Parakeet，并查看 numpy 作为
    Cython 的旗舰用法。
- en: OpenMP support
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenMP 支持
- en: 'OpenMP is a standard API in the shared-memory parallel computing for languages;
    it''s used in several open source projects such as ImageMagick ([http://www.imagemagick.org/](http://www.imagemagick.org/))
    to try and speed up the processing on large image manipulations. Cython has some
    support for this compiler extension. But, you must be aware that you need to use
    compilers such as GCC or MSVC, which support OpenMP. Clang/LLVM has no OpenMP
    support yet. This isn''t really a place to explain when and why to use OpenMP
    since it is really a vast subject, but you should check out the following website:
    [http://docs.cython.org/src/userguide/parallelism.html](http://docs.cython.org/src/userguide/parallelism.html).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP 是一种用于共享内存并行计算的语言标准 API；它在多个开源项目中使用，例如 ImageMagick ([http://www.imagemagick.org/](http://www.imagemagick.org/))，旨在加快大型图像处理的速度。Cython
    对此编译器扩展提供了一些支持。但是，您必须意识到您需要使用支持 OpenMP 的编译器，如 GCC 或 MSVC。Clang/LLVM 目前还没有 OpenMP
    支持。这并不是解释何时以及为什么使用 OpenMP 的地方，因为它是一个庞大的主题，但您应该查看以下网站：[http://docs.cython.org/src/userguide/parallelism.html](http://docs.cython.org/src/userguide/parallelism.html)。
- en: Compile time preprocessor
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时预处理器
- en: 'At compile time, similar to C/C++, we have the C-preprocessor to make some
    decisions on what gets compiled mostly from conditionals, defines, and a mixture
    of both. In Cython, we can replicate some of this behavior using `IF`, `ELIF`,
    `ELSE`, and `DEF`. This is demonstrated as an example in the following code line:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，类似于 C/C++，我们有 C 预处理器来决定编译什么，这主要基于条件、定义和两者的混合。在 Cython 中，我们可以使用 `IF`、`ELIF`、`ELSE`
    和 `DEF` 来复制其中的一些行为。以下代码行展示了这一示例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also have access to `os.uname` as predefined constants from the Cython compiler:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从 Cython 编译器访问预定义的常量 `os.uname`：
- en: '`UNAME_SYSNAME`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNAME_SYSNAME`'
- en: '`UNAME_NODENAME`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNAME_NODENAME`'
- en: '`UNAME_RELEASE`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNAME_RELEASE`'
- en: '`UNAME_VERSION`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNAME_VERSION`'
- en: '`UNAME_MACHINE`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNAME_MACHINE`'
- en: 'We can also run conditional expressions against these as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对这些内容进行条件表达式，如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You also have `ELIF` to use in conditional expressions. If you compare something
    as this against some of your headers in C programs, you will see how you can replicate
    basic C-preprocessor behavior in Cython. This gives you a quick idea of how you
    can replicate C-preprocessor usage in your headers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在条件表达式中使用 `ELIF`。如果您将某些内容与 C 程序中的头文件进行比较，您将看到如何在 Cython 中复制基本的 C 预处理器行为。这为您快速了解如何在头文件中复制
    C 预处理器使用提供了思路。
- en: Python 3
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 3
- en: 'Porting to Python 3 can be painful, but reading around the subject shows us
    that people have had success porting their code to 3.*x* by simply compiling their
    module with Cython instead of actually porting their code! With Cython, you can
    specify the output to conform to the Python 3 API via the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码迁移到 Python 3 可能很痛苦，但围绕这个主题的阅读表明，人们通过仅用 Cython 编译他们的模块而不是实际迁移代码，已经成功地将他们的代码迁移到
    3.*x*。使用 Cython，您可以通过以下方式指定输出以符合 Python 3 API：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will make sure you are outputting Python 3 stuff instead of the default
    argument of `-2`, which generates for the 2.*x* standard.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您输出的是 Python 3 内容，而不是默认的 `-2` 参数，该参数为 2.*x* 标准生成。
- en: PyPy
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyPy
- en: PyPy has become a popular alternative to the standard Python implementation.
    More importantly, it is now being used by many companies (small and large) in
    their production environments to boost performance and scalability. How does PyPy
    differ from normal CPython? While the latter is a traditional interpreter, the
    former is a full-fledged virtual machine. It maintains a just-in-time compiler
    backend for runtime optimization on most relevant architectures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy 已成为标准 Python 实现的流行替代品。更重要的是，现在许多公司（从小到大）正在将其用于生产环境以提升性能和可扩展性。PyPy 与正常的
    CPython 有何不同？虽然后者是一个传统的解释器，但前者是一个完整的虚拟机。它在大多数相关架构上维护了一个即时编译器后端，以进行运行时优化。
- en: Getting Cythonized modules to run on PyPy is dependent on their **cpyext** emulation
    layer. This isn't quite complete and has many inconsistencies. But, if you are
    brave and up to trying it out, it's going to get better and better with each release.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PyPy 上运行 Cython 化的模块，取决于它们的 **cpyext** 模拟层。这还不完整，有许多不一致之处。但是，如果你勇敢并愿意尝试，它将随着每个版本的发布而变得越来越好。
- en: AutoPXD
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AutoPXD
- en: When it comes to writing Cython modules most of your work will comprise of get-ting
    your pxd declarations correct so that you can manipulate native code correctly.
    There are several projects attempting to create a compiler to read C/C++ headers
    and generate your pxd declarations as output. The main issue is maintaining a
    fully compliant C and C++ parser. Part of my Google Summer of Code project was
    to use the Python plugin system as part of GCC to reuse GCC's code for parsing
    C/C++ code. The plugin could intercept the declarations, types and prototypes.
    It isn't fully ready for use and there are other similar projects attempting the
    same issue. More information can be found at [https://github.com/cython/cython/wiki/AutoPxd](https://github.com/cython/cython/wiki/AutoPxd).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到编写 Cython 模块时，你大部分的工作将包括正确获取你的 pxd 声明，以便正确操作原生代码。有几个项目试图创建一个编译器，读取 C/C++
    头文件并生成你的 pxd 声明作为输出。主要问题是维护一个完全符合 C 和 C++ 解析器的编译器。我的 Google Summer of Code 项目的一部分是使用
    Python 插件系统作为 GCC 的一部分，以重用 GCC 的代码来解析 C/C++ 代码。该插件可以拦截声明、类型和原型。它还没有完全准备好使用，还有其他类似的项目试图解决同样的问题。更多信息可以在[https://github.com/cython/cython/wiki/AutoPxd](https://github.com/cython/cython/wiki/AutoPxd)找到。
- en: Pyrex and Cython
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pyrex 和 Cython
- en: Cython is a derivative of Pyrex.. However Pyrex is more primitive, Cython provides
    us with much more powerful typing and features as well as optimizations and confidence
    with exception handling.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 是 Pyrex 的衍生产品。然而，Pyrex 更加原始，Cython 为我们提供了更强大的类型和功能，以及优化和异常处理的信心。
- en: SWIG and Cython
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SWIG 和 Cython
- en: 'Overall, if you consider SWIG ([http://swig.org/](http://swig.org/)) as a way
    to write a native Python module, you could be fooled to think that Cython and
    SWIG are similar. SWIG is mainly used to write wrappers for language bindings.
    For example, if you have some C code as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，如果你将 SWIG ([http://swig.org/](http://swig.org/)) 视为编写原生 Python 模块的方法，你可能会被误导，认为
    Cython 和 SWIG 是相似的。SWIG 主要用于编写语言绑定的包装器。例如，如果你有一些如下所示的 C 代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can write the SWIG interface file as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式编写 SWIG 接口文件：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Compile this with the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令编译：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can compile and link the module as you would do for a Cython output since
    this generates the necessary C code. This is fine if you want a basic module to
    simply call into C from Python. But Cython provides users with much more.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像编译 Cython 输出一样编译和链接模块，因为这将生成必要的 C 代码。如果你只想创建一个基本的模块，从 Python 调用 C，这是可以的。但
    Cython 为用户提供得更多。
- en: Cython is much more developed and optimized, and it truly understands how to
    work with C types and memory management and how to handle exceptions. With SWIG,
    you cannot manipulate data; you simply call into functions on the C side from
    Python. In Cython, we can call C from Python and vice versa. The type conversion
    is just so powerful; not only this, we can also wrap C types into real Python
    classes to make C data feel Pythonic.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 发展得更加完善和优化，它真正理解如何与 C 类型和工作内存管理协同工作，以及如何处理异常。使用 SWIG，你无法操作数据；你只能从 Python
    调用 C 端的函数。在 Cython 中，我们可以从 Python 调用 C，反之亦然。类型转换功能非常强大；不仅如此，我们还可以将 C 类型封装成真正的
    Python 类，使 C 数据感觉更像是 Pythonic。
- en: The XML example from [Chapter 5](ch05.html "Chapter 5. Advanced Cython"), *Advanced
    Cython*, where we were able to drop in the `import` replacement? This is possible
    because of Cython's type conversion, and the API is very Pythonic. Not only can
    we wrap C types into Pythonic objects, but we also let Cython generate the boilerplate
    necessary for Python to do this without wrapping things into a class. What's more
    is that Cython produces a much more optimized code for the user.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 来自第 5 章 [高级 Cython](ch05.html "第 5 章。高级 Cython") 的 XML 示例，我们能够插入 `import` 替换？这是由于
    Cython 的类型转换，API 非常 Pythonic。我们不仅可以把 C 类型包装成 Pythonic 对象，而且还让 Cython 生成 Python
    执行此操作所需的样板代码，而无需将事物包装成类。更重要的是，Cython 为用户生成了更多优化的代码。
- en: Cython and NumPy
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython 和 NumPy
- en: 'NumPy is a scientific library designed to provide functionality similar to
    or on par with MATLAB, which is a paid proprietary mathematics package. NumPy
    has a lot of popularity with Cython users since you can seek out more performance
    from your highly computational code using C types. In Cython, you can import this
    library as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是一个科学库，旨在提供类似于 MATLAB 的功能，MATLAB 是一个付费的专有数学包。由于你可以使用 C 类型从高度计算密集型的代码中获得更多性能，NumPy
    在 Cython 用户中非常受欢迎。在 Cython 中，你可以如下导入这个库：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can access full Python APIs as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以如下访问完整的 Python API：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, you can integrate with iterators at a very native area of the API. This
    allows NumPy users to get a lot of speed when working with native types via something
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以在 API 的一个非常本地区域与迭代器集成。这允许 NumPy 用户在通过以下方式使用本地类型时获得很多速度：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can cast the data from the array to `double`, and it's a `cdef` type in Cython
    to work with now. For more information and NumPy tutorials, visit [https://github.com/cython/cython/wiki/tutorials-numpy](https://github.com/cython/cython/wiki/tutorials-numpy).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数组中的数据转换为 `double`，在 Cython 中它是一个 `cdef` 类型，现在可以与之一起工作。有关更多信息以及 NumPy 教程，请访问
    [https://github.com/cython/cython/wiki/tutorials-numpy](https://github.com/cython/cython/wiki/tutorials-numpy)。
- en: Numba versus Cython
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Numba 与 Cython 的比较
- en: 'Numba is another way to get your Python code to become almost native to your
    host system by outputting the code to be run on LLVM seamlessly. Numba makes use
    of decorators such as the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 是另一种让你的 Python 代码几乎成为宿主系统的本地代码的方法，通过无缝输出要在 LLVM 上运行的代码。Numba 使用以下装饰器等：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Numba also integrates with NumPy. On the whole, it sounds great. Unlike Cython,
    you only apply decorators to pure Python code, and it does everything for you,
    but you may find that the optimizations will be fewer and not as powerful.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 还与 NumPy 集成。总的来说，这听起来很棒。与 Cython 不同，你只需将装饰器应用于纯 Python 代码，它为你做所有事情，但你可能会发现优化会更少，也不那么强大。
- en: Numba does not integrate with C/C++ to the extent that Cython does. If you want
    it to integrate, you need to use **Foreign Function Interfaces** (**FFI**) to
    wrap calls. You also need to define structs and work with C types in Python code
    in a very abstract sense to a point where you don't really have much control as
    compared with Cython.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 并没有像 Cython 那样与 C/C++ 集成。如果你想让它集成，你需要使用 **外部函数接口**（**FFI**）来包装调用。你还需要在
    Python 代码中以非常抽象的方式定义结构体并与 C 类型一起工作，以至于与 Cython 相比，你实际上几乎没有多少控制权。
- en: Numba is mostly comprised of decorators, such as `@locals`, from Cython. But
    in the end, all this creates is just-in-time-compiled functions with a proper
    native function signature. Since you can specify the typing of function calls,
    this should provide more native speed when calling and returning data from functions.
    I would argue that the optimizations you will get as compared to Cython will be
    minimal as you might need a lot of abstractions to talk to the native code; although,
    calling in a lot of functions might be a faster technique.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 主要由装饰器组成，例如来自 Cython 的 `@locals`。但最终，所有这些创建的只是即时编译的函数，具有适当的本地函数签名。由于你可以指定函数调用的类型，这应该会在调用和从函数返回数据时提供更本地的速度。我认为，与
    Cython 相比，你将获得的优化将非常有限，因为你可能需要很多抽象来与本地代码通信；尽管如此，调用很多函数可能是一种更快的技术。
- en: Just for reference, LLVM is a low-level virtual machine; it's a compiler development
    infrastructure where projects can use it as a JIT compiler. The infrastructure
    can be extended to run things, such as pure Java byte-code and even Python via
    Numba. It can be used for almost any purpose with a nice API for development.
    As opposed to GCC (an ahead-of-time compiler infrastructure), which implements
    a lot of static analysis ahead of time before code is run, LLVM allows code to
    change at runtime.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 仅作参考，LLVM 是一个低级虚拟机；它是一个编译器开发基础设施，项目可以使用它作为即时编译器。该基础设施可以扩展以运行各种事物，例如纯 Java 字节码，甚至通过
    Numba 运行 Python。它几乎可以用于任何目的，并提供了一个良好的 API 用于开发。与 GCC（一个编译时编译器基础设施）相反，GCC 在代码运行之前会提前执行大量的静态分析，LLVM
    允许代码在运行时进行更改。
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For more information on Numba and LLVM, you can refer to either of the following
    links:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 Numba 和 LLVM 的信息，您可以参考以下链接中的任何一个：
- en: '[http://numba.pydata.org/](http://numba.pydata.org/)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://numba.pydata.org/](http://numba.pydata.org/)'
- en: '[http://llvm.org/](http://llvm.org/)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://llvm.org/](http://llvm.org/)'
- en: Parakeet and Numba
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Parakeet 和 Numba
- en: Parakeet is another project that works alongside Numba, adding extremely specific
    optimizations to the Python code that uses lots of nested loops and parallelism.
    As with OpenMP, where it's really cool, Numba too requires using annotations on
    your code to do all this for the programmer. The downside is that you won't just
    magically optimize any Python code, the optimization that Parakeet does is on
    very specific sets of code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Parakeet 是另一个与 Numba 一起工作的项目，它为使用大量嵌套循环和并行性的 Python 代码添加了非常具体的优化。与 OpenMP 类似，它真的很酷，Numba
    也需要您在代码上使用注解来完成所有这些工作。缺点是您不会神奇地优化任何 Python 代码，Parakeet 所做的优化是针对非常具体的代码集。
- en: Relevant Links
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关链接
- en: 'Some useful links for referencing are:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有用的参考链接：
- en: '[https://github.com/cython/cython/wiki/FAQ](https://github.com/cython/cython/wiki/FAQ)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/cython/cython/wiki/FAQ](https://github.com/cython/cython/wiki/FAQ)'
- en: '[https://github.com/cython/cython/wiki](https://github.com/cython/cython/wiki)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/cython/cython/wiki](https://github.com/cython/cython/wiki)'
- en: '[http://cython.org/](http://cython.org/)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://cython.org/](http://cython.org/)'
- en: '[http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/](http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/](http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/)'
- en: '[http://swig.org/](http://swig.org/)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://swig.org/](http://swig.org/)'
- en: '[http://www.numpy.org/](http://www.numpy.org/)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.numpy.org/](http://www.numpy.org/)'
- en: '[http://wiki.cython.org/tutorials/numpy](http://wiki.cython.org/tutorials/numpy)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://wiki.cython.org/tutorials/numpy](http://wiki.cython.org/tutorials/numpy)'
- en: '[http://en.wikipedia.org/wiki/NumPy](http://en.wikipedia.org/wiki/NumPy)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/NumPy](http://en.wikipedia.org/wiki/NumPy)'
- en: '[http://llvm.org/](http://llvm.org/)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://llvm.org/](http://llvm.org/)'
- en: '[http://numba.pydata.org/](http://numba.pydata.org/)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://numba.pydata.org/](http://numba.pydata.org/)'
- en: '[http://numba.pydata.org/numba-doc/0.9/interface_c.html](http://numba.pydata.org/numba-doc/0.9/interface_c.html)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://numba.pydata.org/numba-doc/0.9/interface_c.html](http://numba.pydata.org/numba-doc/0.9/interface_c.html)'
- en: '[http://gcc.gnu.org/](http://gcc.gnu.org/)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://gcc.gnu.org/](http://gcc.gnu.org/)'
- en: Summary
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you've read this far, you should now be familiar with Cython to such an extent
    that you can embed it with C bindings and even make some of your pure Python code
    more efficient. I've shown you how to apply Cython against an actual open source
    project and even how to extend native software with a Twisted Web server! As I
    kept saying throughout the book, it makes C feel as though there are endless possibilities
    to control logic or that you can extend the system with the plethora of Python
    modules available. Thanks for reading.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读到这里，那么您现在应该对 Cython 非常熟悉，以至于您可以使用 C 绑定将其嵌入，甚至可以使一些纯 Python 代码更加高效。我已经向您展示了如何将
    Cython 应用于实际的开源项目，甚至如何使用 Twisted Web 服务器扩展原生软件！正如我在整本书中一直说的那样，这使得 C 感觉到似乎有无穷无尽的可能性来控制逻辑，或者您可以使用大量的
    Python 模块来扩展系统。感谢您的阅读。
