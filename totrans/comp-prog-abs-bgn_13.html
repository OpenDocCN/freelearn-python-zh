<html><head></head><body>
		<div><h1 id="_idParaDest-167"><em class="italic"><a id="_idTextAnchor168"/>Chapter 11:</em> Programming Tools and Methodologies</h1>
			<p>Now, it's time for us to take a closer look at the development cycle. Producing software is more than just writing code. We must plan what will be coded, write the code, integrate the code we write with already existing code, share our code with other developers, test the code, deploy the code so that the application can be accessed by the users, add new features to the application, and fix bugs and errors that will show up in the code that has been released.</p>
			<p>To accomplish this, a development team will typically use different tools and methodologies for how things will be done and in what order.</p>
			<p>In this chapter, we will look at all the components that are part of the development process that is not the actual coding.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding what a version control system is and what it can be used for</li>
				<li>Understanding unit tests</li>
				<li>Understanding integration tests</li>
				<li>Understanding the concept of a release</li>
				<li>Understanding software deployment</li>
				<li>Understanding code maintenance </li>
				<li>Understanding software development process methodologies</li>
			</ul>
			<p>We have lots to cover, so let's start with an essential tool in software development: version control systems.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor169"/>Understanding version control systems</h1>
			<p>A <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>) is used to manage changes in documents, computer programs, or other <a id="_idIndexMarker679"/>collections of files. They are used by programmers to manage different revisions of their code.</p>
			<p>It is possible to restore earlier reversions if needed. This makes it safer to edit files, as we always have a way for us to restore what we had if we decide that the changes we made need to be reset.</p>
			<p>VCSs are also used so that developers can work together on the same project and, in a safe manner, work in the same source code files. Version control systems also keep track of who changed what in a document, and when the change was made.</p>
			<p>Files that are <a id="_idIndexMarker680"/>version controlled are stored in what is called a <strong class="bold">repository</strong>. When changes are made to a file, the user of the VCS can commit these changes to the repository, and by extension of that, create a reversion point. It is at these points where the version control system takes a snapshot of all the changes made.</p>
			<p>To illustrate how this works, we can use one of the most popular version control systems available: Git. Git was created by Linus Torvalds, the creator of Linux, in 2005. It was initially created to be used by the programmers who were working on the Linux kernel code, but soon gained popularity outside the Linux project. Today, it is by far the most popular version control system.</p>
			<p>Let's start by writing some code. Let's say we have this code in a file called <code>calc.code</code>:</p>
			<pre>function add(a, b)
    return a + b</pre>
			<p>Save this file in an empty folder. We can now use the GIT software to create a repository. This means that we can start to version control the files within this folder. From the command line, we can do this by writing the following code:</p>
			<pre>git init</pre>
			<p>At this point, nothing is version controlled yet. We will need to tell GIT what files we want to add to version control. We can do that with the following command:</p>
			<pre>git add calc.code</pre>
			<p>Our file is now staged. This means that its changes will be tracked, but we will need to do one more thing to record the changes that have been made to our file. What we'll do is called a <strong class="bold">commit</strong>. A commit <a id="_idIndexMarker681"/>will record our changes and store them in our repository. Let's do that with the following command:</p>
			<pre>git commit -m "Initial Commit"</pre>
			<p><code>-m</code> tells <code>git</code> that we will provide a commit message, and the message is what comes within the quotes. The messages will help us see what is changed in a commit, so we should take some time to come up with descriptive messages.</p>
			<p>The changes <a id="_idIndexMarker682"/>we have made are now stored on what is called the <em class="italic">master branch</em>. The following diagram illustrates what this looks like:</p>
			<div><div><img src="img/Figure_11.1_B15554.jpg" alt="Figure 11.1 – The master branch after our initial commit"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – The master branch after our initial commit</p>
			<p>We would now like to continue to work on our program and add more code to this file. To make life a little bit safer, we can create a new branch and make our changes in this branch. We will soon see why this might be a good idea.</p>
			<p>To create a new branch called <code>subtract</code>, we can use the following command:</p>
			<pre>git branch subtract</pre>
			<p>Creating a new branch will give us an exact copy of the branch we created it from, which in this case is the master branch. This can be illustrated as follows:</p>
			<div><div><img src="img/Figure_11.2_B15554.jpg" alt="Figure 11.2 – Creating a new branch called subtract from the master branch"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Creating a new branch called subtract from the master branch</p>
			<p>We are still on the master branch, so any changes we make will be on this branch. So, before we do anything else, we should switch branches. We can do that with the <code>checkout</code> command:</p>
			<pre>git checkout subtract</pre>
			<p>We are <a id="_idIndexMarker683"/>now on the <code>subtract</code> branch. Now, we can update our source code file, so let's add another function, making the file look like this:</p>
			<pre>function add(a, b)
    return a + b
function subtract(a, b)
    return a - b</pre>
			<p>If we save these changes, we can add the file to the staging area and commit the changes with the following commands:</p>
			<pre>git add calc.code
git commit -m "Added the subtract function."</pre>
			<p>We can illustrate this commit with another circle on the submit branch, as shown in the following diagram:</p>
			<div><div><img src="img/Figure_11.3_B15554.jpg" alt="Figure 11.3 – Committing to our new branch"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Committing to our new branch</p>
			<p>Now that we have committed our changes to GIT, we can switch branches. Let's do that with the following command:</p>
			<pre>git checkout master</pre>
			<p>If we open our file now, we will see the following content:</p>
			<pre>function add(a, b)
    return a + b</pre>
			<p>The changes <a id="_idIndexMarker684"/>we made are not here. This is because these changes are not in the master branch. Keeping the file open in our editor, we can now switch back to the <code>subtract</code> branch by using the following command:</p>
			<pre>git checkout subtract</pre>
			<p>Like magic, the changes we made to the file are back, and the <code>subtract</code> function is as we left it:</p>
			<pre>function add(a, b)
    return a + b
function subtract(a, b)
    return a - b</pre>
			<p>This illustrates that if we, for some reason, decide that the changes we made were no good, we can always go back to our master branch, and everything will be like it was before we started. However, if we, on the other hand, are happy with the changes, we can now bring the two branches together. In GIT, this is called a <strong class="bold">merge</strong>. The first thing we should <a id="_idIndexMarker685"/>do before merging the two branches is make sure that the branch we want to merge is active. In this case, it is the master branch, so we write the following:</p>
			<pre>git checkout master</pre>
			<p>Now, we are ready to merge the changes we made back into the master branch. We can do this with the following command:</p>
			<pre>git merge subtract</pre>
			<p>This means <a id="_idIndexMarker686"/>we take the changes made in the branch called <code>subtract</code> and <code>merge</code> it with the content of the current branch, <code>master</code>. We can illustrate this with the following diagram:</p>
			<div><div><img src="img/Figure_11.4_B15554.jpg" alt="Figure 11.4 – Merging the subtract branch with the master branch"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – Merging the subtract branch with the master branch</p>
			<p>This is how we can use version control with GIT on our local machine. Now, let's see how we can use it to collaborate with other programmers who work on the same project as us. For that, we will need not only our local repository but also a central repository that we can use to update the other on the changes we make.</p>
			<p>Let's assume that Alice and Bob are both working on the same project and want to use GIT to update each other on the changes they make to any files in the project. They will not only have their local GIT repositories, as we saw in the preceding example, but they will also connect to a centralized repository. Any changes they make can now be pushed to this repository, and they can also pull down any changes the other person made from that repository.</p>
			<p>This will look something like the following:</p>
			<div><div><img src="img/Figure_11.5_B15554.jpg" alt="Figure 11.5 – Two programmers connected to a central repository"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – Two programmers connected to a central repository</p>
			<p>We can now <a id="_idIndexMarker687"/>assume that they will both work on the same file we saw previously, <code>calc.code</code>, and that it has the same content as we left it with, like this:</p>
			<pre>function add(a, b)
    return a + b
function subtract(a, b)
    return a - b</pre>
			<p>The central <a id="_idIndexMarker688"/>repository is often referred to as the <code>multiply</code> function:</p>
			<ol>
				<li>The first thing she should do is pull down the latest version from the central repository (origin) with the following command:<pre><code>origin</code> points out the central repository, and <code>master</code> is the branch she wants to pull down. </p></li>
				<li>She now has the latest version, and she can begin implementing her function. She decides to do this in a new branch, so she executes the following command:<pre><strong class="bold">git branch multiply</strong></pre></li>
				<li>She will then switch to this branch with the following command:<pre><strong class="bold">git checkout multiply</strong></pre></li>
				<li>Now, she can make the necessary changes, so she adds the following code to the file:<pre>function add(a, b)
    return a + b
function subtract(a, b)
    return a – b
function multiply(a, b)
    return a * b</pre></li>
			</ol>
			<p>Let's leave <a id="_idIndexMarker689"/>Alice here and check what Bob is doing.</p>
			<p>While Alice has started her work, Bob decides he wants to create a <code>divide</code> function:</p>
			<ol>
				<li value="1">Just like Alice, he will pull down the latest version of the <code>master</code> branch and create a new branch called <code>divide</code>, switch to it, and then change the <code>calc.code</code> file, so that it looks as follows:<pre>function add(a, b)
    return a + b
function subtract(a, b)
    return a – b
function divide(a, b)
    return a / b</pre><p>At this point, Alice is happy with her changes, so she commits them to her branch and merges her branch with the master.</p></li>
				<li>Now, she wants to push these changes to the central repository. Before she does that, though, she wants to make sure that changes have been made to the central repository. So, first, she tries to pull down any changes to her repository with the same command she ran previously:<pre><strong class="bold">git pull origin master</strong></pre></li>
				<li>Since nothing has happened to the central repository since her last pull, nothing will happen. She can now push her changes with the following command:<pre><strong class="bold">git push origin master</strong></pre></li>
			</ol>
			<p>Now, her changes <a id="_idIndexMarker690"/>are stored in the central repository. At this point, her local version of the <code>master</code> branch and the version stored in the central repository are identical. </p>
			<p>Let's go back to Bob, who has finished his function. He commits his changes to his local repository in his branch and merges it into the master branch. Now, he is ready to commit his changes to the central repository:</p>
			<ol>
				<li value="1">Just like Alice, first, he wants to make sure that he has the latest changes from the central repository, so he issues a <code>pull</code> command:<pre><strong class="bold">git pull origin master</strong></pre></li>
				<li>This time, things will not go so well. He gets a message that there has been a merge conflict. What's that? He opens the code file, and he now sees this:<pre>function add(a, b)
  return a + b
function subtract(a, b)
  return a - b
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
function multiply(a, b)
  return a * b  
=======
function divide(a, b)
  return a / b
&gt;&gt;&gt;&gt;&gt;&gt;&gt; div</pre><p>What happened <a id="_idIndexMarker691"/>was that he and Alice made changes to the same file on the same line, which is at the end of the file in this case.</p><p>GIT became confused due to this and needs help to decide what will be in the file.</p><p>Bob looks at this and understands that Alice has added a function to the same location in the file that he did, and he understands that both functions should be there.</p><p>The <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> marker indicates the beginning of the conflict. What is between that line and the <code>=======</code> line is the changes he pulled down. The code between <code>=======</code> and  <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; div</code> are his changes.</p></li>
				<li>Since he decides that both functions should be in this file, he removes the three marker lines from the file, so it now looks like this:<pre>function add(a, b)
  return a + b
function subtract(a, b)
  return a - b
function multiply(a, b)
  return a * b  
function divide(a, b)
  return a / b</pre></li>
			</ol>
			<p>He can now commit his changes to his local repository and then push the changes so that Alice can get the changes later.</p>
			<p>This illustrates how a version control system can be used to share work between multiple programmers in a project. There are, of course, many other aspects of version control systems <a id="_idIndexMarker692"/>that we did not cover here, but now, you at least have an idea about what a version control system can do for you and how it can be used to share work with others.</p>
			<p>This tool is used throughout the development process. Now, let's look at what we do when the code is written, as well as how we can make sure that it is working before we push it to the central repository.</p>
			<p>It's now time for unit testing!</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor170"/>Unit testing</h1>
			<p>Testing our code is essential so that we can verify that it does what it should. We will also use tests <a id="_idIndexMarker693"/>to make sure that any changes we make to the code have not made things that previously worked stop working or behave in an undesired way.</p>
			<p>Several kinds of testing can be done on our code, and the first type of test we will look at is called a <strong class="bold">unit test</strong>. The unit part indicates that the test will be done on a separate unit of our code. This is typically at a function level. This means that we will try to isolate one single function (or another small unit of code) and run our tests on just that unit.</p>
			<p>These tests are typically written by the developer of the code unit to be tested and are often automated. This means that as soon as a block of code is ready to be committed to the version control system, it must first pass the unit test written for it.</p>
			<p>Since the unit test only tests a single code unit, they are typically rather trivial. To test our <code>calc</code> functions, we must first decide what we want to test. First, we can set up some test cases for valid input and match these inputs to some expected results.</p>
			<p>We could do this in a table like this one:</p>
			<div><div><img src="img/Chapter_11_table_1_01.jpg" alt="Table 11.1 "/>
				</div>
			</div>
			<p class="figure-caption">Table 11.1 </p>
			<p>We can <a id="_idIndexMarker694"/>use this to write our tests.</p>
			<p>Unit tests are typically written in a separate file that will call the code to be tested. They might look something like this:</p>
			<pre>function test_add_one()
  result = add(2, 3)
  assert.equal(5, result)</pre>
			<p>The first argument, <code>assert.equal</code>, is what we expect as a result, and it is compared to the content of the <code>result</code> variable. If they match, this test will pass; if not, the test will fail. We can now go ahead and create tests in the same manner for the rest of our test cases:</p>
			<pre>function test_add_two()
  result = add(0, 10)
  assert.equal(10, result)
function test_subtract_one()
  result = subtract(2, 3)
  assert.equal(-1, result)
function test_subtract_two()
  result = subtract(7, 4)
  assert.equal(3, result)</pre>
			<p>Here, we are just listing the first ones, but we continue like that with the rest.</p>
			<p>For simple tests like these, the structure will be the same—call the function we want to test, store the returned value in a variable, and compare the returned value with the expected one. We should also think of odd cases and what kind of result we expect to get. For example, what will happen if we make this call to <code>divide</code>? Here is how the code appears:</p>
			<pre>result = divide(10, 0)</pre>
			<p>As we discussed in <a href="B15554_09_Final_NM_ePub.xhtml#_idTextAnchor127"><em class="italic">Chapter 9</em></a>, <em class="italic">When Things Go Wrong – Bugs and Exceptions</em>, we can't divide a number by zero. This will result in an exception. If we expect to get an exception when <a id="_idIndexMarker695"/>this is done, the function works, but if we expect the function to handle this case, it will need to be modified. This is done so that it returns whatever we decide it should return. This may happen if we decide that we should get another exception that indicates that we can't pass a 0 as the second argument. So, no matter what we expect, it should be tested.</p>
			<p>This is one type of test that we should run on our code, but these tests will just test a single unit; that is, an isolated part of the application. We will also need to perform another type of test, called an integration test. We'll see what this is in the next section.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor171"/>Integration testing</h1>
			<p>Integration testing is <a id="_idIndexMarker696"/>about putting several units together and testing them so that they work correctly when they are no longer isolated, but work together.</p>
			<p>Units that work together will need to communicate, and they will communicate by passing data between them. This means that integration testing is about checking that the data transfer and data representation aspects work. </p>
			<p>Imagine that we are working on a project that is divided into several modules. To speed up development time, we let several programmers work on the separate modules. This might look something like this:</p>
			<div><div><img src="img/Figure_11.6_B15554.jpg" alt="Figure 11.6 – Four developers working on four different modules"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – Four developers working on four different modules</p>
			<p>These four developers will now start to write their modules, and they will make sure that their modules meet the requirements by running unit tests on them. But the only thing these tests will show is that this module works in isolation. </p>
			<p>But in the final application, these modules will need to interact with each other, and when they do, they will need to send data back and forth. The problem here is that all four programmers are human, and humans tend to interpret even the most detailed description differently. So, if Carl needs to pass a value for a year to the module Alice is writing, he might pass it as a two-digit value, such as 23. But Alice, who is writing the code receiving this data, might expect that the year comes in a four-digit format, so she expects 2023. </p>
			<p>If we trace <a id="_idIndexMarker697"/>the communication between the modules when they are put together, this might look something like this:</p>
			<div><div><img src="img/Figure_11.7_B15554.jpg" alt="Figure 11.7 – Modules communicating"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7 – Modules communicating</p>
			<p>This is just a small example. In real applications, there will be many more modules and many more lines of communication. But the point is that we will need to verify that all the data that's passed back and forth is valid and works in all situations.</p>
			<p>In this case, we will need to do what's called an <strong class="bold">integration test</strong>. This is when we test that different parts of the application are working when they're put together. </p>
			<p>This can be done in several ways. There is a big-bang approach we can take, which means that we wait for all the modules to be completed, and then we put them together and test them. The disadvantage of this is that the modules will not be ready at the same time. If Alice, who writes Module A, is done with her work, she will need Bob to finish his work <a id="_idIndexMarker698"/>before she can integration test her module, as her work is making a call to Bob's work. The same goes for Bob: he needs Carl to finish his work before he can integrate his module into the application. </p>
			<p>There are other approaches where we don't wait for all the parts to be finished before we begin testing. Instead, we create <em class="italic">fake</em> modules, called <strong class="bold">stubs</strong> and <strong class="bold">drivers</strong>. A stub is a module that <a id="_idIndexMarker699"/>gets called by another module, while a driver is a module calling another module. We can create these to <a id="_idIndexMarker700"/>pass and accept data so that we can begin testing. They are not fully functional modules, but they act as the real modules for the sake of testing. As modules get completed, they can replace these stubs and drivers, and tests can then be performed on the real modules.</p>
			<p>Having these tests in place is essential, partly because it verifies that the modules can interact with each other, but also for the future. When we add new functionality later, either by changing existing modules or adding new ones, we want to make sure that everything that worked previously still does. Inserting new code into an existing application can have unwanted side effects, and we must make sure that this has not happe<a id="_idTextAnchor172"/>ned.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor173"/>Other types of tests</h1>
			<p>Unit and integration testing are not the only types of tests we have. Depending on what kind of application <a id="_idIndexMarker701"/>we are creating and what requirements our software has when it comes to things such as data integrity, handling large workloads, compatibility with other applications, and so on, we can choose to expose the code for several different test types.</p>
			<p>Let's briefly look at some of these tests.</p>
			<h3>System testing</h3>
			<p>System testing <a id="_idIndexMarker702"/>tests a system when it is completely integrated <a id="_idIndexMarker703"/>into its execution environment. Here, we will test things such as whether the login works, whether we can create and edit data in the application, whether the user interface presents data correctly, and whether we can delete entries.</p>
			<p>These things <a id="_idIndexMarker704"/>are typically tested earlier in the development <a id="_idIndexMarker705"/>process too, but they need to be verified when the source code is in its live production environment. </p>
			<h3>Acceptance testing</h3>
			<p>Acceptance <a id="_idIndexMarker706"/>testing is often divided into four different types:</p>
			<ul>
				<li>User <a id="_idIndexMarker707"/>acceptance testing</li>
				<li>Operational acceptance testing</li>
				<li>Constructional and regulatory acceptance testing</li>
				<li>Alpha and beta testing</li>
			</ul>
			<p>Let's understand these in detail:</p>
			<ul>
				<li><strong class="bold">User acceptance testing</strong>: This is a way to verify that the solution created works for <a id="_idIndexMarker708"/>the end users of our application. The questions we are trying to answer with these tests are if the users can <a id="_idIndexMarker709"/>use the software, if it is what they asked for, whether they have any trouble using it, and if the application behaves as anticipated. </li>
				<li><strong class="bold">Operational acceptance testing</strong>: This is done to verify the operational readiness <a id="_idIndexMarker710"/> of an application <a id="_idIndexMarker711"/>before it is released to end users.</li>
				<li><strong class="bold">Constructional and regulatory acceptance testing</strong>: This is done to verify that the <a id="_idIndexMarker712"/>developed software <a id="_idIndexMarker713"/>fulfills the conditions <a id="_idIndexMarker714"/>specified in the agreement that was entered <a id="_idIndexMarker715"/>into with the organization that ordered the software. Regulatory testing verifies that the software conforms to the current regulations.</li>
				<li><strong class="bold">Alpha and beta testing</strong>: These are two tests that are performed to verify and identify all <a id="_idIndexMarker716"/>possible issues and bugs. Alpha testing is performed <a id="_idIndexMarker717"/>early in the development <a id="_idIndexMarker718"/>process, while beta testing is done near the end of <a id="_idIndexMarker719"/>the development process. They are both conducted by potential users of the finished product or by a group of people with a similar skill level as the end users of the application.</li>
			</ul>
			<h3>Regression testing</h3>
			<p>Regression testing focuses on finding defects after a significant code change and seeks to uncover <a id="_idIndexMarker720"/>software regressions. A software regression is a bug that will make some features in an application stop functioning after the update. There is also <a id="_idIndexMarker721"/>software performance regression, where the software still operates correctly, but where an update harmed the system's performance.</p>
			<p>These were some other tests we can perform on our software. There are many more, but the ones we have covered here are among the most typical tests you will get exposed to as a software developer.</p>
			<p>When we have code that is tested, we can make it available to the end users of our application. Before we talk about how to make the code we have written available to our users, we should stop and talk about what a release is.</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor174"/>Software releases</h1>
			<p>When creating software, we don't want to start with an idea for the finished project and then get to <a id="_idIndexMarker722"/>work on everything that this application needs to do and, several years later, finally publish the finished software. The reason we don't want to do this is that during development time, several things will happen; for example, the requirements for this application might change, new laws can make us need to do things differently, and competing software solutions might be released, to name a few.</p>
			<p>Instead, we want to implement some core features, release them to our users, and then immediately begin the development of the next release, which will contain some more features. This can be illustrated as follows:</p>
			<div><div><img src="img/Figure_11.8_B15554.jpg" alt="Figure 11.8 – Development process through continuous iterations"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.8 – Development process through continuous iterations</p>
			<p>We start <a id="_idIndexMarker723"/>with a vision or an idea. Then, we take some fundamental parts of this idea and implement them in what is called an <strong class="bold">iteration</strong>. During this <a id="_idIndexMarker724"/>iteration phase, we perform several steps, all of which we will look at in more detail soon. At the end of the iteration, we have code that works that we can release to our users. We then begin the next iteration, implementing more features that are released as soon as this iteration is complete.</p>
			<p>The steps that are taken during an iteration will vary, depending on the development methodology, but commonly, it will be something similar to the following:</p>
			<div><div><img src="img/Figure_11.9_B15554.jpg" alt="Figure 11.9 – Typical steps during one iteration"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9 – Typical steps during one iteration</p>
			<p>Here, we can see that we take our ideas and requirements into the development cycle. First, we will perform an analysis and design the steps. Here, we are trying to answer two questions:</p>
			<ul>
				<li>What is it that we will do (analysis)?</li>
				<li>How can we do it (design)?</li>
			</ul>
			<p>When we know what we should do and how to do it, we can start to implement the different parts that go into this iteration.</p>
			<p>As we finish a section of code, it gets unit tested, and then all the code undergoes integration tests. Other tests might also be performed before the code is released to end users. Releasing <a id="_idIndexMarker725"/>the code is called a <strong class="bold">deployment</strong>, a step we will look closer at soon.</p>
			<p>What we <a id="_idIndexMarker726"/>have accomplished now is a release, and this means that our software now has some new features or bug fixes.</p>
			<p>We can now begin the next iteration. This is completed by evaluating the iteration we just ended. This is done so that we can fine-tune our workflow, see whether we have discovered some problems during the last cycle, or any other issues that we need to consider in the next iteration.</p>
			<p>We can then specify what will go into the next iteration, and by using that repeat the whole process.</p>
			<p>Now, let's take a closer look at the deployment phase to learn what it is and how it can be done.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor175"/>Understanding software deployment</h1>
			<p>When we have some code to release, we will need to deploy it. Deployment is the process of <a id="_idIndexMarker727"/>making sure the software is installed in the right location, that it is secured to prevent any hacker attacks, and making sure that privileges are given to the software so that it can read and write files as needed.</p>
			<p>When the code is deployed, we usually want to test it again to make sure that everything is still working the way it is intended.</p>
			<p>Deploying the code is usually done in several steps. Developers will typically have a server that's used during the development process. This is called the <strong class="bold">development server</strong>, and during development, the code can be executed and tested on this server. It will often come <a id="_idIndexMarker728"/>with a development database that, if the application we develop uses a database, is used to simulate the real data the application handles. Still, it can be modified any way the developer wants as it is detached from the real data the users see and work with.</p>
			<p>Before the code is moved to the production server, that is, the server the application users will use <a id="_idIndexMarker729"/>to run the application, the code is usually moved to an intermediate server, often referred to as a <strong class="bold">staging server</strong>. The role of this server is to be as much like the production server as possible so that the new code can be tested alongside the code that was already released. The idea is to make sure that everything runs smoothly <a id="_idIndexMarker730"/>and that no bugs appear when the new code hits the live production server. </p>
			<p>The staging server also has a database. The data in this database is often copied from the production database to make sure that everything is a mirror of the real server.</p>
			<p>Finally, when the team is confident that everything works correctly, the code is moved to the production server. Apart from moving the code, other adjustments might be needed, such as adding things to the production database that the new software version will need, adding other applications and code libraries that are used by the new code, and so on. This is depicted here:</p>
			<div><div><img src="img/Figure_11.10_B15554.jpg" alt="Figure 11.10 – Example of servers and their databases"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.10 – Example of servers and their databases</p>
			<p>We must also have a strategy for how we can undo this deployment if needed. No matter how thorough our test has been, when the code hits production and users start to use it, things that we never imagined begin surfacing. Users might behave in unpredicted ways, and there might be differences in the production environment compared to <a id="_idIndexMarker731"/>the staging environment that we overlooked.</p>
			<p>We always hope for the best, but we will need a plan for what we will do if things backfire. What we want is a way to undo all the changes and go back to what we had before the <a id="_idIndexMarker732"/>deployment as quickly as possible. This is called a <strong class="bold">rollback strategy</strong>.</p>
			<p>We can accomplish such a rollback in several ways. One of them would be to take a backup of the production database before the deployment occurs. This way, we can ensure that we have a snapshot of how all the data in the application was, before the release of the new code. </p>
			<p>The actual code is usually deployed to the server with the help of a VCS, so rolling back the actual code to a previous version is rather simple.</p>
			<p>The steps involved in deploying code to the production environment are often automated, meaning that different tools and applications take care of all the steps. Let's see how this automation works.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor176"/>Deployment automation</h2>
			<p>It is often a good idea to automate as many of the deployment steps as possible. The reason is that <a id="_idIndexMarker733"/>there are usually many steps involved that need to be done in the correct order, a job ideally suited for automation. At the same time, it's something where humans often make mistakes by forgetting to do something or do something in the wrong order.</p>
			<p>Depending on the complexity of the system, we can use several tools that will help us accomplish automated deployment. </p>
			<p>Automating deployment will ensure that we have high-quality code since the automation process typically runs tests and lets the code through to the production server that passes the tests.</p>
			<p>It will also save time as the deployment steps will be performed much faster by the deployment tools than they would be if humans performed them.</p>
			<p>When the code is deployed, the work with it is not over. Deployed code must be maintained.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor177"/>Code maintenance</h2>
			<p>A typical software developer will spend more time maintaining existing code than writing new exciting features.</p>
			<p>This is not very <a id="_idIndexMarker734"/>strange if we think about it. First, the lifespan of an application is typically much longer than the time it took to develop it. This means that there are more and more softwares out there that are running and performing their tasks. </p>
			<p>Programs that are used will always need maintenance as users will find bugs that we must fix, new features will be added to the application as demands from users change, and old features must be updated and improved. </p>
			<p>This means that developers spend most of their time in old code, fixing and updating it. This can be code written decades ago by someone who has left the company a long time ago, or it can be written by you just the other week. </p>
			<p>If you think ahead to what your life as a programmer will look like, you will most likely imagine yourself writing new, exciting software that uses the latest tools and features that are out there. Still, the fact is that it is much more likely that you will be poking around in code written a long time ago, in a version of the language that was released when you were in preschool. </p>
			<p>At times, you will have the chance to write that brand-new, cool, and shiny piece of software, but remember, if you do a good job, that code will live on and will need to be maintained by others (or yourself) in the future.</p>
			<p>That is the <a id="_idIndexMarker735"/>life of a software developer. This means that we need to ensure that the code we write is as maintainable as possible. A skilled software developer is someone who writes highly maintainable code. This means that the code is clear, easy to understand, and easy to change, without the risk of people introducing some unwanted side effects in the application.</p>
			<p>There is a simple rule we can follow to help us create maintainable code: the boy scout rule.</p>
			<p>The legend of the boy scout rule says:</p>
			<p><em class="italic">Leave the campground cleaner than you found it.</em></p>
			<p>I have no evidence that this rule was ever used by actual scouts. It is more likely a variant of a message the founder of the scout movement, Robert Baden-Powell, left to the movement before his death. In that message, he said, <em class="italic">Try to leave this world a little better than you found it.</em></p>
			<p>In the book <em class="italic">Clean Code,</em> the author, Robert C. Martin, also known as Uncle Bob, transformed this rule so that it could be applied to code. He states that if we apply this rule when we maintain our code, we should always leave our code a little cleaner and better each time we maintain it so that its quality will increase over time. We can rephrase the boy scout rule in relation to software development so that it says, <em class="italic">Always leave the code you're editing a little better than you found it</em>.</p>
			<p>The changes do not have to be huge. You will not have to rewrite large sections of code. If you change a variable name to something that better describes the value it is holding, or adding documentation to a piece of code where it was missing previously will increase the code's quality slightly.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <a href="B15554_12_Final_NM_ePub.xhtml#_idTextAnchor186"><em class="italic">Chapter 12</em></a>, <em class="italic">Code Quality,</em> and <a href="B15554_AppA_Final_NM_ePub.xhtml#_idTextAnchor210"><em class="italic">Appendix A</em></a>, <em class="italic">How To Translate the Pseudocode into Real Code</em>, we will dive deeper into how we can write high-quality code, among other things, wh<a id="_idTextAnchor178"/>ile keeping maintainability in mind.</p>
			<p>Now that <a id="_idIndexMarker736"/>we have an idea of how to get the software to our users, when we are done writing and testing it, we should take a closer look at the actual development process.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor179"/>Software development process methodologies</h1>
			<p>Since the 1960s, different methodologies have been developed to help system developers <a id="_idIndexMarker737"/>be more productive, on target, and create higher quality code. Here, we will look at some of the more essential methodologies – some that are in use today and some that have been superseded by newer and more flexible ones.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor180"/>Waterfall development</h2>
			<p>The waterfall <a id="_idIndexMarker738"/>development model is one that almost everyone loves to hate. We will look at it anyway, as many newer methodologies have been developed as a reaction to it.</p>
			<p>The reason it is hated, <a id="_idIndexMarker739"/>is that it will not take changing requirements into account.</p>
			<p>In the waterfall model, several defined steps are completed, one preceding the next. An example of these steps can be seen in the following diagram:</p>
			<div><div><img src="img/Figure_11.11_B15554.jpg" alt="Figure 11.11 – The steps in the waterfall model"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.11 – The steps in the waterfall model</p>
			<p>This is <a id="_idIndexMarker740"/>how the model works:</p>
			<ol>
				<li value="1">First, we gather all the requirements needed for this application.</li>
				<li>After that, we make a system design, where we describe how different responsibilities will be divided between different parts of the application. </li>
				<li>Then, we write the code. </li>
				<li>During the verification phase, the code is tested.</li>
				<li>Finally, when the software is released, it goes into the maintenance phase, where it is maintained.</li>
			</ol>
			<p>The main <a id="_idIndexMarker741"/>criticism of this model is that it will not capture new requirements that might (and often will) arise during the development phase. The process of going from an initial idea to a finalized product can be rather long, and during this time, a lot of things will happen that will have an impact on this application. New laws can come into place,  competing applications might be released, new versions of operating systems and other software that this application relies on might be released, and so on. </p>
			<p>If we have a development model that cannot capture these changes, we will most likely have developed a product that is outdated before it has even been released. </p>
			<p>Now that we have looked at a methodology that is not in use anymore, or at least, no one will say that they are using it, we can look at some that are in use and that are created as a reaction to the waterfall model.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor181"/>Spiral model</h2>
			<p>In 1986, the American software engineer Barry Boehm described and depicted a model that, instead <a id="_idIndexMarker742"/>of going from one phase to the next, was shaped as a spiral. </p>
			<p>This idea <a id="_idIndexMarker743"/>has since been developed and modified into several new methodologies. Still, the basic idea of driving the development process by a spiral has been prevalent since then.</p>
			<p>One key concept in the spiral model is that risk is taken into consideration as a critical concept when developing software. </p>
			<p>In the following diagram, we can see a simplified version of the spiral model:</p>
			<div><div><img src="img/Figure_11.12_B15554.jpg" alt="Figure 11.12 – A simplified version of the spiral model"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.12 – A simplified version of the spiral model</p>
			<p>Here, we have four distinct phases. Instead of going through them once in order, we will iterate through them over and over as many times as necessary until the application is developed. Let's take a look:</p>
			<ol>
				<li value="1">In the first phase, we look at the objectives, as we see them at this point in the development process. </li>
				<li>We then look at the risks. What can hinder us from succeeding in implementing the objectives we just determined? By identifying the risks, we have a higher chance of avoiding them or at least minimizing the impact they will have on our software.</li>
				<li>When that is done, we will go ahead and develop and test the software. </li>
				<li>The last phase is a review phase. Here, we look back at what we have done in the other three phases during this iteration, including what went well and what problems we had. We can learn from this so that the next iteration is better.</li>
			</ol>
			<p>We will then <a id="_idIndexMarker744"/>start over with the objectives for the next iteration by determining the risks and developing and reviewing them repeatedly.</p>
			<p>The growing <a id="_idIndexMarker745"/>spiral illustrates that, for each iteration, more of the software has been created.</p>
			<p>Even if the spiral model was created as a reaction to the shortcomings of the waterfall model, this claim shows that the problem is not the Waterfall model in itself, but that the development process becomes very prolonged and therefore can't react to rapid changes in requirements.</p>
			<p>The spiral model gave inspiration to several new methodologies, where the development process is divided into smaller iterations. The next one is one such example and the one that is currently the foundation of how most software projects are run.</p>
			<p>Barry Boehm also said that this model is just a series of small waterfall models.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor182"/>Agile development</h2>
			<p>Agile <a id="_idIndexMarker746"/>software development <a id="_idIndexMarker747"/>refers to a group of software methodologies, all based on iterative development.</p>
			<p>The term <em class="italic">agile</em> comes from a group of 17 software developers who met at a resort in Snowbird, Utah, in 2001. After the meeting, they published <em class="italic">Manifesto for Agile Software Development</em>. </p>
			<p>The manifesto is a short description of what should be prioritized during the software development process. </p>
			<p>It can be found at <a href="https://agilemanifesto.org/">https://agilemanifesto.org/</a>.</p>
			<p>This manifesto <a id="_idIndexMarker748"/>is then outlined in more detail by twelve principles, called <em class="italic">Principles behind the Agile Manifesto</em>, and they can be found here at <a href="https://agilemanifesto.org/principles.html">https://agilemanifesto.org/principles.html</a>.</p>
			<p>These <a id="_idIndexMarker749"/>ideas had a significant impact on the software industry, and several new software development <a id="_idIndexMarker750"/>methodologies were developed in response to the manifesto.</p>
			<p>Let's look at some of the more popular of these.</p>
			<h3>Agile Scrum methodology</h3>
			<p>This methodology, better <a id="_idIndexMarker751"/>known as Scrum, is a lightweight project management framework that uses an iterative and incremental approach. </p>
			<p>In Scrum, the <a id="_idIndexMarker752"/>product owner – a person with the power to decide what items will go into the application – plays a central role. This person needs to play an active role throughout the development process.</p>
			<p>The product owner works closely with the development team to create a prioritized list of system functionality, called the <strong class="bold">product backlog</strong>. The product backlog consists of whatever <a id="_idIndexMarker753"/>needs to be done to deliver a working software system successfully. The items in the backlog can be things such as the features of the application, bugs that need to be fixed, and non-functional requirements such as certification, accessibility, and data integrity.</p>
			<p>When the properties in the backlog have been prioritized, a team of developers (and potentially other roles, if needed) will start to develop in what can be called <em class="italic">potentially shippable increments</em>.</p>
			<p>This means that the team will take some of the highest prioritized items from the backlog and start to implement them during a short time frame, known as a <strong class="bold">sprint</strong>. A sprint will <a id="_idIndexMarker754"/>typically last for somewhere between 14 and 30 days.</p>
			<p>The outcome <a id="_idIndexMarker755"/>of the sprint is preferably fully functional so that it can immediately be put into production, and users can start using this functionality.</p>
			<p>The team will then start over with a new sprint. This will be repeated as many times as necessary.</p>
			<h3>Lean software development</h3>
			<p>This Agile methodology is iterative, just like Scrum, and focuses on delivering fully functional batches. The methodology is highly flexible and does not have any rigid rules or guidelines.</p>
			<p>Its main idea <a id="_idIndexMarker756"/>is to eliminate what is called <em class="italic">waste</em>. This is done by letting users of the system select only the precious features for the system. These features are then prioritized and delivered in small batches.</p>
			<p>It relies on rapid and reliable feedback from the users of the software. In Lean development, the work is <em class="italic">pulled</em> by customer requests.</p>
			<h3>Extreme Programming (XP)</h3>
			<p>This methodology was first described by Kent Beck, an American software engineer who took software best practices to an extreme level. One example of this is code review. Standard practice <a id="_idIndexMarker757"/>is that another developer should review all the code before it can be merged with the code that goes into a release. In XP, this is done by using the concept of <em class="italic">pair programming</em>. Pair programming is when two developers are using one computer to develop code. One is called the <em class="italic">driver</em> and is the one that will write the code. The other developer is called the <em class="italic">observer</em> or the <em class="italic">navigator</em> and will observe and review what the driver is doing. The two will frequently switch roles. </p>
			<p>Compared to the traditional code review process, this will speed things up as the review is done during the development phase. Other benefits of pair programming include the fact that the driver will consistently get input from the observer regarding how to solve the current task.</p>
			<p>The goal of XP is to reduce the cost of changes in the requirements. To do t<a id="_idTextAnchor183"/>his, XP uses short development cycles.</p>
			<p>In XP, changes in <a id="_idIndexMarker758"/>requirements are a natural, inescapable, and desirable aspect of software development.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor184"/>Summary</h1>
			<p>In this chapter, we looked at some of the more essential concepts that go into software development that have nothing to do with the actual coding. Even if we are not working on large-scale, professional projects, we should still version control our code, write tests to verify that the code does what it is supposed to, and work iteratively.</p>
			<p>We began by learning that version control systems are a great tool that will help us not only be able to go back in time to an earlier version of the code, but also help us share our code with other developers in our team.</p>
			<p>Then, we saw that to verify that the code we have written is doing what it is supposed to, we need to test it. In this case, we have something called unit tests and integration tests that we should perform to make sure that the application produces the correct result and that the new code does not produce any side effects, which would produce an undesirable result for a code that worked successfully in a previous version.</p>
			<p>After this, we saw that the software release life cycle defines what steps are to be performed to make a piece of code mature enough to be released to end users. When code is ready to be released, we need to deploy it to the environment (for example, as an application server) so that the end users of this application can access it. When the code is used, we need to maintain it. Bugs will be discovered, features will need to be added or changed, and so on.</p>
			<p>Lastly, we learned that to handle the development process, a software development team will typically use a development methodology. The methodology will describe in what order things should be done, how the team will cooperate to achieve a good result, and how to decide what will go into a software release.</p>
			<p>In the next chapter, we will take a look at how we can write high-quality code, and what we mean by code quality.</p>
		</div>
	</body></html>