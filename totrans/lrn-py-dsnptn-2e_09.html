<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Model-View-Controller – Compound Patterns</h1></div></div></div><p class="calibre6">In the previous chapter, we started with an introduction to Template Method design pattern, in which subclasses redefine the concrete steps of the algorithm, thus achieving flexibility and code reuse. You learned about the Template Method and how it is used to construct the algorithm with a sequence of steps. We discussed the UML diagram, its pros and cons, learned more about it in the FAQ section, and summarized the discussion at the end of the chapter.</p><p class="calibre6">In this <a id="id221" class="calibre1"/>chapter, we will talk about Compound patterns. We will get introduced to the <strong class="calibre7">Model-View-Controller</strong> (<strong class="calibre7">MVC</strong>) design pattern and discuss how it is used in software application development. We will work with a sample use case and implement it in Python v3.5.</p><p class="calibre6">We will cover the following topics in brief in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">An introduction to Compound patterns and the Model-View-Controller</li><li class="listitem">The MVC pattern and its UML diagram</li><li class="listitem">A real-world use case with the Python v3.5 code implementation</li><li class="listitem">MVC pattern—pros and cons</li><li class="listitem">Frequently asked questions</li></ul></div><p class="calibre6">At the end of the chapter, we will summarize the entire discussion—consider this as a takeaway.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec66" class="calibre1"/>An introduction to Compound patterns</h1></div></div></div><p class="calibre6">Throughout<a id="id222" class="calibre1"/> this book, we explored various design patterns. As we saw, design patterns are classified under three main categories: structural, creational, and behavioral design patterns. You also learned about each of these with examples.</p><p class="calibre6">However, in software implementation, patterns don't work in isolation. Every software design or solution is not implemented with just one design pattern. Actually, patterns are often used together and combined to achieve a given design solution. As GoF defines, "<em class="calibre13">a compound pattern combines two or more patterns into a solution that solves a recurring or general problem</em>." A Compound pattern is not a set of patterns working together; it is a general solution to a problem.</p><p class="calibre6">We're now<a id="id223" class="calibre1"/> going to look at the Model-View-Controller Compound pattern. It's the best example of Compound patterns and has been used in many design solutions over the years.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec67" class="calibre1"/>The Model-View-Controller pattern</h1></div></div></div><p class="calibre6">MVC is a<a id="id224" class="calibre1"/> software pattern to implement user interfaces and an architecture that can be easily modified and maintained. Essentially, the MVC pattern talks about separating the application into three essential parts: model, view, and controller. These three parts are interconnected and help in separating the ways in which information is represented to the way information is presented.</p><p class="calibre6">This is how<a id="id225" class="calibre1"/> the MVC pattern works: the model represents the data and business logic (how information is stored and queried), view is nothing but the representation (how it is presented) of the data, and controller is the glue between the two, the one that directs the model and view to behave in a certain way based on what a user needs. Interestingly, the view and controller are dependent on the model but not the other way round. This is primarily because a user is concerned about the data. Models can be worked with independently and this is the key aspect of the MVC pattern.</p><p class="calibre6">Consider the case of a website. This is one of the classical examples to describe the MVC pattern. What happens on a website? You click on a button, a few operations happen, and you get to see what you desired. How does this happen?</p><div><ul class="itemizedlist"><li class="listitem">You are the user and you interact with the view. The view is the web page that is presented to you. You click on the buttons on the view and it tells the controller what needs to be done.</li><li class="listitem">Controllers take the input from the view and send it to the model. The model gets manipulated based on the actions done by the user.</li><li class="listitem">Controllers can also ask the view to change based on the action it receives from the user, such as changing the buttons, presenting additional UI elements, and so on.</li><li class="listitem">The model notifies the change in state to the view. This can be based on a few internal changes or external triggers such as clicking on a button.</li><li class="listitem">The view then displays the state that it gets directly from the model. For example, if a user logs in to the website, he/she might be presented with a dashboard view (post login). All the details that need to be populated on the dashboard are given by the model to the view.</li></ul></div><p class="calibre6">The MVC design <a id="id226" class="calibre1"/>pattern works with the following terms—Model, View, Controller and the Client:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre7">Model</strong>: This declares a class to store and manipulate data</li><li class="listitem"><strong class="calibre7">View</strong>: This declares a class to build user interfaces and data displays</li><li class="listitem"><strong class="calibre7">Controller</strong>: This declares a class that connects the model and view</li><li class="listitem"><strong class="calibre7">User</strong>: This declares a class that requests for certain results based on certain actions</li></ul></div><p class="calibre6">The following image explains the flow of the MVC pattern:</p><div><img src="img/00031.jpeg" alt="The Model-View-Controller pattern" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">To talk about the MVC pattern in software development terminologies, let's look into the main classes involved in the MVC pattern:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="email">model</code> class is used to define all the operations that happen on the data (such as create, modify, and delete) and provides methods on how to use the data.</li><li class="listitem">The <code class="email">view</code> class is a representation of the user interface. It will have methods that help us build web or GUI interfaces based on the context and need of the application. It should not contain any logic of its own and just display the data that it receives.</li><li class="listitem">The <code class="email">controller</code> class is used to receive data from the request and send it to other parts of the system. It has methods that are used to route requests.</li></ul></div><p class="calibre6">The MVC pattern is used in the following cases:</p><div><ul class="itemizedlist"><li class="listitem">When<a id="id227" class="calibre1"/> there is a need to change the presentation without changes in the business logic</li><li class="listitem">Multiple controllers can be used to work with multiple views to change the representation on the user interface</li><li class="listitem">Once again, the model can be changed without changes in the view as they can work independently of each other</li></ul></div><p class="calibre6">In short, the main intention of the MVC pattern is as follows:</p><div><ul class="itemizedlist"><li class="listitem">Keeping the data and presentation of the data separate.</li><li class="listitem">Easy maintenance of the class and implementation.</li><li class="listitem">Flexibility to change the way in which data is stored and displayed. Both are independent and hence have the flexibility to change.</li></ul></div><p class="calibre6">Let's look at the model, view, and controller in detail as covered in <em class="calibre13">Learning Python Design Patterns</em>, <em class="calibre13">Gennadiy Zlobin</em>, <em class="calibre13">Packt Publishing</em> as well.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec44" class="calibre1"/>Model – knowledge of the application</h2></div></div></div><p class="calibre6">Model is the cornerstone of an application because it is independent of the view and controller. The <a id="id228" class="calibre1"/>view and controller in turn are dependent on the model.</p><p class="calibre6">Model also provides data that is requested by the client. Typically, in applications, the model is represented by the database tables that store and return information. Model has state and methods to change states but is not aware of how the data would be seen by the client.</p><p class="calibre6">It is critical that the model stays consistent across multiple operations; otherwise, the client may get corrupted or display stale data, which is completely undesirable.</p><p class="calibre6">As the model is completely independent, developers working on this piece can focus on maintenance without the need for the latest view changes.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec45" class="calibre1"/>View – the appearance</h2></div></div></div><p class="calibre6">The view is<a id="id229" class="calibre1"/> a representation of data on the interface that the client sees. The view can be developed independently but should not contain any complex logic. Logic should still reside in the controller or model.</p><p class="calibre6">In today's world, views need to be flexible enough and should cater to multiple platforms such as desktop, mobiles, tables, and multiple screen sizes.</p><p class="calibre6">Views<a id="id230" class="calibre1"/> should avoid interacting directly with the databases and rely on models to get the required data.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec46" class="calibre1"/>Controller – the glue</h2></div></div></div><p class="calibre6">The<a id="id231" class="calibre1"/> controller, as the name suggests, controls the interaction of the user on the interface. When the user clicks on certain elements on the interface, based on the interaction (button click or touch), the controller makes a call to the model that in turn creates, updates, or deletes the data.</p><p class="calibre6">Controllers also pass the data to the view that renders the information for the user to view on the interface.</p><p class="calibre6">The Controller shouldn't make database calls or get involved in presenting the data. The controller should act as the glue between the model and view and be as thin as possible.</p><p class="calibre6">Let's now get into action and develop one sample app. The Python code shown next implements the MVC design pattern. Consider that we want to develop an application that tells a user about the marketing services delivered by a cloud company, which include e-mail, SMS, and voice facilities.</p><p class="calibre6">We first develop the <code class="email">model</code> class (Model) that defines the services provided by the product, namely, e-mail, SMS, and voice. Each of these services have designated rates, such as 1,000 e-mails would charge the client $2, and for 1,000 messages, the charges are $10, and $15 for 1,000 voice messages. Thus, the model represents the data about the product services and prices.</p><p class="calibre6">We then define the <code class="email">view</code> class (View) that provides a method to present the information back to the client. The methods are <code class="email">list_services()</code> and <code class="email">list_pricing()</code>; as the name suggests, one method is used to print the services offered by the product and the other is to list the pricing for the services.</p><p class="calibre6">We then define the <code class="email">Controller</code> class that defines two methods, <code class="email">get_services()</code> and <code class="email">get_pricing()</code>. Each of these methods queries the model and gets the data. The data is then fed to the view and thus presented to the client.</p><p class="calibre6">The <code class="email">Client</code> class instantiates the controller. The <code class="email">controller</code> object is used to call appropriate methods based on the client's request:</p><div><pre class="programlisting">class Model(object):
    services = {
                 'email': {'number': 1000, 'price': 2,},
                 'sms': {'number': 1000, 'price': 10,},
                 'voice': {'number': 1000, 'price': 15,},
    }


class View(object):
    def list_services(self, services):
        for svc in services:
            print(svc, ' ')
    
    def list_pricing(self, services):
        for svc in services:
            print("For" , Model.services[svc]['number'],
                               svc, "message you pay $",
                           Model.services[svc]['price'])


class Controller(object):
    def __init__(self):
        self.model = Model()
        self.view = View()
    
    def get_services(self):
        services = self.model.services.keys()
        return(self.view.list_services(services))
    
    def get_pricing(self):
        services = self.model.services.keys()
        return(self.view.list_pricing(services))


class Client(object):
    controller = Controller()
    print("Services Provided:")
    controller.get_services()
    print("Pricing for Services:")
    controller.get_pricing()</pre></div><p class="calibre6">The <a id="id232" class="calibre1"/>following is the output of the preceding code:</p><div><img src="img/00032.jpeg" alt="Controller – the glue" class="calibre14"/></div><p class="calibre15"> </p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec68" class="calibre1"/>A UML class diagram for the MVC design pattern</h1></div></div></div><p class="calibre6">Let's<a id="id233" class="calibre1"/> now understand more about the MVC pattern with the help of the following UML diagram.</p><p class="calibre6">As we discussed in the previous sections, the MVC pattern has the following main participants: the <code class="email">Model</code>, <code class="email">View</code>, and <code class="email">Controller</code> class.</p><div><img src="img/00033.jpeg" alt="A UML class diagram for the MVC design pattern" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">In the UML diagram, we can see three main classes in this pattern:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="email">Model</code> class: This defines the business logic or operations attached to certain tasks from the client.</li><li class="listitem">The <code class="email">View</code> class: This defines the view or representation that is viewed by the client. The model presents the data to the view based on the business logic.</li><li class="listitem">The <code class="email">Controller</code> class: This is essentially an interface that is between the view and model. When the client takes certain actions, the controller directs the query from the view to model.</li></ul></div><p class="calibre6">The following is a code example to understand the pattern with all the participants involved:</p><div><pre class="programlisting">class Model(object):
    def logic(self):
        data = 'Got it!'
        print("Model: Crunching data as per business logic")
        return data


class View(object):
    def update(self, data):
        print("View: Updating the view with results: ", data)


class Controller(object):
    def __init__(self):
        self.model = Model()
        self.view = View()
    
    def interface(self):
        print("Controller: Relayed the Client asks")
        data = self.model.logic()
        self.view.update(data)


class Client(object):
    print("Client: asks for certain information")
    controller = Controller()
    controller.interface()</pre></div><p class="calibre6">The<a id="id234" class="calibre1"/> following is the output of the preceding code:</p><div><img src="img/00034.jpeg" alt="A UML class diagram for the MVC design pattern" class="calibre14"/></div><p class="calibre15"> </p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec69" class="calibre1"/>The MVC pattern in the real world</h1></div></div></div><p class="calibre6">Our good<a id="id235" class="calibre1"/> old web application frameworks are based on the philosophies of MVC. Take the example of Django or Rails (Ruby): they structure their projects in the Model-View-Controller format except that it is represented as <strong class="calibre7">MTV</strong> (<strong class="calibre7">Model</strong>, <strong class="calibre7">Template</strong>, <strong class="calibre7">View</strong>) where the model is the database, templates<a id="id236" class="calibre1"/> are the views, and controllers are the views/routes.</p><p class="calibre6">As an <a id="id237" class="calibre1"/>example, let's take up the Tornado web application framework (<a class="calibre1" href="http://www.tornadoweb.org/en/stable/">http://www.tornadoweb.org/en/stable/</a>) to develop a single-page app. This application is used to manage a user's tasks and the user has permissions to add tasks, update tasks, and delete tasks.</p><p class="calibre6">Let's see the design considerations:</p><div><ul class="itemizedlist"><li class="listitem">Let's start <a id="id238" class="calibre1"/>with the controllers first. In Tornado, controllers have been defined as views/app routes. We need to define multiple views such as listing the tasks, creating new tasks, closing the tasks, and handling an operation if a request could not be served.</li><li class="listitem">We<a id="id239" class="calibre1"/> should also define models, the database operations to list, create, or delete the tasks.</li><li class="listitem">Finally, the views are represented by templates in Tornado. Based on our app, we would need a template to show tasks, create or delete tasks, and also a template if a URL is not found.</li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec47" class="calibre1"/>Modules</h2></div></div></div><p class="calibre6">We <a id="id240" class="calibre1"/>will use the following modules for this application:</p><div><ul class="itemizedlist"><li class="listitem">Torando==4.3</li><li class="listitem">SQLite3==2.6.0</li></ul></div><p class="calibre6">Let's start by importing the Python modules in our app:</p><div><pre class="programlisting">importtornado
import tornado.web
import tornado.ioloop
import tornado.httpserver
import sqlite3</pre></div><p class="calibre6">The following code represents the database operations, essentially, the models in MVC. In Tornado, DB operations are performed under different handlers. Handlers perform operations on the DB based on the route requested by the user in the web app. Here, we talk about the<a id="id241" class="calibre1"/> four handlers that we have created in this example:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">IndexHandler</code>: This<a id="id242" class="calibre1"/> returns all the tasks that are stored in the database. It returns a dictionary with key tasks. It performs the <code class="email">SELECT</code> database operation to get these tasks.</li><li class="listitem"><code class="email">NewHandler</code>: As<a id="id243" class="calibre1"/> the name suggests, this is useful to add new tasks. It checks whether there is a <code class="email">POST</code> call to create a new task and does an <code class="email">INSERT</code> operation in the DB.</li><li class="listitem"><code class="email">UpdateHandler</code>: This <a id="id244" class="calibre1"/>is useful in marking a task as complete or reopening a given task. In this case, the <code class="email">UPDATE</code> database operation occurs to set a task with the status as open/closed.</li><li class="listitem"><code class="email">DeleteHandler</code>: This deletes a given task from the database. Once deleted, the task<a id="id245" class="calibre1"/> is no more visible in the list of tasks.</li></ul></div><p class="calibre6">We have also developed an <code class="email">_execute()</code> method that takes a SQLite query as an input and performs the required DB operation. The <code class="email">_execute()</code> method does the following operations on the SQLite DB:</p><div><ul class="itemizedlist"><li class="listitem">Creating a <a id="id246" class="calibre1"/>SQLite DB connection</li><li class="listitem">Getting the cursor object</li><li class="listitem">Using the cursor object to make a transaction</li><li class="listitem">Committing the query</li><li class="listitem">Closing the connection</li></ul></div><p class="calibre6">Let's look at the handlers in the Python implementation:</p><div><pre class="programlisting">class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        query = "select * from task"
        todos = _execute(query)
        self.render('index.html', todos=todos)

class NewHandler(tornado.web.RequestHandler):
    def post(self):
        name = self.get_argument('name', None)
        query = "create table if not exists task (id INTEGER \
            PRIMARY KEY, name TEXT, status NUMERIC) "
        _execute(query)
        query = "insert into task (name, status) \
            values ('%s', %d) " %(name, 1)
        _execute(query)
        self.redirect('/')
    
    def get(self):
        self.render('new.html')


class UpdateHandler(tornado.web.RequestHandler):
    def get(self, id, status):
        query = "update task set status=%d where \
            id=%s" %(int(status), id)
        _execute(query)
        self.redirect('/')


class DeleteHandler(tornado.web.RequestHandler):
    def get(self, id):
        query = "delete from task where id=%s" % id
        _execute(query)
        self.redirect('/')</pre></div><p class="calibre6">If you look <a id="id247" class="calibre1"/>up these methods, you'll notice something called <code class="email">self.render()</code>. This essentially represents the views in MVC (templates in the Tornado framework). We have three main templates:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">index.html</code>: This is a template to list all the tasks</li><li class="listitem"><code class="email">new.html</code>: This is the view to create a new task</li><li class="listitem"><code class="email">base.html</code>: This is the base template from which other templates are inherited</li></ul></div><p class="calibre6">Consider the following code:</p><div><pre class="programlisting">base.html
&lt;html&gt;
&lt;!DOCTYPE&gt;
&lt;html&gt;
&lt;head&gt;
        {% block header %}{% end %}
&lt;/head&gt;
&lt;body&gt;
        {% block body %}{% end %}
&lt;/body&gt;
&lt;/html&gt;

index.html

{% extends 'base.html' %}
&lt;title&gt;ToDo&lt;/title&gt;
{% block body %}
&lt;h3&gt;Your Tasks&lt;/h3&gt;
&lt;table border="1" &gt;
&lt;tralign="center"&gt;
&lt;td&gt;Id&lt;/td&gt;
&lt;td&gt;Name&lt;/td&gt;
&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;Update&lt;/td&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;/tr&gt;
    {% for todo in todos %}
&lt;tralign="center"&gt;
&lt;td&gt;{{todo[0]}}&lt;/td&gt;
&lt;td&gt;{{todo[1]}}&lt;/td&gt;
            {% if todo[2] %}
&lt;td&gt;Open&lt;/td&gt;
            {% else %}
&lt;td&gt;Closed&lt;/td&gt;
            {% end %}
            {% if todo[2] %}
&lt;td&gt;&lt;a href="/todo/update/{{todo[0]}}/0"&gt;Close Task&lt;/a&gt;&lt;/td&gt;
            {% else %}
&lt;td&gt;&lt;a href="/todo/update/{{todo[0]}}/1"&gt;Open Task&lt;/a&gt;&lt;/td&gt;
            {% end %}
&lt;td&gt;&lt;a href="/todo/delete/{{todo[0]}}"&gt;X&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
    {% end %}
&lt;/table&gt;

&lt;div&gt;
&lt;h3&gt;&lt;a href="/todo/new"&gt;Add Task&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
{% end %}

new.html

{% extends 'base.html' %}
&lt;title&gt;ToDo&lt;/title&gt;
{% block body %}
&lt;div&gt;
&lt;h3&gt;Add Task to your List&lt;/h3&gt;
&lt;form action="/todo/new" method="post" id="new"&gt;
&lt;p&gt;&lt;input type="text" name="name" placeholder="Enter task"/&gt;
&lt;input type="submit" class="submit" value="add" /&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;/div&gt;
{% end %}</pre></div><p class="calibre6">In<a id="id248" class="calibre1"/> Tornado, we also have the application routes that are controllers in MVC. We have four application routes in this example:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">/</code>: This is the route to list all the tasks</li><li class="listitem"><code class="email">/todo/new</code>: This is the route to create new tasks</li><li class="listitem"><code class="email">/todo/update</code>: This is the route to update the task status to open/closed</li><li class="listitem"><code class="email">/todo/delete</code>: This is the route to delete a completed task</li></ul></div><p class="calibre6">The code example is as follows:</p><div><pre class="programlisting">class RunApp(tornado.web.Application):
    def __init__(self):
        Handlers = [
            (r'/', IndexHandler),
            (r'/todo/new', NewHandler),
            (r'/todo/update/(\d+)/status/(\d+)', UpdateHandler),
            (r'/todo/delete/(\d+)', DeleteHandler),
        ]
        settings = dict(
            debug=True,
            template_path='templates',
            static_path="static",
        )
        tornado.web.Application.__init__(self, Handlers, \
            **settings)</pre></div><p class="calibre6">We also have application settings and can start the HTTP web server to run the application:</p><div><pre class="programlisting">if__name__ == '__main__':
    http_server = tornado.httpserver.HTTPServer(RunApp())
    http_server.listen(5000)
    tornado.ioloop.IOLoop.instance().start()</pre></div><p class="calibre6">When <a id="id249" class="calibre1"/>we run the Python program:</p><div><ol class="orderedlist"><li class="listitem" value="1">The server gets started and runs on port <code class="email">5000</code>. The appropriate views, templates, and controllers have been configured.</li><li class="listitem" value="2">On browsing <code class="email">http://localhost:5000/</code>, we can see the list of tasks. the following screenshot shows the output in the browser:<div><img src="img/00035.jpeg" alt="Modules" class="calibre14"/></div><p class="calibre19"> </p></li><li class="listitem" value="3">We can also add a new task. Once you click on <strong class="calibre7">add</strong>, a new task gets added. In the following screenshot, a new task <code class="email">Write the New Chapter</code> is added and listed<a id="id250" class="calibre1"/> in the task list:<div><img src="img/00036.jpeg" alt="Modules" class="calibre14"/></div><p class="calibre19"> </p><p class="calibre26">When we enter the new task and click on the ADD button, the task gets added to the list of existing tasks:</p><div><img src="img/00037.jpeg" alt="Modules" class="calibre14"/></div><p class="calibre19"> </p></li><li class="listitem" value="4">We can close tasks from the UI as well. For example, we update the <strong class="calibre7">Cook food</strong> task and the list gets updated. We can reopen the task if we choose to:<div><img src="img/00038.jpeg" alt="Modules" class="calibre14"/></div><p class="calibre19"> </p></li><li class="listitem" value="5">We can also delete a task. In this case, we delete the first task, <strong class="calibre7">New Task</strong>, and the task list will get updated to remove the task:<div><img src="img/00039.jpeg" alt="Modules" class="calibre14"/></div><p class="calibre19"> </p></li></ol><div></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec70" class="calibre1"/>Benefits of the MVC pattern</h1></div></div></div><p class="calibre6">The<a id="id251" class="calibre1"/> following are the benefits of the MVC pattern:</p><div><ul class="itemizedlist"><li class="listitem">With MVC, developers can split the software application into three major parts: model, view, and controller. This helps in achieving easy maintenance, enforcing loose coupling, and decreasing complexity.</li><li class="listitem">MVC allows independent changes on the frontend without any, or very few, changes on the backend logic, and so the development efforts can still run independently.</li><li class="listitem">On similar lines, models or business logic can be changed without any changes in the view.</li><li class="listitem">Additionally, the controller can be changed without any impact on views or models.</li><li class="listitem">MVC also helps in hiring people with specific capabilities such as platform engineers and UI engineers who can work independently in their field of expertise.</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec71" class="calibre1"/>Frequently asked questions</h1></div></div></div><p class="calibre6">Q1. Isn't MVC a pattern? Why is it called a Compound pattern?</p><p class="calibre6">A: Compound <a id="id252" class="calibre1"/>patterns are essentially groups of patterns put together to solve large design problems in software application development. The MVC pattern is the most popular and widely used Compound pattern. As it is so widely used and reliable, it is treated as a pattern itself.</p><p class="calibre6">Q2. Is MVC used only in websites?</p><p class="calibre6">A: No, a website is the best example to describe MVC. However, MVC can be used in multiple areas such as GUI applications or any other place where you need loose coupling and splitting of components in an independent way. Typical examples of MVC include blogs, movie database applications, and video streaming web apps. While MVC is useful in many places, it's overkill if you use it for the landing pages, marketing content, or quick single-page applications.</p><p class="calibre6">Q3. Can multiple views work with multiple models?</p><p class="calibre6">A: Yes, often you'd end up in a situation where the data needs to be collated from multiple models and presented in one view. One-to-one mapping is rare in today's web app world.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec72" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">We began the chapter by understanding Compound patterns and looked at the Model-View-Controller pattern and how it is effectively used in software architecture. We then looked at how the MVC pattern is used to ensure loose coupling and maintain a multilayer framework for independent task development.</p><p class="calibre6">You also learned the pattern with a UML diagram and sample code implementation in Python v3.5 along with the explanation. We also covered a section on FAQs that would help you get more ideas on the pattern and its possible advantages/disadvantages.</p><p class="calibre6">In the next chapter, we will talk about the Anti patterns. See you there!</p></div></body></html>