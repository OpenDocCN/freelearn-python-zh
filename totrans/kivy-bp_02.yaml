- en: Chapter 2. Building a Paint App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html "Chapter 1. Building a Clock App"), *Building a Clock
    App*, we built an application from Kivy''s standard components: layouts, text
    labels, and buttons. We were able to significantly customize the look of these
    components while retaining a very high level of abstraction—working with full-fledged
    widgets, as opposed to individual graphical primitives. This is convenient for
    certain types of applications but not always desirable, and as you will see shortly,
    the Kivy framework also provides tools to work with a lower level of abstraction:
    draw points and lines.'
  prefs: []
  type: TYPE_NORMAL
- en: I believe that the best way to play with free-form graphics is by building a
    painting app. Our application, when complete, will be somewhat similar to the
    MS Paint application that comes bundled with the Windows OS.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Microsoft Paint, our Kivy Paint app will be fully cross-platform, including
    mobile devices running Android and iOS. Also, we will deliberately omit many features
    found in "real" software for image processing, such as rectangular selection,
    layers, and saving files to disk. Implementing them can be a good exercise for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regarding mobile devices: while building a fully functional iOS application
    with Kivy is of course possible, it''s still non-trivial if you have no experience
    with either iOS or Kivy development. Therefore, it''s recommended that you write
    for easy platforms first so that you can quickly update your code and run the
    application without building binaries and such. In this sense, Android development
    is much simpler, thanks to Kivy Launcher, a generic environment to run Kivy apps
    on Android. It is available on Google Play at [https://play.google.com/store/apps/details?id=org.kivy.pygame](https://play.google.com/store/apps/details?id=org.kivy.pygame).'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to immediately launch and test your app without compiling is an
    incredibly important aspect of Kivy development. This allows programmers to iterate
    quickly and evaluate possible solutions on the spot, which is crucial for **rapid
    application development** (**RAD**) and the agile methodology as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: With the notable exception of window resizing, which isn't widely used on mobiles,
    Kivy apps behave in a similar way on various mobile and desktop platforms. So
    it's perfectly feasible to write and debug just the desktop or Android version
    of the program until much later in the release cycle and then fill the compatibility
    gaps, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also explore two distinctive, almost mutually exclusive features available
    to Kivy apps: multitouch controls, useful on devices with a touch screen, and
    changing mouse pointers on a desktop computer.'
  prefs: []
  type: TYPE_NORMAL
- en: Staying true to its mobile-first approach, Kivy provides an emulation layer
    for multitouch input, usable with the mouse. It can be triggered with a right-click.
    This multitouch emulation isn't, however, suitable for any real-world usage, except
    for debugging; it will be turned off in the production version of the application
    when running on a desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our application will look like at the end of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Paint App](img/B01620_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Kivy Paint app, bad painting sold separately
  prefs: []
  type: TYPE_NORMAL
- en: Setting the stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, the entire surface of our app is occupied by the **root widget**,
    in this case, that's the canvas the user can paint upon. We won't devote any screen
    space to the instruments' area until later.
  prefs: []
  type: TYPE_NORMAL
- en: As you probably know by now, the root widget is the outermost widget in the
    hierarchy. Every Kivy application has one, and it can be pretty much anything,
    depending on the desired behavior. As seen in [Chapter 1](ch01.html "Chapter 1. Building
    a Clock App"), *Building a Clock App*, `BoxLayout` is a suitable root widget;
    it was sufficient as we had no additional requirements for it, and layouts are
    designed to work as containers for other controls.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a Paint app, we need its root widget to adhere to much more interesting
    requirements; the user should be able to draw lines, possibly utilizing multitouch
    functionality, if available. At the moment, Kivy has no built-in controls suitable
    for the task at hand, so we will need to create our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building new Kivy widgets is simple. As soon as our class inherits from Kivy''s
    `Widget` class, we''re good to go. So the simplest custom widget that does nothing
    special, together with the Kivy application that uses it, can be implemented like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the full listing of our Paint app's starting point, `main.py`, complete
    with the `PaintApp` class. In future chapters, we will omit simple boilerplate
    like this; this one is provided for the sake of completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Widget` class usually serves as a base class, like `object` in Python or
    `Object` Java. While it's possible to use it "as is" in the application, `Widget`
    itself is of very limited utility. It has no visual appearance and no properties
    that would be immediately useful in the program. Subclassing `Widget`, on the
    other hand, is pretty straightforward and useful in many different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning the looks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's tweak the appearance of our app. This isn't exactly a critical
    functionality, but bear with me here, as these customizations are commonly requested
    and also pretty easy to set up. I'll briefly describe the properties that we covered
    in the previous chapter, and we'll add a number of new tweaks, such as window
    size and change of the mouse cursor.
  prefs: []
  type: TYPE_NORMAL
- en: Visual appearance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I strongly believe that the background color of any Paint app should initially
    be white. You''re probably already familiar with this setting from the first chapter.
    Here''s the line of code we add after the `__name__ == ''__main__''` line to achieve
    the desired effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You may want to put most of the `import` lines where they usually belong, near
    the beginning of a program file. As you will learn shortly, some imports in Kivy
    are actually order-dependent and have side effects, most notably the `Window`
    object. This is rarely the case in well-behaved Python programs, and the side
    effects of the import statement are generally considered bad application design.
  prefs: []
  type: TYPE_NORMAL
- en: Window size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another commonly tweaked property of a desktop application is window size. The
    following changes will have absolutely no effect on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth noting that by default, Kivy's window on a desktop can be resized
    by the end user. We will learn how to disable that shortly (only for the sake
    of completeness; usually, that's not such a great idea).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting the window size programmatically is also a handy thing to do when you're
    targeting a mobile device whose specifications are known in advance. This allows
    you to test the application on a desktop using the correct screen resolution of
    the target device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To assign the initial window size, insert the next code snippet right above
    the line that reads `from kivy.core.window import Window`. It''s critical to apply
    these settings before the `Window` object is even imported; otherwise, they won''t
    have any effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, you may want to disable window resizing by adding this one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Please don't do this unless you have a very good reason, since taking these
    trivial customizations away from the user is usually a bad idea and can easily
    ruin the overall user experience. Building a pixel-perfect app in just one resolution
    is tempting, but many of your customers (especially mobile users) won't be happy.
    Kivy layouts, on the other hand, make building scalable interfaces bearable.
  prefs: []
  type: TYPE_NORMAL
- en: Mouse cursor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next customization that generally applies only to desktop apps is changing
    the mouse pointer. Kivy has no abstraction for this, so we will work at a lower
    level, importing and calling methods directly from Pygame, the SDL-based window
    and OpenGL context provider, which is commonly used by Kivy on desktop platforms.
  prefs: []
  type: TYPE_NORMAL
- en: This code, if you choose to implement it, should always be run conditionally.
    Most mobile and some desktop apps won't have a Pygame window, and we surely want
    to avoid crashing the program over a trivial and non-essential matter like the
    mouse cursor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Long story short, this is the mouse pointer format that''s used by Pygame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mouse cursor](img/B01620_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ASCII format used to describe a custom mouse pointer
  prefs: []
  type: TYPE_NORMAL
- en: 'Every character in this notation stands for one pixel: `''@''` is black and
    `''-''` is white; everything else is transparent. All lines have to be of equal
    width, divisible by eight (a restriction imposed by the underlying SDL implementation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When used in an application, it should look as depicted in the next screenshot
    (the image is significantly zoomed in, obviously):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mouse cursor](img/B01620_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Mouse cursor for the Kivy Paint app: a crosshair'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a caveat though. At the time of writing this, the version of Pygame
    that's commonly available in some operating systems has a bug in the `pygame.cursors.compile()`
    function that switches between white and black. Detecting the affected versions
    of Pygame is impractical, so we'll just include the correctly working function
    in our code and won't call the potentially buggy version of the same function.
  prefs: []
  type: TYPE_NORMAL
- en: The correct function, `pygame_compile_cursor()`, that translates the Pygame's
    mouse cursor definition into something expected by **Simple DirectMedia Layer**
    (**SDL**), Pygame's backend library, is available online at [http://goo.gl/2KaepD](http://goo.gl/2KaepD).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to actually apply the resulting cursor to the application window, we''ll
    replace our `PaintApp.build` method with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is pretty straightforward, but some aspects of it may need explanation.
    Here is a quick walk-through:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EventLoop.ensure_window()`: This function call blocks the execution until
    we have the application window (`EventLoop.window`) ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if EventLoop.window.__class__.__name__.endswith(''Pygame'')`: This condition
    checks the window class name (not the greatest way to make assertions about the
    code, but works in this case). We want to run our mouse cursor customization code
    only for a certain window provider, in this case, Pygame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining part of the code, enclosed in a `try ... except` block, is a Pygame-specific
    `mouse.set_cursor` call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables `a` and `b` constitute the internal representation of the cursor used
    by SDL, namely the XOR and AND mask. They are binary and should be considered
    an opaque implementation detail of the SDL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, please refer to the official reference manual for the full API specification.
    Pygame documentation can be found at [http://www.pygame.org](http://www.pygame.org).
  prefs: []
  type: TYPE_NORMAL
- en: This entire situation when we're working at a level of abstraction much lower
    than Kivy's isn't very common, but by all means, don't be afraid to dive into
    implementation details sometimes. There are many things that can be achieved only
    in the underlying library because Kivy does not provide meaningful abstractions
    for them. This especially applies to non-cross-platform functionality, such as
    OS-dependent app interoperability, notification services, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reiterate, this diagram summarizes the abstraction levels we traverse in
    this specific case to set the mouse pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mouse cursor](img/B01620_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The relationship of Kivy, Pygame, SDL, and the underlying operating system abstractions
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, we didn't have to work directly with the operating system—cross-platform
    functionality can be surprisingly hard to get right. This is exactly what SDL
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we don't work with the SDL directly, you might still want to take a look
    at the documentation found at [https://www.libsdl.org/](https://www.libsdl.org/)—this
    will give you a perspective on the underlying low-level API calls that Kivy ultimately
    relies on.
  prefs: []
  type: TYPE_NORMAL
- en: Multitouch emulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Kivy provides an emulation mode for multitouch operations when running
    on a desktop system. It is activated with a right-click and spawns permanent touches
    rendered as semi-transparent red dots; they can also be dragged while holding
    the right mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature may be nice for debugging, especially when you don''t have a real
    multitouch device to test on; users, on the other hand, won''t be expecting this
    functionality bound to the right click. It''s probably a good idea to disable
    it so that our users don''t get confused by this not very useful or obvious emulation
    mode. For this, add the following to the initialization sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code can be made conditional (or just commented out temporarily) at the
    time of development if you're actually using this feature for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate one possible scenario for reacting to the touch input, let's draw
    a circle every time the user touches (or clicks) the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Widget` has an `on_touch_down` event that will come in handy for this task.
    We''re interested in just the coordinates of every touch for the time being, and
    they are accessible as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example prints the position of touches as they occur. To draw something
    on the screen instead, we will use the `Widget.canvas` property. Kivy's `Canvas`
    is a logical drawable surface that abstracts away the underlying OpenGL renderer.
    Unlike the low-level graphical API, the canvas is stateful and preserves the drawing
    instructions that were added to it.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of drawing primitives, many of those can be imported from the `kivy.graphics`
    package. Examples of drawing instructions are `Color`, `Line`, `Rectangle`, and
    `Bezier`, among others.
  prefs: []
  type: TYPE_NORMAL
- en: A very short introduction to the canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Canvas` API can be invoked directly or as a context handler using the
    `with` keyword. A simple (direct) invocation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This adds a `Line` primitive with arguments to a graphical instructions queue.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to try out this code right off the bat, please see the next section,
    *Displaying touches on the screen*, for a more comprehensive example of using
    canvas instructions in the context of our Paint app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the context handler generally looks nicer and less cluttered, especially
    when applying multiple instructions. It is shown in the following example, which
    is functionally equivalent to the previous code snippet with `self.canvas.add()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This may seem a bit harder to grasp than the direct approach. Choosing the code
    style to use is a matter of personal preference, as they achieve the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, as mentioned before, every subsequent call gets added to the canvas
    without affecting the instructions that were applied previously; at the core,
    the canvas is a growing array of instructions that are replayed every time the
    surface is rendered to the screen. Keep this in mind: as we aim for 60 fps refresh
    rate, we certainly don''t want this list to grow indefinitely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, one of the coding practices that works correctly on the immediate-mode-rendering
    surface (like HTML5''s `<canvas>`) is erasing the previously drawn graphics from
    the view by overpainting it with background color. This is rather intuitive and
    works correctly in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kivy, on the other hand, this pattern still just adds drawing instructions;
    it first renders all of the pre-existing primitives and then paints them over
    with a rectangle. This looks just about right (the canvas is visually empty) but
    does the wrong thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like a memory leak, this bug can go unnoticed for a long time, quietly
    accumulating rendering instructions and degrading performance. Thanks to powerful
    video cards found in today's devices, including smartphones, rendering is generally
    very fast. So it's hard to realize that the overhead is there when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In order to properly clear the canvas in Kivy (that is, remove all the drawing
    instructions), you should use the `canvas.clear()` method, shown later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying touches on the screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to implement a button to clear the screen shortly; in the meantime,
    let''s display touches on the screen. We remove the call to `print()` and add
    the following method to the `CanvasWidget` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This draws an empty circle around every touch that our widget receives. The
    `Color` instruction sets the color for the following `Line` primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the color format (here, `#RRGGBBAA`) isn't strictly CSS conformant,
    as it has the fourth component, namely the alpha channel (transparency). This
    syntax variation should be self-evident. It's akin to, for example, `rgb()` and
    `rgba()` notations commonly found elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: You may have also noticed how we're using `Line` in quite an unorthodox way
    here, drawing circles instead of straight lines. Many Kivy graphical primitives
    are powerful like that. For example, any canvas instruction, such as the `Rectangle`
    or `Triangle` primitive, can render a background image, given a `source` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re following along, this is how the result should look so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying touches on the screen](img/B01620_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying touches on the screen
  prefs: []
  type: TYPE_NORMAL
- en: 'The full source code up to this point, which was used to produce the preceding
    demonstration, reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This excludes the nonessential mouse cursor part for the sake of keeping the
    example code short and sweet. The accompanying Kivy language file, `paint.kv`,
    is missing altogether at this point—instead, the `build()` method of the app class
    returns the root widget.
  prefs: []
  type: TYPE_NORMAL
- en: Observe the unusual placement of the `import Window` line. This is due to the
    side effects of this specific module, already mentioned earlier. `Config.set()`
    calls should precede this `import` statement to have any effect.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to add more features to our little program, bringing it in
    line with the desired Paint app behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, the only way to clear the screen in our little app is to restart
    it. Let's add a button for deleting everything from the canvas to our UI, which
    is very minimalistic at the moment. We'll reuse the button look from the previous
    app, so there will be nothing new about theming; the interesting part here is
    positioning.
  prefs: []
  type: TYPE_NORMAL
- en: In our first program, the Clock app from [Chapter 1](ch01.html "Chapter 1. Building
    a Clock App"), *Building a Clock App*, we didn't work on any explicit positioning
    at all, as everything was being held in place by nested `BoxLayouts`. Now, however,
    we don't have any layout to our program as the root widget is our very own `CanvasWidget`,
    and we didn't implement any logic to position its children.
  prefs: []
  type: TYPE_NORMAL
- en: In Kivy, the absence of an explicit layout means that every widget has full
    control over its placement and size (this is pretty much the default state of
    affairs in many other UI toolkits, such as Delphi, Visual Basic, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'To position the newly created delete button in the top-right corner, we do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a property binding that says the button's `right` and `top` properties
    should be kept in sync with the root widget's properties accordingly. We could
    also do the math here, for example, `root.top – 20`. The rest is pretty straightforward,
    as `width` and `height` are absolute values.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we've defined a class rule for `<CanvasWidget>` without specifying
    its superclass. This works because this time we are extending the existing class
    with the same name, defined earlier in Python code. Kivy allows us to augment
    all the existing widget classes, both built-ins, such as `<Button>` and `<Label>`,
    and custom ones.
  prefs: []
  type: TYPE_NORMAL
- en: This illustrates a common good practice to describe visual attributes of objects
    using the Kivy language. At the same time, it's better to keep all program flow
    constructs, such as event handlers, on the Python side of things. Such separation
    of concerns makes both the Python source code and its corresponding Kivy language
    counterpart more readable and easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Passing events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have kept up with this tutorial and already tried clicking the button,
    you may have noticed (or even guessed) that it doesn't work. The fact that it
    doesn't do anything useful is obviously due to the missing click handler that
    we're going to implement shortly. What's more interesting is that the click just
    doesn't get through, as there is no visual feedback; instead, the usual semi-transparent
    circle gets painted on top of the button, and that's it.
  prefs: []
  type: TYPE_NORMAL
- en: This strange effect happens because we're processing all the touches in the
    `CanvasWidget.on_touch_down` handler and don't pass them to the children, so they
    cannot react. Unlike HTML's **Document Object Model** (**DOM**), events in Kivy
    don't bubble up from the nested element up to its parent. They go the other way
    around, from the parent down to the children, that is, if the parent widget would
    pass them, which it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'This could be fixed by explicitly doing something along the lines of the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In reality, that''s pretty much what the default behavior (`Widget.on_touch_down`)
    already does, so we may as well call it and make the code much more concise, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The default `on_touch_down` handler also returns `True` if the event was actually
    processed in a meaningful way. Touching a button will return `True` since the
    button reacts to it, and at the very least, changes its appearance. That's just
    what we need in order to cancel our own event processing, which amounts to drawing
    circles at this time, hence the `return` statement on the second line of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we move on to the easiest and also the most useful part of the **Delete**
    button—a touch handler that erases everything. Clearing the canvas is quite simple,
    so everything we need to do in order to get this function to work is here. Yup,
    just two lines of code grand total:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to add this method as an event handler to the `paint.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It works, except that it also removes the **Delete** button itself! This happens
    because the button is a child of `CanvasWidget` (naturally, since `CanvasWidget`
    is a root widget, everything is its direct or indirect child). And while the button
    widget itself isn't deleted (and clicking it still clears the screen), its canvas
    (`Button.canvas`) gets removed from the `CanvasWidget.canvas.children` hierarchy
    and is thus no longer rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very straightforward way of fixing it is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this isn''t nice because widgets may do their own initialization and
    arrange things differently. A better way to solve this issue is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove all the children from the "offending" widget (`CanvasWidget`, in this
    case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, re-add child widgets back so that they can initialize their rendering
    properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The revised version of the code is a bit longer but works properly and is more
    bulletproof:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: One line that may need explanation is the `saved = self.children[:]`expression.
    The `[:]` operation is an array copy (literally, "create a new array with these
    same elements"). If we write `saved = self.children` instead, this means we're
    copying a pointer to an array; later, when we call `self.clear_widgets()`, it
    will remove everything from both `self.children` and `saved` since they're referring
    to the same object in the memory. This is why `self.children[:]` is required.
    (The behavior we just discussed is how Python works and is not related to Kivy.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're not familiar with the slicing syntax in Python, please see the StackOverflow
    thread at [http://stackoverflow.com/questions/509211](http://stackoverflow.com/questions/509211)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we can already kind of paint things with blue bubbles, as depicted
    in the following screenshot. This is clearly not the final behavior of our Paint
    app, so please read on to the next section in which we will make it draw actual
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: '![Clearing the canvas](img/B01620_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Delete button in all its dreadful glory. Also, painting with a circle "brush"
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the dots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our app already has a clear screen function but still draws just circles. Let's
    change it so that we can draw lines instead.
  prefs: []
  type: TYPE_NORMAL
- en: To follow continuous touch events (click-and-drag), we'll need to add a new
    event listener, `on_touch_move`. Every time the callback is invoked, it receives
    the latest point where the event occurred.
  prefs: []
  type: TYPE_NORMAL
- en: If we only had a single line going at every moment (like typically done on a
    desktop, since there is only one mouse pointer anyway), we could save the line
    we're currently drawing in `self.current_line`. But since we're aiming at multitouch
    support from the very beginning, we'll take another approach and store every line
    being drawn in the corresponding `touch` variable itself.
  prefs: []
  type: TYPE_NORMAL
- en: This works because for every continuous touch from start to end, all callbacks
    receive the same `touch` object. There is also a `touch.ud` property of the type
    `dict` (where `ud` is short for user data), which is specifically tailored to
    keep touch-specific attributes between event handler invocations. Initially, the
    `touch.ud` property is an empty Python dictionary, `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re going to do next is:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `on_touch_down` handler, create a new line and store it in the `touch.ud`
    dictionary. This time, we will use regular straight lines instead of the fancy
    circular lines we employed earlier to illustrate where individual touches would
    land.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `on_touch_move`, append a new point to the end of the corresponding line.
    We are adding a straight line segment, but since the event handler is going to
    be invoked many times per second, the end result will consist of a series of very
    short segments and will look rather smooth nevertheless.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More advanced graphical programs are using sophisticated algorithms to make
    lines appear as if they were drawn on a real physical surface. This includes using
    Bezier curves to make lines seamless even at high resolution and extrapolating
    line thickness from the pointer movement's speed or pressure. We aren't going
    to implement these here as they bear no relation to Kivy, but adding these techniques
    to the resulting Paint app may constitute a nice exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code, as we just described, is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This simple approach works, and we're able to draw boring blue lines on our
    canvas. Now let's give our users the ability to select color, then we'll be one
    step closer to a painting app that's actually somewhat useful.
  prefs: []
  type: TYPE_NORMAL
- en: The color palette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every painting program comes with a palette to choose colors from, and ours
    will be no exception by the time we reach the end of this section, real soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, a palette is just a list of available colors, presented in a
    way that makes choosing the right color easy. In a full-fledged image editor,
    it usually includes every color available on the system (commonly a full 24-bit
    true color or the 16,777,216 unique colors). The customary representation of this
    all-encompassing palette typically looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The color palette](img/B01620_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Illustration of a true color palette window
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we aren't going to compete with popular proprietary image
    editing applications, we might as well ship a limited selection of colors. For
    a person with little to no background in graphics, this may even pose a competitive
    advantage—choosing fitting colors that look good together is hard. For this exact
    reason, there are palettes on the Internet that may be universally used for UI
    and graphic design.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, we are going to make use of the Flat UI style guide (available
    at [http://designmodo.github.io/Flat-UI/](http://designmodo.github.io/Flat-UI/)),
    which is based on a list of carefully chosen colors that work great together.
    Alternatively, feel free to choose any other palette you like, which is purely
    an aesthetic preference.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is much to learn in the area of colors, especially color compatibility
    and suitability for specific tasks. Low-contrast combinations may work great for
    decorative elements or big headlines, but they fall short for the main article's
    text; however, counterintuitively, very high contrast, like white on black, is
    not easy on the eyes and quickly strains them.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a good rule of thumb regarding colors is that unless you are absolutely
    confident in your artistic skills, preferably stick to well-established palettes
    that are successfully used by others. A great place to start is your favorite
    operating system''s or desktop environment''s guidelines. The following are some
    of the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Tango palette, which is widely used in open source environments such as desktop
    Linux, can be found at [http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines](http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Material design principles, presented at the Google I/O conference in
    2014, is available at [https://www.google.com/design/material-design.pdf](https://www.google.com/design/material-design.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unofficial iOS 7 color swatches can be found at [http://ios7colors.com/](http://ios7colors.com/)
    (many people, including me, find these a bit exaggerated and too vibrant, thus
    best suited for games and maybe advertising, as opposed to a UI for daily use).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more color palettes for various tasks readily available—check
    Google if interested, or use a color picker on your favorite OS and programs.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing the buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we''re going for a rather short fixed list of colors, the UI controls
    that are best suited to represent such a list are likely toggle or radio buttons.
    Kivy''s `ToggleButton` would be perfectly suitable for this task, but it has an
    unfortunate limitation: in a toggle group, all buttons may be deselected at once.
    This would mean that, in the context of the Paint app, there is no color selected.
    (One possible option in this case is to fall back to a default color, but this
    may be surprising to the user so we won''t take this approach.)'
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that with Python's **OOP** (**object-oriented programming**)
    capabilities, we can easily subclass `ToggleButton` and alter its behavior to
    do what we need, that is, to forbid the deselection of the currently selected
    button. After this tweak, exactly one color will be selected at all times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subclassing will also achieve another goal in this case: for a palette, we
    want to paint every button in its distinctive color. While we could certainly
    employ the previously used technique of assigning background images to buttons,
    this would require us to produce a whole lot of different background images. Instead,
    we are going to use the background color property, which can be assigned from
    the `paint.kv` file.'
  prefs: []
  type: TYPE_NORMAL
- en: This architecture allows us to keep the definition of the palette itself in
    a very readable declarative form inside `paint.kv`, while the implementation details
    stay out of our way in a subclass—exactly how an OOP program should be.
  prefs: []
  type: TYPE_NORMAL
- en: Taking away the ability to deselect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's make toggle buttons that cannot all be deselected simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the problem (and also create the bare-bones implementation that
    will serve as a starting point), let''s implement the desired UI using standard
    Kivy''s `ToggleButton` widgets. This part is purely declarative; let''s just add
    the following code to `paint.kv` to the bottom of the `<CanvasWidget>` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We use the familiar `BoxLayout` component here, acting as a toolbar for individual
    color buttons. The layout widget itself is positioned absolutely, with `x` and
    `y` both set to `0` (that is, the bottom-left corner), taking the full width of
    `CanvasWidget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `ToggleButton` belongs to the same group, `''color''`, so that at most
    only one of these can be selected (`state: ''down''`) at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the standard behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, the built-in `ToggleButton` behavior isn't exactly
    the radio button that we need; if you click on the selected button, it will be
    deselected, leaving the whole toggle group without a selected element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix it, let''s subclass `ToggleButton` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We allow the button to toggle like it normally would only if it wasn't
    already selected (its `state` is `'normal'`, as opposed to `'down'`).
  prefs: []
  type: TYPE_NORMAL
- en: Now all that's left is to replace every instance of `ToggleButton` in the `paint.kv`
    file with `RadioButton`, the name of our custom class, and instantly see the difference
    in the behavior of buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a major selling point of the Kivy framework: in only a few lines, you
    can override the built-in functions and methods, achieving practically unmatched
    flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To become usable in Kivy language, the `RadioButton` definition should reside
    in the `main.py` module or be imported into its scope. Since we have just one
    Python file now, that''s a non-issue, but as your application grows, do keep this
    in mind: custom Kivy widgets, like other Python classes or functions, have to
    be imported prior to their first use.'
  prefs: []
  type: TYPE_NORMAL
- en: Coloring buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our buttons behave properly, the next step is coloring. What we''re
    aiming for will look like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coloring buttons](img/B01620_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Paint app's color palette, vibrant and inviting
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we are going to use the `background_color` property. The background
    color in Kivy acts as a tint and not just a solid color; we need to prepare a
    pure white background image first, which, when tinted, will give us the color
    we want. This way, we only need to prepare two button textures (normal and pressed
    state) for any number of arbitrary colored buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The images we use here aren''t very different from those we prepared previously
    for the Clock app in [Chapter 1](ch01.html "Chapter 1. Building a Clock App"),
    *Building a Clock App*, except that now the main area of a button is white to
    allow coloring, and the selected state features a black border:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coloring buttons](img/B01620_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The color button's texture, where the white area will be tinted using the background
    color property
  prefs: []
  type: TYPE_NORMAL
- en: A new kind of button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This time, we can do most of the work, including creating a new button class,
    in the `paint.kv` file. The new class will be called `ColorButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''ve moved the `group` property here to avoid cluttering
    the palette definition with repetitive `group: ''color''` lines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also assigning an event handler, `on_release`, that will be called when
    a `ColorButton` is pressed. Every button passes its `background_color` property
    to the event handler, so all that''s left to do is assign this color to the canvas.
    This event will be handled by `CanvasWidget`, which needs to be exposed from the
    `PaintApp` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this arrangement is that we cannot use the `root` shortcut in
    the preceding `paint.kv` class definition; it will point at the `ColorButton`
    itself (the root definition inside the class rule is indeed the class rule itself
    because it's defined at the top level in `paint.kv`). We can also set the default
    color here, as shown in the code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re in the `main.py` module, let''s also implement the `set_color()`
    method on `CanvasWidget`, which will serve as an event handler for `ColorButton`
    clicks. The method in question is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Just set the color that was passed as an argument. That's it!
  prefs: []
  type: TYPE_NORMAL
- en: Defining the palette
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here comes the creative part: defining the actual palette. With all the groundwork
    in place, let''s remove the old `RadioButton` definitions from `paint.kv` and
    start anew.'
  prefs: []
  type: TYPE_NORMAL
- en: To use the familiar CSS notation for colors, we'll need to import the appropriate
    function into the `paint.kv` file. Yes, it can import functions, just like a regular
    Python module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this line to the beginning of `paint.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the same as the following code in Python (with shorter alias
    for brevity, since we''re going to use it a lot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, we will use Flat UI colors for this example, but feel
    free to choose whatever palette you like. The definition itself looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This notation is as clear as it can possibly get. There is just one property
    to define for every `ColorButton` widget, namely its `background_color` property.
    Everything else is inherited from the class definition, including the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this architecture is that now we can add any number of such buttons,
    and they will align and perform correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the line thickness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last and easiest feature that we are going to implement is a simple line
    thickness selector. As you can see in the following screenshot, we're reusing
    assets and styles from the previous part, the color palette.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the line thickness](img/B01620_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Line width selector
  prefs: []
  type: TYPE_NORMAL
- en: 'This UI uses yet another `RadioButton` subclass, unimaginatively named `LineWidthButton`.
    Append the following declaration to the `paint.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Key differences from `ColorButton` are highlighted in the preceding code. These
    new buttons belong to another radio group and fire another event handler when
    interacted with. Other than this, they are very similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout is equally simple, built in the same fashion as that of the color
    palette, except that it''s vertical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that our new event listener `CanvasWidget.set_line_width` will accept the
    `text` property of a pressed button. It is implemented like this for simplicity,
    as this allows us to define just one distinct property per widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real-world scenario, this approach isn''t strictly forbidden or particularly
    unheard of but, still a bit questionable: what happens with these text labels
    when we decide to translate our application to Chinese or Hebrew?'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the line width
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With every part of the user interface in place, we can finally attach the event
    listener that''s going to apply the selected line thickness to the painting. We
    will store the numeric value of the line width in `CanvasWidget.line_width`, based
    on the button''s text mapping that''s provided inline, and use it in the `on_touch_down`
    handler when beginning a new line. Long story short, these are relevant parts
    of the revised `CanvasWidget` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the Kivy Paint app tutorial. If you start the program now, you
    can probably paint something beautiful. (I cannot, as you have probably noticed
    from the illustrations.)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we highlighted a number of common practices for the development
    of Kivy-based apps, such as customization of the main window, changing the mouse
    cursor, window size, and background color, the use of canvas instructions to draw
    free-form graphics programmatically, and handling touch events correctly across
    all supported platforms, with regards to multitouch.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing about Kivy that should be evident after building the Paint app is
    how open ended and versatile the framework is. Instead of providing a large number
    of rigid components, Kivy capitalizes on composability of simple building blocks:
    graphical primitives and behaviors. This means that while there are not many useful
    ready-made widgets bundled with Kivy, you can hack together anything you need
    in a few lines of highly readable Pythonic code.'
  prefs: []
  type: TYPE_NORMAL
- en: The modular API design pays off nicely, thanks to its practically limitless
    flexibility. The end result meets your application's unique requirements perfectly.
    The customer wants something sensational, such as a triangular button—sure, you
    can also have a texture on it, all in a whopping three lines of code or so. (By
    comparison, try making a triangular button using **WinAPI**. That's like staring
    into the abyss, only less productive.)
  prefs: []
  type: TYPE_NORMAL
- en: These custom Kivy components also usually end up being reusable. In fact, you
    could easily import `CanvasWidget` from the `main.py` module and use it in another
    application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Natural user interface**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also worth mentioning that our second app is way more interactive than
    the first one: it responds not just to button clicks, but to arbitrary multitouch
    gestures as well.'
  prefs: []
  type: TYPE_NORMAL
- en: All the available window surface reacts to touch, and as soon as it becomes
    evident to the end user, there is no cognitive overhead to painting, especially
    on a touch screen device. You just paint on a screen with your fingers, like it
    was a physical surface, and your fingers were sufficiently dirty to leave marks
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of interface, or lack thereof, is called **NUI** (**natural user
    interface**). It has an interesting characteristic: a NUI application can be used
    by small kids and even pets—those capable of seeing and touching graphical objects
    on screen. This is literally a natural, intuitive interface, a "no-brainer" kind
    of thing, as opposed to the interface of, for example, Norton Commander, which
    was called intuitive back in the days. Let''s face it: that was a lie. Intuition
    is not applicable to blue-screen, two-panel ASCII art programs in any practical
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build yet another Kivy-based program, this time
    limited to Android devices. It will exemplify the interoperability between Python
    code and Java classes that comprise the Android API.
  prefs: []
  type: TYPE_NORMAL
