<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Developing RESTful APIs with Django</h1></div></div></div><p>In this chapter, we will start our journey towards RESTful Web APIs with Python and four different Web frameworks. Python is one of the most popular and versatile programming languages. There are thousands of Python packages, which allow you to extend Python capabilities to any kind of domain you can imagine. We can work with many different Web frameworks and packages to easily build simple and complex RESTful Web APIs with Python, and we can also combine these frameworks with other Python packages.</p><p>We can leverage our existing knowledge of Python and its packages to code the different pieces of our RESTful Web APIs and their ecosystem. We can use the object-oriented features to create code that is easier to maintain, understand, and reuse. We can use all the packages that we already know to interact with databases, Web services, and different APIs. Python makes it easy for us to create RESTful Web APIs. We don't need to learn another programming language; we can use the one we already know and love.</p><p>In this chapter, we will start working with Django and Django REST Framework, and we will create a RESTful Web API that performs <strong>CRUD</strong> (<strong>Create, Read, Update, and Delete</strong>) operations on a simple SQLite database. We will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Design a RESTful API to interact with a simple SQLite database</li><li class="listitem" style="list-style-type: disc">Understand the tasks performed by each HTTP method</li><li class="listitem" style="list-style-type: disc">Set up the virtual environment with Django REST framework</li><li class="listitem" style="list-style-type: disc">Create the database models</li><li class="listitem" style="list-style-type: disc">Manage serialization and deserialization of data</li><li class="listitem" style="list-style-type: disc">Write API views</li><li class="listitem" style="list-style-type: disc">Make HTTP requests to the API with command-line tools</li><li class="listitem" style="list-style-type: disc">Work with GUI tools to compose and send HTTP requests</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec7"/>Designing a RESTful API to interact with a simple SQLite database</h1></div></div></div><p>Imagine that we have to start working on a mobile App that has to interact with a RESTful API to perform CRUD operations with games. We don't want to spend time choosing and configuring the most appropriate <strong>ORM</strong> ( <strong>Object-Relational Mapping</strong>); we just want to finish the RESTful API as soon as possible to start interacting with it via our mobile App. We really want the games to persist in a database but we don't need it to be production-ready, and therefore, we can use the simplest possible relational database, as long as we don't have to spend time making complex installations or configurations.</p><p>Django REST framework, also known as DRF, will allow us to easily accomplish this task and start making HTTP requests to our first version of our RESTful Web Service. In this case, we will work with a very simple SQLite database, the default database for a new Django REST framework project.</p><p>First, we must specify the requirements for our main resource: a game. We need the following attributes or fields for a game:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An integer identifier</li><li class="listitem" style="list-style-type: disc">A name or title</li><li class="listitem" style="list-style-type: disc">A release date</li><li class="listitem" style="list-style-type: disc">A game category description, such as <em>3D RPG</em> and <em>2D mobile arcade</em>.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">bool</code> value indicating whether the game was played at least once by a player or not</li></ul></div><p>In addition, we want our database to save a timestamp with the date and time in which the game was inserted in the database.</p><p>The following table shows the HTTP verbs, the scope, and the semantics for the methods that our first version of the API must support. Each method is composed by an HTTP verb and a scope and all the methods have a well defined meaning for all games and collections.</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>HTTP verb</strong></p></td><td>
<p>
<strong>Scope</strong></p></td><td>
<p>
<strong>Semantics</strong></p></td></tr><tr><td>
<p>
<code class="literal">GET</code></p></td><td>
<p>Collection of games</p></td><td>
<p>Retrieve all the stored games in the collection, sorted by their name in ascending order</p></td></tr><tr><td>
<p>
<code class="literal">GET</code></p></td><td>
<p>Game</p></td><td>
<p>Retrieve a single game</p></td></tr><tr><td>
<p>
<code class="literal">POST</code></p></td><td>
<p>Collection of games</p></td><td>
<p>Create a new game in the collection</p></td></tr><tr><td>
<p>
<code class="literal">PUT</code></p></td><td>
<p>Game</p></td><td>
<p>Update an existing game</p></td></tr><tr><td>
<p>
<code class="literal">DELETE</code></p></td><td>
<p>Game</p></td><td>
<p>Delete an existing game</p></td></tr></tbody></table></div><div><div><h3 class="title"><a id="tip3"/>Tip</h3><p>In a RESTful API, each resource has its own unique URL. In our API, each game has its own unique URL.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec8"/>Understanding the tasks performed by each HTTP method</h1></div></div></div><p>In the preceding table, the <code class="literal">GET</code> HTTP verb appears twice but with two different scopes. The first row shows a <code class="literal">GET</code> HTTP verb applied to a collection of games (collection of resources) and the second row shows a <code class="literal">GET</code> HTTP verb applied to a game (a single resource).</p><p>Let's consider that <code class="literal">http://localhost:8000/games/</code> is the URL for the collection of games. If we add a number and a slash (<code class="literal">/</code>) to the preceding URL, we identify a specific game whose id or primary key is equal to the specified numeric value. For example, <code class="literal">http://localhost:8000/games/12/</code> identifies the game whose id or primary key is equal to <code class="literal">12</code>.</p><p>We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">POST</code>) and request URL (<code class="literal">http://localhost:8000/games/</code>) to create a new game. In addition, we have to provide the <strong>JSON</strong> (<strong>JavaScript Object Notation</strong>) key-value pairs with the field names and the values to create the new game. As a result of the request, the server will validate the provided values for the fields, make sure that it is a valid game and persist it in the database.</p><p>The server will insert a new row with the new game in the appropriate table and it will return a <code class="literal">201 Created</code> status code and a JSON body with the recently added game serialized to JSON, including the assigned id or primary key that was automatically generated by the database and assigned to the game object.</p><pre class="programlisting">POST http://localhost:8000/games/ &#13;
</pre><p>We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">GET</code>) and request URL (<code class="literal">http://localhost:8000/games/{id}/</code>) to retrieve the game whose id or primary key matches the specified numeric value in the place where <code class="literal">{id}</code> is written.</p><p>For example, if we use the request URL <code class="literal">http://localhost:8000/games/50/</code>, the server will retrieve the game whose id or primary key matches <code class="literal">50</code>.</p><p>As a result of the request, the server will retrieve a game with the specified id or primary key from the database and create the appropriate game object in Python. If a game is found, the server will serialize the game object into JSON and return a <code class="literal">200 OK</code> status code and a JSON body with the serialized game object. If no game matches the specified id or primary key, the server will return just a <code class="literal">404 Not Found</code> status:</p><pre class="programlisting">GET http://localhost:8000/games/{id}/ &#13;
</pre><p>We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">PUT</code>) and request URL (<code class="literal">http://localhost:8000/games/{id}/</code>) to retrieve the game whose id or primary key matches the specified numeric value in the place where <code class="literal">{id}</code> is written and replace it with a game created with the provided data. In addition, we have to provide the JSON key-value pairs with the field names and the values to create the new game that will replace the existing one. As a result of the request, the server will validate the provided values for the fields, make sure that it is a valid game and replace the one that matches the specified id or primary key with the new one in the database. The id or primary key for the game will be the same after the update operation. The server will update the existing row in the appropriate table and it will return a <code class="literal">200 OK</code> status code and a JSON body with the recently updated game serialized to JSON. If we don't provide all the necessary data for the new game, the server will return a <code class="literal">400 Bad Request</code> status code. If the server doesn't find a game with the specified id, the server will return just a <code class="literal">404 Not Found</code> status.</p><pre class="programlisting">PUT http://localhost:8000/games/{id}/ &#13;
</pre><p>We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">DELETE</code>) and request URL (<code class="literal">http://localhost:8000/games/{id}/</code>) to remove the game whose id or primary key matches the specified numeric value in the place where <code class="literal">{id}</code> is written. For example, if we use the request URL <code class="literal">http://localhost:8000/games/20/</code>, the server will delete the game whose id or primary key matches <code class="literal">20</code>. As a result of the request, the server will retrieve a game with the specified id or primary key from the database and create the appropriate game object in Python. If a game is found, the server will request the ORM to delete the game row associated with this game object and the server will return a <code class="literal">204 No Content</code> status code. If no game matches the specified id or primary key, the server will return just a <code class="literal">404 Not Found</code> status.</p><pre class="programlisting">DELETE http://localhost:8000/games/{id}/ &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec9"/>Working with lightweight virtual environments</h1></div></div></div><p>Throughout this book, we will be working with different frameworks and libraries, and therefore, it is convenient to work with virtual environments. We will work with the lightweight virtual environments introduced in Python 3.3 and improved in Python 3.4. However, you can also choose to use the popular <code class="literal">virtualenv</code> (<a class="ulink" href="https://pypi.python.org/pypi/virtualenv">https://pypi.python.org/pypi/virtualenv</a>) third-party virtual environment builder or the virtual environment options provided by your Python IDE.</p><p>You just have to make sure that you activate your virtual environment with the appropriate mechanism when it is necessary to do so, instead of following the step explained to activate the virtual environment generated with the <code class="literal">venv</code> module integrated in Python. You can read more information about PEP 405 Python Virtual Environment that introduced the <code class="literal">venv</code> module at <a class="ulink" href="https://www.python.org/dev/peps/pep-0405">https://www.python.org/dev/peps/pep-0405</a>.</p><div><div><h3 class="title"><a id="tip4"/>Tip</h3><p>Each virtual environment we create with <code class="literal">venv</code> is an isolated environment and it will have its own independent set of installed Python packages in its site directories. When we create a virtual environment with <code class="literal">venv</code> in Python 3.4 and greater, pip is included in the new virtual environment. In Python 3.3, it was necessary to manually install pip after creating the virtual environment. Notice that the instructions provided are compatible with Python 3.4 or greater, including Python 3.5.x. The following commands assume that you have Python 3.5.x installed on macOS, Linux, or Windows.</p></div></div><p>First, we have to select the target folder or directory for our virtual environment. The following is the path we will use in the example for macOS and Linux. The target folder for the virtual environment will be the <code class="literal">PythonREST/Django</code> folder within our home directory. For example, if our home directory in macOS or Linux is <code class="literal">/Users/gaston</code>, the virtual environment will be created within <code class="literal">/Users/gaston/PythonREST/Django</code>. You can replace the specified path with your desired path in each command.</p><pre class="programlisting"><strong>    ~/PythonREST/Django  </strong></pre><p>The following is the path we will use in the example for Windows. The target folder for the virtual environment will be the <code class="literal">PythonREST/Django</code> folder within our user profile folder. For example, if our user profile folder is <code class="literal">C:\Users\Gaston</code>, the virtual environment will be created within <code class="literal">C:\Users\gaston\PythonREST\Django</code>. You can replace the specified path with your desired path in each command.</p><pre class="programlisting"><strong>%USERPROFILE%\PythonREST\Django</strong></pre><p>Now, we have to use the <code class="literal">-m</code> option followed by the <code class="literal">venv</code> module name and the desired path to make Python run this module as a script and create a virtual environment in the specified path. The instructions are different depending on the platform in which we are creating the virtual environment.</p><p>Open a Terminal in macOS or Linux and execute the following command to create a virtual environment:</p><pre class="programlisting"><strong>python3 -m venv ~/PythonREST/Django01</strong></pre><p>In Windows, execute the following command to create a virtual environment:</p><pre class="programlisting"><strong>python -m venv %USERPROFILE%\PythonREST\Django01</strong></pre><p>The preceding command doesn't produce any output. The script created the specified target folder and installed pip by invoking <code class="literal">ensurepip</code> because we didn't specify the <code class="literal">--without-pip</code> option. The specified target folder has a new directory tree that contains Python executable files and other files that indicate that it is a virtual environment.</p><p>The <code class="literal">pyenv.cfg</code> configuration file specifies different options for the virtual environment and its existence is an indicator that we are in the root folder for a virtual environment. In OS and Linux, the folder will have the following main sub-folders—<code class="literal">bin</code>, <code class="literal">include</code>, <code class="literal">lib</code>, <code class="literal">lib/python3.5</code> and <code class="literal">lib/python3.5/site-packages</code>. In Windows, the folder will have the following main sub-folders—<code class="literal">Include</code>, <code class="literal">Lib</code>, <code class="literal">Lib\site-packages</code>, and <code class="literal">Scripts</code>. The directory trees for the virtual environment in each platform are the same as the layout of the Python installation in these platforms. The following screenshot shows the folders and files in the directory trees generated for the <code class="literal">Django01</code> virtual environment in macOS:</p><p>
</p><div><img src="img/image_01_001.jpg" alt="Working with lightweight virtual environments"/></div><p>The following screenshot shows the main folders in the directory trees generated for the virtual environments in Windows:</p><p>
</p><div><img src="img/image_01_002.jpg" alt="Working with lightweight virtual environments"/></div><div><div><h3 class="title"><a id="tip5"/>Tip</h3><p>After we activate the virtual environment, we will install third-party packages into the virtual environment and the modules will be located within the <code class="literal">lib/python3.5/site-packages</code> or <code class="literal">Lib\site-packages</code> folder, based on the platform. The executables will be copied in the <code class="literal">bin</code> or <code class="literal">Scripts</code> folder, based on the platform. The packages we install won't make changes to other virtual environments or our base Python environment.</p></div></div><p>Now that we have created a virtual environment, we will run a platform-specific script to activate it. After we activate the virtual environment, we will install packages that will only be available in this virtual environment.</p><p>Run the following command in the terminal in macOS or Linux. Note that the results of this command will be accurate if you don't start a different shell than the default shell in the terminal session. In case you have doubts, check your terminal configuration and preferences.</p><pre class="programlisting"><strong>echo $SHELL</strong></pre><p>The command will display the name of the shell you are using in the Terminal. In macOS, the default is <code class="literal">/bin/bash</code> and this means you are working with the bash shell. Depending on the shell, you must run a different command to activate the virtual environment in OS or Linux.</p><p>If your Terminal is configured to use the <code class="literal">bash</code> shell in macOS or Linux, run the following command to activate the virtual environment. The command also works for the <code class="literal">zsh</code> shell:</p><pre class="programlisting"><strong>source ~/PythonREST/Django01/bin/activate</strong></pre><p>If your Terminal is configured to use either the <code class="literal">csh</code> or <code class="literal">tcsh</code> shell, run the following command to activate the virtual environment:</p><pre class="programlisting"><strong>source ~/PythonREST/Django01/bin/activate.csh</strong></pre><p>If your Terminal is configured to use either the <code class="literal">fish</code> shell, run the following command to activate the virtual environment:</p><pre class="programlisting"><strong>source ~/PythonREST/Django01/bin/activate.fish</strong></pre><p>In Windows, you can run either a batch file in the command prompt or a Windows PowerShell script to activate the virtual environment. If you prefer the command prompt, run the following command in the Windows command line to activate the virtual environment:</p><pre class="programlisting"><strong>%USERPROFILE%\PythonREST\Django01\Scripts\activate.bat</strong></pre><p>If you prefer the Windows PowerShell, launch it and run the following commands to activate the virtual environment. However, notice that you should have scripts execution enabled in Windows PowerShell to be able to run the script:</p><pre class="programlisting"><strong>cd $env:USERPROFILE</strong>
<strong>PythonREST\Django01\Scripts\Activate.ps1</strong></pre><p>After you activate the virtual environment, the command prompt will display the virtual environment root folder name enclosed in parenthesis as a prefix of the default prompt to remind us that we are working in the virtual environment. In this case, we will see (<code class="literal">Django01</code>) as a prefix for the command prompt because the root folder for the activated virtual environment is <code class="literal">Django01</code>.</p><p>The following screenshot shows the virtual environment activated in a macOS El Capitan terminal with a <code class="literal">bash</code> shell, after executing the previously shown commands:</p><p>
</p><div><img src="img/image_01_003.jpg" alt="Working with lightweight virtual environments"/></div><p>As we can see in the preceding screenshot, the prompt changed from <code class="literal">Gastons-MacBook-Pro:~ gaston$</code> to <code class="literal">(Django01) Gastons-MacBook-Pro:~ gaston$</code> after the activation of the virtual environment.</p><p>The following screenshot shows the virtual environment activated in a Windows 10 Command Prompt, after executing the previously shown commands:</p><p>
</p><div><img src="img/image_01_004.jpg" alt="Working with lightweight virtual environments"/></div><p>As we can notice from the preceding screenshot, the prompt changed from <code class="literal">C:\Users\gaston\AppData\Local\Programs\Python\Python35</code> to <code class="literal">(Django01) C:\Users\gaston\AppData\Local\Programs\Python\Python35</code> after the activation of the virtual environment.</p><div><div><h3 class="title"><a id="tip6"/>Tip</h3><p>It is extremely easy to deactivate a virtual environment generated with the previously explained process. In macOS or Linux, just type <code class="literal">deactivate</code> and press Enter. In a Windows command prompt, you have to run the <code class="literal">deactivate.bat</code> batch file included in the Scripts folder <code class="literal">(%USERPROFILE%\PythonREST\Django01\Scripts\deactivate.bat</code> in our example). In Windows PowerShell, you have to run the <code class="literal">Deactivate.ps1</code> script in the <code class="literal">Scripts</code> folder. The deactivation will remove all the changes made in the environment variables.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Setting up the virtual environment with Django REST framework</h1></div></div></div><p>We have created and activated a virtual environment. It is time to run many commands that will be the same for either macOS, Linux or Windows. Now, we must run the following command to install the Django Web framework:</p><pre class="programlisting"><strong>pip install django</strong></pre><p>The last lines of the output will indicate that the <code class="literal">django</code> package has been successfully installed. Take into account that you may also see a notice to upgrade <code class="literal">pip</code>.</p><pre class="programlisting"><strong>Collecting django</strong>
<strong>Installing collected packages: django</strong>
<strong>Successfully installed django-1.10</strong></pre><p>Now that we have installed Django Web framework, we can install Django REST framework. We just need to run the following command to install this package:</p><pre class="programlisting"><strong>pip install djangorestframework</strong></pre><p>The last lines for the output will indicate that the <code class="literal">djangorestframework</code> package has been successfully installed:</p><pre class="programlisting"><strong>Collecting djangorestframework</strong>
<strong>Installing collected packages: djangorestframework</strong>
<strong>Successfully installed djangorestframework-3.3.3</strong></pre><p>Go to the root folder for the virtual environment-<code class="literal">Django01</code>. In macOS or Linux, enter the following command:</p><pre class="programlisting"><strong>cd ~/PythonREST/Django01</strong></pre><p>In Windows, enter the following command:</p><pre class="programlisting"><strong>cd /d %USERPROFILE%\PythonREST\Django01</strong></pre><p>Run the following command to create a new Django project named <code class="literal">gamesapi</code>. The command won't produce any output:</p><pre class="programlisting"><strong>django-admin.py startproject gamesapi</strong></pre><p>The previous command created a <code class="literal">gamesapi</code> folder with other sub-folders and Python files. Now, go to the recently created <code class="literal">gamesapi</code> folder. Just execute the following command:</p><pre class="programlisting"><strong>cd gamesapi</strong></pre><p>Then, run the following command to create a new Django app named <code class="literal">games</code> within the <code class="literal">gamesapi</code> Django project. The command won't produce any output:</p><pre class="programlisting"><strong>python manage.py startapp games</strong></pre><p>The previous command created a new <code class="literal">gamesapi/games</code> sub-folder, with the following files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">__init__.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">admin.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">apps.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">models.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">tests.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">views.py</code></li></ul></div><p>In addition, the <code class="literal">gamesapi/games</code> folder will have a <code class="literal">migrations</code> sub-folder with an <code class="literal">__init__.py</code> Python script. The following diagram shows the folders and files in the directory trees starting at the <code class="literal">gamesapi</code> folder:</p><p>
</p><div><img src="img/image_01_005.jpg" alt="Setting up the virtual environment with Django REST framework"/></div><p>Let's check the Python code in the <code class="literal">apps.py</code> file within the <code class="literal">gamesapi/games</code> folder. The following lines shows the code for this file:</p><pre class="programlisting">from django.apps import AppConfig &#13;
 &#13;
 &#13;
class GamesConfig(AppConfig): &#13;
    name = 'games' &#13;
</pre><p>The code declares the <code class="literal">GamesConfig</code> class as a subclass of the <code class="literal">django.apps.AppConfig</code> class that represents a Django application and its configuration. The <code class="literal">GamesConfig</code> class just defines the <code class="literal">name</code> class attribute and sets its value to <code class="literal">'games'</code>. We have to add <code class="literal">games.apps.GamesConfig</code> as one of the installed apps in the <code class="literal">gamesapi/settings.py</code> file that configures settings for the <code class="literal">gamesapi</code> Django project. We built the preceding string as follows-app name + <code class="literal">.apps.</code> + class name, which is, <code class="literal">games</code> + <code class="literal">.apps.</code> + <code class="literal">GamesConfig</code>. In addition, we have to add the <code class="literal">rest_framework</code> app to make it possible for us to use Django REST Framework.</p><p>The <code class="literal">gamesapi/settings.py</code> file is a Python module with module-level variables that define the configuration of Django for the <code class="literal">gamesapi</code> project. We will make some changes to this Django settings file. Open the <code class="literal">gamesapi/settings.py</code> file and locate the following lines that specify the strings list that declares the installed apps:</p><pre class="programlisting">INSTALLED_APPS = [ &#13;
    'django.contrib.admin', &#13;
    'django.contrib.auth', &#13;
    'django.contrib.contenttypes', &#13;
    'django.contrib.sessions', &#13;
    'django.contrib.messages', &#13;
    'django.contrib.staticfiles', &#13;
] &#13;
</pre><p>Add the following two strings to the <code class="literal">INSTALLED_APPS</code> strings list and save the changes to the <code class="literal">gamesapi/settings.py</code> file:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">'rest_framework'</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">'games.apps.GamesConfig'</code></li></ul></div><p>The following lines show the new code that declares the <code class="literal">INSTALLED_APPS</code> strings list with the added lines highlighted. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder:</p><pre class="programlisting">INSTALLED_APPS = [ &#13;
    'django.contrib.admin', &#13;
    'django.contrib.auth', &#13;
    'django.contrib.contenttypes', &#13;
    'django.contrib.sessions', &#13;
    'django.contrib.messages', &#13;
    'django.contrib.staticfiles', &#13;
   <strong> # Django REST Framework &#13;
    'rest_framework', &#13;
    # Games application &#13;
    'games.apps.GamesConfig',</strong> &#13;
] &#13;
</pre><p>This way, we have added Django REST Framework and the <code class="literal">games</code> application to our initial Django project named <code class="literal">gamesapi</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Creating the models</h1></div></div></div><p>Now, we will create a simple <code class="literal">Game</code> model that we will use to represent and persist games. Open the <code class="literal">games/models.py</code> file. The following lines show the initial code for this file, with just one import statement and a comment that indicates we should create the models:</p><pre class="programlisting">from django.db import models &#13;
 &#13;
# Create your models here. &#13;
</pre><p>The following lines show the new code that creates a <code class="literal">Game</code> class, specifically, a <code class="literal">Game</code> model in the <code class="literal">games/models.py</code> file. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder:</p><pre class="programlisting">from django.db import models &#13;
 &#13;
 &#13;
class Game(models.Model): &#13;
    created = models.DateTimeField(auto_now_add=True) &#13;
    name = models.CharField(max_length=200, blank=True, default='') &#13;
    release_date = models.DateTimeField() &#13;
    game_category = models.CharField(max_length=200, blank=True, default='') &#13;
    played = models.BooleanField(default=False) &#13;
 &#13;
    class Meta: &#13;
        ordering = ('name',) &#13;
</pre><p>The <code class="literal">Game</code> class is a subclass of the <code class="literal">django.db.models.Model</code> class. Each defined attribute represents a database column or field. Django automatically adds an auto-increment integer primary key column named <code class="literal">id</code> when it creates the database table related to the model. However, the model maps the underlying <code class="literal">id</code> column in an attribute named <code class="literal">pk</code> for the model. We specified the field types, maximum lengths and defaults for many attributes. The class declares a Meta inner class that declares a ordering attribute and sets its value to a tuple of string whose first value is the <code class="literal">'name'</code> string, indicating that, by default, we want the results ordered by the <code class="literal">name</code> attribute in ascending order.</p><p>Then, it is necessary to create the initial migration for the new <code class="literal">Game</code> model we recently coded. We just need to run the following Python scripts and we will also synchronize the database for the first time. By default, Django uses an SQLite database. In this example, we will be working with this default configuration:</p><pre class="programlisting"><strong>python manage.py makemigrations games</strong></pre><p>The following lines show the output generated after running the preceding command.</p><pre class="programlisting"><strong>Migrations for 'games':</strong>
<strong>  0001_initial.py:</strong>
<strong>    - Create model Game</strong></pre><p>The output indicates that the <code class="literal">gamesapi/games/migrations/0001_initial.py</code> file includes the code to create the <code class="literal">Game</code> model. The following lines show the code for this file that was automatically generated by Django. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder:</p><pre class="programlisting"># -*- coding: utf-8 -*- &#13;
# Generated by Django 1.9.6 on 2016-05-17 21:19 &#13;
from __future__ import unicode_literals &#13;
 &#13;
from django.db import migrations, models &#13;
 &#13;
 &#13;
class Migration(migrations.Migration): &#13;
 &#13;
    initial = True &#13;
 &#13;
    dependencies = [ &#13;
    ] &#13;
 &#13;
    operations = [ &#13;
        migrations.CreateModel( &#13;
            name='Game', &#13;
            fields=[ &#13;
                ('id', models.AutoField(auto_created=True, primary_key=True,&#13;
                serialize=False, verbose_name='ID')), &#13;
                ('created', models.DateTimeField(auto_now_add=True)), &#13;
                ('name', models.CharField(blank=True, default='',&#13;
                 max_length=200)), &#13;
                ('release_date', models.DateTimeField()), &#13;
                ('game_category', models.CharField(blank=True, default='',&#13;
                 max_length=200)), &#13;
                ('played', models.BooleanField(default=False)), &#13;
            ], &#13;
            options={ &#13;
                'ordering': ('name',), &#13;
            }, &#13;
        ), &#13;
    ] &#13;
</pre><p>The code defines a subclass of the <code class="literal">django.db.migrations.Migration</code> class named <code class="literal">Migration</code> that defines an operation that creates the <code class="literal">Game</code> model's table. Now, run the following python script to apply all the generated migrations:</p><pre class="programlisting"><strong>python manage.py migrate</strong></pre><p>The following lines show the output generated after running the preceding command:</p><pre class="programlisting"><strong>Operations to perform:</strong>
<strong>  Apply all migrations: sessions, games, contenttypes, admin, auth</strong>
<strong>Running migrations:</strong>
<strong>  Rendering model states... DONE</strong>
<strong>  Applying contenttypes.0001_initial... OK</strong>
<strong>  Applying auth.0001_initial... OK</strong>
<strong>  Applying admin.0001_initial... OK</strong>
<strong>  Applying admin.0002_logentry_remove_auto_add... OK</strong>
<strong>  Applying contenttypes.0002_remove_content_type_name... OK</strong>
<strong>  Applying auth.0002_alter_permission_name_max_length... OK</strong>
<strong>  Applying auth.0003_alter_user_email_max_length... OK</strong>
<strong>  Applying auth.0004_alter_user_username_opts... OK</strong>
<strong>  Applying auth.0005_alter_user_last_login_null... OK</strong>
<strong>  Applying auth.0006_require_contenttypes_0002... OK</strong>
<strong>  Applying auth.0007_alter_validators_add_error_messages... OK</strong>
<strong>  Applying games.0001_initial... OK</strong>
<strong>  Applying sessions.0001_initial... OK</strong></pre><p>After we run the preceding command, we will notice that the root folder for our <code class="literal">gamesapi</code> project now has a <code class="literal">db.sqlite3</code> file. We can use the SQLite command line or any other application that allows us to easily check the contents of the SQLite database to check the tables that Django generated.</p><p>In macOS and most modern Linux distributions, SQLite is already installed, and therefore, you can run the <code class="literal">sqlite3</code> command-line utility. However, in Windows, if you want to work with the <code class="literal">sqlite3.exe</code> command-line utility, you will have to download and install SQLite from its Web page-<a class="ulink" href="http://www.sqlite.org">http://www.sqlite.org</a>.</p><p>Run the following command to list the generated tables:</p><pre class="programlisting"><strong>sqlite3 db.sqlite3 '.tables'</strong></pre><p>Run the following command to retrieve the SQL used to create the <code class="literal">games_game</code> table:</p><pre class="programlisting"><strong>sqlite3 db.sqlite3 '.schema games_game'</strong></pre><p>The following command will allow you to check the contents of the <code class="literal">games_game</code> table after we compose and send HTTP requests to the RESTful API and make CRUD operations to the <code class="literal">games_game</code> table:</p><pre class="programlisting"><strong>sqlite3 db.sqlite3 'SELECT * FROM games_game ORDER BY name;'</strong></pre><p>Instead of working with the SQLite command-line utility, you can use a GUI tool to check the contents of the SQLite database. DB Browser for SQLite is a useful multiplatform and free GUI tool that allows us to easily check the database contents of an SQLite database in macOS, Linux and Windows. You can read more information about this tool and download its different versions from <a class="ulink" href="http://sqlitebrowser.org">http://sqlitebrowser.org</a>. Once you installed the tool, you just need to open the <code class="literal">db.sqlite3</code> file and you can check the database structure and browse the data for the different tables. You can use also the database tools included in your favorite IDE to check the contents for the SQLite database.</p><p>The SQLite database engine and the database file name are specified in the <code class="literal">gamesapi/settings.py</code> Python file. The following lines show the declaration of the <code class="literal">DATABASES</code> dictionary that contains the settings for all the database that Django uses. The nested dictionary maps the database named <code class="literal">default</code> with the <code class="literal">django.db.backends.sqlite3</code> database engine and the <code class="literal">db.sqlite3</code> database file located in the <code class="literal">BASE_DIR</code> folder (<code class="literal">gamesapi</code>):</p><pre class="programlisting">DATABASES = { &#13;
    'default': { &#13;
        'ENGINE': 'django.db.backends.sqlite3', &#13;
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#13;
    } &#13;
} &#13;
</pre><p>After we executed the migrations, the SQLite database will have the following tables:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">auth_group</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">auth_group_permissions</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">auth_permission</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">auth_user</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">auth_user_groups</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">auth_user_groups_permissions</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">django_admin_log</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">django_content_type</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">django_migrations</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">django_session</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">games_game</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite_sequence</code></li></ul></div><p>The <code class="literal">games_game</code> table persists in the database the <code class="literal">Game</code> class we recently created, specifically, the <code class="literal">Game</code> model. Django's integrated ORM generated the <code class="literal">games_game</code> table based on our <code class="literal">Game</code> model. The <code class="literal">games_game</code> table has the following rows (also known as fields) with their SQLite types and all of them are not nullable:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: The integer primary key, an <code class="literal">autoincrement</code> row</li><li class="listitem" style="list-style-type: disc"><code class="literal">created</code>: <code class="literal">datetime</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">name</code>: <code class="literal">varchar(200)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">release_date</code>: <code class="literal">datetime</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">game_category</code>: <code class="literal">varchar(200)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">played</code>: <code class="literal">bool</code></li></ul></div><p>The following lines show the SQL creation script that Django generated when we executed the migrations:</p><pre class="programlisting">CREATE TABLE "games_game" ( &#13;
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, &#13;
    "created" datetime NOT NULL, &#13;
    "name" varchar(200) NOT NULL, &#13;
    "release_date" datetime NOT NULL, &#13;
    "game_category" varchar(200) NOT NULL, &#13;
    "played" bool NOT NULL &#13;
) &#13;
</pre><p>Django generated additional tables that it requires to support the Web framework and the authentication features that we will use later.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Managing serialization and deserialization</h1></div></div></div><p>Our RESTful Web API has to be able to serialize and deserialize the game instances into JSON representations. With Django REST Framework, we just need to create a serializer class for the game instances to manage serialization to JSON and deserialization from JSON.</p><p>Django REST Framework uses a two-phase process for serialization. The serializers are mediators between the model instances and Python primitives. Parser and renderers handle as mediators between Python primitives and HTTP requests and responses. We will configure our mediator between the <code class="literal">Game</code> model instances and Python primitives by creating a subclass of the <code class="literal">rest_framework.serializers.Serializer</code> class to declare the fields and the necessary methods to manage serialization and deserialization. We will repeat some of the information about the fields that we have included in the <code class="literal">Game</code> model so that we understand all the things that we can configure in a subclass of the Serializer class. However, we will work with shortcuts that will reduce boilerplate code later in the next examples. We will write less code in the next examples by using the <code class="literal">ModelSerializer</code> class.</p><p>Now, go to the <code class="literal">gamesapi/games</code> folder folder and create a new Python code file named <code class="literal">serializers.py</code>. The following lines show the code that declares the new <code class="literal">GameSerializer</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder.</p><pre class="programlisting">from rest_framework import serializers &#13;
from games.models import Game &#13;
 &#13;
 &#13;
class GameSerializer(serializers.Serializer): &#13;
    pk = serializers.IntegerField(read_only=True) &#13;
    name = serializers.CharField(max_length=200) &#13;
    release_date = serializers.DateTimeField() &#13;
    game_category = serializers.CharField(max_length=200) &#13;
    played = serializers.BooleanField(required=False) &#13;
 &#13;
    def create(self, validated_data): &#13;
        return Game.objects.create(**validated_data) &#13;
 &#13;
    def update(self, instance, validated_data): &#13;
        instance.name = validated_data.get('name', instance.name) &#13;
        instance.release_date = validated_data.get('release_date', instance.release_date) &#13;
        instance.game_category = validated_data.get('game_category', instance.game_category) &#13;
        instance.played = validated_data.get('played', instance.played) &#13;
        instance.save() &#13;
        return instance &#13;
</pre><p>The <code class="literal">GameSerializer</code> class declares the attributes that represent the fields that we want to be serialized. Notice that they have omitted the <code class="literal">created</code> attribute that was present in the <code class="literal">Game</code> model. When there is a call to the inherited <code class="literal">save</code> method for this class, the overridden <code class="literal">create</code> and <code class="literal">update</code> methods define how to create or modify an instance. In fact, these methods must be implemented in our class because they just raise a <code class="literal">NotImplementedError</code> exception in their base declaration.</p><p>The <code class="literal">create</code> method receives the validated data in the <code class="literal">validated_data</code> argument. The code creates and returns a new <code class="literal">Game</code> instance based on the received validated data.</p><p>The <code class="literal">update</code> method receives an existing <code class="literal">Game</code> instance that is being updated and the new validated data in the <code class="literal">instance</code> and <code class="literal">validated_data</code> arguments. The code updates the values for the attributes of the instance with the updated attribute values retrieved from the validated data, calls the save method for the updated <code class="literal">Game</code> instance and returns the updated and saved instance.</p><p>We can launch our default Python interactive shell and make all the Django project modules available before it starts. This way, we can check that the serializer works as expected. In addition, it will help us understanding how serialization works in Django. Run the following command to launch the interactive shell. Make sure you are within the <code class="literal">gamesapi</code> folder in the Terminal or command prompt:</p><pre class="programlisting"><strong>python manage.py shell</strong></pre><p>You will notice that a line that says (<code class="literal">InteractiveConsole</code>) is displayed after the usual lines that introduce your default Python interactive shell. Enter the following code in the Python interactive shell to import all the things we will need to test the <code class="literal">Game</code> model and its serializer. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder, in the <code class="literal">serializers_test_01.py</code> file:</p><pre class="programlisting">from datetime import datetime &#13;
from django.utils import timezone &#13;
from django.utils.six import BytesIO &#13;
from rest_framework.renderers import JSONRenderer &#13;
from rest_framework.parsers import JSONParser &#13;
from games.models import Game &#13;
from games.serializers import GameSerializer &#13;
</pre><p>Enter the following code to create two instances of the Game model and save them. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder, in the <code class="literal">serializers_test_01.py</code> file:</p><pre class="programlisting">gamedatetime = timezone.make_aware(datetime.now(), timezone.get_current_timezone()) &#13;
game1 = Game(name='Smurfs Jungle', release_date=gamedatetime, game_category='2D mobile arcade', played=False) &#13;
game1.save() &#13;
game2 = Game(name='Angry Birds RPG', release_date=gamedatetime, game_category='3D RPG', played=False) &#13;
game2.save() &#13;
</pre><p>After we execute the preceding code, we can check the SQLite database with the previously introduce command-line or GUI tool to check the contents of the <code class="literal">games_game</code> table. We will notice the table has two rows and the columns have the values we have provided to the different attributes of the <code class="literal">Game</code> instances.</p><p>Enter the following commands in the interactive shell to check the values for the primary keys or identifiers for the saved <code class="literal">Game</code> instances and the value of the <code class="literal">created</code> attribute includes the date and time in which we saved the instance to the database. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder, in the <code class="literal">serializers_test_01.py</code> file:</p><pre class="programlisting">print(game1.pk) &#13;
print(game1.name) &#13;
print(game1.created) &#13;
print(game2.pk) &#13;
print(game2.name) &#13;
print(game2.created) &#13;
</pre><p>Now, let's write the following code to serialize the first game instance (<code class="literal">game1</code>). The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder, in the <code class="literal">serializers_test_01.py</code> file:</p><pre class="programlisting">game_serializer1 = GameSerializer(game1) &#13;
print(game_serializer1.data) &#13;
</pre><p>The following line shows the generated dictionary, specifically, a <code class="literal">rest_framework.utils.serializer_helpers.ReturnDict</code> instance:</p><pre class="programlisting">{'release_date': '2016-05-18T03:02:00.776594Z', 'game_category': '2D mobile arcade', 'played': False, 'pk': 2, 'name': 'Smurfs Jungle'} &#13;
</pre><p>Now, let's serialize the second game instance (<code class="literal">game2</code>). The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder, in the <code class="literal">serializers_test_01.py</code> file:</p><pre class="programlisting">game_serializer2 = GameSerializer(game2) &#13;
print(game_serializer2.data) &#13;
</pre><p>The following line shows the generated dictionary:</p><pre class="programlisting">{'release_date': '2016-05-18T03:02:00.776594Z', 'game_category': '3D RPG', 'played': False, 'pk': 3, 'name': 'Angry Birds RPG'} &#13;
</pre><p>We can easily render the dictionaries hold in the <code class="literal">data</code> attribute into JSON with the help of the <code class="literal">rest_framework.renderers.JSONRenderer</code> class. The following lines create an instance of this class and then calls the <code class="literal">render</code> method to render the dictionaries hold in the data attribute into JSON. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder, in the <code class="literal">serializers_test_01.py</code> file:</p><pre class="programlisting">renderer = JSONRenderer() &#13;
rendered_game1 = renderer.render(game_serializer1.data) &#13;
rendered_game2 = renderer.render(game_serializer2.data) &#13;
print(rendered_game1) &#13;
print(rendered_game2) &#13;
</pre><p>The following lines show the output generated from the two calls to the <code class="literal">render</code> method:</p><pre class="programlisting"><strong>b'{"pk":2,"name":"Smurfs Jungle","release_date":"2016-05-&#13;
    18T03:02:00.776594Z","game_category":"2D mobile arcade","played":false}'</strong>
<strong>b'{"pk":3,"name":"Angry Birds RPG","release_date":"2016-05-&#13;
18T03:02:00.776594Z","game_category":"3D RPG","played":false}'</strong></pre><p>Now, we will work in the opposite direction: from serialized data to the population of a <code class="literal">Game</code> instance. The following lines generate a new <code class="literal">Game</code> instance from a JSON string (serialized data), that is, they will deserialize. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder, in the <code class="literal">serializers_test_01.py</code> file:</p><pre class="programlisting">json_string_for_new_game = '{"name":"Tomb Raider Extreme Edition","release_date":"2016-05-18T03:02:00.776594Z","game_category":"3D RPG","played":false}' &#13;
json_bytes_for_new_game = bytes(json_string_for_new_game , encoding="UTF-8") &#13;
stream_for_new_game = BytesIO(json_bytes_for_new_game) &#13;
parser = JSONParser() &#13;
parsed_new_game = parser.parse(stream_for_new_game) &#13;
print(parsed_new_game) &#13;
</pre><p>The first line creates a new string with the JSON that defines a new game (<code class="literal">json_string_for_new_game</code>). Then, the code converts the string to <code class="literal">bytes</code> and saves the results of the conversion in the <code class="literal">json_bytes_for_new_game</code> variable. The <code class="literal">django.utils.six.BytesIO</code> class provides a buffered I/O implementation using an in-memory bytes buffer. The code uses this class to create a stream from the previously generated JSON bytes with the serialized data, <code class="literal">json_bytes_for_new_game</code>, and saves the generated instance in the <code class="literal">stream_for_new_game</code> variable.</p><p>We can easily deserialize and parse a stream into the Python models with the help of the <code class="literal">rest_framework.parsers.JSONParser</code> class. The next line creates an instance of this class and then calls the <code class="literal">parse</code> method with <code class="literal">stream_for_new_game</code> as an argument, parses the stream into Python native datatypes and saves the results in the <code class="literal">parsed_new_game</code> variable.</p><p>After executing the preceding lines, <code class="literal">parsed_new_game</code> holds a Python dictionary, parsed from the stream. The following lines show the output generated after executing the preceding code snippet:</p><pre class="programlisting"><strong>{'release_date': '2016-05-18T03:02:00.776594Z', 'played': False,&#13;
    'game_category': '3D RPG', 'name': 'Tomb Raider Extreme Edition'}</strong></pre><p>The following lines use the <code class="literal">GameSerializer</code> class to generate a fully populated <code class="literal">Game</code> instance named <code class="literal">new_game</code> from the Python dictionary, parsed from the stream. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder, in the <code class="literal">serializers_test_01.py</code> file.</p><pre class="programlisting">new_game_serializer = GameSerializer(data=parsed_new_game) &#13;
if new_game_serializer.is_valid(): &#13;
    new_game = new_game_serializer.save() &#13;
    print(new_game.name) &#13;
</pre><p>First, the code creates an instance of the <code class="literal">GameSerializer</code> class with the Python dictionary that we previously parsed from the stream (<code class="literal">parsed_new_game</code>) passed as the <code class="literal">data</code> keyword argument. Then, the code calls the <code class="literal">is_valid</code> method to determine whether the data is valid. Notice that we must always call <code class="literal">is_valid</code> before we attempt to access the serialized data representation when we pass a <code class="literal">data</code> keyword argument in the creation of a serializer.</p><p>If the method returns <code class="literal">true</code>, we can access the serialized representation in the <code class="literal">data</code> attribute, and therefore, the code calls the <code class="literal">save</code> method that inserts the corresponding row in the database and returns a fully populated <code class="literal">Game</code> instance, saved in the <code class="literal">new_game</code> local variable. Then, the code prints one of the attributes from the fully populated <code class="literal">Game</code> instance. After executing the preceding code, we fully populated two Game instances: <code class="literal">new_game1_instance</code> and <code class="literal">new_game2_instance</code>.</p><div><div><h3 class="title"><a id="tip7"/>Tip</h3><p>As we can learn from the preceding code, Django REST Framework makes it easy to serialize from objects to JSON and deserialize from JSON to objects, which are core requirements for our RESTful Web API that has to perform CRUD operations.</p></div></div><p>Enter the following command to leave the shell with the Django project modules that we started to test serialization and deserialization:</p><pre class="programlisting">quit() &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Writing API views</h1></div></div></div><p>Now, we will create Django views that will use the previously created <code class="literal">GameSerializer</code> class to return JSON representations for each HTTP request that our API will handle. Open the <code class="literal">games/views.py</code> file. The following lines show the initial code for this file, with just one import statement and a comment that indicates we should create the views.</p><pre class="programlisting">from django.shortcuts import render &#13;
 &#13;
# Create your views here. &#13;
</pre><p>The following lines show the new code that creates a <code class="literal">JSONResponse</code> class and declares two functions: <code class="literal">game_list</code> and <code class="literal">game_detail</code>, in the <code class="literal">games/views.py</code> file. We are creating our first version of the API, and we use functions to keep the code as simple as possible. We will work with classes and more complex code in the next examples. The highlighted lines show the expressions that evaluate the value of the <code class="literal">request.method</code> attribute to determine the actions to be performed based on the HTTP verb. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder:</p><pre class="programlisting">from django.http import HttpResponse &#13;
from django.views.decorators.csrf import csrf_exempt &#13;
from rest_framework.renderers import JSONRenderer &#13;
from rest_framework.parsers import JSONParser &#13;
from rest_framework import status &#13;
from games.models import Game &#13;
from games.serializers import GameSerializer &#13;
 &#13;
 &#13;
class JSONResponse(HttpResponse): &#13;
    def __init__(self, data, **kwargs): &#13;
        content = JSONRenderer().render(data) &#13;
        kwargs['content_type'] = 'application/json' &#13;
        super(JSONResponse, self).__init__(content, **kwargs) &#13;
 &#13;
 &#13;
@csrf_exempt &#13;
def game_list(request): &#13;
   <strong> if request.method == 'GET':</strong> &#13;
        games = Game.objects.all() &#13;
        games_serializer = GameSerializer(games, many=True) &#13;
        return JSONResponse(games_serializer.data) &#13;
 &#13;
    <strong>elif request.method == 'POST':</strong> &#13;
        game_data = JSONParser().parse(request) &#13;
        game_serializer = GameSerializer(data=game_data) &#13;
        if game_serializer.is_valid(): &#13;
            game_serializer.save() &#13;
            return JSONResponse(game_serializer.data,&#13;
            status=status.HTTP_201_CREATED) &#13;
        return JSONResponse(game_serializer.errors,&#13;
        status=status.HTTP_400_BAD_REQUEST) &#13;
 &#13;
 &#13;
@csrf_exempt &#13;
def game_detail(request, pk): &#13;
    try: &#13;
        game = Game.objects.get(pk=pk) &#13;
    except Game.DoesNotExist: &#13;
        return HttpResponse(status=status.HTTP_404_NOT_FOUND) &#13;
 &#13;
   <strong> if request.method == 'GET':</strong> &#13;
        game_serializer = GameSerializer(game) &#13;
        return JSONResponse(game_serializer.data) &#13;
 &#13;
   <strong> elif request.method == 'PUT':</strong> &#13;
        game_data = JSONParser().parse(request) &#13;
        game_serializer = GameSerializer(game, data=game_data) &#13;
        if game_serializer.is_valid(): &#13;
            game_serializer.save() &#13;
            return JSONResponse(game_serializer.data) &#13;
        return JSONResponse(game_serializer.errors,&#13;
        status=status.HTTP_400_BAD_REQUEST) &#13;
 &#13;
  <strong>  elif request.method == 'DELETE':</strong> &#13;
        game.delete() &#13;
        return HttpResponse(status=status.HTTP_204_NO_CONTENT) &#13;
</pre><p>The <code class="literal">JSONResponse</code> class is a subclass of the <code class="literal">django.http.HttpResponse</code> class. The superclass represents an HTTP response with a string as content. The <code class="literal">JSONResponse</code> class renders its content into JSON. The class defines just declare the <code class="literal">__init__</code> method that created a <code class="literal">rest_framework.renderers.JSONRenderer</code> instance and calls its <code class="literal">render</code> method to render the received data into JSON save the returned bytestring in the <code class="literal">content</code> local variable. Then, the code adds the <code class="literal">'content_type'</code> key to the response header with <code class="literal">'application/json'</code> as its value. Finally, the code calls the initializer for the base class with the JSON <code class="literal">bytestring</code> and the key-value pair added to the header. This way, the class represents a JSON response that we use in the two functions to easily return a JSON response.</p><p>The code uses the <code class="literal">@csrf_exempt</code> decorator in the two functions to ensure that the view sets a <strong>Cross-Site Request Forgery</strong> (<strong>CSRF</strong>) cookie. We do this to make it simple to test this example that doesn't represent a production-ready Web Service. We will add security features to our RESTful API later.</p><p>When the Django server receives an HTTP request, Django creates an <code class="literal">HttpRequest</code> instance, specifically a <code class="literal">django.http.HttpRequest</code> object. This instance contains metadata about the request, including the HTTP verb. The <code class="literal">method</code> attribute provides a string representing the HTTP verb or method used in the request.</p><p>When Django loads the appropriate view that will process the requests, it passes the <code class="literal">HttpRequest</code> instance as the first argument to the view function. The view function has to return an <code class="literal">HttpResponse</code> instance, specifically a <code class="literal">django.http.HttpResponse</code> instance.</p><p>The <code class="literal">game_list</code> function lists all the games or creates a new game. The function receives an <code class="literal">HttpRequest</code> instance in the <code class="literal">request</code> argument. The function is capable of processing two HTTP verbs: <code class="literal">GET</code> and <code class="literal">POST</code>. The code checks the value of the <code class="literal">request.method</code> attribute to determine the code to be executed based on the HTTP verb. If the HTTP verb is <code class="literal">GET</code>, the expression <code class="literal">request.method == 'GET'</code> will evaluate to <code class="literal">True</code> and the code has to list all the games. The code will retrieve all the <code class="literal">Game</code> objects from the database, use the <code class="literal">GameSerializer</code> to serialize all of them, and return a <code class="literal">JSONResponse</code> instance built with the data generated by the <code class="literal">GameSerializer</code>. The code creates the <code class="literal">GameSerializer</code> instance with the <code class="literal">many=True</code> argument to specify that multiple instances have to be serialized and not just one. Under the hoods, Django uses a <code class="literal">ListSerializer</code> when the <code class="literal">many</code> argument value is set to <code class="literal">True</code>.</p><p>If the HTTP verb is <code class="literal">POST</code>, the code has to create a new game based on the JSON data that is included in the HTTP request. First, the code uses a <code class="literal">JSONParser</code> instance and calls its parse method with request as an argument to parse the game data provided as <code class="literal">JSON</code> data in the request and saves the results in the <code class="literal">game_data</code> local variable. Then, the code creates a <code class="literal">GameSerializer</code> instance with the previously retrieved data and calls the <code class="literal">is_valid</code> method to determine whether the <code class="literal">Game</code> instance is valid or not. If the instance is valid, the code calls the <code class="literal">save</code> method to persist the instance in the database and returns a JSONResponse with the saved data in its body and a status equal to <code class="literal">status.HTTP_201_CREATED</code>, that is, <code class="literal">201 Created</code>.</p><div><div><h3 class="title"><a id="tip8"/>Tip</h3><p>Whenever we have to return a specific status different from the default <code class="literal">200 OK</code> status, it is a good practice to use the module variables defined in the <code class="literal">rest_framework.status</code> module and to avoid using hardcoded numeric values.</p></div></div><p>The <code class="literal">game_detail</code> function retrieves, updates or deletes an existing game. The function receives an <code class="literal">HttpRequest</code> instance in the <code class="literal">request</code> argument and the primary key or identifier for the game to be retrieved, updated or deleted in the <code class="literal">pk</code> argument. The function is capable of processing three HTTP verbs: <code class="literal">GET</code>, <code class="literal">PUT</code> and <code class="literal">DELETE</code>. The code checks the value of the <code class="literal">request.method</code> attribute to determine the code to be executed based on the HTTP verb. No matter which is the HTTP verb, the function calls the <code class="literal">Game.objects.get</code> method with the received <code class="literal">pk</code> as the <code class="literal">pk</code> argument to retrieve a Game instance from the database based on the specified primary key or identifier, and saves it in the <code class="literal">game</code> local variable. In case a game with the specified primary key or identifier doesn't exist in the database, the code returns an <code class="literal">HttpResponse</code> with its status equal to <code class="literal">status.HTTP_404_NOT_FOUND</code>, that is, <code class="literal">404 Not Found</code>.</p><p>If the HTTP verb is <code class="literal">GET</code>, the code creates a <code class="literal">GameSerializer</code> instance with <code class="literal">game</code> as an argument and returns the data for the serialized game in a <code class="literal">JSONResponse</code> that will include the default <code class="literal">200 OK</code> status. The code returns the retrieved game serialized as JSON.</p><p>If the HTTP verb is <code class="literal">PUT</code>, the code has to create a new game based on the JSON data that is included in the HTTP request and use it to replace an existing game. First, the code uses a <code class="literal">JSONParser</code> instance and calls its parse method with request as an argument to parse the game data provided as <code class="literal">JSON</code> data in the request and saves the results in the <code class="literal">game_data</code> local variable. Then, the code creates a <code class="literal">GameSerializer</code> instance with the <code class="literal">Game</code> instance previously retrieved from the database (<code class="literal">game</code>) and the retrieved data that will replace the existing data (<code class="literal">game_data</code>). Then, the code calls the <code class="literal">is_valid</code> method to determine whether the <code class="literal">Game</code> instance is valid or not. If the instance is valid, the code calls the <code class="literal">save</code> method to persist the instance with the replaced values in the database and returns a <code class="literal">JSONResponse</code> with the saved data in its body and the default <code class="literal">200 OK</code> status. If the parsed data doesn't generate a valid Game instance, the code returns a <code class="literal">JSONResponse</code> with a status equal to <code class="literal">status.HTTP_400_BAD_REQUEST</code>, that is, <code class="literal">400 Bad Request</code>.</p><p>If the HTTP verb is <code class="literal">DELETE</code>, the code calls the <code class="literal">delete</code> method for the <code class="literal">Game</code> instance previously retrieved from the database (<code class="literal">game</code>). The call to the <code class="literal">delete</code> method erases the underlying row in the <code class="literal">games_game</code> table, and therefore, the game won't be available anymore. Then, the code returns a <code class="literal">JSONResponse</code> with a status equal to <code class="literal">status.HTTP_204_NO_CONTENT</code> that is, <code class="literal">204 No Content</code>.</p><p>Now, we have to create a new Python file named <code class="literal">urls.py</code> in the <code class="literal">games</code> folder, specifically, the <code class="literal">games/urls.py</code> file. The following lines show the code for this file that defines the URL patterns that specifies the regular expressions that have to be matched in the request to run a specific function defines in the <code class="literal">views.py</code> file. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder:</p><pre class="programlisting">from django.conf.urls import url &#13;
from games import views &#13;
 &#13;
urlpatterns = [ &#13;
    url(r'^games/$', views.game_list), &#13;
    url(r'^games/(?P&lt;pk&gt;[0-9]+)/$', views.game_detail), &#13;
] &#13;
</pre><p>The <code class="literal">urlpatterns</code> list makes it possible to route URLs to views. The code calls the <code class="literal">django.conf.urls.url</code> function with the regular expression that has to be matched and the view function defined in the views module as arguments to create a <code class="literal">RegexURLPattern</code> instance for each entry in the <code class="literal">urlpatterns</code> list.</p><p>We have to replace the code in the <code class="literal">urls.py</code> file in the <code class="literal">gamesapi</code> folder, specifically, the <code class="literal">gamesapi/urls.py</code> file. The file defines the root URL configurations, and therefore, we must include the URL patterns declared in the previously coded <code class="literal">games/urls.py</code> file. The following lines show the new code for the <code class="literal">gamesapi/urls.py</code> file. The code file for the sample is included in the <code class="literal">restful_python_chapter_01_01</code> folder:</p><pre class="programlisting">from django.conf.urls import url, include &#13;
 &#13;
urlpatterns = [ &#13;
    url(r'^', include('games.urls')), &#13;
] &#13;
</pre><p>Now, we can launch Django's development server to compose and send HTTP requests to our unsecure Web API (we will definitely add security later). Execute the following command:</p><pre class="programlisting"><strong>python manage.py runserver</strong></pre><p>The following lines show the output after we execute the preceding command. The development server is listening at port <code class="literal">8000 </code>.</p><pre class="programlisting"><strong>Performing system checks...</strong>
<strong>System check identified no issues (0 silenced).</strong>
<strong>May 20, 2016 - 04:22:38</strong>
<strong>Django version 1.9.6, using settings 'gamesapi.settings'</strong>
<strong>Starting development server at http://127.0.0.1:8000/</strong>
<strong>Quit the server with CONTROL-C.</strong></pre><p>With the preceding command, we will start Django development server and we will only be able to access it in our development computer. The preceding command starts the development server in the default IP address, that is, <code class="literal">127.0.0.1</code> (<code class="literal">localhost</code>). It is not possible to access this IP address from other computers or devices connected on our LAN. Thus, if we want to make HTTP requests to our API from other computers or devices connected to our LAN, we should use the development computer IP address, <code class="literal">0.0.0.0</code> (for IPv4 configurations), or <code class="literal">::</code> (for IPv6 configurations) as the desired IP address for our development server.</p><p>If we specify <code class="literal">0.0.0.0</code> as the desired IP address for IPv4 configurations, the development server will listen on every interface on port 8000. When we specify <code class="literal">::</code> for IPv6 configurations, it will have the same effect. In addition, it is necessary to open the default port <code class="literal">8000</code> in our firewalls (software and/or hardware) and configure port-forwarding to the computer that is running the development server. The following command launches Django's development server in an IPv4 configuration and allows requests to be made from other computers and devices connected to our LAN:</p><pre class="programlisting"><strong>python manage.py runserver 0.0.0.0:8000</strong></pre><div><div><h3 class="title"><a id="tip9"/>Tip</h3><p>If you decide to compose and send HTTP requests from other computers or devices connected to the LAN, remember that you have to use the development computer's assigned IP address instead of <code class="literal">localhost</code>. For example, if the computer's assigned IPv4 IP address is <code class="literal">192.168.1.106</code>, instead of <code class="literal">localhost:8000</code>, you should use <code class="literal">192.168.1.106:8000</code>. Of course, you can also use the host name instead of the IP address. The previously explained configurations are very important because mobile devices might be the consumers of our RESTful APIs and we will always want to test the apps that make use of our APIs in our development environments.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Making HTTP requests to the API</h1></div></div></div><p>The Django development server is running on localhost (<code class="literal">127.0.0.1</code>), listening on port <code class="literal">8000</code>, and waiting for our HTTP requests. Now, we will compose and send HTTP requests locally in our development computer or from other computer or devices connected to our LAN. We will use the following different kind of tools to compose and send HTTP requests throughout our book.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Command-line tools</li><li class="listitem" style="list-style-type: disc">GUI tools</li><li class="listitem" style="list-style-type: disc">Python code</li><li class="listitem" style="list-style-type: disc">JavaScript code</li></ul></div><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Notice that you can use any other application that allows you to compose and send HTTP requests. There are many apps that run on tablets and smartphones that allow you to accomplish this task. However, we will focus our attention on the most useful tools when building RESTful Web APIs.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec5"/>Working with command-line tools - curl and httpie</h2></div></div></div><p>We will start with command-line tools. One of the key advantages of command-line tools is that we can easily run again the HTTP requests after we built them for the first time, and we don't need to use the mouse or tap the screen to run requests. We can also easily build a script with batch requests and run them. As happens with any command-line tool, it can take more time to perform the first requests compared with GUI tools, but it becomes easier once we performed many requests and we can easily reuse the commands we have written in the past to compose new requests.</p><p>Curl, also known as cURL, is a very popular open source command-line tool and library that allow us to easily transfer data. We can use the curl command-line tool to easily compose and send HTTP requests and check their responses.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>If you are working on either macOS or Linux, you can open a Terminal and start using curl from the command line. If you are working on any Windows version, you can easily install curl from the <code class="literal">Cygwin</code> package installation option, and execute it from the Cygwin terminal. You can read more about the curl utility at <a class="ulink" href="http://curl.haxx.se">http://curl.haxx.se</a>. You can read more about the Cygwin terminal and its installation procedure at <a class="ulink" href="http://cygwin.com/install.html">http://cygwin.com/install.html</a>.</p></div></div><p>Open a Cygwin terminal in Windows or a terminal in macOS or Linux, and run the following command. It is very important that you enter the ending slash (<code class="literal">/</code>) because <code class="literal">/games</code> won't match any of the patterns specified in <code class="literal">urlpatterns</code> in the <code class="literal">games/urls.py</code> file. We are using the default configuration for Django that doesn't redirect URLs that don't match any of the patterns to the same URLs with a slash appended. Thus, we must enter <code class="literal">/games/</code>, including the ending slash (<code class="literal">/</code>):</p><pre class="programlisting"><strong>curl -X GET :8000/games/</strong></pre><p>The preceding command will compose and send the following HTTP request-<code class="literal">GET http://localhost:8000/games/</code>. The request is the simplest case in our RESTful API because it will match and run the <code class="literal">views.game_list</code> function, that is, the <code class="literal">game_list</code> function declared within the <code class="literal">games/views.py</code> file. The function just receives <code class="literal">request</code> as a parameter because the URL pattern doesn't include any parameters. As the HTTP verb for the request is <code class="literal">GET</code>, the <code class="literal">request.method</code> property is equal to <code class="literal">'GET'</code>, and therefore, the function will execute the code that retrieves all the <code class="literal">Game</code> objects and generates a JSON response with all of these <code class="literal">Game</code> objects serialized.</p><p>The following lines show an example response for the HTTP request, with three <code class="literal">Game</code> objects in the JSON response:</p><pre class="programlisting"><strong>[{"pk":3,"name":"Angry Birds RPG","release_date":"2016-05-18T03:02:00.776594Z","game_category":"3D RPG","played":false},{"pk":2,"name":"Smurfs Jungle","release_date":"2016-05-18T03:02:00.776594Z","game_category":"2D mobile arcade","played":false},{"pk":11,"name":"Tomb Raider Extreme Edition","release_date":"2016-05-18T03:02:00.776594Z","game_category":"3D RPG","played":false}]</strong></pre><p>As we might notice from the previous response, the curl utility displays the JSON response in a single line, and therefore, it is a bit difficult to read it. In this case, we know that the <code class="literal">Content-Type</code> of the response is <code class="literal">application/json</code>. However, in case we want to have more details about the response, we can use the <code class="literal">-i</code> option to request curl to print the HTTP response headers. We can combine the <code class="literal">-i</code> and <code class="literal">-X</code> options by using <code class="literal">-iX</code>.</p><p>Go back to the Cygwin terminal in Windows or the Terminal in macOS or Linux, and run the following command:</p><pre class="programlisting"><strong>curl -iX GET :8000/games/</strong></pre><p>The following lines show an example response for the HTTP request. The first lines show the HTTP response headers, including the status (<code class="literal">200 OK</code>) and the <code class="literal">Content-type </code>(<code class="literal">application/json</code>). After the HTTP response headers, we can see the details for the three <code class="literal">Game</code> objects in the JSON response:</p><pre class="programlisting"><strong>HTTP/1.0 200 OK</strong>
<strong>Date: Tue, 24 May 2016 18:04:40 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Content-Type: application/json</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>[{"pk":3,"name":"Angry Birds RPG","release_date":"2016-05-18T03:02:00.776594Z","game_category":"3D RPG","played":false},{"pk":2,"name":"Smurfs Jungle","release_date":"2016-05-18T03:02:00.776594Z","game_category":"2D mobile arcade","played":false},{"pk":11,"name":"Tomb Raider Extreme Edition","release_date":"2016-05-18T03:02:00.776594Z","game_category":"3D RPG","played":false}]</strong></pre><p>After we run the two requests, we will see the following lines in the window that is running the Django development server. The output indicates that the server received two HTTP requests with the <code class="literal">GET</code> verb and <code class="literal">/games/</code> as the URI. The server processed both HTTP requests, returned status code 200 and the response length was equal to 379 characters. The response length can be different because the value for the primary key assigned to each game will have an incidence in the response length. The first number after <code class="literal">HTTP/1.1."</code> indicates the returned status code (<code class="literal">200</code>) and the second number the response length (<code class="literal">379</code>).</p><pre class="programlisting"><strong>[25/May/2016 04:35:09] "GET /games/ HTTP/1.1" 200 379</strong>
<strong>[25/May/2016 04:35:10] "GET /games/ HTTP/1.1" 200 379</strong></pre><p>The following image shows two terminal windows side-by-side on macOS. The Terminal window at the left-hand side is running the Django development server and displays the received and processed HTTP requests. The Terminal window at the right-hand side is running <code class="literal">curl</code> commands to generate the HTTP requests.</p><p>It is a good idea to use a similar configuration to check the output while we compose and send the HTTP requests. Notice that the JSON outputs are a bit difficult to read because they don't use syntax highlighting:</p><p>
</p><div><img src="img/image_01_006.jpg" alt="Working with command-line tools - curl and httpie"/></div><p>Now, we will install HTTPie, a command-line HTTP client written in Python that makes it easy to send HTTP requests and uses a syntax that is easier than curl (also known as cURL). One of the great advantages of HTTPie is that it displays colorized output and uses multiple lines to display the response details. Thus, HTTPie makes it easier to understand the responses than the curl utility. We just need to activate the virtual environment and then run the following command in the terminal or command prompt to install the HTTPie package:</p><pre class="programlisting"><strong>pip install --upgrade httpie</strong></pre><p>The last lines for the output will indicate that the <code class="literal">django</code> package has been successfully installed.</p><pre class="programlisting"><strong>Collecting httpie</strong>
<strong>  Downloading httpie-0.9.3-py2.py3-none-any.whl (66kB)</strong>
<strong>Collecting requests&gt;=2.3.0 (from httpie)</strong>
<strong>  Using cached requests-2.10.0-py2.py3-none-any.whl</strong>
<strong>Collecting Pygments&gt;=1.5 (from httpie)</strong>
<strong>  Using cached Pygments-2.1.3-py2.py3-none-any.whl</strong>
<strong>Installing collected packages: requests, Pygments, httpie</strong>
<strong>Successfully installed Pygments-2.1.3 httpie-0.9.3 requests-2.10.0</strong></pre><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>In case you don't remember how to activate the virtual environment that we created for this example, read the following section in this chapter-<em>Setting up the virtual environment with Django REST framework</em>.</p></div></div><p>Now, we can use an <code class="literal">http</code> command to easily compose and send HTTP requests to <code class="literal">localhost:8000</code> and test the RESTful API built with Django REST framework. HTTPie supports curl-like shorthands for localhost, and therefore, we can use <code class="literal">:8000</code> as a shorthand that expands to <code class="literal">http://localhost:8000</code>. Run the following command and remember to enter the ending slash (<code class="literal">/</code>):</p><pre class="programlisting"><strong>http :8000/games/</strong></pre><p>The preceding command will compose and send the following HTTP request: <code class="literal">GET http://localhost:8000/games/</code>. The request is the same one we have previously composed with the curl command. However, in this case, the HTTPie utility will display a colorized output and it will use multiple lines to display the JSON response. The preceding command is equivalent to the following command that specifies the GET method after <code class="literal">http</code>:</p><pre class="programlisting"><strong>http GET :8000/games/</strong></pre><p>The following lines show an example response for the HTTP request, with the headers and the three <code class="literal">Game</code> objects in the JSON response. It is indeed easier to understand the response compared with the results generated when we composed the HTTP request with curl. HTTPie automatically formats the JSON data received as a response and applies syntax highlighting, specifically, both colors and formatting:</p><pre class="programlisting"><strong>HTTP/1.0 200 OK</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Thu, 26 May 2016 21:33:17 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>[</strong>
<strong>    {</strong>
<strong>        "game_category": "3D RPG",</strong>
<strong>        "name": "Angry Birds RPG",</strong>
<strong>        "pk": 3,</strong>
<strong>        "played": false,</strong>
<strong>        "release_date": "2016-05-18T03:02:00.776594Z"</strong>
<strong>    },</strong>
<strong>    {</strong>
<strong>        "game_category": "2D mobile arcade",</strong>
<strong>        "name": "Smurfs Jungle",</strong>
<strong>        "pk": 2,</strong>
<strong>        "played": false,</strong>
<strong>        "release_date": "2016-05-18T03:02:00.776594Z"</strong>
<strong>    },</strong>
<strong>    {</strong>
<strong>        "game_category": "3D RPG",</strong>
<strong>        "name": "Tomb Raider Extreme Edition",</strong>
<strong>        "pk": 11,</strong>
<strong>        "played": false,</strong>
<strong>        "release_date": "2016-05-18T03:02:00.776594Z"</strong>
<strong>    }</strong>
<strong>]</strong></pre><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>We can achieve the same results by combining the output generated with the curl command with other utilities. However, HTTPie provides us exactly what we need to work with RESTful APIs. We will use HTTPie to compose and send HTTP request, but we will always provide the equivalent curl command.</p></div></div><p>The following image shows two Terminal windows side-by-side on macOS. The terminal window at the left-hand side is running the Django development server and displays the received and processed HTTP requests. The Terminal window at the right-hand side is running HTTPie commands to generate the HTTP requests. Notice that the JSON output is easier to read compared to the output generated by the curl command:</p><p>
</p><div><img src="img/image_01_007.jpg" alt="Working with command-line tools - curl and httpie"/></div><p>We can execute HTTPie with the <code class="literal">-b</code> option in case we don't want to include the header in the response. For example, the following line performs the same HTTP request but doesn't display the header in the response output, and therefore, the output will just display the JSON response:</p><pre class="programlisting"><strong>http -b :8000/games/</strong></pre><p>Now, we will select one of the games from the preceding list and we will compose an HTTP request to retrieve just the chosen game. For example, in the previous list, the first game has a <code class="literal">pk</code> value equal to <code class="literal">3</code>. Run the following command to retrieve this game. Use the <code class="literal">pk</code> value you have retrieved in the previous command for the first game, as the pk number might be different:</p><pre class="programlisting"><strong>http :8000/games/3/</strong></pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting"><strong>curl -iX GET :8000/games/3/</strong></pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">GET http://localhost:8000/games/3/</code>. The request has a number after <code class="literal">/games/</code>, and therefore, it will match <code class="literal">'^games/(?P&lt;pk&gt;[0-9]+)/$'</code> and run the <code class="literal">views.game_detail</code> function, that is, the <code class="literal">game_detail</code> function declared within the <code class="literal">games/views.py</code> file. The function receives <code class="literal">request</code> and <code class="literal">pk</code> as parameters because the URL pattern passes the number specified after <code class="literal">/games/</code> in the <code class="literal">pk</code> parameter. As the HTTP verb for the request is <code class="literal">GET</code>, the <code class="literal">request.method</code> property is equal to <code class="literal">'GET'</code>, and therefore, the function will execute the code that retrieves the <code class="literal">Game</code> object whose primary key matches the <code class="literal">pk</code> value received as an argument and, if found, generates a JSON response with this <code class="literal">Game</code> object serialized. The following lines show an example response for the HTTP request, with the <code class="literal">Game</code> object that matches the <code class="literal">pk</code> value in the JSON response:</p><pre class="programlisting"><strong>HTTP/1.0 200 OK</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Fri, 27 May 2016 02:28:30 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "game_category": "3D RPG",</strong>
<strong>    "name": "Angry Birds RPG",</strong>
<strong>    "pk": 3,</strong>
<strong>    "played": false,</strong>
<strong>    "release_date": "2016-05-18T03:02:00.776594Z"</strong>
<strong>}</strong></pre><p>Now, we will compose and send an HTTP request to retrieve a game that doesn't exist. For example, in the preceding list, there is no game with a <code class="literal">pk</code> value equal to <code class="literal">99999</code>. Run the following command to try to retrieve this game. Make sure you use a <code class="literal">pk</code> value that doesn't exist. We must make sure that the utilities display the headers as part of the response because the response won't have a body:</p><pre class="programlisting"><strong>http :8000/games/99999/</strong></pre><p>The following is the equivalent curl command:</p><pre class="programlisting"><strong>curl -iX GET :8000/games/99999/</strong></pre><p>The preceding commands will compose and send the following HTTP request: <code class="literal">GET http://localhost:8000/games/99999/</code>. The request is the same than the previous one we have analyzed, with a different number for the <code class="literal">pk</code> parameter. The server will run the <code class="literal">views.game_detail</code> function, that is, the <code class="literal">game_detail</code> function declared within the <code class="literal">games/views.py</code> file. The function will execute the code that retrieves the <code class="literal">Game</code> object whose primary key matches the <code class="literal">pk</code> value received as an argument and a <code class="literal">Game.DoesNotExist</code> exception will be thrown and captured because there is no game with the specified <code class="literal">pk</code> value. Thus, the code will return an HTTP 404 Not Found status code. The following lines show an example header response for the HTTP request:</p><pre class="programlisting"><strong>HTTP/1.0 404 Not Found</strong>
<strong>Content-Type: text/html; charset=utf-8</strong>
<strong>Date: Fri, 27 May 2016 02:20:41 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong></pre><p>We will compose and send an HTTP request to create a new game.</p><pre class="programlisting"><strong>http POST :8000/games/ name='PvZ 3' game_category='2D mobile arcade' played=false release_date='2016-05-18T03:02:00.776594Z'</strong></pre><p>The following is the equivalent curl command. It is very important to use the <code class="literal">-H "Content-Type: application/json"</code> option to indicate curl to send the data specified after the -d option as <code class="literal">application/json</code> instead of the default <code class="literal">application/x-www-form-urlencoded</code>:</p><pre class="programlisting"><strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"PvZ 3", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-05-18T03:02:00.776594Z"}' :8000/games/</strong></pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">POST http://localhost:8000/games/</code> with the following JSON key-value pairs:</p><pre class="programlisting">{  &#13;
    "name": "PvZ 3",  &#13;
    "game_category": "2D mobile arcade",  &#13;
    "played": false,  &#13;
    "release_date": "2016-05-18T03:02:00.776594Z" &#13;
} &#13;
</pre><p>The request specifies <code class="literal">/games/</code>, and therefore, it will match <code class="literal">'^games/$'</code> and run the <code class="literal">views.game_list</code> function, that is, the <code class="literal">game_detail</code> function declared within the <code class="literal">games/views.py</code> file. The function just receives <code class="literal">request</code> as a parameter because the URL pattern doesn't include any parameters. As the HTTP verb for the request is <code class="literal">POST</code>, the <code class="literal">request.method</code> property is equal to <code class="literal">'POST'</code>, and therefore, the function will execute the code that parses the JSON data received in the request, creates a new <code class="literal">Game</code> and, if the data is valid, it saves the new <code class="literal">Game</code>. If the new Game was successfully persisted in the database, the function returns an <code class="literal">HTTP 201 Created</code> status code and the recently persisted <code class="literal">Game</code> serialized serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <code class="literal">Game</code> object in the JSON response:</p><pre class="programlisting"><strong>HTTP/1.0 201 Created</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Fri, 27 May 2016 05:12:39 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "game_category": "2D mobile arcade",</strong>
<strong>    "name": "PvZ 3",</strong>
<strong>    "pk": 15,</strong>
<strong>    "played": false,</strong>
<strong>    "release_date": "2016-05-18T03:02:00.776594Z"</strong>
<strong>}</strong></pre><p>Now, we will compose and send an HTTP request to update an existing game, specifically, the previously added game. We have to check the value assigned to <code class="literal">pk</code> in the previous response and replace <code class="literal">15</code> in the command with the returned value. For example, in case the value for <code class="literal">pk</code> was <code class="literal">5</code>, you should use <code class="literal">:8000/games/5/</code> instead of <code class="literal">:8000/games/15/</code>.</p><pre class="programlisting"><strong>http PUT :8000/games/15/ name='PvZ 3' game_category='2D mobile arcade' played=true release_date='2016-05-20T03:02:00.776594Z'</strong></pre><p>The following is the equivalent curl command. As happened with the previous curl example, it is very important to use the <code class="literal">-H "Content-Type: application/json"</code> option to indicate curl to send the data specified after the <code class="literal">-d</code> option as <code class="literal">application/json</code> instead of the default <code class="literal">application/x-www-form-urlencoded</code>:</p><pre class="programlisting"><strong>curl -iX PUT -H "Content-Type: application/json" -d '{"name":"PvZ 3", "game_category":"2D mobile arcade", "played": "true", "release_date": "2016-05-20T03:02:00.776594Z"}' :8000/games/15/</strong></pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">PUT http://localhost:8000/games/15/</code> with the following JSON key-value pairs:</p><pre class="programlisting">{  &#13;
    "name": "PvZ 3",  &#13;
    "game_category": "2D mobile arcade",  &#13;
    "played": true,  &#13;
    "release_date": "2016-05-20T03:02:00.776594Z" &#13;
} &#13;
</pre><p>The request has a number after <code class="literal">/games/</code>, and therefore, it will match <code class="literal">'^games/(?P&lt;pk&gt;[0-9]+)/$'</code> and run the <code class="literal">views.game_detail</code> function, that is, the <code class="literal">game_detail</code> function declared within the <code class="literal">games/views.py</code> file. The function receives <code class="literal">request</code> and <code class="literal">pk</code> as parameters because the URL pattern passes the number specified after <code class="literal">/games/</code> in the <code class="literal">pk</code> parameter. As the HTTP verb for the request is <code class="literal">PUT</code>, the <code class="literal">request.method</code> property is equal to <code class="literal">'PUT'</code>, and therefore, the function will execute the code that parses the JSON data received in the request, creates a <code class="literal">Game</code> instance from this data and updates the existing game in the database. If the game was successfully updated in the database, the function returns an <code class="literal">HTTP 200 OK</code> status code and the recently updated <code class="literal">Game</code> serialized serialized to JSON in the response body. The following lines show an example response for the <code class="literal">HTTP</code> request, with the updated <code class="literal">Game</code> object in the JSON response:</p><pre class="programlisting"><strong>HTTP/1.0 200 OK</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Sat, 28 May 2016 00:49:05 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "game_category": "2D mobile arcade",</strong>
<strong>    "name": "PvZ 3",</strong>
<strong>    "pk": 15,</strong>
<strong>    "played": true,</strong>
<strong>    "release_date": "2016-05-20T03:02:00.776594Z"</strong>
<strong>}</strong></pre><p>In order to successfully process a PUT HTTP request that updates an existing game, we must provide values for all the required fields. We will compose and send an HTTP request to try update an existing game, and we will fail to do so because we will just provide a value for the name. As happened in the previous request, we will use the value assigned to <code class="literal">pk</code> in the last game we added:</p><pre class="programlisting"><strong>http PUT :8000/games/15/ name='PvZ 4'</strong></pre><p>The following is the equivalent curl command:</p><pre class="programlisting"><strong>curl -iX PUT -H "Content-Type: application/json" -d '{"name":"PvZ 4"}'&#13;
    :8000/games/15/</strong></pre><p>The previous commands will compose and send the following <code class="literal">HTTP</code> request: <code class="literal">PUT http://localhost:8000/games/15/</code> with the following JSON key-value pair:</p><pre class="programlisting">{  &#13;
    "name": "PvZ 4",  &#13;
} &#13;
</pre><p>The request will execute the same code we explained for the previous request. Because we didn't provide all the required values for a <code class="literal">Game</code> instance, the <code class="literal">game_serializer.is_valid()</code> method will return <code class="literal">False</code> and the function will return an <code class="literal">HTTP 400 Bad Request</code> status code and the details generated in the <code class="literal">game_serializer.errors</code> attribute serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the required fields that our request didn't include values in the JSON response:</p><pre class="programlisting"><strong>HTTP/1.0 400 Bad Request</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Sat, 28 May 2016 02:53:08 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "game_category": [</strong>
<strong>        "This field is required."</strong>
<strong>    ],</strong>
<strong>    "release_date": [</strong>
<strong>        "This field is required."</strong>
<strong>    ]</strong>
<strong>}</strong></pre><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>When we want our API to be able to update a single field for an existing resource, in this case, an existing game, we should provide an implementation for the <code class="literal">PATCH</code> method. The <code class="literal">PUT</code> method is meant to replace an entire resource and the <code class="literal">PATCH</code> method is meant to apply a delta to an existing resource. We can write code in the handler for the <code class="literal">PUT</code> method apply a delta to an existing resource, but it is a better practice to use the <code class="literal">PATCH</code> method for this specific task. We will work with the <code class="literal">PATCH</code> method later.</p></div></div><p>Now, we will compose and send an HTTP request to delete an existing game, specifically, the last game we added. As happened in our last HTTP requests, we have to check the value assigned to <code class="literal">pk</code> in the previous response and replace <code class="literal">12</code> in the command with the returned value:</p><pre class="programlisting"><strong>http DELETE :8000/games/15/</strong></pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting"><strong>curl -iX DELETE :8000/games/15/</strong></pre><p>The preceding commands will compose and send the following HTTP request: <code class="literal">DELETE http://localhost:8000/games/15/</code>. The request has a number after <code class="literal">/games/</code>, and therefore, it will match <code class="literal">'^games/(?P&lt;pk&gt;[0-9]+)/$'</code> and run the <code class="literal">views.game_detail</code> function, that is, the <code class="literal">game_detail</code> function declared within the <code class="literal">games/views.py</code> file. The function receives <code class="literal">request</code> and <code class="literal">pk</code> as parameters because the URL pattern passes the number specified after <code class="literal">/games/</code> in the <code class="literal">pk</code> parameter. As the HTTP verb for the request is <code class="literal">DELETE</code>, the <code class="literal">request.method</code> property is equal to <code class="literal">'DELETE'</code>, and therefore, the function will execute the code that parses the JSON data received in the request, creates a <code class="literal">Game</code> instance from this data and deletes the existing game in the database. If the game was successfully deleted in the database, the function returns an <code class="literal">HTTP 204 No Content</code> status code. The following lines show an example response for the HTTP request after successfully deleting an existing game:</p><pre class="programlisting"><strong>HTTP/1.0 204 No Content</strong>
<strong>Date: Sat, 28 May 2016 04:08:58 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Content-Length: 0</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>Content-Type: text/html; charset=utf-8</strong></pre></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec6"/>Working with GUI tools - Postman and others</h2></div></div></div><p>So far, we have been working with two terminal-based or command-line tools to compose and send HTTP requests to our Django development server-cURL and HTTPie. Now, we will work with <strong>GUI</strong> (<strong>Graphical User Interface</strong>) tools.</p><p>Postman is a very popular API testing suite GUI tool that allows us to easily compose and send HTTP requests, among other features. Postman is available as a Chrome App and as a Mac App. We can execute it in Windows, Linux and macOS as a Chrome App, that is, an application running on top of Google Chrome. In case we work with macOS, we can use the Mac App instead of the Chrome App. You can download the versions of the Postman App from the following URL-<a class="ulink" href="https://www.getpostman.com">https://www.getpostman.com</a>.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>You can download and install Postman for free to compose and send HTTP requests to our RESTful APIs. You just need to sign up to Postman and we won't be using any of the paid features provided by Postman cloud in our examples. All the instructions work with Postman 4.2.2 or greater.</p></div></div><p>Now, we will use the <strong>Builder</strong> tab in Postman to easily compose and send HTTP requests to <code class="literal">localhost:8000</code> and test the RESTful API with this GUI tool. Postman doesn't support curl-like shorthands for localhost, and therefore, we cannot use the same shorthands we have been using when composing requests with HTTPie.</p><p>Select <strong>GET</strong> in the dropdown menu at the left-hand side of the <strong>Enter request URL</strong> textbox, and enter <code class="literal">localhost:8000/games/</code> in this textbox at the right-hand side of the dropdown. Then, click <strong>Send</strong> and Postman will display the Status (<strong>200 OK</strong>), the time it took for the request to be processed and the response body with all the games formatted as JSON with syntax highlighting (<strong>Pretty</strong> view).</p><p>The following screenshot shows the JSON response body in Postman for the HTTP GET request:</p><p>
</p><div><img src="img/image_01_008.jpg" alt="Working with GUI tools - Postman and others"/></div><p>Click on <strong>Headers</strong> at the right-hand side of <strong>Body</strong> and <strong>Cookies</strong> to read the response headers. The following screenshot shows the layout for the response headers that Postman displays for the preceding response. Notice that Postman displays the <strong>Status</strong> at the right-hand side of the response and doesn't include it as the first line of the Headers, as happened when we worked with both the cURL and HTTPie utilities:</p><p>
</p><div><img src="img/image_01_009.jpg" alt="Working with GUI tools - Postman and others"/></div><p>Now, we will use the <strong>Builder</strong> tab in Postman to compose and send an HTTP request to create a new game, specifically, a POST request. Follow the next steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select <strong>POST</strong> in the drop-down menu at the left-hand side of the <strong>Enter request URL</strong> textbox, and enter <code class="literal">localhost:8000/games/</code> in this textbox at the right-hand side of the dropdown.</li><li class="listitem">Click <strong>Body</strong> at the right-hand side of <strong>Authorization</strong> and <strong>Headers</strong>, within the panel that composes the request.</li><li class="listitem">Activate the <strong>raw</strong> radio button and select <strong>JSON (application/json)</strong> in the dropdown at the right-hand side of the <strong>binary</strong> radio button. Postman will automatically add a <strong>Content-type</strong> as <strong>application/json</strong> header, and therefore, you will notice the <strong>Headers</strong> tab will be renamed to <strong>Headers (1)</strong>, indicating us that there is one key-value pair specified for the request headers.</li><li class="listitem">Enter the following lines in the textbox below the radio buttons, within the <strong>Body</strong> tab:</li></ol></div><pre class="programlisting">{ &#13;
    "name": "Batman vs Superman",  &#13;
    "game_category": "3D RPG",  &#13;
    "played": false,  &#13;
    "release_date": "2016-05-18T03:02:00.776594Z" &#13;
} &#13;
</pre><p>The following screenshot shows the request body in Postman:</p><p>
</p><div><img src="img/image_01_010.jpg" alt="Working with GUI tools - Postman and others"/></div><p>We followed the necessary steps to create an HTTP POST request with a JSON body that specifies the necessary key-value pairs to create a new game. Click on <strong>Send</strong> and Postman will display the Status (<code class="literal">201 Created</code>), the time it took for the request to be processed and the response body with the recently added game formatted as JSON with syntax highlighting (<strong>Pretty</strong> view). The following screenshot shows the JSON response body in Postman for the HTTP POST request.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>If we want to compose and send an HTTP PUT request with Postman, it is necessary to follow the previously explained steps to provide JSON data within the request body.</p></div></div><p>One of the nice features included in Postman is that we can easily review and again run the HTTP requests we have made by browsing the saved <strong>History</strong> shown at the left-hand side of the Postman window. The History pane displays a list with the HTTP verb followed by the URL for each HTTP request we have composed and sent. We just need to click on the desired HTTP request and click <strong>Send</strong> to run it again. The following screenshot shows the many HTTP requests in the <strong>History</strong> pane and the first one selected to send it again.</p><p>
<strong>JetBrains PyCharm</strong> is a very popular multiplatform Python IDE (short for Integrated Development Environment) available on macOS, Linux and Windows. Its paid Professional version includes a REST Client that allows us to test RESTful Web services. In case we work with this version of the IDE, we can compose and send HTTP requests without leaving the IDE. You don't need a JetBrains PyCharm Professional version license to run the examples included in this book. However, as the IDE is very popular, we will learn the necessary steps to compose and send an HTTP request for our API using the REST Client included in this IDE.</p><p>Now, we will use the <strong>REST Client</strong> included in PyCharm professional to compose and send an HTTP request to create a new game, specifically, a POST request. Follow the next steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select <strong>Tools</strong> | <strong>Test</strong> RESTful Web Service in the main menu to display the REST Client panel.</li><li class="listitem">Select <strong>POST</strong> in the HTTP method dropdown menu in the REST Client pane.</li><li class="listitem">Enter <code class="literal">localhost:8000</code> in the <strong>Host/port</strong> textbox, at the right-hand side of the dropdown.</li><li class="listitem">Enter <code class="literal">/games/</code> in the <strong>Path</strong> textbox, at the right-hand side of the <strong>Host/port</strong> textbox.</li><li class="listitem">Make sure that the <strong>Request</strong> tab is activated and click on the add (<strong>+</strong>) button at the bottom of the <strong>Headers</strong> list. The IDE will display a textbox for the name and a dropdown for the value. Enter <code class="literal">Content-Type</code> in <strong>Name</strong>, enter <code class="literal">application/json</code> in <strong>Value</strong> and press Enter.</li><li class="listitem">Activate the <strong>Text:</strong> radio button in <strong>Request Body</strong> and click the <strong>...</strong> button, on the right-hand side of the <strong>Text</strong> textbox, to specify the text to send. Enter the following lines in textbox included in the <strong>Specify the text to send</strong> dialog box and then click on <strong>OK</strong>.</li></ol></div><pre class="programlisting">{ &#13;
    "name": "Teenage Mutant Ninja Turtles",  &#13;
    "game_category": "3D RPG",  &#13;
    "played": false,  &#13;
    "release_date": "2016-05-18T03:02:00.776594Z" &#13;
} &#13;
</pre><p>The following screenshot shows the request built in PyCharm Professional <strong>REST Client</strong>:</p><p>
</p><div><img src="img/image_01_011.jpg" alt="Working with GUI tools - Postman and others"/></div><p>We followed the necessary steps to create an HTTP POST request with a JSON body that specifies the necessary key-value pairs to create a new game. Click on the submit request button, that is, the first button with the play icon at the upper-left corner of the <strong>REST Client</strong> pane. The REST client will compose and send the HTTP POST request, will activate the <strong>Response</strong> tab, and display the response code <strong>201 (Created)</strong>, the time it took for the request to be processed, and the content length at the bottom of the pane.</p><p>By default, the REST client will automatically apply JSON syntax highlighting to the response. However, sometimes, the JSON content is displayed without line breaks and it is necessary to click on the reformat response button, that is, the first button in the <strong>Response</strong> tab. The REST client displays the response headers in another tab, and therefore, it just displays the response body in the <strong>Response</strong> tab. The following screenshot shows the JSON response body in the REST client for the HTTP POST request:</p><p>
</p><div><img src="img/image_01_012.jpg" alt="Working with GUI tools - Postman and others"/></div><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>If we want to compose and send an HTTP PUT request with the REST Client included in PyCharm Professional, it is necessary to follow the previously explained steps to provide JSON data within the request body.</p></div></div><p>In case you don't work with PyCharm Professional, run any of the following commands to compose and send the HTTP POST request to create the new game:</p><pre class="programlisting"><strong>http POST :8000/games/ name='Teenage Mutant Ninja Turtles' game_category='3D RPG' played=false release_date='2016-05-18T03:02:00.776594Z'</strong></pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting"><strong>curl -iX POST -H "Content-Type: application/json" -d '{"name": "Teenage&#13;
Mutant Ninja Turtles", "game_category": "3D RPG", "played": "false",&#13;
"release_date": "2016-05-18T03:02:00.776594Z"}' :8000/games/</strong></pre><p>Telerik Fiddler is a popular tool for Windows developers. Telerik Fiddler is a free Web debugging proxy with a GUI but it only runs on Windows. Its main Web page promotes it as a multi-platform tool, but at the time this book was published, the macOS and Linux versions were completely unstable and their development abandoned. We can use Telerik Fiddler in Windows to compose and send HTTP requests, among other features. You can download Fiddler for Windows from the following URL-<a class="ulink" href="https://www.telerik.com/download/fiddler">https://www.telerik.com/download/fiddler</a>.</p><p>Stoplight is a popular powerful API modeling tool that allows us to easily test our APIs. Its HTTP request maker allows us to compose and send requests and generate the necessary code to make them in different programming languages, such as JavaScript, Swift, C#, PHP, Node, and Go, among others. You can sign up to work with Stoplight at the following URL-<a class="ulink" href="http://stoplight.io">http://stoplight.io</a>.</p><p>We can also use apps that can compose and send HTTP requests from mobile devices to work with the RESTful API. For example, we can work with the iCurlHTTP App on iOS devices such as iPad and iPhone-<a class="ulink" href="https://itunes.apple.com/us/app/icurlhttp/id611943891?mt=8">https://itunes.apple.com/us/app/icurlhttp/id611943891?mt=8</a>. In Android devices, we can work with the HTTP Request App-<a class="ulink" href="https://play.google.com/store/apps/details?id=air.http.request&amp;hl=en">https://play.google.com/store/apps/details?id=air.http.request&amp;hl=en</a>.</p><p>The following screenshot shows the results of composing and sending the following HTTP request with the iCurlHTTP App: <code class="literal">GET http://192.168.1.106:8000/games/</code>. Remember that you have to perform the previously explained configurations in your LAN and router to be able to access the Django development server from other devices connected to your LAN. In this case, the IP assigned to the computer running the Django Web server is <code class="literal">192.168.1.106</code>, and therefore, you must replace this IP with the IP assigned to your development computer.</p><p>At the time this book was published, the mobile apps that allow you to compose and send HTTP requests do not provide all the features you can find in Postman or command-line utilities.</p><p>
</p><div><img src="img/image_01_013.jpg" alt="Working with GUI tools - Postman and others"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Test your knowledge</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">If we want to create a simple <code class="literal">Player</code> model that we will use to represent and persist players in Django REST framework, we can create:<div><ol class="orderedlist arabic"><li class="listitem"> A <code class="literal">Player</code> class as a subclass of the <code class="literal">djangorestframework.models.Model class</code>.</li><li class="listitem"> A <code class="literal">Player</code> class as a subclass of the <code class="literal">django.db.models.Model class</code>.</li><li class="listitem"> A Player function in the <code class="literal">restframeworkmodels.py</code> file.</li></ol></div><p>
</p></li><li class="listitem">In the Django REST Framework, serializers are:<div><ol class="orderedlist arabic"><li class="listitem">Mediators between the model instances and Python primitives.</li><li class="listitem">Mediators between the view functions and Python primitives.</li><li class="listitem">Mediators between the URLs and view functions.</li></ol></div><p>
</p></li><li class="listitem">In the Django REST Framework, parsers and renderers:<div><ol class="orderedlist arabic"><li class="listitem">Handle as mediators between model instances and Python primitives.</li><li class="listitem">Reset the board.</li><li class="listitem">Handle as mediators between Python primitives and HTTP requests and responses.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">urlpatterns</code> list declared in the urls.py file makes it possible to:<div><ol class="orderedlist arabic"><li class="listitem"> Route URLs to views.</li><li class="listitem"> Route URLs to models.</li><li class="listitem"> Route URLs to Python primitives.</li></ol></div><p>
</p></li><li class="listitem">HTTPie is a:<div><ol class="orderedlist arabic"><li class="listitem">Command-line HTTP server written in Python that makes it easy to create a RESTful Web Server.</li><li class="listitem">Command-line utility that allows us to run queries against an SQLite database.</li><li class="listitem">Command-line HTTP client written in Python that makes it easy to compose and send HTTP requests.</li></ol></div><p>
</p></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, we designed a RESTful API to interact with a simple SQLite database and perform CRUD operations with games. We defined the requirements for our API and we understood the tasks performed by each HTTP method. We learned the advantages of working with lightweight virtual environments in Python and we set up a virtual environment with Django REST Framework.</p><p>We created a model to represent and persist games and we executed migrations in Django. We learned to manage serialization and serialization of game instances into JSON representations with Django REST Framework. We wrote API views to process the different HTTP requests and we configured the URL patterns list to route URLs to views.</p><p>Finally, we started the Django development server and we used command-line tools to compose and send HTTP requests to our RESTful API and analyzed how each HTTP request was processed in our code. We also worked with GUI tools to compose and send HTTP requests.</p><p>Now that we understand the basics of Django REST Framework, we will expand the capabilities of the RESTful Web API by taking advantage of the advanced features included in the Django REST Framework, which is what we are going to discuss in the next chapter.</p></div></body></html>