<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Python Objects, Types, and Expressions</h1>
            </header>

            <article>
                
<p>Python is the language of choice for many advanced data tasks for a very good reason. Python is one of the easiest advanced programming languages to learn. Intuitive structures and semantics mean that for people who are not computer scientists, but maybe biologists, statisticians, or the directors of a start-up, Python is a straightforward way to perform a wide variety of data tasks. It is not just a scripting language, but a full-featured object-oriented programming language.</p>
<p>In Python, there are many useful data structures and algorithms built in to the language. Also, because Python is an object-based language, it is relatively easy to create custom data objects. In this book, we will examine both Python internal libraries, some of the external libraries, as well as learning how to build your own data objects from first principles.</p>
<p>This book does assume that you know Python. However, if you are a bit rusty, coming from another language, or do not know Python at all, don't worry, this first chapter should get you quickly up to speed. If not, then visit <a href="https://docs.python.org/3/tutorial/index.html"><span class="URLPACKT">https://docs.python.org/3/tutorial/index.html</span></a><span class="URLPACKT">,</span> and also you can find the documentation at <a href="https://www.python.org/doc/"><span class="URLPACKT">https://www.python.org/doc/</span></a>. These are all excellent resources to easily learn this programming language.</p>
<p>In this chapter, we will look at the following topics:</p>
<ul>
<li>Obtaining a general working knowledge of data structures and algorithms</li>
<li>Understanding core data types and their functions</li>
<li>Exploring the object-oriented aspects of the Python programming language</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Understanding data structures and algorithms</h1>
            </header>

            <article>
                
<p>Algorithms and data structures are the most fundamental concepts in computing. They are the building blocks from which complex software is built. Having an understanding of these foundation concepts is hugely important in software design and this involves the following three characteristics:</p>
<ul>
<li>How algorithms manipulate information contained within data structures</li>
<li>How data is arranged in memory</li>
<li>What the performance characteristics of particular data structures are</li>
</ul>
<p>In this book, we will examine this topic from several perspectives. Firstly, we will look at the fundamentals of the Python programming language from the perspective of data structures and algorithms. Secondly, it is important that we have the correct mathematical tools. We need to understand some fundamental concepts of computer science and for this we need mathematics. By taking a heuristics approach, developing some guiding principles means that, in general, we do not need any more than high school mathematics to understand the principles of these key ideas.</p>
<p>Another important aspect is evaluation. Measuring an algorithms performance involves understanding how each increase in data size affects operations on that data. When we are working on large datasets or real-time applications, it is essential that our algorithms and structures are as efficient as they can be.</p>
<p>Finally, we need a sound experimental design strategy. Being able to conceptually translate a real-world problem into the algorithms and data structures of a programming language involves being able to understand the important elements of a problem and a methodology for mapping these elements to programming structures.</p>
<p>To give us some insight into algorithmic thinking, let's consider a real-world example. Imagine we are at an unfamiliar market and we are given the task of purchasing a list of items. We assume that the market is laid out randomly, and each vendor sells a random subset of items, some of which may be on our list. Our aim is to minimize the price we pay for each item as well as minimize the time spent at the market. One way to approach this is to write an algorithm like the following:</p>
<p>Repeat for each vendor:</p>
<ol>
<li>Does the vendor have items on my list and is the cost less than a predicted cost for the item?</li>
<li>If yes, buy and remove from list; if no, move on to the next vendor.</li>
<li>If no more vendors, end.</li>
</ol>
<p>This is a simple iterator, with a decision and an action. If we were to implement this, we would need data structures to define both the list of items we want to buy as well as the list of items of each vendor. We would need to determine the best way of matching items in each list and we need some sort of logic to decide whether to purchase or not.</p>
<p>There are several observations that we can make regarding this algorithm. Firstly, since the cost calculation is based on a prediction, we don't know what the real average cost is; if we underpredict the cost of an item, we come to the end of the market with items remaining on our list. Therefore, we need an efficient way to backtrack to the vendor with the lowest cost.</p>
<p>Also, we need to understand what happens to the time it takes to compare items on our shopping list with items sold by each vendor as the number of items on our shopping list, or the number of items sold by each vendor, increases. The order in which we search through items and the shape of the data structures can make a big difference to the time it takes to do a search. Clearly, we would like to arrange our list, as well as the order we visit each vendor, in such a way that we minimize search time.</p>
<p>Also, consider what happens when we change the buy condition to purchase at the <em>cheapest</em> price, not just the below average price. This changes the problem entirely. Instead of sequentially going from one vendor to the next, we need to traverse the market once and, with this knowledge, we can order our shopping list with regards to the vendors we want to visit.</p>
<p>Obviously, there are many more subtleties involved in translating a real-world problem into an abstract construct such as a programming language. For example, as we progress through the market, our knowledge of the cost of a product improves, so our predicted average price variable becomes more accurate until, by the last stall, our knowledge of the market is perfect. Assuming any kind of backtracking algorithm incurs a cost, we can see cause to review our entire strategy. Conditions such as high price variability, the size and shape of our data structures, and the cost of backtracking all determine the most appropriate solution.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Python for data</h1>
            </header>

            <article>
                
<p>Python has several built-in data structures, including lists, dictionaries, and sets, that we use to build customized objects. In addition, there are a number of internal libraries, such as collections and the <kbd>math</kbd> object, which allow us to create more advanced structures as well as perform calculations on those structures. Finally, there are the external libraries such as those found in the <kbd>SciPy</kbd> packages. These allow us to perform a range of advanced data tasks such as logistic and linear regression, visualization, and mathematical calculations such as operations on matrixes and vectors. External libraries can be very useful for an <em>out-of-the-box</em> solution. However, we must also be aware that there is often a performance penalty compared to building customized objects from the ground up. By learning how to code these objects ourselves, we can target them to specific tasks, making them more efficient. This is not to exclude the role of external libraries and we will look at this in <a href="f1986aa3-0229-4480-8496-d25a2a9dae46.xhtml">Chapter 12</a><em>, Design Techniques and Strategies</em><em>.</em></p>
<p>To begin, we will take an overview of some of the key language features that make Python such a great choice for data programming.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The Python environment</h1>
            </header>

            <article>
                
<p>A feature of the Python environment is its interactive console allowing you to both use Python as a desktop programmable calculator and also as an environment to write and test snippets of code. The <strong>read-evaluate-print</strong> loop of the console is a very convenient way to interact with a larger code base, such as to run functions and methods or to create instances of classes. This is one of the major advantages of Python over compiled languages such as C/C++ or Java, where the <strong>write-compile-test-recompile</strong> cycle can increase development time considerably compared to Python's read - evaluate - print loop. Being able to type in expressions and get an immediate response can greatly speed up data science tasks.</p>
<p>There are some excellent distributions of Python apart from the official CPython version. Two of the most popular are Anaconda (<a href="https://www.continuum.io/downloads">https://www.continuum.io/downloads</a>) and Canopy (<a href="https://www.enthought.com/products/canopy/">https://www.enthought.com/products/canopy/</a>). Most distributions come with their own developer environments. Both Canopy and Anaconda include libraries for scientific, machine learning, and other data applications. Most distributions come with an editor.</p>
<p>There are also a number of implementations of the Python console, apart from the CPython version. Most notable amongst these is the Ipython/Jupyter platform that includes a web-based computational environment.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Variables and expressions</h1>
            </header>

            <article>
                
<p>To translate a real-world problem into one that can be solved by an algorithm, there are two interrelated tasks. Firstly, select the variables, and secondly, find the expressions that relate to these variables. Variables are labels attached to objects; they are not the object itself. They are not containers for objects either. A variable does not contain the object, rather it acts as a pointer or reference to an object. For example, consider the following code:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="111" src="assets/image_01_001.png" width="167"/></div>
<p>Here we have created a variable, <kbd>a</kbd>, which points to a list object. We create another variable, <kbd>b</kbd>, which points to this same list object. When we append an element to this list object, this change is reflected in both <kbd>a</kbd> and <kbd>b</kbd>.</p>
<p>Python is a dynamically typed language. Variable names can be bound to different values and types during program execution. Each value is of a type, a string, or integer for example; however, the name that points to this value does not have a specific type. This is different from many languages such as C and Java where a name represents a fixed size, type, and location in memory. This means when we initialize variables in Python, we do not need to declare a type. Also, variables, or more specifically the objects they point to, can change type depending on the values assigned to them, for example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="130" src="assets/image_01_002.png" width="121"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Variable scope</h1>
            </header>

            <article>
                
<p>It is important to understand the scoping rules of variables inside functions. Each time a function executes, a new local namespace is created. This represents a local environment that contains the names of the parameters and variables that are assigned by the function. To resolve a namespace when a function is called, the Python interpreter first searches the local namespace (that is, the function itself) and if no match is found, it searches the global namespace. This global namespace is the module in which the function was defined. If the name is still not found, it searches the built-in namespace. Finally, if this fails then the interpreter raises a <kbd>NameError</kbd> exception. Consider the following code:</p>
<pre>
    a=10; b=20 <br/>    def my_function(): <br/>        global a <br/>        a=11; b=21 <br/>    my_function() <br/>    print(a) #prints 11 <br/>    print(b) #prints 20
</pre>
<p>Here is the output of the preceding code:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_003.png"/></div>
<p>In the preceding code, we define two global variables. We need to tell the interpreter, using the keyword <kbd>global</kbd>, that inside the function, we are referring to a global variable. When we change this variable to <kbd>11</kbd>, these changes are reflected in the global scope. However, the variable <kbd>b</kbd> we set to <kbd>21</kbd> is local to the function, and any changes made to it inside the function are not reflected in the global scope. When we run the function and print <kbd>b</kbd>, we see that it retains its global value.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Flow control and iteration</h1>
            </header>

            <article>
                
<p>Python programs consist of a sequence of statements. The interpreter executes each statement in order until there are no more statements. This is true if both files run as the main program as well as files that are loaded via <kbd>import</kbd>. All statements, including variable assignment, function definitions, class definitions, and module imports, have equal status. There are no special statements that have higher priority than any other and every statement can be placed anywhere in a program. There are two main ways of controlling the flow of program execution, conditional statements and loops.</p>
<p>The <kbd>if</kbd>, <kbd>else</kbd>, and <kbd>elif</kbd> statements control the conditional execution of statements. The general format is a series of <kbd>if</kbd> and <kbd>elif</kbd> statements followed by a final <kbd>else</kbd> statement:</p>
<pre>
    x='one' <br/>    if x==0:  <br/>        print('False') <br/>    elif x==1: <br/>        print('True') <br/>    else: print('Something else') <br/>    #prints 'Something else' 
</pre>
<p>Note the use of the <kbd>==</kbd> operator to test for the same values. This returns <kbd>true</kbd> if the values are equal; it returns <kbd>false</kbd> otherwise. Note also that setting <kbd>x</kbd> to a string will return <em>something else</em> rather than generate a type error as may happen in languages that are not dynamically typed. Dynamically typed languages such as Python allow flexible assignment of objects with different types.</p>
<p>The other way of controlling program flow is with loops. They are created using the <kbd>while</kbd> or <kbd>for</kbd> statements, for example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_004.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Overview of data types and objects</h1>
            </header>

            <article>
                
<p>Python contains 12 built-in data types. These include four numeric types (<kbd>int</kbd>, <kbd>float</kbd>, <kbd>complex</kbd>, <kbd>bool</kbd>), four sequence types (<kbd>str</kbd>, <kbd>list</kbd>, <kbd>tuple</kbd>, <kbd>range</kbd>), one mapping type (<kbd>dict</kbd>), and two set types. It is also possible to create user-defined objects such as functions or classes. We will look at the <kbd>string</kbd> and the <kbd>list</kbd> data types in this chapter and the remaining built-in types in the next chapter.</p>
<p>All data types in Python are <strong>objects</strong>. In fact, pretty much everything is an object in Python, including modules, classes, and functions, as well as literals such as strings and integers. Each object in Python has a <strong>type</strong>, a <strong>value,</strong> and an <strong>identity</strong>. When we write <kbd>greet = "hello world"</kbd> we are creating an instance of a string object with the value <kbd>"hello world"</kbd> and the identity of <kbd>greet</kbd>. The identity of an object acts as a pointer to the object's location in memory. The type of an object, also known as the object's class, describes the object's internal representation as well as the methods and operations it supports. Once an instance of an object is created, its identity and type cannot be changed.</p>
<p>We can get the identity of an object by using the built-in function <kbd>id()</kbd>. This returns an identifying integer and on most systems this refers to its memory location, although you should not rely on this in any of your code.</p>
<p>Also, there are a number of ways to compare objects, for example:</p>
<pre>
    if a== b: #a and b have the same value <br/><br/>    if a is b: # if a and b are the same object <br/>    if type(a) is type(b): # a and b are the same type 
</pre>
<p>An important distinction needs to be made between <strong>mutable</strong> and <strong>immutable</strong> objects. Mutable object's such as lists can have their values changed. They have methods, such as <kbd>insert()</kbd> or <kbd>append()</kbd>, that change an objects value. Immutable objects, such as strings, cannot have their values changed, so when we run their methods, they simply return a value rather than change the value of an underlying object. We can, of course, use this value by assigning it to a variable or using it as an argument in a function.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Strings</h1>
            </header>

            <article>
                
<p>Strings are immutable sequence objects, with each character representing an element in the sequence. As with all objects, we use methods to perform operations. Strings, being immutable, do not change the instance; each method simply returns a value. This value can be stored as another variable or given as an argument to a function or method.</p>
<p>The following table is a list of some of the most commonly used string methods and their descriptions:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Methods</strong></p>
</td>
<td>
<p><strong>Descriptions</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.count(substring, [start,end])</kbd></p>
</td>
<td>
<p>Counts the occurrences of a substring with optional start and end parameters.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.expandtabs([tabsize])</kbd></p>
</td>
<td>
<p>Replaces tabs with spaces.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.find(substring, [start, end])</kbd></p>
</td>
<td>
<p>Returns the index of the first occurrence of a substring or returns <kbd>-1</kbd> if the substring is not found.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.isalnum()</kbd></p>
</td>
<td>
<p>Returns <kbd>True</kbd> if all characters are alphanumeric, returns <kbd>False</kbd> otherwise.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.isalpha()</kbd></p>
</td>
<td>
<p>Returns <kbd>True</kbd> if all characters are alphabetic, returns <kbd>False</kbd> otherwise.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.isdigit()</kbd></p>
</td>
<td>
<p>Returns <kbd>True</kbd> if all characters are digits, returns <kbd>False</kbd> otherwise.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.join(t)</kbd></p>
</td>
<td>
<p>Joins the strings in sequence <kbd>t</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.lower()</kbd></p>
</td>
<td>
<p>Converts the string to all lowercase.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.replace(old, new [maxreplace])</kbd></p>
</td>
<td>
<p>Replaces old substring with new substring.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.strip([characters])</kbd></p>
</td>
<td>
<p>Removes whitespace or optional characters.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.split([separator], [maxsplit])</kbd></p>
</td>
<td>
<p>Splits a string separated by whitespace or an optional separator. Returns a list.</p>
</td>
</tr>
</tbody>
</table>
<p>Strings, like all sequence types, support indexing and slicing. We can retrieve any character from a string by using its index <kbd>s[i]</kbd>. We can retrieve a slice of a string by using <kbd>s[i:j]</kbd>, where <kbd>i</kbd> and <kbd>j</kbd> are the start and end points of the slice. We can return an extended slice by using a stride, as in the following: <kbd>s[i:j:stride]</kbd>. The following code should make this clear:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="151" src="assets/image_01_005.png" width="177"/></div>
<p>The first two examples are pretty straightforward, returning the character located at index <kbd>1</kbd> and the first seven characters of the string, respectively. Notice that indexing begins at <kbd>0</kbd>. In the third example, we are using a stride of <kbd>2</kbd>. This results in every second character being returned. In the final example, we omit the end index and the slice returns every second character in the entire string.</p>
<p>You can use any expression, variable, or operator as an index as long as the value is an integer, for example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="58" src="assets/image_01_006.png" width="160"/></div>
<p>Another common operation is traversing through a string with a loop, for example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="75" src="assets/image_01_007.png" width="292"/></div>
<p>Given that strings are immutable, a common question that arises is how we perform operations such inserting values. Rather than changing a string, we need to think of ways to build new string objects for the results we need. For example, if we wanted to insert a word into our greeting, we could assign a variable to the following:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_008.png"/></div>
<p>As this code shows, we use the slice operator to split the string at index position <kbd>5</kbd> and use <kbd>+</kbd> to concatenate. Python never interprets the contents of a string as a number. If we need to perform mathematical operations on a string, we need to first convert them to a numeric type, for example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_009.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Lists</h1>
            </header>

            <article>
                
<p>Lists are probably the most used built-in data structures in Python because they can be composed of any number of other data types. They are a simple representation of arbitrary objects. Like strings, they are indexed by integers starting with zero. The following table contains the most commonly used list methods and their descriptions:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>list(s)</kbd></p>
</td>
<td>
<p>Returns a list of the sequence <kbd>s</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.append(x)</kbd></p>
</td>
<td>
<p>Appends element <kbd>x</kbd> to the end of <kbd>s</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.extend(x)</kbd></p>
</td>
<td>
<p>Appends the list <kbd>x</kbd> to <kbd>s</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.count(x)</kbd></p>
</td>
<td>
<p>Counts the occurrence of <kbd>x</kbd> in <kbd>s</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.index(x, [start], [stop])</kbd></p>
</td>
<td>
<p>Returns the smallest index, <kbd>i</kbd>, where <kbd>s[i] ==x</kbd>. Can include optional start and stop index for the search.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.insert(i,e)</kbd></p>
</td>
<td>
<p>Inserts <kbd>x</kbd> at index <kbd>i</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.pop(i)</kbd></p>
</td>
<td>
<p>Returns the element <kbd>i</kbd> and removes it from the list.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.remove(x)</kbd></p>
</td>
<td>
<p>Removes <kbd>x</kbd> from <kbd>s</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.reverse()</kbd></p>
</td>
<td>
<p>Reverses the order of <kbd>s</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.sort(key ,[reverse])</kbd></p>
</td>
<td>
<p>Sorts <kbd>s</kbd> with optional key and reverse.</p>
</td>
</tr>
</tbody>
</table>
<p>When we are working with lists, and other <em>container</em> objects, it is important to understand the internal mechanism that Python uses to copy them. Python creates real copies only if it has to. When we assign the value of a variable to another variable, both of these variables point to the same memory location. A new slot in memory will only be allocated if one of the variables changes. This has important consequences for mutable compound objects such as lists. Consider the following code:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="113" src="assets/image_01_010.png" width="153"/></div>
<p>Here, both the <kbd>list1</kbd> and <kbd>list2</kbd> variables point to the same slot in memory. When we change the <kbd>y</kbd> variable to <kbd>4</kbd>, we are changing the same <kbd>y</kbd> variable that <kbd>list1</kbd> is pointing to.</p>
<p>An important feature of list's is that they can contain nested structures, that is, other lists, for example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_011.png"/></div>
<p>We can access the lists values using the bracket operators and since lists are mutable, they are copied in place. The following example demonstrates how we can use this to update elements; for example, here we are raising the price of flour by 20 percent:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_012.png"/></div>
<p>A common and very intuitive way to create lists from expressions is using <strong>list comprehensions.</strong> This allows us to create a list by writing an expression directly into the list, for example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_013.png"/></div>
<p>List comprehensions can be quite flexible; for example, consider the following code. It essentially shows two different ways to performs a function composition, where we apply one function (<kbd>x * 4</kbd>) to another (<kbd>x * 2</kbd>). The following code prints out two lists representing the function composition of <kbd>f1</kbd> and <kbd>f2</kbd> calculated first using a <kbd>for</kbd> loop and then using a list comprehension:</p>
<pre>
    def f1(x): return x*2 <br/>    def f2(x): return x*4 <br/><br/>    lst = [] <br/>    for i in range(16): <br/>        lst.append(f1(f2(i))) <br/><br/>    print(lst) <br/><br/>    print([f1(x)  for x in range(64) if x in [f2(j) for j in range(16)]]) 
</pre>
<p>The first line of output is from the for loop construct. The second is from the list comprehension expression:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_014.png"/></div>
<p>List comprehensions can also be used to replicate the action of nested loops in a more compact form. For example, we multiply each of the elements contained within <kbd>list1</kbd> with each other:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_015.png"/></div>
<p>We can also use list comprehensions with other objects such as strings, to build more complex structures. For example, the following code creates a list of words and their letter count:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_016.png"/></div>
<p>As we will see, lists form the foundation of many of the data structures we will look at. Their versatility, ease of creation, and use enables them to build more specialized and complex data structures.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Functions as first class objects</h1>
            </header>

            <article>
                
<p>In Python, it is not only data types that are treated as objects. Both functions and classes are what are known as first class objects, allowing them to be manipulated in the same ways as built-in data types. By definition, first class objects are:</p>
<ul>
<li>Created at runtime</li>
<li>Assigned as a variable or in a data structure</li>
<li>Passed as an argument to a function</li>
<li>Returned as the result of a function</li>
</ul>
<p>In Python, the term <strong>first class object</strong> is a bit of a misnomer since it implies some sort of hierarchy, whereas all Python objects are essentially first class.</p>
<p>To have a look at how this works, let's define a simple function:</p>
<pre>
    def greeting(language): <br/>    if language== 'eng': <br/>             return 'hello world' <br/>       if language  == 'fr' <br/>             return 'Bonjour le monde' <br/>       else: return 'language not supported' 
</pre>
<p>Since user-defined functions are objects, we can do things such as include them in other objects, such as lists:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="53" src="assets/image_01_017.png" width="365"/></div>
<p>Functions can also be used as arguments for other functions. For example, we can define the following function:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="86" src="assets/image_01_018.png" width="186"/></div>
<p>Here, <kbd>callf()</kbd> takes a function as an argument, sets a language variable to <kbd>'eng'</kbd>, and then calls the function with the language variable as its argument. We could see how this would be useful if, for example, we wanted to produce a program that returns specific sentences in a variety of languages, perhaps for some sort of natural language application. Here we have a central place to set the language. As well as our <kbd>greeting</kbd> function, we could create similar functions that return different sentences. By having one point where we set the language, the rest of the program logic does not have to worry about this. If we want to change the language, we simply change the language variable and we can keep everything else the same.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Higher order functions</h1>
            </header>

            <article>
                
<p>Functions that take other functions as arguments, or that return functions, are called <strong>higher order functions</strong>. Python 3 contains two built-in higher order functions, <kbd>filter()</kbd> and <kbd>map()</kbd>. Note that in earlier versions of Python, these functions returned lists; in Python 3, they return an iterator, making them much more efficient. The <kbd>map()</kbd> function provides an easy way to transform each item into an iterable object. For example, here is an efficient, compact way to perform an operation on a sequence. Note the use of the <kbd>lambda</kbd> anonymous function:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="64" src="assets/image_01_019.png" width="276"/></div>
<p>Similarly, we can use the <kbd>filter</kbd> built-in function to filter items in a list:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_020.png"/></div>
<p>Note that both <kbd>map</kbd> and <kbd>filter</kbd> perform the identical function as to what can be achieved by list comprehensions. There does not seem to be a great deal of difference in the performance characteristics apart from a slight performance advantage when using the in built functions <kbd>map</kbd> and <kbd>filter</kbd> without the <kbd>lambda</kbd> operator, compared to list comprehensions. Despite this, most style guides recommend the use of list comprehensions over built-in functions, possibly because they tend to be easier to read.</p>
<p>Creating our own higher order functions is one of the hallmarks of functional programming style. A practical example of how higher order functions can be useful is demonstrated by the following. Here we are passing the <kbd>len</kbd> function as the key to the <kbd>sort</kbd> function. This way, we can sort a list of words by length:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_021.png"/></div>
<p>Here is another example for case-insensitive sorting:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="156" src="assets/image_01_022.png" width="272"/></div>
<p>Note the difference between the <kbd>list.sort()</kbd> method and the <kbd>sorted</kbd> built-in function. <kbd>list.sort()</kbd>, a method of the <kbd>list</kbd> object, sorts the existing instance of a list without copying it. This method changes the target object and returns <kbd>None</kbd>. It is an important convention in Python that functions or methods that change the object return <kbd>None</kbd> to make it clear that no new object was created and that the object itself was changed.</p>
<p>On the other hand, the sorted built-in function returns a new list. It actually accepts any iterable object as an argument, but it will always return a list. Both <kbd>list sort</kbd> and <kbd>sorted</kbd> take two optional keyword arguments as key.</p>
<p>A simple way to sort more complex structures is to use the index of the element to sort using the <kbd>lambda</kbd> operator, for example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_023.png"/></div>
<p>Here we have sorted the items by price.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Recursive functions</h1>
            </header>

            <article>
                
<p>Recursion is one of the most fundamental concepts of computer science. In Python, we can implement a recursive function simply by calling it within its own function body. To stop a recursive function turning into an infinite loop, we need at least one argument that tests for a terminating case to end the recursion. This is sometimes called the base case. It should be pointed out that recursion is different from iteration. Although both involve repetition, iteration loops through a sequence of operations, whereas recursion repeatedly calls a function. Both need a selection statement to end. Technically, recursion is a special case of iteration known as tail iteration, and it is usually always possible to convert an iterative function to a recursive function and vice versa. The interesting thing about recursive functions is that they are able to describe an infinite object within a finite statement.</p>
<p>The following code should demonstrate the difference between recursion and iteration. Both these functions simply print out numbers between <kbd>low</kbd> and <kbd>high</kbd>, the first one using iteration and the second using recursion:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="102" src="assets/image_01_024.png" width="207"/></div>
<p>Notice, <kbd>iterTest</kbd>, the iteration example, we use a <kbd>while</kbd> statement to test for the condition, then call the <kbd>print</kbd> method, and finally increment the <kbd>low</kbd> value. The recursive example tests for the condition, prints, then calls itself, incrementing the <kbd>low</kbd> variable in its argument. In general, iteration is more efficient; however, recursive functions are often easier to understand and write. Recursive functions are also useful for manipulating recursive data structures such as linked lists and trees, as we will see.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Generators and co-routines</h1>
            </header>

            <article>
                
<p>We can create functions that do not just return one result, but rather an entire sequence of results, by using the <kbd>yield</kbd> statement. These functions are called <strong>generators.</strong> Python contains generator functions, which are an easy way to create iterators and they are especially useful as a replacement for unworkably long lists. A generator yields items rather than build lists. For example, the following code shows why we might choose to use a generator as opposed to creating a list:</p>
<pre>
    # compares the running time of a list compared to a generator <br/>    import time <br/>    #generator function creates an iterator of odd numbers between n and m <br/>    def oddGen(n, m):         <br/>        while n &lt; m: <br/>            yield n <br/>            n += 2 <br/>    #builds a list of odd numbers between n and m <br/>    def oddLst(n,m): <br/>        lst=[] <br/>        while n&lt;m: <br/>            lst.append(n) <br/>            n +=2 <br/>        return lst <br/>    #the time it takes to perform sum on an iterator    <br/>    t1=time.time() <br/>    sum(oddGen(1,1000000)) <br/>    print("Time to sum an iterator: %f" % (time.time() - t1)) <br/><br/>    #the time it takes to build and sum a list <br/>    t1=time.time() <br/>    sum(oddLst(1,1000000)) <br/>    print("Time to build and sum a list: %f" % (time.time() - t1))      
</pre>
<p>This prints out the following:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="33" src="assets/image_01_025.png" width="266"/></div>
<p>As we can see, building a list to do this calculation takes significantly longer. The performance improvement as a result of using generators is because the values are generated on demand, rather than saved as a list in memory. A calculation can begin before all the elements have been generated and elements are generated only when they are needed.</p>
<p>In the preceding example, the <kbd>sum</kbd> method loads each number into memory when it is needed for the calculation. This is achieved by the generator object repeatedly calling the <kbd>__next__()</kbd> special method. Generators never return a value other than <kbd>None</kbd>.</p>
<p>Typically, generator objects are used in <kbd>for</kbd> loops. For example, we can make use of the <kbd>oddcount</kbd> generator function created in the preceding code to print out odd integers between <kbd>1</kbd> and <kbd>10</kbd>:</p>
<pre>
    for i in oddcount(1,10):print(i) 
</pre>
<p>We can also create a <strong>generator expression,</strong> which, apart from replacing square brackets with parentheses, uses the same syntax and carries out the same operation as list comprehensions. Generator expressions, however, do not create a list, they create a <strong>generator object</strong>. This object does not create the data, but rather creates that data on demand. This means that generator objects do not support sequence methods such as <kbd>append()</kbd> and <kbd>insert()</kbd>. You can, however, change a generator into a list using the <kbd>list()</kbd> function:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="131" src="assets/image_01_026.png" width="334"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Classes and object programming</h1>
            </header>

            <article>
                
<p>Classes are a way to create new kinds of objects and they are central to object-oriented programming. A class defines a set of attributes that are shared across instances of that class. Typically, classes are sets of functions, variables, and properties.</p>
<p>The object-oriented paradigm is compelling because it gives us a concrete way to think about and represent the core functionality of our programs. By organizing our programs around objects and data rather than actions and logic, we have a robust and flexible way to build complex applications. The actions and logic are still present of course, but by embodying them in objects, we have a way to encapsulate functionality, allowing objects to change in very specific ways. This makes our code less error-prone, easier to extend and maintain, and able to model real-world objects.</p>
<p>Classes are created in Python using the <kbd>class</kbd> statement. This defines a set of shared attributes associated with a collection of class instances. A class usually consists of a number of methods, class variables, and computed properties. It is important to understand that defining a class does not, by itself, create any instances of that class. To create an instance, a variable must be assigned to a class. The class body consists of a series of statements that execute during the class definition. The functions defined inside a class are called <strong>instance methods.</strong> They apply some operations to the class instance by passing an instance of that class as the first argument. This argument is called <kbd>self</kbd> by convention, but it can be any legal identifier. Here is a simple example:</p>
<pre>
    class Employee(object): <br/>        numEmployee = 0 <br/>        def __init__(self, name, rate): <br/>            self.owed = 0         <br/>            self.name = name <br/>            self.rate=rate <br/>            Employee.numEmployee += 1 <br/><br/>        def __del__(self): <br/>            Employee.numEmployee -= 1 <br/><br/>        def hours(self, numHours): <br/>            self.owed += numHours * self.rate <br/>            return("%.2f hours worked" % numHours) <br/><br/>        def pay(self):                 <br/>            self.owed = 0 <br/>            return("payed %s " % self.name) 
</pre>
<p>Class variables, such as <kbd>numEmployee</kbd>, share values among all the instances of the class. In this example, <kbd>numEmployee</kbd> is used to count the number of employee instances. Note that the <kbd>Employee</kbd> class implements the <kbd>__init__</kbd> and <kbd>__del__</kbd> special methods, which we will discuss in the next section.</p>
<p>We can create instances of the <kbd>Employee</kbd> objects, run methods, and return class and instance variables by doing the following:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="204" src="assets/image_01_027.png" width="275"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Special methods</h1>
            </header>

            <article>
                
<p>We can use the <kbd>dir(object)</kbd> function to get a list of attributes of a particular object. The methods that begin and end with two underscores are called <strong>special methods.</strong> Apart from the following exception<strong>,</strong> special method, are generally called by the Python interpreter rather than the programmer; for example, when we use the <kbd>+</kbd> operator, we are actually invoking a call to <kbd>__add__()</kbd>. For example, rather than using <kbd>my_object.__len__()</kbd> we can use <kbd>len(my_object)</kbd> using <kbd>len()</kbd> on a string object is actually much faster because it returns the value representing the object's size in memory, rather than making a call to the object's <kbd>__len__</kbd> method. The only special method we actually call in our programs, as common practice, is the <kbd>__init__</kbd> method, to invoke the initializer of the superclass in our own class definitions. It is strongly advised not to use the double underscore syntax for your own objects because of potential current or future conflicts with Python's own special methods.</p>
<p>We may, however, want to implement special methods in custom objects, to give them some of the behavior of built-in types. In the following code, we create a class that implements the <kbd>__repr__</kbd> method. This method creates a string representation of our object that is useful for inspection purposes:</p>
<pre>
    class my_class(): <br/>        def __init__(self, greet): <br/>            self.greet = greet <br/>        def __repr__(self): <br/>            return 'a custom object (%r)' % (self.greet) 
</pre>
<p>When we create an instance of this object and inspect it, we can see we get our customized string representation. Notice the use of the <kbd>%r</kbd> format placeholder to return the standard representation of the object. This is useful and best practice, because, in this case, it shows us that the <kbd>greet</kbd> object is a string indicated by the quotation marks:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_028.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Inheritance</h1>
            </header>

            <article>
                
<p>It is possible to create a new class that modifies the behavior of an existing class through inheritance. This is done by passing the inherited class as an argument in the class definition. It is often used to modify the behavior of existing methods, for example:</p>
<pre>
    class specialEmployee(Employee): <br/>        def hours(self, numHours): <br/>            self.owed += numHours * self.rate * 2 <br/>            return("%.2f hours worked" % numHours)    
</pre>
<p>An instance of the <kbd>specialEmployee</kbd> class is identical to an <kbd>Employee</kbd> instance except for the changed <kbd>hours()</kbd> method.</p>
<p>For a subclass to define new class variables, it needs to define an <kbd>__init__()</kbd> method, as follows:</p>
<pre>
    class specialEmployee(Employee): <br/>        def __init__(self,name,rate, bonus): <br/>            Employee.__init__(self, name, rate) #calls the base classes <br/>            self.bonus = bonus <br/><br/>        def hours(self, numHours): <br/>            self.owed += numHours * self.rate + self.bonus  <br/>            return("%.2f hours worked" % numHours)      
</pre>
<p>Notice that the methods of the base class are not automatically invoked and it is necessary for the derived class to call them. We can test for class membership using the built-in function <kbd>isintance(obj1, obj2)</kbd>. This returns true if <kbd>obj1</kbd> belongs to the class of <kbd>obj2</kbd> or any class derived from <kbd>obj2</kbd>.</p>
<p>Within a class definition, it is assumed that all methods operate on the instance, but this is not a requirement. There are, however, other types of methods: <strong>static methods</strong> and <strong>class methods</strong>. A static method is just an ordinary function that just happens to be defined in a class. It does not perform any operations on the instance and it is defined using the <kbd>@staticmethod</kbd> class decorator. Static methods cannot access the attributes of an instance, so their most common usage is as a convenience to group utility functions together.</p>
<p>Class methods operate on the class itself, not the instance, in the same way that class variables are associated with the classes rather than instances of that class. They are defined using the <kbd>@classmethod</kbd> decorator, and are distinguished from instance methods in that the class is passed as the first argument. This is named <kbd>cls</kbd> by convention.</p>
<pre>
    class Aexp(object): <br/>        base=2 <br/>        @classmethod <br/>        def exp(cls,x): <br/>            return(cls.base**x) <br/><br/>    class Bexp(Aexp): <br/>            base=3 
</pre>
<p>The class <kbd>Bexp</kbd> inherits from the <kbd>Aexp</kbd> class and changes the base class variable to <kbd>3</kbd>. We can run the parent class's <kbd>exp()</kbd> method as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_01_029.png"/></div>
<p>Although this example is a little contrived, there are several reasons why class methods may be useful. For example, because a subclass inherits all the same features of its parent, there is the potential for it to break inherited methods. Using class methods is a way to define exactly what methods are run.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Data encapsulation and properties</h1>
            </header>

            <article>
                
<p>Unless otherwise specified, all attributes and methods are accessible without restriction. This also means that everything defined in a base class is accessible from a derived class. This may cause problems when we are building object-oriented applications where we may want to hide the internal implementation of an object. This can lead to namespace conflicts between objects defined in derived classes with the base class. To prevent this, the methods we define private attributes with have a double underscore, such as <kbd>__privateMethod()</kbd>. These method names are automatically changed to <kbd>_Classname__privateMethod()</kbd> to prevent name conflicts with methods defined in base classes. Be aware that this does not strictly hide private attributes, rather it just provides a mechanism for preventing name conflicts.</p>
<p>It is recommended to use private attributes when using a class <strong>property</strong> to define mutable attributes. A property is a kind of attribute that rather than returning a stored value, computes its value when called. For example, we could redefine the <kbd>exp()</kbd> property with the following:</p>
<pre>
    class Bexp(Aexp): <br/>        __base=3 <br/>        def __exp(self): <br/>            return(x**cls.base)     
</pre>
<p>In this chapter, we have looked at some of the fundamentals of the Python programming language, from basic operations to functions, classes, and objects in Python. In the next chapter, we will examine, in detail, the built-in data structures of Python.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>This chapter has given us a good foundation and introduction into Python programming. We covered the use of variables, lists, a couple of control structures, and learned how to use conditionals statement. The various kinds of objects were discussed, together with some materials on the object-oriented aspects of the Python language. We created our own objects and inherited from them.</p>
<p>There is still more that Python offers. As we prepare to examine the later chapters on some implementations of algorithms, the next chapter will focus on numbers, sequences, maps, and sets. These are also data types in Python that prove useful when organizing data for a series of operations.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>