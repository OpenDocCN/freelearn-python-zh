- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User Inputs and Outputs
  prefs: []
  type: TYPE_NORMAL
- en: The key purpose of software is to produce useful output. Of the many possible
    outputs, one simple type of output is text displaying a useful result. Python
    supports this with the print() function.
  prefs: []
  type: TYPE_NORMAL
- en: The input() function has a parallel with the print() function. The input() function
    reads text from a console, allowing us to provide data to our programs. The use
    of print() and input() creates an elegant symmetry between input and output from
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of other common ways to provide input to a program. Parsing
    the command line is helpful for many applications. We sometimes need to use configuration
    files to provide useful input. Data files and network connections are yet more
    ways to provide input. Each of these methods is distinct and needs to be looked
    at separately. In this chapter, we’ll focus on the fundamentals of input() and
    print().
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the features of the print() function](ch010.xhtml#x1-3310001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using input() and getpass() for user input](ch010.xhtml#x1-3370002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Debugging with f”{value=}” strings](ch010.xhtml#x1-3430003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using argparse to get command-line input](ch010.xhtml#x1-3490004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using invoke to get command-line input](ch010.xhtml#x1-3550005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using cmd to create command-line applications](ch010.xhtml#x1-3610006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the OS environment settings](ch010.xhtml#x1-3670007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It seems best to start with the print() function and show several of the things
    it can do. After all, it’s often the output from an application that is most useful.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Using the features of the print() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In many cases, the print() function is the first function we learn about. The
    first script is often a variation on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The print() function can display multiple values, with helpful spaces between
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can see that a space separator is included for us. Additionally, a line break,
    usually represented by the \n character, is printed after the values provided
    in the function.
  prefs: []
  type: TYPE_NORMAL
- en: Can we control this formatting? Can we change the extra characters that are
    supplied?
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider this spreadsheet, used to record fuel consumption on a large sailboat.
    The CSV file has rows that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this data, refer to the [Shrinking sets – remove(),
    pop(), and difference](ch008_split_001.xhtml#x1-2750008) and [Slicing and dicing
    a list](ch008_split_000.xhtml#x1-2400003) recipes in Chapter [4](ch008_split_000.xhtml#x1-2240004).
    Instead of a sensor inside the tank, the depth of fuel is observed through a glass
    panel on the side of the tank. Knowing the tank is approximately rectangular,
    with a full depth of about 31 inches and a volume of about 72 gallons, it’s possible
    to convert depth to volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using this CSV data. This function reads the file and
    returns a list of fields built from each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of reading and printing rows from the CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The output from the print() function, shown here in long lines, is challenging
    to use. Let’s look at how we can improve this output using additional features
    of the print() function.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two ways to control the print() function output format:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the inter-field separator string, sep. The default value is a single-space
    character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the end-of-line string, end. The default value is the \n character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This recipe will show several variations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each item in the data, make any useful data conversions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following alternatives show different ways to include separators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Print labels and fields using the default values of sep and end:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: When we look at the output, we can see where a space was inserted between each
    item.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When preparing data, we might want to use a format that’s similar to CSV, perhaps
    using a column separator that’s not a simple comma. We can print labels and fields
    using a string value of " | " for the sep parameter:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In this case, we can see that each column has the given separator string. Since
    there were no changes to the end setting, each print() function produces a distinct
    line of output.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s how we might change the default punctuation to emphasize the field name
    and value. We can print labels and fields using a string value of "=" for the
    sep parameter and ", " for the end parameter:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Since the string used at the end of the line was changed to ", ", each use of
    the print() function no longer produces separate lines. In order to see a proper
    end of line, the final print() function has a default value for end. We could
    also have used an argument value of end="\n" to make the presence of the newline
    character explicit.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 6.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The print() function has a definition that includes several parameters that
    must be provided as keywords. Two of these are the sep and end keyword parameters,
    with default values of space and newline, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Using the print() function’s sep and end parameters can get quite complex for
    anything more sophisticated than these simple examples. Rather than working with
    a complex sequence of print() function requests, we can use the format() method
    of a string, or use an f-string.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sys module defines the two standard output files that are always available:
    sys.stdout and sys.stderr. Generally, the print() function can be thought of as
    a handy wrapper around sys.stdout.write().'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the file= keyword argument to write to the standard error file instead
    of writing to the standard output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We’ve imported the sys module so that we have access to the standard error file.
    We used this to write a message that will not be part of the standard output stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because these two files are always available, using OS file redirection techniques
    often works out nicely. When our program’s primary output is written to sys.stdout,
    it can be redirected at the OS level. A user might enter a shell command line
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will provide the input.dat file as the input to sys.stdin. When this Python
    program writes to sys.stdout, the output will be redirected by the OS to the output.dat
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we need to open additional files. In that case, we might see
    programming like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve opened a specific path for the output and assigned the
    open file to target_file, using the with statement. We can then use this as the
    file= value in a print() function to write to this file. Because a file is a context
    manager, leaving the with statement means that the file will be closed properly;
    all of the OS resources will be released from the application. All file operations
    should be wrapped in a with statement context to ensure that the resources are
    properly released.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more formatting options, see the [Debugging with f”{value=}” strings](ch010.xhtml#x1-3430003)
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on the input data in this example, refer to the [Shrinking
    sets – remove(), pop(), and difference](ch008_split_001.xhtml#x1-2750008) and
    [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipes in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on file operations in general, refer to Chapter [8](ch012.xhtml#x1-4520008)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.2 Using input() and getpass() for user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some Python scripts depend on gathering input from a user. There are several
    ways to do this. One popular technique is to use the console to prompt a user
    for input interactively.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two relatively common situations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordinary input: This will provide a helpful echo of the characters being entered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Secure, no echo input: This is often used for passwords. The characters entered
    aren’t displayed, providing a degree of privacy. We use the getpass() function
    in the getpass module for this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an alternative to interactive input, we’ll look at some other approaches
    in the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The input() and getpass() functions are just two implementation choices to read
    from the console. It turns out that getting the string of characters is only the
    first step in gathering useful data. The input also needs to be validated.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at a technique to read a complex structure from a person. In this
    case, we’ll use year, month, and day as separate items. These items are then combined
    to create a complete date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick example of user input that omits all of the validation considerations.
    This is poor design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While it is very easy to use the input() function, it lacks a number of helpful
    features. When the user enters an invalid date, this will raise a potentially
    confusing exception.
  prefs: []
  type: TYPE_NORMAL
- en: We often need to wrap the input() function with data validation processing to
    make it more useful. The calendar is complex, and we’d hate to accept February
    31 without warning the user that it is not a proper date.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the input is a password or something equally subject to redaction, the input()
    function isn’t the best choice. If passwords or other secrets are involved, then
    use the getpass.getpass() function. This means we need the following import when
    secrets are involved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Otherwise, when secret input is not required, we’ll use the built-in input()
    function, and no additional import is required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Determine which prompt will be used. In our example, we provided a field name
    and a hint about the type of data expected as the prompt string argument to the
    input() or getpass() functions. It can help to separate the input from the text-to-integer
    conversion. This recipe doesn’t follow the snippet shown previously; it breaks
    the operation into two separate steps. First, get the text value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine how to validate each item in isolation. The simplest case is a single
    value with a single rule that covers everything. In more complex cases – like
    this one – each individual element is a number with a range constraint. In a later
    step, we’ll look at validating the composite item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wrap the input and validation into a while-try block that looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This applies a single validation rule, the int(year_txt) expression, to ensure
    that the input is an integer. The while statement leads to a repeat of the input
    and conversion sequence of steps until the value of the year variable is not None.
  prefs: []
  type: TYPE_NORMAL
- en: Raising an exception for faulty input allows us some flexibility. We can extend
    this with additional exception classes for other conditions the input must meet.
  prefs: []
  type: TYPE_NORMAL
- en: This processing only covers the year field. We still need to get values for
    the month and day fields. This means we’ll need three nearly identical loops for
    each of these three fields of a complex date object. Rather than copying and pasting
    nearly identical code, we need to restructure this processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll define a new function, get_integer(), for general-purpose input of a
    numeric value. Here’s the complete function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine this into an overall process to get the three integers of a
    date. This will involve a similar while-try design pattern but applied to the
    composite object. It will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This uses individual while-try processing sequences around the sequence of get_integer()
    functions to get the individual values that make up a date. Then, it uses the
    date() constructor to create a date object from the individual fields. If the
    date object – as a whole – can’t be built because the pieces are invalid, then
    the year, month, and day must be reentered to create a valid date.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to decompose the input problem into several separate but closely related
    problems. To do this, imagine a tower of conversion steps. At the bottom layer
    is the initial interaction with the user. We identified two of the common ways
    to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'input(): This prompts and reads from a user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'getpass.getpass(): This prompts and reads input (like passwords) without a
    visible echo'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two functions provide the essential console interaction. There are other
    libraries that can provide more sophisticated interactions, if that’s required.
    For example, the Click project has some helpful prompting capabilities. See [https://click.palletsprojects.com/en/7.x/](https://click.palletsprojects.com/en/7.x/).
  prefs: []
  type: TYPE_NORMAL
- en: The Rich project has extremely sophisticated terminal interaction. See [https://rich.readthedocs.io/en/latest/](https://rich.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of the foundation, we’ve built several tiers of validation processing.
    The tiers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A data type validation: This uses built-in conversion functions such as int()
    or float(). These raise a ValueError exception for invalid text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A domain validation: This uses an if statement to determine whether values
    fit any application-specific constraints. For consistency, this should also raise
    a ValueError exception if the data is invalid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Composite object validation: This is application-specific checking. For our
    example, the composite object was an instance of datetime.date. This also tends
    to raise ValueError exceptions for dates that are invalid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of potential kinds of constraints that might be imposed on values.
    We’ve used the valid date constraint because it’s particularly complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have several alternatives for user input that involve slightly different
    approaches. We’ll look at these two topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex text: This will involve the simple use of input() with more sophisticated
    parsing of the source text. Instead of prompting for individual fields, it might
    be better to accept a string in the yyyy-mm-dd format and use the strptime() parser
    to extract a date. This doesn’t change the design pattern; it replaces an int()
    or float() with something a bit more complicated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interaction via the cmd module: This involves a more complex class to control
    interaction. We’ll look at this closely in the [Using cmd to create command-line
    applications](ch010.xhtml#x1-3610006) recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of potential input validation rules can be extracted from JSON schema
    definitions. This list of types includes Boolean, integer, float, and string.
    A number of common string formats defined in JSON schema include date-time, time,
    date, email, hostname, IP addresses in the version 4 and version 6 formats, and
    URIs.
  prefs: []
  type: TYPE_NORMAL
- en: Another source of user input validation rules can be found in the definition
    of the HTML5 <input> tag. This list includes color, date, datetime-local, email,
    file, month, number, password, telephone numbers, time, URL, and week-year.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Using cmd to create command-line applications](ch010.xhtml#x1-3610006)
    recipe in this chapter for complex interaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    to gather user input from the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the reference material for the SunOS operating system, which is now owned
    by Oracle, there is a collection of commands that prompt for different kinds of
    user inputs: [https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html](https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.3 Debugging with f”{value=}” strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important debugging and design tools available in Python is
    the print() function. The two formatting options shown in the [Using the features
    of the print() function](ch010.xhtml#x1-3310001) recipe don’t offer a lot of flexibility.
    We have more flexibility with f"string" formatting. We’ll build on some of the
    recipes shown in Chapter [1](ch005_split_000.xhtml#x1-170001), [Numbers, Strings,
    and Tuples](ch005_split_000.xhtml#x1-170001).
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a multi-step process that involves some moderately complex calculations.
    We’ll compute the mean and standard deviation of some sample data. Given these
    values, we’ll locate all items that are more than one standard deviation above
    the mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This calculation has several working variables. The final list comprehension
    involves three other variables, mean_size, std_size, and sig1\. With so many values
    used to filter the size list, it’s difficult to visualize what’s going on. It’s
    often helpful to know the steps in the calculation; showing the values of the
    intermediate variables can be very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The f"{name=}" string will have both the literal string name= and the value
    for the name expression. This is often a variable, but any expression can be used.
    Using this with a print() function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can use {name=} to put any variable into the f-string and see the value.
    These examples in the code above include a suffix of :.2f as the format specification
    to show the values rounded to two decimal places. Another common suffix is !r
    to show the internal representation of the object; we might use f"{name=!r}".
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more background on the formatting options, refer to the [Building complicated
    strings with f-strings](ch005_split_000.xhtml#x1-410004) recipe in Chapter [1](ch005_split_000.xhtml#x1-170001).
  prefs: []
  type: TYPE_NORMAL
- en: There is a very handy extension to this capability. We can use any expression
    on the left of the = in the f-string. This will show the expression and the value
    computed by the expression, providing us with even more debugging information.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the extended expression capability of f-strings to include additional
    calculations that aren’t simply the values’ local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We’ve computed a new value, mean_size+2*std_size, that appears only inside the
    formatted output. This lets us display intermediate computed results without having
    to create an extra variable.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the [Building complicated strings with f-strings](ch005_split_000.xhtml#x1-410004)
    recipe in Chapter [1](ch005_split_000.xhtml#x1-170001), for more of the things
    that can be done with f-strings and the format() method of a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the [Using the features of the print() function](ch010.xhtml#x1-3310001)
    recipe earlier in this chapter for other formatting options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.4 Using argparse to get command-line input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some applications, it can be better to get the user input from the OS command
    line without a lot of human interaction. We’d prefer to parse the command-line
    argument values and either perform the processing or report an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, at the OS level, we might want to run a program like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At the OS prompt of %, we entered a command, python ch06/distance_app.py. This
    command had an optional argument, -u KM, and two positional arguments of 36.12,-86.67
    and 33.94,-118.40.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user enters something incorrect, the interaction might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: An invalid argument value of -118asd leads to an error message. A user can hit
    the up-arrow key to get the previous command line back, make a change, and run
    the program again. The interactive user experience is delegated to OS command-line
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to refactor our code to create three separate
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: A function to get the arguments from the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that does the real work. The intent is to define a function that
    can be reused in a variety of contexts, one of which is with parameters from the
    command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A main function that gathers arguments and invokes the real work function with
    the appropriate argument values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s our real work function, display():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve imported the core calculation, haversine(), from the ch06.distance_computation
    module. We’ve based this on the calculations shown in the examples in the [Picking
    an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    recipe in Chapter [3](ch007_split_000.xhtml#x1-1610003):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the function looks when it’s used inside Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This function has two important design features. The first feature is that it
    avoids references to features of the argparse.Namespace object that’s created
    by argument parsing. Our goal is to have a function that we can reuse in a number
    of alternative contexts. We need to keep the input and output elements of the
    user interface separate.
  prefs: []
  type: TYPE_NORMAL
- en: The second design feature is that this function displays a value computed by
    another function. This is a decomposition of a larger problem into two smaller
    problems. We’ve separated the user experience of printed output from the essential
    calculation. (Both aspects are quite small, but the principle of separating these
    two aspects is important.)
  prefs: []
  type: TYPE_NORMAL
- en: 6.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the overall argument parsing function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the parser object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the various types of arguments to the parser object. Sometimes, this is
    difficult because we’re still refining the user experience. It’s difficult to
    imagine all the ways in which people will use a program and all of the questions
    they might have. For our example, we have two mandatory, positional arguments
    and an optional argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point 1 latitude and longitude
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Point 2 latitude and longitude
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional units of distance; we’ll provide nautical miles as the default:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve added a mix of optional and mandatory arguments. The -u argument starts
    with a dash to mark it as optional. A longer double dash version, --units, is
    supported as an alternative.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The mandatory, positional arguments are named without a prefix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate the parse_args() method of the parser object created in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, the parser uses the values from sys.argv, which are the command-line
    argument values entered by the user. Testing is much easier when we can provide
    an explicit argument value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the final function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This relies on a point_type() function to both validate the strings and convert
    the string to a (latitude, longitude) two-tuple. Here’s the definition of this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If anything goes wrong, an exception will be raised. From this exception, we’ll
    raise an ArgumentTypeError exception. This is caught by the argparse module and
    causes it to report the error to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the main script that combines the option parser and the output display
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This main script connects the user inputs to the displayed output. The details
    of error messages and help processing are delegated to the argparse module.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The argument parser works in three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the overall context by creating a parser object as an instance of the
    ArgumentParser class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add individual arguments with the add_argument() method. These can include optional
    arguments as well as required arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the actual command-line inputs, often based on sys.argv.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some simple programs will have a few optional arguments. A more complex program
    may have many optional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common to have a filename as a positional argument. When a program reads
    one or more files, the filenames can be provided in the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve used the Linux shell’s globbing feature: the *.rst string is expanded
    into a list of all files that match the naming rule. This is a feature of the
    Linux shell, and it happens before the Python interpreter starts. This list of
    files can be processed using an argument, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All of the arguments on the command line that do not start with the - character
    are positional arguments, and they are collected into the file value in the object
    built by the parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the following to process each of the given files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For Windows programs, the shell doesn’t glob filenames from wildcard patterns.
    This means the application must deal with filenames that contain wildcard characters
    like "*" and "?" in them. The Python glob module can help with this. Also, the
    pathlib module can create Path objects, which include globbing features to locate
    matching filenames in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What kinds of arguments can we process? There are a lot of argument styles
    in common use. All of these variations are defined using the add_argument() method
    of a parser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple options: Arguments of the form -o or --option often define optional
    features. These use the ’store_true’ or ’store_false’ actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Options with values: We showed -r unit as an option with a value. The ’store’
    action is how the value is saved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Options that increment a counter: The action ’count’ and default=0 permit an
    option that can be repeated. The verbose and very verbose logging options, -v
    and -vv, respectively, are an example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Options that accumulate a list: The action ’append’ and default=[] can accumulate
    multiple option values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Show the version number: A special action of ’version’ can be used to create
    an argument that will show the version number and exit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positional arguments do not have a leading ’-’ in their name. They must be defined
    in the order they will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The argparse module uses -h, and --help will display a help message and exit.
    These options are available unless changed by an argument that uses the ’help’
    action.
  prefs: []
  type: TYPE_NORMAL
- en: This covers most of the common cases for command-line argument processing. Generally,
    we’ll try to leverage these common styles of arguments when we write our own applications.
    If we strive to follow the widely used argument styles, our users are more likely
    to understand how our application works.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at how to get interactive user input in the [Using input() and getpass()
    for user input](ch010.xhtml#x1-3370002) recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at a way to add even more flexibility to this in the [Using the OS
    environment settings](ch010.xhtml#x1-3670007) recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.5 Using invoke to get command-line input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The [invoke](https://www.pyinvoke.org) package is not part of the standard
    library. It needs to be installed separately. Generally, this is done with the
    following terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using the python -m pip command ensures that we will use the pip command that
    goes with the currently active virtual environment, shown as cookbook3.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the [Using argparse to get command-line input](ch010.xhtml#x1-3490004)
    recipe in this chapter. It describes a command-line application that works something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The command will always be invoke. The Python path information is used to locate
    a module file named tasks.py to provide the definitions of the commands that can
    be invoked. The remaining command-line values are provided to a function defined
    in the tasks module.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, we’ll create a two-tiered design when using invoke. These two tiers
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: A function to get the arguments from the command line, do any validation or
    conversion required, and invoke the function to perform the real work. This function
    will be decorated with @task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that does the real work. It helps if this function is designed so
    that it makes no reference to the command-line options in any direct way. The
    intent is to define a function to be reused in a variety of contexts, one of which
    is with parameters from the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, these two functions can be merged into one. This often happens
    when Python is used as a wrapper to provide a simple interface for an underlying
    application that is bewilderingly complicated. In this kind of application, the
    Python wrapper may do very little processing, with no useful distinction between
    validating parameter values and doing the “real work” of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    in this chapter, the display() function is defined. This function does the “real
    work” of the application. When working with invoke, this design will continue
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a function that describes a task that can be invoked. It’s often essential
    to provide some help for the various parameters, which is done by providing a
    dictionary of parameter names and help text to the @task decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The docstring for the function becomes the help text provided by the invoke distance --help
    command. It’s very important to provide something that will help the user understand
    what the various commands will do and how to use them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Context parameter is required, but it won’t be used in this example. This
    object provides a consistent context when invoking multiple separate tasks. It
    also provides methods to run external applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Perform any needed conversions on the various parameter values. Evaluate the
    “real-work” function with cleaned values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve used sys.exit() to produce a failure message. It’s also possible to raise
    an exception, but this will show long traceback displays that may not be helpful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 6.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The invoke package examines the parameters for a given Python function and builds
    the necessary command-line parsing options. The parameter names become the names
    for options. In the example distance() function, the parameters of p1, p2, and
    u become the command-line options of --p1, --p2, and -u, respectively. This lets
    us provide the parameters flexibly when running the application. The values can
    be provided positionally, or by using the option flags.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important feature of invoke is its ability to act as a wrapper for
    other binary applications. The Context object that’s provided to each task provides
    ways to change the current working directory and run an arbitrary OS command.
    This includes options to update the environment of the subprocess, capture the
    output and error streams, provide an input stream, and many other features.
  prefs: []
  type: TYPE_NORMAL
- en: We can use invoke to combine multiple applications under a single wrapper. This
    can help to simplify complicated collections of applications by providing a uniform
    interface via a single module of task definitions.
  prefs: []
  type: TYPE_NORMAL
- en: We can, for example, combine an application that computes distance between two
    points, and a separate application that processes a CSV file with an entire route
    of a connected series of points.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall design might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The context.run() method will invoke an arbitrary OS-level command. The env
    parameter value provides updated environment variables to the command that’s executed.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Additional recipes for application integration are shown in Chapter [14](ch018.xhtml#x1-75800014),
    [Application Integration: Combination](ch018.xhtml#x1-75800014).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [https://www.pyinvoke.org](https://www.pyinvoke.org) web page contains all
    of the documentation on invoke.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.6 Using cmd to create command-line applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to create interactive applications. The [Using input()
    and getpass() for user input](ch010.xhtml#x1-3370002) recipe looked at functions
    such as input() and getpass.getpass(). The [Using argparse to get command-line
    input](ch010.xhtml#x1-3490004) recipe showed us how to use the argparse module
    to create applications with which a user can interact from the OS command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have another way to create interactive applications: using the cmd module.
    This module will prompt the user for input and then invoke a specific method of
    the class we provide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We entered the dice 5 command to set the number of dice. After that, the roll
    command showed the results of rolling five dice. The help command will show the
    available commands.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core feature of a cmd.Cmd application is a read-evaluate-print loop (REPL).
    This kind of application works well when there are a number of individual state
    changes and a number of closely related commands to make those state changes.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make use of a simple, stateful dice game. The idea is to have a handful
    of dice, some of which can be rolled and some of which are frozen. This means
    our Cmd class definition must have some attributes that describe the current state
    of a handful of dice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: dice to set the number of dice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: roll to roll the dice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reroll to re-roll selected dice, leaving the others untouched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the cmd module to make the cmd.Cmd class definition available. Since
    this is a game, the random module will also be needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an extension to cmd.Cmd:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define any initialization required in the preloop() method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method is evaluated once when the processing starts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Initialization can also be done in an __init__() method. However, doing this
    is a bit more complicated because it must collaborate with the Cmd class initialization.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For each command, create a do_command() method. The name of the method will
    be the command, prefixed by the characters do_. Any user input text after the
    command will be provided as an argument value to the method. The docstring comment
    in the method definition is the help text for the command. Here is the roll command,
    defined by the do_roll() method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parse and validate the arguments to the commands that use them. The user’s
    input after the command will be provided as the value of the first positional
    argument to the method. Here is the dice command, defined by the do_dice() method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the main script. This will create an instance of this class and execute
    the cmdloop() method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The cmdloop() method handles the details of prompting, collecting input, and
    executing the proper method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 6.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Cmd class contains a large number of built-in features to display a prompt,
    read input from a user, and then locate the proper method based on the user’s
    input.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we enter a command like dice 5, the built-in methods of the
    Cmd superclass will strip the first word from the input, dice, and prefix this
    with do_. It will then try to evaluate the method with the argument value of the
    rest of the line, 5.
  prefs: []
  type: TYPE_NORMAL
- en: If we enter a command for which there’s no matching do_*() method, the command
    processor writes an error message. This is done automatically; we don’t need to
    write any code to handle invalid command input.
  prefs: []
  type: TYPE_NORMAL
- en: Some methods, such as do_help(), are already part of the application. These
    methods will summarize the other do_* methods. When one of our methods has a docstring,
    this will be displayed by the built-in help feature.
  prefs: []
  type: TYPE_NORMAL
- en: The Cmd class relies on Python’s facilities for introspection. An instance of
    the class can examine the method names to locate all of the methods that start
    with do_. Introspection is an advanced topic, one that will be touched on in Chapter [8](ch012.xhtml#x1-4520008).
  prefs: []
  type: TYPE_NORMAL
- en: 6.6.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Cmd class has a number of additional places where we can add interactive
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: We can define specific help_*() methods that become part of the help topics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When any of the do_*() methods return a non-False value, the loop will end.
    We might want to add a do_quit() method to return True.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input stream is closed, an EOF command will be provided. In Linux, using
    ctrl-d will close the input file. This leads to the do_EOF() method, which should
    use return True.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might provide a method named emptyline() to respond to blank lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default() method is evaluated when the user’s input does not match any of
    the do_*() methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The postloop() method can be used to do some processing just after the loop
    finishes. This would be a good place to write a summary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, there are a number of attributes we can set. These are class-level variables
    that would be peers of the method definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The prompt attribute is the prompt string to write. The intro attribute is
    the introductory text to write before the first prompt. For our example, we can
    do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can tailor the help output by setting doc_header, undoc_header, misc_header,
    and ruler attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is to be able to create a tidy class that handles user interaction
    as directly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at class definitions in Chapter [7](ch011_split_000.xhtml#x1-3760007)
    and Chapter [8](ch012.xhtml#x1-4520008).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.7 Using the OS environment settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to look at inputs provided by the users of our software:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interactive input: This is provided by the user as required by the application.
    See the [Using input() and getpass() for user input](ch010.xhtml#x1-3370002) recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Command-line arguments: These are provided once, when the program is started.
    See the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) and
    [Using invoke to get command-line input](ch010.xhtml#x1-3550005) recipes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment variables: These are OS-level settings. There are several ways
    these can be set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the command line, when running the application.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set in a configuration file for the user’s selected shell. For example, if using
    zsh, these files are the ~/.zshrc file and the ~/.profile file. There can also
    be system-wide files, like the /etc/zshrc file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Windows, there’s the Advanced Settings option for environment variables.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration files: These are unique to an application. They are the subject
    of Chapter [13](ch017.xhtml#x1-71500013).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment variables are available through the os module.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe,
    we wrapped the haversine() function in a simple application that parsed command-line
    arguments. We created a program that worked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: After using this version of the application for a while, we may find that we’re
    often using nautical miles to compute distances from where our boat is anchored.
    We’d really like to have default values for one of the input points as well as
    the -r argument.
  prefs: []
  type: TYPE_NORMAL
- en: Since a boat can be anchored in a variety of places, we need to change the default
    without having to tweak the actual code. The idea of a ”slowly changing” argument
    value fits well with the OS environment variables. They can be persistent but
    are also relatively easy to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use two OS environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: UNITS will have the default distance units.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HOME_PORT can have an anchor point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We want to be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 6.7.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the os module. The default set of command-line arguments to parse comes
    from sys.argv, so it’s important to also import the sys module. The application
    will also depend on the argparse module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import any other classes or objects needed for the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function that will use the environment values as defaults for optional
    command-line arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Gather default values from the OS environment settings. This includes any validation
    required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that using os.environ.get() permits the application to include a default
    value for cases where the environment variable is not set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the parser object. Provide the default values for the relevant arguments
    extracted from the environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do any additional validation to ensure that arguments are set properly. In this
    example, it’s possible to have no value for HOME_PORT and no value provided for
    the second command-line argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This requires an if statement and a call to sys.exit():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the final options object with the set of valid arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow the -u argument and the second point to be optional. The argument
    parser will use the configuration information to supply default values if these
    are omitted from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: There is a nuanced distinction in the error code provided by sys.exit(). When
    applications fail because of command-line problems, it’s common to return a status
    code of 2, but sys.exit() will set the value to 1\. A slightly better approach
    is to use the parser.error() method. Doing this requires refactoring to create
    the ArgumentParser instance before acquiring and validating values from environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve used the OS environment variables to create default values that can be
    overridden by command-line arguments. If the environment variable is set, that
    string is provided as the default to the argument definition. If the environment
    variable is not set, then an application-level default value will used. In the
    case of the UNITS variable, in this example, the application uses kilometers as
    the default if the OS environment variable is not set.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve used the OS environment to set default values that can be overridden by
    the command-line argument values. This supports the idea of the environment providing
    a general context that might be shared by a number of commands.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    shows a slightly different way to handle the default command-line arguments available
    from sys.argv. The first of the arguments is the name of the Python application
    being executed and is not often relevant to argument parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of sys.argv will be a list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We have to skip the initial value in sys.argv[0] at some point in the processing.
    Generally, the application needs to provide sys.argv[1:] to the parser. This can
    be done inside the get_options() function. It can be done when the main() function
    evaluates the get_options() function. As shown in this example, it can be done
    when creating the default argument values for the get_options() function.
  prefs: []
  type: TYPE_NORMAL
- en: The argparse module allows us to provide type information for an argument definition.
    Providing type information can be used to validate argument values. In many cases,
    there may be a finite list of choices for a value, and this set of allowed choices
    can be provided as part of the argument definition. Doing this creates better
    error and help messages, improving the user experience when running the application.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at numerous ways to handle configuration files in Chapter [13](ch017.xhtml#x1-71500013).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
