<html><head></head><body>
<div><div><div><h1 id="_idParaDest-351"><em class="italic"><a id="_idTextAnchor332"/>Chapter 22</em>: The Façade Pattern</h1>
			<p>In the previous chapter, we covered a third structural pattern, the bridge pattern, which helps to define an abstraction and its implementation in a decoupled way, so that both can vary independently. Now, we will learn about another structural pattern, the <strong class="bold">façade</strong> pattern, which achieves an important goal in many software use cases: hiding the inner workings of an application and only giving access to what is necessary. </p>
			<p>In the chapter, we will discuss the following topics:</p>
			<ul>
				<li>Understanding the façade pattern</li>
				<li>Real-world examples</li>
				<li>Use cases</li>
				<li>Implementation</li>
			</ul>
			<p>Throughout this chapter, we will see why façade is a good pattern to employ and what its benefits are, and as always, implement a hands-on example in Python.</p>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor333"/>Technical requirements</h1>
			<p>The code files for this chapter can be accessed through this link: <a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter22">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter22</a>.</p>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor334"/>Understanding the façade pattern</h1>
			<p>As systems evolve, they can get <a id="_idIndexMarker1277"/>very complex. It is not unusual to end up with a very large (and sometimes confusing) collection of classes and interactions. In many cases, we don't want to expose this complexity to the client. This is where façade comes to our rescue.</p>
			<p>The façade design pattern helps us to hide the internal complexity of our systems and expose only what is necessary to the client through a simplified interface. In essence, a façade is an abstraction layer implemented over an existing complex system.</p>
			<p>Let's take the example of a computer to illustrate things. A computer is a complex machine that depends on several parts to be fully functional. To keep things simple, the word <em class="italic">computer</em>, in this case, refers to an IBM derivative that uses a von Neumann architecture. Booting a <a id="_idIndexMarker1278"/>computer is a particularly complex procedure. The CPU, main memory, and hard disk need to be up and running, the boot loader must be loaded from the hard disk to the main memory, the CPU must boot the <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>) kernel, and so forth. Instead of exposing all this complexity to the client, we create a façade that encapsulates the whole procedure, making sure that all steps are executed in the right order.</p>
			<p>In terms of object design and programming, we should have several classes, but only the <code>Computer</code> class needs to be exposed to the client code. The client will only have to execute the <code>start()</code> method of the <code>Computer</code> class, for example, and all the other complex parts are taken care of by the façade <code>Computer</code> class.</p>
			<p>Let's discuss more real-life examples of the façade pattern in the next section.</p>
			<h1 id="_idParaDest-354"><a id="_idTextAnchor335"/>Real-world examples</h1>
			<p>The façade pattern is quite common in life. When you call a bank or a company, you are usually first connected to <a id="_idIndexMarker1279"/>the customer service department. The customer service employee acts as a façade between you and the actual department (billing, technical support, general assistance, and so on), and the employee that will help you with your specific problem.</p>
			<p>Another example is the key used to turn on a car or motorcycle, which can also be considered a façade. It is a simple way of activating a system that is very complex internally. And, of course, the same is true for other complex electronic devices that we can activate with a single button, such as computers.</p>
			<p>In software, the <code>django-oscar-datacash</code> module is a Django third-party module that integrates with the <strong class="bold">DataCash</strong> payment gateway. The module has a gateway class that provides fine-grained access to the various DataCash APIs. On top of that, it also offers a façade class that provides a less granular API (for those who don't want to mess with the details), and the ability to save transactions for auditing purposes.</p>
			<p>In the next section, we will <a id="_idIndexMarker1280"/>see why the façade pattern is important in software.</p>
			<h1 id="_idParaDest-355"><a id="_idTextAnchor336"/>Use cases</h1>
			<p>The most common reason to use the façade pattern is to provide a single, simple entry point to a complex system. By introducing a façade, the client code can use a system by simply calling a single <a id="_idIndexMarker1281"/>method/function. At the same time, the internal system does not lose any functionality; it just encapsulates it.</p>
			<p>Not exposing the internal functionality of a system to the client code gives us an extra benefit: we can introduce changes to the system, but the client code remains unaware of and unaffected by the changes. No modifications are required to the client code.</p>
			<p>The façade is also useful if you have more than one layer in your system. You can introduce one façade entry point per layer, and let all layers communicate with each other through their façades. This, in turn, promotes <strong class="bold">loose coupling</strong> and keeps the layers as independent as possible.</p>
			<p>With that, we are now ready to try our hand at an actual implementation example in the next section.</p>
			<h1 id="_idParaDest-356"><a id="_idTextAnchor337"/>Implementation</h1>
			<p>Assume that we want to create <a id="_idIndexMarker1282"/>an OS using a multiserver approach, similar to how it is done in <strong class="bold">MINIX 3</strong> (<a href="http://j.mp/minix3">j.mp/minix3</a>) or <strong class="bold">GNU Hurd</strong> (<a href="http://j.mp/gnuhurd">j.mp/gnuhurd</a>). A multiserver <a id="_idIndexMarker1283"/>OS has a minimal kernel, called the <strong class="bold">microkernel</strong>, which runs in <a id="_idIndexMarker1284"/>privileged mode. All the other services of the system are following a <a id="_idIndexMarker1285"/>server architecture (driver server, process server, file server, and so forth). Each server belongs to a different memory address space and runs on top of the microkernel in user mode. The pros of this approach are that the OS can become more fault-tolerant, reliable, and secure. For example, since all drivers are running in user mode on a driver server, a bug in a driver cannot crash the whole system, nor can it affect the other servers. The cons of this approach are the performance overhead and the complexity of system programming. These are a result of the communication happening between a server and the microkernel, as well as between the independent servers, using message passing. Message passing is more complex than the shared memory model used in monolithic kernels, such as Linux (<a href="http://j.mp/helenosm">j.mp/helenosm</a>).</p>
			<p>We begin with a <code>Server</code> interface. An <code>Enum</code> parameter describes the different possible states of a server. We use the <code>Server</code> interface and make the <a id="_idIndexMarker1287"/>fundamental <code>boot()</code> and <code>kill()</code> methods mandatory, assuming that different actions are needed to be taken for booting, killing, and restarting each server. If you have not used the ABC module before, note the following important things:</p>
			<ul>
				<li>We need to subclass <code>ABCMeta</code> using the <code>metaclass</code> keyword.</li>
				<li>We use the <code>@abstractmethod</code> decorator for stating which methods should be implemented (mandatory) by all subclasses of the server.</li>
			</ul>
			<p>Try removing the <code>boot()</code> or <code>kill()</code> method of a subclass and see what happens. Do the same after removing the <code>@abstractmethod</code> decorator as well. Do things work as you expected?</p>
			<p>Let's consider the following code:</p>
			<pre> State = Enum('State', 'new running sleeping restart \
   zombie')
  
 class Server(metaclass=ABCMeta):
     @abstractmethod
     def __init__(self):
         pass
  
     def __str__(self):
         return self.name
  
     @abstractmethod
     def boot(self):
         pass
  
     @abstractmethod  
     def kill(self, restart=True):
         pass</pre>
			<p>A modular OS can have a great number of interesting servers: a file server, a process server, an authentication server, a network server, a graphical/window server, and so forth. The following <a id="_idIndexMarker1288"/>example includes two stub servers: <code>FileServer</code> and <code>ProcessServer</code>. Apart from the methods required to be implemented by the <code>Server</code> interface, each server can have its own specific methods. For instance, <code>FileServer</code> has a <code>create_file()</code> method for creating files, and <code>ProcessServer</code> has a <code>create_process()</code> method for creating processes.</p>
			<p>The <code>FileServer</code> class is as follows:</p>
			<pre>class FileServer(Server): 
    def __init__(self): 
        '''actions required for initializing the file \
          server''' 
        self.name = 'FileServer' 
        self.state = State.new 
 
    def boot(self): 
        print(f'booting the {self}') 
        '''actions required for booting the file server''' 
        self.state = State.running 
 
    def kill(self, restart=True): 
        print(f'Killing {self}') 
        '''actions required for killing the file server''' 
        self.state = State.restart if restart else \
          State.zombie 
 
    def create_file(self, user, name, permissions): 
        '''check validity of permissions, user rights, \
          etc.''' 
        print(f"trying to create the file '{name}' for \
           user '{user}' with permissions {permissions}") </pre>
			<p>The <code>ProcessServer</code> class <a id="_idIndexMarker1289"/>is as follows:</p>
			<pre>class ProcessServer(Server): 
    def __init__(self): 
        '''actions required for initializing the process \ 
          server''' 
        self.name = 'ProcessServer' 
        self.state = State.new 
 
    def boot(self): 
        print(f'booting the {self}') 
        '''actions required for booting the process \
          server''' 
        self.state = State.running 
 
    def kill(self, restart=True): 
        print(f'Killing {self}') 
        '''actions required for killing the process \
          server''' 
        self.state = State.restart if restart else \
          State.zombie 
 
    def create_process(self, user, name): 
        '''check user rights, generate PID, etc.'''  
        print(f"trying to create the process '{name}' for \
          user '{user}'")</pre>
			<p>The <code>OperatingSystem</code> class is a façade. In its <code>__init__()</code> method, all the necessary server instances are created. The <code>start()</code> method, used by the client code, is the entry point to the system. More wrapper methods can be added, if necessary, as access points to the services <a id="_idIndexMarker1290"/>of the servers, such as the <code>create_file()</code>, and <code>create_process()</code> wrappers. From the client's point of view, all those services are provided by the <code>OperatingSystem</code> class. The client should not be confused by unnecessary details such as the existence of servers and the responsibility of each server.</p>
			<p>The code for the <code>OperatingSystem</code> class is as follows:</p>
			<pre>class OperatingSystem: 
    '''The Facade''' 
    def __init__(self): 
        self.fs = FileServer() 
        self.ps = ProcessServer() 
 
    def start(self): 
        [i.boot() for i in (self.fs, self.ps)] 
 
    def create_file(self, user, name, permissions): 
        return self.fs.create_file(user, name, permissions) 
 
    def create_process(self, user, name): 
        return self.ps.create_process(user, name)</pre>
			<p>As you are going to see in a minute, when we present a summary of the example, there are many dummy classes and servers. They are there to give you an idea about the required abstractions (<code>User</code>, <code>Process</code>, <code>File</code>, and so forth) and servers (<code>WindowServer</code>, <code>NetworkServer</code>, and so forth) for making the system functional. A recommended exercise is to <a id="_idIndexMarker1291"/>implement at least one service of the system (for example, file creation). Feel free to change the interface and the signature of the methods to fit your needs. Make sure that after your changes, the client code does not need to know anything other than the façade <code>OperatingSystem</code> class.</p>
			<p>This application could be summarized in the following UML diagram, where <code>OperatingSystem</code> interacts with both <code>FileServer</code> and <code>ProcessServer</code>, hiding their methods away from the client code:</p>
			<div><div><img src="img/Figure_22.1_B17499.jpg" alt="Figure 22.1 — UML diagram for the OS example " width="1650" height="1013"/>
				</div>
			</div>
			<p class="figure-caption">Figure 22.1 — UML diagram for the OS example</p>
			<p>We are going to recapitulate <a id="_idIndexMarker1292"/>the details of our implementation example; the full code is in the <code>facade.py</code> file:</p>
			<ol>
				<li>We start with the imports we need:<pre>from enum import Enum 
from abc import ABCMeta, abstractmethod </pre></li>
				<li>We define the <code>State</code> constant using <code>Enum</code>, as shown earlier.</li>
				<li>We then add the <code>User</code>, <code>Process</code>, and <code>File</code> classes, which do nothing in this minimal but functional example:<pre>class User: 
    pass 
 
class Process: 
    pass 
 
class File: 
    pass </pre></li>
				<li>We define the base <code>Server</code> class, as shown earlier.</li>
				<li>We then define <a id="_idIndexMarker1293"/>the <code>FileServer</code> class and the <code>ProcessServer</code> class, which are both subclasses of <code>Server</code>.</li>
				<li>We add two other dummy classes, <code>WindowServer</code> and <code>NetworkServer</code>:<pre>class WindowServer: 
    pass 
 
class NetworkServer: 
    pass</pre></li>
				<li>Then, we define our façade class, <code>OperatingSystem</code>, as shown earlier.</li>
				<li>Finally, here is the main part of the code, where we use the façade we have defined:<pre>def main(): 
    os = OperatingSystem() 
    os.start()  
    os.create_file('foo', 'hello', '-rw-r-r') 
    os.create_process('bar', 'ls /tmp') 
 
if __name__ == '__main__': 
    main()</pre></li>
			</ol>
			<p>As you can see, executing <a id="_idIndexMarker1294"/>the <code>python facade.py</code> command shows the starting message of our two stub servers:</p>
			<pre>booting the FileServer
booting the ProcessServer
trying to create the file 'hello' for user 'foo' with 
permissions -rw-r-r
trying to create the process 'ls /tmp' for user 'bar'</pre>
			<p>The façade <code>OperatingSystem</code> class does a good job. The client code can create files and processes without needing to know internal details about the OS, such as the existence of multiple servers. To be precise, the client code can call the methods for creating files and processes, but they are currently dummies. As an interesting exercise, you can implement one of the two methods, or even both.</p>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor338"/>Summary</h1>
			<p>In this chapter, we have learned how to use the façade pattern. This pattern is ideal for providing a simple interface to client code that wants to use a complex system but does not need to be aware of the system's complexity. We discussed a Django third-party module that uses façade: <code>django-oscar-datacash</code>. It uses the façade pattern to provide a simple DataCash API and the ability to save transactions.</p>
			<p>We also learned how to implement the interface used by a multiserver OS. Overall, we learned that a façade is an elegant way of hiding the complexity of a system because, in most cases, the client code should not be aware of such details.</p>
			<p>In the next chapter, we will cover other structural design patterns.</p>
			<h1 id="_idParaDest-358"><a id="_idTextAnchor339"/>Questions</h1>
			<ol>
				<li value="1">What are the high-level benefits of using the façade pattern?</li>
				<li>How does using the façade pattern help when it comes to making changes to an application?</li>
				<li>How is the façade pattern implemented in the Python example of the OS we considered?</li>
			</ol>
			<h1 id="_idParaDest-359"><a id="_idTextAnchor340"/>Further reading</h1>
			<p><em class="italic">Design Patterns</em> by Gamma Enrich, Helm Richard, Johnson Ralph, and Vlissides John available at <a href="https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8">https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8</a></p>
		</div>
	</div>
</div>
</body></html>