<html><head></head><body>
        

            
                <h1 class="header-title">Communication Interfaces</h1>
            

            
                
<p>So far, we have discussed loops, conditional statements, and functions in Python. We also discussed interfacing output devices and simple digital input devices.</p>
<p>In this chapter, we will discuss the following communication interfaces:</p>
<ul>
<li>UART – serial port</li>
<li>Serial Peripheral Interface</li>
<li>I<sup>2</sup>C interface</li>
</ul>
<p>We will be making use of different sensors/electronic components to demonstrate writing code in Python for these interfaces. We leave it up to you to pick a component of your choice to explore these communication interfaces.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">UART - serial port</h1>
            

            
                
<p><strong>Universal Asynchronous Receiver/Transmitter</strong> (<strong>UART</strong>), a serial port, is a communication interface where the data is transmitted serially in bits from a sensor to the host computer. Using a serial port is one of the oldest forms of communication protocol. It is used in data logging where microcontrollers collect data from sensors and transmit the data via a serial port. There are also sensors that transmit data via serial communication as responses to incoming commands.</p>
<p>We will not go into the theory behind serial port communications (there's plenty of theory available on the Web at <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter</a>). We will be discussing the use of the serial port to interface different sensors with the Raspberry Pi.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Raspberry Pi Zero's UART port</h1>
            

            
                
<p>Typically, UART ports consist of a receiver (<em>Rx</em>) and a transmitter (<em>Tx</em>) pin that receive and transmit data. The Raspberry Pi's GPIO header comes with an UART port. The GPIO pins 14 (the <em>Tx</em> pin) and 15 (is the <em>Rx</em> pin) serve as the UART port for the Raspberry Pi:</p>
<div><img class=" image-border" height="305" src="img/image_04_001.png" width="418"/></div>
<p>GPIO pins 14 and 15 are the UART pins (image source: https://www.rs-online.com/designspark/introducing-the-raspberry-pi-b-plus)</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Setting up the Raspberry Pi Zero serial port</h1>
            

            
                
<p>In order to use the serial port to talk to sensors, the serial port login/console needs to be disabled. In the <strong>Raspbian</strong> OS image, this is enabled by default as it enables easy debugging.</p>
<p>The serial port login can be disabled via <kbd>raspi-config</kbd>:</p>
<ol>
<li>Launch the terminal and run this command:</li>
</ol>
<pre>
       <strong>sudo raspi-config</strong>
</pre>
<ol start="2">
<li>Select Advanced Options from the main menu of <kbd>raspi-config</kbd>:</li>
</ol>
<div><img class=" image-border" height="178" src="img/image_04_002.png" width="446"/></div>
<p>Select Advanced Options from the raspi-config menu</p>
<ol start="3">
<li>Select the A8 Serial option from the drop-down menu:</li>
</ol>
<div><img class=" image-border" height="207" src="img/image_04_003.png" width="533"/></div>
<p>Select A8 Serial from the dropdown</p>
<ol start="4">
<li>Disable serial login:</li>
</ol>
<div><img class=" image-border" height="216" src="img/image_04_004.png" width="274"/></div>
<p>Disable serial login</p>
<ol start="5">
<li>Finish the configuration and reboot at the end:</li>
</ol>
<div><img class=" image-border" height="210" src="img/image_04_005.png" width="268"/></div>
<p>Save config and reboot</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Example 1 - interfacing a carbon dioxide sensor to the Raspberry Pi</h1>
            

            
                
<p>We will be making use of the K30 carbon dioxide sensor (its documentation is available here, <a href="http://co2meters.com/Documentation/Datasheets/DS30-01%20-%20K30.pdf">http://co2meters.com/Documentation/Datasheets/DS30-01%20-%20K30.pdf</a>). It has a range of 0-10,000 ppm, and the sensor provides it carbon dioxide concentration readings via serial port as a response to certain commands from the Raspberry Pi.</p>
<p>The following diagram shows the connections between the Raspberry Pi and the K30 carbon dioxide sensor:</p>
<div><img class=" image-border" height="305" src="img/image_04_006.png" width="191"/></div>
<p>K30 carbon dioxide sensor interfaced with the Raspberry Pi</p>
<p>The receiver (<em>Rx</em>) pin of the sensor is connected to the transmitter (<em>Tx</em>-<strong>GPIO 14 (UART_TXD)</strong>) pin of the Raspberry Pi Zero (the yellow wire in the preceding figure). The transmitter (<em>Tx</em>) pin of the sensor is connected to the receiver (<em>Rx</em>-<strong>GPIO 15 (UART_RXD)</strong>) pin of the Raspberry Pi Zero (the green wire in the preceding figure).</p>
<p>In order to power the sensor, the G+ pin of the sensor (the red wire in the preceding figure) is connected to the <strong>5V</strong> pin of the Raspberry Pi Zero. The G0 pin of the sensor is connected to the <strong>GND</strong> pin of the Raspberry Pi Zero (black wire in the earlier figure).</p>
<p>Typically, serial port communication is initiated by specifying the baud rate, the number of bits in a frame, stop bit, and flow control.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Python code for serial port communication</h1>
            

            
                
<p>We will make use of the <strong>pySerial</strong> library (<a href="https://pyserial.readthedocs.io/en/latest/shortintro.html#opening-serial-ports">https://pyserial.readthedocs.io/en/latest/shortintro.html#opening-serial-ports</a>) for interfacing the carbon dioxide sensor:</p>
<ol>
<li>As per the sensor's documentation, the sensor output can be read by initiating the serial port at a baud rate of 9600, no parity, 8 bits, and 1 stop bit. The GPIO serial port is <kbd>ttyAMA0</kbd>. The first step in interfacing with the sensor is initiating serial port communication:</li>
</ol>
<pre>
       import serial <br/>       ser = serial.Serial("/dev/ttyAMA0")
</pre>
<ol start="2">
<li>As per the sensor documentation (<a href="http://co2meters.com/Documentation/Other/SenseAirCommGuide.zip">http://co2meters.com/Documentation/Other/SenseAirCommGuide.zip</a>), the sensor responds to the following command for the carbon dioxide concentration:</li>
</ol>
<div><img class=" image-border" height="118" src="img/image_04_007.png" width="561"/></div>
<p>Command to read carbon dioxide concentration from the sensor-borrowed from the sensor datasheet</p>
<ol start="3">
<li>The command can be transmitted to the sensor as follows:</li>
</ol>
<pre>
       ser.write(bytearray([0xFE, 0x44, 0x00, 0x08, 0x02, 0x9F, 0x25]))
</pre>
<ol start="4">
<li>The sensor responds with a 7-byte response, which can be read as follows:</li>
</ol>
<pre>
       resp = ser.read(7)
</pre>
<ol start="5">
<li>The sensor's response is in the following format:</li>
</ol>
<div><img class=" image-border" height="82" src="img/image_04_008.png" width="563"/></div>
<p>Carbon dioxide sensor response</p>
<ol start="6">
<li>According to the datasheet, the sensor data size is 2 bytes. Each byte can be used to store a value of 0 and 255. Two bytes can be used to store values up to 65,535 (255 * 255). The carbon dioxide concentration could be calculated from the message as follows:</li>
</ol>
<pre>
       high = resp[3] <br/>       low = resp[4] <br/>       co2 = (high*256) + low
</pre>
<ol start="7">
<li>Put it all together:</li>
</ol>
<pre>
       import serial <br/>       import time <br/>       import array <br/>       ser = serial.Serial("/dev/ttyAMA0") <br/>       print("Serial Connected!") <br/>       ser.flushInput() <br/>       time.sleep(1) <br/><br/>       while True: <br/>           ser.write(bytearray([0xFE, 0x44, 0x00, 0x08,<br/>           0x02, 0x9F, 0x25])) <br/>           # wait for sensor to respond <br/>           time.sleep(.01) <br/>           resp = ser.read(7) <br/>           high = resp[3] <br/>           low = resp[4] <br/>           co2 = (high*256) + low <br/>           print() <br/>           print() <br/>           print("Co2 = " + str(co2)) <br/>           time.sleep(1)
</pre>
<ol start="8">
<li>Save the code to a file and try executing it.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">I2C communication</h1>
            

            
                
<p><strong>Inter-Integrated Circuit</strong> (<strong>I<sup>2</sup>C</strong>) communication is a type of serial communication that allows interfacing multiple sensors to the computer. I<sup>2</sup>C communication consists of two wires of a clock and a data line. The Raspberry Pi Zero's clock and data pins for I<sup>2</sup>C communication are <strong>GPIO 3</strong> (<strong>SCL</strong>) and <strong>GPIO 2</strong> (<strong>SDA</strong>), respectively. In order to communicate with multiple sensors over the same bus, sensors/actuators that communicate via I<sup>2</sup>C protocol are usually addressed by their 7-bit address. It is possible to have two or more Raspberry Pi boards talking to the same sensor on the same I<sup>2</sup>C bus. This enables building a sensor network around the Raspberry Pi.</p>
<p>The I<sup>2</sup>C communication lines are open drain lines; hence, they are pulled up using resistors, as shown in the following figure:</p>
<div><img class=" image-border" height="275" src="img/image_04_009.png" width="477"/></div>
<p>I<sup>2</sup>C setup</p>
<p>Let's review an example of I<sup>2</sup>C communication using an example.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Example 2 - PiGlow</h1>
            

            
                
<p>The <strong>PiGlow</strong> is a piece of add-on hardware for the Raspberry Pi that consists of 18 LEDs interfaced with the <strong>SN3218</strong> chip. This chip permits controlling the LEDs via the I<sup>2</sup>C interface. The chip's 7-bit address is <kbd>0x54</kbd>.</p>
<p>To interface the add-on hardware, the <strong>SCL</strong> pin is connected to <strong>GPIO 3</strong> and <strong>SDA</strong> pin to <strong>GPIO 2</strong>; the ground pins and the power supply pins are connected to the counterparts of the add-on hardware, respectively.</p>
<p>The PiGlow comes with a library that comes which abstracts the I<sup>2</sup>C communication: <a href="https://github.com/pimoroni/piglow">https://github.com/pimoroni/piglow</a>.</p>
<p>Although the library is a wrapper around the I<sup>2</sup>C interface for the library, we recommend reading through the code to understand the internal mechanism to operate the LEDs:</p>
<div><img class="image-border" height="236" src="img/image_04_010.jpg" width="416"/></div>
<p>PiGlow stacked on top of the Raspberry Pi</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Installing libraries</h1>
            

            
                
<p>The PiGlow library may be installed by running the following from the command-line terminal:</p>
<pre>
    <strong>curl get.pimoroni.com/piglow | bash</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Example</h1>
            

            
                
<p>On the completion of installation, switch to the example folder (<kbd>/home/pi/Pimoroni/piglow</kbd>) and run one of the examples:</p>
<pre>
    <strong>python3 bar.py</strong>
</pre>
<p>It should run <em>blinky</em> light effects as shown in the following figure:</p>
<div><img class="image-border" height="247" src="img/image_04_011.jpg" width="408"/></div>
<p>Blinky lights on the PiGlow</p>
<p>Similarly, there are libraries to talk to real-time clocks, LCD displays, and so on using I<sup>2</sup>C communication. If you are interested in writing your own interface that provides the nitty-gritty detail of I<sup>2</sup>C communication with sensors/output devices, check out this book's accompanying website for some examples.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Example 3 - Sensorian add-on hardware for the Raspberry Pi</h1>
            

            
                
<p>The <strong>Sensorian</strong> is an add-on hardware designed for the Raspberry Pi. This add-on hardware comes with different types of sensors, including a light sensor, barometer, accelerometer, LCD display interface, flash memory, capacitive touch sensors, and a real-time clock.</p>
<p>The sensors on this add-on hardware is sufficient to learn using all the communication interfaces discussed in this chapter:</p>
<div><img class="image-border" height="320" src="img/image_04_012.jpg" width="339"/></div>
<p>Sensorian hardware stacked on top of the Raspberry Pi Zero</p>
<p>In this section, we will discuss an example where we will measure the ambient light levels using a Raspberry Pi Zero via the I<sup>2</sup>C interface. The sensor on the add-on hardware board is the <strong>APDS-9300</strong> sensor (<a href="http://www.avagotech.com/docs/AV02-1077EN">www.avagotech.com/docs/AV02-1077EN</a>).</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">I2C drivers for the lux sensor</h1>
            

            
                
<p>The drivers are available from the GitHub repository for the Sensorian hardware (<a href="https://github.com/sensorian/sensorian-firmware.git">https://github.com/sensorian/sensorian-firmware.git</a>). Let's clone the repository from the command-line terminal:</p>
<pre>
    <strong>git clone https://github.com/sensorian/sensorian-firmware.git </strong>
</pre>
<p>Let's make use of the drivers (which is available in the <kbd> ~/sensorian-firmware/Drivers_Python/APDS-9300</kbd> folder) to read the values from the two ADC channels of the sensor:</p>
<pre>
import time <br/>import APDS9300 as LuxSens <br/>import sys <br/><br/>AmbientLight = LuxSens.APDS9300() <br/>while True: <br/>   time.sleep(1) <br/>   channel1 = AmbientLight.readChannel(1)                       <br/>   channel2 = AmbientLight.readChannel(0) <br/>   Lux = AmbientLight.getLuxLevel(channel1,channel2) <br/>   print("Lux output: %d." % Lux)
</pre>
<p>With the ADC values available from both the channel, the ambient light value can be calculated by the driver using the following formula (retrieved from the sensor datasheet):</p>
<div><img class=" image-border" height="112" src="img/image_04_013.png" width="438"/></div>
<p>Ambient light levels calculated using the ADC values</p>
<p>This calculation is performed by the attribute <kbd>getLuxLevel</kbd>. Under normal lighting conditions, the ambient light level (measured in lux) was around <kbd>2</kbd>. The measured output was <kbd>0</kbd> when we covered the lux sensor with the palm. This sensor could be used to measure ambient light and adjust the room lighting accordingly.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Challenge</h1>
            

            
                
<p>We discussed measuring ambient light levels using the lux sensor. How do we make use of the lux output (ambient light levels) to control the room lighting?</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">The SPI interface</h1>
            

            
                
<p>There is another type of serial communication interface named the <strong>Serial Peripheral Interface</strong> (<strong>SPI</strong>). This interface has to be enabled via <kbd>raspi-config</kbd> (this is similar to enabling serial port interface earlier in this chapter). Using the SPI interface is similar to that of I<sup>2</sup>C interface and the serial port.</p>
<p>Typically, an SPI interface consists of a clock line, data-in, data-out, and a <strong>Slave Select</strong> (<strong>SS</strong>) line. Unlike I<sup>2</sup>C communication (where we could connect multiple masters), there can be only one master (the Raspberry Pi Zero), but multiple slaves on the same bus. The <strong>SS</strong> pin enables selecting a specific sensor that the Raspberry Pi Zero is reading/writing data when there are multiple sensors connected to the same bus.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Example 4 - writing to external memory chip</h1>
            

            
                
<p>Let's review an example where we write to a flash memory chip on the Sensorian add-on hardware via the SPI interface. The drivers for the SPI interface and the memory chip are available from the same GitHub repository.</p>
<p>Since we already have the drivers downloaded, let's review an example available with drivers:</p>
<pre>
import sys <br/>import time   <br/>import S25FL204K as Memory
</pre>
<p>Let's initialize and write the message <kbd>hello</kbd> to the memory:</p>
<pre>
Flash_memory = Memory.S25FL204K() <br/>Flash_memory.writeStatusRegister(0x00) <br/>message = "hello" <br/>flash_memory.writeArray(0x000000,list(message), message.len())
</pre>
<p>Now, let's try to read the data we just wrote to the external memory:</p>
<pre>
data = flash_memory.readArray(0x000000, message.len()) <br/>print("Data Read from memory: ") <br/>print(''.join(data))
</pre>
<p>The code sample is available for download with this chapter (<kbd>memory_test.py</kbd>).</p>
<p>We were able to demonstrate using the SPI to read/write to an external memory chip.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Challenge to the reader</h1>
            

            
                
<p>In the figure here, there is an LED strip (<a href="https://www.adafruit.com/product/306">https://www.adafruit.com/product/306</a>) interfaced to the SPI interface of the Raspberry Pi add on hardware using the Adafruit Cobbler (<a href="https://www.adafruit.com/product/914">https://www.adafruit.com/product/914</a>). We are providing a clue on how to interface the LED strip to the Raspberry Pi Zero. We would like to see if you are able to find a solution to interface the LED strip by yourself. Refer to this book's website for the answer.</p>
<div><img class=" image-border" height="143" src="img/image_04_014.png" width="573"/></div>
<p>LED strip interfaced with the Adafruit Cobbler for the Raspberry Pi Zero</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, we have discussed different communication interfaces that are available on the Raspberry Pi Zero. These interfaces include I<sup>2</sup>C, SPI, and UART. We will be making use of these interfaces in our final projects. We discussed these interfaces using a carbon dioxide sensor, LED driver, and a sensor platform. In the next chapter, we will discuss object-oriented programming and its distinct advantages. We will discuss the need for object-oriented programming using an example. Object-oriented programming can be especially helpful in scenarios where you have to write your own drivers to control a component of your robot or write an interface library for a sensor.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>