<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Python Design Patterns II</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will be introduced to several more design patterns. Once again, we'll cover the canonical examples as well as any common alternative implementations in Python. We'll be discussing the following:</p>
<ul>
<li>The adapter pattern</li>
<li>The facade pattern</li>
<li>Lazy initialization and the flyweight pattern</li>
<li>The command pattern</li>
<li>The abstract factory pattern</li>
<li>The composition pattern</li>
</ul>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The adapter pattern</h1>
                </header>
            
            <article>
                
<p>Unlike most of the patterns we reviewed in the previous chapter, the adapter pattern is designed to interact with existing code. We would not design a brand new set of objects that implement the adapter pattern. Adapters are used to allow two preexisting objects to work together, even if their interfaces are not compatible. Like the display adapters that allow you to plug your Micro USB charging cable into a USB-C phone, an adapter object sits between two different interfaces, translating between them on the fly. The adapter object's sole purpose is to perform this translation. Adapting may entail a variety of tasks, such as converting arguments to a different format, rearranging the order of arguments, calling a differently named method, or supplying default arguments.</p>
<p>In structure, the adapter pattern is similar to a simplified decorator pattern. Decorators typically provide the same interface that they replace, whereas adapters map between two different interfaces. <span>This is depicted in UML form in the following diagram:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/bef847c5-155c-4661-91f7-b48a291ce802.png" style="width:26.50em;height:15.08em;"/></div>
<p class="mce-root"/>
<p>Here, <strong>Interface1 </strong>is expecting to call a method called <strong>make_action(some, arguments)</strong>. We already have this perfect <strong>Interface2</strong> class that does everything we want (and to avoid duplication, we don't want to rewrite it!), but it provides a method called <strong>different_action(other, arguments)</strong> instead. The <strong>Adapter</strong> class implements the <strong>make_action</strong> interface and maps the arguments to the existing interface.</p>
<p>The advantage here is that the code that maps from one interface to another is all in one place. The alternative would be really ugly; we'd have to perform the translation in multiple places whenever we need to access this code.</p>
<p>For example, imagine we have the following preexisting class, which takes a string date in the format <kbd>YYYY-MM-DD</kbd> and calculates a person's age on that date:</p>
<pre>class AgeCalculator:<br/>    def __init__(self, birthday):<br/>        self.year, self.month, self.day = (<br/>            int(x) for x in birthday.split("-")<br/>        )<br/><br/>    def calculate_age(self, date):<br/>        year, month, day = (int(x) for x in date.split("-"))<br/>        age = year - self.year<br/>        if (month, day) &lt; (self.month, self.day):<br/>            age -= 1<br/>        return age</pre>
<p>This is a pretty simple class that does what it's supposed to do. But we have to wonder what the programmer was thinking, using a specifically formatted string instead of using Python's incredibly useful built-in <kbd>datetime</kbd> library. As conscientious programmers who reuse code whenever possible, most of the programs we write will interact with <kbd>datetime</kbd> objects, not strings.</p>
<p>We have several options to address this scenario. We could rewrite the class to accept <kbd>datetime</kbd> objects, which would probably be more accurate anyway. But if this class had been provided by a third party and we don't know how to or can't change its internal structure, we need an alternative. We could use the class as it is, and whenever we want to calculate the age on a <kbd>datetime.date</kbd> object, we could call <kbd>datetime.date.strftime('%Y-%m-%d')</kbd> to convert it to the proper format. But that conversion would be happening in a lot of places, and worse, if we mistyped the <kbd>%m</kbd> as <kbd>%M</kbd>, it would give us the current minute instead of the  month entered. Imagine if you wrote that in a dozen different places only to have to go back and change it when you realized your mistake. It's not maintainable code, and it breaks the DRY principle.</p>
<p>Instead, we can write an adapter that allows a normal date to be plugged into a normal <kbd>AgeCalculator</kbd> class, as shown in the following code:</p>
<pre>import datetime 
<br/><br/>class DateAgeAdapter:<br/>    def _str_date(self, date):<br/>        return date.strftime("%Y-%m-%d")<br/><br/>    def __init__(self, birthday):<br/>        birthday = self._str_date(birthday)<br/>        self.calculator = AgeCalculator(birthday)<br/><br/>    def get_age(self, date):<br/>        date = self._str_date(date)<br/>        return self.calculator.calculate_age(date)</pre>
<p>This adapter converts <kbd>datetime.date</kbd> and <kbd>datetime.time</kbd> (they have the same interface to <kbd>strftime</kbd>) into a string that our original <kbd>AgeCalculator</kbd> can use. Now we can use the original code with our new interface. I changed the method signature to <kbd>get_age</kbd> to demonstrate that the calling interface may also be looking for a different method name, not just a different type of argument.</p>
<p>Creating a class as an adapter is the usual way to implement this pattern, but, as usual, there are other ways to do it in Python. Inheritance and multiple inheritance can be used to add functionality to a class. For example, we could add an adapter on the <kbd>date</kbd> class so that it works with the original <kbd>AgeCalculator</kbd> <span>class, as follows</span>:</p>
<pre>import datetime 
class AgeableDate(datetime.date): 
    def split(self, char): 
        return self.year, self.month, self.day </pre>
<p>It's code like this that makes one wonder whether Python should even be legal. We have added a <kbd>split</kbd> method to our subclass that takes a single argument (which we ignore) and returns a tuple of year, month, and day. This works flawlessly with the original <kbd>AgeCalculator</kbd> class because the code calls <kbd>strip</kbd> on a specially formatted string, and <kbd>strip</kbd>, in that case, returns a tuple of year, month, and day. The <kbd>AgeCalculator</kbd> code only cares if <kbd>strip</kbd> exists and returns acceptable values; it doesn't care if we really passed in a string. <span>The following code really works</span>:</p>
<pre><strong>&gt;&gt;&gt; bd = AgeableDate(1975, 6, 14)</strong>
<strong>&gt;&gt;&gt; today = AgeableDate.today()</strong>
<strong>&gt;&gt;&gt; today</strong>
<strong>AgeableDate(2015, 8, 4)</strong>
<strong>&gt;&gt;&gt; a = AgeCalculator(bd)</strong>
<strong>&gt;&gt;&gt; a.calculate_age(today)</strong>
<strong>40</strong>  </pre>
<p>It works but it's a stupid idea. In this particular instance, such an adapter would be hard to maintain. We'd soon forget why we needed to add a <kbd>strip</kbd> method to a <kbd>date</kbd> class. The method name is ambiguous. That can be the nature of adapters, but creating an adapter explicitly instead of using inheritance usually clarifies its purpose.</p>
<p>Instead of inheritance, we can sometimes also use monkey-patching to add a method to an existing class. It won't work with the <kbd>datetime</kbd> object, as it doesn't allow attributes to be added at runtime.  In normal classes, however, we can just add a new method that provides the adapted interface that is required by calling code. Alternatively, we could extend or monkey-patch the <kbd>AgeCalculator</kbd> itself to replace the <kbd>calculate_age</kbd> method with something more amenable to our needs.</p>
<p>Finally, it is often possible to use a function as an adapter; this doesn't obviously fit the actual design of the adapter pattern, but if we recall that functions are essentially objects with a <kbd>__call__</kbd> method, it becomes an obvious adapter adaptation.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The facade pattern</h1>
                </header>
            
            <article>
                
<p>The facade pattern is designed to provide a simple interface to a complex system of components. For complex tasks, we may need to interact with these objects directly, but there is often a <em>typical</em> usage for the system for which these complicated interactions aren't necessary. The facade pattern allows us to define a new object that encapsulates this typical usage of the system. Any time we want access to common functionality, we can use the single object's simplified interface. If another part of the project needs access to more complicated functionality, it is still able to interact with the system directly. The UML diagram for the facade pattern is really dependent on the subsystem, but in a cloudy way, it looks like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/900379e3-b9e5-4451-b8ed-abcf6451c417.png" style="width:20.25em;height:18.00em;"/></div>
<p>A facade is, in many ways, like an adapter. The primary difference is that a facade tries to abstract a simpler interface out of a complex one, while an adapter only tries to map one existing interface to another.</p>
<p>Let's write a simple facade for an email application. The low-level library for sending email in Python, as we saw in <a href="b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>Python Object-Oriented Shortcuts</em>, is quite complicated. The two libraries for receiving messages are even worse.</p>
<p>It would be nice to have a simple class that allows us to send a single email, and list the emails currently in the inbox on an IMAP or POP3 connection. To keep our example short, we'll stick with IMAP and SMTP: two totally different subsystems that happen to deal with email. Our facade performs only two tasks: sending an email to a specific address, and checking the inbox on an IMAP connection. It makes some common assumptions about the connection, such as that the host for both SMTP and IMAP is at the same address, that the username and password for both is the same, and that they use standard ports. This covers the case for many email servers, but if a programmer needs more flexibility, they can always bypass the facade and access the two subsystems directly.</p>
<p>The class is initialized with the hostname of the email server, a username, and a password to log in:</p>
<pre>import smtplib 
import imaplib 
 <br/>class EmailFacade: 
    def __init__(self, host, username, password): 
        self.host = host 
        self.username = username 
        self.password = password </pre>
<p>The <kbd>send_email</kbd> method formats the email address and message, and sends it using <kbd>smtplib</kbd>. This isn't a complicated task, but it requires quite a bit of fiddling to massage the <em>natural</em> input parameters that are passed into the facade to the correct format to enable <kbd>smtplib</kbd> to send the message, as follows:</p>
<pre>    def send_email(self, to_email, subject, message):<br/>        if not "@" in self.username:<br/>            from_email = "{0}@{1}".format(self.username, self.host)<br/>        else:<br/>            from_email = self.username<br/>        message = (<br/>            "From: {0}\r\n" "To: {1}\r\n" "Subject: {2}\r\n\r\n{3}"<br/>        ).format(from_email, to_email, subject, message)<br/><br/>        smtp = smtplib.SMTP(self.host)<br/>        smtp.login(self.username, self.password)<br/>        smtp.sendmail(from_email, [to_email], message)</pre>
<p>The <kbd>if</kbd> statement at the beginning of the method is catching whether or not the <kbd>username</kbd> is the entire <em>from</em> email address or just the part on the left-hand side of the <kbd>@</kbd> symbol; different hosts treat the login details differently.</p>
<p>Finally, the code to get the messages currently in the inbox is a royal mess. The IMAP protocol is painfully over-engineered, and the <kbd>imaplib</kbd> standard library is only a thin layer over the protocol. But we get to simplify it, as follows:</p>
<pre>    def get_inbox(self):<br/>        mailbox = imaplib.IMAP4(self.host)<br/>        mailbox.login(<br/>            bytes(self.username, "utf8"), bytes(self.password, "utf8")<br/>        )<br/>        mailbox.select()<br/>        x, data = mailbox.search(None, "ALL")<br/>        messages = []<br/>        for num in data[0].split():<br/>            x, message = mailbox.fetch(num, "(RFC822)")<br/>            messages.append(message[0][1])<br/>        return messages</pre>
<p>Now, if we add all this together, we have a simple facade class that can send and receive messages in a fairly straightforward manner; much simpler than if we had to interact with these complex libraries directly.</p>
<p>Although it is rarely mentioned by name in the Python community, the facade pattern is an integral part of the Python ecosystem. Because Python emphasizes language readability, both the language and its libraries tend to provide easy-to-comprehend interfaces to complicated tasks. For example, <kbd>for</kbd> loops, <kbd>list</kbd> comprehensions, and generators are all facades into a more complicated iterator protocol. The <kbd>defaultdict</kbd> implementation is a facade that abstracts away annoying corner cases when a key doesn't exist in a dictionary. The third-party <strong>requests</strong> library is a powerful facade over less readable libraries for HTTP requests, which are themselves a facade over managing the text-based HTTP protocol yourself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The flyweight pattern</h1>
                </header>
            
            <article>
                
<p>The flyweight pattern is a memory optimization pattern. Novice Python programmers tend to ignore memory optimization, assuming the built-in garbage collector will take care of them. This is usually perfectly acceptable, but when developing larger applications with many related objects, paying attention to memory concerns can have a huge payoff.</p>
<p>The flyweight pattern ensures that objects that share a state can use the same memory for that shared state. It is normally implemented only after a program has demonstrated memory problems. It may make sense to design an optimal configuration from the beginning in some situations, but bear in mind that premature optimization is the most effective way to create a program that is too complicated to maintain.</p>
<p>Let's have a look at the following UML diagram for the flyweight pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/fac04995-3717-4ad7-b0bb-2c2e85f65770.png" style="width:29.25em;height:10.92em;"/></div>
<p>Each <strong>Flyweight</strong> has no specific state. Any time it needs to perform an operation on <strong>SpecificState</strong>, that state needs to be passed into the <strong>Flyweight</strong> by the calling code. Traditionally, the factory that returns a flyweight is a separate object; its purpose is to return a flyweight for a given key identifying that flyweight. It works like the singleton pattern we discussed in <a href="345fe617-9a90-4c59-9355-e7076759f9a4.xhtml"><span class="ChapterrefPACKT">Chapter 10</span></a>, <em>Python Design Patterns I</em>; if the flyweight exists, we return it; otherwise, we create a new one. In many languages, the factory is implemented, not as a separate object, but as a static method on the <kbd>Flyweight</kbd> class itself.</p>
<p>Think of an inventory system for car sales. Each individual car has a specific serial number and is a specific color. But most of the details about that car are the same for all cars of a particular model. For example, the Honda Fit DX model is a bare-bones car with few features. The LX model has A/C, tilt, cruise, and power windows and locks. The Sport model has fancy wheels, a USB charger, and a spoiler. Without the flyweight pattern, each individual car object would have to store a long list of which features it did and did not have. Considering the number of cars Honda sells in a year, this would add up to a huge amount of wasted memory.</p>
<p>Using the flyweight pattern, we can instead have shared objects for the list of features associated with a model, and then simply reference that model, along with a serial number and color, for individual vehicles. In Python, the flyweight factory is often implemented using that funky <kbd>__new__</kbd> constructor, similar to what we did with the singleton pattern.</p>
<p>Unlike the singleton pattern, which only needs to return one instance of the class, we need to be able to return different instances depending on the keys. We could store the items in a dictionary and look them up based on the key. This solution is problematic, however, because the item will remain in memory as long as it is in the dictionary. If we sold out of LX model Fits, the Fit flyweight would no longer be necessary, yet it would still be in the dictionary. We could clean this up whenever we sell a car, but isn't that what a garbage collector is for?</p>
<p>We can solve this by taking advantage of Python's <kbd>weakref</kbd> module. This module provides a <kbd>WeakValueDictionary</kbd> object, which basically allows us to store items in a dictionary without the garbage collector caring about them. If a value is in a weak referenced dictionary and there are no other references to that object stored anywhere in the application (that is, we sold out of LX models), the garbage collector will eventually clean up for us.</p>
<p>Let's build the factory for our car flyweights <span>first, as follows</span>:</p>
<pre>import weakref<br/><br/><br/>class CarModel:<br/>    _models = weakref.WeakValueDictionary()<br/><br/>    def __new__(cls, model_name, *args, **kwargs):<br/>        model = cls._models.get(model_name)<br/>        if not model:<br/>            model = super().__new__(cls)<br/>            cls._models[model_name] = model<br/><br/>        return model</pre>
<p>Basically, whenever we construct a new flyweight with a given name, we first look up that name in the weak referenced dictionary; if it exists, we return that model; if not, we create a new one. Either way, we know the <kbd>__init__</kbd> method on the flyweight will be called every time, regardless of whether it is a new or existing object. Our <kbd>__init__</kbd> method can therefore look like <span>the following code snippet</span>:</p>
<pre>    def __init__(<br/>        self,<br/>        model_name,<br/>        air=False,<br/>        tilt=False,<br/>        cruise_control=False,<br/>        power_locks=False,<br/>        alloy_wheels=False,<br/>        usb_charger=False,<br/>    ):<br/>        if not hasattr(self, "initted"):<br/>            self.model_name = model_name<br/>            self.air = air<br/>            self.tilt = tilt<br/>            self.cruise_control = cruise_control<br/>            self.power_locks = power_locks<br/>            self.alloy_wheels = alloy_wheels<br/>            self.usb_charger = usb_charger<br/>            self.initted = True<br/><br/></pre>
<p>The <kbd>if</kbd> statement ensures that we only initialize the object the first time <kbd>__init__</kbd> is called. This means we can call the factory later with just the model name and get the same flyweight object back. However, because the flyweight will be garbage-collected if no external references to it exist, we must be careful not to accidentally create a new flyweight with null values.</p>
<p>Let's add a method to our flyweight that hypothetically looks up a serial number on a specific model of vehicle, and determines whether it has been involved in any accidents. This method needs access to the car's serial number, which varies from car to car; it cannot be stored with the flyweight. Therefore, this data must be passed into the method by the calling <span>code, as follows</span>:</p>
<pre>    def check_serial(self, serial_number):<br/>        print(<br/>            "Sorry, we are unable to check "<br/>            "the serial number {0} on the {1} "<br/>            "at this time".format(serial_number, self.model_name)<br/>        )</pre>
<p>We can define a class that stores the additional information, as well as a reference to the <span>flyweight, as follows</span>:</p>
<pre>class Car: 
    def __init__(self, model, color, serial): 
        self.model = model 
        self.color = color 
        self.serial = serial 
 
    def check_serial(self): 
        return self.model.check_serial(self.serial) </pre>
<p>We can also keep track of the available models, as well as the individual cars on the <span>lot, as follows</span>:</p>
<pre><strong>&gt;&gt;&gt; dx = CarModel("FIT DX")</strong>
<strong>&gt;&gt;&gt; lx = CarModel("FIT LX", air=True, cruise_control=True,</strong>
<strong>... power_locks=True, tilt=True)</strong>
<strong>&gt;&gt;&gt; car1 = Car(dx, "blue", "12345")</strong>
<strong>&gt;&gt;&gt; car2 = Car(dx, "black", "12346")</strong>
<strong>&gt;&gt;&gt; car3 = Car(lx, "red", "12347")</strong>  </pre>
<p>Now, let's demonstrate the weak referencing at <span>work in the following code snippet</span>:</p>
<pre><strong>&gt;&gt;&gt; id(lx)</strong>
<strong>3071620300</strong>
<strong>&gt;&gt;&gt; del lx</strong>
<strong>&gt;&gt;&gt; del car3</strong>
<strong>&gt;&gt;&gt; import gc</strong>
<strong>&gt;&gt;&gt; gc.collect()</strong>
<strong>0</strong>
<strong>&gt;&gt;&gt; lx = CarModel("FIT LX", air=True, cruise_control=True,</strong>
<strong>... power_locks=True, tilt=True)</strong>
<strong>&gt;&gt;&gt; id(lx)</strong>
<strong>3071576140</strong>
<strong>&gt;&gt;&gt; lx = CarModel("FIT LX")</strong>
<strong>&gt;&gt;&gt; id(lx)</strong>
<strong>3071576140</strong>
<strong>&gt;&gt;&gt; lx.air</strong>
<strong>True</strong>  </pre>
<p>The <kbd>id</kbd> function tells us the unique identifier for an object. When we call it a second time, after deleting all references to the LX model and forcing garbage collection, we see that the ID has changed. The value in the <kbd>CarModel __new__</kbd> factory dictionary was deleted and a fresh one was created. If we then try to construct a second <kbd>CarModel</kbd> instance, however, it returns the same object (the IDs are the same), and, even though we did not supply any arguments in the second call, the <kbd>air</kbd> variable is still set to <kbd>True</kbd>. This means the object was not initialized the second time, just as we designed.</p>
<p>Obviously, using the flyweight pattern is more complicated than just storing features on a single car class. When should we choose to use it? The flyweight pattern is designed for conserving memory; if we have hundreds of thousands of similar objects, combining similar properties into a flyweight can have an enormous impact on memory consumption.</p>
<p>It is common for programming solutions that optimize CPU, memory, or disk space to result in more complicated code than their unoptimized brethren. It is therefore important to weigh up the trade-offs when deciding between code maintainability and optimization. When choosing optimization, try to use patterns such as flyweight to ensure that the complexity introduced by optimization is confined to a single (well-documented) section of the code.</p>
<div class="packt_tip">If you have a lot of Python objects in one program, one of the quickest ways to save memory is through the use of <kbd>__slots__</kbd>. The <kbd>__slots__</kbd> magic method is beyond the scope of this book, but there is plenty of information available if you check online. If you are still low on memory, flyweight may be a reasonable solution.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The command pattern</h1>
                </header>
            
            <article>
                
<p>The command pattern adds a level of abstraction between actions that must be done and the object that invokes those actions, normally at a later time. In the command pattern, client code creates a <kbd>Command</kbd> object that can be executed at a later date. This object knows about a receiver object that manages its own internal state when the command is executed on it. The <kbd>Command</kbd> object implements a specific interface (typically, it has an <kbd>execute</kbd> or <kbd>do_action</kbd> method, and also keeps track of any arguments required to perform the action. Finally, one or more <kbd>Invoker</kbd> objects execute the command at the correct time.</p>
<p>Here's the UML diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e52cf46a-6bfd-4406-ad35-8d763854b323.png" style="width:21.00em;height:14.25em;"/></div>
<p>A common example of the command pattern is actions on a graphical window. Often, an action can be invoked by a menu item on the menu bar, a keyboard shortcut, a toolbar icon, or a context menu. These are all examples of <kbd>Invoker</kbd> objects. The actions that actually occur, such as <kbd>Exit</kbd>, <kbd>Save</kbd>, or <kbd>Copy</kbd>, are implementations of <kbd>CommandInterface</kbd>. A GUI window to receive exit, a document to receive save, and <kbd>ClipboardManager</kbd> to receive copy commands, are all examples of possible <kbd>Receivers</kbd>.</p>
<p>Let's implement a simple command pattern that provides commands for <kbd>Save</kbd> and <kbd>Exit</kbd> actions. We'll start with some modest receiver classes, <span>themselves with the following code</span>:</p>
<pre>import sys 
 
class Window: 
    def exit(self): 
        sys.exit(0) 
 
class Document: 
    def __init__(self, filename): 
        self.filename = filename 
        self.contents = "This file cannot be modified" 
 
    def save(self): 
        with open(self.filename, 'w') as file: 
            file.write(self.contents) </pre>
<p>These mock classes model objects that would likely be doing a lot more in a working environment. The window would need to handle mouse movement and keyboard events, and the document would need to handle character insertion, deletion, and selection. But for our example, these two classes will do what we need.</p>
<p>Now let's define some invoker classes. These will model toolbar, menu, and keyboard events that can happen; again, they aren't actually hooked up to anything, but we can see how they are decoupled from the command, receiver, and client <span>code in the following code snippet</span>:</p>
<pre>class ToolbarButton:<br/>    def __init__(self, name, iconname):<br/>        self.name = name<br/>        self.iconname = iconname<br/><br/>    def click(self):<br/>        self.command.execute()<br/><br/><br/>class MenuItem:<br/>    def __init__(self, menu_name, menuitem_name):<br/>        self.menu = menu_name<br/>        self.item = menuitem_name<br/><br/>    def click(self):<br/>        self.command.execute()<br/><br/><br/>class KeyboardShortcut:<br/>    def __init__(self, key, modifier):<br/>        self.key = key<br/>        self.modifier = modifier<br/><br/>    def keypress(self):<br/>        self.command.execute()</pre>
<p>Notice how the various action methods each call the <kbd>execute</kbd> method on their respective commands? This code doesn't show the <kbd>command</kbd> attribute being set on each object. They could be passed into the <kbd>__init__</kbd> function, but because they may be changed (for example, with a customizable keybinding editor), it makes more sense to set the attributes on the objects afterwards.</p>
<p>Now, let's hook up the commands <span>themselves with the following code</span>:</p>
<pre>class SaveCommand:<br/>    def __init__(self, document):<br/>        self.document = document<br/><br/>    def execute(self):<br/>        self.document.save()<br/><br/><br/>class ExitCommand:<br/>    def __init__(self, window):<br/>        self.window = window<br/><br/>    def execute(self):<br/>        self.window.exit()</pre>
<p>These commands are straightforward; they demonstrate the basic pattern, but it is important to note that we can store state and other information with the command if necessary. For example, if we had a command to insert a character, we could maintain state for the character currently being inserted.</p>
<p>Now all we have to do is hook up some client and test code to make the commands work. For basic testing, we can just include the following code at the end of the script:</p>
<pre>window = Window() 
document = Document("a_document.txt") 
save = SaveCommand(document) 
exit = ExitCommand(window) 
 
save_button = ToolbarButton('save', 'save.png') 
save_button.command = save 
save_keystroke = KeyboardShortcut("s", "ctrl") 
save_keystroke.command = save 
exit_menu = MenuItem("File", "Exit") 
exit_menu.command = exit </pre>
<p>First, we create two receivers and two commands. Then, we create several of the available invokers and set the correct command on each of them. To test, we can use <kbd>python3</kbd><kbd>-i</kbd><kbd>filename.py</kbd> and run code such as <kbd>exit_menu.click()</kbd>, which will end the program, or <kbd>save_keystroke.keystroke()</kbd>, which will save the fake file.</p>
<p>Unfortunately, the preceding examples do not feel terribly Pythonic. They have a lot of "boilerplate code" (code that does not accomplish anything, but only provides structure to the pattern), and the <kbd>Command</kbd> classes are all eerily similar to each other. Perhaps we could create a generic command object that takes a function as a callback?</p>
<p>In fact, why bother? Can we just use a function or method object for each command? Instead of an object with an <kbd>execute()</kbd> method, we can write a function and use that as the command directly. The following is a common paradigm for the command pattern in Python:</p>
<pre>import sys<br/><br/><br/>class Window:<br/>    def exit(self):<br/>        sys.exit(0)<br/><br/><br/>class MenuItem:<br/>    def click(self):<br/>        self.command()<br/><br/><br/>window = Window()<br/>menu_item = MenuItem()<br/>menu_item.command = window.exit</pre>
<p>Now that looks a lot more like Python. At first glance, it looks like we've removed the command pattern altogether, and we've tightly connected the <kbd>menu_item</kbd> and <kbd>Window</kbd> classes. But if we look closer, we find there is no tight coupling at all. Any callable can be set up as the command on <kbd>MenuItem</kbd>, just as before. And the <kbd>Window.exit</kbd> method can be attached to any invoker. Most of the flexibility of the command pattern has been maintained. We have sacrificed complete decoupling for readability, but this code is, in my opinion, and that of many Python programmers, more maintainable than the fully abstracted version.</p>
<p>Of course, since we can add a <kbd>__call__</kbd> method to any object, we aren't restricted to functions. The previous example is a useful shortcut when the method being called doesn't have to maintain state, but in more advanced usage, we can use <span>the following</span> code as well:</p>
<pre>class Document:<br/>    def __init__(self, filename):<br/>        self.filename = filename<br/>        self.contents = "This file cannot be modified"<br/><br/>    def save(self):<br/>        with open(self.filename, "w") as file:<br/>            file.write(self.contents)<br/><br/><br/>class KeyboardShortcut:<br/>    def keypress(self):<br/>        self.command()<br/><br/><br/>class SaveCommand:<br/>    def __init__(self, document):<br/>        self.document = document<br/><br/>    def __call__(self):<br/>        self.document.save()<br/><br/><br/>document = Document("a_file.txt")<br/>shortcut = KeyboardShortcut()<br/>save_command = SaveCommand(document)<br/>shortcut.command = save_command</pre>
<p>Here, we have something that looks like the first command pattern, but a bit more idiomatic. As you can see, making the invoker call a callable instead of a <kbd>command</kbd> object with an execute method has not restricted us in any way. In fact, it's given us more flexibility. We can link to functions directly when that works, yet we can build a complete callable <kbd>command</kbd> object when the situation calls for it.</p>
<p>The command pattern is often extended to support undoable commands. For example, a text program may wrap each insertion in a separate command with not only an <kbd>execute</kbd> method, but also an <kbd>undo</kbd> method that will delete that insertion. A graphics program may wrap each drawing action (rectangle, line, freehand pixels, and so on) in a command that has an <kbd>undo</kbd> method that resets the pixels to their original state. In such cases, the decoupling of the command pattern is much more obviously useful, because each action has to maintain enough of its state to undo that action at a later date.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The abstract factory pattern</h1>
                </header>
            
            <article>
                
<p>The abstract factory pattern is normally used when we have multiple possible implementations of a system that depend on some configuration or platform issue. The calling code requests an object from the abstract factory, not knowing exactly what class of object will be returned. The underlying implementation returned may depend on a variety of factors, such as current locale, operating system, or local configuration.</p>
<p>Common examples of the abstract factory pattern include code for operating-system-independent toolkits, database backends, and country-specific formatters or calculators. An operating-system-independent GUI toolkit might use an abstract factory pattern that returns a set of WinForm widgets under Windows, Cocoa widgets under Mac, GTK widgets under Gnome, and QT widgets under KDE. Django provides an abstract factory that returns a set of object relational classes for interacting with a specific database backend (MySQL, PostgreSQL, SQLite, and others) depending on a configuration setting for the current site. If the application needs to be deployed in multiple places, each one can use a different database backend by changing only one configuration variable. Different countries have different systems for calculating taxes, subtotals, and totals on retail merchandise; an abstract factory can return a particular tax calculation object.</p>
<p>The UML class diagram for an abstract factory pattern is hard to understand without a specific example, so let's turn things around and create a concrete example first. In our example, we'll create a set of formatters that depend on a specific locale and help us format dates and currencies. There will be an abstract factory class that picks the specific factory, as well as a couple of example concrete factories, one for France and one for the USA. Each of these will create formatter objects for dates and times, which can be queried to format a specific value. <span>This is depicted in the following diagram</span>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/f5f237a6-54d7-45f3-9978-66742550e887.png" style="width:45.83em;height:23.75em;"/></div>
<p>Comparing that image to the earlier, simpler text shows that a picture is not always worth a thousand words, especially considering we haven't even allowed for factory selection code here.</p>
<p>Of course, in Python, we don't have to implement any interface classes, so we can discard <kbd>DateFormatter</kbd>, <kbd>CurrencyFormatter</kbd>, and <kbd>FormatterFactory</kbd>. The formatting classes themselves are pretty straightforward, if <span>verbose, shown here</span>:</p>
<pre>class FranceDateFormatter:<br/>    def format_date(self, y, m, d):<br/>        y, m, d = (str(x) for x in (y, m, d))<br/>        y = "20" + y if len(y) == 2 else y<br/>        m = "0" + m if len(m) == 1 else m<br/>        d = "0" + d if len(d) == 1 else d<br/>        return "{0}/{1}/{2}".format(d, m, y)<br/><br/><br/>class USADateFormatter:<br/>    def format_date(self, y, m, d):<br/>        y, m, d = (str(x) for x in (y, m, d))<br/>        y = "20" + y if len(y) == 2 else y<br/>        m = "0" + m if len(m) == 1 else m<br/>        d = "0" + d if len(d) == 1 else d<br/>        return "{0}-{1}-{2}".format(m, d, y)<br/><br/><br/>class FranceCurrencyFormatter:<br/>    def format_currency(self, base, cents):<br/>        base, cents = (str(x) for x in (base, cents))<br/>        if len(cents) == 0:<br/>            cents = "00"<br/>        elif len(cents) == 1:<br/>            cents = "0" + cents<br/><br/>        digits = []<br/>        for i, c in enumerate(reversed(base)):<br/>            if i and not i % 3:<br/>                digits.append(" ")<br/>            digits.append(c)<br/>        base = "".join(reversed(digits))<br/>        return "{0}€{1}".format(base, cents)<br/><br/><br/>class USACurrencyFormatter:<br/>    def format_currency(self, base, cents):<br/>        base, cents = (str(x) for x in (base, cents))<br/>        if len(cents) == 0:<br/>            cents = "00"<br/>        elif len(cents) == 1:<br/>            cents = "0" + cents<br/>        digits = []<br/>        for i, c in enumerate(reversed(base)):<br/>            if i and not i % 3:<br/>                digits.append(",")<br/>            digits.append(c)<br/>        base = "".join(reversed(digits))<br/>        return "${0}.{1}".format(base, cents)</pre>
<p>These classes use some basic string manipulation to try to turn a variety of possible inputs (integers, strings of different lengths, and others) into the following formats:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td/>
<td class="CDPAlignCenter CDPAlign">
<p><strong>USA</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><strong>France</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>Date</strong></p>
</td>
<td>
<p>mm-dd-yyyy</p>
</td>
<td>
<p>dd/mm/yyyy</p>
</td>
</tr>
<tr>
<td>
<p><strong>Currency</strong></p>
</td>
<td>
<p>$14,500.50</p>
</td>
<td>
<p>14 500€50</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>
<p>There could obviously be more validation on the input in this code, but let's keep it simple for this example.</p>
<p>Now that we have the formatters set up, we just need to create the formatter <span>factories, as follows</span>:</p>
<pre>class USAFormatterFactory:<br/>    def create_date_formatter(self):<br/>        return USADateFormatter()<br/><br/>    def create_currency_formatter(self):<br/>        return USACurrencyFormatter()<br/><br/><br/>class FranceFormatterFactory:<br/>    def create_date_formatter(self):<br/>        return FranceDateFormatter()<br/><br/>    def create_currency_formatter(self):<br/>        return FranceCurrencyFormatter()</pre>
<p>Now we set up the code that picks the appropriate formatter. Since this is the kind of thing that only needs to be set up once, we could make it a singleton–except singletons aren't very useful in Python. Let's just make the current formatter a module-level variable instead:</p>
<pre>country_code = "US"<br/>factory_map = {"US": USAFormatterFactory, "FR": FranceFormatterFactory}<br/>formatter_factory = factory_map.get(country_code)()</pre>
<p>In this example, we hardcode the current country code; in practice, it would likely introspect the locale, the operating system, or a configuration file to choose the code. This example uses a dictionary to associate the country codes with factory classes. Then, we grab the correct class from the dictionary and instantiate it.</p>
<p>It is easy to see what needs to be done when we want to add support for more countries: create the new formatter classes and the abstract factory itself. Bear in mind that <kbd>Formatter</kbd> classes might be reused; for example, Canada formats its currency the same way as the USA, but its date format is more sensible than its Southern neighbor.</p>
<p>Abstract factories often return a singleton object, but this is not required. In our code, it's returning a new instance of each formatter every time it's called. There's no reason the formatters couldn't be stored as instance variables and the same instance returned for each factory.</p>
<p>Looking back at these examples, we see that, once again, there appears to be a lot of boilerplate code for factories that just doesn't feel necessary in Python. Often, the requirements that might call for an abstract factory can be more easily fulfilled by using a separate module for each factory type (for example: the USA and France), and then ensuring that the correct module is being accessed in a factory module. The package structure for such modules might look like <span>this</span>:</p>
<pre>localize/ 
    __init__.py 
    backends/ 
        __init__.py 
        USA.py 
        France.py 
        ... </pre>
<p>The trick is that <kbd>__init__.py</kbd> in the <kbd>localize</kbd> package can contain logic that redirects all requests to the correct backend. There are a variety of ways this might be done.</p>
<p>If we know that the backend is never going to change dynamically (that is, without a program restart), we can just put some <kbd>if</kbd> statements in <kbd>__init__.py</kbd> that check the current country code, and use the (normally unacceptable) <kbd>from</kbd><kbd>.backends.USA</kbd><kbd>import</kbd><kbd>*</kbd> syntax to import all variables from the appropriate backend. Or, we could import each of the backends and set a <kbd>current_backend</kbd> variable to point at a specific <span>module, as follows</span>:</p>
<pre>from .backends import USA, France 
 
if country_code == "US": 
    current_backend = USA </pre>
<p>Depending on which solution we choose, our client code would have to call either <kbd>localize.format_date</kbd> or <kbd>localize.current_backend.format_date</kbd> to get a date formatted in the current country's locale. The end result is much more Pythonic than the original abstract factory pattern and, in typical usage, is just as flexible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The composite pattern</h1>
                </header>
            
            <article>
                
<p>The composite pattern allows complex tree-like structures to be built from simple components. These components, called composite objects, are able to behave sort of like a container and sort of like a variable, depending on whether they have child components. Composite objects are container objects, where the content may actually be another composite object.</p>
<p>Traditionally, each component in a composite object must be either a leaf node (that cannot contain other objects) or a composite node. The key is that both composite and leaf nodes can have the same interface. The following UML diagram <span>is very simple</span>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/9fa1eb55-b038-4c5b-b10c-c5f34bf86e4d.png" style="width:18.75em;height:9.83em;"/></div>
<p>This simple pattern, however, allows us to create complex arrangements of elements, all of which satisfy the interface of the component object. <span>The following diagram depicts</span> a concrete instance of such a complicated arrangement:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/99c562f9-c96b-4219-874e-c832fc7aa6ea.png" style="width:23.08em;height:11.42em;"/></div>
<p>The composite pattern is commonly useful in file/folder-like trees. Regardless of whether a node in the tree is a normal file or a folder, it is still subject to operations such as moving, copying, or deleting the node. We can create a component interface that supports these operations, and then use a composite object to represent folders, and leaf nodes to represent normal files.</p>
<p>Of course, in Python, once again, we can take advantage of duck typing to implicitly provide the interface, so we only need to write two classes. Let's define these interfaces <span>first in the following code</span>:</p>
<pre>class Folder: 
    def __init__(self, name): 
        self.name = name 
        self.children = {} 
 
    def add_child(self, child): 
        pass 
 
    def move(self, new_path): 
        pass 
 
    def copy(self, new_path): 
        pass 
 
    def delete(self): 
        pass 
 <br/>class File: 
    def __init__(self, name, contents): 
        self.name = name 
        self.contents = contents 
 
    def move(self, new_path): 
        pass 
 
    def copy(self, new_path): 
        pass 
 
    def delete(self): 
        pass </pre>
<p>For each folder (composite) object, we maintain a dictionary of children. For many composite implementations, a list is sufficient, but in this case, a dictionary will be useful for looking up children by name. Our paths will be specified as node names separated by the <kbd>/</kbd> character, similar to paths in a Unix shell.</p>
<p>Thinking about the methods involved, we can see that moving or deleting a node behaves in a similar way, regardless of whether or not it is a file or folder node. Copying, however, has to do a recursive copy for folder nodes, while copying a file node is a trivial operation.</p>
<p>To take advantage of the similar operations, we can extract some of the common methods into a parent class. Let's take that discarded <kbd>Component</kbd> interface and change it to a base <span>class with the following code</span>:</p>
<pre>class Component:<br/>    def __init__(self, name):<br/>        self.name = name<br/><br/>    def move(self, new_path):<br/>        new_folder = get_path(new_path)<br/>        del self.parent.children[self.name]<br/>        new_folder.children[self.name] = self<br/>        self.parent = new_folder<br/><br/>    def delete(self):<br/>        del self.parent.children[self.name]<br/><br/><br/>class Folder(Component):<br/>    def __init__(self, name):<br/>        super().__init__(name)<br/>        self.children = {}<br/><br/>    def add_child(self, child):<br/>        pass<br/><br/>    def copy(self, new_path):<br/>        pass<br/><br/><br/>class File(Component):<br/>    def __init__(self, name, contents):<br/>        super().__init__(name)<br/>        self.contents = contents<br/><br/>    def copy(self, new_path):<br/>        pass<br/><br/><br/>root = Folder("")<br/><br/><br/>def get_path(path):<br/>    names = path.split("/")[1:]<br/>    node = root<br/>    for name in names:<br/>        node = node.children[name]<br/>    return node</pre>
<p>We've created the <kbd>move</kbd> and <kbd>delete</kbd> methods on the <kbd>Component</kbd> class. Both of them access a mysterious <kbd>parent</kbd> variable that we haven't set yet. The <kbd>move</kbd> method uses a module-level <kbd>get_path</kbd> function that finds a node from a predefined root node, given a path. All files will be added to this root node or a child of that node. For the <kbd>move</kbd> method, the target should be an existing folder, or we'll get an error. As in many examples in technical books, error handling is woefully absent, to help focus on the principles under consideration.</p>
<p>Let's set up that mysterious <kbd>parent</kbd> variable in the folder's <kbd>add_child</kbd> method<span>, as follows</span>:</p>
<pre>    def add_child(self, child):<br/>        child.parent = self<br/>        self.children[child.name] = child</pre>
<p>Well, that was easy enough. Let's see if our composite file hierarchy is working <span>properly with the following code snippet</span>:</p>
<pre><strong>$ python3 -i 1261_09_18_add_child.py</strong>

<strong>&gt;&gt;&gt; folder1 = Folder('folder1')</strong>
<strong>&gt;&gt;&gt; folder2 = Folder('folder2')</strong>
<strong>&gt;&gt;&gt; root.add_child(folder1)</strong>
<strong>&gt;&gt;&gt; root.add_child(folder2)</strong>
<strong>&gt;&gt;&gt; folder11 = Folder('folder11')</strong>
<strong>&gt;&gt;&gt; folder1.add_child(folder11)</strong>
<strong>&gt;&gt;&gt; file111 = File('file111', 'contents')</strong>
<strong>&gt;&gt;&gt; folder11.add_child(file111)</strong>
<strong>&gt;&gt;&gt; file21 = File('file21', 'other contents')</strong>
<strong>&gt;&gt;&gt; folder2.add_child(file21)</strong>
<strong>&gt;&gt;&gt; folder2.children</strong>
<strong>{'file21': &lt;__main__.File object at 0xb7220a4c&gt;}</strong>
<strong>&gt;&gt;&gt; folder2.move('/folder1/folder11')</strong>
<strong>&gt;&gt;&gt; folder11.children</strong>
<strong>{'folder2': &lt;__main__.Folder object at 0xb722080c&gt;, 'file111': &lt;__main__.File object at <br/>0xb72209ec&gt;}</strong>
<strong>&gt;&gt;&gt; file21.move('/folder1')</strong>
<strong>&gt;&gt;&gt; folder1.children</strong>
<strong>{'file21': &lt;__main__.File object at 0xb7220a4c&gt;, 'folder11': &lt;__main__.Folder object at <br/>0xb722084c&gt;}</strong>  </pre>
<p>Yes, we can create folders, add folders to other folders, add files to folders, and move them around! What more could we ask for in a file hierarchy?</p>
<p>Well, we could ask for copying to be implemented, but to conserve trees, let's leave that as an exercise.</p>
<p>The composite pattern is extremely useful for a variety of tree-like structures, including GUI widget hierarchies, file hierarchies, tree sets, graphs, and HTML DOM. It can be a useful pattern in Python when implemented according to the traditional implementation, as in the example demonstrated earlier. Sometimes, if only a shallow tree is being created, we can get away with a list of lists or a dictionary of dictionaries, and do not need to implement custom component, leaf, and composite classes. Other times, we can get away with implementing only one composite class, and treating leaf and composite objects as a single class. Alternatively, Python's duck typing can make it easy to add other objects to a composite hierarchy, as long as they have the correct interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>Before diving into exercises for each design pattern, take a moment to implement the <kbd>copy</kbd> method for the <kbd>File</kbd> and <kbd>Folder</kbd> objects in the previous section. The <kbd>File</kbd> method should be quite trivial; just create a new node with the same name and contents, and add it to the new parent folder. The <kbd>copy</kbd> method on <kbd>Folder</kbd> is quite a bit more complicated, as you first have to duplicate the folder, and then recursively copy each of its children to the new location. You can call the <kbd>copy()</kbd> method on the children indiscriminately, regardless of whether each is a file or a folder object. This will drive home just how powerful the composite pattern can be.</p>
<p>Now, as in the previous chapter, look at the patterns we've discussed and consider ideal places where you might implement them. You may want to apply the adapter pattern to existing code, as it is usually applicable when interfacing with existing libraries, rather than new code. How can you use an adapter to force two interfaces to interact with each other correctly?</p>
<p>Can you think of a system complex enough to justify using the facade pattern? Consider how facades are used in real-life situations, such as the driver-facing interface of a car, or the control panel in a factory. It is similar in software, except the users of the facade interface are other programmers, rather than people trained to use them. Are there complex systems in your latest project that could benefit from the facade pattern?</p>
<p>It's possible you don't have any huge, memory-consuming code that would benefit from the flyweight pattern, but can you think of situations where it might be useful? Anywhere that large amounts of overlapping data need to be processed, a flyweight is waiting to be used. Would it be useful in the banking industry? In web applications? At what point does adopting the flyweight pattern make sense? When is it overkill?</p>
<p>What about the command pattern? Can you think of any common (or better yet, uncommon) examples of places where the decoupling of action from invocation would be useful? Look at the programs you use on a daily basis and imagine how they are implemented internally. It's likely that many of them use the command pattern for one purpose or another.</p>
<p>The abstract factory pattern, or the somewhat more Pythonic derivatives we discussed, can be very useful for creating one-touch-configurable systems. Can you think of places where such systems are useful?</p>
<p>Finally, consider the composite pattern. There are tree-like structures all around us in programming; some of them, like our file hierarchy example, are blatant; others are fairly subtle. What situations might arise where the composite pattern would be useful? Can you think of places where you can use it in your own code? What if you adapted the pattern slightly; for example, to contain different types of leaf or composite nodes for different types of objects?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we went into detail on several more design patterns, covering their canonical descriptions as well as alternatives for implementing them in Python, which is often more flexible and versatile than traditional object-oriented languages. The adapter pattern is useful for matching interfaces, while the facade pattern is suited to simplifying them. Flyweight is a complicated pattern and only useful if memory optimization is required. In Python, the command pattern is often more aptly implemented using first class functions as callbacks. Abstract factories allow runtime separation of implementations depending on configuration or system information. The composite pattern is used universally for tree-like structures.</p>
<p>This is the last of the truly object-oriented chapters in this book, but I've thrown in a couple of freebies on topics very dear to my heart. In the next chapter, we'll discuss how important it is to test Python programs, and how to do it, focusing on object-oriented principles.</p>


            </article>

            
        </section>
    </body></html>