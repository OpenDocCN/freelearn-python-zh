- en: Internationalization and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will *internationalize* our GUI by displaying text on labels,
    buttons, tabs, and other widgets, in different languages. We will start simply
    and then explore how we can prepare our GUI for internationalization at the design
    level.
  prefs: []
  type: TYPE_NORMAL
- en: We will also *localize* the GUI, which is slightly different from internationalization.
  prefs: []
  type: TYPE_NORMAL
- en: As these words are long, they have been abbreviated to use the first character
    of the word, followed by the total number of characters in between the first and
    last character, followed by the last character of the word. So, **internationalization**
    becomes **I18N**, and **localization** becomes **L10N**.
  prefs: []
  type: TYPE_NORMAL
- en: We will also test our GUI code, write unit tests, and explore the value unit
    tests can provide in our development efforts, which will lead us to the best practice
    of refactoring our code.
  prefs: []
  type: TYPE_NORMAL
- en: There are no additional Python packages to install. We write our own code in
    Python and the unit testing framework is shipped with Python, so we can simply
    import it.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to both internationalize and test our code is an essential skill
    every programmer needs to know.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will acquire the valuable skills of testing, refactoring,
    and internationalization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an overview of the Python modules for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f041c29-7d58-4cef-9e94-ac5800a8bd3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will internationalize and test our Python GUI, covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying widget text in different languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the entire GUI language all at once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localizing the GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the GUI for internationalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design a GUI in an agile fashion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need to test the GUI code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting debug watches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring different debug output levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating self-testing code using Python's `__main__` section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating robust GUIs using unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write unit tests using the Eclipse PyDev **Integrated Development Environment**
    (**IDE**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying widget text in different languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to internationalize text strings in Python is by moving them
    into a separate Python module and then selecting the language to be displayed
    in our GUI by passing in an argument to this module.
  prefs: []
  type: TYPE_NORMAL
- en: While this approach, according to online search results, is not highly recommended,
    depending on the specific requirements of the application you are developing,
    it may still be the most pragmatic and fastest to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will reuse the Python GUI we created earlier in [Chapter 7](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml),
    *Storing Data in Our MySQL Database via Our GUI*. We will comment out one line
    of Python code that creates the MySQL tab because we do not interact with a MySQL
    database in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will start the I18N of our GUI by changing the window's title
    from English to another language.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name *GUI* is the same in other languages, we will first expand the
    name that enables us to see the visual effects of our changes. Let''s now see
    the steps in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_MySQL.py` from the previous chapter ([Chapter 7](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml), *Storing
    Data in Our MySQL Database via Our GUI*) and save it as `GUI.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following was our previous line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change this to the following code. Also, comment out the creation of
    the MySQL tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code change results in the following title for our GUI program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b43f000a-c0ef-4dd7-8a05-94e08d5038b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Please note that, in this chapter, we will use English and German to exemplify
    the principle of internationalizing our Python GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new Python module and name it `LanguageResources.py`. Let's next
    move the English string of our GUI title into this module and also create a German
    version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `I18N` class and change the language to `''de''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code, we now get the following internationalized result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1791aa33-d031-499b-9a45-1dbfa640a7ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from s*tep 4*, we break out the hardcoded strings that are part of
    our GUI into their own separate module, `LanguageResources.py`. Within the class's
    `__init__()` method, we select which language our GUI will display, depending
    on the passed-in language argument. We then import the `LanguageResources.py` module
    into our OOP class module.
  prefs: []
  type: TYPE_NORMAL
- en: We set the default language to `'en'`, which means English.
  prefs: []
  type: TYPE_NORMAL
- en: Within `GUI.py`, we are creating an instance of the `I18N` class. This class
    resides in `LanguageResources.py`, so the name of our class is shorter and different
    to the name of the Python module. We save the selected language in a class instance
    attribute, `self.i18n`, and use it to display the title. We are separating the
    GUI from the languages it displays, which is an OOP design principle.
  prefs: []
  type: TYPE_NORMAL
- en: We can further modularize our code by separating the internationalized strings
    into separate files, potentially in XML or another format. We could also read
    them from a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: This is a **separation of concerns** (**SoC**) coding approach, which is at
    the heart of OOP programming.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the entire GUI language all at once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will change all of the GUI display names, all at once, by
    refactoring all the previously hardcoded English strings into a separate Python
    module and then internationalizing those strings.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows that it is a good design principle to avoid hardcoding any
    strings, that our GUI displays, but to separate the GUI code from the text that
    is displayed by the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Designing our GUI in a modular way makes internationalizing it much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue to use the GUI from the previous recipe, `GUI.py`. In that
    recipe, we had already internationalized the title of the GUI. We will enhance
    the `LanguageResources.py` module from the previous recipe as well by adding more internationalized strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to internationalize the text displayed in all of our GUI widgets,
    we have to move all hardcoded strings into a separate Python module, and this
    is what we''ll do next:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `LanguageResources.py` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code for the English internationalized strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Python `GUI.py` module, replace all the hardcoded strings with an instance of
    our new `I18N` class, for example, `self.i18n.colorsIn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can now implement the translation to German by simply filling in the variable
    names with the corresponding words.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `LanguageResources.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our GUI code, we can now change the entire GUI display language in one line
    of Python code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code creates the following internationalized GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/878bc719-1be8-48da-86c6-8d1f4444aad9.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now see how this recipe works!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to internationalize our GUI, we refactored hardcoded strings into a
    separate module and then used the same class instance attributes to internationalize
    our GUI by passing in a string to the initializer of our `I18N` class, effectively
    controlling the language our GUI displays.
  prefs: []
  type: TYPE_NORMAL
- en: Note how all of the previously hardcoded English strings have been replaced
    by calls to the instance of our new `I18N` class. One example is `self.win.title(self.i18n.title)`.
  prefs: []
  type: TYPE_NORMAL
- en: What this gives us is the ability to internationalize our GUI. We simply have
    to use the same variable names and combine them by passing in a parameter to select
    the language we wish to display.
  prefs: []
  type: TYPE_NORMAL
- en: We could change languages on the fly as part of the GUI as well, or we could
    read the local PC settings and decide which language our GUI text should display
    according to those settings. An example of how to read the local settings is covered
    in the next recipe, *Localizing the GUI*.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, every single string of every widget, including the title of our
    GUI, the tab control names, and so on, were all hardcoded and intermixed with
    the code that creates the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to think about how we can best internationalize our GUI at
    the design phase of our GUI software development process.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we internationalized all strings displayed in our GUI widgets.
    We are not internationalizing the text entered into our GUI, because this depends
    on the local settings on your PC.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the first step of internationalizing our GUI, the next step is to *localize*
    it. Why would we wish to do this?
  prefs: []
  type: TYPE_NORMAL
- en: Well, here in the United States of America, we are all cowboys and we live in
    different time zones.
  prefs: []
  type: TYPE_NORMAL
- en: While we are internationalized to the US, our horses do wake up in different
    time zones (and do expect to be fed according to their own inner horse time zone
    schedule).
  prefs: []
  type: TYPE_NORMAL
- en: This is where *localization* comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are extending the GUI we developed in the previous recipe by localizing it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to perform this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by first installing the Python `pytz` time zone module, using `pip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open Command Prompt and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When the installation is successful, we get the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/faed9de8-a4c7-4a82-8742-d82e0d1639ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we add a new `Button` widget to `GUI.py`. We can list all the existing
    time zones by running the following code, which will display the time zones in
    our `ScrolledText` widget by adding the `allTimeZones` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking our new `Button` widget results in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5795c9c0-45fa-49c0-97dc-d050e45f18a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Install the `tzlocal` Python module using `pip`, and then we can display our
    current locale by adding the `localZone` method and connecting it to a new `Button`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We internationalize the strings of our two new buttons in `LanguageResources.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The English version is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The German version is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking our new button now tells us which time zone we are in (hey, we didn''t
    know that, did we…):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2547fc31-bbac-4de3-986c-7947309aca10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now change our local time to US EST by first converting it to **Coordinated
    Universal Time** (**UTC**) and then applying the time zone function from the imported
    `pytz` module. Next, add the following code to `GUI.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking the button, now renamed as New York, results in the following output
    in label 2 in the top-left corner of the GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a32db2f-5e9e-4857-88f4-6c09206c8dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the following output in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6db51bd4-1ec8-4e0f-aec2-6dd2f658d0c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's learn about this recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we installed the Python `pytz` module using `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are using Python 3.7, which comes with the `pip` module built
    in. If you are using an older version of Python, then you may have to install
    the `pip` module first.
  prefs: []
  type: TYPE_NORMAL
- en: The screenshot in s*tep 2* shows that the `pip` command downloaded the `.whl` format.
    If you have not done so, you might have to install the Python wheel module as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: This installed the Python `pytz` module into the `site-packages` folder, so
    now we can import this module from our Python GUI code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to localize date and time information, we first need to convert our
    local time to UTC time. We then apply the time zone information and use the `astimezone`
    function from the `pytz` Python time zone module to convert to any time zone across
    the globe!
  prefs: []
  type: TYPE_NORMAL
- en: We installed the Python `tzlocal` module using `pip`, and now we can translate
    our local time to a different time zone. We used US EST as an example.
  prefs: []
  type: TYPE_NORMAL
- en: In s*tep 8*, we converted the local time of the US west coast to UTC and then
    displayed the US east coast time in label 2 (`self.lbl2`) of our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we are printing the UTC times of the cities Los Angeles and
    New York with their respective time zone conversions, relative to the UTC time
    to the console, using a US date formatting string.
  prefs: []
  type: TYPE_NORMAL
- en: UTC never observes **Daylight Saving Time** (**DST**). During **Eastern Daylight
    Time** (**EDT**), UTC is four hours ahead and, during standard time (EST), it
    is five hours ahead of the local time.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the GUI for internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will prepare our GUI for internationalization by realizing
    that not all is as easy as could be expected when translating English into foreign
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: We still have one problem to solve, which is how to properly display non-English
    Unicode characters from foreign languages.
  prefs: []
  type: TYPE_NORMAL
- en: You might expect that displaying the German ä, ö, and ü Unicode umlaut characters
    would be handled by Python 3.7 automatically, but this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue to use the Python GUI we developed in recent chapters. First,
    we will change the default language to German in the `GUI.py` initialization code.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe might be specific to the Eclipse PyDev IDE, but it is good to see
    this as an example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving deep into the recipe, we should know that when we change the word
    "Ueber" to the correct German word "Űber" using the umlaut character, the Eclipse
    PyDev plugin is not too happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see the steps of this recipe sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncomment the line `self.i18n = I18N('de')` in order to use German.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `GUI.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7db6e6a2-67d4-481d-be0b-cd12f02cdda0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get an error message, which is a little bit confusing because, when we run
    the same line of code from within the Eclipse PyDev Console, we get the expected
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0ce0803b-2443-428a-9e4a-71e4e96dacdc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we ask for the Python default encoding, we get the expected result, which
    is utf-8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b0b1388-5f90-4bb9-9d76-29ca5c88d6bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using Windows built-in character map, we can find the Unicode representation
    of the umlaut character, which is **U+00DC** for the capital **U** with an umlaut:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5dcb6c70-1228-4ae2-bac5-a78a1a9dfa3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While this workaround is truly ugly, it does the trick. Instead of typing in
    the literal character **Ü**, we can pass in the Unicode of **U+00DC** to get this
    character correctly displayed in our GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6ee94ee9-f13a-4c38-93c1-f9aba869c65a.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also just accept the change in the default encoding from Cp1252 to UTF-8
    using PyDev with Eclipse, but we may not always get the prompt to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instead, we might see the following error message displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4a6bd90-76d4-4a73-98c1-b77a931e44b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The way to solve this problem is to change the PyDev project''s Text file encoding
    setting to UTF-8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c39c62ca-7cdc-42df-adc0-78147a745aab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After changing the PyDev default encoding, we now can display those German
    umlaut characters. We also updated the title to use the correct German ä character, `GUI_.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/15aac6be-ccc7-49ac-9ca3-77f0240eb7ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internationalization and working with foreign language Unicode characters is
    often not as straightforward as we would wish.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we have to find workarounds, and expressing Unicode characters via
    Python by using the direct representation by prepending `\u` can do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows built-in character map shows us `"U+00DC"`, which we translate into
    Python as `"\u00DC"`.
  prefs: []
  type: TYPE_NORMAL
- en: We can always resort to the direct representation of Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: At other times, we just have to find the settings of our development environment
    to adjust. We saw an example of how to do this using the Eclipse IDE.
  prefs: []
  type: TYPE_NORMAL
- en: How to design a GUI in an agile fashion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modern agile software development approach to design and coding came out
    of the lessons learned by software professionals. This method applies to a GUI
    as much as to any other code. One of the main keys of agile software development
    is the continuously applied process of refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: One practical example of how refactoring our code can help us in our software
    development work is by first implementing some simple functionality using functions.
  prefs: []
  type: TYPE_NORMAL
- en: As our code grows in complexity, we might want to refactor our functions into
    methods of a class. This approach would enable us to remove global variables and
    also to be more flexible about where we place the methods inside the class.
  prefs: []
  type: TYPE_NORMAL
- en: While the functionality of our code has not changed, the structure has.
  prefs: []
  type: TYPE_NORMAL
- en: In this process, we code, test, refactor, and then test again. We do this in
    short cycles and often start with the minimum code required to get some functionality
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven software development is one particular style of the agile development
    methodology.
  prefs: []
  type: TYPE_NORMAL
- en: While our GUI is working nicely, our main `GUI.py` code has been ever-increasing
    in complexity, and it has started to get a little bit harder to maintain an overview
    of our code. This means that we need to refactor our code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will refactor the GUI we created in previous chapters. We will use the English
    version of the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already broken out all the names our GUI displays when we internationalized
    it in the previous recipe. That was an excellent start to refactoring our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's rename our `GUI.py` file as `GUI_Refactored.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Group the `import` statements as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can refactor our code further by breaking out the callback methods into their
    own module.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new module, `Callbacks_Refactored.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `GUI_Refactored.py`, import the `Callbacks` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Callbacks_Refactored.py`, add `self.callBacks = Callbacks(self)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `Callbacks` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's now see how this recipe works!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have first improved the readability of our code by grouping the related `import`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: By simply grouping related imports, we can reduce the number of lines of code,
    which improves the readability of our imports, making them appear less overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: We next broke out the callback methods into their own class and module, `Callbacks_Refactored.py`,
    in order to reduce the complexity of our code further.
  prefs: []
  type: TYPE_NORMAL
- en: In the initializer of our new class, the passed-in GUI instance is saved under
    the name `self.oop` and used throughout this new Python class module.
  prefs: []
  type: TYPE_NORMAL
- en: Running the refactored GUI code still works as before. We have only increased
    its readability and reduced the complexity of our code in preparation for further
    development work.
  prefs: []
  type: TYPE_NORMAL
- en: We had already taken the same OOP approach by having the `ToolTip` class reside
    in its own module, and by internationalizing all GUI strings in the previous recipes. In
    this recipe, we went one step further in refactoring by passing our own instance
    into the callback method's class that our GUI relies upon. This enables us to
    use all of our GUI widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we better understand the value of a modular approach to software development,
    we will most likely start with this approach in our future software designs.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring is the process of improving the structure, readability, and maintainability
    of the existing code. We are not adding new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to test the GUI code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing our software is an important activity during the coding phase as well
    as when releasing service packs or bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: There are different levels of testing. The first level is developer testing,
    which often starts with the compiler or interpreter not letting us run buggy code,
    forcing us to test small parts of our code on the level of individual methods.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first level of defense.
  prefs: []
  type: TYPE_NORMAL
- en: A second level of coding defensively is when our source code control system
    tells us about some conflicts to be resolved and does not let us check our modified
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This is very useful and absolutely necessary when we work professionally in
    a team of developers. The source code control system is our friend and points
    out changes that have been committed to a particular branch or top-of-tree, either
    by ourselves or by our other developers, and tells us that our local version of
    the code is both outdated and has some conflicts that need to be resolved before
    we can submit our code to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: This part assumes you use a source control system to manage and store your code.
    Examples include Git, Mercurial, SVN, and several others. Git is a very popular
    source control.
  prefs: []
  type: TYPE_NORMAL
- en: A third level is the level of APIs where we encapsulate potential future changes
    to our code by only allowing interactions with our code via published interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Another level of testing is integration testing, when half of the bridge we
    built meets the other half that the other development teams created, and the two
    don't meet at the same height (say, one half ended up two meters or yards higher
    than the other half…).
  prefs: []
  type: TYPE_NORMAL
- en: Then, there is end user testing. While we built what they specified, it is not
    really what they wanted.
  prefs: []
  type: TYPE_NORMAL
- en: All of the preceding examples are valid reasons why we need to test our code
    both in the design and implementation stages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will test the GUI we created in recent recipes and chapters. We will also
    show some simple examples of what can go wrong and why we need to keep testing
    our code and the code we call via APIs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's examine this recipe in detail.
  prefs: []
  type: TYPE_NORMAL
- en: In Python GUI programming, one of the first things that can go wrong is missing
    out on importing required modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI.py` and comment out the `import` statement, `# import tkinter as tk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ef061b3b-a6e6-49ee-9486-aff6b7eeaf07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the `import` statement to the top to solve this error as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using an example from [Chapter 7](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml),
    *Storing Data in Our MySQL Database via Our GUI*, let's say we click on the Get
    Quotes button and this works, but we never clicked on the Mody Quote button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `GUI_MySQL.py` from [Chapter 7](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml), *Storing
    Data in Our MySQL Database via Our GUI*, and click the Get Quotes button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/36c264a3-7561-4544-b478-260530dc6ade.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, click the Mody Quote button, which creates the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a0ebc989-3aac-4a8b-a7f4-9a4196474431.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another potential area of bugs is when a function or method suddenly no longer
    returns the expected result. Let''s say we are calling the following function,
    which returns the expected result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c8cfb57-70b5-4350-805c-8a100d9024ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, someone makes a mistake, and we no longer get the previous results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change `(num * num)` to `(num ** num)` and run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24a26109-43d2-4c0c-8a3f-0f93d7f55f83.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, in *Steps 1* and *2*, we are trying to create an instance of the `tkinter`
    class, but things don't work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we simply forgot to import the module and alias it as `tk`, and we can
    fix this by adding a line of Python code above our class creation, where the `import`
    statements live.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example in which our development environment does the testing for
    us. We just have to do the debugging and code fixing.
  prefs: []
  type: TYPE_NORMAL
- en: Another example more closely related to developer testing is when we code conditionals
    and, during our regular development, do not exercise all branches of logic.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, in *Steps 4* and *5*, we use an example from [Chapter 7](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml),
    *Storing Data in Our MySQL Database via Our GUI*. We click on the Get Quotes button
    and this works, but we never clicked on the Mody Quote button. The first button
    click creates the desired result, but the second throws an exception (because
    we had not yet implemented this code and probably forgot all about it).
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, in *Steps 6* and *7*, instead of multiplying, we are exponentially
    raising by the power of the passed-in number, and the result is no longer what
    it used to be.
  prefs: []
  type: TYPE_NORMAL
- en: In software testing, this sort of bug is called **regression**.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever something goes wrong in our code, we have to debug it. The first step
    of doing this is to set breakpoints and then step through our code, line by line,
    or method by method.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping in and out of our code is a daily activity until the code runs smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we emphasized the importance of software testing during several
    phases of the software development life cycle by showing several examples of where
    the code can go wrong and introduce software defects (also known as bugs).
  prefs: []
  type: TYPE_NORMAL
- en: Setting debug watches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern IDEs, such as the PyDev plugin in Eclipse, or other IDEs such as NetBeans,
    we can set debug watches to monitor the state of our GUI during the execution
    of our code.
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to the Microsoft IDEs of Visual Studio and the more recent
    versions of Visual Studio .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Setting debug watches is a very convenient way to help our development efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will reuse the Python GUI we developed in the earlier recipes.
    We will step through the code we had developed previously, and we will set debug
    watches.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this recipe applies to the PyDev plugin in the Java-based Eclipse IDE,
    its principles also apply to many modern IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how we can sequentially proceed with this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `GUI.py` and place a breakpoint at the line with `mainloop`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e5fe093c-7710-4210-afcb-ca5ff2c47bdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Start a debug session as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/79046081-8c6a-4c1f-a889-8993f5473f7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's place a breakpoint at the New York button callback method, which we named
    `getDateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Open `Callbacks_Refactored.py` and place a breakpoint at the `getDateTime` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Step through the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd64e5c5-4043-4804-b9c0-f7ca8163503a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first position where we might wish to place a breakpoint is at the place
    where we make our GUI visible by calling the `tkinter` main event loop. We do
    this in *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: The green balloon symbol on the left is a breakpoint in PyDev/Eclipse. When
    we execute our code in debug mode, the execution of the code will be halted once
    the execution reaches the breakpoint. At this point, we can see the values of
    all the variables that are currently in scope. We can also type expressions into
    one of the debugger windows, which will execute them, showing us the results.
    If the result is what we want, we might decide to change our code using what we
    have just learned.
  prefs: []
  type: TYPE_NORMAL
- en: We normally step through the code by either clicking an icon in the toolbar
    of our IDE, or by using a keyboard shortcut (such as pressing *F5* to step into
    code, *F6* to step over, and *F7* to step out of the current method).
  prefs: []
  type: TYPE_NORMAL
- en: Placing the breakpoint where we did and then stepping into this code turns out
    to be a problem because we end up in some low-level `tkinter` code we really do
    not wish to debug right now. We get out of this low-level `tkinter` code by clicking
    the Step-Out toolbar icon (which is the third yellow arrow on the right beneath
    the project menu) or by pressing *F7* (assuming we are using PyDev in Eclipse).
  prefs: []
  type: TYPE_NORMAL
- en: A better idea is to place our breakpoint closer to our own code in order to
    watch the values of some of our own Python variables. In the event-driven world
    of modern GUIs, we have to place our breakpoints at code that gets invoked during
    events, for example, button clicks. We do this in *Steps 3* and *4*.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, one of our main functionalities resides in a button click event.
    When we click the button labelled New York, we create an event, which then results
    in something happening in our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in learning how to install Eclipse with the PyDev plugin
    for Python, there is a great tutorial that will get you started with installing
    all the necessary free software and then introduce you to PyDev within Eclipse
    by creating a simple, working Python program: [http://www.vogella.com/tutorials/Python/article.html](http://www.vogella.com/tutorials/Python/article.html).
  prefs: []
  type: TYPE_NORMAL
- en: We use modern IDEs in the 21^(st) century that are freely available to help
    us to create solid code.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe showed how to set debug watches, which is a fundamental tool in
    every developer's skill set. Stepping through our own code even when not hunting
    down bugs ensures that we understand our code, and it can lead to improving our
    code via refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Debug watches help us to create solid code and this is not a waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring different debug output levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will configure different debug levels, which we can select
    and change at runtime. This allows us to control how much we want to drill down
    into our code when debugging our code.
  prefs: []
  type: TYPE_NORMAL
- en: We will create two new Python classes and place both of them in the same module.
  prefs: []
  type: TYPE_NORMAL
- en: We will use four different logging levels and write our debugging output to
    a log file that we will create. If the logs folder does not exist, we will create
    it automatically as well.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the log file is the name of the executing script, which is our refactored
    `GUI_Refactored.py`. We can also choose other names for our log files by passing
    in the full path to the initializer of our `Logger` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue using our refactored `GUI_Refactored.py` code from the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we shall proceed with this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new Python module into which we place two new classes. The
    first class is very simple and defines the logging levels. This is basically an
    enumeration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new module and name it` Logger.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the second class to the same module, `Logger.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `writeToLog` method shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `GUI_Refactored.py` and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/61cfa7f8-2617-40b1-bce0-fb02af08d67a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows that we created an instance of our new `Logger`
    class, and the following screenshot shows that both the `logs` folder as well
    as the log were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5ac420f-fde0-4cbb-8c34-94abb206c96b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, open the log file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c2656814-1745-4a41-9555-433d45025c8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first created a new module and used a simple class as an enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: The second class creates a log file by using the passed-in full path of the
    filename and places this into a logs folder. On the first run, the logs folder
    might not exist, so the code automatically creates the folder.
  prefs: []
  type: TYPE_NORMAL
- en: In order to write to our log file, we use the `writeToLog` method. Inside the
    method, the first thing we do is check whether the message has a logging level
    higher than the limit we set our desired logging output to. If the message has
    a lower level, we discard it and immediately return from the method.
  prefs: []
  type: TYPE_NORMAL
- en: If the message has the logging level that we want to display, we then check
    whether it starts with a newline character, and, if it does, we discard the newline
    by slicing the method starting at index 1, using Python's slice operator (`msg
    = msg[1:]`).
  prefs: []
  type: TYPE_NORMAL
- en: We then write one line to our log file, consisting of the current date timestamp,
    two tab spaces, our message, and ending in a newline character.
  prefs: []
  type: TYPE_NORMAL
- en: We can now import our new Python module and, inside the `__init__` section of
    our GUI code, we create an instance of the `Logger` class.
  prefs: []
  type: TYPE_NORMAL
- en: We are retrieving the full path to our running GUI script via `path.realpath(__file__)`
    and passing this into the initializer of the `Logger` class. If the logs folder
    does not exist, it will automatically be created by our Python code.
  prefs: []
  type: TYPE_NORMAL
- en: We then verify that the log and folder got created.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created our own logging class. While Python ships with a
    logging module, it is very easy to create our own, which gives us absolute control
    over our logging format. This is very useful when we combine our own logging output
    with MS Excel or `Matplotlib`, which we explored in the recipes of a previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will use Python's built-in `__main__` functionality to
    use the four different logging levels we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating self-testing code using Python's __main__ section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python comes with a very nice feature that enables each module to self-test.
    Making use of this feature is a great way of making sure that the changes to our
    code do not break the existing code and, additionally, the `__main__` self-testing
    section can serve as documentation for how each module works.
  prefs: []
  type: TYPE_NORMAL
- en: After a few months or years, we sometimes forget what our code is doing, so
    having an explanation written in the code itself is indeed of great benefit.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to always add a self-testing section to every Python module,
    when possible. It is sometimes not possible but, in most modules, it is possible
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will extend the previous recipe, so in order to understand what the code
    in this recipe is doing, we have to first read and understand the code of the
    previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the steps of this recipe in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will explore the power of the Python `__main__` self-testing section
    by adding this self-testing section to our `LanguageResources.py` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add the following code to `LanguageResources.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b8d5a812-edab-4520-be62-1dd363cf1d02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a `__main__` self-testing section to the `GUI_Refactored.py` module and
    run the code to see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/59dc1e7c-82f4-4aa0-af2a-3e510c192972.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, in the `GUI_Refactored.py` module, add `oop.log.writeToLog(''Test message'')`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This gets written to our log file, as can be seen in the following screenshot
    of the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b02b6fe6-f6f4-4d1f-90b7-a3243d3bdf2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In `GUI_Refactored.py`, import both new classes from our `Logger` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create local instances of those classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use different logging levels via `self.oop.level`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and open the log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df842b27-68f8-4b4b-9f93-77ac20c8fdf4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the `setLoggingLevel` method of the `Logger` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `__main__` section of our GUI, change the logging level to `MINIMUM`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the log file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/28cc8eb5-64e3-4ec3-a767-9f87b112011f.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by adding a `__main__` self-testing section to `LanguageResources.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we run a module that has this self-testing section located at the bottom
    of the module, when the module is executed by itself, this code will run.
  prefs: []
  type: TYPE_NORMAL
- en: When the module is imported and used from other modules, the code in the `__main__`
    self-testing section will not be executed.
  prefs: []
  type: TYPE_NORMAL
- en: We first pass English as the language to be displayed in our GUI, and then we
    pass German as the language our GUI will display.
  prefs: []
  type: TYPE_NORMAL
- en: We print out the title of our GUI to show that our Python module works as we
    intended it to work.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to use our logging capabilities, which we created in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We add a `__main__` self-testing section to `GUI_Refactored.py` and then verify
    that we created an instance of our `Logger` class.
  prefs: []
  type: TYPE_NORMAL
- en: We next write to our log file by using the command shown. We have designed our
    logging level to default to log every message, which is the `DEBUG` level, and,
    because of this, we do not have to change anything. We just pass the message to
    be logged to the `writeToLog` method.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can control the logging by adding logging levels to our logging statements
    and setting the level we wish to output. We add this capability to our New York
    button callback method in the `Callbacks_Refactored.py` module, which is the `getDateTime`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We change the previous print statements to log statements using different debug
    levels.
  prefs: []
  type: TYPE_NORMAL
- en: As we are passing an instance of the GUI class to the `Callbacks_Refactored.py` initializer,
    we can use logging level constraints according to the `LogLevel` class we created.
  prefs: []
  type: TYPE_NORMAL
- en: When we now click our New York button, depending upon the logging level selected,
    we get different output written to our log file. The default logging level is
    `DEBUG`, which means that everything gets written to our log.
  prefs: []
  type: TYPE_NORMAL
- en: When we change the logging level, we control what gets written to our log. We
    do this by calling the `setLoggingLevel` method of the `Logger` class.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the level to `MINIMUM` results in a reduced output written to our log
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our log file no longer shows the test message and only shows messages that
    meet the set logging level.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we made good use of Python's built-in `__main__` self-testing
    section. We introduced our own logging file and, at the same time, learned how
    to create different logging levels. By doing this, we have full control over what
    gets written to our log files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating robust GUIs using unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python comes with a built-in unit testing framework and, in this recipe, we
    will start using this framework to test our Python GUI code.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing unit tests, we want to design our testing strategy.
    We could easily intermix the unit tests with the code they are testing, but a
    better strategy is to separate the application code from the unit test code.
  prefs: []
  type: TYPE_NORMAL
- en: '`PyUnit` has been designed according to the principles of all the other xUnit
    testing frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will test the internationalized GUI we created earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use Python''s built-in unit testing framework, we import the Python
    `unittest` module. Let''s now look at the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new module and name it `UnitTestsMinimum.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `UnitTestsMinimum.py` and observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/12dcecf3-982d-4df6-b8a3-ef73b1d6e920.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new module, name it `UnitTests_One.py`, and then add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `UnitTests_One.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/036e99fc-3b80-4409-aedb-3744ac31d4ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Save the module as `UnitTestsFail.py` and then copy, paste, and modify the
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `UnitTestsFail.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5dcca416-976e-4aef-b0cc-fddb32e446a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Correct this failure by passing in `''de''` to `I18N`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun `UnitTestsFail.py` with the failure corrected and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac1ba1cd-76c3-48fe-9bdb-6826ef8df28f.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first import the `unittest` module, then we create our own class and, within
    this class, we inherit and extend the `unittest.TestCase` class. We use the minimum
    amount of code to get started. The code isn't doing much yet but, when we run
    it, we do not get any errors, which is a good sign.
  prefs: []
  type: TYPE_NORMAL
- en: We actually do get an output written to the console stating that we successfully
    ran zero tests.
  prefs: []
  type: TYPE_NORMAL
- en: That output is a bit misleading, as all we have done so far is create a class
    that contains no actual testing methods.
  prefs: []
  type: TYPE_NORMAL
- en: We add testing methods that do the actual unit testing by following the default
    naming for all the test methods to start with the word **test**. This is an option
    that can be changed, but it is much easier and clearer to follow this *naming
    convention*.
  prefs: []
  type: TYPE_NORMAL
- en: We then add one test method that tests the title of our GUI. This will verify
    that, by passing the expected arguments, we get the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: We are importing our `I18N` class from our `LanguageResources.py` module, passing
    English as the language to be displayed in our GUI. As this is our first unit
    test, we will print out the title result as well, just to make sure we know what
    we are getting back. We next use the `unittest assertEqual` method to verify that
    our title is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Running this code gives us an OK, which means that the unit test passed.
  prefs: []
  type: TYPE_NORMAL
- en: The unit test runs and succeeds, which is indicated by one dot and the word
    OK. If it had failed or got an error, we would not have gotten the dot but an
    *F* or *E* as the output.
  prefs: []
  type: TYPE_NORMAL
- en: We then do the same automated unit testing check by verifying the title for
    the German version of our GUI. We test our internationalized GUI title in two
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: We ran two unit tests but, instead of an OK, we got a failure. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: Our assertion failed for the German version of our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: While debugging our code, it turns out that in the copy, paste, and modify approach
    of our unit test code, we forgot to pass in German as the language.
  prefs: []
  type: TYPE_NORMAL
- en: After correcting the failure, we reran our unit tests, and we get the expected
    result of all our tests passing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing code is also code and can have bugs too.
  prefs: []
  type: TYPE_NORMAL
- en: While the purpose of writing unit tests is really to test our application code,
    we have to make sure that our tests are written correctly. One approach from the
    **Test-Driven-Development** (**TDD**) methodology might help us.
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, we develop the unit tests before we actually write the application code.
    Now, if a test passes for a method that does not even exist, something is wrong.
    The next step is to create the non-existing method and make sure it will fail.
    After that, we can write the minimum amount of code necessary to make the unit
    test pass.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we started testing our Python GUI, and writing unit tests in
    Python. We saw that Python unit test code is just code and can contain mistakes
    that need to be corrected. In the next recipe, we will extend this recipe's code
    and use the graphical unit test runner that comes with the PyDev plugin for the
    Eclipse IDE.
  prefs: []
  type: TYPE_NORMAL
- en: How to write unit tests using the Eclipse PyDev IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we started using Python's unit testing capabilities,
    and, in this recipe, we will ensure the quality of our GUI code by using this
    capability further.
  prefs: []
  type: TYPE_NORMAL
- en: We will unit test our GUI in order to make sure that the internationalized strings
    our GUI displays are as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we encountered some bugs in our unit testing code but,
    typically, our unit tests will find regression bugs that are caused by modifying
    the existing application code, not the unit test code. Once we have verified that
    our unit testing code is correct, we do not usually change it.
  prefs: []
  type: TYPE_NORMAL
- en: Our unit tests also serve as a documentation of what we expect our code to do.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Python's unit tests are executed with a textual unit test runner,
    and we can run this in the PyDev plugin from within the Eclipse IDE. We can also
    run the very same unit tests from a console window.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the text runner in this recipe, we will explore PyDev's graphical
    unit test feature, which can be used from within the Eclipse IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will extend the previous recipe in which we began using Python unit tests. The
    Python unit testing framework comes with what are called **Test Fixtures**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following URLs for a description of what a test fixture is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3.7/library/unittest.html](https://docs.python.org/3.7/library/unittest.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Test_fixture](https://en.wikipedia.org/wiki/Test_fixture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html](http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What this means is that we can create `setup` and `teardown` unit testing methods
    so that the `setup` method is called at the beginning before any single test is
    executed, and, at the end of every single unit test, the `teardown` method is
    called.
  prefs: []
  type: TYPE_NORMAL
- en: This test fixture capability provides us with a very controlled environment
    in which we can run our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s see how to perform this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, let's set up our unit testing environment. We will create a new testing
    class that focuses on the aforementioned correctness of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new module, `UnitTestsEnglish.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9ee00d5e-d548-4469-a558-1536c6bde418.png)'
  prefs: []
  type: TYPE_IMG
- en: Open `UnitTestsEnglish.py` and save it as `UnitTests.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `UnitTests.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33ef01af-7821-4644-a489-da190bdcec7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the code from Command Prompt and observe the output as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/77a67d45-6553-4c6e-8d4b-a750d11c87b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using Eclipse, we can also choose to run our unit tests, not as a simple Python
    script, but as a Python unit test script, which gives us some colorful output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f12a233f-a2ed-4ddf-a389-1ce393402a65.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's learn about the steps in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firstly, we created three test methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`unittest.main()` runs any method that starts with the `test` prefix, no matter
    how many classes we create within a given Python module.'
  prefs: []
  type: TYPE_NORMAL
- en: The unit testing code shows that we can create several unit testing classes
    and they can all be run in the same module by calling `unittest.main()`.
  prefs: []
  type: TYPE_NORMAL
- en: It also shows that the `setup` method does not count as a test in the output
    of the unit test report (the count of tests is three) while, at the same time,
    it did its intended job as we can now access our `self.gui` class instance variable
    from within the unit test method.
  prefs: []
  type: TYPE_NORMAL
- en: We are interested in testing the correctness of all of our labels and, especially,
    catching bugs when we make changes to our code.
  prefs: []
  type: TYPE_NORMAL
- en: If we have copied and pasted strings from our application code to the testing
    code, it will catch any unintended changes with the click of a unit testing framework
    button.
  prefs: []
  type: TYPE_NORMAL
- en: We also want to test the fact that invoking any of our radio button widgets
    in any language results in the `LabelFrame` widget text being updated. In order
    to automatically test this, we have to do two things.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to retrieve the value of the `LabelFrame` widget and assign
    the value to a variable we name `labelFrameText`. We have to use the following
    syntax because the properties of this widget are being passed and retrieved via
    a dictionary data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can now verify the default text and then the internationalized versions after
    clicking one of the radio button widgets programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'After verifying the default `labelFrameText`, we programmatically set the radio
    button to `index 1` and then invoke the radio button''s callback method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is basically the same action as clicking the radio button in the GUI, but
    we do this button click event via code in the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we verify that our text in the `LabelFrame` widget has changed as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get a `ModuleNotFoundError`, simply add the directory where your Python
    code lives to the Windows `PYTHONPATH` environmental variable, as shown in the
    following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An error gets encountered as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e4e459a-23ef-4ce0-a47e-b95e3e2677a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The solution to the error, if you encounter it, is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aeff779b-3908-4688-9279-9d54dba0ccf2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, `C:\Eclipse_Oxygen_workspace_Packt_3rd_GUI_BOOK\3rd Edition Python
    GUI Programming Cookbook`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bfd962a-63a0-423b-8278-38cc37f9cdd5.png)'
  prefs: []
  type: TYPE_IMG
- en: This will recognize the `Ch08_Code` folder as a Python package and the code
    will run.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the unit test from the graphical runner in Eclipse, the result bar
    is green, which means that all our unit tests have passed.
  prefs: []
  type: TYPE_NORMAL
- en: We extended our unit testing code by testing labels, programmatically invoking `Radiobutton`,
    and then verifying in our unit tests that the corresponding text property of the
    `LabelFrame` widget has changed as expected. We tested two different languages. We
    then moved on to use the built-in Eclipse/PyDev graphical unit test runner.
  prefs: []
  type: TYPE_NORMAL
