- en: Internationalization and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化和测试
- en: In this chapter, we will *internationalize* our GUI by displaying text on labels,
    buttons, tabs, and other widgets, in different languages. We will start simply
    and then explore how we can prepare our GUI for internationalization at the design
    level.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过在标签、按钮、标签页和其他小部件上显示不同语言的文本来国际化我们的GUI。我们将从简单开始，然后探讨我们如何在设计层面为国际化准备我们的GUI。
- en: We will also *localize* the GUI, which is slightly different from internationalization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将*本地化*GUI，这与国际化略有不同。
- en: As these words are long, they have been abbreviated to use the first character
    of the word, followed by the total number of characters in between the first and
    last character, followed by the last character of the word. So, **internationalization**
    becomes **I18N**, and **localization** becomes **L10N**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些单词很长，它们已经被缩写为使用单词的第一个字母，然后是第一个和最后一个字母之间的总字符数，最后是单词的最后一个字母。因此，**国际化**变为**I18N**，**本地化**变为**L10N**。
- en: We will also test our GUI code, write unit tests, and explore the value unit
    tests can provide in our development efforts, which will lead us to the best practice
    of refactoring our code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将测试我们的GUI代码，编写单元测试，并探索单元测试在我们开发努力中的价值，这将引导我们到重构代码的最佳实践。
- en: There are no additional Python packages to install. We write our own code in
    Python and the unit testing framework is shipped with Python, so we can simply
    import it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 没有额外的Python包需要安装。我们用Python编写自己的代码，单元测试框架是Python自带的，所以我们可以简单地导入它。
- en: Knowing how to both internationalize and test our code is an essential skill
    every programmer needs to know.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何国际化并测试我们的代码是每个程序员都需要掌握的基本技能。
- en: In this chapter, you will acquire the valuable skills of testing, refactoring,
    and internationalization.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将获得测试、重构和国际化等宝贵技能。
- en: 'Here is an overview of the Python modules for this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章Python模块的概述：
- en: '![](img/7f041c29-7d58-4cef-9e94-ac5800a8bd3a.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f041c29-7d58-4cef-9e94-ac5800a8bd3a.png)'
- en: 'We will internationalize and test our Python GUI, covering the following recipes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将国际化并测试我们的Python GUI，涵盖以下菜谱：
- en: Displaying widget text in different languages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同语言中显示小部件文本
- en: Changing the entire GUI language all at once
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性更改整个GUI语言
- en: Localizing the GUI
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化GUI
- en: Preparing the GUI for internationalization
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为国际化准备GUI
- en: How to design a GUI in an agile fashion
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以敏捷的方式设计GUI
- en: Do we need to test the GUI code?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否需要测试GUI代码？
- en: Setting debug watches
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置调试监视器
- en: Configuring different debug output levels
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置不同的调试输出级别
- en: Creating self-testing code using Python's `__main__` section
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python的`__main__`部分创建自测试代码
- en: Creating robust GUIs using unit tests
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单元测试创建健壮的GUI
- en: How to write unit tests using the Eclipse PyDev **Integrated Development Environment**
    (**IDE**)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Eclipse PyDev **集成开发环境**（**IDE**）编写单元测试
- en: Displaying widget text in different languages
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同语言中显示小部件文本
- en: The easiest way to internationalize text strings in Python is by moving them
    into a separate Python module and then selecting the language to be displayed
    in our GUI by passing in an argument to this module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中将文本字符串国际化最简单的方法是将它们移动到单独的Python模块中，然后通过传递一个参数给这个模块来选择GUI中要显示的语言。
- en: While this approach, according to online search results, is not highly recommended,
    depending on the specific requirements of the application you are developing,
    it may still be the most pragmatic and fastest to implement.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据在线搜索结果，这种方法并不特别推荐，但根据你正在开发的应用程序的具体要求，它可能仍然是实现起来最实用和最快的方法。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will reuse the Python GUI we created earlier in [Chapter 7](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml),
    *Storing Data in Our MySQL Database via Our GUI*. We will comment out one line
    of Python code that creates the MySQL tab because we do not interact with a MySQL
    database in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用我们在[第7章](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml)，“通过我们的GUI将数据存储到我们的MySQL数据库中”中创建的Python
    GUI。我们将注释掉一行创建MySQL标签的Python代码，因为我们在这个章节中不与MySQL数据库交互。
- en: How to do it…
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we will start the I18N of our GUI by changing the window's title
    from English to another language.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过更改窗口标题为其他语言来开始我们GUI的I18N。
- en: 'As the name *GUI* is the same in other languages, we will first expand the
    name that enables us to see the visual effects of our changes. Let''s now see
    the steps in detail:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *GUI* 在其他语言中名称相同，我们将首先扩展名称，以便我们可以看到我们更改的视觉效果。现在让我们详细查看步骤：
- en: Open `GUI_MySQL.py` from the previous chapter ([Chapter 7](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml), *Storing
    Data in Our MySQL Database via Our GUI*) and save it as `GUI.py`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开上一章（[第 7 章](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml)，*通过我们的 GUI 在我们的 MySQL
    数据库中存储数据*）中的 `GUI_MySQL.py` 并将其保存为 `GUI.py`。
- en: 'The following was our previous line of code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们之前的代码行：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s change this to the following code. Also, comment out the creation of
    the MySQL tab:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将此更改为以下代码。同时，注释掉创建 MySQL 标签的代码：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code change results in the following title for our GUI program:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码更改导致我们的 GUI 程序的以下标题：
- en: '![](img/b43f000a-c0ef-4dd7-8a05-94e08d5038b1.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b43f000a-c0ef-4dd7-8a05-94e08d5038b1.png)'
- en: Please note that, in this chapter, we will use English and German to exemplify
    the principle of internationalizing our Python GUI.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本章中，我们将使用英语和德语来举例说明国际化我们的 Python GUI 的原则。
- en: Let's create a new Python module and name it `LanguageResources.py`. Let's next
    move the English string of our GUI title into this module and also create a German
    version.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 Python 模块，并将其命名为 `LanguageResources.py`。接下来，我们将我们的 GUI 标题的英文字符串移动到这个模块中，并创建一个德语版本。
- en: 'Add the following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Import the `I18N` class and change the language to `''de''`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `I18N` 类并将语言更改为 `'de'`：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running the preceding code, we now get the following internationalized result:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码，我们现在得到以下国际化结果：
- en: '![](img/1791aa33-d031-499b-9a45-1dbfa640a7ff.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1791aa33-d031-499b-9a45-1dbfa640a7ff.png)'
- en: Let's now go behind the scenes to understand the code better.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解。
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Starting from s*tep 4*, we break out the hardcoded strings that are part of
    our GUI into their own separate module, `LanguageResources.py`. Within the class's
    `__init__()` method, we select which language our GUI will display, depending
    on the passed-in language argument. We then import the `LanguageResources.py` module
    into our OOP class module.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 4 步开始，我们将 GUI 中作为其一部分的硬编码字符串分离到它们自己的单独模块 `LanguageResources.py` 中。在类的 `__init__()`
    方法中，我们根据传入的语言参数选择 GUI 将显示哪种语言。然后我们将 `LanguageResources.py` 模块导入到我们的面向对象类模块中。
- en: We set the default language to `'en'`, which means English.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将默认语言设置为 `'en'`，这意味着英语。
- en: Within `GUI.py`, we are creating an instance of the `I18N` class. This class
    resides in `LanguageResources.py`, so the name of our class is shorter and different
    to the name of the Python module. We save the selected language in a class instance
    attribute, `self.i18n`, and use it to display the title. We are separating the
    GUI from the languages it displays, which is an OOP design principle.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GUI.py` 中，我们正在创建 `I18N` 类的一个实例。这个类位于 `LanguageResources.py` 中，因此我们类的名称更短，与
    Python 模块的名称不同。我们将选定的语言保存在类的实例属性 `self.i18n` 中，并使用它来显示标题。我们正在将 GUI 与其显示的语言分离，这是一个面向对象的设计原则。
- en: We can further modularize our code by separating the internationalized strings
    into separate files, potentially in XML or another format. We could also read
    them from a MySQL database.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将国际化字符串分离到单独的文件中进一步模块化我们的代码，这些文件可能是 XML 或其他格式。我们也可以从 MySQL 数据库中读取它们。
- en: This is a **separation of concerns** (**SoC**) coding approach, which is at
    the heart of OOP programming.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 **关注点分离**（**SoC**）的编码方法，这是面向对象编程的核心。
- en: Changing the entire GUI language all at once
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次性更改整个 GUI 语言
- en: In this recipe, we will change all of the GUI display names, all at once, by
    refactoring all the previously hardcoded English strings into a separate Python
    module and then internationalizing those strings.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过重构所有之前硬编码的英文字符串到一个单独的 Python 模块中，然后国际化这些字符串，一次性更改所有 GUI 显示名称。
- en: This recipe shows that it is a good design principle to avoid hardcoding any
    strings, that our GUI displays, but to separate the GUI code from the text that
    is displayed by the GUI.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例表明，避免硬编码任何字符串，这些字符串是我们 GUI 显示的，将 GUI 代码与 GUI 显示的文本分离，是一个好的设计原则。
- en: Designing our GUI in a modular way makes internationalizing it much easier.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以模块化方式设计我们的 GUI 使得国际化它变得容易得多。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue to use the GUI from the previous recipe, `GUI.py`. In that
    recipe, we had already internationalized the title of the GUI. We will enhance
    the `LanguageResources.py` module from the previous recipe as well by adding more internationalized strings.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前菜谱中的GUI，即`GUI.py`。在那个菜谱中，我们已经国际化了GUI的标题。我们还将增强之前菜谱中的`LanguageResources.py`模块，通过添加更多的国际化字符串。
- en: How to do it…
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to internationalize the text displayed in all of our GUI widgets,
    we have to move all hardcoded strings into a separate Python module, and this
    is what we''ll do next:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了国际化所有GUI小部件中显示的文本，我们必须将所有硬编码的字符串移动到一个单独的Python模块中，这就是我们接下来要做的：
- en: Open the `LanguageResources.py` module.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`LanguageResources.py`模块。
- en: 'Add the following code for the English internationalized strings:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为英文国际化字符串添加以下代码：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the Python `GUI.py` module, replace all the hardcoded strings with an instance of
    our new `I18N` class, for example, `self.i18n.colorsIn`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python的`GUI.py`模块中，将所有硬编码的字符串替换为我们的新`I18N`类的一个实例，例如，`self.i18n.colorsIn`：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can now implement the translation to German by simply filling in the variable
    names with the corresponding words.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过简单地填写相应的单词来变量名来实现对德语的翻译。
- en: 'Add the following code to `LanguageResources.py`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`LanguageResources.py`：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our GUI code, we can now change the entire GUI display language in one line
    of Python code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的GUI代码中，我们现在可以用一行Python代码更改整个GUI显示的语言：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the preceding code creates the following internationalized GUI:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码创建以下国际化的GUI：
- en: '![](img/878bc719-1be8-48da-86c6-8d1f4444aad9.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/878bc719-1be8-48da-86c6-8d1f4444aad9.png)'
- en: Let's now see how this recipe works!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看这个菜谱是如何工作的！
- en: How it works…
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to internationalize our GUI, we refactored hardcoded strings into a
    separate module and then used the same class instance attributes to internationalize
    our GUI by passing in a string to the initializer of our `I18N` class, effectively
    controlling the language our GUI displays.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了国际化我们的图形用户界面（GUI），我们将硬编码的字符串重构到一个单独的模块中，然后通过将字符串传递给我们的`I18N`类的初始化器，使用相同的类实例属性来国际化我们的GUI，从而有效地控制GUI显示的语言。
- en: Note how all of the previously hardcoded English strings have been replaced
    by calls to the instance of our new `I18N` class. One example is `self.win.title(self.i18n.title)`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前所有硬编码的英文字符串都已被替换为对新的`I18N`类实例的调用。一个例子是`self.win.title(self.i18n.title)`。
- en: What this gives us is the ability to internationalize our GUI. We simply have
    to use the same variable names and combine them by passing in a parameter to select
    the language we wish to display.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了国际化GUI的能力。我们只需使用相同的变量名，并通过传递参数来组合它们，以选择我们希望显示的语言。
- en: We could change languages on the fly as part of the GUI as well, or we could
    read the local PC settings and decide which language our GUI text should display
    according to those settings. An example of how to read the local settings is covered
    in the next recipe, *Localizing the GUI*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在GUI中动态更改语言，或者我们可以读取本地PC设置，并根据这些设置决定我们的GUI文本应该显示哪种语言。如何读取本地设置的示例将在下一个菜谱中介绍，*本地化GUI*。
- en: Previously, every single string of every widget, including the title of our
    GUI, the tab control names, and so on, were all hardcoded and intermixed with
    the code that creates the GUI.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，每个小部件的每一行字符串，包括我们GUI的标题、标签控件名称等，都是硬编码的，并且与创建GUI的代码混合在一起。
- en: It is a good idea to think about how we can best internationalize our GUI at
    the design phase of our GUI software development process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GUI软件开发过程的设计阶段考虑如何最好地国际化我们的GUI是一个好主意。
- en: In this recipe, we internationalized all strings displayed in our GUI widgets.
    We are not internationalizing the text entered into our GUI, because this depends
    on the local settings on your PC.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们国际化了GUI小部件中显示的所有字符串。我们不会国际化输入到GUI中的文本，因为这取决于您PC上的本地设置。
- en: Localizing the GUI
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化GUI
- en: After the first step of internationalizing our GUI, the next step is to *localize*
    it. Why would we wish to do this?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GUI国际化第一步之后，下一步是*本地化*它。我们为什么要这样做呢？
- en: Well, here in the United States of America, we are all cowboys and we live in
    different time zones.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在这里的美国，我们都是牛仔，我们生活在不同的时区。
- en: While we are internationalized to the US, our horses do wake up in different
    time zones (and do expect to be fed according to their own inner horse time zone
    schedule).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们国际化到美国时，我们的马匹在不同的时区醒来（并且确实期望根据自己的内在马时区时间表被喂食）。
- en: This is where *localization* comes in.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*本地化*的作用。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are extending the GUI we developed in the previous recipe by localizing it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过本地化扩展了我们之前开发的GUI。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how to perform this recipe:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何执行这个食谱：
- en: We start by first installing the Python `pytz` time zone module, using `pip`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用`pip`安装Python的`pytz`时区模块。
- en: 'Next, open Command Prompt and type the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开命令提示符并输入以下命令：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the installation is successful, we get the following result:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装成功后，我们得到以下结果：
- en: '![](img/faed9de8-a4c7-4a82-8742-d82e0d1639ee.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/faed9de8-a4c7-4a82-8742-d82e0d1639ee.png)'
- en: 'Next, we add a new `Button` widget to `GUI.py`. We can list all the existing
    time zones by running the following code, which will display the time zones in
    our `ScrolledText` widget by adding the `allTimeZones` method as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在`GUI.py`中添加一个新的`Button`小部件。我们可以通过运行以下代码列出所有现有时区，该代码将时区添加到我们的`ScrolledText`小部件中，如下所示：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Clicking our new `Button` widget results in the following output:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们新的`Button`小部件，结果如下输出：
- en: '![](img/5795c9c0-45fa-49c0-97dc-d050e45f18a3.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5795c9c0-45fa-49c0-97dc-d050e45f18a3.png)'
- en: 'Install the `tzlocal` Python module using `pip`, and then we can display our
    current locale by adding the `localZone` method and connecting it to a new `Button`
    command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pip`安装`tzlocal` Python模块，然后我们可以通过添加`localZone`方法并将其连接到新的`Button`命令来显示我们的当前区域设置：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We internationalize the strings of our two new buttons in `LanguageResources.py`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`LanguageResources.py`中国际化了我们两个新按钮的字符串。
- en: 'The English version is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 英文版本如下：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The German version is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 德语版本如下：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Clicking our new button now tells us which time zone we are in (hey, we didn''t
    know that, did we…):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 点击我们新的按钮现在告诉我们我们所在的时区（嘿，我们不知道这个，对吧…）：
- en: '![](img/2547fc31-bbac-4de3-986c-7947309aca10.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2547fc31-bbac-4de3-986c-7947309aca10.png)'
- en: 'We can now change our local time to US EST by first converting it to **Coordinated
    Universal Time** (**UTC**) and then applying the time zone function from the imported
    `pytz` module. Next, add the following code to `GUI.py`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过首先将其转换为**协调世界时**（**UTC**）然后应用导入的`pytz`模块中的时区函数来将本地时间更改为美国东部标准时间（US EST）。接下来，将以下代码添加到`GUI.py`中：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Clicking the button, now renamed as New York, results in the following output
    in label 2 in the top-left corner of the GUI:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击现在重命名为纽约的按钮，结果在GUI左上角的标签2中如下输出：
- en: '![](img/7a32db2f-5e9e-4857-88f4-6c09206c8dc0.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a32db2f-5e9e-4857-88f4-6c09206c8dc0.png)'
- en: 'Notice the following output in the console:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意控制台中的以下输出：
- en: '![](img/6db51bd4-1ec8-4e0f-aec2-6dd2f658d0c8.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6db51bd4-1ec8-4e0f-aec2-6dd2f658d0c8.png)'
- en: Let's learn about this recipe in the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节学习这个食谱。
- en: How it works…
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, we installed the Python `pytz` module using `pip`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`pip`安装了Python的`pytz`模块。
- en: In this book, we are using Python 3.7, which comes with the `pip` module built
    in. If you are using an older version of Python, then you may have to install
    the `pip` module first.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用的是内置`pip`模块的Python 3.7。如果您使用的是较旧版本的Python，那么您可能首先需要安装`pip`模块。
- en: The screenshot in s*tep 2* shows that the `pip` command downloaded the `.whl` format.
    If you have not done so, you might have to install the Python wheel module as
    well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步的截图显示`pip`命令下载了`.whl`格式。如果您尚未这样做，您可能还需要安装Python的wheel模块。
- en: This installed the Python `pytz` module into the `site-packages` folder, so
    now we can import this module from our Python GUI code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将Python的`pytz`模块安装到`site-packages`文件夹中，因此现在我们可以从我们的Python GUI代码中导入此模块。
- en: In order to localize date and time information, we first need to convert our
    local time to UTC time. We then apply the time zone information and use the `astimezone`
    function from the `pytz` Python time zone module to convert to any time zone across
    the globe!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本地化日期和时间信息，我们首先需要将本地时间转换为UTC时间。然后应用时区信息，并使用从导入的`pytz` Python时区模块中的`astimezone`函数将时间转换为全球任何时区！
- en: We installed the Python `tzlocal` module using `pip`, and now we can translate
    our local time to a different time zone. We used US EST as an example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`pip`安装了Python的`tzlocal`模块，现在我们可以将本地时间转换为不同的时区。我们以美国东部标准时间（US EST）为例。
- en: In s*tep 8*, we converted the local time of the US west coast to UTC and then
    displayed the US east coast time in label 2 (`self.lbl2`) of our GUI.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们将美国西海岸的本地时间转换为UTC，然后在GUI的标签2（`self.lbl2`）中显示美国东部时间。
- en: At the same time, we are printing the UTC times of the cities Los Angeles and
    New York with their respective time zone conversions, relative to the UTC time
    to the console, using a US date formatting string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们正在将洛杉矶和纽约的UTC时间及其相应的时间区域转换相对于UTC时间打印到控制台，使用的是美国日期格式字符串。
- en: UTC never observes **Daylight Saving Time** (**DST**). During **Eastern Daylight
    Time** (**EDT**), UTC is four hours ahead and, during standard time (EST), it
    is five hours ahead of the local time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: UTC从不观察**夏令时**（**DST**）。在**东部夏令时**（**EDT**）期间，UTC比本地时间快四小时，而在标准时间（**EST**）期间，UTC比本地时间快五小时。
- en: Preparing the GUI for internationalization
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备GUI进行国际化
- en: In this recipe, we will prepare our GUI for internationalization by realizing
    that not all is as easy as could be expected when translating English into foreign
    languages.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过实现以下事实来为我们的GUI进行国际化准备：当将英语翻译成外语时，并非所有事情都像预期的那样简单。
- en: We still have one problem to solve, which is how to properly display non-English
    Unicode characters from foreign languages.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有一个问题要解决，那就是如何正确显示来自外语的非英语Unicode字符。
- en: You might expect that displaying the German ä, ö, and ü Unicode umlaut characters
    would be handled by Python 3.7 automatically, but this is not the case.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会期望显示德语的ä、ö和ü Unicode重音字符会由Python 3.7自动处理，但这并不是事实。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will continue to use the Python GUI we developed in recent chapters. First,
    we will change the default language to German in the `GUI.py` initialization code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们在最近章节中开发的Python GUI。首先，我们将更改 `GUI.py` 初始化代码中的默认语言为德语。
- en: This recipe might be specific to the Eclipse PyDev IDE, but it is good to see
    this as an example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方可能特定于Eclipse PyDev IDE，但将其视为一个例子是很好的。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Before diving deep into the recipe, we should know that when we change the word
    "Ueber" to the correct German word "Űber" using the umlaut character, the Eclipse
    PyDev plugin is not too happy.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入配方之前，我们应该知道，当我们使用重音符号将单词 "Ueber" 更改为正确的德语单词 "Űber" 时，Eclipse PyDev插件并不太高兴。
- en: 'Let''s now see the steps of this recipe sequentially:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在按顺序查看这个配方的步骤：
- en: Open `GUI.py`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI.py`。
- en: Uncomment the line `self.i18n = I18N('de')` in order to use German.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消注释行 `self.i18n = I18N('de')` 以使用德语。
- en: 'Run `GUI.py`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '运行 `GUI.py`:'
- en: '![](img/7db6e6a2-67d4-481d-be0b-cd12f02cdda0.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7db6e6a2-67d4-481d-be0b-cd12f02cdda0.png)'
- en: 'We get an error message, which is a little bit confusing because, when we run
    the same line of code from within the Eclipse PyDev Console, we get the expected
    result:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到一个错误消息，这有点令人困惑，因为当我们从Eclipse PyDev控制台运行相同的代码行时，我们得到预期的结果：
- en: '![](img/0ce0803b-2443-428a-9e4a-71e4e96dacdc.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ce0803b-2443-428a-9e4a-71e4e96dacdc.png)'
- en: 'When we ask for the Python default encoding, we get the expected result, which
    is utf-8:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们请求Python默认编码时，我们得到预期的结果，即utf-8：
- en: '![](img/9b0b1388-5f90-4bb9-9d76-29ca5c88d6bf.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b0b1388-5f90-4bb9-9d76-29ca5c88d6bf.png)'
- en: 'Using Windows built-in character map, we can find the Unicode representation
    of the umlaut character, which is **U+00DC** for the capital **U** with an umlaut:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Windows内置字符映射表，我们可以找到重音字符的Unicode表示，对于大写 **U** 带有重音的是 **U+00DC**：
- en: '![](img/5dcb6c70-1228-4ae2-bac5-a78a1a9dfa3b.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dcb6c70-1228-4ae2-bac5-a78a1a9dfa3b.png)'
- en: 'While this workaround is truly ugly, it does the trick. Instead of typing in
    the literal character **Ü**, we can pass in the Unicode of **U+00DC** to get this
    character correctly displayed in our GUI:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然这个解决方案确实很丑陋，但它确实有效。我们不必输入字面字符 **Ü**，而是可以传递 **U+00DC** 的Unicode来正确地在我们的GUI中显示这个字符：
- en: '![](img/6ee94ee9-f13a-4c38-93c1-f9aba869c65a.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ee94ee9-f13a-4c38-93c1-f9aba869c65a.png)'
- en: We can also just accept the change in the default encoding from Cp1252 to UTF-8
    using PyDev with Eclipse, but we may not always get the prompt to do so.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以接受使用Eclipse PyDev将默认编码从Cp1252更改为UTF-8的改变，但我们可能不会总是得到提示去做。
- en: 'Instead, we might see the following error message displayed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可能会看到以下错误消息显示：
- en: '![](img/a4a6bd90-76d4-4a73-98c1-b77a931e44b1.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4a6bd90-76d4-4a73-98c1-b77a931e44b1.png)'
- en: 'The way to solve this problem is to change the PyDev project''s Text file encoding
    setting to UTF-8:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是更改PyDev项目的文本文件编码设置到UTF-8：
- en: '![](img/c39c62ca-7cdc-42df-adc0-78147a745aab.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c39c62ca-7cdc-42df-adc0-78147a745aab.png)'
- en: 'After changing the PyDev default encoding, we now can display those German
    umlaut characters. We also updated the title to use the correct German ä character, `GUI_.py`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更改PyDev默认编码后，我们现在可以显示那些德语的重音字符。我们还更新了标题，使用正确的德语ä字符，`GUI_.py`：
- en: '![](img/15aac6be-ccc7-49ac-9ca3-77f0240eb7ca.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15aac6be-ccc7-49ac-9ca3-77f0240eb7ca.png)'
- en: Let's now go behind the scenes to understand the code better.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在幕后了解代码。
- en: How it works…
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Internationalization and working with foreign language Unicode characters is
    often not as straightforward as we would wish.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化和处理外文Unicode字符通常不像我们希望的那样简单直接。
- en: Sometimes, we have to find workarounds, and expressing Unicode characters via
    Python by using the direct representation by prepending `\u` can do the trick.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要找到解决方案，通过Python使用`\u`前缀直接表示Unicode字符可以解决这个问题。
- en: The Windows built-in character map shows us `"U+00DC"`, which we translate into
    Python as `"\u00DC"`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Windows内置字符映射表显示“`U+00DC`”，我们将其转换为Python中的`"\u00DC"`。
- en: We can always resort to the direct representation of Unicode.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以求助于Unicode的直接表示。
- en: At other times, we just have to find the settings of our development environment
    to adjust. We saw an example of how to do this using the Eclipse IDE.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他时候，我们只需要找到我们的开发环境的设置来调整。我们看到了如何使用Eclipse IDE来完成这个任务的例子。
- en: How to design a GUI in an agile fashion
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何以敏捷的方式设计GUI
- en: The modern agile software development approach to design and coding came out
    of the lessons learned by software professionals. This method applies to a GUI
    as much as to any other code. One of the main keys of agile software development
    is the continuously applied process of refactoring.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现代敏捷软件开发的设计和编码方法源于软件专业人士的经验教训。这种方法适用于GUI，也适用于任何其他代码。敏捷软件开发的一个主要关键是持续进行的重构过程。
- en: One practical example of how refactoring our code can help us in our software
    development work is by first implementing some simple functionality using functions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构如何帮助我们进行软件开发工作的一个实际例子是首先通过函数实现一些简单的功能。
- en: As our code grows in complexity, we might want to refactor our functions into
    methods of a class. This approach would enable us to remove global variables and
    also to be more flexible about where we place the methods inside the class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的代码复杂性增加，我们可能希望将我们的函数重构为类的成员方法。这种方法将使我们能够删除全局变量，并且可以在类内部更灵活地放置方法。
- en: While the functionality of our code has not changed, the structure has.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的代码的功能没有改变，但其结构已经改变了。
- en: In this process, we code, test, refactor, and then test again. We do this in
    short cycles and often start with the minimum code required to get some functionality
    to work.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们编写代码、测试、重构，然后再测试。我们在短周期内这样做，通常从实现某些功能所需的最小代码开始。
- en: Test-driven software development is one particular style of the agile development
    methodology.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动软件开发是敏捷开发方法中的一种特定风格。
- en: While our GUI is working nicely, our main `GUI.py` code has been ever-increasing
    in complexity, and it has started to get a little bit harder to maintain an overview
    of our code. This means that we need to refactor our code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的GUI运行得很好，但我们的主要`GUI.py`代码的复杂性一直在增加，开始变得有点难以对代码有一个全面的了解。这意味着我们需要重构我们的代码。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will refactor the GUI we created in previous chapters. We will use the English
    version of the GUI.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构在前几章中创建的GUI。我们将使用GUI的英文版本。
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We have already broken out all the names our GUI displays when we internationalized
    it in the previous recipe. That was an excellent start to refactoring our code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，当我们国际化GUI时，我们已经将GUI显示的所有名称都提取出来了。这是重构我们代码的一个很好的开始：
- en: Let's rename our `GUI.py` file as `GUI_Refactored.py`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`GUI.py`文件重命名为`GUI_Refactored.py`。
- en: 'Group the `import` statements as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式分组`import`语句：
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can refactor our code further by breaking out the callback methods into their
    own module.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将回调方法分离到它们自己的模块中来进一步重构我们的代码。
- en: Create a new module, `Callbacks_Refactored.py`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，`Callbacks_Refactored.py`。
- en: In `GUI_Refactored.py`, import the `Callbacks` class.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GUI_Refactored.py`中导入`Callbacks`类。
- en: 'In `Callbacks_Refactored.py`, add `self.callBacks = Callbacks(self)`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Callbacks_Refactored.py`中添加`self.callBacks = Callbacks(self)`：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code to the `Callbacks` class:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Callbacks`类中：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's now see how this recipe works!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看这个菜谱是如何工作的！
- en: How it works…
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作…
- en: We have first improved the readability of our code by grouping the related `import`
    statements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过分组相关的`import`语句来提高了代码的可读性。
- en: By simply grouping related imports, we can reduce the number of lines of code,
    which improves the readability of our imports, making them appear less overwhelming.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地分组相关的导入，我们可以减少代码行数，这提高了我们导入的可读性，使它们看起来不那么令人压倒。
- en: We next broke out the callback methods into their own class and module, `Callbacks_Refactored.py`,
    in order to reduce the complexity of our code further.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将回调方法分离到它们自己的类和模块中，即`Callbacks_Refactored.py`，以进一步降低代码的复杂性。
- en: In the initializer of our new class, the passed-in GUI instance is saved under
    the name `self.oop` and used throughout this new Python class module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新类初始化器中，传入的GUI实例被保存为`self.oop`名称，并在整个新的Python类模块中使用。
- en: Running the refactored GUI code still works as before. We have only increased
    its readability and reduced the complexity of our code in preparation for further
    development work.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 运行重构后的GUI代码仍然像以前一样工作。我们只是提高了其可读性，并降低了代码的复杂性，为后续的开发工作做准备。
- en: We had already taken the same OOP approach by having the `ToolTip` class reside
    in its own module, and by internationalizing all GUI strings in the previous recipes. In
    this recipe, we went one step further in refactoring by passing our own instance
    into the callback method's class that our GUI relies upon. This enables us to
    use all of our GUI widgets.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过将`ToolTip`类放在自己的模块中，并在之前的菜谱中国际化所有GUI字符串，采用了相同的面向对象（OOP）方法。在这个菜谱中，我们通过将我们的实例传递给我们的GUI所依赖的回调方法类，进一步进行了重构。这使得我们能够使用所有的GUI小部件。
- en: Now that we better understand the value of a modular approach to software development,
    we will most likely start with this approach in our future software designs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更好地理解了模块化软件开发方法的价值，我们很可能会在未来的软件设计中从这种方法开始。
- en: Refactoring is the process of improving the structure, readability, and maintainability
    of the existing code. We are not adding new functionality.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是改进现有代码结构、可读性和可维护性的过程。我们并没有添加新的功能。
- en: Do we need to test the GUI code?
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要测试GUI代码吗？
- en: Testing our software is an important activity during the coding phase as well
    as when releasing service packs or bug fixes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码阶段以及发布服务包或错误修复时，测试我们的软件是一项重要的活动。
- en: There are different levels of testing. The first level is developer testing,
    which often starts with the compiler or interpreter not letting us run buggy code,
    forcing us to test small parts of our code on the level of individual methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 存在不同的测试级别。第一级是开发者测试，通常从编译器或解释器不允许我们运行有错误的代码开始，迫使我们测试代码的各个方法级别的小部分。
- en: This is the first level of defense.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一层防御。
- en: A second level of coding defensively is when our source code control system
    tells us about some conflicts to be resolved and does not let us check our modified
    code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编码的第二层是当我们的源代码控制系统告诉我们有一些冲突需要解决，并且不允许我们检查修改后的代码。
- en: This is very useful and absolutely necessary when we work professionally in
    a team of developers. The source code control system is our friend and points
    out changes that have been committed to a particular branch or top-of-tree, either
    by ourselves or by our other developers, and tells us that our local version of
    the code is both outdated and has some conflicts that need to be resolved before
    we can submit our code to the repository.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一个由开发者组成的团队中专业工作时，这非常有用且绝对必要。源代码控制系统是我们的朋友，它会指出已经提交到特定分支或树顶部的更改，无论是我们自己还是我们的其他开发者，并告诉我们我们的本地代码版本已经过时，并且在我们将代码提交到仓库之前需要解决一些冲突。
- en: This part assumes you use a source control system to manage and store your code.
    Examples include Git, Mercurial, SVN, and several others. Git is a very popular
    source control.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分假设你使用源代码控制系统来管理和存储你的代码。例如，Git、Mercurial、SVN以及几个其他系统。Git是一个非常流行的源代码控制系统。
- en: A third level is the level of APIs where we encapsulate potential future changes
    to our code by only allowing interactions with our code via published interfaces.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个级别是API级别，我们通过只允许通过发布的接口与我们的代码进行交互，来封装我们代码的潜在未来更改。
- en: Another level of testing is integration testing, when half of the bridge we
    built meets the other half that the other development teams created, and the two
    don't meet at the same height (say, one half ended up two meters or yards higher
    than the other half…).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试级别是集成测试，当我们所建造的桥梁的一半遇到其他开发团队创建的另一半，并且两者不在同一高度（比如说，一半最终比另一半高出两米或码…）。
- en: Then, there is end user testing. While we built what they specified, it is not
    really what they wanted.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是最终用户测试。虽然我们构建了他们指定的内容，但这并不是他们真正想要的。
- en: All of the preceding examples are valid reasons why we need to test our code
    both in the design and implementation stages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述例子都是我们需要在设计阶段和实现阶段测试代码的有效理由。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will test the GUI we created in recent recipes and chapters. We will also
    show some simple examples of what can go wrong and why we need to keep testing
    our code and the code we call via APIs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试最近配方和章节中创建的 GUI。我们还将展示一些简单的例子，说明可能会出错的原因，以及为什么我们需要持续测试我们的代码和通过 API 调用的代码。
- en: How to do it…
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's examine this recipe in detail.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查这个配方。
- en: In Python GUI programming, one of the first things that can go wrong is missing
    out on importing required modules.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python GUI 编程中，可能出错的第一件事是遗漏导入所需的模块。
- en: 'Here is a simple example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: Open `GUI.py` and comment out the `import` statement, `# import tkinter as tk`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI.py` 并取消注释 `import` 语句，`# import tkinter as tk`。
- en: 'Run the code and observe the following output:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察以下输出：
- en: '![](img/ef061b3b-a6e6-49ee-9486-aff6b7eeaf07.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef061b3b-a6e6-49ee-9486-aff6b7eeaf07.png)'
- en: 'Add the `import` statement to the top to solve this error as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部添加 `import` 语句以解决此错误，如下所示：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using an example from [Chapter 7](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml),
    *Storing Data in Our MySQL Database via Our GUI*, let's say we click on the Get
    Quotes button and this works, but we never clicked on the Mody Quote button.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自 [第 7 章](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml)，*通过我们的 GUI 将数据存储在我们的
    MySQL 数据库中* 的示例，假设我们点击获取报价按钮，这成功了，但我们从未点击过修改报价按钮。
- en: 'Open `GUI_MySQL.py` from [Chapter 7](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml), *Storing
    Data in Our MySQL Database via Our GUI*, and click the Get Quotes button:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [第 7 章](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml)，*通过我们的 GUI 将数据存储在我们的 MySQL
    数据库中* 的 `GUI_MySQL.py` 打开，并点击获取报价按钮：
- en: '![](img/36c264a3-7561-4544-b478-260530dc6ade.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36c264a3-7561-4544-b478-260530dc6ade.png)'
- en: 'Next, click the Mody Quote button, which creates the following result:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击修改报价按钮，这将产生以下结果：
- en: '![](img/a0ebc989-3aac-4a8b-a7f4-9a4196474431.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a0ebc989-3aac-4a8b-a7f4-9a4196474431.png)'
- en: 'Another potential area of bugs is when a function or method suddenly no longer
    returns the expected result. Let''s say we are calling the following function,
    which returns the expected result:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个潜在的错误区域是当一个函数或方法突然不再返回预期的结果。假设我们正在调用以下函数，它返回预期的结果：
- en: '![](img/5c8cfb57-70b5-4350-805c-8a100d9024ef.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c8cfb57-70b5-4350-805c-8a100d9024ef.png)'
- en: Then, someone makes a mistake, and we no longer get the previous results.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，有人犯了一个错误，我们不再得到之前的结果。
- en: 'Change `(num * num)` to `(num ** num)` and run the code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `(num * num)` 改为 `(num ** num)` 并运行代码：
- en: '![](img/24a26109-43d2-4c0c-8a3f-0f93d7f55f83.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24a26109-43d2-4c0c-8a3f-0f93d7f55f83.png)'
- en: Let's now go behind the scenes to understand the code better.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入幕后，更好地理解代码。
- en: How it works…
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, in *Steps 1* and *2*, we are trying to create an instance of the `tkinter`
    class, but things don't work as expected.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 *步骤 1* 和 *步骤 2* 中，我们正在尝试创建 `tkinter` 类的实例，但事情并没有按预期进行。
- en: Well, we simply forgot to import the module and alias it as `tk`, and we can
    fix this by adding a line of Python code above our class creation, where the `import`
    statements live.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们只是忘记导入模块并将其别名为 `tk`，我们可以在类创建上方添加一行 Python 代码来修复这个问题，其中 `import` 语句位于那里。
- en: This is an example in which our development environment does the testing for
    us. We just have to do the debugging and code fixing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，我们的开发环境为我们进行测试。我们只需要进行调试和代码修复。
- en: Another example more closely related to developer testing is when we code conditionals
    and, during our regular development, do not exercise all branches of logic.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与开发者测试更相关的例子是，当我们编写条件语句时，在常规开发过程中，我们没有测试所有逻辑分支。
- en: To demonstrate this, in *Steps 4* and *5*, we use an example from [Chapter 7](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml),
    *Storing Data in Our MySQL Database via Our GUI*. We click on the Get Quotes button
    and this works, but we never clicked on the Mody Quote button. The first button
    click creates the desired result, but the second throws an exception (because
    we had not yet implemented this code and probably forgot all about it).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，在 *步骤 4* 和 *步骤 5* 中，我们使用来自 [第 7 章](3fc59cd5-cbab-4621-b4bb-73e359e0e8e3.xhtml)，*通过我们的
    GUI 将数据存储在我们的 MySQL 数据库中* 的示例。我们点击获取报价按钮，这成功了，但我们从未点击过修改报价按钮。第一个按钮点击创建了所需的结果，但第二个抛出了异常（因为我们还没有实现这段代码，可能完全忘记了它）。
- en: In the next example, in *Steps 6* and *7*, instead of multiplying, we are exponentially
    raising by the power of the passed-in number, and the result is no longer what
    it used to be.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，在*步骤 6*和*步骤 7*中，我们不是进行乘法运算，而是通过传入数字的幂进行指数级提升，结果不再是之前的样子。
- en: In software testing, this sort of bug is called **regression**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件测试中，这种类型的错误被称为**回归**。
- en: Whenever something goes wrong in our code, we have to debug it. The first step
    of doing this is to set breakpoints and then step through our code, line by line,
    or method by method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的代码中发生什么问题，我们都需要调试它。进行此操作的第一步是设置断点，然后逐行或逐方法地逐步通过我们的代码。
- en: Stepping in and out of our code is a daily activity until the code runs smoothly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步进入和退出我们的代码是我们日常活动的一部分，直到代码运行顺畅。
- en: In this recipe, we emphasized the importance of software testing during several
    phases of the software development life cycle by showing several examples of where
    the code can go wrong and introduce software defects (also known as bugs).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们通过展示代码可能出错并引入软件缺陷（也称为错误）的几个示例，强调了在软件开发生命周期的几个阶段进行软件测试的重要性。
- en: Setting debug watches
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置调试监视器
- en: In modern IDEs, such as the PyDev plugin in Eclipse, or other IDEs such as NetBeans,
    we can set debug watches to monitor the state of our GUI during the execution
    of our code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 IDE 中，例如 Eclipse 中的 PyDev 插件或其他 IDE，如 NetBeans，我们可以在代码执行期间设置调试监视器来监控我们的
    GUI 状态。
- en: This is very similar to the Microsoft IDEs of Visual Studio and the more recent
    versions of Visual Studio .NET.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这与微软的 Visual Studio 和更近版本的 Visual Studio .NET 的 IDE 非常相似。
- en: Setting debug watches is a very convenient way to help our development efforts.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 设置调试监视器是一种非常方便的方式来帮助我们开发工作。
- en: Getting ready
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will reuse the Python GUI we developed in the earlier recipes.
    We will step through the code we had developed previously, and we will set debug
    watches.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重用我们在早期菜谱中开发的 Python GUI。我们将逐步通过我们之前开发的代码，并设置调试监视器。
- en: How to do it…
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: While this recipe applies to the PyDev plugin in the Java-based Eclipse IDE,
    its principles also apply to many modern IDEs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个菜谱适用于基于 Java 的 Eclipse IDE 中的 PyDev 插件，但其原则也适用于许多现代 IDE。
- en: 'Let''s now see how we can sequentially proceed with this recipe:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看我们如何可以按顺序进行这个菜谱：
- en: 'Open `GUI.py` and place a breakpoint at the line with `mainloop`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI.py` 并在带有 `mainloop` 的行上放置一个断点：
- en: '![](img/e5fe093c-7710-4210-afcb-ca5ff2c47bdf.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5fe093c-7710-4210-afcb-ca5ff2c47bdf.png)'
- en: 'Start a debug session as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下步骤开始调试会话：
- en: '![](img/79046081-8c6a-4c1f-a889-8993f5473f7a.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79046081-8c6a-4c1f-a889-8993f5473f7a.png)'
- en: Let's place a breakpoint at the New York button callback method, which we named
    `getDateTime`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在名为 `getDateTime` 的纽约按钮回调方法上放置一个断点。
- en: Open `Callbacks_Refactored.py` and place a breakpoint at the `getDateTime` method.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Callbacks_Refactored.py` 并在 `getDateTime` 方法上放置一个断点。
- en: 'Step through the code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐步通过代码：
- en: '![](img/fd64e5c5-4043-4804-b9c0-f7ca8163503a.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd64e5c5-4043-4804-b9c0-f7ca8163503a.png)'
- en: Let's now go behind the scenes to understand the code better.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在幕后了解代码，以便更好地理解它。
- en: How it works…
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first position where we might wish to place a breakpoint is at the place
    where we make our GUI visible by calling the `tkinter` main event loop. We do
    this in *step 1*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望放置断点的第一个位置是在我们通过调用 `tkinter` 主事件循环使我们的 GUI 可见的地方。我们在*步骤 1*中这样做。
- en: The green balloon symbol on the left is a breakpoint in PyDev/Eclipse. When
    we execute our code in debug mode, the execution of the code will be halted once
    the execution reaches the breakpoint. At this point, we can see the values of
    all the variables that are currently in scope. We can also type expressions into
    one of the debugger windows, which will execute them, showing us the results.
    If the result is what we want, we might decide to change our code using what we
    have just learned.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的绿色气球符号是 PyDev/Eclipse 中的断点。当我们以调试模式执行代码时，一旦执行达到断点，代码的执行将被中断。此时，我们可以看到当前作用域内所有变量的值。我们还可以在调试器窗口中输入表达式，这些表达式将被执行，并显示结果。如果结果是我们要的，我们可能会决定使用我们刚刚学到的东西来更改我们的代码。
- en: We normally step through the code by either clicking an icon in the toolbar
    of our IDE, or by using a keyboard shortcut (such as pressing *F5* to step into
    code, *F6* to step over, and *F7* to step out of the current method).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过点击 IDE 工具栏中的一个图标或使用键盘快捷键（例如按 *F5* 进入代码，*F6* 跳过，*F7* 从当前方法中退出）来逐步通过代码。
- en: Placing the breakpoint where we did and then stepping into this code turns out
    to be a problem because we end up in some low-level `tkinter` code we really do
    not wish to debug right now. We get out of this low-level `tkinter` code by clicking
    the Step-Out toolbar icon (which is the third yellow arrow on the right beneath
    the project menu) or by pressing *F7* (assuming we are using PyDev in Eclipse).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 将断点放置在之前的位置，然后逐步进入这段代码，结果是我们最终进入了一些我们目前并不想调试的低级`tkinter`代码。我们可以通过点击步骤退出工具栏图标（位于项目菜单下方右侧的第三个黄色箭头）或按*F7*（假设我们在使用Eclipse中的PyDev）来退出这种低级`tkinter`代码。
- en: A better idea is to place our breakpoint closer to our own code in order to
    watch the values of some of our own Python variables. In the event-driven world
    of modern GUIs, we have to place our breakpoints at code that gets invoked during
    events, for example, button clicks. We do this in *Steps 3* and *4*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的主意是将断点放置得更靠近我们自己的代码，以便观察我们自己的Python变量的值。在现代GUI的事件驱动世界中，我们必须将断点放置在事件期间被调用的代码中，例如，按钮点击。我们在*步骤3*和*步骤4*中这样做。
- en: Currently, one of our main functionalities resides in a button click event.
    When we click the button labelled New York, we create an event, which then results
    in something happening in our GUI.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的一项主要功能位于一个按钮点击事件中。当我们点击标记为纽约的按钮时，我们创建了一个事件，然后导致我们的GUI中发生某些事情。
- en: If you are interested in learning how to install Eclipse with the PyDev plugin
    for Python, there is a great tutorial that will get you started with installing
    all the necessary free software and then introduce you to PyDev within Eclipse
    by creating a simple, working Python program: [http://www.vogella.com/tutorials/Python/article.html](http://www.vogella.com/tutorials/Python/article.html).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对学习如何安装带有PyDev插件的Eclipse以用于Python感兴趣，有一个很好的教程，它将帮助你安装所有必要的免费软件，然后通过创建一个简单、有效的Python程序来介绍Eclipse中的PyDev：[http://www.vogella.com/tutorials/Python/article.html](http://www.vogella.com/tutorials/Python/article.html)。
- en: We use modern IDEs in the 21^(st) century that are freely available to help
    us to create solid code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在21世纪使用现代IDE，这些IDE是免费提供的，帮助我们创建坚实的代码。
- en: This recipe showed how to set debug watches, which is a fundamental tool in
    every developer's skill set. Stepping through our own code even when not hunting
    down bugs ensures that we understand our code, and it can lead to improving our
    code via refactoring.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何设置调试监视器，这是每个开发者技能集中的基本工具。即使不是在寻找错误，逐步执行我们自己的代码也能确保我们理解我们的代码，并且这可以通过重构来改进我们的代码。
- en: Debug watches help us to create solid code and this is not a waste of time.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 调试监视器帮助我们创建坚实的代码，这并不是浪费时间。
- en: Configuring different debug output levels
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置不同的调试输出级别
- en: In this recipe, we will configure different debug levels, which we can select
    and change at runtime. This allows us to control how much we want to drill down
    into our code when debugging our code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将配置不同的调试级别，我们可以在运行时选择和更改它们。这允许我们在调试代码时控制我们想要深入挖掘代码的程度。
- en: We will create two new Python classes and place both of them in the same module.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个新的Python类，并将它们都放在同一个模块中。
- en: We will use four different logging levels and write our debugging output to
    a log file that we will create. If the logs folder does not exist, we will create
    it automatically as well.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用四个不同的日志级别，并将我们的调试输出写入我们将创建的日志文件。如果日志文件夹不存在，我们将自动创建它。
- en: The name of the log file is the name of the executing script, which is our refactored
    `GUI_Refactored.py`. We can also choose other names for our log files by passing
    in the full path to the initializer of our `Logger` class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件的名称是执行脚本的名称，即我们重构后的`GUI_Refactored.py`。我们也可以通过传递`Logger`类初始化器的完整路径来为我们的日志文件选择其他名称。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using our refactored `GUI_Refactored.py` code from the previous
    recipe.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前菜谱中重构的`GUI_Refactored.py`代码。
- en: How to do it…
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how we shall proceed with this recipe:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将如何进行这个菜谱：
- en: First, we create a new Python module into which we place two new classes. The
    first class is very simple and defines the logging levels. This is basically an
    enumeration.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的Python模块，并将两个新的类放入其中。第一个类非常简单，定义了日志级别。这基本上是一个枚举。
- en: Create a new module and name it` Logger.py`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，并将其命名为`Logger.py`。
- en: 'Add the code as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加如下代码：
- en: '[PRE18]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the second class to the same module, `Logger.py`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个类添加到同一个模块中，`Logger.py`：
- en: '[PRE19]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the `writeToLog` method shown here:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`writeToLog`方法：
- en: '[PRE20]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Open `GUI_Refactored.py` and add this code:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_Refactored.py` 并添加以下代码：
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the code and observe the output:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出：
- en: '![](img/61cfa7f8-2617-40b1-bce0-fb02af08d67a.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61cfa7f8-2617-40b1-bce0-fb02af08d67a.png)'
- en: 'The preceding screenshot shows that we created an instance of our new `Logger`
    class, and the following screenshot shows that both the `logs` folder as well
    as the log were created:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示我们创建了一个新的 `Logger` 类的实例，下一张截图显示日志文件夹以及日志都已创建：
- en: '![](img/f5ac420f-fde0-4cbb-8c34-94abb206c96b.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5ac420f-fde0-4cbb-8c34-94abb206c96b.png)'
- en: 'Finally, open the log file:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开日志文件：
- en: '![](img/c2656814-1745-4a41-9555-433d45025c8b.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2656814-1745-4a41-9555-433d45025c8b.png)'
- en: Let's now go behind the scenes to understand the code better.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在幕后了解代码，以便更好地理解。
- en: How it works…
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first created a new module and used a simple class as an enumeration.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个新的模块，并使用一个简单的类作为枚举。
- en: The second class creates a log file by using the passed-in full path of the
    filename and places this into a logs folder. On the first run, the logs folder
    might not exist, so the code automatically creates the folder.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个类通过使用传递的文件名完整路径创建日志文件，并将其放置在日志文件夹中。在第一次运行时，日志文件夹可能不存在，因此代码会自动创建文件夹。
- en: In order to write to our log file, we use the `writeToLog` method. Inside the
    method, the first thing we do is check whether the message has a logging level
    higher than the limit we set our desired logging output to. If the message has
    a lower level, we discard it and immediately return from the method.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将内容写入我们的日志文件，我们使用 `writeToLog` 方法。在方法内部，我们首先检查消息的日志级别是否高于我们为期望的日志输出设置的极限。如果消息的级别较低，我们将其丢弃并立即从方法返回。
- en: If the message has the logging level that we want to display, we then check
    whether it starts with a newline character, and, if it does, we discard the newline
    by slicing the method starting at index 1, using Python's slice operator (`msg
    = msg[1:]`).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息具有我们想要显示的日志级别，我们接下来检查它是否以换行符开头，如果是，我们通过使用 Python 的切片操作符（`msg = msg[1:]`）从索引
    1 开始切片来丢弃换行符。
- en: We then write one line to our log file, consisting of the current date timestamp,
    two tab spaces, our message, and ending in a newline character.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们向日志文件写入一行，包括当前日期时间戳、两个制表符、我们的消息，并以换行符结束。
- en: We can now import our new Python module and, inside the `__init__` section of
    our GUI code, we create an instance of the `Logger` class.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以导入我们的新 Python 模块，并在我们的 GUI 代码的 `__init__` 部分创建 `Logger` 类的一个实例。
- en: We are retrieving the full path to our running GUI script via `path.realpath(__file__)`
    and passing this into the initializer of the `Logger` class. If the logs folder
    does not exist, it will automatically be created by our Python code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `path.realpath(__file__)` 获取我们正在运行的 GUI 脚本的完整路径，并将其传递给 `Logger` 类的初始化器。如果日志文件夹不存在，我们的
    Python 代码将自动创建它。
- en: We then verify that the log and folder got created.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来验证日志和文件夹是否已创建。
- en: In this recipe, we created our own logging class. While Python ships with a
    logging module, it is very easy to create our own, which gives us absolute control
    over our logging format. This is very useful when we combine our own logging output
    with MS Excel or `Matplotlib`, which we explored in the recipes of a previous
    chapter.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了自己的日志类。虽然 Python 附带了日志模块，但创建自己的日志模块非常简单，这使我们能够完全控制我们的日志格式。当我们将自己的日志输出与
    MS Excel 或 `Matplotlib` 结合使用时，这非常有用，这在上一章的菜谱中已经探讨过。
- en: In the next recipe, we will use Python's built-in `__main__` functionality to
    use the four different logging levels we just created.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将使用 Python 的内置 `__main__` 功能来使用我们刚刚创建的四个不同的日志级别。
- en: Creating self-testing code using Python's __main__ section
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 的 __main__ 部分创建自我测试代码
- en: Python comes with a very nice feature that enables each module to self-test.
    Making use of this feature is a great way of making sure that the changes to our
    code do not break the existing code and, additionally, the `__main__` self-testing
    section can serve as documentation for how each module works.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Python 具有一个非常棒的功能，它使每个模块都能够自我测试。利用这个功能是确保我们的代码更改不会破坏现有代码的绝佳方式，此外，`__main__`
    自我测试部分还可以作为每个模块如何工作的文档。
- en: After a few months or years, we sometimes forget what our code is doing, so
    having an explanation written in the code itself is indeed of great benefit.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月或几年后，我们有时会忘记我们的代码在做什么，所以代码本身有解释确实非常有好处。
- en: It is a good idea to always add a self-testing section to every Python module,
    when possible. It is sometimes not possible but, in most modules, it is possible
    to do so.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在可能的情况下给每个Python模块添加一个自我测试部分是一个好主意。有时可能做不到，但在大多数模块中，这样做是可能的。
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will extend the previous recipe, so in order to understand what the code
    in this recipe is doing, we have to first read and understand the code of the
    previous recipe.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展之前的菜谱，因此为了理解这个菜谱中的代码在做什么，我们首先需要阅读和理解之前菜谱中的代码。
- en: How to do it…
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see the steps of this recipe in detail:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这个菜谱的步骤：
- en: First, we will explore the power of the Python `__main__` self-testing section
    by adding this self-testing section to our `LanguageResources.py` module.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过将这个自我测试部分添加到我们的`LanguageResources.py`模块来探索Python `__main__`自我测试部分的力量。
- en: 'Next, add the following code to `LanguageResources.py`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到`LanguageResources.py`：
- en: '[PRE22]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the code and observe the output:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出：
- en: '![](img/b8d5a812-edab-4520-be62-1dd363cf1d02.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8d5a812-edab-4520-be62-1dd363cf1d02.png)'
- en: 'Add a `__main__` self-testing section to the `GUI_Refactored.py` module and
    run the code to see the following output:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GUI_Refactored.py`模块中添加一个`__main__`自我测试部分并运行代码以查看以下输出：
- en: '![](img/59dc1e7c-82f4-4aa0-af2a-3e510c192972.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59dc1e7c-82f4-4aa0-af2a-3e510c192972.png)'
- en: 'Next, in the `GUI_Refactored.py` module, add `oop.log.writeToLog(''Test message'')`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`GUI_Refactored.py`模块中，添加`oop.log.writeToLog('Test message')`：
- en: '[PRE23]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This gets written to our log file, as can be seen in the following screenshot
    of the log:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被写入我们的日志文件，如下面的日志截图所示：
- en: '![](img/b02b6fe6-f6f4-4d1f-90b7-a3243d3bdf2f.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b02b6fe6-f6f4-4d1f-90b7-a3243d3bdf2f.png)'
- en: 'In `GUI_Refactored.py`, import both new classes from our `Logger` module:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GUI_Refactored.py`中，从我们的`Logger`模块导入这两个新类：
- en: '[PRE24]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, create local instances of those classes:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建这些类的本地实例：
- en: '[PRE25]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use different logging levels via `self.oop.level`:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`self.oop.level`使用不同的日志级别：
- en: '[PRE26]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the code and open the log:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并打开日志：
- en: '![](img/df842b27-68f8-4b4b-9f93-77ac20c8fdf4.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df842b27-68f8-4b4b-9f93-77ac20c8fdf4.png)'
- en: 'Notice the `setLoggingLevel` method of the `Logger` class:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Logger`类的`setLoggingLevel`方法：
- en: '[PRE27]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `__main__` section of our GUI, change the logging level to `MINIMUM`:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的GUI的`__main__`部分，将日志级别更改为`MINIMUM`：
- en: '[PRE28]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Open the log file:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开日志文件：
- en: '![](img/28cc8eb5-64e3-4ec3-a767-9f87b112011f.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/28cc8eb5-64e3-4ec3-a767-9f87b112011f.png)'
- en: Let's now go behind the scenes to understand the code better.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入幕后更好地理解代码。
- en: How it works…
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by adding a `__main__` self-testing section to `LanguageResources.py`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`LanguageResources.py`中添加一个`__main__`自我测试部分。
- en: Whenever we run a module that has this self-testing section located at the bottom
    of the module, when the module is executed by itself, this code will run.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们运行一个包含位于模块底部的这个自我测试部分的模块时，当模块独立执行时，这段代码将会运行。
- en: When the module is imported and used from other modules, the code in the `__main__`
    self-testing section will not be executed.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块被其他模块导入和使用时，`__main__`自我测试部分的代码将不会执行。
- en: We first pass English as the language to be displayed in our GUI, and then we
    pass German as the language our GUI will display.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先传递英语作为GUI中要显示的语言，然后传递德语作为GUI将显示的语言。
- en: We print out the title of our GUI to show that our Python module works as we
    intended it to work.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出GUI的标题，以表明我们的Python模块按预期工作。
- en: The next step is to use our logging capabilities, which we created in the previous
    recipe.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用我们在之前的菜谱中创建的日志功能。
- en: We add a `__main__` self-testing section to `GUI_Refactored.py` and then verify
    that we created an instance of our `Logger` class.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`GUI_Refactored.py`中添加一个`__main__`自我测试部分，然后验证我们是否创建了一个`Logger`类的实例。
- en: We next write to our log file by using the command shown. We have designed our
    logging level to default to log every message, which is the `DEBUG` level, and,
    because of this, we do not have to change anything. We just pass the message to
    be logged to the `writeToLog` method.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用显示的命令将信息写入我们的日志文件。我们已经设计好我们的日志级别默认为记录每条消息，即`DEBUG`级别，因此我们不需要做任何改变。我们只需将需要记录的消息传递给`writeToLog`方法。
- en: Now, we can control the logging by adding logging levels to our logging statements
    and setting the level we wish to output. We add this capability to our New York
    button callback method in the `Callbacks_Refactored.py` module, which is the `getDateTime`
    method.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过添加日志级别到我们的日志语句并设置我们希望输出的级别来控制日志。我们在`Callbacks_Refactored.py`模块的New
    York按钮回调方法中添加了这个功能，即`getDateTime`方法。
- en: We change the previous print statements to log statements using different debug
    levels.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前的打印语句更改为使用不同调试级别的日志语句。
- en: As we are passing an instance of the GUI class to the `Callbacks_Refactored.py` initializer,
    we can use logging level constraints according to the `LogLevel` class we created.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将GUI类的实例传递给`Callbacks_Refactored.py`初始化器，我们可以使用我们创建的`LogLevel`类的日志级别约束。
- en: When we now click our New York button, depending upon the logging level selected,
    we get different output written to our log file. The default logging level is
    `DEBUG`, which means that everything gets written to our log.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在点击纽约按钮时，根据选择的日志级别，我们将不同的输出写入日志文件。默认的日志级别是`DEBUG`，这意味着所有内容都会写入日志。
- en: When we change the logging level, we control what gets written to our log. We
    do this by calling the `setLoggingLevel` method of the `Logger` class.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更改日志级别时，我们控制写入日志的内容。我们通过调用`Logger`类的`setLoggingLevel`方法来完成此操作。
- en: Setting the level to `MINIMUM` results in a reduced output written to our log
    file.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 将级别设置为`MINIMUM`会导致写入日志文件的输出减少。
- en: Now, our log file no longer shows the test message and only shows messages that
    meet the set logging level.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的日志文件不再显示测试消息，只显示符合设置日志级别的消息。
- en: In this recipe, we made good use of Python's built-in `__main__` self-testing
    section. We introduced our own logging file and, at the same time, learned how
    to create different logging levels. By doing this, we have full control over what
    gets written to our log files.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们很好地使用了Python的内置`__main__`自我测试部分。我们引入了自己的日志文件，同时学习了如何创建不同的日志级别。通过这样做，我们完全控制了写入日志文件的内容。
- en: Creating robust GUIs using unit tests
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单元测试创建健壮的GUI
- en: Python comes with a built-in unit testing framework and, in this recipe, we
    will start using this framework to test our Python GUI code.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了一个单元测试框架，在这个菜谱中，我们将开始使用这个框架来测试我们的Python GUI代码。
- en: Before we start writing unit tests, we want to design our testing strategy.
    We could easily intermix the unit tests with the code they are testing, but a
    better strategy is to separate the application code from the unit test code.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写单元测试之前，我们想要设计我们的测试策略。我们可以很容易地将单元测试与它们正在测试的代码混合，但更好的策略是将应用程序代码与单元测试代码分开。
- en: '`PyUnit` has been designed according to the principles of all the other xUnit
    testing frameworks.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyUnit`是根据所有其他xUnit测试框架的原则设计的。'
- en: Getting ready
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: We will test the internationalized GUI we created earlier in this chapter.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试本章中较早创建的国际化GUI。
- en: How to do it…
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'In order to use Python''s built-in unit testing framework, we import the Python
    `unittest` module. Let''s now look at the next steps:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Python的内置单元测试框架，我们导入Python的`unittest`模块。现在让我们看看下一步：
- en: Create a new module and name it `UnitTestsMinimum.py`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，并将其命名为`UnitTestsMinimum.py`。
- en: 'Add the following code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE29]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run `UnitTestsMinimum.py` and observe the following output:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`UnitTestsMinimum.py`并观察以下输出：
- en: '![](img/12dcecf3-982d-4df6-b8a3-ef73b1d6e920.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12dcecf3-982d-4df6-b8a3-ef73b1d6e920.png)'
- en: 'Create a new module, name it `UnitTests_One.py`, and then add this code:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，命名为`UnitTests_One.py`，然后添加以下代码：
- en: '[PRE30]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run `UnitTests_One.py`:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`UnitTests_One.py`：
- en: '![](img/036e99fc-3b80-4409-aedb-3744ac31d4ec.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/036e99fc-3b80-4409-aedb-3744ac31d4ec.png)'
- en: 'Save the module as `UnitTestsFail.py` and then copy, paste, and modify the
    code:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模块保存为`UnitTestsFail.py`，然后复制、粘贴并修改代码：
- en: '[PRE31]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run `UnitTestsFail.py`:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`UnitTestsFail.py`：
- en: '![](img/5dcca416-976e-4aef-b0cc-fddb32e446a4.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dcca416-976e-4aef-b0cc-fddb32e446a4.png)'
- en: 'Correct this failure by passing in `''de''` to `I18N`:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递`'de'`到`I18N`来纠正这个错误：
- en: '[PRE32]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Rerun `UnitTestsFail.py` with the failure corrected and observe the output:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行`UnitTestsFail.py`，修正错误并观察输出：
- en: '![](img/ac1ba1cd-76c3-48fe-9bdb-6826ef8df28f.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac1ba1cd-76c3-48fe-9bdb-6826ef8df28f.png)'
- en: Let's now go behind the scenes to understand the code better.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在幕后了解代码，以便更好地理解。
- en: How it works…
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We first import the `unittest` module, then we create our own class and, within
    this class, we inherit and extend the `unittest.TestCase` class. We use the minimum
    amount of code to get started. The code isn't doing much yet but, when we run
    it, we do not get any errors, which is a good sign.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`unittest`模块，然后创建我们自己的类，并在该类中继承并扩展`unittest.TestCase`类。我们使用最少的代码来开始。目前的代码还没有做很多事情，但是当我们运行它时，我们没有得到任何错误，这是一个好兆头。
- en: We actually do get an output written to the console stating that we successfully
    ran zero tests.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上确实在控制台上写入了输出，表明我们成功运行了零个测试。
- en: That output is a bit misleading, as all we have done so far is create a class
    that contains no actual testing methods.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 那个输出有点误导，因为我们到目前为止只是创建了一个不包含实际测试方法的类。
- en: We add testing methods that do the actual unit testing by following the default
    naming for all the test methods to start with the word **test**. This is an option
    that can be changed, but it is much easier and clearer to follow this *naming
    convention*.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了测试方法，通过遵循所有测试方法以单词**test**开头的默认命名来执行实际的单元测试。这是一个可以更改的选项，但遵循这个*命名约定*要容易和清晰得多。
- en: We then add one test method that tests the title of our GUI. This will verify
    that, by passing the expected arguments, we get the expected result.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后添加了一个测试方法来测试我们的GUI标题。这将验证通过传递预期的参数，我们是否得到了预期的结果。
- en: We are importing our `I18N` class from our `LanguageResources.py` module, passing
    English as the language to be displayed in our GUI. As this is our first unit
    test, we will print out the title result as well, just to make sure we know what
    we are getting back. We next use the `unittest assertEqual` method to verify that
    our title is correct.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`LanguageResources.py`模块导入我们的`I18N`类，将英语作为在GUI中显示的语言。由于这是我们第一个单元测试，我们将打印出标题结果，以确保我们知道我们得到了什么。接下来，我们使用`unittest
    assertEqual`方法来验证我们的标题是否正确。
- en: Running this code gives us an OK, which means that the unit test passed.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码给我们一个OK，这意味着单元测试通过了。
- en: The unit test runs and succeeds, which is indicated by one dot and the word
    OK. If it had failed or got an error, we would not have gotten the dot but an
    *F* or *E* as the output.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试运行并成功，这由一个点和单词OK表示。如果它失败了或者出现了错误，我们不会得到点，而是得到输出中的*F*或*E*。
- en: We then do the same automated unit testing check by verifying the title for
    the German version of our GUI. We test our internationalized GUI title in two
    languages.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过验证GUI德语版本的标题来进行相同的自动化单元测试检查。我们在两种语言中测试了我们的国际化GUI标题。
- en: We ran two unit tests but, instead of an OK, we got a failure. What happened?
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了两个单元测试，但得到的不是OK，而是失败。发生了什么？
- en: Our assertion failed for the German version of our GUI.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的断言对于GUI的德语版本失败了。
- en: While debugging our code, it turns out that in the copy, paste, and modify approach
    of our unit test code, we forgot to pass in German as the language.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试我们的代码时，我们发现，在我们的单元测试代码的复制、粘贴和修改方法中，我们忘记传递德语作为语言。
- en: After correcting the failure, we reran our unit tests, and we get the expected
    result of all our tests passing.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在纠正了失败之后，我们重新运行了我们的单元测试，并且所有测试都通过了预期的结果。
- en: Unit testing code is also code and can have bugs too.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试代码也是代码，也可能有错误。
- en: While the purpose of writing unit tests is really to test our application code,
    we have to make sure that our tests are written correctly. One approach from the
    **Test-Driven-Development** (**TDD**) methodology might help us.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写单元测试的目的是真正测试我们的应用程序代码，但我们必须确保我们的测试被正确编写。**测试驱动开发**（**TDD**）方法的一个方法可能有助于我们。
- en: In TDD, we develop the unit tests before we actually write the application code.
    Now, if a test passes for a method that does not even exist, something is wrong.
    The next step is to create the non-existing method and make sure it will fail.
    After that, we can write the minimum amount of code necessary to make the unit
    test pass.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，我们在实际编写应用程序代码之前就开发单元测试。现在，如果一个测试对于一个甚至不存在的函数通过了，那么就有问题。下一步是创建一个不存在的函数并确保它将失败。然后，我们可以编写必要的最小代码来使单元测试通过。
- en: In this recipe, we started testing our Python GUI, and writing unit tests in
    Python. We saw that Python unit test code is just code and can contain mistakes
    that need to be corrected. In the next recipe, we will extend this recipe's code
    and use the graphical unit test runner that comes with the PyDev plugin for the
    Eclipse IDE.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们开始测试我们的Python GUI，并编写Python单元测试。我们看到了Python单元测试代码只是代码，也可能包含需要修正的错误。在下一个菜谱中，我们将扩展这个菜谱的代码，并使用Eclipse
    IDE的PyDev插件提供的图形单元测试运行器。
- en: How to write unit tests using the Eclipse PyDev IDE
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用Eclipse PyDev IDE编写单元测试
- en: In the previous recipe, we started using Python's unit testing capabilities,
    and, in this recipe, we will ensure the quality of our GUI code by using this
    capability further.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们开始使用Python的单元测试功能，在这个菜谱中，我们将通过进一步使用这个功能来确保我们的GUI代码的质量。
- en: We will unit test our GUI in order to make sure that the internationalized strings
    our GUI displays are as expected.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将单元测试我们的GUI，以确保GUI显示的国际化字符串符合预期。
- en: In the previous recipe, we encountered some bugs in our unit testing code but,
    typically, our unit tests will find regression bugs that are caused by modifying
    the existing application code, not the unit test code. Once we have verified that
    our unit testing code is correct, we do not usually change it.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们在单元测试代码中遇到了一些错误，但通常，我们的单元测试会发现由修改现有应用程序代码而不是单元测试代码引起的回归错误。一旦我们验证了我们的单元测试代码是正确的，我们通常不会更改它。
- en: Our unit tests also serve as a documentation of what we expect our code to do.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试还充当了我们期望代码如何操作的文档。
- en: By default, Python's unit tests are executed with a textual unit test runner,
    and we can run this in the PyDev plugin from within the Eclipse IDE. We can also
    run the very same unit tests from a console window.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python 的单元测试是通过文本单元测试运行器执行的，我们可以在 Eclipse IDE 中的 PyDev 插件中运行它。我们也可以从控制台窗口运行完全相同的单元测试。
- en: In addition to the text runner in this recipe, we will explore PyDev's graphical
    unit test feature, which can be used from within the Eclipse IDE.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本菜谱中的文本运行器，我们还将探索 PyDev 的图形单元测试功能，这可以在 Eclipse IDE 中使用。
- en: Getting ready
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will extend the previous recipe in which we began using Python unit tests. The
    Python unit testing framework comes with what are called **Test Fixtures**.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展之前的菜谱，其中我们开始使用 Python 单元测试。Python 单元测试框架附带了一些称为 **测试用例** 的功能。
- en: 'Refer to the following URLs for a description of what a test fixture is:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下网址以了解测试用例的描述：
- en: '[https://docs.python.org/3.7/library/unittest.html](https://docs.python.org/3.7/library/unittest.html)'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3.7/library/unittest.html](https://docs.python.org/3.7/library/unittest.html)'
- en: '[https://en.wikipedia.org/wiki/Test_fixture](https://en.wikipedia.org/wiki/Test_fixture)'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Test_fixture](https://en.wikipedia.org/wiki/Test_fixture)'
- en: '[http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html](http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html](http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html)'
- en: What this means is that we can create `setup` and `teardown` unit testing methods
    so that the `setup` method is called at the beginning before any single test is
    executed, and, at the end of every single unit test, the `teardown` method is
    called.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以创建 `setup` 和 `teardown` 单元测试方法，以便在执行任何单个测试之前调用 `setup` 方法，并且在每个单元测试结束时调用
    `teardown` 方法。
- en: This test fixture capability provides us with a very controlled environment
    in which we can run our unit tests.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试用例功能为我们提供了一个非常受控的环境，我们可以在这个环境中运行我们的单元测试。
- en: How to do it…
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now, let''s see how to perform this recipe:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何执行这个菜谱：
- en: Firstly, let's set up our unit testing environment. We will create a new testing
    class that focuses on the aforementioned correctness of code.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们设置我们的单元测试环境。我们将创建一个新的测试类，专注于上述代码的正确性。
- en: Create a new module, `UnitTestsEnglish.py`.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，`UnitTestsEnglish.py`。
- en: 'Add the following code:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE33]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the code and observe the output:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出：
- en: '![](img/9ee00d5e-d548-4469-a558-1536c6bde418.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ee00d5e-d548-4469-a558-1536c6bde418.png)'
- en: Open `UnitTestsEnglish.py` and save it as `UnitTests.py`.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `UnitTestsEnglish.py` 并将其保存为 `UnitTests.py`。
- en: 'Add the following code to the module:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到模块中：
- en: '[PRE34]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run `UnitTests.py`:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `UnitTests.py`：
- en: '![](img/33ef01af-7821-4644-a489-da190bdcec7c.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33ef01af-7821-4644-a489-da190bdcec7c.png)'
- en: 'Run the code from Command Prompt and observe the output as follows:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令提示符运行代码并观察以下输出：
- en: '![](img/77a67d45-6553-4c6e-8d4b-a750d11c87b8.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77a67d45-6553-4c6e-8d4b-a750d11c87b8.png)'
- en: 'Using Eclipse, we can also choose to run our unit tests, not as a simple Python
    script, but as a Python unit test script, which gives us some colorful output:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Eclipse，我们还可以选择将我们的单元测试作为 Python 单元测试脚本运行，而不是简单的 Python 脚本，这会给我们一些彩色的输出：
- en: '![](img/f12a233f-a2ed-4ddf-a389-1ce393402a65.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f12a233f-a2ed-4ddf-a389-1ce393402a65.png)'
- en: Let's learn about the steps in the next section.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中了解这些步骤。
- en: How it works…
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Firstly, we created three test methods.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了三个测试方法。
- en: '`unittest.main()` runs any method that starts with the `test` prefix, no matter
    how many classes we create within a given Python module.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.main()` 运行任何以 `test` 前缀开始的任何方法，无论我们在给定的 Python 模块中创建了多少个类。'
- en: The unit testing code shows that we can create several unit testing classes
    and they can all be run in the same module by calling `unittest.main()`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试代码显示我们可以创建几个单元测试类，并且它们都可以通过调用 `unittest.main()` 在同一个模块中运行。
- en: It also shows that the `setup` method does not count as a test in the output
    of the unit test report (the count of tests is three) while, at the same time,
    it did its intended job as we can now access our `self.gui` class instance variable
    from within the unit test method.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 它还显示，在单元测试报告的输出中，`setup` 方法不被算作一个测试（测试数量为三个），同时，它也完成了预期的任务，因为我们现在可以从单元测试方法中访问我们的
    `self.gui` 类实例变量。
- en: We are interested in testing the correctness of all of our labels and, especially,
    catching bugs when we make changes to our code.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对测试所有标签的正确性感兴趣，尤其是在我们更改代码时捕捉到错误。
- en: If we have copied and pasted strings from our application code to the testing
    code, it will catch any unintended changes with the click of a unit testing framework
    button.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将应用程序代码中的字符串复制粘贴到测试代码中，它将通过点击单元测试框架按钮捕捉到任何意外的更改。
- en: We also want to test the fact that invoking any of our radio button widgets
    in any language results in the `LabelFrame` widget text being updated. In order
    to automatically test this, we have to do two things.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望测试调用任何语言中的任何单选按钮小部件都会导致 `LabelFrame` 小部件文本更新的事实。为了自动测试这一点，我们必须做两件事。
- en: 'First, we have to retrieve the value of the `LabelFrame` widget and assign
    the value to a variable we name `labelFrameText`. We have to use the following
    syntax because the properties of this widget are being passed and retrieved via
    a dictionary data type:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须检索 `LabelFrame` 小部件的值，并将其分配给一个我们命名为 `labelFrameText` 的变量。我们必须使用以下语法，因为此小部件的属性是通过字典数据类型传递和检索的：
- en: '[PRE35]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can now verify the default text and then the internationalized versions after
    clicking one of the radio button widgets programmatically.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以验证默认文本，然后点击其中一个单选按钮小部件后验证国际化版本。
- en: 'After verifying the default `labelFrameText`, we programmatically set the radio
    button to `index 1` and then invoke the radio button''s callback method:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证默认 `labelFrameText` 后，我们程序化地将单选按钮设置为 `索引 1`，然后调用单选按钮的回调方法：
- en: '[PRE36]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is basically the same action as clicking the radio button in the GUI, but
    we do this button click event via code in the unit tests.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与在 GUI 中点击单选按钮相同，但我们通过代码在单元测试中执行此按钮点击事件。
- en: Then, we verify that our text in the `LabelFrame` widget has changed as intended.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们验证我们的 `LabelFrame` 小部件中的文本是否按预期更改。
- en: 'If you get a `ModuleNotFoundError`, simply add the directory where your Python
    code lives to the Windows `PYTHONPATH` environmental variable, as shown in the
    following screenshots:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到 `ModuleNotFoundError`，只需将你的 Python 代码所在的目录添加到 Windows 的 `PYTHONPATH` 环境变量中，如下面的截图所示：
- en: 'An error gets encountered as shown:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，遇到错误：
- en: '![](img/8e4e459a-23ef-4ce0-a47e-b95e3e2677a1.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e4e459a-23ef-4ce0-a47e-b95e3e2677a1.png)'
- en: 'The solution to the error, if you encounter it, is shown here:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到错误，解决方案如下所示：
- en: '![](img/aeff779b-3908-4688-9279-9d54dba0ccf2.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aeff779b-3908-4688-9279-9d54dba0ccf2.png)'
- en: 'For example, `C:\Eclipse_Oxygen_workspace_Packt_3rd_GUI_BOOK\3rd Edition Python
    GUI Programming Cookbook`:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`C:\Eclipse_Oxygen_workspace_Packt_3rd_GUI_BOOK\3rd Edition Python GUI Programming
    Cookbook`：
- en: '![](img/4bfd962a-63a0-423b-8278-38cc37f9cdd5.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4bfd962a-63a0-423b-8278-38cc37f9cdd5.png)'
- en: This will recognize the `Ch08_Code` folder as a Python package and the code
    will run.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这将识别 `Ch08_Code` 文件夹为 Python 包，代码将运行。
- en: When we run the unit test from the graphical runner in Eclipse, the result bar
    is green, which means that all our unit tests have passed.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 Eclipse 的图形运行器中运行单元测试时，结果栏是绿色的，这意味着我们所有的单元测试都通过了。
- en: We extended our unit testing code by testing labels, programmatically invoking `Radiobutton`,
    and then verifying in our unit tests that the corresponding text property of the
    `LabelFrame` widget has changed as expected. We tested two different languages. We
    then moved on to use the built-in Eclipse/PyDev graphical unit test runner.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过测试标签、程序化调用 `Radiobutton` 并在单元测试中验证 `LabelFrame` 小部件的相应文本属性是否按预期更改来扩展我们的单元测试代码。我们测试了两种不同的语言。然后，我们继续使用内置的
    Eclipse/PyDev 图形单元测试运行器。
