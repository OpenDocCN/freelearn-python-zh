- en: 7 Dealing with Security Concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When building a web application, it might be very tempting to sit down, plan
    out your functionality, build it, test it, and only then come back to think about
    security. For example, when building a single-page application, you might not
    even consider CORS until the first time you see this message in the browser while
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To a large extent, this is how we have been building in this book. We see a
    feature and build it. Anytime we have run up against a potential security issue
    in this book, we have pushed it off to a later date. We finally are at this point
    where we will learn how to deal with security issues in Sanic. The topic of web
    security is, of course, extremely broad, and it is beyond the scope of this book
    to be an exhaustive study.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, in this chapter we will explore:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an effective CORS policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting applications from CSRF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting your Sanic app with authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In particular, we want to gain a basic understanding of the security issues
    so we can build Sanic solutions to solve them. The bigger takeaway from this Chapter
    will be to make you feel comfortable enough with these topics that they do not
    become the after-thought. When these issues are broken down, we can see that building
    them into application design from the beginning will make them more effective
    and less burdensome to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The requirements for this chapter will again build upon what we have been using
    in previous chapters. Since web security often includes the interaction between
    frontend Javascript applications and backend Python applications, we may see some
    examples that use Javascript that is widely available in major web browsers. You
    can find all of the source code for this chapter at: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we are going to use three common (and battle tested) security
    libraries: `cryptography`, `bcrypt`, and `pyjwt`. If you do not already have them
    installed in your virtual environment, you can add them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Setting up an effective CORS policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are building a web application where the server exclusively responds
    to requests on a single computer, and that computer is physically disconnected
    from the Internet, perhaps this section is not as relevant to you. For anyone
    else, pay attention! To be clear, you are part of “anyone else”. This is important
    stuff.
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, **cross-origin resource sharing (CORS)** is a fancy way of
    saying *accessing one domain from another domain with a browser*. Without an effective
    strategy for handling this, your application could open up a security risk for
    your users.
  prefs: []
  type: TYPE_NORMAL
- en: What is the security issue with ineffective CORS?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The modern web uses a lot of Javascript in web browsers. It, of course, enables
    all kinds of interactive and quality user experiences. One of those capabilities
    is to issue requests for data on behalf of the user without them knowing about
    it. This feature is one of the biggest differentiators between web applications
    today and web applications from the late ’90s. Requesting data while the user
    is on a website is what makes web pages feel like applications. That is to say
    that it makes them interactive and engaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'So imagine that you have a hypothetical application that appears to the user
    as: `https://superawesomecatvideos.com`. It is a super successful website, and
    lots of people like to come to visit it to see their favorite car videos. If it
    starts requesting information in the background (because of a hacker attack, or
    otherwise) from `https://mybank.com`, well, we of course do not want to allow
    that to succeed. There is no reason that the Super Awesome Cat Videos website
    should be able to access anything from My Bank, especially if I have an authenticated
    web session at My Bank’s website.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, web browsers will not allow this by default because of the
    **same-origin policy**. This means that web applications may only interact with
    resources that are of the same-origin. An origin is comprised of:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP scheme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at some examples of URLs that are and are not considered to be same-origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **URL A** | **URL B** | **Same-origin?** |'
  prefs: []
  type: TYPE_TB
- en: '| [`http://sacv.com`](http://sacv.com) | [`http://sacv.com`](http://sacv.com)
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| [`http://sacv.com`](http://sacv.com) | [`http://sacv.com`](http://sacv.com)
    `/about` | Yes, path does not matter |'
  prefs: []
  type: TYPE_TB
- en: '| [`http://sacv.com`](http://sacv.com) | [`https://sacv.com`](https://sacv.com)
    | No, different HTTP schemes |'
  prefs: []
  type: TYPE_TB
- en: '| [`http://sacv.com`](http://sacv.com) | [`http://sacv.com`](http://sacv.com)
    `:8080` | NO, different ports |'
  prefs: []
  type: TYPE_TB
- en: '| [`http://sacv.com`](http://sacv.com) | [`http://api.sacv.com`](http://api.sacv.com)
    | No, different domains |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 - Comparison of URLs and their same-origin status
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll assume that our Super Awesome Cat Video website also has the domain:
    sacv.com. For example, if `https://superawesomecatvideos.com` wants to load: `https://superawesomecatvideos.com/catvid1234.mp4`,
    that is fine. When the only difference is the path or resource being loaded, the
    URLs are considered same-origin. In our example, both URLs contain the same HTTP
    scheme, domain, and port designation. But, when the same website [https://superawesomecatvideos](https://superawesomecatvideos)
    tries to fetch data from `https://api.superawesomecatvideos.com/videos`, uh oh,
    error time. These are the sorts of potential attack vectors that the same-origin
    policy is meant to protect from. So, the question becomes: how can we allow legitimate
    cross-origin requests, without allowing *all* cross-origin requests? The answer
    is that we essentially need to create a whitelist and let the browser know which
    origins our server will accept requests from.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build a super simple example that will show us the problem. We are going
    to build two webservers here. One will be a stand-in for the frontend application,
    and the other will be the backend meant to feed data to the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by building and running a simple API endpoint that looks no different
    than anything we have seen before. Stand up the application using the same method
    we have already used. Here is what your endpoint can look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have a Sanic server running on port `7777` using what we have
    already learned. You can test it out by accessing: `http://localhost:7777/Adam`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory somewhere and add this file called `index.html` to it. For
    my example it will be `/path/to/directory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, this application will run a background request to our application
    that is running on `http://localhost:7777`. After it gets the content, it will
    dump it on the screen in place of the `Loading ...` text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run this application, we are going to use a neat little trick that Sanic
    includes called “*Sanic Simple Server*”. Instead of building a Sanic application,
    we will point the Sanic CLI at a directory and it will serve that for us as a
    website:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Tip**'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a super helpful tool to keep in your back pocket, even when not building
    a Sanic application. In the course of development, I often find a need to quickly
    standup a web application to view static content in a browser. This could be useful
    when building an application that uses only static content, or when building a
    Javascript application and you need a development server.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Open up a web browser and go to this application that should be running at
    [http://localhost:8000](http://localhost:8000). You should see something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1 - Screenshot of the web application with CORS issue](img/file8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 - Screenshot of the web application with CORS issue
  prefs: []
  type: TYPE_NORMAL
- en: 'Uh oh, something went wrong. Our application is throwing an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For most of us getting into web development, this experience would be our first
    with CORS. What on Earth does this mean? What is a “*Cross-Origin Request*”, and
    why is it blocked? What is a CORS header? And, most importantly, how do I make
    this go away?! This last question is the one that bothers me. We are not going
    to “*make it go away*”, we are going to understand what this means, why the browser
    decided to throw up a road block, and then move on to creating a solution.
  prefs: []
  type: TYPE_NORMAL
- en: The naive web developer upon seeing this error will immediately go online to
    search how to deal with this, find a mess of partial or way-too-in-depth information,
    and then move on without ever understanding the actual issue. Making it go away
    will get you back to developing since the error is no longer blocking your progress,
    but it will not solve the problem. In fact, you just created a new one. To become
    a better developer, we are not going to just implement an off-the-shelf solution
    without understanding it. Instead we will pause to learn what is happening and
    why. Maybe you have come up against this issue yourself, if not, you surely will
    at some point. Whether you have or have not “solved” this problem in the past,
    we are going to take some time to learn the rationale behind this error before
    coming up with an appropriate—or rather, *obvious*—solution. Once you peel back
    the layers of CORS, you will see that it starts to make a lot of sense and can
    become simple to master.
  prefs: []
  type: TYPE_NORMAL
- en: 'I was one such naive person that searched this error, clicked the first link,
    copied and pasted a solution that made the error go away, and then moved on with
    life not giving it another thought. The browser no longer complained: problem
    solved. At least that is what I thought. I did not think about the consequences
    of my action and the security hole I had introduced. What was that security hole
    masquerading as a fix? The solution I found was to add a simple header, and I
    gave it no further thought: `Access-Control-Allow-Origin: *`. *DO NOT DO THIS!*
    I did not know any better and I moved on never thinking twice about CORS, except
    that it was the pesky thing in browsers that seemed to cause me problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue here is that the frontend application is trying to access details
    from another origin: hence *cross origin*. When I added that header, I was effectively
    disabling the same-origin protection that the browser was creating. The `*` means:
    *allow this application to request any cross origin information it wants*.'
  prefs: []
  type: TYPE_NORMAL
- en: My browser had created a castle for protection. Rather than learn about how
    to effectively handle CORS, I decided to drop the drawbridge, open all of the
    gates, and send the guards home to their beds.
  prefs: []
  type: TYPE_NORMAL
- en: What should I have done? Let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a strategy for effectively dealing with CORS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Obviously, my strategy to completely disable the browser defenses was not the
    best approach. It was the easy way out, the lazy way out, and the irresponsible
    way out. What I should have done is go to a resource like the one that Mozilla
    provides and read up on the issue: [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).
    If I did, then this would have caught my attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Who should read this article?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Everyone, really.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh, *everyone* should read it? If you have not read it, you have the opportunity
    now to take a different path than me, and to go read it now. I am not kidding.
    Please do yourself a favor: put a bookmark in this book and go read that webpage.
    Then come back here. I promise we will wait for you. It is written in fairly simple
    terms to understand and is an authoritative resource to keep in your back pocket.'
  prefs: []
  type: TYPE_NORMAL
- en: According to the official HTTP specification, the `OPTIONS` method *allows a
    client to determine the options and/or requirements associated with a resource,
    or the capabilities of a server, without implying a resource action* ([https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.7](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.7)).
    In other words, it gives an HTTP client the ability to check what an endpoint
    might require from it before sending an actual request. If you have ever built
    a browser-based web application, or if you intend to, this method is extremely
    important. Therefore, as we dive into what the CORS headers are, we will also
    revisit and heavily make use of our `OPTIONS` handler from back in *Chapter 3*,
    *Routing and intaking HTTP requests*. Take a flip back to that section to reacquaint
    yourself with how we will automatically attach `OPTIONS` handlers for all of our
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CORS headers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Solving these cross origin access issues is accomplished through the application
    of response headers. Therefore, we will need to learn what some of these headers
    are and when they should be applied and used. Our job in this section will be
    to build HTTP responses with some basic CORS headers that we can use in our applications.
    We, of course, could take the easy way out and install one of the third-party
    packages on PyPI that will automatically add the headers for us.
  prefs: []
  type: TYPE_NORMAL
- en: In actuality, I do suggest that you do this for a production application. CORS
    issues can be complex, and implementing a *trusted* solution should bring some
    level of comfort and peace of mind. However, relying upon one of these packages
    without knowing the basics is only slightly better than my first solution of disabling
    the same-origin policy completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the common CORS response headers we should know about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access-Control-Allow-Origin**: This is used by the server to tell the client
    which origins it will and will not accept cross-origin requests from;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access-Control-Expose-Headers**: This is used by the server to tell the browser
    which HTTP headers it can allow Javascript to access safely (meaning it does not
    contain sensitive data);'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access-Control-Max-Age**: This is used by the server to tell the client how
    long it could cache the results of a **preflight request** (see the next section
    to learn what a preflight request is);'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access-Control-Allow-Credentials**: This is used by the server to tell the
    client whether it can or cannot include credentials when sending in requests;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access-Control-Allow-Methods**: This is used by the server in preflight requests
    to tell the client what HTTP methods it will accept on a given endpoint;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access-Control-Allow-Headers**: This is used by the server in preflight requests
    to tell the client which HTTP headers it will allow it to add.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding preflight requests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In certain scenarios, before a browser tries to access a cross-origin *something*,
    it will issue what is known as a **preflight request**. This is a request to the
    same domain and endpoint as the intended resource that happens before the actual
    call, except with an `OPTIONS` HTTP method. The goal of this request is to get
    access to the CORS headers to learn what the server will and will not allow. If
    the browser determines that the response is not “safe”, it will not allow it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When will a browser decide to issue a preflight request? Mozilla provides a
    great overview on their CORS page ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests)).
    In summary, a preflight request will *not* be issued by the browser when:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a `GET`, `HEAD`, or `POST`
  prefs: []
  type: TYPE_NORMAL
- en: Does not contain any manually set headers, except for `Accept`, `Accept-Language`,
    `Content-Language`, or `Content-Type`
  prefs: []
  type: TYPE_NORMAL
- en: The request headers include `Content-Type`, and it is set to one of `application/x-www-form-urlencoded`,
    `multipart/form-data`, or `text/plain`
  prefs: []
  type: TYPE_NORMAL
- en: There are no Javascript event listeners on the request
  prefs: []
  type: TYPE_NORMAL
- en: The response is not going to be streamed by the client
  prefs: []
  type: TYPE_NORMAL
- en: 'These requests are generally meant to cover the scenarios encountered by *normal*
    web traffic: navigating to a page, submitting an HTML form, and basic AJAX requests.
    As soon as your application starts adding in functionality that is typical of
    most single-page web applications, you will begin to notice your browser issuing
    preflight requests. In this context, the two most common types of requests that
    trigger preflight are:'
  prefs: []
  type: TYPE_NORMAL
- en: JS applications that inject custom headers (`Authorization`, `X-XSRF-Token`,
    `Foobar`, etc)
  prefs: []
  type: TYPE_NORMAL
- en: 'JS applications that submit JSON data using `Content-Type`: `application/json`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering: why does this matter? It is important to understand this
    so that we know when we need to respond with each of the six CORS response headers
    we saw in the last section.'
  prefs: []
  type: TYPE_NORMAL
- en: Solving for CORS with Sanic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Up until this point, we have entirely avoided the usage of any third-party plugins.
    That is, to say that we have steered away from any implementation that would require
    us to `pip install` a solution. This has been a conscious decision so that we
    learn the principles needed to build our web applications before we just outsource
    the solution to someone else. While this is still valid here and is the reason
    we are about to handle CORS requests by hand, it is also important to point out
    that this is a problem that has been solved already. The officially supported
    `sanic-ext` package and the community-supported `sanic-cors` package are both
    reputable options for implementing CORS protection.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, let’s think about each of the six (6) response headers and *when*
    and how we will need to implement them. We have some headers we want to add regardless
    of the type of request, and some that will `only` be added on preflight requests.
    We will need a standard and repeatable method for adding response headers in these
    two scenarios. What is our go-to strategy for that? Middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with this basic middleware and add code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We are doing two things to determine that a request is indeed a preflight request:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we know that the browser will always issue it as an `OPTIONS` request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, the browser will always attach a request header called `Access-Control-Request-Method`
    with the value of the type of HTTP request that it is about to send
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To simulate a preflight request, we will use the following curl request that
    adds the two headers we need to trigger the preflight request response (the `Origin`
    header and the `Access-Control-Request-Method` header):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need is some ability for adding `OPTIONS` as a viable HTTP
    method for every existing route in our application. This is something that `sanic-ext`
    adds, and we will learn an easy way to accomplish this in *Chapter 11*, *A complete
    real-world example*, using that package. But first, you might recall that this
    is something that we built way back in *Chapter 3*, *Routing and intaking HTTP
    requests*. We will reuse the code that looped through all of our defined routes
    and added an `OPTIONS` endpoint. You can find it in that chapter in the *Blanket
    support for OPTIONS and HEAD* section.
  prefs: []
  type: TYPE_NORMAL
- en: With this established, we will look at each response header to understand them
    more completely.
  prefs: []
  type: TYPE_NORMAL
- en: Access-Control-Allow-Origin
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This header alone is arguably the most important one to add. It is also the
    one that is most tempting to be the nuclear option and just disable CORS protection
    completely as discussed earlier. Unless you have a specific reason to accept requests
    from any browser origin, you should avoid `*`.
  prefs: []
  type: TYPE_NORMAL
- en: The value should, instead, be the address that you anticipate requests coming
    from. You should *NOT* just recycle the incoming request’s `Origin` header and
    apply that. This is effectively the same as `*`. Instead, it is a good practice
    to have a predefined list of allowed origins and cross-reference the incoming
    `Origin` with those. If there is not a match, simply do not add any CORS headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first snippet we will add to our middleware to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you set the configuration `ALLOWED_ORIGINS` value as well. This
    could be done wherever you create your app instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we will add this to all responses that are coming from the browser.
    How do we know it is a browser request? Because we can expect that browsers will
    add the `Origin` header.
  prefs: []
  type: TYPE_NORMAL
- en: Access-Control-Expose-Headers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `Access-Control-Expose-Headers` header provides the server with the ability
    to control which headers are exposed to Javascript access. It is a security measure
    to provide a whitelist control of what information is available to the in-browser
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start adding some tests into the browser. For these examples, we will
    use a similar basic HTML structure as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by setting up our HTML. The goal here is to read the header `foobar`
    in Javascript and output it on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to set up our application to see the HTML and add the header:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify our curiosity, we will double-check the response with `curl` to make
    sure the header is actually being sent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open your browser to `http://127.0.0.1:7777/test`. You should see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What happened is that the browser was blocked from accessing the header. If
    we want to allow it, then we need to be explicit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Therefore, heading back to the `add_cors_headers` middleware that we were building,
    let’s add the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do not forget that since we are actually testing this on a browser, we need
    to set the `ALLOWED_ORIGINS` configuration value appropriately:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time when you access the browser, you should see that the Javascript was
    able to reach in and get the value from the `Foobar` header:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Therefore, if you intend to use any sort of meta-data on the client-side of
    your application, you will need to properly use `access-control-expose-headers`.
  prefs: []
  type: TYPE_NORMAL
- en: Access-Control-Max-Age
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When a browser *does* issue a preflight request, it has the ability to cache
    that response so that the next time it makes the same request it does not need
    to hit the server. This performance improvement can be controlled (to some extent)
    by the server using the `Access-Control-Max-Age`, which specifies the length of
    time (in seconds) that the preflight request can be cached.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, web browsers will set a maximum value for this. If you tried to set
    it to some absurdly large number, they will drop it down to their predefined maximum
    value. For this reason, I usually recommend going with a value that is around
    10 minutes. Some browsers will allow you to go up to 24 hours, but that is probably
    about the maximum allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see this now in our middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Access-Control-Allow-Credentials
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This header is for preflight requests only. So, the snippet we will add here
    needs to go inside our `is_preflight(request)` block.
  prefs: []
  type: TYPE_NORMAL
- en: When a Javascript application makes a request, it must *explicitly* make the
    call allowing for credentials to be sent. If not, then the browser will not include
    them in the request. The server can then play its part to tell the browser that
    this request that includes credentials is—or is not—safe to expose to the Javascript
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow it, we set the header like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Access-Control-Allow-Methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Up until this point, there really has not been a need for any plugins. Adding
    these CORS headers has been fairly straightforward. The next part, however, is
    something that could become a little more tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Access-Control-Allow-Methods` header is meant to be a warning to the browser
    during the preflight request about what HTTP methods the browser is allowed to
    send to the endpoint cross-origin. A lot of applications disable this protection
    by allowing everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This certainly is a simple solution. It is less harmful than that first CORS
    solution I came across that allowed any origin. But, we can still do better.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish the ability to have dynamic methods that match the *actual* endpoint
    possibilities, we are going to change some things around in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Remember how we are defining a request as preflight? Let’s do that up front
    in the request middleware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, when we generate the handlers for `OPTIONS` requests, we will inject
    a list of all of the allowed methods like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have access to the preflight check in our options handler, we can
    do our check and add the headers there. We also can take the list of methods that
    were passed in and concatenate them into a comma-delimited list. This should now
    provide an automated set of `OPTIONS` endpoints with exactly the HTTP methods
    that will be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will look at the preflight response using curl to see all of our headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Access-Control-Request-Headers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final header we are concerned with here is `Access-Control-Request-Headers`,
    and is also one that should be sent in preflight responses. It is an indication
    to the browser which non-standard headers can be sent in the cross-origin request.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the Javascript wanted to send a header called *counting*, then it would
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: However, because this would trigger a preflight request, the browser will fail
    with a CORS error because the server has not explicitly allowed counting as an
    acceptable header.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we enable it in our preflight block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our review of CORS headers has added a lot of code. To see the completed version,
    please checkout the GitHub repository: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07/corsissue](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07/corsissue).
    Now that we have completed our CORS review, we are onto the next topic that is
    similarly related: CSRF'
  prefs: []
  type: TYPE_NORMAL
- en: Protecting applications from CSRF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step in our journey is handling cross-site request forgery (CSRF).
    It should also be noted that this often also carries the acronym XSRF. If you
    see these two on the web, they refer to the same issue. So, what is the issue?
  prefs: []
  type: TYPE_NORMAL
- en: You know that suspiciously awkward email that you received that says “click
    here to claim your $500 prize”? Likely that link brings you to a malicious website
    controlled by someone that is trying to hack you. They may have placed some links
    or caused you to do something on their site that sends off a background request
    to a legitimate website to do something bad. If your application is not protected
    from CSRF attacks like this, it could be possible for that bad actor to induce
    your users to changing their passwords without them even knowing it!
  prefs: []
  type: TYPE_NORMAL
- en: Thwarting these attacks can be done on both sides. Your users could, of course,
    take better care not to open their email in the Spam box. But you, as a responsible
    web application developer, also have a responsibility to protect your users.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions that do not work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cookies. You may be surprised if you skipped ahead to peak at the solution that
    I offer you will see that it does include cookies. Indeed, cookies can play a
    part in solving the problem. However, they are a flawed security measure and *cannot*
    be the answer to the CSRF problem by themselves.
  prefs: []
  type: TYPE_NORMAL
- en: How would this even work? Imagine that you set a session ID in a cookie. It
    is a decently good mixture of random characters so that it would be impractical
    for someone to guess it correctly. The problem is that cookies are sent with every
    request based not upon where the request is initiated, but where it is headed.
    So, if your browser sees that it has a cookie in storage for `yourapplication.com`,
    then even if the request was initiated at `h4ck3rsp4r4d1se.com`, the browser would
    send the cookies.
  prefs: []
  type: TYPE_NORMAL
- en: It also should be noted that introducing TLS and reading the Origin header are
    not sufficient solutions either. Of course, these are useful and valid things
    your application should be done, but alone they do not add protection from CSRF.
    The `Origin` header, for example, could easily be spoofed.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions that do work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know what will not protect us from CSRF attacks, we can look into
    a few solutions that will work and help protect our web applications. These are
    not mutually exclusive, and I suggest you consider implementing them all in one
    form or another. Your decision will be contextual, of course, but here are some
    good practices to keep in mind while protecting your application from CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Do not change state on `GET`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is incredibly important. We discussed the issue back in *Chapter 3*, but
    `GET` requests should not be state-changing. That means that the application should
    not take any direction from a `GET` request to go do something. These should be
    for information only. By removing `GET` from the hackers’ arsenal, we are forcing
    them into using Javascript exploits on their malicious websites.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that we want to allow this is because the browser has some built-in
    security measures we know about and can use to our advantage. First, from within
    the browser, the Origin header cannot be spoofed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say our bad website had this code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you went to `somebadwebsite.com`, the origin would still be `http://somebadwebsite.com`.
    That is why CORS protection works. By disallowing stateful changes from `GET`
    requests, we make it so that a hack like this will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Forcing the hacker into Javascript—especially Javascript requests that are forced
    into issuing preflight requests—gives us some more control as we are about to
    see.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next helpful solution involves cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Wait? Cookies were in the *do not work* solution category, what gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'We just said that we want to force malicious attackers to use Javascript in
    their exploits. This is because we also know that browser cookies have a feature
    that we can control: `HttpOnly`. When a server creates a cookie, it can decide
    whether or not Javascript should be able to access that cookie. This means that
    the cookie will continue to be sent on every web request when enabled, but it
    will be inaccessible to any Javascript code. This makes it an ideal location for
    storing secure credentials like session tokens. Absent this, cookies are subject
    to what is known as Cross-Site Scripting attacks (aka “XSS”). This is an attack
    where some hacker is able to extract secure details from a frontend browser using
    Javascript.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If your browser application can access some piece of information with Javascript,
    so can a hacker.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We also mentioned that there was a problem that cookies for `yourapplication.com`
    can still be sent unknowingly from `h4ck3rsp4r4d1se.com`. Since Javascript ,when
    it is allowed to access cookie,s can only do so on the current domain, we have
    another tool in our belt we can use while building our solution.
  prefs: []
  type: TYPE_NORMAL
- en: When a user logs in, if we set two cookies (one for the session and one for
    the CSRF protection) we can set the `HttpOnly` value based upon the intended usage.
    The session cookie remains inaccessible, and the cookie that is set aside for
    CSRF protection could be Javascript accessible. We then could require that the
    Javscript uses that cookie’s value when sending in a request. This will work because
    the Javascript that is running on `h4ck3rsp4r4d1se.com` will not be able to access
    cookies that are marked for another domain.
  prefs: []
  type: TYPE_NORMAL
- en: What should the value of this cookie be? Well, really anything that could be
    impossible to guess. It is best to keep that value user specific so that you are
    able to verify its contents and be assured that the token is authentic. Also,
    the value should change and not be static. This will help make it more difficult
    for any would-be attackers. This dual cookie method is not 100% fault-proof. But
    it should be reasonably secure for most applications' needs. The problem comes
    when your users start accidentally downloading malware that is capable of circumventing
    the browser protections. We’ll leave that issue aside as it is an issue outside
    our ability to control, and a much more in-depth conversation beyond the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that we do not necessarily care that the CSRF token could
    be compromised and used by a bad actor. That is fine. Because even if they could
    access it, they have no way to then send with both: the correct origin, and the
    correct session token.'
  prefs: []
  type: TYPE_NORMAL
- en: Form fields
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is another form of CSRF protection that other frameworks use. For example,
    Django made popular the idea of injecting some hidden HTML onto the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This value would then be included in form responses, or read into the request
    in some expected way. This is essentially the exact same idea that I am proposing
    here. The only difference is that instead of injecting the value into a hidden—although
    Javascript accessible location—input, we are storing it in a cookie. Both solutions
    will ultimately depend upon what happens in the next section when that value is
    sent back to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Putting a solution into practice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have a general idea of our approach let’s recap to be clear. We
    want to allow stateful changes in our application to authenticated users only.
    To achieve confidence that the changes are coming from our users and not hackers,
    we will allow the change when:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP method is `POST`, `PATCH`, `PUT`, or `DELETE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The origin of the incoming request matches what we would expect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The incoming request has a cookie that was stored with `HttpOnly`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The incoming request has a valid CSRF token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To accomplish our goal, we need to decide where we will put our code that is
    going to accomplish this goal. We, therefore, come back to the debate we have
    seen a few times already: decorators or middleware. There is not a correct choice,
    and the answer will, of course, depend upon what you are building.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we will build it as a decorator. When we come to authentication
    in the next section, it will become more clear why we are using the decorator
    pattern here. If you think middleware works for you, go ahead and try to rebuild
    this as middleware. Both options are legitimate patterns and may serve your needs
    in different circumstances. To be honest, however, I usually find the decorator
    pattern to be more easily adoptable with a broader set of use cases. Here are
    the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will make a barebones decorator. To make the job easier, you can
    grab a decorator template from the Sanic User Guide: [https://sanicframework.org/en/guide/best-practices/decorators.html#templates](https://sanicframework.org/en/guide/best-practices/decorators.html#templates).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When there is a CSRF failure, the correct response should be a `403 Forbidden`.
    We will make a custom exception that we can raise whenever this happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Thinking about our goals and our requirements, we want to somehow determine
    that the request is coming from a browser. This is because a browser request will
    be subject to CSRF protection. There is no need to implement it on direct access
    API requests. Personally, I like to do this by adding a `HttpOnly` cookie on every
    request if it does not exist. The value is completely irrelevant. The only thing
    we care about is that the value was sent. The same is with the origin header.
    If an `Origin` was sent, we will assume it is a browser request and subject it
    to the stiffer requirements we will impose next. This is, for sure, a belt and
    suspenders approach since they are a bit duplicative. It does still, however,
    give you an idea of the types of strategies you should be thinking about when
    designing your own solutions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**TIP**'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Marking the `browser_check` cookie on every request is overkill. I generally
    recommend doing this on a landing page. Or, in someway catching the case when
    there is an `Origin` and no cookie to set it then. I will leave this to your discretion
    to determine an appropriate place and method to setting this cookie. If you control
    the frontend application, you might even consider setting it there. The point
    of this cookie is just to give us an additional indication that this is not a
    direct access API request.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Looking at our list of requirements again, let’s add some code into the decorated_function
    of our decorator that makes sure that the origin matches. This is necessary because
    as we already know when the request is coming from the browser’s Javascript, this
    value cannot be spoofed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next requirement that we have is to make sure an `HttpOnly` token is present.
    For now, we will just use our `browser_check` cookie. This could also be satisfied
    with a session cookie if you have one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we need to verify our CSRF token. I know we have not discussed what
    that is, how to generate it, so of course we have not gotten to the verification
    bit yet. We will get there momentarily. Until then, let’s simply add a function
    to round out our decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now finally turn to CSRF tokens. For our implementation we are going to
    use a Fernet token. This is a method of encrypting some bit of text with a secret
    key so that it cannot be changed or read without that key. We are going to set
    this token in a cookie that will explicitly *not* be `HttpOnly`. We want the frontend
    Javascript application to read this value and send it back in the application
    via the headers. When the potentially harmful state-changing request comes in,
    we will verify that the header and the cookie match. We also will extract the
    payload of the Fernet token and validate its contents. The actual value of that
    token we will store in a second cookie that will be `HttpOnly`. The purpose of
    this dual cookie, and dual submit verification is to protect our applications
    from various types of attacks that might otherwise compromise our strategy. The
    solution might sound much more complicated than it actually is, so let’s look
    at some code to start piecing this together:'
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by setting up some configuration values that we will need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: It should come as no surprise that you should never, *never*, *NEVER* hard code
    a secret like this in your applications. This is for example purposes only. Instead,
    you should be injecting secret values via environment variables or some other
    more secure method than this.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We need a function that will generate our CSRF reference value and token. To
    accomplish this, we will use the cryptography library mentioned at the beginning
    of this chapter. It is battle tested and reliable. It should be the obvious first
    place to turn for all cryptographic needs in Python. Here’s the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, this is fairly simple. We create the cipher object using our
    secret. Then, as per the recommendation from the cryptography library, we use
    the operating system’s random generator logic with `os.urandom` to make our reference
    value, and some extra fluff. The reference is encrypted, and our token is then
    padded and returned along with the reference value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Creating the reverse for verifying our token is a matter of performing these
    steps in reverse, and then comparing the encrypted value to the passed referenced
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need a way to make sure these values exist as cookies. Therefore, we
    will generate them in middleware for this example. However, it might be logical
    to instead perform this function on a login endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember, the plan is for the `csrf_token` to be Javascript accessible. We
    want the incoming request to not only include this in a cookie value but also
    have this value injected in the HTTP headers. This can only be done by Javascript
    running on our applications because of the same-origin policy. CORS to the rescue.
    This means, do not forget to whitelabel our request header that we will see next:
    `X-XSRF-Token`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remember back in our `@csrf_protected` decorator, one of the checks was `csrf_check(request)`.
    We will finally now uncover what that function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be three values that we care about: the two cookies we just set,
    and the incoming `X-XSRF-Token` header. This header as we know will be generated
    on the client-side by extracting the cookie and injecting the value in the header.
    It should now be simply a matter of verifying that:'
  prefs: []
  type: TYPE_NORMAL
- en: The cookie and the header match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The protected `HttpOnly` reference value is the same as the encrypted value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If that all checks out, we can be confident that the request is genuine.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You may be wondering why I chose XSRF here instead of `X-CSRF-Token`, or even
    just `CSRF-Token` for the header name. The reason is that there are some frontend
    frameworks that automatically add this header injection for you client side. Since
    it is not important from our perspective what the header is called, we might as
    well play nice with some other tooling that likes it named this way.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Samesite cookies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be familiar with a newer concept in CSRF protection known as **samesite**
    cookies. This is a value that can be appended to the cookie that provides extra
    directions to the browser about how to treat that cookie. In short, by setting
    this value on the cookies on the server, we allow the application to dictate to
    the browser when it is and is not acceptable to send the cookie. This alone *nearly*
    mitigates the issues with CSRF, but it should *NOT* be used by itself as the solution.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the **Open Web Application Security Project (OWASP)**—a nonprofit foundation
    that promotes the enhancement of security practices online—specifically states
    that the samesite attribute “*should not replace having a CSRF Token. Instead,
    it should co-exist with that token in order to protect the user in a more robust
    way.*” [https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute)
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now learn about samesite cookie protection, and how to integrate it
    into our solution. There are three allowed values: `None`, `Lax`, and `Strict`'
  prefs: []
  type: TYPE_NORMAL
- en: Samesite=None
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Cookies that use `Samesite=None` should be considered only for non-security
    related cookies. This is because they will be sent with every request, no matter
    what site they are originating from. Therefore, if you are on the hacker’s website,
    that hacker will be able to submit requests on your behalf to other sites that
    you have visited and making use of the cookies you have on your computer. Not
    cool.
  prefs: []
  type: TYPE_NORMAL
- en: But, for the right kind of cookies, this is not really an issue. As long as
    the value has nothing to do with security or sessions, this is acceptable. It
    should be also noted, however, that for this to work it will also only be allowed
    when the cookie is marked Secure. That is to say that it is only allowed to be
    passed across `https` requests. In your production level code, you should be doing
    this regardless. You are using TLS encryption right? If not, we will see super
    simple solution to this in Chapters 8 and 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting `Samesite=None` is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Samesite=Lax
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the default in most modern web browsers now. You should not, however,
    rely upon that fact, and it is certainly still best practice to do so explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: What does this value mean? It means that the cross-site `POST` requests we have
    been worried about will not include the cookies (which is a big part of CSRF protection).
    However, it will allow them in some contexts. To be sent in a cross-site request,
    the request must be a top-level navigation (think of this as the address bar in
    the browser), and the HTTP method must be `GET` or `HEAD`.
  prefs: []
  type: TYPE_NORMAL
- en: This basically boils down to protection from AJAX requests, but allowing the
    cookie to be sent when someone navigates to the site from a third-party link.
    This actually makes a lot of sense and is probably what you want to use for a
    lot of your cookies.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your session cookies were *not* set to Lax (and instead were
    `Strict`) when someone clicked a link from another website that brought them to
    your site, they would not appear as logged in. However, once they started clicking
    around, suddenly their session would appear. This might be an awkward experience
    for the user. Therefore, it is suggested that session management and authentication
    cookies should be `Lax` for most typical applications. If you are building a secured
    banking application, you probably have no use for someone to link to a secured
    banking page, and maybe `Lax` is not the right answer. However, it is generally
    acceptable to use Lax for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, you do not need to explicitly state the samesite attribute anymore,
    but explicit is better than implicit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a cookie that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Samesite=Strict
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As alluded to in the last section, a `Strict` cookie will only be sent when
    the request originated from the correct site. This means that the user must first
    be on your application, and *then* submit the request. In my opinion, this really
    sounds like the type of request that would be performed that is state-changing.
    Do you see where I am headed with this?
  prefs: []
  type: TYPE_NORMAL
- en: 'In my opinion (and you will undoubtedly come across different opinions), CSRF
    protection cookies should be `Samesite=Strict`. There is no legitimate use case
    (at least not in my applications) where I can think that I would not want my user
    to be on my application first before initiating the types of requests that I am
    trying to protect. You may have different needs, and this might not work for you.
    If `Lax` makes sense, then go with it. I’ll stick to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can probably guess, our cookies now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As mentioned, support for samesite cookies is not universal. You should check
    a website like CanIUse to see if any browsers you are targetting do not implement
    it: [https://caniuse.com/same-site-cookie-attribute](https://caniuse.com/same-site-cookie-attribute).
    Also, a “same” site in this context does include subdomains. There is a public
    list of addresses that are considered “top-level” for this context, which does
    not completely line up with .com, .org, io, etc. For example, two websites on
    github.io are not considered samesite. For the full list, check it out here: [https://publicsuffix.org](https://publicsuffix.org).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In our review of CSRF, there was a lot of mention of session tokens and authentication,
    but we have not looked at that yet. While this is an incredibly deep topic by
    itself, we will explore how you can implement authentication on your applications
    using Sanic.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting your Sanic app with authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When many people think about a web application, what comes to mind is some
    type of a platform on the web where they login to do… *something*. The activity
    is not what we care about here. When you are done reading this book, you are going
    to go off and build some amazing applications. What we care about is the journey
    and the process. And, the part of the process that we care about right now is:
    login.'
  prefs: []
  type: TYPE_NORMAL
- en: To be more specific and correct, what we are about to look is **authentication**
    and not so much about **authorization**. While these two ideas are very closely
    related, they are not the same and are not interchangeable. In fact, authorization
    usually presumes that authentication already happened.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the difference?
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: answers the question: who are you?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: answers the question: what are you allowed to do?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To confuse matters even more, a failure of **authentication** is a `401 Unauthorized`
    response. This is super unfortunate naming from the early days of the Internet.
    A failure of **authorization** is a `403 Forbidden` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2020, I spoke at EuroPython about access control issues. The slides and
    a link to the YouTube presentation are on my GitHub page: [https://github.com/ahopkins/europython2020-overcoming-access-control](https://github.com/ahopkins/europython2020-overcoming-access-control).
    If you have about 30 minutes to watch a riveting presentation about this thrilling
    topic, its “don’t miss” opportunity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The presentation covers this authentication/authorization topic, but also largely
    tries to answer the question: “what are the different methods for protecting my
    API?” It answers this by comparing session-based authentication with non-session
    based (aka stateless). We will review both of these strategies here, but also
    include how to implement API keys (which is not covered in that presentation).'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, there is a set of questions that need to be answered. Before we
    dive into how to implement some of the common strategies with Sanic, we will review
    some of the questions that you should ask yourself before deciding upon a strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Who will consume the API?You should think about whether the API is going to
    be used by other applications or scripts, or by actual people. Will it be used
    by programmers who are integrating it into their applications? Or, will it be
    used to power a mobile application? Does a frontend Javascript application need
    to access it?The reason you should care is you must have an understanding of the
    technical abilities, but also the weaknesses of your intended use case. If your
    API will only ever be consumed by other backend scripts and applications, then
    you will have an easier time securing it. Most of that stuff we talked about cookies
    is highly irrelevant; and CORS is a non-issue.On the other hand, if you intend
    to power a browser-based single page application, then you likely need a more
    robust authentication strategy than simple API keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you have control over the client?The core of this question is whether you
    (or your organization) will be the consumer of the API. Contrast this with an
    API that is meant to be consumed by integrations and other applications, and you
    should see that this can have a difference on how you control access. For example,
    if you are building a microservice that is not exposed to the Internet, but only
    exists within a highly controlled network, you obviously have a different set
    of security concerns than the API that powers your bank’s website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Will this power a web browser frontend application?This is a bit of a subset
    of the first question, but it is important enough to think about on its own. The
    reason that this is so much of an issue is that the browser is flawed. When the
    Internet was first created and web browsers were first being released, no one
    could quite predict the direction and level of importance that would become of
    the Internet. The security concerns—and the solutions to mitigate them—were born
    out of years of hackers attempting to exploit a system that was never really designed
    with a security first mindset.For example, the fact that non-encrypted `http://`
    websites even exist in today’s world is really mind-boggling. This Chapter devoted
    a lot of energy so far to how to deal with certain security concerns that only
    exist because the web browser is broken. Therefore, knowing that there is even
    a possibility of frontend usage for your application should trigger warning bells
    early on that you **must** dedicate time and attention to this topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With those three questions in our mind, we will now look at three potential
    schemes for authenticating users. But first, another reminder that just because
    I do something some way here does not mean you should as well. Use your skills
    to take what is provided to build the solutions you need for your application.
    We are talking security, so maybe you should be careful before you stray too far.
    If you ever have a question about whether a strategy, feel free to bring the question
    to the community on Discord or in the Forums.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore *some* of the strategies you may find.
  prefs: []
  type: TYPE_NORMAL
- en: Using API Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By far, API keys are the simplest authentication scheme. They are easy to set
    up and easy for the end-user to implement. It also means that they offer lesser
    security. That does not mean they should be overlooked. In the right context,
    API keys can be the exact right tool to get the job done, provided you take measures
    to mitigate any security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'API keys go by many names, but they boil down to a simple concept: your application
    provides a secure persistent token. When the request is accompanied by that token,
    it works. If not, it fails. It is as simple as that. One of the main benefits—besides
    simplicity—is that the keys are easy to invalidate. Since you are storing the
    keys *somewhere*, all you need to do is change the stored value or remove it and
    that key will no longer work.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason that API keys are more susceptible to attacks is that they are a
    single, persistent value. This means that it is in theory easier for the value
    to be brute force attacked. A hacker could set up a machine and try every single
    combination until one worked. Therefore, the first step in making sure that your
    API scheme is secure is to **use strong keys**. This means a high amount of entropy.
  prefs: []
  type: TYPE_NORMAL
- en: Once a sufficiently complex API key has been generated, it should be hashed
    before storing. **Do not encrypt** your keys. What is the difference between hashing
    and encrypting? When you “encrypt” data, it can be reversed. Like we saw with
    Fernet encryption, we were able to reverse the process and decrypt the original
    value. This is a no-no for API keys. Hashing, on the other hand, is a one-way
    street. Once it is hashed, there is no way to recover the original value. Therefore,
    to validate a value against it, you need to hash the incoming value using the
    same strategy, and compare the result to the stored hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might sound to you like password management, right? That is because you
    should basically treat an API key exactly as you would a password. This brings
    up the second potential security pitfall when using API keys: storage. **Never**
    store it in plain text, **never** store it in a format where the original value
    can be retrieved, and **never** store it so that the hashed value can easily be
    predicted.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the value of a newly generated key, you will add a “salt” before
    storing it. A password salt is a random bit of text that is added to a password
    so that when the password is hashed, it is done so in an unpredictable format.
    If you do not salt the password, then the hashed value can be cracked by comparing
    to known hashes for common passwords. Hackers keep databases of the hashed values
    of common passwords for this reason. Even though they might not be able to decrypt
    a hashed value, if you fail to salt it, then it is super simple for them to backwards
    engineer the value by simply looking at known values. Luckily, the `bcrypt` module
    makes this easy. Let’s dive into some code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by creating a function to generate an API key. To do this, we
    will use the `secrets` module that comes from the Python standard library. In
    our example, we will use `secrets.token_urlsafe` to generate the value. You also
    could use `secrets.token_hex`, but it will produce a slightly longer string to
    represent the same value. The reason I suggest using this library with its default
    settings is that the maintainers of Python will change the amount of entropy needed
    based upon current best practices. As of the time of this writing, the default
    is 32 bytes. If you feel more is required, feel free to increase that value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We also used the `bcrypt` module for generating a salt. What this does is adds
    random text, creates a hash, and then repeats the cycle several times. By folding
    the hashed value with multiple rounds of salting, it becomes more difficult to
    compare against a known value (it also becomes computationally more expensive,
    so setting the value too high might be super-time consuming). We will use `gensalt`
    with the default value of 12 rounds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will need some endpoint that generates and stores these values. A typical
    implementation will have a frontend UI where the user clicks a button to generate
    the API key. The value is returned on screen just long enough for them to copy
    it. Once they navigate away, that value is gone and cannot be recovered. In the
    backend, this means that we need an endpoint that uses the `generate_token`, sends
    the API key to the user, and stores the hashed key in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As a reminder, you can look back to *Chapter 4* for strategies on how to extract
    data from the request to get the user, for example. In the above, `get_user_from_request`
    is a stand-in to show that you would be pulling the user information based upon
    the incoming request. Similarly, since we have not looked at how to interact with
    databases yet, `store_hashed_key` is just a stand-in to show that you would need
    to use the user and the hashed key to *somehow* store the value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will create a new decorator to protect endpoints with our API key. In this
    decorator, we will extract the user from the request, and compare the hashed key
    to whatever the user has sent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One thing that is helpful to point out here is that Sanic will extract a token
    from the `Authorization` header for us. It is a very common scheme to send tokens
    in headers as so-called **bearer tokens**. They look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Therefore, to get access to that token valued, all you need to use is `request.token`
    and Sanic will find it from either location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to implement this, all we need to do is wrap our endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another thing to point out is the inherent security leak in failing to use the
    correct status codes and exception messages when something goes wrong. We mentioned
    this back in *Chapter 6*, and it is worth seeing how to address the concern here.
    You may have noticed that we are allowing our decorator to pass in an Exception
    class and message. This is so that we have control over what information is sent
    to the end-user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen how easy it is to implement *proper* API keys, the only
    remaining question is: when is it appropriate to use them?'
  prefs: []
  type: TYPE_NORMAL
- en: '*Never use an API key to secure a browser-based UI*.'
  prefs: []
  type: TYPE_NORMAL
- en: The security afforded by the API key is not sufficient to handle all of the
    issues that the browser raises by virtue of storage of credentials. This is really
    only appropriate for integrations coming from outside scripts or applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of that reason, I like to use `check_request` middleware we created
    earlier in this Chapter in conjunction with my authorization decorator. Since
    `@api_key_required` should never be valid for a request from the browser, I like
    to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how and when to use API keys, let’s look at approaches to handling
    authentication in a scenario that is appropriate for web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding session versus non-session based authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: User sessions are perhaps the most common approach to handling authentication
    in web applications. A more recent strategy employs tokens known as **JSON Web
    Tokens (JWT)**. In most other contexts, you will hear about these referred to
    as *stateful* versus *stateless*. User sessions are *stateful* and JWTs are *stateless*.
    This is all true, but I like to refer to them as **session based** and **non-session
    based**. Call me a rebel, but I think that this more clearly describes what we
    are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: First, what is a session? If a user logs into your application, and you record
    that login in your database so that it can be invalidated at will, then you are
    creating a session. This means that so long as that record exists in your database,
    there is an active session that can be authenticated against that particular user.
  prefs: []
  type: TYPE_NORMAL
- en: Session-based authentication is very simple to implement on both the frontend
    and the backend. And, because it offers a high degree of security, it is the reason
    that it has become a default approach for many web applications. One of its huge
    benefits is that any active session can be inactivated at any time. Have you ever
    been on a web application (perhaps your email provider) that lists out everywhere
    you are logged in? With a click of a button, you can log out the other locations.
    This is really helpful in case a session is compromised or hacked.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, non-session based authentication provides a great deal more
    flexibility. The typical example of a non-session based token is a JWT. So even
    though I am talking specifically about JWTs, they are not the only way to handle
    non-session based authentication. The most critical component that is offered
    by this strategy is that the token itself is self-authentication. That means that
    a server only needs to look at the token to determine if it is genuine, and if
    it has been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, authenticating a JWT becomes highly portable. You can have
    one microservice that handles authentication and generating tokens, and then other
    services can verify them without having to involve the authentication service
    at all! This allows for very scalable architectures. This also highlights another
    benefit. Every time a session token is received, in order to authenticate it you
    *must* make a round-trip to your storage engine. This means every single API call
    includes at least one more network call to the database. This is completely avoided
    with self-authenticating tokens, and can lead to overall performance benefits.
  prefs: []
  type: TYPE_NORMAL
- en: JWTs specifically also carry the benefit that they can be embedded with non-secret
    payloads. This often means that you can include a list of permissions, or meta
    information about a user that the frontend application can make use of.
  prefs: []
  type: TYPE_NORMAL
- en: That all sounds great, but the downside to JWTs is that once issued they cannot
    be invalidated. When they are created, they are given an expiration time. The
    token will remain valid until that time expires. This is the reason why these
    expiration times are usually quite short, and usually measured in minutes (not
    hours or days as may be typical of sessions). If a token expires every ten (10)
    minutes, it would be super inconvenient for a web application user to need to
    login again so frequently. Therefore, JWTs are often accompanied by a refresh
    token. This token is a value that allows a user to exchange an expired JWT for
    a fresh new one.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, session-based tokens are generally easier to protect from XSS attacks
    using the `HttpOnly` cookies as we saw earlier. Since JWTs are usually sent as
    a bearer token like API keys, implementing them also means revisiting how we are
    going to protect them inside the browser. If your head is starting to spin thinking
    about all of the concerns that exist with trying to implement JWTs as both a secure
    and user-friendly approach, then you are not alone. Adding JWTs to an application
    is certainly much more involved than sessions. Therefore, you must think about
    your specific application needs when deciding which strategy to use.
  prefs: []
  type: TYPE_NORMAL
- en: “*Hold up!*” You might be saying to yourself. “*If JWTs have so many benefits,
    why not just treat them like session tokens and store them as cookies? Also, we
    can get around invalidating tokens by comparing them against a black list! Then,
    we can make them longer and just add them to the blacklist when we want to logout
    or invalidate them. Both problems solved.*”
  prefs: []
  type: TYPE_NORMAL
- en: Yes, that is true. Let’s look at both of those proposals in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, storing JWTs as a cookie like a session token does work. But, you now
    lose out on one of its big benefits: the authenticated payload. Remember that
    one of its benefits is that they can carry meta details that your frontend application
    could use. If they are stuck inside of an `HttpOnly` cookie, then that information
    is not available. (We will look at a way to address this when we look at JWT implementations).'
  prefs: []
  type: TYPE_NORMAL
- en: Second, if you are maintaining a blacklist of tokens to allow a token to be
    *revoked* or *invalidated*, then you no longer are using non-session based authentication.
    Instead, you are using JWTs in a session based scheme. This is acceptable and
    people do it. However, it makes your tokens less portable since they require a
    centralized store to be validated, and also include additional network calls.
    Implement at your own risk.
  prefs: []
  type: TYPE_NORMAL
- en: We now turn to implementation strategies within Sanic. Because we have not looked
    at database implementation, we will still use some stand-in functions for getting
    and storing information when needed. Try to look over those details for now since
    we are focusing more upon how to handle authentication not persisting data. If
    you look on the GitHub repository at these examples, there will be some dummy
    versions of these functions just to make the examples operational. Try not to
    get hung up on those details right now.
  prefs: []
  type: TYPE_NORMAL
- en: Using sessions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have decided after reading the *Session v. non-session based authentication*
    section that stateful sessions are the right options for your application. Super,
    you really already know just about everything you need.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen how to handle passwords (the same as API keys). Therefore,
    implementing a login route should be simple.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that the session token needs to *not* be accessible from Javascript
    to combat XSS. Therefore, we will use `HttpOnly` cookies.
  prefs: []
  type: TYPE_NORMAL
- en: We also know that using an `HttpOnly` cookie by itself leaves an application
    vulnerable to CSRF attacks. Therefore, we will couple our implementation with
    the CSRF protection scheme we came up with earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s left? Not much. We need endpoints for:'
  prefs: []
  type: TYPE_NORMAL
- en: registering a use (which will be responsible for storing the password securely);
  prefs: []
  type: TYPE_NORMAL
- en: logging in (which takes a username and password and verifies it, just like in
    the API key example, creates a session key, stores it, and sets it as a cookie);
    and
  prefs: []
  type: TYPE_NORMAL
- en: logging out (which deletes the session from the database).
  prefs: []
  type: TYPE_NORMAL
- en: This is a great opportunity for you to take these requirements and try and build
    your own solution. Put the book down and build these three endpoints. If you get
    stuck, there is an example solution in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: In order to protect your endpoints, we will have a similar approach with a decorator.
    Do you remember the `@csrf_protected` decorator we built earlier? If you are using
    session-based authentication, then I suggest combining that decorator with the
    one we are building here. They compliment each other nicely and then it makes
    it easier for you to properly protect your endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we will rebuild it. We are adding a similar block to our decorator
    like the API key decorator that will raise an exception if session verification
    fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The verification of the session does depend upon your database implementation.
    But, in general, it should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the session token exists, then we can proceed. If it does not, then return
    False.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, sessions tend to be easy to implement once you have the basic
    functionality for storing and retrieving data from a database. We now turn to
    the more complicated alternative.
  prefs: []
  type: TYPE_NORMAL
- en: JWT (JSON Web Token)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, you have read the section on *Session v. non-session based authentication*
    and decided to implement JWTs. Now what? The problem that we need to solve is
    that to use them to their full capacity within a frontend application poses two
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: How to store and send them to not compromise on functionality or security?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to maintain a reasonable user experience without sacrificing security?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will address these questions in turn, and then develop a solution that gives
    us satisfaction on both.
  prefs: []
  type: TYPE_NORMAL
- en: To cookie, or not to cookie?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two competing interests when deciding how to send the access token
    (please note that from here on out access token is synonymous with JWT): usability
    and security. If we send the token via the headers, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To accomplish this, we need some client-side Javascript to read the value and
    inject it into our request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You should (by now) already be suspecting the problem with this: XSS vulnerability!
    If our frontend application can access the token from Javascript, then that means
    that any bad script can as well. Bummer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You may be thinking to yourself, why is the JWT being stored client-side in
    a cookie and not in web storage (either localStorage or sessionStorage)? The reason
    is that both of those solutions are great for handling non-sensitive details.
    They are subject to the XSS attacks we are trying to prevent. You may see a lot
    of advice online suggesting that you use these for JWTs. *Don’t do it!* The solution
    that is offered here will be much more secure and still not sacrifice on usability.
    All it takes is a little extra work server-side, so please be patient and do not
    rush off to this sub-standard alternative.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To fix the problem we use `HttpOnly` and let our application just send the cookie
    back by itself. In this situation we will rely on the server to write and read
    the cookie as needed. But, in doing this, we cannot access the JWT payload. There
    also is the problem of CSRF that we have seen a few times already, but by now
    you should already understand how to solve that problem. If not, please go back
    to read the section *Protecting applications from CSRF* in this Chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option might be to return the payload of the access token when you first
    login. These details you could store in web storage safely and use them whenever
    you want. That might look something like this on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: I support this approach, and it certainly will work. You gain access to the
    payload, and you have a secure way to transport and store the access token.
  prefs: []
  type: TYPE_NORMAL
- en: A second option would be to use split cookies. More on that in just a bit. Feel
    free to skip ahead, or go back and reference that EuroPython talk I mentioned
    at the beginning of the Chapter where I discussed this approach.
  prefs: []
  type: TYPE_NORMAL
- en: “Your session expired after 10 minutes, please login again?”
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Have you ever been on a website that does this? Usually, it is banking or financial
    applications because they are concerned about a user standing up from their computer
    and walking away to leave a logged in session. Maybe this is your need, so great!
    You can rest comfortably with JWTs as a solution and expire your tokens often
    with no concern.
  prefs: []
  type: TYPE_NORMAL
- en: For most applications, however, this would lead to a terrible user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the reason we are expiring our access tokens at such a short interval
    is to reduce the potential attack surface. If a token were to fall into the wrong
    hands, it can only be used for a very small window. The shorter the expiration,
    the more secure the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to the problem requires a little bit of frontend complexity. But,
    I think it is worth the protection it affords. There are actually two solutions
    that you can choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Javascript’s `setInterval` to periodically send a request to refresh the
    token in the background unknown to the user
  prefs: []
  type: TYPE_NORMAL
- en: Wrap your Javascript fetch call with a proper exception handler. It catches
    the scenario where an expired token was submitted, sends a request to refresh
    the token, and then retries the original request with the new token
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to choose the approach that works for you. The GitHub repository has
    some sample Javascript for implementing each strategy.
  prefs: []
  type: TYPE_NORMAL
- en: To implement a refresh token, we will borrow some of the concepts we used earlier
    for making the API token. When a user performs a login, we will continue to generate
    the access token, but we will also generate and store a refresh token by reusing
    the API token logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a login endpoint that also generates and stores a refresh token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go back to the *Using API Keys* section to see the `generate_token` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To issue a new access token, we need to create a new endpoint that will validate
    the refresh token (like we did the API token). As an added level of security (since
    a single point of authentication from the browser is not a good idea), we also
    will require a previously issued access token even if it is already expired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have not seen how to validate JWT yet, so do not worry that you are not sure
    how to implement `check_access_token`. We will do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Solving for JWTs in browser-based applications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By now we generally have an understanding of what we want to achieve. What
    we need to look at now is:'
  prefs: []
  type: TYPE_NORMAL
- en: How to generate the access token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to verify the access token (both with and without expiration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to “split” the token to make it usable and secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To generate the token, we will use `pyjwt`. The first thing we will need to
    do is create an application with secret. Just like before, I will hardcode it
    in my example, but you will get the value from an environment variable or other
    secure method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the secret and some other configuration values that we will need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a model that will hold our JWT details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate the token with some payload. In JWT-speak, a payload is essentially
    just a dictionary of values. It can contain a “claim” which is a special key-value
    pair that can be used in authenticating a token. If you get into JWT, I suggest
    you dig deeper into some of the standard claims. In our example, the only one
    we are using is the expiration claim: `exp`. Other than that, feel free to add
    whatever you want to the payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have generated the `AccessToken` object, it will be super easy to
    split it up into two cookies. One of them will be Javascript accessible, and one
    of them will be `HttpOnly`. We also want the refresh token to be `HttpOnly`. Your
    login handler would have something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then set all of our cookies with a convenience function. Pay careful attention
    to the how these cookies are set with respect to `httponly` and `samesite`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have all the building blocks needed to build out our endpoints and our
    decorator. It is time for you to put your skills to the test and try and piece
    together the endpoints from the knowledge in this chapter. Don’t worry, there
    is a full solution in the GitHub repository, including the `set_cookie` convenience
    function used above.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit of self-promotion here: one of the first libraries I built for Sanic
    was a package to handle authentication and authorization for Sanic using JWTs.
    It allows for handling this split token approach and includes all other sorts
    of goodies and protections. If you do not want to roll your own solution, it has
    become widely adopted within the community. Check out my personal GitHub page
    for more details: [https://github.com/ahopkins/sanic-jwt](https://github.com/ahopkins/sanic-jwt).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This Chapter has covered a *lot* of material. Even still, it has only scratched
    the surface of Web security. To truly raise the security bar, you should continue
    to do some of your own research. There are some other common headers like: `Content-Security-Policy`,
    `X-Content-Type-Options`, and `X-Frame-Options` that we did not have a chance
    to cover. Nonetheless, with the information you have gathered here, and with your
    own self-ingenuity, you should be able to implement—for example—a `Content-Security-Policy`
    that works for your application. The first place I look for this kind of material
    is Mozilla’s MDN website: [https://developer.mozilla.org/en-US/.](https://developer.mozilla.org/en-US/.)
    I highly recommend you visit it to learn about web standards and practices.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we cover?
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be familiar with the concept of same-origin, and how to develop
    a CORS policy to defeat both CSRF and XSS attacks. We also looked at three common
    schemes for authenticating users: API keys, session tokens, and JWT. And, of course,
    by looking through all of the examples you should be learning how to use the Sanic
    tool belt to craft your own unique and *obvious* patterns to serve your applications’
    needs. At this point in the book, we really have covered most of what you will
    need in order to build a web application. You should be familiar with all of the
    basic building blocks, and start to have some ideas on how to piece them together
    to build solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: What we are missing now is knowledge on how to deploy our applications and run
    them. This is what we will cover next.
  prefs: []
  type: TYPE_NORMAL
