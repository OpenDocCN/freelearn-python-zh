<html><head></head><body>
<section data-number="0.8" id="chapter-5-built-in-data-structures-part-2-dictionaries">
<h2 class="likechapterhead" data-number="0.8"><span><span class="kobospan" id="kobo.1.1">5</span></span><br class="tipbox1"/> <span id="x1-2890005"/><span class="kobospan" id="kobo.2.1">Built-In Data Structures Part 2: Dictionaries</span></h2>
<p class="normal"><span class="kobospan" id="kobo.3.1">Starting with </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.4.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.5.1"> </span></span><a href="ch008_split_000.xhtml#x1-2240004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.6.1">4</span></span></a><span class="cmti-10x-x"><span class="kobospan" id="kobo.7.1">, </span></span><a href="ch008_split_000.xhtml#x1-2240004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.8.1">Built-In Data Structures Part 1: Lists and Sets</span></span></a><span class="kobospan" id="kobo.9.1">, we began looking at Python’s rich collection of built-in data structures. </span><span class="kobospan" id="kobo.9.2">These data</span><span id="dx1-289001"/><span class="kobospan" id="kobo.10.1"> structures are sometimes</span><span id="dx1-289002"/><span class="kobospan" id="kobo.11.1"> called ”containers” or ”collections” because they contain a collection of individual items.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.12.1">In this chapter, we’ll cover the dictionary structure. </span><span class="kobospan" id="kobo.12.2">A dictionary is a mapping</span><span id="dx1-289003"/><span class="kobospan" id="kobo.13.1"> from keys to values, sometimes called an associative array. </span><span class="kobospan" id="kobo.13.2">It seems sensible to separate mappings from the two sequences – lists and sets.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.14.1">This chapter will also look at some more advanced topics related to how Python handles references to mutable collection objects. </span><span class="kobospan" id="kobo.14.2">This has consequences in the way functions need to be defined.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.15.1">In this chapter, we’ll look at the following recipes, all related to Python’s built-in data structures:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><a href="ch009.xhtml#x1-2900001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.16.1">Creating dictionaries – inserting and updating</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch009.xhtml#x1-2980002" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.17.1">Shrinking dictionaries – the pop() method and the del statement</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch009.xhtml#x1-3040003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.18.1">Writing dictionary-related type hints</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch009.xhtml#x1-3100004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.19.1">Understanding variables, references, and assignment</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch009.xhtml#x1-3160005" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.20.1">Making shallow and deep copies of objects</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch009.xhtml#x1-3210006" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.21.1">Avoiding mutable default values for function parameters</span></span></a></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.22.1">We’ll start with how to create a dictionary. </span><span id="x1-289004r560"/></p>
<section data-number="0.8.1" id="creating-dictionaries-inserting-and-updating">
<h1 class="unnumbered" data-number="0.8.1"><span><span class="kobospan" id="kobo.23.1">5.1 </span></span> <span id="x1-2900001"/><span class="kobospan" id="kobo.24.1">Creating dictionaries – inserting and updating</span></h1>
<p class="normal"><span class="kobospan" id="kobo.25.1">A dictionary is one kind of Python</span><span id="dx1-290001"/><span class="kobospan" id="kobo.26.1"> mapping. </span><span class="kobospan" id="kobo.26.2">The built-in type </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.27.1">dict</span></span></span></span><span class="kobospan" id="kobo.28.1"> provides a number of foundational features. </span><span class="kobospan" id="kobo.28.2">There are some common variations on these features defined in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.29.1">collections</span></span></span></span><span class="kobospan" id="kobo.30.1"> module.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.31.1">As we noted in the </span><a href="ch008_split_000.xhtml#x1-2250001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.32.1">Choosing a data structure</span></span></a><span class="kobospan" id="kobo.33.1"> recipe at the beginning of </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.34.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.35.1"> </span></span><a href="ch008_split_000.xhtml#x1-2240004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.36.1">4</span></span></a><span class="kobospan" id="kobo.37.1">, we’ll use a dictionary when we have a key that we need to map the key to a given value. </span><span class="kobospan" id="kobo.37.2">For example, we might want to map a single word to a long, complex definition of the word, or perhaps map some value to a count of the number of times that value has occurred in a dataset. </span><span id="x1-290002r558"/></p>
<section data-number="0.8.1.1" id="getting-ready-39">
<h2 class="likechapterhead" data-number="0.8.1.1"><span><span class="kobospan" id="kobo.38.1">5.1.1 </span></span> <span id="x1-2910001"/><span class="kobospan" id="kobo.39.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.40.1">We’ll look at an algorithm for locating the various stages in transaction processing. </span><span class="kobospan" id="kobo.40.2">This relies on assigning a unique ID to each request and including that ID with each log record written during the transaction. </span><span class="kobospan" id="kobo.40.3">Because a multi-threaded server may be handling a number of requests concurrently, the stages for each request’s transaction will be interleaved unpredictably. </span><span class="kobospan" id="kobo.40.4">Reorganizing the log by request ID helps isolate each transaction.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.41.1">Here’s a simulated sequence of log entries for three concurrent requests:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.42.1">[2019/11/12:08:09:10,123] INFO #PJQXB^{}eRwnEGG?2%32U path="/openapi.yaml" method=GET 
 
[2019/11/12:08:09:10,234] INFO 9DiC!B^{}nXxnEGG?2%32U path="/items?limit=x" method=GET 
 
[2019/11/12:08:09:10,235] INFO 9DiC!B^{}nXxnEGG?2%32U error="invalid query" 
 
[2019/11/12:08:09:10,345] INFO #PJQXB^{}eRwnEGG?2%32U status="200" bytes="11234" 
 
[2019/11/12:08:09:10,456] INFO 9DiC!B^{}nXxnEGG?2%32U status="404" bytes="987" 
 
[2019/11/12:08:09:10,567] INFO &gt;~UL&gt;~PB_R&gt;&amp;nEGG?2%32U path="/category/42" method=GET</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.43.1">The lines are long, and may be wrapped haphazardly to fit within the book’s margins. </span><span class="kobospan" id="kobo.43.2">Each line has a timestamp. </span><span class="kobospan" id="kobo.43.3">The severity level is </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.44.1">INFO</span></span></span></span><span class="kobospan" id="kobo.45.1"> for each record shown in the example. </span><span class="kobospan" id="kobo.45.2">The next string of 20 characters is a transaction ID. </span><span class="kobospan" id="kobo.45.3">This is followed by log information for unique to a step in the transaction.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.46.1">The following regular expression defines the log records:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.47.1">import re 
 
log_parser = re.compile(r"\[(.*?)\] (\w+) (\S+) (.*)")</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.48.1">This pattern captures the four fields</span><span id="dx1-291011"/><span class="kobospan" id="kobo.49.1"> of each log entry. </span><span class="kobospan" id="kobo.49.2">For more information on regular expression, see the </span><a href="ch005_split_000.xhtml#x1-350003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.50.1">String parsing with regular expressions</span></span></a><span class="kobospan" id="kobo.51.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.52.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.53.1"> </span></span><a href="ch005_split_000.xhtml#x1-170001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.54.1">1</span></span></a><span class="kobospan" id="kobo.55.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.56.1">Parsing these lines will produce a sequence of four-tuples. </span><span class="kobospan" id="kobo.56.2">The resulting object looks like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.57.1">[(’2019/11/12:08:09:10,123’, 
 
  ’INFO’, 
 
  ’#PJQXB^{}eRwnEGG?2%32U’, 
 
  ’path="/openapi.yaml" method=GET’), 
 
 (’2019/11/12:08:09:10,234’, 
 
  ’INFO’, 
 
  ’9DiC!B^{}nXxnEGG?2%32U’, 
 
  ’path="/items?limit=x" method=GET’),</span></code></pre>
<pre class="programlisting" id="listing-32"><code class="calibre13"><span class="kobospan" id="kobo.58.1">... </span><span class="kobospan" id="kobo.58.2">details omitted ...</span></code></pre>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.59.1">
 
 
 (’2019/11/12:08:09:10,567’, 
 
  ’INFO’, 
 
  ’&gt;~UL&gt;~PB_R&gt;&amp;nEGG?2%32U’, 
 
  ’path="/category/42" method=GET’)]</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.60.1">We need to know how often each unique path is requested. </span><span class="kobospan" id="kobo.60.2">This means ignoring some log records and collecting data from the other records. </span><span class="kobospan" id="kobo.60.3">A mapping from the path string to a count is an elegant way to gather this data. </span><span class="kobospan" id="kobo.60.4">We’ll look at how to implement this in detail. </span><span class="kobospan" id="kobo.60.5">Later, we’ll look at some alternative implementations</span><span id="dx1-291027"/><span class="kobospan" id="kobo.61.1"> in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.62.1">collections</span></span></span></span><span class="kobospan" id="kobo.63.1"> module. </span><span id="x1-291028r564"/></p>
</section>
<section data-number="0.8.1.2" id="how-to-do-it...-39">
<h2 class="likechapterhead" data-number="0.8.1.2"><span><span class="kobospan" id="kobo.64.1">5.1.2 </span></span> <span id="x1-2920002"/><span class="kobospan" id="kobo.65.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.66.1">We have a number of ways to build</span><span id="dx1-292001"/><span class="kobospan" id="kobo.67.1"> dictionary objects:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.68.1">Literal</span></span><span class="kobospan" id="kobo.69.1">: We can create a display of a dictionary</span><span id="dx1-292002"/><span class="kobospan" id="kobo.70.1"> by using a sequence of key/value pairs surrounded by </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.71.1">{}</span></span></span></span><span class="kobospan" id="kobo.72.1"> characters. </span><span class="kobospan" id="kobo.72.2">We use a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.73.1">:</span></span></span></span><span class="kobospan" id="kobo.74.1"> between a key and the associated value. </span><span class="kobospan" id="kobo.74.2">Literals look like this: </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.75.1">{"num":</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.76.1"> 355,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.77.1"> "den":</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.78.1"> 113}</span></span></span></span><span class="kobospan" id="kobo.79.1">.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.80.1">Conversion function</span></span><span class="kobospan" id="kobo.81.1">: A sequence of two-tuples can be turned</span><span id="dx1-292003"/><span class="kobospan" id="kobo.82.1"> into a dictionary like this: </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.83.1">dict([(’num’,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.84.1"> 355),</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.85.1"> (’den’,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.86.1"> 113)])</span></span></span></span><span class="kobospan" id="kobo.87.1">. </span><span class="kobospan" id="kobo.87.2">Each two-tuple becomes a key-value pair. </span><span class="kobospan" id="kobo.87.3">The keys must be immutable objects like strings, numbers, or tuples of immutable objects. </span><span class="kobospan" id="kobo.87.4">We can also build dictionaries like this: </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.88.1">dict(num=355,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.89.1"> den=113)</span></span></span></span><span class="kobospan" id="kobo.90.1">. </span><span class="kobospan" id="kobo.90.2">Each of the parameter names becomes a key. </span><span class="kobospan" id="kobo.90.3">This limits the dictionary keys to strings that are also valid Python variable names.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.91.1">Insertion</span></span><span class="kobospan" id="kobo.92.1">: We can use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.93.1">dictionary</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.94.1"> [key]</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.95.1"> =</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.96.1"> value</span></span></span></span><span class="kobospan" id="kobo.97.1"> syntax</span><span id="dx1-292004"/><span class="kobospan" id="kobo.98.1"> to set or replace a value in a dictionary. </span><span class="kobospan" id="kobo.98.2">We’ll look at this later in this recipe.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.99.1">Comprehensions</span></span><span class="kobospan" id="kobo.100.1">: Similar to lists and sets, we can write a dictionary</span><span id="dx1-292005"/><span class="kobospan" id="kobo.101.1"> comprehension to build a dictionary from some source of data.</span></p></li>
</ul>
<section data-number="0.8.1.2.1" id="building-a-dictionary-by-setting-items">
<h3 class="likesubsubsectionhead" data-number="0.8.1.2.1"><span id="x1-2930002"/><span class="kobospan" id="kobo.102.1">Building a dictionary by setting items</span></h3>
<p class="normal"><span class="kobospan" id="kobo.103.1">We build a dictionary by creating an empty</span><span id="dx1-293001"/><span class="kobospan" id="kobo.104.1"> dictionary and then setting items to it:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-293003x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.105.1">Create an empty dictionary to map paths to counts. </span><span class="kobospan" id="kobo.105.2">We can also use </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.106.1">dict()</span></span></span></span><span class="kobospan" id="kobo.107.1"> to create an empty dictionary. </span><span class="kobospan" id="kobo.107.2">Since we’re going to create a histogram that counts the number of times a path is used, we’ll call it </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.108.1">histogram</span></span></span></span><span class="kobospan" id="kobo.109.1">:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.110.1">&gt;&gt;&gt; histogram = {}</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.111.1">We can also use the function </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.112.1">dict()</span></span></span></span><span class="kobospan" id="kobo.113.1"> instead of the literal value </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.114.1">{}</span></span></span></span><span class="kobospan" id="kobo.115.1"> to create an empty dictionary.</span></p>
</div></li>
<li class="calibre7"><div id="x1-293007x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.116.1">For each of the log lines, filter out the ones that do not have a value that starts with path in the item with an index of 3:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.117.1">&gt;&gt;&gt; for line in log_lines: 
 
... </span><span class="kobospan" id="kobo.117.2">    path_method = line[3]  # group(4) of the original match 
 
... </span><span class="kobospan" id="kobo.117.3">    if path_method.startswith("path"):</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-293013x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.118.1">If the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.119.1">path</span></span></span></span><span class="kobospan" id="kobo.120.1"> is not in the dictionary, we need to add it. </span><span class="kobospan" id="kobo.120.2">Once the value of the path_method string is in the dictionary, we can increment the value in the dictionary, based on the key from the data:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.121.1">
... </span><span class="kobospan" id="kobo.121.2">        if path_method not in histogram: 
 
... </span><span class="kobospan" id="kobo.121.3">            histogram[path_method] = 0 
 
... </span><span class="kobospan" id="kobo.121.4">        histogram[path_method] += 1</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.122.1">This technique adds</span><span id="dx1-293018"/><span class="kobospan" id="kobo.123.1"> each new </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.124.1">path_method</span></span></span></span><span class="kobospan" id="kobo.125.1"> value to the dictionary. </span><span class="kobospan" id="kobo.125.2">Once it has been established that the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.126.1">path_method</span></span></span></span><span class="kobospan" id="kobo.127.1"> key is in the dictionary, we can increment the value associated with the key.</span></p>
</section>
<section data-number="0.8.1.2.2" id="building-a-dictionary-as-a-comprehension">
<h3 class="likesubsubsectionhead" data-number="0.8.1.2.2"><span id="x1-2940002"/><span class="kobospan" id="kobo.128.1">Building a dictionary as a comprehension</span></h3>
<p class="normal"><span class="kobospan" id="kobo.129.1">The last field of each log line</span><span id="dx1-294001"/><span class="kobospan" id="kobo.130.1"> had one or two fields</span><span id="dx1-294002"/><span class="kobospan" id="kobo.131.1"> inside. </span><span class="kobospan" id="kobo.131.2">There may have been a value like </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.132.1">path="/openapi.yaml"</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.133.1"> method=GET</span></span></span></span><span class="kobospan" id="kobo.134.1"> with two attributes, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.135.1">path</span></span></span></span><span class="kobospan" id="kobo.136.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.137.1">method</span></span></span></span><span class="kobospan" id="kobo.138.1">, or a value like </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.139.1">error="invalid</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.140.1"> query"</span></span></span></span><span class="kobospan" id="kobo.141.1"> with only one attribute, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.142.1">error</span></span></span></span><span class="kobospan" id="kobo.143.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.144.1">We can use the following regular expression to decompose the final field of each line:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.145.1">param_parser = re.compile( 
 
    r’(\w+)=(".*?"|\w+)’ 
 
)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.146.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.147.1">findall()</span></span></span></span><span class="kobospan" id="kobo.148.1"> method of this regular expression will provide a sequence of two-tuples based on the matching text. </span><span class="kobospan" id="kobo.148.2">We can then build a dictionary from the sequence of matched groups:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-294008x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.149.1">For each of the log lines, apply the regular expression to create a sequence of pairs:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.150.1">&gt;&gt;&gt; for line in log_lines: 
 
... </span><span class="kobospan" id="kobo.150.2">    name_value_pairs = param_parser.findall(line[3])</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-294013x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.151.1">Use a dictionary comprehension to use the first matching group as the key and the second matching group as the value:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.152.1">
... </span><span class="kobospan" id="kobo.152.2">    params = {match[0]: match[1] for match in name_value_pairs}                                                                

                                                                     
     </span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.153.1">We can print the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.154.1">params</span></span></span></span><span class="kobospan" id="kobo.155.1"> values and we’ll see the dictionaries like the following examples:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.156.1">{’path’: ’"/openapi.yaml"’, ’method’: ’GET’} 
 
{’path’: ’"/items?limit=x"’, ’method’: ’GET’} 
 
{’error’: ’"invalid query"’}</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.157.1">Using a dictionary for the final fields</span><span id="dx1-294020"/><span class="kobospan" id="kobo.158.1"> of each log record</span><span id="dx1-294021"/><span class="kobospan" id="kobo.159.1"> makes it easier to separate the important pieces of information. </span><span id="x1-294022r569"/></p>
</section>
</section>
<section data-number="0.8.1.3" id="how-it-works...-39">
<h2 class="likechapterhead" data-number="0.8.1.3"><span><span class="kobospan" id="kobo.160.1">5.1.3 </span></span> <span id="x1-2950003"/><span class="kobospan" id="kobo.161.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.162.1">The core feature of a dictionary</span><span id="dx1-295001"/><span class="kobospan" id="kobo.163.1"> is a mapping from an immutable key to a value object of any kind. </span><span class="kobospan" id="kobo.163.2">In the first example, we’ve used an immutable string as the key, and an integer as the value. </span><span class="kobospan" id="kobo.163.3">We describe it as </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.164.1">dict[str,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.165.1"> int]</span></span></span></span><span class="kobospan" id="kobo.166.1"> in the type hint.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.167.1">It’s important to understand how the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.168.1">+=</span></span></span></span><span class="kobospan" id="kobo.169.1"> assignment statement works. </span><span class="kobospan" id="kobo.169.2">The implementation of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.170.1">+=</span></span></span></span><span class="kobospan" id="kobo.171.1"> is essentially this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.172.1">histogram[customer] = histogram[customer] + 1</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.173.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.174.1">histogram[customer]</span></span></span></span><span class="kobospan" id="kobo.175.1"> value is fetched from the dictionary, a new value is computed, and the result is used to update the dictionary.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.176.1">It’s essential that dictionary key objects be immutable. </span><span class="kobospan" id="kobo.176.2">We cannot use a list, set, or dictionary as the key in a dictionary mapping. </span><span class="kobospan" id="kobo.176.3">We can, however, transform a list into an immutable tuple, or make a set into a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.177.1">frozenset</span></span></span></span><span class="kobospan" id="kobo.178.1"> so that we can use one of these more complex objects as a key. </span><span class="kobospan" id="kobo.178.2">In the examples</span><span id="dx1-295004"/><span class="kobospan" id="kobo.179.1"> shown in this recipe, we had immutable strings as the keys to each dictionary. </span><span id="x1-295005r579"/></p>
</section>
<section data-number="0.8.1.4" id="theres-more...-32">
<h2 class="likechapterhead" data-number="0.8.1.4"><span><span class="kobospan" id="kobo.180.1">5.1.4 </span></span> <span id="x1-2960004"/><span class="kobospan" id="kobo.181.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.182.1">We don’t have to use an </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.183.1">if</span></span></span></span><span class="kobospan" id="kobo.184.1"> statement to add missing keys. </span><span class="kobospan" id="kobo.184.2">We can use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.185.1">setdefault()</span></span></span></span><span class="kobospan" id="kobo.186.1"> method of a dictionary</span><span id="dx1-296001"/><span class="kobospan" id="kobo.187.1"> instead. </span><span class="kobospan" id="kobo.187.2">It’s even easier to use one of the classes from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.188.1">collections</span></span></span></span><span class="kobospan" id="kobo.189.1"> module.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.190.1">Here’s the version using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.191.1">defaultdict</span></span></span></span><span class="kobospan" id="kobo.192.1"> class from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.193.1">collections</span></span></span></span><span class="kobospan" id="kobo.194.1"> module:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.195.1">&gt;&gt;&gt; from collections import defaultdict

&gt;&gt;&gt; histogram = defaultdict(int) 
 
&gt;&gt;&gt; for line in log_lines: 
 
... </span><span class="kobospan" id="kobo.195.2">    path_method = line[3]  # group(4) of the match 
 
... </span><span class="kobospan" id="kobo.195.3">    if path_method.startswith("path"): 
 
... </span><span class="kobospan" id="kobo.195.4">        histogram[path_method] += 1</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.196.1">We’ve created a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.197.1">defaultdict</span></span></span></span><span class="kobospan" id="kobo.198.1"> instance that will initialize any unknown key values using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.199.1">int()</span></span></span></span><span class="kobospan" id="kobo.200.1"> function. </span><span class="kobospan" id="kobo.200.2">We provide </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.201.1">int</span></span></span></span><span class="kobospan" id="kobo.202.1">—the function object—to the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.203.1">defaultdict</span></span></span></span><span class="kobospan" id="kobo.204.1"> constructor. </span><span class="kobospan" id="kobo.204.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.205.1">defaultdict</span></span></span></span><span class="kobospan" id="kobo.206.1"> instance will evaluate the given function to create default values.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.207.1">This allows us to use </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.208.1">histogram[path_method]</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.209.1"> +=</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.210.1"> 1</span></span></span></span><span class="kobospan" id="kobo.211.1">. </span><span class="kobospan" id="kobo.211.2">If the value associated with the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.212.1">path_method</span></span></span></span><span class="kobospan" id="kobo.213.1"> key was previously in the dictionary, the value will be incremented and put back into the dictionary. </span><span class="kobospan" id="kobo.213.2">If the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.214.1">path_method</span></span></span></span><span class="kobospan" id="kobo.215.1"> key was not in the dictionary, the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.216.1">int()</span></span></span></span><span class="kobospan" id="kobo.217.1"> function is called with no argument; this default value will be incremented and put into the dictionary.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.218.1">The other way we can accumulate frequency counts is by creating a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.219.1">Counter</span></span></span></span><span class="kobospan" id="kobo.220.1"> object. </span><span class="kobospan" id="kobo.220.2">We can build the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.221.1">Counter</span></span></span></span><span class="kobospan" id="kobo.222.1"> object from the raw data as follows:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.223.1">&gt;&gt;&gt; from collections import Counter 
 
 
 
&gt;&gt;&gt; filtered_paths = ( 
 
... </span><span class="kobospan" id="kobo.223.2">    line[3] 
 
... </span><span class="kobospan" id="kobo.223.3">    for line in log_lines 
 
... </span><span class="kobospan" id="kobo.223.4">    if line[3].startswith("path") 
 
... </span><span class="kobospan" id="kobo.223.5">) 
 
&gt;&gt;&gt; histogram = Counter(filtered_paths) 
 
&gt;&gt;&gt; histogram 
 
Counter({’path="/openapi.yaml" method=GET’: 1, ’path="/items?limit=x" method=GET’: 1, ’path="/category/42" method=GET’: 1})</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.224.1">First, we used a generator expression to create an iterator over the filtered path data; this was assigned to </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.225.1">filtered_paths</span></span></span></span><span class="kobospan" id="kobo.226.1">. </span><span class="kobospan" id="kobo.226.2">Then we created a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.227.1">Counter</span></span></span></span><span class="kobospan" id="kobo.228.1"> from the source of data; the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.229.1">Counter</span></span></span></span><span class="kobospan" id="kobo.230.1"> class will scan the data and count the distinct occurrences. </span><span id="x1-296021r581"/></p>
</section>
<section data-number="0.8.1.5" id="see-also-38">
<h2 class="likechapterhead" data-number="0.8.1.5"><span><span class="kobospan" id="kobo.231.1">5.1.5 </span></span> <span id="x1-2970005"/><span class="kobospan" id="kobo.232.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.233.1">In the </span><a href="ch009.xhtml#x1-2980002" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.234.1">Shrinking dictionaries – the pop() method and the del statement</span></span></a><span class="kobospan" id="kobo.235.1"> recipe, we’ll look at how dictionaries can be modified by removing items.</span></p></li>
</ul>
<p class="normal1"><span id="x1-297001r563"/></p>
</section>
</section>
<section data-number="0.8.2" id="shrinking-dictionaries-the-pop-method-and-the-del-statement">
<h1 class="unnumbered" data-number="0.8.2"><span><span class="kobospan" id="kobo.236.1">5.2 </span></span> <span id="x1-2980002"/><span class="kobospan" id="kobo.237.1">Shrinking dictionaries – the pop() method and the del statement</span></h1>
<p class="normal"><span class="kobospan" id="kobo.238.1">A common use case</span><span id="dx1-298001"/><span class="kobospan" id="kobo.239.1"> for a dictionary is as an </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.240.1">associative store</span></span><span class="kobospan" id="kobo.241.1">: it keeps an association</span><span id="dx1-298002"/><span class="kobospan" id="kobo.242.1"> between key and value objects. </span><span class="kobospan" id="kobo.242.2">This means that we may be doing any of the </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.243.1">CRUD </span></span><span class="kobospan" id="kobo.244.1">operations on an item</span><span id="dx1-298003"/><span class="kobospan" id="kobo.245.1"> in the dictionary:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.246.1">Create a new key and value pair.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.247.1">Retrieve the value associated with a key.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.248.1">Update the value associated with a key.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.249.1">Delete the key (and the corresponding value) from the dictionary.</span></p></li>
</ul>
<p class="normal1"><span id="x1-298004r584"/></p>
<section data-number="0.8.2.1" id="getting-ready-40">
<h2 class="likechapterhead" data-number="0.8.2.1"><span><span class="kobospan" id="kobo.250.1">5.2.1 </span></span> <span id="x1-2990001"/><span class="kobospan" id="kobo.251.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.252.1">A great deal of processing supports the need to group items around one (or more) different common values. </span><span class="kobospan" id="kobo.252.2">We’ll return to the log data shown in the </span><a href="ch009.xhtml#x1-2900001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.253.1">Creating dictionaries – inserting and updating</span></span></a><span class="kobospan" id="kobo.254.1"> recipe in this chapter.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.255.1">We’ll use an iterator algorithm that uses the transaction ID as a key in a dictionary. </span><span class="kobospan" id="kobo.255.2">The value for this key will be the sequence of steps for the transaction. </span><span class="kobospan" id="kobo.255.3">With a very long log, we don’t — generally — want to save every transaction in a gigantic dictionary. </span><span class="kobospan" id="kobo.255.4">When we reach the termination of a transaction’s sequence, we can yield the list of log entries for the transaction. </span><span class="kobospan" id="kobo.255.5">A function can consume this iterator, processing each batch of transactions independently. </span><span id="x1-299001r586"/></p>
</section>
<section data-number="0.8.2.2" id="how-to-do-it...-40">
<h2 class="likechapterhead" data-number="0.8.2.2"><span><span class="kobospan" id="kobo.256.1">5.2.2 </span></span> <span id="x1-3000002"/><span class="kobospan" id="kobo.257.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.258.1">The context for this recipe</span><span id="dx1-300001"/><span class="kobospan" id="kobo.259.1"> will require an </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.260.1">if</span></span></span></span><span class="kobospan" id="kobo.261.1"> statement with the condition </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.262.1">match</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.263.1"> :=</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.264.1"> log_parser.match(line)</span></span></span></span><span class="kobospan" id="kobo.265.1">. </span><span class="kobospan" id="kobo.265.2">This will apply the regular expression, and collect the result in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.266.1">match</span></span></span></span><span class="kobospan" id="kobo.267.1"> variable. </span><span class="kobospan" id="kobo.267.2">Given that context, the processing to update or delete from a dictionary is as follows:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-300003x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.268.1">This function uses the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.269.1">defaultdict</span></span></span></span><span class="kobospan" id="kobo.270.1"> class, and two additional type hints, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.271.1">Iterable</span></span></span></span><span class="kobospan" id="kobo.272.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.273.1">Iterator</span></span></span></span><span class="kobospan" id="kobo.274.1">:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.275.1">from collections import defaultdict 
 
from collections.abc import Iterable, Iterator</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-300008x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.276.1">Define a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.277.1">defaultdict</span></span></span></span><span class="kobospan" id="kobo.278.1"> object to hold transaction steps. </span><span class="kobospan" id="kobo.278.2">The keys are 20-character strings. </span><span class="kobospan" id="kobo.278.3">The values are lists of log records. </span><span class="kobospan" id="kobo.278.4">In this case, each log record will have been parsed from the source text into a tuple of individual strings:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.279.1">LogRec = tuple[str, ...] 
 
 
 
def request_iter_t(source: Iterable[str]) -&gt; Iterator[list[LogRec]]: 
 
    requests: defaultdict[str, list[LogRec]] = defaultdict(list)</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-300015x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.280.1">Define the key for each cluster of log entries:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.281.1">
    for line in source: 
 
        if match := log_parser.match(line): 
 
            id = match.group(3)</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-300021x4" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.282.1">Update a dictionary item with a log record:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.283.1">
            requests[id].append(tuple(match.groups()))</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-300025x5" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.284.1">If this log record completes a transaction, yield the group as part of a generator function. </span><span class="kobospan" id="kobo.284.2">Then remove the transaction from the dictionary, since it’s complete:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.285.1">
            if match.group(4).startswith(’status’): 
 
                yield requests[id] 
 
                del requests[id]</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-300031x6" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.286.1">At the end, there may be an non-empty </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.287.1">requests</span></span></span></span><span class="kobospan" id="kobo.288.1"> dictionary. </span><span class="kobospan" id="kobo.288.2">This reflects a transaction that was in process when the log file was switched.</span></p>
</div></li>
</ol>
<p class="normal1"><span id="x1-300032r587"/></p>
</section>
<section data-number="0.8.2.3" id="how-it-works...-40">
<h2 class="likechapterhead" data-number="0.8.2.3"><span><span class="kobospan" id="kobo.289.1">5.2.3 </span></span> <span id="x1-3010003"/><span class="kobospan" id="kobo.290.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.291.1">Because a dictionary is a mutable</span><span id="dx1-301001"/><span class="kobospan" id="kobo.292.1"> object, we can remove keys from a dictionary. </span><span class="kobospan" id="kobo.292.2">A </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.293.1">del</span></span></span></span><span class="kobospan" id="kobo.294.1"> statement will delete both the key and the value object associated with the key. </span><span class="kobospan" id="kobo.294.2">In this example, the key is removed when the data reveals the transaction is complete. </span><span class="kobospan" id="kobo.294.3">A moderately busy web server handling an average of 10 transactions per second will see 864,000 transactions in a 24-hour period. </span><span class="kobospan" id="kobo.294.4">If there are an average of 2.5 log entries per transaction, there will be at least 2,160,000 lines in the file.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.295.1">If we only want to know the elapsed time per resource, we don’t want to keep the entire dictionary of 864,000 transactions in memory. </span><span class="kobospan" id="kobo.295.2">We’d rather transform the log into an intermediate summary file for further analysis.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.296.1">This idea of transient data leads us to accumulate the parsed log lines into a list instance. </span><span class="kobospan" id="kobo.296.2">Each new line is appended to the appropriate list for the transaction in which the line belongs. </span><span class="kobospan" id="kobo.296.3">When the final line has been found, the group of lines can be purged from the dictionary. </span><span id="x1-301002r593"/></p>
</section>
<section data-number="0.8.2.4" id="theres-more...-33">
<h2 class="likechapterhead" data-number="0.8.2.4"><span><span class="kobospan" id="kobo.297.1">5.2.4 </span></span> <span id="x1-3020004"/><span class="kobospan" id="kobo.298.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.299.1">In the example, we used</span><span id="dx1-302001"/><span class="kobospan" id="kobo.300.1"> the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.301.1">del</span></span></span></span><span class="kobospan" id="kobo.302.1"> statement. </span><span class="kobospan" id="kobo.302.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.303.1">pop()</span></span></span></span><span class="kobospan" id="kobo.304.1"> method can also</span><span id="dx1-302002"/><span class="kobospan" id="kobo.305.1"> be used. </span><span class="kobospan" id="kobo.305.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.306.1">del</span></span></span></span><span class="kobospan" id="kobo.307.1"> statement will raise a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.308.1">KeyError</span></span></span></span><span class="kobospan" id="kobo.309.1"> exception if the given item cannot be found in the dictionary.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.310.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.311.1">pop()</span></span></span></span><span class="kobospan" id="kobo.312.1"> method would look like this:</span></p>
<pre class="programlisting" id="listing-33"><code class="calibre13"><span class="kobospan" id="kobo.313.1">        requests.pop(id)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.314.1">This will mutate the dictionary in place, removing the item if it exists, or raising a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.315.1">KeyError</span></span></span></span><span class="kobospan" id="kobo.316.1"> exception.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.317.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.318.1">pop()</span></span></span></span><span class="kobospan" id="kobo.319.1"> method, when provided</span><span id="dx1-302004"/><span class="kobospan" id="kobo.320.1"> with a default value, can return the given default value instead of raising an exception when a key is not found. </span><span class="kobospan" id="kobo.320.2">In either case, the key will no longer be in the dictionary. </span><span class="kobospan" id="kobo.320.3">Note that this method both mutates the collection </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.321.1">and </span></span><span class="kobospan" id="kobo.322.1">returns a value.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.323.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.324.1">popitem()</span></span></span></span><span class="kobospan" id="kobo.325.1"> method will remove a key</span><span id="dx1-302005"/><span class="kobospan" id="kobo.326.1"> and value pair from the dictionary. </span><span class="kobospan" id="kobo.326.2">The pairs</span><span id="dx1-302006"/><span class="kobospan" id="kobo.327.1"> are returned in </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.328.1">Last-In-First-Out (LIFO) </span></span><span class="kobospan" id="kobo.329.1">order. </span><span class="kobospan" id="kobo.329.2">This means a dictionary is also a kind of stack. </span><span id="x1-302007r594"/></p>
</section>
<section data-number="0.8.2.5" id="see-also-39">
<h2 class="likechapterhead" data-number="0.8.2.5"><span><span class="kobospan" id="kobo.330.1">5.2.5 </span></span> <span id="x1-3030005"/><span class="kobospan" id="kobo.331.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.332.1">In the </span><a href="ch009.xhtml#x1-2900001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.333.1">Creating dictionaries – inserting and updating</span></span></a><span class="kobospan" id="kobo.334.1"> recipe, we look at how we create dictionaries and fill them with keys and values.</span></p></li>
</ul>
<p class="normal1"><span id="x1-303001r585"/></p>
</section>
</section>
<section data-number="0.8.3" id="writing-dictionary-related-type-hints">
<h1 class="unnumbered" data-number="0.8.3"><span><span class="kobospan" id="kobo.335.1">5.3 </span></span> <span id="x1-3040003"/><span class="kobospan" id="kobo.336.1">Writing dictionary-related type hints</span></h1>
<p class="normal"><span class="kobospan" id="kobo.337.1">When we look at sets</span><span id="dx1-304001"/><span class="kobospan" id="kobo.338.1"> and lists, we generally expect each item within a list (or a set) to be the same type. </span><span class="kobospan" id="kobo.338.2">When we look at object-oriented class designs, in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.339.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.340.1"> </span></span><a href="ch011_split_000.xhtml#x1-3760007" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.341.1">7</span></span></a><span class="kobospan" id="kobo.342.1">, we’ll see how a common superclass can be the common type for a closely related family of object types. </span><span class="kobospan" id="kobo.342.2">While it’s possible to have heterogeneous types in a list or set collection, it often becomes quite complex to process, requiring the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.343.1">match</span></span></span></span><span class="kobospan" id="kobo.344.1"> statement to do proper type matching. </span><span class="kobospan" id="kobo.344.2">A dictionary, however, can be used to create a </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.345.1">discriminated union </span></span><span class="kobospan" id="kobo.346.1">of types. </span><span class="kobospan" id="kobo.346.2">A particular key value may be used to define which other keys are present in the dictionary. </span><span class="kobospan" id="kobo.346.3">This means a simple </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.347.1">if</span></span></span></span><span class="kobospan" id="kobo.348.1"> statement can discriminate between heterogeneous types. </span><span id="x1-304002r595"/></p>
<section data-number="0.8.3.1" id="getting-ready-41">
<h2 class="likechapterhead" data-number="0.8.3.1"><span><span class="kobospan" id="kobo.349.1">5.3.1 </span></span> <span id="x1-3050001"/><span class="kobospan" id="kobo.350.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.351.1">We’ll look at two kinds of dictionary type hints, one for homogeneous value types and the other for heterogeneous value types. </span><span class="kobospan" id="kobo.351.2">We’ll look at data that starts out as one of these kinds of dictionaries but is transformed to have more complex type definitions.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.352.1">We’ll be starting with the following CSV file:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.353.1">date,engine on,fuel height on,engine off,fuel height off 
 
10/25/13,08:24:00,29,13:15:00,27 
 
10/26/13,09:12:00,27,18:25:00,22 
 
10/28/13,13:21:00,22,06:25:00,14</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.354.1">This describes three separate</span><span id="dx1-305006"/><span class="kobospan" id="kobo.355.1"> legs of a multi-day trip on a sailboat. </span><span class="kobospan" id="kobo.355.2">The fuel is measured by the height in the tank, rather than some indirect method using a float or other gauges. </span><span class="kobospan" id="kobo.355.3">Because the tank is approximately rectangular, 31 inches of depth is about 75 gallons of fuel. </span><span id="x1-305007r597"/></p>
</section>
<section data-number="0.8.3.2" id="how-to-do-it...-41">
<h2 class="likechapterhead" data-number="0.8.3.2"><span><span class="kobospan" id="kobo.356.1">5.3.2 </span></span> <span id="x1-3060002"/><span class="kobospan" id="kobo.357.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.358.1">The initial use of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.359.1">csv.DictReader</span></span></span></span><span class="kobospan" id="kobo.360.1"> will lead to dictionaries with homogeneous type definitions:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-306002x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.361.1">Locate the type of the keys in the dictionary. </span><span class="kobospan" id="kobo.361.2">When reading CSV files, the keys are strings, with the type </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.362.1">str</span></span></span></span><span class="kobospan" id="kobo.363.1">.</span></p>
</div></li>
<li class="calibre7"><div id="x1-306004x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.364.1">Locate the type of the values in the dictionary. </span><span class="kobospan" id="kobo.364.2">When reading CSV files, the values are strings, with the type </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.365.1">str</span></span></span></span><span class="kobospan" id="kobo.366.1">.</span></p>
</div></li>
<li class="calibre7"><div id="x1-306006x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.367.1">Combine the types using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.368.1">dict</span></span></span></span><span class="kobospan" id="kobo.369.1"> type hint. </span><span class="kobospan" id="kobo.369.2">This yields </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.370.1">dict[str,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.371.1"> str]</span></span></span></span><span class="kobospan" id="kobo.372.1">.</span></p>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.373.1">Here’s an example function for reading data from a CSV file:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.374.1">import csv 
 
from pathlib import Path 
 
 
 
def get_fuel_use(source_path: Path) -&gt; list[dict[str, str]]: 
 
    with source_path.open() as source_file: 
 
        rdr = csv.DictReader(source_file) 
 
        data: list[dict[str, str]] = list(rdr) 
 
    return data</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.375.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.376.1">get_fuel_use()</span></span></span></span><span class="kobospan" id="kobo.377.1"> function yields values that match the source data. </span><span class="kobospan" id="kobo.377.2">In this case, it’s a dictionary that maps string column names to string cell values.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.378.1">This data, by itself, is difficult to work with. </span><span class="kobospan" id="kobo.378.2">A common second step is to apply transformations to the source rows to create more useful data types. </span><span class="kobospan" id="kobo.378.3">We can describe the results with a type hint:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-306017x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.379.1">Identify the various value</span><span id="dx1-306018"/><span class="kobospan" id="kobo.380.1"> types that will be needed. </span><span class="kobospan" id="kobo.380.2">In this example, there are five fields with three different types, shown here:</span></p>
<ul class="calibre17">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.381.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.382.1">date</span></span></span></span><span class="kobospan" id="kobo.383.1"> field is a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.384.1">datetime.date</span></span></span></span><span class="kobospan" id="kobo.385.1"> object.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.386.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.387.1">engine</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.388.1"> on</span></span></span></span><span class="kobospan" id="kobo.389.1"> field is a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.390.1">datetime.time</span></span></span></span><span class="kobospan" id="kobo.391.1"> object.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.392.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.393.1">fuel</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.394.1"> height</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.395.1"> on</span></span></span></span><span class="kobospan" id="kobo.396.1"> field is an integer, but we know that it will be used in a float context, so we’ll create a float directly.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.397.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.398.1">engine</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.399.1"> off</span></span></span></span><span class="kobospan" id="kobo.400.1"> field is a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.401.1">datetime.time</span></span></span></span><span class="kobospan" id="kobo.402.1"> object.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.403.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.404.1">fuel</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.405.1"> height</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.406.1"> off</span></span></span></span><span class="kobospan" id="kobo.407.1"> field is also a float value.</span></p></li>
</ul>
</div></li>
<li class="calibre7"><div id="x1-306020x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.408.1">Import the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.409.1">TypedDict</span></span></span></span><span class="kobospan" id="kobo.410.1"> type definition from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.411.1">typing</span></span></span></span><span class="kobospan" id="kobo.412.1"> module.</span></p>
</div></li>
<li class="calibre7"><div id="x1-306022x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.413.1">Define the subclass of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.414.1">TypedDict</span></span></span></span><span class="kobospan" id="kobo.415.1"> with the new heterogeneous dictionary types:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.416.1">import datetime 
 
from typing import TypedDict 
 
 
 
class History(TypedDict): 
 
    date: datetime.date 
 
    start_time: datetime.time 
 
    start_fuel: float 
 
    end_time: datetime.time 
 
    end_fuel: float</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.417.1">This is, in part, a teaser for </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.418.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.419.1"> </span></span><a href="ch011_split_000.xhtml#x1-3760007" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.420.1">7</span></span></a><span class="kobospan" id="kobo.421.1">. </span><span class="kobospan" id="kobo.421.2">It shows a very simple kind of class definition. </span><span class="kobospan" id="kobo.421.3">In this case, the class is dictionaries with five specific keys, all of which are required and must have values of the given types.</span></p>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.422.1">In this example, we’ve also renamed the fields to make them into names that are valid Python names. </span><span class="kobospan" id="kobo.422.2">Replacing punctuation with </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.423.1">_</span></span></span></span><span class="kobospan" id="kobo.424.1"> is the obvious first step. </span><span class="kobospan" id="kobo.424.2">We also changed a few because the column names in the CSV file seemed awkward.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.425.1">The function to perform the transformation</span><span id="dx1-306033"/><span class="kobospan" id="kobo.426.1"> can look like the following example:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.427.1">from collections.abc import Iterable, Iterator 
 
 
 
def make_history(source: Iterable[dict[str, str]]) -&gt; Iterator[History]: 
 
    for row in source: 
 
        yield dict( 
 
            date=datetime.datetime.strptime( 
 
                row[’date’], "%m/%d/%y").date(), 
 
            start_time=datetime.datetime.strptime( 
 
                row[’engine on’], ’%H:%M:%S’).time(), 
 
            start_fuel=float(row[’fuel height on’]), 
 
            end_time=datetime.datetime.strptime( 
 
                row[’engine off’], ’%H:%M:%S’).time(), 
 
            end_fuel=float(row[’fuel height off’]), 
 
        )</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.428.1">This function consumes instances of the initial </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.429.1">dict[str,str]</span></span></span></span><span class="kobospan" id="kobo.430.1"> dictionary and creates instances of the dictionary described by the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.431.1">History</span></span></span></span><span class="kobospan" id="kobo.432.1"> class. </span><span class="kobospan" id="kobo.432.2">Here’s how these two functions work together:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.433.1">&gt;&gt;&gt; from pprint import pprint 
 
 
 
&gt;&gt;&gt; source_path = Path("data/fuel2.csv") 
 
&gt;&gt;&gt; fuel_use = make_history(get_fuel_use(source_path)) 
 
&gt;&gt;&gt; for row in fuel_use: 
 
... </span><span class="kobospan" id="kobo.433.2">    pprint(row) 
 
{’date’: datetime.date(2013, 10, 25), 
 
 ’end_fuel’: 27.0, 
 
 ’end_time’: datetime.time(13, 15), 
 
 ’start_fuel’: 29.0, 
 
 ’start_time’: datetime.time(8, 24)} 
 
{’date’: datetime.date(2013, 10, 26), 
 
 ’end_fuel’: 22.0, 
 
 ’end_time’: datetime.time(18, 25), 
 
 ’start_fuel’: 27.0, 
 
 ’start_time’: datetime.time(9, 12)} 
 
{’date’: datetime.date(2013, 10, 28), 
 
 ’end_fuel’: 14.0, 
 
 ’end_time’: datetime.time(6, 25), 
 
 ’start_fuel’: 22.0, 
 
 ’start_time’: datetime.time(13, 21)}</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.434.1">This shows how the output from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.435.1">get_fuel_use()</span></span></span></span><span class="kobospan" id="kobo.436.1"> function can be processed by the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.437.1">make_history()</span></span></span></span><span class="kobospan" id="kobo.438.1"> function to create an iterable sequence of dictionaries. </span><span class="kobospan" id="kobo.438.2">Each of the resulting dictionaries has the source data converted to a more useful type. </span><span id="x1-306071r599"/></p>
</section>
<section data-number="0.8.3.3" id="how-it-works...-41">
<h2 class="likechapterhead" data-number="0.8.3.3"><span><span class="kobospan" id="kobo.439.1">5.3.3 </span></span> <span id="x1-3070003"/><span class="kobospan" id="kobo.440.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.441.1">The core type hint for a dictionary</span><span id="dx1-307001"/><span class="kobospan" id="kobo.442.1"> names the key type and the value type, in the form </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.443.1">dict[key,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.444.1"> value]</span></span></span></span><span class="kobospan" id="kobo.445.1">. </span><span class="kobospan" id="kobo.445.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.446.1">TypedDict</span></span></span></span><span class="kobospan" id="kobo.447.1"> class lets us be more specific about bindings between dictionary keys and a broad domain of values.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.448.1">It’s important to note that type hints</span><span id="dx1-307002"/><span class="kobospan" id="kobo.449.1"> are only checked by programs like </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.450.1">mypy</span></span><span class="kobospan" id="kobo.451.1">. </span><span class="kobospan" id="kobo.451.2">These hints have no runtime impact. </span><span class="kobospan" id="kobo.451.3">We could, for example, write a statement like the following:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.452.1">result: History = {’date’: 42}</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.453.1">This statement claims that the result dictionary will match the type hints in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.454.1">History</span></span></span></span><span class="kobospan" id="kobo.455.1"> type definition. </span><span class="kobospan" id="kobo.455.2">The dictionary literal, however, has the wrong type for the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.456.1">’date’</span></span></span></span><span class="kobospan" id="kobo.457.1"> field and a number of other fields are missing. </span><span class="kobospan" id="kobo.457.2">While this will execute, it will raise errors from </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.458.1">mypy</span></span><span class="kobospan" id="kobo.459.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.460.1">Running the </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.461.1">mypy </span></span><span class="kobospan" id="kobo.462.1">program reveals the error as shown in the following listing:</span></p>
<pre class="programlisting" id="listing-34"><code class="calibre13"><span class="kobospan" id="kobo.463.1">(cookbook3) % python -m mypy src/ch05/recipe_04_bad.py 
 
src/ch05/recipe_04_bad.py:18: error: Missing keys ("start_time", "start_fuel", "end_time", "end_fuel") for TypedDict "History"  [typeddict-item] 
 
Found 1 error in 1 file (checked 1 source file)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.464.1">For run-time validation</span><span id="dx1-307008"/><span class="kobospan" id="kobo.465.1"> of data, a project like </span><a href="https://docs.pydantic.dev/2.7/" class="url"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.466.1">Pydantic</span></span></a><span class="kobospan" id="kobo.467.1"> can be very</span><span id="dx1-307009"/><span class="kobospan" id="kobo.468.1"> helpful. </span><span id="x1-307010r604"/></p>
</section>
<section data-number="0.8.3.4" id="theres-more...-34">
<h2 class="likechapterhead" data-number="0.8.3.4"><span><span class="kobospan" id="kobo.469.1">5.3.4 </span></span> <span id="x1-3080004"/><span class="kobospan" id="kobo.470.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.471.1">One of the common cases for heterogeneity in dictionary keys is optional items. </span><span class="kobospan" id="kobo.471.2">The type hint </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.472.1">Optional[str]</span></span></span></span><span class="kobospan" id="kobo.473.1"> or </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.474.1">str</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.475.1"> |</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.476.1"> None</span></span></span></span><span class="kobospan" id="kobo.477.1"> describes this. </span><span class="kobospan" id="kobo.477.2">This is rarely needed with a dictionary, since it can be simpler to omit the </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.478.1">key-value </span></span><span class="kobospan" id="kobo.479.1">pair entirely.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.480.1">Let’s assume we need two variants of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.481.1">History</span></span></span></span><span class="kobospan" id="kobo.482.1"> type:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.483.1">The variant shown earlier in this recipe, where all fields are present.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.484.1">Two ”incomplete” records, one without an engine off time and ending fuel height, and another variant without an engine on time or starting fuel height. </span><span class="kobospan" id="kobo.484.2">These two records might be used for an overnight passage under power.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.485.1">In this case, we might need to use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.486.1">NotRequired</span></span></span></span><span class="kobospan" id="kobo.487.1"> annotation for these fields. </span><span class="kobospan" id="kobo.487.2">The resulting class definition would look like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.488.1">from typing import TypedDict, NotRequired 
 
 
 
class History2(TypedDict): 
 
   date: datetime.date 
 
   start_time: NotRequired[datetime.time] 
 
   start_fuel: NotRequired[float] 
 
   end_time: NotRequired[datetime.time] 
 
   end_fuel: NotRequired[float]
                                                                     

                                                                     </span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.489.1">This record permits a great deal of variability in the dictionary values. </span><span class="kobospan" id="kobo.489.2">It requires the use of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.490.1">if</span></span></span></span><span class="kobospan" id="kobo.491.1"> statements to determine the mix of fields present in the data. </span><span class="kobospan" id="kobo.491.2">Furthermore, it also requires somewhat more clever processing in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.492.1">make_history()</span></span></span></span><span class="kobospan" id="kobo.493.1"> function to create these variant records based on empty columns in the CSV file.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.494.1">There are some parallels between </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.495.1">TypedDict</span></span></span></span><span class="kobospan" id="kobo.496.1"> and the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.497.1">NamedTuple</span></span></span></span><span class="kobospan" id="kobo.498.1"> type definitions. </span><span class="kobospan" id="kobo.498.2">Changing </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.499.1">TypedDict</span></span></span></span><span class="kobospan" id="kobo.500.1"> to </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.501.1">NamedTuple</span></span></span></span><span class="kobospan" id="kobo.502.1"> will create a named tuple class instead of a typed dictionary class.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.503.1">Because a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.504.1">NamedTuple</span></span></span></span><span class="kobospan" id="kobo.505.1"> class has an </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.506.1">_asdict()</span></span></span></span><span class="kobospan" id="kobo.507.1"> method, it’s possible to produce a dictionary that matches the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.508.1">TypedDict</span></span></span></span><span class="kobospan" id="kobo.509.1"> structure from a named tuple.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.510.1">A dictionary that matches the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.511.1">TypedDict</span></span></span></span><span class="kobospan" id="kobo.512.1"> hint is mutable. </span><span class="kobospan" id="kobo.512.2">A subclass of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.513.1">NamedTuple</span></span></span></span><span class="kobospan" id="kobo.514.1">, however, is immutable. </span><span class="kobospan" id="kobo.514.2">This is one central difference between these two type hints. </span><span class="kobospan" id="kobo.514.3">More importantly, a dictionary uses </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.515.1">row[’date’]</span></span></span></span><span class="kobospan" id="kobo.516.1"> syntax to refer to one item using the key </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.517.1">’date’</span></span></span></span><span class="kobospan" id="kobo.518.1">. </span><span class="kobospan" id="kobo.518.2">A named tuple uses </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.519.1">row.date</span></span></span></span><span class="kobospan" id="kobo.520.1"> syntax to refer to one item using a name. </span><span id="x1-308010r606"/></p>
</section>
<section data-number="0.8.3.5" id="see-also-40">
<h2 class="likechapterhead" data-number="0.8.3.5"><span><span class="kobospan" id="kobo.521.1">5.3.5 </span></span> <span id="x1-3090005"/><span class="kobospan" id="kobo.522.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.523.1">The </span><a href="ch005_split_001.xhtml#x1-7500010" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.524.1">Using NamedTuples to simplify item access in tuples</span></span></a><span class="kobospan" id="kobo.525.1"> recipe provides more details on the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.526.1">NamedTuple</span></span></span></span><span class="kobospan" id="kobo.527.1"> type hint.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.528.1">See the </span><a href="ch008_split_001.xhtml#x1-2560005" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.529.1">Writing list-related type hints</span></span></a><span class="kobospan" id="kobo.530.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.531.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.532.1"> </span></span><a href="ch008_split_000.xhtml#x1-2240004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.533.1">4</span></span></a><span class="kobospan" id="kobo.534.1"> for more about type hints for lists.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.535.1">The </span><a href="ch008_split_001.xhtml#x1-2800009" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.536.1">Writing set-related type hints</span></span></a><span class="kobospan" id="kobo.537.1"> recipe, also in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.538.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.539.1"> </span></span><a href="ch008_split_000.xhtml#x1-2240004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.540.1">4</span></span></a><span class="kobospan" id="kobo.541.1">, covers this from the view of set types.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.542.1">For runtime validation</span><span id="dx1-309001"/><span class="kobospan" id="kobo.543.1"> of data, a project like </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.544.1">Pydantic </span></span><span class="kobospan" id="kobo.545.1">can be very helpful. </span><span class="kobospan" id="kobo.545.2">See </span><a class="url" href="https://docs.pydantic.dev/latest/"><span class="url1"><span class="kobospan" id="kobo.546.1">https://docs.pydantic.dev/latest/</span></span></a><span class="kobospan" id="kobo.547.1">.</span></p></li>
</ul>
<p class="normal1"><span id="x1-309002r596"/></p>
</section>
</section>
<section data-number="0.8.4" id="understanding-variables-references-and-assignment">
<h1 class="unnumbered" data-number="0.8.4"><span><span class="kobospan" id="kobo.548.1">5.4 </span></span> <span id="x1-3100004"/><span class="kobospan" id="kobo.549.1">Understanding variables, references, and assignment</span></h1>
<p class="normal"><span class="kobospan" id="kobo.550.1">How do variables really work? </span><span class="kobospan" id="kobo.550.2">What happens</span><span id="dx1-310001"/><span class="kobospan" id="kobo.551.1"> when we assign</span><span id="dx1-310002"/><span class="kobospan" id="kobo.552.1"> a mutable</span><span id="dx1-310003"/><span class="kobospan" id="kobo.553.1"> object to two variables? </span><span class="kobospan" id="kobo.553.2">When two variables are sharing references to a common mutable object, the behaviors can be confusing.</span></p>
<div class="tipbox" id="tcolobox-10">
<div class="note">
<p class="normal1"><span class="kobospan" id="kobo.554.1">This is the core principle: </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.555.1">Python shares references; it doesn’t</span></span> <span class="cmbx-10x-x"><span class="kobospan" id="kobo.556.1">copy data</span></span><span class="kobospan" id="kobo.557.1">.</span></p>
</div>
</div>
<p class="normal1"><span class="kobospan" id="kobo.558.1">To see what this rule on reference sharing means, we’ll create two data structures: one is mutable and one is immutable. </span><span id="x1-310004r608"/></p>
<section data-number="0.8.4.1" id="getting-ready-42">
<h2 class="likechapterhead" data-number="0.8.4.1"><span><span class="kobospan" id="kobo.559.1">5.4.1 </span></span> <span id="x1-3110001"/><span class="kobospan" id="kobo.560.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.561.1">We’ll look at the two kinds of sequences, although we could do something similar with two kinds of sets:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.562.1">&gt;&gt;&gt; mutable = [1, 1, 2, 3, 5, 8] 
 
&gt;&gt;&gt; immutable = (5, 8, 13, 21)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.563.1">We’ll look at what happens when references to these objects are shared.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.564.1">We can do a similar comparison with a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.565.1">set</span></span></span></span><span class="kobospan" id="kobo.566.1"> and a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.567.1">frozenset</span></span></span></span><span class="kobospan" id="kobo.568.1">. </span><span class="kobospan" id="kobo.568.2">We can’t easily do this with a mapping because Python doesn’t offer a handy immutable mapping. </span><span id="x1-311004r610"/></p>
</section>
<section data-number="0.8.4.2" id="how-to-do-it...-42">
<h2 class="likechapterhead" data-number="0.8.4.2"><span><span class="kobospan" id="kobo.569.1">5.4.2 </span></span> <span id="x1-3120002"/><span class="kobospan" id="kobo.570.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.571.1">This recipe will show how</span><span id="dx1-312001"/><span class="kobospan" id="kobo.572.1"> to observe</span><span id="dx1-312002"/><span class="kobospan" id="kobo.573.1"> the ”spooky action at a distance” when there</span><span id="dx1-312003"/><span class="kobospan" id="kobo.574.1"> are two references to an underlying mutable object. </span><span class="kobospan" id="kobo.574.2">We’ll look at ways to prevent this in the </span><a href="ch009.xhtml#x1-3160005" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.575.1">Making shallow and deep copies of objects</span></span></a><span class="kobospan" id="kobo.576.1"> recipe. </span><span class="kobospan" id="kobo.576.2">Here are the steps for seeing the difference between mutable and immutable collections:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-312005x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.577.1">Assign each collection to an additional variable. </span><span class="kobospan" id="kobo.577.2">This will create two references to the structure:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.578.1">&gt;&gt;&gt; mutable_b = mutable 
 
&gt;&gt;&gt; immutable_b = immutable                                                                

                                                                     
     </span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.579.1">We now have two references to the list </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.580.1">[1,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.581.1"> 1,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.582.1"> 2,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.583.1"> 3,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.584.1"> 5,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.585.1"> 8]</span></span></span></span><span class="kobospan" id="kobo.586.1"> and two references to the tuple </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.587.1">(5,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.588.1"> 8,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.589.1"> 13,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.590.1"> 21)</span></span></span></span><span class="kobospan" id="kobo.591.1">.</span></p>
</div></li>
<li class="calibre7"><div id="x1-312010x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.592.1">We can confirm this using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.593.1">is</span></span></span></span><span class="kobospan" id="kobo.594.1"> operator. </span><span class="kobospan" id="kobo.594.2">This determines if two variables refer to the same underlying object:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.595.1">&gt;&gt;&gt; mutable_b is mutable 
 
True 
 
&gt;&gt;&gt; immutable_b is immutable 
 
True</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-312017x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.596.1">Make a change to one of the two references to the collection. </span><span class="kobospan" id="kobo.596.2">For the list type, we have methods like </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.597.1">extend()</span></span></span></span><span class="kobospan" id="kobo.598.1"> or </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.599.1">append()</span></span></span></span><span class="kobospan" id="kobo.600.1">. </span><span class="kobospan" id="kobo.600.2">For this example we’ll use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.601.1">+</span></span></span></span><span class="kobospan" id="kobo.602.1"> operator:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.603.1">&gt;&gt;&gt; mutable += [mutable[-2] + mutable[-1]]</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.604.1">We can do a similar thing with the immutable structure:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.605.1">&gt;&gt;&gt; immutable += (immutable[-2] + immutable[-1],)</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-312023x4" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.606.1">Look at the other two variables that reference the mutable structure. </span><span class="kobospan" id="kobo.606.2">Because the two variables are references to the same underlying list object, each variable shows the current state:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.607.1">&gt;&gt;&gt; mutable_b 
 
[1, 1, 2, 3, 5, 8, 13] 
 
&gt;&gt;&gt; mutable is mutable_b 
 
True</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-312030x5" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.608.1">Look at the two variables</span><span id="dx1-312031"/><span class="kobospan" id="kobo.609.1"> referring to immutable</span><span id="dx1-312032"/><span class="kobospan" id="kobo.610.1"> structures. </span><span class="kobospan" id="kobo.610.2">Initially, the two variables</span><span id="dx1-312033"/><span class="kobospan" id="kobo.611.1"> shared a common object. </span><span class="kobospan" id="kobo.611.2">When the assignment statement was executed, a new tuple was created and only one variable changed to refer to the new tuple:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.612.1">
&gt;&gt;&gt; immutable_b 
 
(5, 8, 13, 21) 
 
&gt;&gt;&gt; immutable 
 
(5, 8, 13, 21, 34)</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span id="x1-312039r612"/></p>
</section>
<section data-number="0.8.4.3" id="how-it-works...-42">
<h2 class="likechapterhead" data-number="0.8.4.3"><span><span class="kobospan" id="kobo.613.1">5.4.3 </span></span> <span id="x1-3130003"/><span class="kobospan" id="kobo.614.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.615.1">The two variables, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.616.1">mutable</span></span></span></span><span class="kobospan" id="kobo.617.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.618.1">mutable_b</span></span></span></span><span class="kobospan" id="kobo.619.1">, still refer to the same underlying object. </span><span class="kobospan" id="kobo.619.2">Because of that, we can use either variable to change the object and see the change reflected in the other variable’s value.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.620.1">The two variables, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.621.1">immutable_b</span></span></span></span><span class="kobospan" id="kobo.622.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.623.1">immutable</span></span></span></span><span class="kobospan" id="kobo.624.1">, started out referring to the same object. </span><span class="kobospan" id="kobo.624.2">Because the object cannot be mutated in place, a change to one variable means that a new object is assigned to that variable. </span><span class="kobospan" id="kobo.624.3">The other variable remains firmly attached to the original object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.625.1">In Python, a variable is a label that’s attached to an object. </span><span class="kobospan" id="kobo.625.2">We can think of them like adhesive notes in bright colors that we stick on an object temporarily. </span><span class="kobospan" id="kobo.625.3">Multiple labels can be attached to an object. </span><span class="kobospan" id="kobo.625.4">It’s the assignment statement that places a variable name on an object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.626.1">Consider the following statement:</span></p> <pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.627.1">immutable += (immutable[-2] + immutable[-1],)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.628.1">This has the same effect as this statement:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.629.1">immutable = immutable + (immutable[-2] + immutable[-1],)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.630.1">The expression on the right side</span><span id="dx1-313005"/><span class="kobospan" id="kobo.631.1"> of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.632.1">=</span></span></span></span><span class="kobospan" id="kobo.633.1"> creates a new tuple</span><span id="dx1-313006"/><span class="kobospan" id="kobo.634.1"> from the previous value of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.635.1">immutable</span></span></span></span><span class="kobospan" id="kobo.636.1"> tuple. </span><span class="kobospan" id="kobo.636.2">The assignment</span><span id="dx1-313007"/><span class="kobospan" id="kobo.637.1"> statement then assigns the label </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.638.1">immutable</span></span></span></span><span class="kobospan" id="kobo.639.1"> to the newly-minted object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.640.1">Assigning to a variable</span><span id="dx1-313008"/><span class="kobospan" id="kobo.641.1"> has two possible actions:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.642.1">For mutable objects that provide definitions for appropriate in-place assignment operators like </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.643.1">+=</span></span></span></span><span class="kobospan" id="kobo.644.1">, the assignment is transformed into a special method; in this case, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.645.1">__iadd__()</span></span></span></span><span class="kobospan" id="kobo.646.1">. </span><span class="kobospan" id="kobo.646.2">The special method will mutate the object’s internal state.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.647.1">For immutable objects that do not provide definitions for assignment like </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.648.1">+=</span></span></span></span><span class="kobospan" id="kobo.649.1">, the assignment is transformed into </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.650.1">=</span></span></span></span><span class="kobospan" id="kobo.651.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.652.1">+</span></span></span></span><span class="kobospan" id="kobo.653.1">. </span><span class="kobospan" id="kobo.653.2">A new object is built by the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.654.1">+</span></span></span></span><span class="kobospan" id="kobo.655.1"> operator and the variable name is attached to that new object. </span><span class="kobospan" id="kobo.655.2">Other variables that previously referred to the object being replaced are not affected; they will continue to refer to old objects.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.656.1">Python counts the number of places from which an object is referenced. </span><span class="kobospan" id="kobo.656.2">When the count of references becomes zero, the object is no longer used anywhere and can be removed from memory. </span><span id="x1-313009r619"/></p>
</section>
<section data-number="0.8.4.4" id="theres-more...-35">
<h2 class="likechapterhead" data-number="0.8.4.4"><span><span class="kobospan" id="kobo.657.1">5.4.4 </span></span> <span id="x1-3140004"/><span class="kobospan" id="kobo.658.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.659.1">Some languages have primitive types in addition to objects. </span><span class="kobospan" id="kobo.659.2">In these languages, a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.660.1">+=</span></span></span></span><span class="kobospan" id="kobo.661.1"> statement may leverage a feature of the hardware instructions to tweak the value of a primitive type.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.662.1">Python doesn’t have this kind of optimization. </span><span class="kobospan" id="kobo.662.2">Numbers are immutable objects; there are no special instructions to tweak their values. </span><span class="kobospan" id="kobo.662.3">Consider the following assignment statements:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.663.1">a = 355 
 
a += 113</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.664.1">The processing does not tweak the internal state of the object 355. </span><span class="kobospan" id="kobo.664.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.665.1">int</span></span></span></span><span class="kobospan" id="kobo.666.1"> class does not provide an </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.667.1">__iadd__()</span></span></span></span><span class="kobospan" id="kobo.668.1"> special method. </span><span class="kobospan" id="kobo.668.2">A new immutable integer object is created. </span><span class="kobospan" id="kobo.668.3">This new object is given the label </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.669.1">a</span></span></span></span><span class="kobospan" id="kobo.670.1">. </span><span class="kobospan" id="kobo.670.2">The old value previously assigned to </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.671.1">a</span></span></span></span><span class="kobospan" id="kobo.672.1"> is no longer needed, and the storage can be reclaimed. </span><span id="x1-314004r622"/></p>
</section>
<section data-number="0.8.4.5" id="see-also-41">
<h2 class="likechapterhead" data-number="0.8.4.5"><span><span class="kobospan" id="kobo.673.1">5.4.5 </span></span> <span id="x1-3150005"/><span class="kobospan" id="kobo.674.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.675.1">In the </span><a href="ch009.xhtml#x1-3160005" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.676.1">Making shallow and deep copies of objects</span></span></a><span class="kobospan" id="kobo.677.1"> recipe, we’ll look at ways we can copy mutable structures to prevent shared references.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.678.1">Also, see </span><a href="ch009.xhtml#x1-3210006" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.679.1">Avoiding mutable default values for function parameters</span></span></a><span class="kobospan" id="kobo.680.1"> for another consequence of the way references are shared in Python.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.681.1">For the CPython implementation, a few objects can be immortal. </span><span class="kobospan" id="kobo.681.2">See </span><a href="https://peps.python.org/pep-0683/" class="url"><span class="kobospan" id="kobo.682.1">PEP 683</span></a><span class="kobospan" id="kobo.683.1"> for more on this implementation detail.</span></p></li>
</ul>
<p class="normal1"><span id="x1-315001r609"/></p>
</section>
</section>
<section data-number="0.8.5" id="making-shallow-and-deep-copies-of-objects">
<h1 class="unnumbered" data-number="0.8.5"><span><span class="kobospan" id="kobo.684.1">5.5 </span></span> <span id="x1-3160005"/><span class="kobospan" id="kobo.685.1">Making shallow and deep copies of objects</span></h1>
<p class="normal"><span class="kobospan" id="kobo.686.1">Throughout this chapter, we’ve talked</span><span id="dx1-316001"/><span class="kobospan" id="kobo.687.1"> about how assignment</span><span id="dx1-316002"/><span class="kobospan" id="kobo.688.1"> statements share references to objects. </span><span class="kobospan" id="kobo.688.2">Objects are not normally copied.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.689.1">Consider this assignment statement:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.690.1">a = b</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.691.1">This creates two references to the same underlying object. </span><span class="kobospan" id="kobo.691.2">If the value of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.692.1">b</span></span></span></span><span class="kobospan" id="kobo.693.1"> variable has a mutable type, like the list, set, or dict types, then a change using either </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.694.1">a</span></span></span></span><span class="kobospan" id="kobo.695.1"> or </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.696.1">b</span></span></span></span><span class="kobospan" id="kobo.697.1"> will update the underlying mutable object. </span><span class="kobospan" id="kobo.697.2">For more background, see the </span><a href="ch009.xhtml#x1-3100004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.698.1">Understanding variables, references, and assignment</span></span></a><span class="kobospan" id="kobo.699.1"> recipe.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.700.1">Most of the time, this is the behavior we want. </span><span class="kobospan" id="kobo.700.2">This is ideal for providing mutable objects to functions and having a local variable in the function mutate an object created outside the function. </span><span class="kobospan" id="kobo.700.3">There are rare situations in which we want to actually have two independent objects created from one original object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.701.1">There are two ways to break the connection that exists when two variables are references to the same underlying object:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.702.1">Making a shallow copy of the structure</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.703.1">Making a deep copy of the structure</span></p></li>
</ul>
<p class="normal1"><span id="x1-316005r624"/></p>
<section data-number="0.8.5.1" id="getting-ready-43">
<h2 class="likechapterhead" data-number="0.8.5.1"><span><span class="kobospan" id="kobo.704.1">5.5.1 </span></span> <span id="x1-3170001"/><span class="kobospan" id="kobo.705.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.706.1">Python does not automatically make a copy</span><span id="dx1-317001"/><span class="kobospan" id="kobo.707.1"> of an object. </span><span class="kobospan" id="kobo.707.2">We’ve seen several kinds</span><span id="dx1-317002"/><span class="kobospan" id="kobo.708.1"> of syntax for making a copy:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.709.1">Sequences – </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.710.1">list</span></span></span></span><span class="kobospan" id="kobo.711.1">, as well as the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.712.1">str</span></span></span></span><span class="kobospan" id="kobo.713.1">, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.714.1">bytes</span></span></span></span><span class="kobospan" id="kobo.715.1">, and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.716.1">tuple</span></span></span></span><span class="kobospan" id="kobo.717.1"> types: we can use </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.718.1">sequence[:]</span></span></span></span><span class="kobospan" id="kobo.719.1"> to copy a sequence by using an empty slice expression. </span><span class="kobospan" id="kobo.719.2">This is a special case for sequences.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.720.1">Almost all collections have a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.721.1">copy()</span></span></span></span><span class="kobospan" id="kobo.722.1"> method.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.723.1">Calling a type, with an instance of the type as the only argument, returns a copy. </span><span class="kobospan" id="kobo.723.2">For example, if </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.724.1">d</span></span></span></span><span class="kobospan" id="kobo.725.1"> is a dictionary, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.726.1">dict(d)</span></span></span></span><span class="kobospan" id="kobo.727.1"> will create a shallow copy of d.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.728.1">What’s important is that these are all </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.729.1">shallow </span></span><span class="kobospan" id="kobo.730.1">copies. </span><span class="kobospan" id="kobo.730.2">When two collections are shallow copies, they each contain references to the same underlying objects. </span><span class="kobospan" id="kobo.730.3">If the underlying objects are immutable, such as tuples, numbers, or strings, this distinction doesn’t matter.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.731.1">For example, if we have </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.732.1">a</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.733.1"> =</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.734.1"> [1,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.735.1"> 1,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.736.1"> 2,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.737.1"> 3]</span></span></span></span><span class="kobospan" id="kobo.738.1">, we can’t perform any mutation on </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.739.1">a[0]</span></span></span></span><span class="kobospan" id="kobo.740.1">. </span><span class="kobospan" id="kobo.740.2">The number 1 in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.741.1">a[0]</span></span></span></span><span class="kobospan" id="kobo.742.1"> has no internal state. </span><span class="kobospan" id="kobo.742.2">We can only replace the object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.743.1">Questions arise, however, when we have a collection that involves mutable objects. </span><span class="kobospan" id="kobo.743.2">First, we’ll create an object, then we’ll create a copy:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.744.1">&gt;&gt;&gt; some_dict = {’a’: [1, 1, 2, 3]} 
 
&gt;&gt;&gt; another_dict = some_dict.copy()</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.745.1">This example created a shallow copy of the dictionary. </span><span class="kobospan" id="kobo.745.2">The two copies will look alike because they both contain references to the same objects. </span><span class="kobospan" id="kobo.745.3">There’s a shared reference to the immutable string </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.746.1">’a’</span></span></span></span><span class="kobospan" id="kobo.747.1"> and a shared reference to the mutable list </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.748.1">[1,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.749.1"> 1,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.750.1"> 2,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.751.1"> 3]</span></span></span></span><span class="kobospan" id="kobo.752.1">. </span><span class="kobospan" id="kobo.752.2">We can display the value of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.753.1">another_dict</span></span></span></span><span class="kobospan" id="kobo.754.1"> to see that it looks like the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.755.1">some_dict</span></span></span></span><span class="kobospan" id="kobo.756.1"> object we started with:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.757.1">&gt;&gt;&gt; another_dict 
 
{’a’: [1, 1, 2, 3]}</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.758.1">Here’s what happens when we update</span><span id="dx1-317009"/><span class="kobospan" id="kobo.759.1"> the shared list that’s inside</span><span id="dx1-317010"/><span class="kobospan" id="kobo.760.1"> the copy of the dictionary. </span><span class="kobospan" id="kobo.760.2">We’ll change the value of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.761.1">some_dict</span></span></span></span><span class="kobospan" id="kobo.762.1"> and see the results are also present in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.763.1">another_dict</span></span></span></span><span class="kobospan" id="kobo.764.1">:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.765.1">&gt;&gt;&gt; some_dict[’a’].append(5) 
 
&gt;&gt;&gt; another_dict 
 
{’a’: [1, 1, 2, 3, 5]}</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.766.1">We can see that the item is shared by using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.767.1">id()</span></span></span></span><span class="kobospan" id="kobo.768.1"> function:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.769.1">&gt;&gt;&gt; id(some_dict[’a’]) == id(another_dict[’a’]) 
 
True</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.770.1">Because the two </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.771.1">id()</span></span></span></span><span class="kobospan" id="kobo.772.1"> values are the same, these are the same underlying object. </span><span class="kobospan" id="kobo.772.2">The value associated with the key </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.773.1">’a’</span></span></span></span><span class="kobospan" id="kobo.774.1"> is the same mutable list in both </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.775.1">some_dict</span></span></span></span><span class="kobospan" id="kobo.776.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.777.1">another_dict</span></span></span></span><span class="kobospan" id="kobo.778.1">. </span><span class="kobospan" id="kobo.778.2">We can also use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.779.1">is</span></span></span></span><span class="kobospan" id="kobo.780.1"> operator to see that they’re the same object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.781.1">This mutation of a shallow copy works for list collections that contain all other mutable object types as items as well:</span></p>
<p class="normal1"><span class="kobospan" id="kobo.782.1">Because we can’t make a set of mutable objects, we don’t really have to consider making shallow copies of sets that share items.</span></p>
<div class="tipbox" id="tcolobox-11">
<div class="note">
<p class="normal1"><span class="kobospan" id="kobo.783.1">A tuple</span><span id="dx1-317018"/><span class="kobospan" id="kobo.784.1"> can contain mutable objects. </span><span class="kobospan" id="kobo.784.2">While the tuple is immutable, the objects inside it are mutable.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.785.1">The immutability of a tuple does not magically propagate to the items within the tuple.</span></p>
</div>
</div>
<p class="normal1"><span class="kobospan" id="kobo.786.1">What if we want to completely disconnect two copies? </span><span class="kobospan" id="kobo.786.2">How do we make a deep copy instead of a shallow copy? </span><span id="x1-317019r627"/></p>
</section>
<section data-number="0.8.5.2" id="how-to-do-it...-43">
<h2 class="likechapterhead" data-number="0.8.5.2"><span><span class="kobospan" id="kobo.787.1">5.5.2 </span></span> <span id="x1-3180002"/><span class="kobospan" id="kobo.788.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.789.1">Python generally works by sharing</span><span id="dx1-318001"/><span class="kobospan" id="kobo.790.1"> references. </span><span class="kobospan" id="kobo.790.2">It makes copies</span><span id="dx1-318002"/><span class="kobospan" id="kobo.791.1"> of objects reluctantly. </span><span class="kobospan" id="kobo.791.2">The default behavior is to make a shallow copy, sharing references to the items within a collection. </span><span class="kobospan" id="kobo.791.3">Here’s how we make deep copies:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-318004x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.792.1">Import the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.793.1">copy</span></span></span></span><span class="kobospan" id="kobo.794.1"> module:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.795.1">&gt;&gt;&gt; import copy</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-318008x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.796.1">Use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.797.1">copy.deepcopy()</span></span></span></span><span class="kobospan" id="kobo.798.1"> function to duplicate an object and all of the mutable items contained within that object:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.799.1">&gt;&gt;&gt; some_dict = {’a’: [1, 1, 2, 3]} 
 
&gt;&gt;&gt; another_dict = copy.deepcopy(some_dict)</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.800.1">This will create copies that have no shared references. </span><span class="kobospan" id="kobo.800.2">A change to one copy’s mutable internal items won’t have any effect anywhere else:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.801.1">&gt;&gt;&gt; some_dict[’a’].append(5) 
 
&gt;&gt;&gt; some_dict 
 
{’a’: [1, 1, 2, 3, 5]} 
 
&gt;&gt;&gt; another_dict 
 
{’a’: [1, 1, 2, 3]}</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.802.1">We updated an item in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.803.1">some_dict</span></span></span></span><span class="kobospan" id="kobo.804.1"> and it had no effect on the copy in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.805.1">another_dict</span></span></span></span><span class="kobospan" id="kobo.806.1">. </span><span class="kobospan" id="kobo.806.2">We can see that the objects are distinct with the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.807.1">id()</span></span></span></span><span class="kobospan" id="kobo.808.1"> function:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.809.1">&gt;&gt;&gt; id(some_dict[’a’]) == id(another_dict[’a’]) 
 
False</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.810.1">Since the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.811.1">id()</span></span></span></span><span class="kobospan" id="kobo.812.1"> values are different, these are distinct objects. </span><span class="kobospan" id="kobo.812.2">We can also use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.813.1">is</span></span></span></span><span class="kobospan" id="kobo.814.1"> operator to see that they’re distinct objects. </span><span id="x1-318022r632"/></p>
</section>
<section data-number="0.8.5.3" id="how-it-works...-43">
<h2 class="likechapterhead" data-number="0.8.5.3"><span><span class="kobospan" id="kobo.815.1">5.5.3 </span></span> <span id="x1-3190003"/><span class="kobospan" id="kobo.816.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.817.1">Making a shallow</span><span id="dx1-319001"/><span class="kobospan" id="kobo.818.1"> copy is relatively</span><span id="dx1-319002"/><span class="kobospan" id="kobo.819.1"> easy. </span><span class="kobospan" id="kobo.819.2">We can even write our own version of the algorithm using comprehensions (containing generator expressions):</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.820.1">&gt;&gt;&gt; copy_of_list = [item for item in some_list] 
 
&gt;&gt;&gt; copy_of_dict = {key:value for key, value in some_dict.items()}</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.821.1">In the list case, the items for the new list are references to the items in the source list. </span><span class="kobospan" id="kobo.821.2">Similarly, in the dict case, the keys and values are references to the keys and values of the source dictionary.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.822.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.823.1">deepcopy()</span></span></span></span><span class="kobospan" id="kobo.824.1"> function uses a recursive algorithm to look inside each item that’s a mutable collection.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.825.1">For an object with a list type, the conceptual algorithm is something like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.826.1">from typing import Any 
 
 
 
def deepcopy_json(some_obj: Any) -&gt; Any: 
 
    match some_obj: 
 
        case int() | float() | tuple() | str() | bytes() | None: 
 
            return some_obj 
 
        case list() as some_list: 
 
            list_copy: list[Any] = [] 
 
            for item in some_list: 
 
                list_copy.append(deepcopy_json(item)) 
 
            return list_copy 
 
        case dict() as some_dict: 
 
            dict_copy: dict[Any, Any] = {} 
 
            for key in some_dict: 
 
                dict_copy[key] = deepcopy_json(some_dict[key]) 
 
            return dict_copy 
 
        case _: 
 
            raise ValueError(f"can’t copy {type(some_obj)}")
                                                                     

                                                                     </span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.827.1">This can be used for the collection of types used in JSON documents. </span><span class="kobospan" id="kobo.827.2">For the immutable types in the first </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.828.1">case</span></span></span></span><span class="kobospan" id="kobo.829.1"> clause, there’s no need to make a copy; an object of one of these types cannot be mutated. </span><span class="kobospan" id="kobo.829.2">For the two mutable types used in JSON documents, empty structures are built, and then copies of each item are inserted. </span><span class="kobospan" id="kobo.829.3">The processing involves recursion to assure that — no matter how deeply nested — all items that are mutable are copied.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.830.1">The actual implementation</span><span id="dx1-319025"/><span class="kobospan" id="kobo.831.1"> of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.832.1">deepcopy()</span></span></span></span><span class="kobospan" id="kobo.833.1"> function</span><span id="dx1-319026"/><span class="kobospan" id="kobo.834.1"> handles additional types, not part of the JSON specification. </span><span class="kobospan" id="kobo.834.2">The point of this example is to show the general idea of a deep copy function. </span><span id="x1-319027r637"/></p>
</section>
<section data-number="0.8.5.4" id="see-also-42">
<h2 class="likechapterhead" data-number="0.8.5.4"><span><span class="kobospan" id="kobo.835.1">5.5.4 </span></span> <span id="x1-3200004"/><span class="kobospan" id="kobo.836.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.837.1">In the </span><a href="ch009.xhtml#x1-3100004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.838.1">Understanding variables, references, and assignment</span></span></a><span class="kobospan" id="kobo.839.1"> recipe, we look at how Python prefers to create references to objects.</span></p></li>
</ul>
<p class="normal1"><span id="x1-320001r625"/></p>
</section>
</section>
<section data-number="0.8.6" id="avoiding-mutable-default-values-for-function-parameters">
<h1 class="unnumbered" data-number="0.8.6"><span><span class="kobospan" id="kobo.840.1">5.6 </span></span> <span id="x1-3210006"/><span class="kobospan" id="kobo.841.1">Avoiding mutable default values for function parameters</span></h1>
<p class="normal"><span class="kobospan" id="kobo.842.1">In </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.843.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.844.1"> </span></span><a href="ch007_split_000.xhtml#x1-1610003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.845.1">3</span></span></a><span class="kobospan" id="kobo.846.1">, we looked at many aspects of Python</span><span id="dx1-321001"/><span class="kobospan" id="kobo.847.1"> function definitions. </span><span class="kobospan" id="kobo.847.2">In the </span><a href="ch007_split_000.xhtml#x1-1680002" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.848.1">Designing functions with optional parameters</span></span></a><span class="kobospan" id="kobo.849.1"> recipe, we showed a recipe</span><span id="dx1-321002"/><span class="kobospan" id="kobo.850.1"> for handling optional parameters. </span><span class="kobospan" id="kobo.850.2">At the time, we didn’t dwell on the issue of providing a reference to a mutable structure as a default. </span><span class="kobospan" id="kobo.850.3">We’ll take a close look at the consequences of a mutable default value for a function parameter. </span><span id="x1-321003r640"/></p>
<section data-number="0.8.6.1" id="getting-ready-44">
<h2 class="likechapterhead" data-number="0.8.6.1"><span><span class="kobospan" id="kobo.851.1">5.6.1 </span></span> <span id="x1-3220001"/><span class="kobospan" id="kobo.852.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.853.1">Let’s imagine a function that either creates or updates a mutable </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.854.1">Counter</span></span></span></span><span class="kobospan" id="kobo.855.1"> object. </span><span class="kobospan" id="kobo.855.2">We’ll call it </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.856.1">gather_stats()</span></span></span></span><span class="kobospan" id="kobo.857.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.858.1">Ideally, a small data gathering function could look like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.859.1">from collections import Counter 
 
from random import randint, seed 
 
 
 
def gather_stats_bad( 
 
    n: int, 
 
    samples: int = 1000, 
 
    summary: Counter[int] = Counter() 
 
) -&gt; Counter[int]: 
 
    summary.update( 
 
      sum(randint(1, 6) 
 
      for d in range(n)) for _ in range(samples) 
 
    ) 
 
    return summary</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.860.1">This shows a </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.861.1">bad </span></span><span class="kobospan" id="kobo.862.1">design for a function. </span><span class="kobospan" id="kobo.862.2">It has two scenarios:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-322016x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.863.1">The first scenario offers no argument value for the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.864.1">summary</span></span></span></span><span class="kobospan" id="kobo.865.1"> parameter. </span><span class="kobospan" id="kobo.865.2">When this is omitted, the function creates and returns a collection of statistics. </span><span class="kobospan" id="kobo.865.3">Here’s the example of this story:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.866.1">&gt;&gt;&gt; seed(1) 
 
&gt;&gt;&gt; s1 = gather_stats_bad(2) 
 
&gt;&gt;&gt; s1 
 
Counter({7: 168, 6: 147, 8: 136, 9: 114, 5: 110, 10: 77, 11: 71, 4: 70, 3: 52, 12: 29, 2: 26})</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-322023x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.867.1">The second scenario allows us to provide an explicit argument value for the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.868.1">summary</span></span></span></span><span class="kobospan" id="kobo.869.1"> parameter. </span><span class="kobospan" id="kobo.869.2">When this argument is provided, this function updates the given object. </span><span class="kobospan" id="kobo.869.3">Here’s an example of this story:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.870.1">&gt;&gt;&gt; seed(1) 
 
&gt;&gt;&gt; mc = Counter() 
 
&gt;&gt;&gt; gather_stats_bad(2, summary=mc) 
 
Counter... 
 
&gt;&gt;&gt; mc 
 
Counter({7: 168, 6: 147, 8: 136, 9: 114, 5: 110, 10: 77, 11: 71, 4: 70, 3: 52, 12: 29, 2: 26})</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.871.1">We’ve set the random</span><span id="dx1-322031"/><span class="kobospan" id="kobo.872.1"> number seed to be sure that the two sequences</span><span id="dx1-322032"/><span class="kobospan" id="kobo.873.1"> of random values are identical. </span><span class="kobospan" id="kobo.873.2">We provided a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.874.1">Counter</span></span></span></span><span class="kobospan" id="kobo.875.1"> object to confirm that the results are identical.</span></p>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.876.1">The problem arises when we do the following operation after the first scenario shown above:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.877.1">&gt;&gt;&gt; seed(1) 
 
&gt;&gt;&gt; s3b = gather_stats_bad(2) 
 
&gt;&gt;&gt; s3b 
 
Counter({7: 336, 6: 294, 8: 272, 9: 228, 5: 220, 10: 154, 11: 142, 4: 140, 3: 104, 12: 58, 2: 52})</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.878.1">The values in this example are incorrect. </span><span class="kobospan" id="kobo.878.2">They’re doubled. </span><span class="kobospan" id="kobo.878.3">Something has gone wrong. </span><span class="kobospan" id="kobo.878.4">This only happens when we use the default scenario more than once. </span><span class="kobospan" id="kobo.878.5">This code can pass a simple unit test suite and </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.879.1">appear</span></span><span class="kobospan" id="kobo.880.1"> correct.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.881.1">As we saw in the </span><a href="ch009.xhtml#x1-3160005" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.882.1">Making shallow and deep copies of objects</span></span></a><span class="kobospan" id="kobo.883.1"> recipe, Python prefers to share references. </span><span class="kobospan" id="kobo.883.2">A consequence of that sharing is the object referenced by the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.884.1">s1</span></span></span></span><span class="kobospan" id="kobo.885.1"> variable and the object referenced by the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.886.1">s3b</span></span></span></span><span class="kobospan" id="kobo.887.1"> variable are the same object:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.888.1">&gt;&gt;&gt; s1 is s3b 
 
True</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.889.1">This means the value of the object referred to by the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.890.1">s1</span></span></span></span><span class="kobospan" id="kobo.891.1"> variable changed when the object for the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.892.1">s3b</span></span></span></span><span class="kobospan" id="kobo.893.1"> variable was created. </span><span class="kobospan" id="kobo.893.2">From this, it should be apparent the function is updating a single, shared collection object and returning the reference to the shared collection.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.894.1">The default value used for the summary parameter of this </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.895.1">gather_stats_bad()</span></span></span></span><span class="kobospan" id="kobo.896.1"> function leads to result values built from a single, shared object. </span><span class="kobospan" id="kobo.896.2">How can we avoid this? </span><span id="x1-322041r642"/></p>
</section>
<section data-number="0.8.6.2" id="how-to-do-it...-44">
<h2 class="likechapterhead" data-number="0.8.6.2"><span><span class="kobospan" id="kobo.897.1">5.6.2 </span></span> <span id="x1-3230002"/><span class="kobospan" id="kobo.898.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.899.1">There are two approaches</span><span id="dx1-323001"/><span class="kobospan" id="kobo.900.1"> to solving this problem</span><span id="dx1-323002"/><span class="kobospan" id="kobo.901.1"> of a mutable default parameter:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.902.1">Provide an immutable default.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.903.1">Change the design.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.904.1">We’ll look at the immutable default first. </span><span class="kobospan" id="kobo.904.2">Changing the design is generally a better idea. </span><span class="kobospan" id="kobo.904.3">In order to see why it’s better to change the design, we’ll show a purely technical solution.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.905.1">When we provide default values for functions, the default object is created exactly once and shared forever after. </span><span class="kobospan" id="kobo.905.2">Here’s the alternative:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-323004x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.906.1">Replace any mutable default parameter value with </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.907.1">None</span></span></span></span><span class="kobospan" id="kobo.908.1">:</span></p>
<pre class="programlisting" id="listing-35"><code class="calibre13"><span class="kobospan" id="kobo.909.1">def gather_stats_good( 
 
    n: int, 
 
    samples: int = 1000, 
 
    summary: Counter[int] | None = None 
 
) -&gt; Counter[int]:</span></code></pre>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.910.1">
def gather_stats_good( 
 
    n: int, 
 
    summary: Counter[int] | None = None, 
 
    samples: int = 1000, 
 
) -&gt; Counter[int]:</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-323017x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.911.1">Add an </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.912.1">if</span></span></span></span><span class="kobospan" id="kobo.913.1"> statement to check for an argument value of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.914.1">None</span></span></span></span><span class="kobospan" id="kobo.915.1"> and replace it with a fresh, new mutable object of the proper type:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.916.1">
    if summary is None: 
 
        summary = Counter()</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.917.1">This will assure</span><span id="dx1-323021"/><span class="kobospan" id="kobo.918.1"> us that every time the function</span><span id="dx1-323022"/><span class="kobospan" id="kobo.919.1"> is evaluated with no argument value for a parameter, we create a fresh, new mutable object. </span><span class="kobospan" id="kobo.919.2">We will avoid sharing a single mutable object over and over again.</span></p>
</div></li>
</ol>
<p class="normal1"><span id="x1-323023r648"/></p>
</section>
<section data-number="0.8.6.3" id="how-it-works...-44">
<h2 class="likechapterhead" data-number="0.8.6.3"><span><span class="kobospan" id="kobo.920.1">5.6.3 </span></span> <span id="x1-3240003"/><span class="kobospan" id="kobo.921.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.922.1">As we noted earlier, Python prefers to share references. </span><span class="kobospan" id="kobo.922.2">It rarely creates copies of objects without explicit use of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.923.1">copy</span></span></span></span><span class="kobospan" id="kobo.924.1"> module or the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.925.1">copy()</span></span></span></span><span class="kobospan" id="kobo.926.1"> method of an object. </span><span class="kobospan" id="kobo.926.2">Therefore, default values for function parameter values will be shared objects. </span><span class="kobospan" id="kobo.926.3">Python does not create fresh, new objects for default parameter values.</span></p>
<div class="tipbox" id="tcolobox-12">
<div class="note">
<p class="normal1"><span class="kobospan" id="kobo.927.1">Never use mutable defaults for default values of function parameters.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.928.1">Instead of a mutable object (for example, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.929.1">set</span></span></span></span><span class="kobospan" id="kobo.930.1">, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.931.1">list</span></span></span></span><span class="kobospan" id="kobo.932.1">, or </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.933.1">dict</span></span></span></span><span class="kobospan" id="kobo.934.1">) as a default, use </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.935.1">None</span></span></span></span><span class="kobospan" id="kobo.936.1">.</span></p>
</div>
</div>
<p class="normal1"><span class="kobospan" id="kobo.937.1">In most cases, we should consider changing the design to not offer a default value at all. </span><span class="kobospan" id="kobo.937.2">Instead, define two separate functions. </span><span class="kobospan" id="kobo.937.3">One function updates a parameter value, and a second function uses this function but provides a fresh, empty mutable object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.938.1">For this example, they might be called </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.939.1">create_stats()</span></span></span></span><span class="kobospan" id="kobo.940.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.941.1">update_stats()</span></span></span></span><span class="kobospan" id="kobo.942.1">, with unambiguous parameters:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.943.1">def update_stats( 
 
    n: int, 
 
    summary: Counter[int], 
 
    samples: int = 1000, 
 
) -&gt; Counter[int]: 
 
    summary.update( 
 
        sum(randint(1, 6) 
 
        for d in range(n)) for _ in range(samples)) 
 
    return summary 
 
 
 
def create_stats(n: int, samples: int = 1000) -&gt; Counter[int]: 
 
    return update_stats(n, Counter(), samples)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.944.1">Note that the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.945.1">summary</span></span></span></span><span class="kobospan" id="kobo.946.1"> parameter to the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.947.1">update_stats()</span></span></span></span><span class="kobospan" id="kobo.948.1"> function is not optional. </span><span class="kobospan" id="kobo.948.2">Similarly, there is no summary object parameter defined for the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.949.1">create_stats()</span></span></span></span><span class="kobospan" id="kobo.950.1"> function.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.951.1">The idea of optional mutable arguments was not a good idea because the mutable object provided as a default</span><span id="dx1-324015"/><span class="kobospan" id="kobo.952.1"> value for a parameter</span><span id="dx1-324016"/><span class="kobospan" id="kobo.953.1"> is reused. </span><span id="x1-324017r651"/></p>
</section>
<section data-number="0.8.6.4" id="theres-more...-36">
<h2 class="likechapterhead" data-number="0.8.6.4"><span><span class="kobospan" id="kobo.954.1">5.6.4 </span></span> <span id="x1-3250004"/><span class="kobospan" id="kobo.955.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.956.1">In the standard library, there are some examples of a cool technique that shows how we can create fresh default objects. </span><span class="kobospan" id="kobo.956.2">A number of places</span><span id="dx1-325001"/><span class="kobospan" id="kobo.957.1"> use a </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.958.1">factory</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.959.1">function </span></span><span class="kobospan" id="kobo.960.1">as a parameter. </span><span class="kobospan" id="kobo.960.2">This function can be used to create a fresh, new mutable object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.961.1">In order to leverage this design pattern, we need to modify the design of our </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.962.1">update_stats()</span></span></span></span><span class="kobospan" id="kobo.963.1"> function. </span><span class="kobospan" id="kobo.963.2">We will no longer update an existing </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.964.1">Counter</span></span></span></span><span class="kobospan" id="kobo.965.1"> object in the function. </span><span class="kobospan" id="kobo.965.2">We’ll always create a fresh, new object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.966.1">Here’s a function that calls a factory function to create a useful default value:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.967.1">from collections import Counter 
 
from collections.abc import Callable, Iterable, Hashable 
 
from typing import TypeVar, TypeAlias 
 
 
 
T = TypeVar(’T’, bound=Hashable) 
 
Summarizer: TypeAlias = Callable[[Iterable[T]], Counter[T]] 
 
 
 
def gather_stats_flex( 
 
    n: int, 
 
    samples: int = 1000, 
 
    summary_func: Summarizer[int] = Counter 
 
) -&gt; Counter[int]: 
 
    summary = summary_func( 
 
        sum(randint(1, 6) 
 
        for d in range(n)) for _ in range(samples)) 
 
    return summary</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.968.1">For this version, we’ve defined the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.969.1">Summarizer</span></span></span></span><span class="kobospan" id="kobo.970.1"> type to be a function of one argument that will create a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.971.1">Counter</span></span></span></span><span class="kobospan" id="kobo.972.1"> object. </span><span class="kobospan" id="kobo.972.2">The default value uses the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.973.1">Counter</span></span></span></span><span class="kobospan" id="kobo.974.1"> class as the one-argument function. </span><span class="kobospan" id="kobo.974.2">We can override the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.975.1">summary_func</span></span></span></span><span class="kobospan" id="kobo.976.1"> function with any one-argument function that will collect details instead of summarizing.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.977.1">Here’s an example</span><span id="dx1-325019"/><span class="kobospan" id="kobo.978.1"> using </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.979.1">list</span></span></span></span><span class="kobospan" id="kobo.980.1"> instead of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.981.1">collections.Counter</span></span></span></span><span class="kobospan" id="kobo.982.1">:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.983.1">&gt;&gt;&gt; seed(1) 
 
&gt;&gt;&gt; gather_stats_flex(2, 12, summary_func=list) 
 
[7, 4, 5, 8, 10, 3, 5, 8, 6, 10, 9, 7]</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.984.1">In this case, we provided the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.985.1">list</span></span></span></span><span class="kobospan" id="kobo.986.1"> function to create a list with the individual random samples in it.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.987.1">Here’s an example without an argument value. </span><span class="kobospan" id="kobo.987.2">It will create a new </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.988.1">collections.Counter</span></span></span></span><span class="kobospan" id="kobo.989.1"> object each time it’s used:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.990.1">&gt;&gt;&gt; seed(1) 
 
&gt;&gt;&gt; gather_stats_flex(2, 12) 
 
Counter({7: 2, 5: 2, 8: 2, 10: 2, 4: 1, 3: 1, 6: 1, 9: 1})</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.991.1">In this case, we’ve evaluated the function using the default value for </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.992.1">summary_func</span></span></span></span><span class="kobospan" id="kobo.993.1">, which creates a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.994.1">collections.Counter</span></span></span></span><span class="kobospan" id="kobo.995.1"> object from the random samples. </span><span id="x1-325028r653"/></p>
</section>
<section data-number="0.8.6.5" id="see-also-43">
<h2 class="likechapterhead" data-number="0.8.6.5"><span><span class="kobospan" id="kobo.996.1">5.6.5 </span></span> <span id="x1-3260005"/><span class="kobospan" id="kobo.997.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.998.1">See the </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.999.1">Creating dictionaries – inserting and updating </span></span><span class="kobospan" id="kobo.1000.1">recipe, which shows how the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1001.1">defaultdict</span></span></span></span><span class="kobospan" id="kobo.1002.1"> collection works.</span></p></li>
</ul>
<p class="normal1"><span id="x1-326001r641"/></p>
</section>
</section>
<section data-number="0.8.9" id="join-our-community-discord-space-5">
<h1 class="unnumbered" data-number="0.8.9"><span id="x1-3290008"/><span class="kobospan" id="kobo.1003.1">Join our community Discord space</span></h1>
<p class="normal"><span class="kobospan" id="kobo.1004.1">Join our Python Discord workspace to discuss and find out more about the book: </span><a href="https://packt.link/dHrHU" class="url"><span class="url1"><span class="kobospan" id="kobo.1005.1">https://packt.link/dHrHU</span></span></a></p>
<p class="normal1"><span class="kobospan" id="kobo.1006.1"><img alt="PIC" src="../media/file1.png" class="calibre9"/></span></p>
<p class="normal1"><span id="x1-329001r562"/></p>
</section>
</section>
</body></html>