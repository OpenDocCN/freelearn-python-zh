["```py\nfrom sanic.exceptions import SanicException\nclass InsufficientConnection(SanicException):\n    status_code = 400\n    message = \"Selected flights do no leave enough time for connection to be made.\"\n```", "```py\nif there_is_a_pink_elephant():\n    await send_adam_an_email()\n    raise PinkElephantError\n```", "```py\nif there_is_a_pink_elephant():\n    raise PinkElephantError\n```", "```py\nclass PinkElephantError(SanicException):\n    status_code = 4000\n    message = \"There is a pink elephant in the room\"\n@app.on_response\nasync def exception_middleware(request, response):\n    if response.status == 4000:\n        response.status = 400\n        await send_adam_an_email()\n```", "```py\n@app.signal(\"http.lifecycle.exception\")\nasync def exception_signal(request, exception):\n    if isinstance(exception, PinkElephantError):\n        await send_adam_an_email()\n```", "```py\n@app.exception(PinkElephantError)\nasync def handle_pink_elephants(request, exception):\n    ...\n```", "```py\n    class PinkElephantError(SanicException):\n        status_code = 400\n        message = \"There is a pink elephant in the room\"\n        quiet = True\n    @app.get(\"/\", error_format=\"text\")\n    async def handler(request: Request):\n        raise PinkElephantError\n    ```", "```py\n    async def send_adam_an_email():\n        print(\"EMAIL ADAM\")\n    @app.exception(PinkElephantError)\n    async def handle_pink_elephants(request, exception):\n        await send_adam_an_email()\n        return request.app.error_handler.default(request, exception)\n    ```", "```py\n    from sanic.handlers import ErrorHandler\n    class CustomErrorHandler(ErrorHandler):\n        def default(self, request, exception):\n            ...\n    ```", "```py\n    from sanic import Sanic\n    app = Sanic(..., error_handler=CustomErrorHandler())\n    ```", "```py\nDoes this mean that subclassing ErrorHandler is not a worthwhile effort? Of course not. In fact, if you are unhappy with the default error formats that Sanic uses,  I would recommend that you change it using the previous example with CustomErrorHandler. \n```", "```py\n$ pip install sanic-testing pytest\n```", "```py\n    # server.py\n    from sanic import Sanic\n    app = Sanic(__name__)\n    @app.get(\"/\")\n    async def handler(request):\n        return text(\"...\")\n    ```", "```py\n    # conftest.py\n    import pytest\n    from sanic_testing.testing import SanicTestClient\n    from server import app\n    @pytest.fixture\n    def test_client():\n        return SanicTestClient(app)\n    ```", "```py\n    # test_sample.py\n    def test_sample(test_client):\n        request, response = test_client.get(\"/\")\n        assert response.status == 200\n    ```", "```py\n    $ pytest\n    ================= test session starts =================\n    platform linux -- Python 3.9.7, pytest-6.2.5, py-1.11.0, pluggy-1.0.0\n    rootdir: /path/to/testing0\n    plugins: anyio-3.3.4\n    collected 1 item \n    test_sample.py . [100%]\n    ================= 1 passed in 0.09s ===================\n    ```", "```py\nrequest, response = test_client.get(\"/foo\")\nrequest, response = test_client.post(\"/bar\")\n```", "```py\nimport pytest\nfrom server import app as application_instance\n@pytest.fixture\ndef app():\n    return application_instance\n```", "```py\ndef test_sample(app):\n    ...\n```", "```py\n@pytest.fixture\ndef app():\n    print(\"Running before the test\")\n    yield application_instance\n    print(\"Running after the test\")\n```", "```py\ndef test_sample(app: Sanic):\n    request, response = app.test_client.get(\"/\")\n    assert response.status == 200\n```", "```py\n    # conftest.py\n    import pytest\n    from sanic import Sanic\n    @pytest.fixture\n    def dummy_app():\n        return Sanic(\"DummyApp\")\n    ```", "```py\n    # test_some_blueprint.py\n    import pytest\n    from path.to.some_blueprint import bp\n    @pytest.fixture\n    def app_with_bp(dummy_app):\n        dummy_app.blueprint(bp)\n        return dummy_app\n    def test_some_blueprint_foobar(app_with_bp):\n        ...\n    ```", "```py\n    from typing import NamedTuple\n    class ExpectedTypes(NamedTuple):\n        a_string: str\n        an_int: int\n    ```", "```py\n    def _check(\n        exists: bool,\n        value: Any, \n        expected: Type[object],\n    ) -> str:\n        if not exists:\n            return \"missing\"\n        return \"OK\" if type(value) is expected else \"WRONG\"\n    ```", "```py\n    from sanic import Blueprint, Request, json\n    bp = Blueprint(\"Something\", url_prefix=\"/some\")\n    @bp.post(\"/validation\")\n    async def check_types(request: Request):\n        valid = {\n            field_name: _check(\n                field_name in request.json,\n                request.json.get(field_name), field_type\n            )\n            for field_name, field_type in\n            ExpectedTypes.__annotations__.items()\n        }\n        expected_length = len(ExpectedTypes.__annotations__)\n        status = (\n            200\n            if all(value == \"OK\" for value in valid.values())\n            and len(request.json) == expected_length\n            else 400\n        )\n        return json(valid, status=status)\n    ```", "```py\n    def test_some_blueprint_no_missing(app_with_bp):\n        _, response = app_with_bp.test_client.post(\n            \"/some/validation\",\n            json={\n                \"a_string\": \"hello\",\n                \"an_int\": \"999\",\n            },\n        )\n        assert not any(\n            value == \"MISSING\"\n            for value in response.json.values()\n        )\n        assert len(response.json) == 2\n    ```", "```py\n    def test_some_blueprint_correct_data(app_with_bp):\n        _, response = app_with_bp.test_client.post(\n            \"/some/validation\",\n            json={\n                \"a_string\": \"hello\",\n                \"an_int\": 999,\n            },\n        )\n        assert response.status == 200\n    ```", "```py\n    def test_some_blueprint_bad_data(app_with_bp):\n        _, response = app_with_bp.test_client.post(\n            \"/some/validation\",\n            json={\n                \"a_string\": \"hello\",\n                \"an_int\": 999,\n                \"a_bool\": True,\n            },\n        )\n        assert response.status == 400\n    ```", "```py\n    @pytest.mark.parametrize(\n    \"input,has_missing,expected_status\",\n    (\n        (\n            {\n                \"a_string\": \"hello\",\n            }, True, 400,\n        ),\n        (\n            {\n                \"a_string\": \"hello\",\n                \"an_int\": \"999\",\n            }, False, 400,\n        ),\n        (\n            {\n                \"a_string\": \"hello\",\n                \"an_int\": 999,\n            }, False, 200,\n        ),\n        (\n            {\n                \"a_string\": \"hello\",\"an_int\": 999,\n                \"a_bool\": True,\n            }, False, 400,\n        ),\n    ),\n    )\n    ```", "```py\n    def test_some_blueprint_data_validation(\n        app_with_bp,\n        input,\n        has_missing,\n        expected_status,\n    ):\n        _, response = app_with_bp.test_client.post(\n            \"/some/validation\",\n            json=input,\n        )\n        assert any(\n            value == \"MISSING\"\n            for value in response.json.values()\n        ) is has_missing\n        assert response.status == expected_status\n    ```", "```py\n    @bp.post(\"/\")\n    async def check_types(request: Request):\n        _validate(request.json, RegistrationSchema)\n        connection: FakeDBConnection = request.app.ctx.db\n        service = RegistrationService(connection)\n        await service.register_user(request.json[\"username\"], request.json[\"email\"])\n        return json(True, status=201)\n    ```", "```py\n    from .some_db_connection import FakeDBConnection\n    class RegistrationService:\n        def __init__(self, connection: FakeDBConnection) -> None:\n            self.connection = connection\n        async def register_user(\n            self, username: str, email: str\n        ) -> None:\n            query = \"INSERT INTO users VALUES ($1, $2);\"\n            await self.connection.execute(query, username, email)\n    ```", "```py\n    from typing import Any\n    class FakeDBConnection:\n        async def execute(self, query: str, *params: Any):\n            ...\n    ```", "```py\n    from sanic import Sanic\n    from .some_db_connection import FakeDBConnection\n    app = Sanic.get_app()\n    @app.before_server_start\n    async def setup_db_connection(app, _):\n        app.ctx.db = FakeDBConnection()\n    ```", "```py\n    @pytest.fixture\n    def dummy_app():\n        app = Sanic(\"DummyApp\")\n        import_module(\"testing3.path.to.some_startup\")\n        return app\n    ```", "```py\n    from unittest.mock import AsyncMock\n    @pytest.fixture\n    def mocked_execute(monkeypatch):\n        execute = AsyncMock()\n        monkeypatch.setattr(\n            testing3.path.to.some_db_connection.FakeDBConnection, \"execute\", execute\n        )\n        return execute\n    ```", "```py\n    @pytest.mark.parametrize(\n        \"input,expected_status\",\n        (\n            (\n                {\n                    \"username\": \"Alice\",\n                    \"email\": \"alice@bob.com\",\n                },\n                201,\n            ),\n        ),\n    )\n    def test_some_blueprint_data_validation(\n        app_with_bp,\n        mocked_execute,\n        input,\n        expected_status,\n    ):\n        _, response = app_with_bp.test_client.post(\n            \"/registration\",\n            json=input,\n        )\n        assert response.status == expected_status\n        if expected_status == 201:\n            mocked_execute.assert_awaited_with(\n                \"INSERT INTO users VALUES ($1, $2);\", input[\"username\"], input[\"email\"]\n            )\n    ```", "```py\nfrom time import time\nfrom sanic import Sanic\napp = Sanic.get_app()\n@app.on_request\nasync def start_timer(request: Request) -> None:\n    request.ctx.start_time = time()\n@app.on_response\nasync def stop_timer(request: Request, _) -> None:\n    end_time = time()\n    total = end_time - request.ctx.start_time\n    async send_the_value_somewhere(total)\n```", "```py\nif app.config.ENVIRONMENT == \"PRODUCTION\":\n    ...\n```", "```py\nfrom importlib import import_module\nfrom typing import Optional, Sequence\nfrom sanic import Sanic\nDEFAULT = (\"path.to.some_middleware.py\",)\ndef create_app(modules: Optional[Sequence[str]] = None) -> Sanic:\n    app = Sanic(\"MyApp\")\n    if modules is None:\n        modules = DEFAULT\n    for module in modules:\n        import_module(module)\n    return app\n```", "```py\nfrom path.to.factory import create_app\n@pytest.fixture\ndef dummy_app():\n    return create_app(modules=[])\n```", "```py\n    from sanic import Sanic, Request, json\n    from itertools import count\n    app = Sanic(\"test\")\n    @app.before_server_start\n    def setup(app, _):\n        app.ctx.counter = count()\n    @app.get(\"\")\n    async def handler(request: Request):\n        return json(next(request.app.ctx.counter))\n    ```", "```py\n    from sanic_testing.reusable import ReusableClient\n    def test_reusable_context():\n        client = ReusableClient(app, host=\"localhost\", port=9999)\n        with client:\n            _, response = client.get(\"/\")\n            assert response.json == 0\n            _, response = client.get(\"/\")\n            assert response.json == 1\n            _, response = client.get(\"/\")\n            assert response.json == 2\n    ```", "```py\n    from sanic_testing.reusable import ReusableClient\n    import pytest\n    @pytest.fixture\n    def test_client():\n        client = ReusableClient(app, host=\"localhost\", port=9999)\n        client.run()\n        yield client\n        client.stop()\n    ```", "```py\n    def test_reusable_fixture(test_client):\n        _, response = test_client.get(\"/\")\n        assert response.json == 0\n        _, response = test_client.get(\"/\")\n        assert response.json == 1\n        _, response = test_client.get(\"/\")\n        assert response.json == 2\n    ```", "```py\n    @pytest.fixture(scope=\"session\")\n    def test_client():\n        client = ReusableClient(app, host=\"localhost\", port=9999)\n        client.run()\n        yield client\n        client.stop()\n    ```", "```py\naccess_logger.info(\"\")\n```", "```py\n[2021-10-21 09:39:14 +0300] - (sanic.access)[INFO][127.0.0.1:58388]: GET http://localhost:9999/  200 13\n```", "```py\nlog.info(\"Some message\", extra={\"arbitrary\": \"data\"})\n```", "```py\nfrom sanic.log import access_logger, error_logger, logger\n```", "```py\n    .\n    ├── Dockerfile\n    ├── myapp\n    │   ├── common\n    │   │   ├── __init__.py\n    │   │   └── log.py\n    │   ├── __init__.py\n    │   └── server.py\n    └── tests\n    ```", "```py\n    from sanic import Sanic, text\n    from myapp.common.log import setup_logging, app_logger\n    def create_app():\n        app = Sanic(__name__)\n        setup_logging()\n        @app.route(\"\")\n        async def dummy(_):\n            app_logger.debug(\"This is a DEBUG message\")\n            app_logger.info(\"This is a INFO message\")\n            app_logger.warning(\"This is a WARNING message\")\n            app_logger.error(\"This is a ERROR message\")\n            app_logger.critical(\"This is a CRITICAL message\")\n            return text(\"\")\n        return app\n    ```", "```py\n    from logging import getLogger\n    logger = getLogger(__name__)\n    ```", "```py\n    from logging import getLogger\n    logger = getLogger(\"myapplogger\")\n    ```", "```py\n    import logging\n    app_logger = logging.getLogger(\"myapplogger\")\n    def setup_logging():\n        ...\n    ```", "```py\n    $ sanic src.server:app -p 7777 --debug --workers=2\n    ```", "```py\n    $ sanic myapp.server:create_app --factory -p 7777 --debug --workers=2\n    ```", "```py\nThis is a WARNING message\nThis is a ERROR message\nThis is a CRITICAL message\n```", "```py\n    DEFAULT_LOGGING_FORMAT = \"[%(asctime)s] [%(levelname)s] [%(filename)s:%(lineno)s] %(message)s\"\n    def setup_logging(app: Sanic):\n        formatter = logging.Formatter(\n            fmt=app.config.get(\"LOGGING_FORMAT\", DEFAULT_LOGGING_FORMAT),\n            datefmt=\"%Y-%m-%d %H:%M:%S %z\",\n        )\n        handler = logging.StreamHandler()\n        handler.setFormatter(formatter)\n        app_logger.addHandler(handler)\n    ```", "```py\n    from sanic.log import logger, error_logger\n    def setup_logging(app: Sanic):\n        ...\n        logger.handlers = app_logger.handlers\n        error_logger.handlers = app_logger.handlers\n    ```", "```py\n    def setup_logging(app: Sanic):\n        formatter = logging.Formatter(\n            fmt=app.config.get(\"LOGGING_FORMAT\", DEFAULT_LOGGING_FORMAT),\n            datefmt=\"%Y-%m-%d %H:%M:%S %z\",\n        )\n        handler = logging.StreamHandler()\n        handler.setFormatter(formatter)\n        app_logger.addHandler(handler)\n        if app.config.get(\"ENVIRONMENT\", \"local\") == \"production\":\n            file_handler = logging.FileHandler(\"output.log\")\n            file_handler.setFormatter(formatter)\n            app_logger.addHandler(file_handler)\n    ```", "```py\n    class ColorFormatter(logging.Formatter):\n        COLORS = {\n            \"DEBUG\": \"\\033[34m\",\n            \"WARNING\": \"\\033[01;33m\",\n            \"ERROR\": \"\\033[01;31m\",\n            \"CRITICAL\": \"\\033[02;47m\\033[01;31m\",\n        }\n        def format(self, record) -> str:\n            prefix = self.COLORS.get(record.levelname)\n            message = super().format(record)\n            if prefix:\n                message = f\"{prefix}{message}\\033[0m\"\n            return message\n    ```", "```py\n    import sys\n    def _get_formatter(is_local, fmt, datefmt):\n        formatter_type = logging.Formatter\n        if is_local and sys.stdout.isatty():\n            formatter_type = ColorFormatter\n        return formatter_type(\n            fmt=fmt,\n            datefmt=datefmt,\n        )\n    ```", "```py\n    DEFAULT_LOGGING_FORMAT = \"[%(asctime)s] [%(levelname)s] [%(filename)s:%(lineno)s] %(message)s\"\n    DEFAULT_LOGGING_DATEFORMAT = \"%Y-%m-%d %H:%M:%S %z\"\n    def setup_logging(app: Sanic):\n        environment = app.config.get(\"ENVIRONMENT\", \"local\")\n        logging_level = app.config.get(\n            \"LOGGING_LEVEL\", logging.DEBUG if environment == \"local\" else logging.INFO\n        )\n        fmt = app.config.get(\"LOGGING_FORMAT\", DEFAULT_LOGGING_FORMAT)\n        datefmt = app.config.get(\"LOGGING_DATEFORMAT\", DEFAULT_LOGGING_DATEFORMAT)\n        formatter = _get_formatter(environment == \"local\", fmt, datefmt)\n        ...\n    ```", "```py\n    from contextvars import ContextVar\n    from sanic import Request, Sanic\n    app = Sanic.get_app()\n    @app.after_server_start\n    async def setup_request_context(app, _):\n        app.ctx.request = ContextVar(\"request\")\n    @app.on_request\n    async def attach_request(request: Request):\n        request.app.ctx.request.set(request)\n    ```", "```py\n    old_factory = logging.getLogRecordFactory()\n    def _record_factory(*args, app, **kwargs):\n        record = old_factory(*args, **kwargs)\n        record.request_info = \"\"\n        if hasattr(app.ctx, \"request\"):\n            request = app.ctx.request.get(None)\n            if request:\n                display = \" \".join([str(request.id), request.method, request.path])\n                record.request_info = f\"[{display}] \"\n        return record\n    ```", "```py\n    DEFAULT_LOGGING_FORMAT = \"[%(asctime)s] [%(levelname)s] [%(filename)s:%(lineno)s] %(request_info)s%(message)s\"\n    ```", "```py\n    from functools import partial\n    def setup_logging(app: Sanic):\n        ...\n        logging.setLogRecordFactory(partial(_record_factory, app=app))\n    ```", "```py\n    [2021-10-21 12:22:48 +0300] [DEBUG] [server.py:12] [b5e7da51-68b0-4add-a850-9855c0a16814 GET /] This is a DEBUG message\n    [2021-10-21 12:22:48 +0300] [INFO] [server.py:13] [b5e7da51-68b0-4add-a850-9855c0a16814 GET /] This is a INFO message\n    [2021-10-21 12:22:48 +0300] [WARNING] [server.py:14] [b5e7da51-68b0-4add-a850-9855c0a16814 GET /] This is a WARNING message\n    [2021-10-21 12:22:48 +0300] [ERROR] [server.py:15] [b5e7da51-68b0-4add-a850-9855c0a16814 GET /] This is a ERROR message\n    [2021-10-21 12:22:48 +0300] [CRITICAL] [server.py:16] [b5e7da51-68b0-4add-a850-9855c0a16814 GET /] This is a CRITICAL message\n    ```", "```py\n$ curl localhost:7777 -H 'x-request-id: abc123'\n```", "```py\n[2021-10-21 12:36:00 +0300] [DEBUG] [server.py:12] [abc123 GET /] This is a DEBUG message\n[2021-10-21 12:36:00 +0300] [INFO] [server.py:13] [abc123 GET /] This is a INFO message\n[2021-10-21 12:36:00 +0300] [WARNING] [server.py:14] [abc123 GET /] This is a WARNING message\n[2021-10-21 12:36:00 +0300] [ERROR] [server.py:15] [abc123 GET /] This is a ERROR message\n[2021-10-21 12:36:00 +0300] [CRITICAL] [server.py:16] [abc123 GET /] This is a CRITICAL message\n```", "```py\n    # ./application/hiking/worker/postgres.py\n    @app.before_server_start\n    async def setup_postgres(app, _):\n        app.ctx.postgres = Database(\n            app.config.POSTGRES_DSN,\n            min_size=app.config.POSTGRES_MIN,\n            max_size=app.config.POSTGRES_MAX,\n        )\n    @app.after_server_start\n    async def connect_postgres(app, _):\n        await app.ctx.postgres.connect()\n    @app.after_server_stop\n    async def shutdown_postgres(app, _):\n        await app.ctx.postgres.disconnect()\n    ```", "```py\n    from sanic import Blueprint, json, Request\n    from sanic.views import HTTPMethodView\n    from .executor import TrailExecutor\n    bp = Blueprint(\"Trails\", url_prefix=\"/trails\")\n    class TrailListView(HTTPMethodView, attach=bp):\n        async def get(self, request: Request):\n            executor = TrailExecutor(request.app.ctx.postgres)\n            trails = await executor.get_all_trails()\n            return json({\"trails\": trails})\n    ```", "```py\n    executor = FoobarExecutor(app.ctx.postgres)\n    await executor.update_foo(value=3.141593)\n    await executor.update_bar(value=1.618034)\n    ```", "```py\nexecutor = FoobarExecutor(app.ctx.postgres)\nasync with app.ctx.postgres.transaction():\n    await executor.update_foo(value=3.141593)\n    await executor.update_bar(value=1.618034)\n```", "```py\n    @app.get(\"/slow\")\n    async def wow_super_slow(request):\n        wait_time = 0\n        for _ in range(10):\n            t = random.random()\n            await asyncio.sleep(t)\n            wait_time += t\n        return text(f\"Wow, that took {wait_time:.2f}s!\")\n    ```", "```py\n    $ curl localhost:7777/slow\n    Wow, that took 5.87s!\n    ```", "```py\n    $ pip install aioredis\n    ```", "```py\n    from sanic import Sanic\n    import aioredis\n    app = Sanic.get_app()\n    @app.before_server_start\n    async def setup_redis(app, _):\n        app.ctx.redis_pool = aioredis.BlockingConnectionPool.from_url(\n            app.config.REDIS_DSN, max_connections=app.config.REDIS_MAX\n        )\n        app.ctx.redis = aioredis.Redis(connection_pool=app.ctx.redis_pool)\n    @app.after_server_stop\n    async def shutdown_redis(app, _):\n        await app.ctx.redis_pool.disconnect()\n    ```", "```py\n    def cache_response(build_key, exp: int = 60 * 60 * 72):\n        def decorator(f):\n            @wraps(f)\n            async def decorated_function(request, *handler_args, **handler_kwargs):\n                cache: Redis = request.app.ctx.redis\n                key = make_key(build_key, request)\n                if cached_response := await get_cached_response(request, cache, key):\n                    response = raw(**cached_response)\n                else:\n                    response = await f(request, *handler_args, **handler_kwargs)\n                    await set_cached_response(response, cache, key, exp)\n                return response\n            return decorated_function\n        return decorator\n    ```", "```py\n    $ curl localhost:7777/v1/slow\n    Wow, that took 5.67s!\n    status=200  size=21 time=5.686937 content-type=\"text/plain; charset=utf-8\"\n    ```", "```py\n    $ curl localhost:7777/v1/slow           \n    Wow, that took 5.67s!\n    status=200  size=21 time=0.004090 content-type=\"text/plain; charset=utf-8\"\n    ```"]