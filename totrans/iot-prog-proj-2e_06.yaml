- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an IoT Alarm Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored the Raspberry Pi’s GPIO port and built
    a basic alarm system. We learned about different communication protocols and worked
    with a set of sensors, which we accessed using the GPIO port. In this chapter,
    we will enhance our basic alarm system using a Raspberry Pi Pico W, a public **Message
    Queuing Telemetry Transport** (**MQTT**) server, and the MQTTHQ web client (*Figure
    6**.1*).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a Raspberry Pi Pico W to host a `motion` message is sent to the
    MQTT server and viewed using the MQTTHQ web client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – IoT-powered alarm module using MQTT](img/B21282_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – IoT-powered alarm module using MQTT
  prefs: []
  type: TYPE_NORMAL
- en: We will send a `buzzer` message to the Raspberry Pi Pico W from the MQTTHQ web
    client to activate the buzzer. This Raspberry Pi Pico W and MQTTHQ web client
    setup forms the foundation of our IoT home security system.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin this chapter with an exploration of MQTT, using a public server
    as our development platform. Then, we’ll familiarize ourselves with the Raspberry
    Pi Pico W, highlighting its strengths in IoT applications. Finally, we’ll conclude
    by installing the components of our IoT alarm module into a custom 3D-printed
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, we will cover the following main topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Investigating MQTT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Raspberry Pi Pico W with MQTT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an IoT alarm module case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the requirements for completing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Python programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x Raspberry Pi Pico WH (with headers) to use with breadboard or Raspberry
    Pi Pico GPIO expander.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x Raspberry Pi Pico W (no headers) to be installed in an optional 3D-printed
    case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x HC-SR501 PIR sensor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x LED connected with a 220 Ohm resistor (refer to [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048)
    for construction).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x SFM-27 active buzzer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 3D printer or 3D printing service to print an optional case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter6
  prefs: []
  type: TYPE_NORMAL
- en: Investigating MQTT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MQTT** is a pivotal component in IoT, enabling lightweight and efficient
    communication among connected devices. In *Figure 6**.1*, we illustrate MQTT within
    the ubiquitous cloud symbolizing the internet. MQTT operates on a **publish-subscribe**
    model, allowing devices to publish messages to specific topics while subscribing
    to relevant topics. This framework ensures efficient and selective communication,
    enabling devices to receive only messages relevant to their functions. MQTT’s
    lightweight design minimizes resource overhead, making it an ideal choice for
    devices with constrained capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: We start our investigation into MQTT by looking at how the publish-subscribe
    model in MQTT works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the publish-subscribe model in MQTT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The effectiveness of MQTT in enabling communication among IoT devices is due
    to its publish-subscribe model. This model provides a flexible and scalable way
    for devices to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In MQTT, devices are categorized into two roles – publishers and subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`motion` message under the `IoTAlarm` topic, while the temperature sensor communicates
    a `25 C` message under the `temp` topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IoTAlarm` and `temp` topics, while the phone is only subscribed to the `IoTAlarm`
    topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Topics in MQTT serve as channels or communication pathways. We may think of
    topics as labels or categories that messages fall under, such as the `IoTAlarm`
    and `temp` topics marked with black boxes with white lettering in *Figure 6**.2*.
    When a publisher sends a message to a specific topic, the MQTT broker (server)
    manages the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The broker maintains a list of all subscribers to that topic, guaranteeing
    message delivery to each. This mechanism allows for efficient and selective communication
    because devices only receive messages from topics they have subscribed to. In
    *Figure 6**.2*, we see our PC subscribing to the `IoTAlarm` and `temp` topics
    and our phone subscribing to only the `IoTAlarm` topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – MQTT communications illustrated](img/B21282_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – MQTT communications illustrated
  prefs: []
  type: TYPE_NORMAL
- en: Before we try some hands-on experience with MQTT, we will look at **Quality-of-Service**
    (**QoS**) levels in MQTT. Understanding QoS levels is crucial as they determine
    the reliability and delivery assurance of messages in MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding QoS in MQTT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**QoS** is an important aspect of MQTT that determines the level of guarantee
    for message delivery between the MQTT broker (server) and MQTT clients (devices
    or applications).'
  prefs: []
  type: TYPE_NORMAL
- en: 'MQTT offers three levels of QoS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**QoS 0 (At Most Once)**: In this mode, the message is delivered at most once,
    meaning that the message may not be delivered to the recipient, and it may get
    lost without any acknowledgment or guarantee of receipt. This level of QoS is
    suitable for scenarios where message loss is acceptable and message delivery is
    not critical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACK`) that the message was received, it will resend the message. This level
    of QoS guarantees that the message is received by the recipient but may result
    in duplicate messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QoS 2 (Exactly Once)**: QoS 2 provides the highest level of guarantee. It
    ensures that the message is delivered exactly once to the recipient. This level
    of QoS involves a more complex handshake between the sender and receiver to ensure
    no duplicates or message loss occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our development purposes, QoS 0 is adequate, as it offers reasonable message
    delivery without the need for the more intricate message tracking and acknowledgment
    mechanisms required by QoS 1 and QoS 2\. QoS 0 simplifies message handling in
    code, making it a practical choice for development scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring MQTT fundamentals with the MQTTHQ web client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To acquire practical knowledge of MQTT, we’ll utilize the **MQTTHQ web client**.
    This web-based service streamlines the process of learning MQTT, eliminating the
    need for complex installations or extensive programming. As a public resource
    aimed at development and testing, it provides an accessible environment for us
    to explore and understand the features of MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by opening the web client in a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our browser, we navigate to the client using the following URL: [https://mqtthq.com/client](https://mqtthq.com/client).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To ensure that we can use the client for our testing, we verify that we are
    connected to [public.mqtthq.com](https://public.mqtthq.com/) from the message
    at the top right of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Connected to the mqtthq.com client](img/B21282_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Connected to the mqtthq.com client
  prefs: []
  type: TYPE_NORMAL
- en: If the message indicating *connected* does not appear, we continue refreshing
    the page until it does.
  prefs: []
  type: TYPE_NORMAL
- en: In the `IoTAlarm`, keep the `0`, and click on the **Subscribe** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should notice that the text under **Received payloads** updates to display
    **Waiting for data…** and the **Subscribe** button has turned into an **Unsubscribe**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Subscribing to the IoTAlarm topic](img/B21282_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Subscribing to the IoTAlarm topic
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `IoTAlarm`, keep the `0`, replace the `Hello World!` message with `motion`,
    and then click on the **Publish** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Publishing a message to the IoTAlarm topic](img/B21282_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Publishing a message to the IoTAlarm topic
  prefs: []
  type: TYPE_NORMAL
- en: 'We should notice that our `motion` message has now appeared under the **Received
    payloads** box in the **Subscribe to** **topic** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – MQTT message received](img/B21282_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – MQTT message received
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that we are successfully sending MQTT messages from a publisher
    to a subscriber, we can use two separate computers: one to publish messages and
    the other to subscribe and receive them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through this exercise, we have effectively demonstrated the process of publishing
    and subscribing to MQTT messages using the MQTTHQ web client. In the next section,
    we will start building our IoT alarm module by leveraging the capabilities of
    the Raspberry Pi Pico W.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Raspberry Pi Pico W with MQTT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build the physical alarm part of our application using
    a **Raspberry Pi Pico W**. This microcontroller not only is affordable but also
    brings a range of capabilities to our project, allowing us to execute tasks efficiently
    without the full power of a **Single-Board Computer** (**SBC**) such as the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi Pico W doesn’t replace our Raspberry Pi; it complements it,
    adding unique strengths to our toolkit. Being a microcontroller, the Pico W is
    substantially more cost-effective compared to the Raspberry Pi, and it typically
    doesn’t heat up as much due to its simpler architecture and lower power consumption.
    This distinction is pivotal for projects such as our IoT alarm module, where the
    primary task is to capture sensory data – a function that does not require the
    computational power of an SBC. This allows us to reserve our Raspberry Pi for
    tasks that demand more computational resources.
  prefs: []
  type: TYPE_NORMAL
- en: Being a microcontroller, our Raspberry Pi Pico W boots up quickly, providing
    a rapid start for our program. We do not need to load a heavy operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the RP2040 chip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Raspberry Pi Pico W utilizes the dual-core ARM Cortex-M0+ processor RP2040
    chip created by the Raspberry Pi Foundation. This chip was designed as a bridge
    between microcontrollers and microcomputers by merging the streamlined operation
    typical of microcontrollers with the capacity to undertake more demanding microcomputer-type
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The *W* in our Raspberry Pi Pico W denotes that our microcontroller supports
    Wi-Fi. Besides the Raspberry Pi Pico W, there is the standard Pico (without Wi-Fi),
    the Pico H (without Wi-Fi and with soldered headers), and the Pico WH (with Wi-Fi
    and soldered headers).
  prefs: []
  type: TYPE_NORMAL
- en: 'The RP2040 chip our Raspberry Pi Pico W is based on may also be found on other
    microcontrollers such as the *Arduino Nano RP2040 Connect*, *Pimoroni Tiny 2040*,
    and *Adafruit Feather RP2040*. In *Figure 6**.7*, we see a Waveshare RP2040-Zero-M
    (*A*) a Raspberry Pi Pico (*B*), and a Raspberry Pi Pico W (*C*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – RP2040-based microcontrollers](img/B21282_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – RP2040-based microcontrollers
  prefs: []
  type: TYPE_NORMAL
- en: To construct our alarm circuit on a breadboard, we need headers on our Raspberry
    Pi Pico W. We can either solder them on ourselves or choose to purchase the Pico
    WH version.
  prefs: []
  type: TYPE_NORMAL
- en: We will start the construction of our IoT alarm module by building out the circuit
    on a breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our alarm circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll build our alarm circuit using an SFM-27 active buzzer,
    an LED with a resistor, and an HC-SR501 PIR sensor. We will configure our circuit
    on a breadboard before moving our components to a 3D-printed case. We may use
    a Raspberry Pi Pico GPIO expander in place of a breadboard. For the breadboard,
    we use male jumpers soldered to our components for connection to the breadboard.
    For the GPIO expander, we use female jumper wires soldered to our components for
    connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 6**.8*, we can see our circuit illustrated in a Fritzing diagram.
    To create our circuit, we wire our components to our Raspberry Pi Pico W with
    the connections outlined in *Figure 6**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Raspberry Pi Pico W alarm circuit](img/B21282_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Raspberry Pi Pico W alarm circuit
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note our connection to the VBUS port on the Raspberry Pi Pico
    W. When the Pico is powered via USB, components connected to the VBUS port will
    receive approximately 5V, which is the standard USB voltage. We will be powering
    our IoT alarm module through the USB port.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table outlines the power ports on the Raspberry Pi Pico W and
    provides insights into how we might utilize them in future projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Port** | **Input** **Voltage Use** | **Output** **Voltage Use** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| VBUS | Used to supply power from a 5V USB source. | Can be used to supply
    5V to external components when the Pico is USB-powered. |'
  prefs: []
  type: TYPE_TB
- en: '| VSYS | Accepts an external power supply ranging from 1.8V to 5.5V. | Not
    typically used to supply power to external components. |'
  prefs: []
  type: TYPE_TB
- en: '| 3V3(OUT) | Not commonly used for input. | Provides a regulated 3.3V supply
    to power external 3.3V components. |'
  prefs: []
  type: TYPE_TB
- en: '| 3V3_EN | Not a power supply port, but a control pin to enable/disable the
    3.3V supply. | Not applicable. |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – Power ports on the Raspberry Pi Pico (W)
  prefs: []
  type: TYPE_NORMAL
- en: With our circuit wired up, we are ready to start coding. We will start by setting
    up Thonny for microcontroller development.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all the software development we have done so far, we will use Thonny
    as our **Integrated Development Environment** (**IDE**). The choice of Thonny’s
    OS version (Windows, macOS, Linux, Raspberry Pi OS, and so on) is flexible since
    our focus is on writing code for a connected microcontroller rather than the computer
    used for coding.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that different OS versions of Thonny may exhibit varying
    levels of functionality necessary for this chapter. The content in this section
    is based on the Windows version of Thonny, and the screenshots provided reflect
    this.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll develop our code using **MicroPython**, a lightweight version of Python
    optimized for microcontrollers. MicroPython shares core syntax and functionality
    with Python, but it’s important to note that due to its focus on resource-constrained
    environments, it may lack some of the extensive libraries and features available
    in standard Python. These differences, however, are a trade-off for the efficiencies
    of MicroPython when used for microcontroller programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install MicroPython on our Raspberry Pi Pico W, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If Thonny is not available on our operating system, we visit the Thonny website
    and download an appropriate version ([https://thonny.org](https://thonny.org)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then launch Thonny using the appropriate method for our operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While holding the *BOOTSEL* button on the Pico W (the small white button near
    the USB port), we insert it into an available USB port and disregard any pop-up
    windows that may appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then click on the interpreter information at the bottom right-hand side
    of the screen and select **Install MicroPython…**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Install MicroPython… option](img/B21282_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Install MicroPython… option
  prefs: []
  type: TYPE_NORMAL
- en: 'For the **MicroPython variant**, we select **Raspberry Pi • Pico W /** **Pico
    WH**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Installing MicroPython on the Raspberry Pi Pico W](img/B21282_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Installing MicroPython on the Raspberry Pi Pico W
  prefs: []
  type: TYPE_NORMAL
- en: We click on the **Install** button and then the **Close** button once the installation
    has been completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To have Thonny configured to run the MicroPython interpreter on our Pico W,
    we select it from the bottom right-hand side of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Selecting the MicroPython interpreter from our Pico W](img/B21282_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Selecting the MicroPython interpreter from our Pico W
  prefs: []
  type: TYPE_NORMAL
- en: 'We confirm that Thonny is using the MicroPython interpreter on our Raspberry
    Pi Pico W by checking the **Shell**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12 – MicroPython prompt in Thonny](img/B21282_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – MicroPython prompt in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the MQTT code, we will require an MQTT library to be installed. To do
    so, we select `umqtt` in the search box, and click on **Search** **on PyPI**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Installing an MQTT library onto our Pico W](img/B21282_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Installing an MQTT library onto our Pico W
  prefs: []
  type: TYPE_NORMAL
- en: We select the `micropython-umqtt.simple` package and click on the **Install**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then close the dialog by clicking on the **Close** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have MicroPython and an MQTT library installed on our Raspberry
    Pi Pico W, we’re prepared to begin coding. Our initial focus will be on connecting
    the components, followed by the implementation of MQTT-related code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the alarm module client code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, we should be well acquainted with the Thonny IDE. Connecting to the
    MicroPython interpreter on the Raspberry Pi Pico W doesn’t significantly alter
    our interaction with Thonny.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, it’s advantageous for our development process to have visibility
    into files stored on both the Pico W and our computer. This visibility allows
    us to easily verify file locations and manage our project effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the **Files** view in Thonny, we click on the **View** menu at the
    top and select **Files**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Enabling Files view in Thonny](img/B21282_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Enabling Files view in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: We should see a view of our project files on both the Raspberry Pi Pico W and
    our computer on the left-hand side of Thonny.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to start writing code. We will start with the buzzer.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the buzzer through code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 6**.1* illustrates an `IoTAlarm` type message sent from the MQTT broker
    to our Raspberry Pi Pico W. This message serves the purpose of activating the
    buzzer in our alarm module. To handle this task, we’ll create a separate program.
    Activating the buzzer involves a slightly more complex process compared to monitoring
    the PIR sensor or LED components in our circuit, and thus a desire to separate
    its code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use
    our Raspberry Pi or another operating system for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the MicroPython environment on our Pico W by selecting it from
    the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new editor tab, we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To save the file, we click on **File** | **Save as...** from the drop-down
    menu. This will open the following dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Saving a file to our Raspberry Pi Pico W](img/B21282_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Saving a file to our Raspberry Pi Pico W
  prefs: []
  type: TYPE_NORMAL
- en: In this dialog, we are given the option to choose where to store our file. To
    save it on our Raspberry Pi Pico W, we click on the corresponding button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then name the file `buzzer.py` and click `Pin` and `PWM` (for `machine` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We import the `utime` class for timer functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the `BUZZER_PIN` constant to 16\. This corresponds to our wiring diagram
    for the buzzer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `buzzer` object by initializing the `PWM` class on the specified
    `BUZZER_PIN` constant. This PWM-based approach allows us to vary the voltage supplied
    to the buzzer rapidly, enabling control over the sound’s tone and volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then set the `BUZZER_FREQ` constant to `4000`, representing the frequency
    of the PWM signal used for the buzzer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then define an `activate_buzzer()` function. This function takes an optional
    `duration` parameter (default is 5 seconds).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `activate_buzzer()` function, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the frequency of the `buzzer` object to the specified `BUZZER_FREQ` constant.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the buzzer’s duty cycle to 50% (32768 out of the full 16-bit range of
    65536), creating a balanced tone, with the buzzer active for half of the signal’s
    16-bit cycle and inactive for the other half.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code then pauses the program for the specified duration in seconds using
    the `utime.sleep()` function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After the specified duration, set the duty cycle of the `buzzer` object back
    to `0`, turning off the buzzer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can test our code using the Shell in Thonny. To do so, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Shell, we import the `activate_buzzer()` function from the buzzer file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Importing the activate_buzzer() function](img/B21282_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Importing the activate_buzzer() function
  prefs: []
  type: TYPE_NORMAL
- en: 'With the function imported, we can run it by simply calling it and hitting
    *Enter* on the keyboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Activating the buzzer](img/B21282_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Activating the buzzer
  prefs: []
  type: TYPE_NORMAL
- en: With our buzzer wired correctly, we should hear it sound for 5 seconds. To adjust
    the duration, we simply pass another value into the `activate_buzzer()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must congratulate ourselves as we have just written and executed our first
    MicroPython program! With the buzzer code done, it is time to create the main
    program for our alarm module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the main code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will write the code to power our IoT alarm module. In this
    code, we will connect to the PIR sensor and LED, as well as the Wi-Fi and MQTT
    broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'In MicroPython, two files control Pico W’s startup and code execution: `boot.py`
    handles essential initialization during boot, while `main.py` contains the primary
    user code for custom logic and functions.'
  prefs: []
  type: TYPE_NORMAL
- en: For our code, we won’t concern ourselves with `boot.py`. We will, however, concentrate
    on `main.py`, the program responsible for launching our application on Pico W
    when it is first powered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write our IoT alarm module code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new tab in Thonny, we start by entering our code for imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our preceding code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`machine`: Provides access to hardware-related functions and classes for our
    microcontroller.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`utime`: Offers time-related functions and timing control for managing delays
    and timestamps.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`network`: Provides network-related functions for configuring and managing
    network connections.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_thread`: Allows creating and managing threads for concurrent execution of
    code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MQTTClient` (from `umqtt.simple`): Provides MQTT client functionality for
    communication over MQTT.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activate_buzzer` (from `buzzer`): Our custom function for activating a buzzer.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then set our variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we have the following variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SSID`: Variable storing the name (SSID) of the Wi-Fi network our program connects
    to'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PASSWORD`: Variable storing the password for the Wi-Fi network'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MQTT_SERVER`: Variable storing the MQTT broker’s/server’s address (we will
    be using `broker.mqtt.com`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MQTT_PORT`: Variable storing the MQTT port number'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pir`: Configures a GPIO pin 26 as an input pin for our PIR sensor'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`led`: Configures a GPIO pin 21 as an output pin to control our LED'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wlan`: Initializes a WLAN (Wi-Fi) interface for connecting to a Wi-Fi network
    in the station (client) mode, allowing our MicroPython device to act as a client
    and join an existing wireless network. This initialization is essential, as it
    allows our Pico W to connect to an existing Wi-Fi network, enabling networked
    communication'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After defining our variables, we create a function to connect our Raspberry
    Pi Pico W to our Wi-Fi network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`wlan.active(True)`: Activates the Wi-Fi interface'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wlan.connect(SSID, PASSWORD)`: Initiates the connection to the Wi-Fi network
    using the specified SSID (network name) and password (network password)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while not wlan.isconnected():`: This loop continuously checks whether the
    device is connected to the Wi-Fi network:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print(''Trying to connect to WiFi...'')`: If not connected, it prints a message
    indicating the ongoing connection attempt'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`utime.sleep(5)`: It pauses for 5 seconds before checking the connection status
    again'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print(''WIFI connection established'')`: Once connected, our code prints a
    message confirming the successful connection to the Wi-Fi network'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With our Wi-Fi connection function in place, we then add a function responsible
    for handling the `buzzer` message received from our MQTT broker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, the following happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our `sub_iotalarm()` function handles incoming MQTT messages by first printing
    the topic and message received
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the topic is `IoTAlarm` and the message is `buzzer`, it calls the `activate_buzzer()`
    function to trigger the buzzer
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `motion_handler()` function is responsible for handling motion detection
    events, printing notifications, and, if the MQTT client is connected, publishing
    a `motion` message to the `IoTAlarm` topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, the following happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our `motion_handler()` function takes in a parameter called `pin`. This parameter
    is needed as a placeholder for the interrupt handler’s expected argument; even
    though we don’t use it within the function, it is required to maintain compatibility
    with the interrupt system.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `b` prefix to denote that the string (`IoTAlarm` and `motion`) should
    be treated as a byte object rather than a text (Unicode) string, which is required
    for sending binary data in protocols such as MQTT.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `connect_mqtt()` function establishes a connection between our code and
    the MQTT broker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, the following happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `connect_mqtt()` function establishes a connection between our code and
    the MQTT server, taking two parameters: `device_id` for device identification
    and `callback` for specifying a function that processes incoming messages (known
    as a callback function). The `device_id` parameter is a unique identifier assigned
    to each MQTT client, allowing our MQTT broker to distinguish specific devices
    on the network.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `while` loop, our code attempts to connect to the MQTT server using
    the given device ID, configures the `callback` function to handle messages, and
    successfully establishes an MQTT connection. If the connection encounters any
    issues, our function retries after a 5-second pause.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a callback function?
  prefs: []
  type: TYPE_NORMAL
- en: In the context of our IoT alarm system, a callback function is used as part
    of the MQTT communication process. In our code, we use the `sub_iotalarm()` function
    as the callback, which means that when relevant MQTT messages are received from
    the MQTT broker, the `sub_iotalarm()` function is automatically invoked. Inside
    our callback function, we have defined specific actions to be taken based on the
    received messages, such as activating the buzzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method controls the LED’s blinking pattern, indicating the application’s
    connection status, and enables troubleshooting when the Raspberry Pi Pico W is
    running independently from a computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Steady On`: The LED remains constantly on when both Wi-Fi and MQTT are connected.
    This occurs when Wi-Fi is connected (`wlan.isconnected()` is `True`) and there
    is a value for `mqtt_client`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fast Blink`: When only Wi-Fi is connected (MQTT client is `None`), the LED
    blinks rapidly every half-second.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slow Blink`: When neither Wi-Fi nor MQTT is connected, the LED blinks more
    slowly, with a 1-second interval for on and off states.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enable independent execution of the `connection_status()` function, our
    code starts a new thread. Threading enables concurrent execution of multiple tasks
    or functions, making efficient use of the RP2040’s dual-core processor to run
    distinct operations simultaneously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our code then calls functions to connect to the Wi-Fi and MQTT broker using
    a unique client ID, `IoTAlarmSystem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then subscribe to the `IoTAlarm` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enable our PIR sensor, we set its `irq()` method with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, the following happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An `motion_handler()` function is invoked to publish a `motion` message to the
    MQTT broker.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In an infinite loop, we wait for a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once a message is received it is processed by the callback function, which we
    defined as `sub_iotalarm()` earlier in the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We save the code as `main.py` onto our Raspberry Pi Pico W to ensure that when
    we power it on or reset it, our code runs automatically. This is standard with
    MicroPython.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the code written, it is time to test it out with the MQTTHQ web client.
  prefs: []
  type: TYPE_NORMAL
- en: Running our alarm module application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have two options for running the code on our Raspberry Pi Pico W. One is
    to power up the Pico W with a standard USB power cable, which is suitable for
    use after testing, but it won’t provide access to debug print messages. The second
    option is to run our code in Thonny. This will allow us to troubleshoot any issues
    we encounter. To do this, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We select the `main.py` tab in Thonny, ensuring that we pick the version installed
    on our Pico W rather than our operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We click on the green run button, hit *F5* on the keyboard, or click on the
    **Run** menu option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe messages in the Shell that our code is connecting first to
    the Wi-Fi network and then to the MQTT server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should also observe that our LED blinks accordingly, slowly before connecting
    to the Wi-Fi network, faster after connecting to the Wi-Fi network but before
    connecting to the MQTT server, and steady once both connections are made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Moving our hand in front of the PIR sensor, we should observe a `Motion detected!!`
    message followed by a message coming back from the MQTT server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Detecting motion with the PIR sensor](img/B21282_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Detecting motion with the PIR sensor
  prefs: []
  type: TYPE_NORMAL
- en: If we only receive a `Motion detected!!` message but not a message coming back
    from the MQTT server (broker), then our application has lost connection to the
    server. This should also be indicated by our LED flashing slowly. To fix this,
    we stop and restart our program using the **Stop** and **Run** buttons respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To verify that our code is sending MQTT messages, we follow the steps from
    the previous section, *Exploring MQTT fundamentals with the MQTTHQ web client*.
    After subscribing to the `IoTAlarm` topic, the web client should receive a `motion`
    message whenever our PIR sensor is triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Receiving motion messages](img/B21282_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Receiving motion messages
  prefs: []
  type: TYPE_NORMAL
- en: 'To test out our buzzer, we publish a `buzzer` message using the MQTTHQ web
    client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Publishing a buzzer message](img/B21282_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – Publishing a buzzer message
  prefs: []
  type: TYPE_NORMAL
- en: After clicking the **Publish** button, we should hear our alarm sound for 5
    seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now created our first MQTT application! We have sent MQTT messages from
    our Raspberry Pi Pico W to and from the internet. As we can imagine, the possibilities
    of our application are vast. For instance, we can extend our IoT alarm system
    by adding more sensors such as a door/window contact sensor for security, or a
    temperature and humidity sensor for home climate monitoring. In the next chapter,
    we will add monitoring and remote arming of our alarm module as we continue to
    build our IoT home security system.
  prefs: []
  type: TYPE_NORMAL
- en: To finish off our IoT alarm module, we will now install our components into
    a custom 3D-printed case.
  prefs: []
  type: TYPE_NORMAL
- en: Building an IoT alarm module case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have done previously, we will install our components into a custom-designed
    3D-printed case. *Figure 6**.21* features a rendering of our alarm module case,
    designed to accommodate the PIR sensor, buzzer, LED with a resistor, and the Raspberry
    Pi Pico W.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the interest of compactness, we’ve opted for the Raspberry Pi Pico W without
    headers, simplifying component fitting and wire soldering. It’s important to note
    that this choice is optional, and we can use the header-equipped Raspberry Pi
    Pico WH:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Alarm module custom case](img/B21282_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Alarm module custom case
  prefs: []
  type: TYPE_NORMAL
- en: We will start by identifying the parts before we move on to constructing and
    then testing our IoT alarm module.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the parts of the custom case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Figure 6**.22*, we can see the parts required to assemble the custom case
    for our IoT alarm module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Parts for the alarm module](img/B21282_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – Parts for the alarm module
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down each part:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi Pico W** (*A*): Header version (shown here), or header-less
    version (preferred).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backplate** (*B*): 3D printed using **Polylactic Acid** (**PLA**), **Acrylonitrile
    Butadiene Styrene** (**ABS**), or **Polyethylene Terephthalate** **Glycol** (**PETG**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hook** (*C*): 3D printed using PLA, ABS, PETG, or engineering-grade resin
    using a liquid resin printer (as shown here). For **Fused Deposition Modeling**
    (**FDM**) printers, the part should be printed on its side with supports for strength.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SFM-27 active buzzer** (*D*): Case designed to fit this buzzer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Side mount stand** (*E*): 3D-printed optional stand for mounting alarm module
    on a wall. May be printed in PLA, ABS, PETG, or engineering-grade resin using
    a liquid resin printer (as shown here).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the split stand with FDM printers
  prefs: []
  type: TYPE_NORMAL
- en: The split stand in the SenseHAT case files (`Build Files` folder, [*Chapter
    1*](B21282_01.xhtml#_idTextAnchor014) repository) is ideal for FDM printing. By
    splitting and printing each half on its side, the stand gains significant strength.
    An accompanying base is also provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**LED with resistor** (*F*): Refer to [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048)
    for construction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LED holder** (*G*): To hold LED into the case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Front shell** (*H*): 3D printed using PLA, ABS, or PETG.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HC-SR501 PIR sensor** (*I*): Case designed to fit this PIR sensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 x M2 5 mm screws (not shown).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x M4 10 mm bolts (not shown).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x M4 nuts (not shown).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 x M3 10 mm bolts (not shown).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glue gun with a glue stick (not shown).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an engineering-grade resin?
  prefs: []
  type: TYPE_NORMAL
- en: Liquid resin 3D printers function by creating shapes layer by layer using UV
    light to solidify liquid resin. Standard resins are typically used for small artistic
    prints, offering excellent detail but often resulting in brittle parts. Engineering
    resins such as Siraya Tech Blu, on the other hand, provide superior strength,
    making them suitable for functional components. Parts *C* and *E* in *Figure 6**.22*
    were printed with an 80–20 mix of standard resin and Siraya Tech Tenacious, giving
    the parts more flexibility and reducing their brittleness.
  prefs: []
  type: TYPE_NORMAL
- en: Files for the 3D-printed parts are in the `Build Files` directory of this chapter’s
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have identified the parts needed to construct the case for our alarm
    module, let’s put it together.
  prefs: []
  type: TYPE_NORMAL
- en: Building the alarm module case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 6**.23* illustrates the steps to build the IoT alarm module case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Steps to build the alarm module case](img/B21282_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Steps to build the alarm module case
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the case, we do the following (the letters representing the different
    components in *Figure 6**.23* are mentioned beside the respective component’s
    name in the following steps):'
  prefs: []
  type: TYPE_NORMAL
- en: Using two M2 5 mm screws, we screw the hook (*C*) onto the backplate (*B*) (*Figure
    6**.23*, *Step 1*). We may also use epoxy glue for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using four M2 5 mm screws, we secure the Raspberry Pi Pico W to the backplate
    (*B*) such that the USB port is facing down and toward the opening (*Figure 6**.23*,
    *Step 2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We secure the buzzer (*D*) to the front shell (*H*) with two M4 10 mm bolts
    and M4 nuts (*Figure 6**.23*, *Step 3*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then install the LED with the resistor (*F*) into the front shell (*H*) using
    the LED holder (*G*) (*Figure 6**.23*, *Step 4*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the glue gun, we secure the PIR sensor (*I*) to the front shell (*H*).
    Ensure that the PIR controls face the opening. We may also use the glue gun to
    reinforce the placement of the LED (*Figure 6**.23*, *Step 5*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a soldering iron, we solder the components to the Raspberry Pi Pico W
    using the wiring diagram from *Figure 6**.8* as a reference (*Figure 6**.23*,
    *Step 6*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using four M3 10 mm bolts, we secure the backplate (*B*) to the front shell
    (*H*) (*Figure 6**.23*, *Step 7*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not already installed, we install MicroPython and our client code onto our
    Raspberry Pi Pico W using Thonny.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For our design, we use the micro-USB port for both power and access to the installed
    programs on our Raspberry Pi Pico W. This allows us to easily update our client
    software, such as changing the Wi-Fi network and password or the MQTT topic used.
  prefs: []
  type: TYPE_NORMAL
- en: Also, our case provides access to the controls on our PIR sensor so that we
    may control the sensitivity and off time.
  prefs: []
  type: TYPE_NORMAL
- en: What are the controls on the HC-SR501 PIR sensor?
  prefs: []
  type: TYPE_NORMAL
- en: 'The HC-SR501 PIR sensor is equipped with two adjustable controls: the sensitivity
    control, which fine-tunes the sensor’s responsiveness to motion by increasing
    sensitivity when turned clockwise and decreasing it when turned counterclockwise,
    and the time delay control, which regulates the duration of the output signal
    after detecting motion, with clockwise rotation extending the signal duration
    and counterclockwise rotation shortening it. These controls sit beside each other
    and may be adjusted using a small screwdriver.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To operate our IoT alarm module, we simply connect a micro-USB cable from our
    Raspberry Pi Pico W to a standard USB charger. The LED should blink quickly at
    first as a Wi-Fi connection is established, followed by a slow blink while our
    program connects to the MQTT broker, and finally, a solid light indicating our
    module is ready for use. If we decide not to print the stand from *Figure 6**.22
    E*, we may mount our module onto a GoPro camera mount of our choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Alarm module installed on a GoPro camera mount](img/B21282_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – Alarm module installed on a GoPro camera mount
  prefs: []
  type: TYPE_NORMAL
- en: To test our IoT alarm module, we connect to the `mqtthq.com` web client and
    subscribe to the `IoTAlarm` topic. Passing our hands over the PIR sensor, we should
    see `motion` messages appear in the client. Publishing the `IoTAlarm` topic and
    sending `buzzer` messages should activate our buzzer for 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: We have just built our first MQTT-based IoT alarm module, enclosed in a physical
    case, capable of sensing motion and activating an alarm remotely through MQTT
    messages. With its built-in GoPro hook, we can easily install our IoT alarm module
    anywhere there is a Wi-Fi connection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored MQTT and used it to create an MQTT-based IoT alarm
    module. We introduced the amazing Raspberry Pi Pico W, a microcontroller that
    complements our Raspberry Pi. We began by understanding MQTT’s publish-subscribe
    model, which enables efficient and selective communication among connected devices.
    Additionally, we examined the significance of threading in maximizing the utilization
    of the Raspberry Pi Pico’s dual-core processor.
  prefs: []
  type: TYPE_NORMAL
- en: We created code for connecting to Wi-Fi and MQTT servers, handling motion detection,
    and activating alarm components. We learned how to use callback functions to process
    MQTT messages.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we covered saving and running our code on the Raspberry Pi Pico
    W, making it a standalone IoT alarm system. We also 3D printed a custom case to
    house the PIR sensor, LED, buzzer, and Raspberry Pi Pico W.
  prefs: []
  type: TYPE_NORMAL
- en: With our MQTT-based IoT alarm module now complete, we are ready to explore further
    enhancements as we expand the capabilities of our IoT home security system. In
    the next chapter, we will build an IoT button that we will use to control our
    alarm module.
  prefs: []
  type: TYPE_NORMAL
