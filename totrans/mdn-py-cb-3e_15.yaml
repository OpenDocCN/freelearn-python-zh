- en: '15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing is central to creating working software. Here’s the canonical statement
    describing the importance of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: ”Any program feature without an automated test simply doesn’t exist”.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(Kent Beck, Extreme Programming Explained: Embrace Change)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can distinguish several kinds of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This applies to independent units of software: functions, classes, or modules.
    The unit is tested in isolation to confirm that it works correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs: []
  type: TYPE_NORMAL
- en: ': This combines units to be sure they integrate properly.'
  prefs: []
  type: TYPE_NORMAL
- en: System testing
  prefs: []
  type: TYPE_NORMAL
- en: ': This tests an entire application or a system of interrelated applications
    to be sure that the suite of software components works properly. This is also
    called end-to-end testing or functional testing. This is often used for acceptance
    testing to confirm that software is fit for use.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing
  prefs: []
  type: TYPE_NORMAL
- en: ': This ensures that a unit, subsystem, or whole system meets performance objectives
    (also often known as load testing). In some cases, performance testing includes
    the study of resources such as memory, threads, or file descriptors. The goal
    is to be sure that software makes appropriate use of system resources. This is
    sometimes called benchmarking, when the goal is to measure resource usage instead
    of ensuring that the usage is below some threshold.'
  prefs: []
  type: TYPE_NORMAL
- en: These are some of the more common types. In this chapter, we’ll focus on unit
    testing since it is foundational to creating trust that software works reliably.
    Other forms of testing rest on the foundation of reasonably complete unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s sometimes helpful to summarize a test scenario following the Gherkin language.
    In this test specification language, each scenario is described by GIVEN-WHEN-THEN
    steps. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This approach to writing tests describes the given starting state or arrangement,
    an action to perform, and one or more assertions about the resulting state after
    the action. This is sometimes called the ”arrange-act-assert” pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Testing functions that raise exceptions](ch019_split_000.xhtml#x1-8040002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Handling common doctest issues](ch019_split_000.xhtml#x1-8100003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Combining unittest and doctest tests](ch019_split_000.xhtml#x1-8250005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Combining pytest and doctest tests](ch019_split_001.xhtml#x1-8370007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Testing things that involve dates or times](ch019_split_001.xhtml#x1-8430008)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mocking external resources](ch019_split_001.xhtml#x1-85500010)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start by including tests within the docstring of a module, class, or function.
    This makes the test case act as both documentation of the design intent and a
    verifiable confirmation that it really does work as advertised.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1 Using docstrings for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good Python includes docstrings inside every module, class, function, and method.
    Many tools can create useful, informative documentation from docstrings. Refer
    back to the [Writing clear documentation strings with RST markup](ch007_split_001.xhtml#x1-2030007)
    recipe in Chapter [3](ch007_split_000.xhtml#x1-1610003) for an example of how
    to create docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: One important element of a docstring is a concrete example. The examples provided
    in docstrings can become unit-test cases that are exercised by Python’s doctest
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at ways to turn examples into proper automated test
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at a small function definition as well as a class definition. Each
    of these will contain docstrings that include examples that can be used as automated
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use a function to compute the binomial coefficient of two numbers. It
    shows the number of combinations of n things taken in groups of size k. For example,
    how many ways a 52-card deck can be dealt into 5-card hands is computed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![( ) n = ----n!--- k k!(n− k)! ](img/file80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This can be implemented by a Python function that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Functions, generally, have no internal state, making a function like this relatively
    easy to test. This will be one of the examples used for showing the unit testing
    tools available.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also look at a class that uses lazy calculation of the mean and median
    of a collection of numbers. Objects often have internal state, defined by the
    various self. attributes. State changes are often difficult. This is similar to
    the classes shown in Chapter [7](ch011_split_000.xhtml#x1-3760007). The [Designing
    classes with lots of processing](ch011_split_000.xhtml#x1-3890003) and [Using
    properties for lazy attributes](ch011_split_001.xhtml#x1-43100010) recipes both
    have classes similar to this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an outline of the Summary class, with some implementation details omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The add() method changes the internal state of a Summary object. Because of
    this state change to the self.counts attribute, we’ll need to provide more sophisticated
    examples to show how an instance of the Summary class behaves.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll show two variations in this recipe. The first variation can be applied
    to functions like the binom() function where there is no object with a mutable
    state. The second is more appropriate for stateful operations, such as the Summary
    class. We’ll look at them together because they’re very similar, even though they
    apply to different kinds of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Writing examples for functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This recipe starts by creating the function’s docstring, and then adds an example
    of how the function works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the docstring with a summary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the parameter definitions and the return value definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Mock up an example of using the function at Python’s >>> prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the docstring with the appropriate quotation marks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Writing examples for stateful objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This recipe also starts with writing a docstring. The docstring will show several
    steps using the stateful object to show the object’s internal state changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a class-level docstring with a summary. It can help to leave some blank
    lines in front of the doctest example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extend the class-level docstring with a concrete example of how the class works.
    In this case, we’ll show how the add() method sets the state of the object. We’ll
    also show how to interrogate the state of the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finish with the triple quotes to end the docstring for this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because this example uses floating-point values, we’ve rounded the result of
    the mean in the docstring example. Floating-point values might not have the exact
    same text representation on all platforms and an exact test for equality may fail
    unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we run the doctest program, we’ll generally get a silent response because
    the test passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interaction looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When the tests pass, there is no output. We can add a -v command-line option
    to see an enumeration of the tests run. This can be helpful to confirm that all
    of the tests in the module were found.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when something doesn’t work? We’ll modify a test case to have
    a wrong answer and force a failure. When we run the doctest program – using a
    broken test case – we’ll see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This shows where the error is. It shows an expected value from the test example,
    and the actual answer that failed to match the expected answer. Ordinarily – without
    the -v option – silence means all tests were passed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The doctest module includes a main program – as well as several functions –
    that scan a Python file for examples. The scanning operation looks for blocks
    of text that have a characteristic pattern of the Python REPL: a >>> prompt with
    code, followed by lines that show the response from the code, followed by a blank
    line to end the example output. Clearly, these must be formatted to precisely
    match the Python REPL output to be found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The doctest parser creates a small test case object from the prompt line and
    the block of response text. There are three common cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'No expected response text: We saw this pattern when we defined the tests for
    the add() method of the Summary class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A single line of response text: This was exemplified by the binom() function
    and the mean() method of the Summary class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple lines of response: Responses are bounded by either the next >>> prompt
    or a blank line. This was exemplified by the str() example of the Summary class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless special annotations are used, the output text must precisely match the
    expectation text. In general, every space counts.
  prefs: []
  type: TYPE_NORMAL
- en: This testing protocol imposes some software design constraints. Functions and
    classes must be designed to work from the >>> prompt. Because it can become awkward
    to create very complex objects as part of a docstring example, class designs must
    be kept simple enough to be demonstrated at the interactive prompt. These constraints
    often have the benefit of keeping a design understandable.
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity of the final comparison with the expected result can create some
    complications. In the example, we rounded the value of the mean to two decimal
    places. This is because the display of floating-point values may vary slightly
    from platform to platform.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the important considerations in test design is identifying edge cases.
    An edge case generally focuses on the limits for which a calculation is designed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, for example, two edge cases for the binomial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![( ) ( ) n n 0 = n = 1 ](img/file81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can add these to the examples to be sure that our implementation is sound.
    This leads to a docstring that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To keep the examples straight in the source code files, we’ve changed the name
    of this function to binom2\. This hack lets us keep both examples in a single
    Python module.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we might need to test values that are outside the valid range
    of values. These cases raise exceptions, which means they aren’t really ideal
    for putting into the docstring. The examples can clutter the explanation with
    details of things that should never normally happen. Fortunately, we have a place
    to put additional examples.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to reading docstrings, the tool also looks for test cases in a global
    variable named __test__. This variable must refer to a mapping. The keys to the
    mapping will be test case names, and the values of the mapping must be doctest
    examples. Generally, each value will need to be a triple-quoted string.
  prefs: []
  type: TYPE_NORMAL
- en: Because the examples in the __test__ variable are not inside the docstrings,
    they don’t show up when using the built-in help() function. Nor do they show up
    when using other tools to create documentation from source code. This might be
    a place to put examples of failures or complex exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might add something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can use this for tests that don’t need to be as visible as the docstring
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Testing functions that raise exceptions](ch019_split_000.xhtml#x1-8040002)
    and [Handling common doctest issues](ch019_split_000.xhtml#x1-8100003) recipes
    later in this chapter, we’ll look at two additional doctest techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more background to the concept of stateless functions, see Chapter [3](ch007_split_000.xhtml#x1-1610003)
    and Chapter [9](ch013_split_000.xhtml#x1-5020009).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.2 Testing functions that raise exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python permits docstrings inside packages, modules, classes, functions, and
    methods. A good docstring should contain an example of how the feature is used.
    The example may need to include common exceptions, too. There’s one complicating
    factor, however, to including exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception is raised, the traceback messages created by Python are not
    completely predictable. The message may include object ID values that are impossible
    to predict or module line numbers that may vary slightly depending on the context
    in which the test is executed. The general matching rules for doctest compare
    expected and actual results precisely. In this recipe, we’ll look at additional
    techniques to add flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at a small function definition as well as a class definition. Each
    of these will contain docstrings that include examples that can be used as formal
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the function from the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe, shown earlier in this chapter, that computes the binomial coefficient
    of two numbers. It shows the number of combinations of n things taken in groups
    of k. For example, it shows how many ways a 52-card deck can be dealt into 5-card
    hands.
  prefs: []
  type: TYPE_NORMAL
- en: This function does a simple calculation and returns a value; it lacks any internal
    state, making each request independent. We’d like to include some additional test
    cases in the __test__ variable to show what this does when given values outside
    the expected ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by running the binom function we defined previously. This output provides
    a handy template to show the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the function manually at the interactive Python prompt to collect the actual
    exception details. Copy and paste these results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a global __test__ variable at the end of the module. One approach is
    to build the mapping from all global variables with names that start with test_:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define each test case as a global variable with a block of text containing the
    doctest example. This can include additional notes about the scenario. These variables
    must be set before the final creation of the __test__ mapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste in the interactive session session output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will start like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the traceback details with .... Leave the initial line and the final
    exception in place. Add a directive to doctest, by putting # doctest: +ELLIPSIS
    after the line to be executed. It will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now use a command like this to test the entire module’s features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Because each test is a separate global variable, we can easily add test scenarios.
    All of the names starting with test_ will become part of the final __test__ mapping
    that’s used by the doctest tool.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because eliding traceback details is so common, the doctest tool recognizes
    the ellipsis (...) in the context of a traceback. The ellipsis is also available
    in other contexts as one of many directives to modify the testing behavior. The
    directives are included as special comments with the line of code that performs
    the test action. They can also be provided as general instructions on the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two additional ways to handle tests that include an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a # doctest: +IGNORE_EXCEPTION_DETAIL directive on the line of code
    that will raise the exception. This lets us provide a full traceback error message.
    The details of the traceback are ignored, and only the final exception line is
    matched against the expected value. This makes it possible to copy an actual error
    and paste it into the documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use a # doctest: +ELLIPSIS directive and replace parts of the traceback
    message with .... This directive is redundant for traceback messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of an explicit directive can help to make it clear what the intent is.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two more directives that are often useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '+NORMALIZE_WHITESPACE: Using this directive allows some flexibility in the
    whitespace for the expected value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '+SKIP: The test is skipped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few more directives, but they’re rarely needed.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001) recipe
    earlier in this chapter. This recipe shows the basics of doctest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the [Handling common doctest issues](ch019_split_000.xhtml#x1-8100003) recipe
    next in this chapter. This shows other special cases that require doctest directives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.3 Handling common doctest issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A docstring that contains an example is part of good Python programming. The
    way the doctest tool uses literal matching of the expected text output against
    the actual text can make testing complicated for Python objects that do not have
    a consistent text representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, object hash values are randomized. This often results in the order
    of elements in a set collection being unpredictable. We have several choices for
    creating test case example output:'
  prefs: []
  type: TYPE_NORMAL
- en: Write examples that can tolerate randomization. One technique is by sorting
    the elements of a set into a defined order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stipulate a specific value for the PYTHONHASHSEED environment variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several other considerations beyond simple variability in the location
    of keys or items in a set. Here are some other concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: The id() and repr() functions may expose an internal object ID. No guarantees
    can be made about these values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating-point values may vary across platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current date, time, and local timezone cannot meaningfully be used in a
    test case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random numbers using the default seed are difficult to predict.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS resources may not exist, or may not be in the proper state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that doctest examples require an exact match with the
    text. This means our test cases must avoid unpredictable results stemming from
    hash randomization or floating-point implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 15.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll look at three separate versions of this recipe. The first will include
    a function where the output includes the contents of a set. Because the order
    of items in a set can vary, this isn’t as easy to test as we’d like. Here’s the
    function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Testing the unique_letters() function is difficult because the order of items
    within a set is unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example will be a class that doesn’t define a unique __repr__()
    definition. The default definition of the __repr__() method will expose an internal
    object ID. Since these vary, the test results will vary. Here’s the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For the third example, we’ll look at a real-valued function so that we can
    work with floating-point values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ϕ (n) = 1[1 + erf√n-] 2 2 ](img/file82.png)'
  prefs: []
  type: TYPE_IMG
- en: This function is the cumulative probability density function for standard z-scores.
    See the [Creating a partial function](ch013_split_001.xhtml#x1-5560008) recipe
    in Chapter [9](ch013_split_000.xhtml#x1-5020009), for more information on the
    idea of normalized scores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the Python implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The phi() and frequency() functions involve some rather complicated numeric
    processing. The unit tests have to reflect the floating-point precision issues.
  prefs: []
  type: TYPE_NORMAL
- en: 15.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at set ordering and object representation in three mini-recipes.
    We’ll start with set ordering, then look at object IDs, and finally, floating-point
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Writing doctest examples with unpredictable set ordering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Write a draft of the test that seems to capture the essence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test will work when the hash values for these strings happen to fall into
    this specific order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One possible fix is to sort the results to impose an order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another alternative is to compare the output to a set object. The two choices
    look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A third choice is to set the PYTHONHASHSEED environment variable to force known
    orderings. We’ll look at this alternative below.
  prefs: []
  type: TYPE_NORMAL
- en: Writing doctest examples with object IDs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ideally, our applications won’t display object IDs. These are essentially impossible
    to predict. Here’s what we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a happy path doctest scenario to show that the class performs its essential
    methods correctly. In this case, we’ll create a Point instance and use the text
    property to see a representation of the point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we define a test that displays the object’s representation string, the
    test will include results that include the unpredictable object ID. The doctest
    might look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to change the test by using a # doctest: +ELLIPSIS directive. This
    means changing the >>> Point(36.8439, -76.2936) line in the test, and using an
    ellipsis on the exception displayed in the expected output to look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This kind of test suggest a design improvement. It’s often best to define __repr__().
    Another choice is to avoid tests where __repr__() may be used.
  prefs: []
  type: TYPE_NORMAL
- en: Writing doctest examples for floating-point values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have two choices when working with float values. We can round the values
    to a certain number of decimal places. An alternative is to use the math.isclose()
    function. We’ll show both:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the necessary libraries and define the phi() and frequency() functions
    as shown previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each example, include an explicit use of round():'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An alternative is to use the isclose() function from the math module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because float values can’t be compared exactly, it’s best to display values
    that have been rounded to an appropriate number of decimal places. It’s sometimes
    nicer for readers of examples to use round() because it may be slightly easier
    to visualize how the function works, compared to the isclose() alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 15.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because of hash randomization, the hash keys used for sets are unpredictable.
    This is an important security feature, used to defeat a subtle denial-of-service
    attack. For details, see url: [http://www.ocert.org/advisories/ocert-2011-003.html.](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: Since Python 3.7, dictionary keys are guaranteed to be kept in insertion order.
    This means that an algorithm that builds a dictionary will provide a consistent
    sequence of key values. The same ordering guarantee is not made for sets. Interestingly,
    sets of integers tend to have a consistent ordering because of the way hash values
    are computed for numbers. Sets of other types of objects, however, will not show
    consistent ordering of items.
  prefs: []
  type: TYPE_NORMAL
- en: When confronted with unpredictable results like set ordering or internal object
    identification revealed by the __repr__() method, we have a testability issue.
    We can either change the software to be more testable, or we can change the test
    to tolerate some unpredictability.
  prefs: []
  type: TYPE_NORMAL
- en: Most floating-point implementations are reasonably consistent. However, there
    are few formal guarantees about the last few bits of any given floating-point
    number. Rather than trusting that all of the bits have exactly the right value,
    it’s often a good practice to round the value to a precision consistent with other
    values in the problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: Being tolerant of unpredictability can be taken too far, allowing the test to
    tolerate bugs. For more in-depth testing of mathematical functions, the [hypothesis](https://hypothesis.readthedocs.io/en/latest/)
    package provides ways to define a domain of robust test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 15.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can run the tests with the PYTHONHASHSEED environment variable set. In Linux
    (and macOS X) we can do this in a single command-line statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will provide a fixed, reproducible hash randomization while running doctest.
    We can also use PYTHONHASHSEED=0 to disable hash randomization.
  prefs: []
  type: TYPE_NORMAL
- en: The tox tool has a --hashseed=x option to allow setting a consistent hash seed
    to an integer value prior to running tests.
  prefs: []
  type: TYPE_NORMAL
- en: 15.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Testing things that involve dates or times](ch019_split_001.xhtml#x1-8430008)
    recipe, in particular, the now() method of datetime requires some care.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009)
    recipe shows how to test processing that involves using the random module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at how to work with external resources in the [Mocking external resources](ch019_split_001.xhtml#x1-85500010)
    recipe later in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.4 Unit testing with the unittest module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unittest module allows us to step beyond the examples used by doctest. Each
    test case can have one more scenario built as a subclass of the TestCase class.
    These use result checks that are more sophisticated than the literal text matching
    used by the doctest tool.
  prefs: []
  type: TYPE_NORMAL
- en: The unittest module also allows us to package tests outside docstrings. This
    can be helpful for tests for edge cases that might be too detailed to be helpful
    documentation. Often, doctest cases focus on the happy path – the most common
    use cases, where everything works as expected. We can use the unittest module
    to more easily define test cases that diverge from the happy path.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how we can use the unittest module to create more sophisticated
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s sometimes helpful to summarize a test following ideas behind the Gherkin
    language. In this test specification language, each scenario is described by GIVEN-WHEN-THEN
    steps. For this case, we have a scenario like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The TestCase class doesn’t precisely follow this three-part given-when-then
    (or arrange-act-assert) structure. A TestCase class generally has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A setUp() method must implement the Given steps of the test case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A runTest() method must handle the Then steps to confirm the results using a
    number of assertion methods to confirm the actual results match the expected results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The When steps can be in either method. The choice of where to implement the
    When steps is often tied to the question of reuse. For example, a class or function
    may have a number of methods to take different actions or make a number of state
    changes. In this case, it makes sense to pair each When step with distinct Then
    steps to confirm correct operation. The runTest() method can implement both When
    and Then steps. A number of subclasses can share the common setUp() method.
  prefs: []
  type: TYPE_NORMAL
- en: As another example, a class hierarchy may offer a number of alternative implementations
    for the same algorithm. In this case, the Then step confirmation of correct behavior
    is in the runTest() method. Each alternative implementation has a distinct subclass
    with a unique setup() method for the Given and When steps.
  prefs: []
  type: TYPE_NORMAL
- en: An optional tearDown() method is available for those tests that need to perform
    some cleanup of left-over resources. This is outside the test’s essential scenario
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create some tests for a class that is designed to compute some basic descriptive
    statistics. The unittest test cases let us define sample data that’s larger than
    anything we’d ever choose to enter as doctest examples. We can easily use thousands
    of data points rather than two or three as part of evaluating performance.
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of the code that we’re going to test was shown in the [Using docstrings
    for testing](ch019_split_000.xhtml#x1-7950001) recipe earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Because we’re not looking at the implementation details, we can think of this
    as opaque-box testing; the implementation details are not known to the tester.
  prefs: []
  type: TYPE_NORMAL
- en: We’d like to be sure that when we use thousands of samples, the class performs
    correctly. We’d also like to ensure that it works quickly; we’ll use this as part
    of an overall performance test, as well as a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need to create a separate module and a subclass of TestCase in that module.
    Tools like pytest can discover test modules if their names begin with test_, giving
    us a naming convention for these additional modules. Here’s how we can creates
    tests separate from the module’s code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file with a name related to the module under test. If the module was
    named summary.py, then a good name for a test module would be test_summary.py.
    Using the test_ prefix makes it easier for tools like pytest to find the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll use the unittest module for creating test classes. We’ll also be using
    the random module to scramble the input data. We’ll also import the module under
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a subclass of TestCase. Provide this class with a name that shows the
    intent of the test. We’ve chosen a name with a summary of the three steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a setUp() method in this class that handles the Given step of the test.
    We’ve created a collection of 1,001 samples shuffled into a random order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a runTest() method that handles the When step of the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add assertions to the runTest() method to implement the Then steps of the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If our test module is called recipe_04.py, we can use the following command
    to find TestCase classes in the recipe_04 module and run them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If all of the assertions pass, then the test suite will pass and the test run
    will be successful overall.
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TestCase class is used to define one test case. The class can have a setUp()
    method to create the unit and possibly the request. The class must have at least
    a runTest() method to make a request of the unit and check the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single test often isn’t sufficient. If we created three separate test classes
    in the recipe_04.py module, then we would see output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As each test is passed, a . is displayed. This shows that the test suite is
    making progress. The summary shows the number of tests run and the time. If there
    are failures or exceptions, the counts shown at the end will reflect these.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there’s a summary line. In this case, it consists of OK, showing that
    all the tests passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we include a test that fails, we’ll see the following output when we use
    the -v option to get verbose output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There’s a final summary of FAILED. This includes (failures=1) to show how many
    tests failed.
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In these examples, we have two assertions for the two Then steps inside the
    runTest() method. If one fails, the test stops as a failure, and the other step
    is not exercised.
  prefs: []
  type: TYPE_NORMAL
- en: This is a weakness in the design of this test. If the first assertion fails,
    we may not get all of the diagnostic information we might want. We should avoid
    having a sequence of otherwise independent assertions in the runTest() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want more diagnostic details, we have two general choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Use multiple test methods instead of a single runTest(). We can create multiple
    methods with names that start with test_. The default implementation of the test
    loader will execute the setUp() method prior to each separate test_ method when
    there is no overall runTest() method. This is often the simplest way to group
    a number of related tests together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use multiple subclasses of the TestCase subclass, each with a separate Then
    step implementation. When the setUp() is inherited, this will be shared by each
    subclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following the first alternative, the test class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We’ve refactored the setUp() method to include the Given and When steps of the
    test. The two independent Then steps are refactored into their own separate test_mean()
    and test_median() methods. These two methods are used instead of the runTest()
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Since each test is run separately, we’ll see separate error reports for problems
    with computing the mean or with computing the median.
  prefs: []
  type: TYPE_NORMAL
- en: The TestCase class defines numerous assertions that can be used as part of the
    Then steps. We encourage careful study of the unittest section of the Python Standard
    Library documentation to see all of the variations available.
  prefs: []
  type: TYPE_NORMAL
- en: In all but the smallest projects, it’s common practice to sequester the test
    files into a separate directory, often called tests. When this is done, we can
    rely on the discovery application that’s part of the unittest framework.
  prefs: []
  type: TYPE_NORMAL
- en: The unittest loader can search each module in a given directory for all classes
    that are derived from the TestCase class. This collection of classes within the
    larger collection of modules becomes the complete TestSuite.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this with the discover command of the unittest package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will locate all test cases in all test modules in the tests directory of
    a project.
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll combine unittest and doctest in the [Combining pytest and doctest tests](ch019_split_001.xhtml#x1-8370007)
    recipe next in this chapter. We’ll look at mocking external objects in the [Mocking
    external resources](ch019_split_001.xhtml#x1-85500010) recipe later in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)
    recipe later in this chapter covers the same test case from the perspective of
    the pytest tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.5 Combining unittest and doctest tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, we’ll want to combine tests written for the unittest and doctest
    tools. For examples of using the doctest tool, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe earlier in this chapter. For examples of using the unittest tool, see the
    [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004) recipe
    earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The doctest examples are an essential element of the documentation strings on
    modules, classes, methods, and functions. The unittest cases will often be in
    a separate tests directory in files with names that match the pattern test_*.py.
    An important part of creating trustworthy software is running as wide a variety
    of tests as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at ways to combine a variety of tests into one tidy
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll refer back to the example from the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe, shown earlier in this chapter. This recipe created tests for a class,
    Summary, that does some statistical calculations. In that recipe, we included
    examples in the docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe earlier in this chapter, we wrote some TestCase classes to provide additional
    tests for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'As context, we’ll assume there’s a project folder structure that looks like
    the following directory tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This means tests are in both the src/summary.py module and in the tests/test_summary.py
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We need to combine all of the tests into a single, comprehensive test suite.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe examples use recipe_01.py instead of some cooler name such as summary.py.
    Ideally, a module should have a memorable, meaningful name. The book content is
    quite large, and the names are designed to match the overall chapter and recipe
    outline.
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To combine unittest and doctest test cases, we’ll start with an existing test
    module, and add a load_tests() function to merge the relevant doctest with the
    existing unittest test cases. A function named load_tests() must be provided.
    This name is required so the unittest loader will use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use doctest tests, import the doctest module. To write TestCase classes,
    import the unittest module. We’ll also need the random module so we can control
    the random seeds in use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the modules containing doctest examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement the load_tests protocol, define a load_tests() function in the
    test module. We’ll combine the standard tests automatically discovered by unittest
    with the additional tests found by the doctest module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The loader argument value to the load_tests() function is the test case loader
    currently being used; this is generally ignored. The standard_tests argument value
    will be all of the tests loaded by default. Generally, this is the suite of all
    subclasses of TestCase. The function updates this object with the additional tests.
    The pattern value is the value provided to the loader to locate tests; this is
    also ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this from the OS command prompt, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that the unittest test cases were included as well as doctest
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The unittest.main() application uses a test loader to find all of the relevant
    test cases. The loader is designed to find all classes that extend TestCase. It
    will also look for a load_tests() function. This function can provide a suite
    of additional tests. It can also do non-default searches for tests when that’s
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we can import a module with docstrings and use a DocTestSuite to
    build a test suite from the imported module. We can, of course, import other modules
    or even scan the README file for more examples to test. The goal is to make sure
    every example in both the code and the documentation actually works.
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, a module may be quite complicated; this can lead to multiple
    test modules. The test modules may have names such as tests/test_module_feature_X.py
    to show that there are tests for separate features of a very complex module. The
    volume of code for test cases can be quite large, and keeping the features separate
    can be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, we might have a test module that has tests for several different
    but closely related small modules. A single test module may employ inheritance
    techniques to cover all the modules in a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'When combining many smaller modules, there may be multiple suites built in
    the load_tests() function. The body might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will incorporate doctest examples from multiple modules into a single,
    comprehensive test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For examples of doctest, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe earlier in the chapter. For examples of unittest, see the [Unit testing
    with the unittest module](ch019_split_000.xhtml#x1-8190004) recipe earlier in
    this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.6 Unit testing with the pytest module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pytest tool allows us to step beyond the examples used by doctest in docstrings.
    Instead of using a subclass of TestCase, the pytest tool lets us use function
    definitions. The pytest approach uses Python’s built-in assert statement, leaving
    the test case looking somewhat simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pytest tool is not part of Python; it needs to be installed separately.
    Use a command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we’ll look at how we can use pytest to simplify our test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Gherkin language can help to structure a test. For this recipe, we have
    a scenario like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A pytest test function doesn’t precisely follow the Gherkin three-part structure.
    A test function generally has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, fixtures are defined to establish the Given steps. Fixtures are
    designed for reuse as well as composition. A fixture can also tear down resources
    after a test has finished.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the function will usually handle the When steps to exercise the
    object being tested and the Then steps to confirm the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These boundaries are not fixed. A fixture might, for example, create an object
    and also take action, executing both the Given and When steps. This permits multiple
    test functions to apply several independent Then steps.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create some tests for a class that is designed to compute some basic descriptive
    statistics. The bulk of the code was shown in the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an outline of the class, provided as a reminder of what the method
    names are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We want to duplicate testing shown in the [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe. We’ll use the pytest features to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s often best to start with a separate test file, perhaps even a separate
    tests directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a test file with a name similar to the module under test. If the module
    file was named summary.py, then a good name for a test module would be test_summary.py.
    Using the test_ prefix makes the test easier to find.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll use the pytest module for creating test classes. We’ll also be using
    the random module to scramble the input data. Also, we need to import the module
    under test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the Given step as a fixture. This is marked with the @pytest.fixture
    decorator. It creates a function that can return a useful object, data for creating
    an object, or a mocked object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the When and Then steps as a test function with a name visible to
    pytest. This means the function name must begin with test_:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a parameter name in a test function definition is the name of a fixture
    function, the fixture function is evaluated automatically. The results of the
    fixture function are provided at runtime. This means the shuffled set of 1,000
    values will be provided as an argument value for the flat_data parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a When step to perform an operation on an object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the Then steps to validate the outcome:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If our test module is called test_summary.py, we can often execute the tests
    found in it with a command like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This will invoke the main application that’s part of the pytest package. It
    will search the given file for functions with names starting with test_ and execute
    those test functions.
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re using several parts of the pytest package:'
  prefs: []
  type: TYPE_NORMAL
- en: The @fixture decorator can be used to create reusable test fixtures with objects
    in known states, ready for further processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pytest application to do several things:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover tests. By default, it searches a directory named tests for module names
    starting with test_. Within those, it looks for functions with names starting
    with test_. It also finds unittest.TestCase classes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run all of the tests, evaluating the fixtures as needed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a summary of the results.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we run the pytest command, we’ll see output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As each test is passed, a . is displayed. This shows that the test suite is
    making progress. The summary shows the number of tests run and the time. If there
    are failures or exceptions, the counts on the last line will reflect this.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change one test slightly to be sure that it fails, we’ll see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This shows a summary of passing and failing tests and the details of each failure.
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have two Then steps inside the test_flat() function. These
    are implemented as two assert statements. If the first one fails, the test stops
    as a failure, and the following step will be skipped. This means we might not
    see all the diagnostic information we might need.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better design is to use multiple test functions. All of the functions can
    share a common fixture. In this case, we can create a second fixture that depends
    on the flat_data fixture and builds a Summary object to be used by a number of
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Since each of these test functions are run separately, we’ll see separate error
    reports for problems when computing the mean and the median, or possibly when
    computing both.
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe in this chapter covers the same test case from the perspective of the unittest
    module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.7 Combining pytest and doctest tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, we’ll have a combination of pytest and doctest test cases. For
    examples of using the doctest tool, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe. For examples of using the pytest tool, see the [Unit testing with the
    pytest module](ch019_split_001.xhtml#x1-8310006) recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, documentation will contain doctest. We need to be sure all examples
    – in docstrings and documentation – work correctly. In this recipe, we’ll combine
    these doctest examples and the pytest test cases into one tidy package.
  prefs: []
  type: TYPE_NORMAL
- en: 15.7.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll refer back to the example from the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe. This recipe created tests for a class, Summary, that does some statistical
    calculations. In that recipe, we included examples in the docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)
    recipe, we wrote some test functions to provide additional tests for this class.
    These tests were put into a separate module, with a name starting with test_,
    specifically, test_summary.py.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the [Combining unittest and doctest tests](ch019_split_000.xhtml#x1-8250005)
    recipe, we’ll also assume there’s a project folder structure that looks like the
    following directory tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The tests directory should contain all the module files with tests. We’ve chosen
    the directory named tests and a module named test_*.py so that they fit well with
    the automated test discovery features of the pytest tool.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe examples use recipe_07 instead of a cooler name such as summary.
    As a general practice, a module should have a memorable, meaningful name. The
    book’s content is quite large, and the names are designed to match the overall
    chapter and recipe outline.
  prefs: []
  type: TYPE_NORMAL
- en: 15.7.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It turns out that we don’t need to write any Python code to combine the tests.
    The pytest module will locate test functions. It can also be used to locate doctest
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a shell command to run the test suite in the recipe_07.py file, as well
    as to examine the recipe_01.py module for the additional doctest cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run this from the OS command prompt, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The pytest command worked with both files. The dots after recipe_07.py show
    that two test cases were found in this file. This was 28% of the test suite. The
    dots after recipe_01.py show that five test cases more were found; this was the
    remaining 72% of the suite.
  prefs: []
  type: TYPE_NORMAL
- en: This shows us that the pytest test cases were included as well as doctest test
    cases. What’s helpful is that we don’t have to adjust anything in either of the
    test suites to execute all of the available test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 15.7.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pytest application has a variety of ways to search for test cases. The default
    is to search the given paths for all functions with names that start with test_
    in a given module. It will also search for all subclasses of TestCase. If we provide
    a directory, it will search it for all modules with names that begin with test_.
    Often, we’ll collect our test files in a directory named tests because this is
    the default directory that will be searched.
  prefs: []
  type: TYPE_NORMAL
- en: The --doctest-modules command-line option is used to mark modules that contain
    doctest examples. These examples are also added to the test suite as test cases.
  prefs: []
  type: TYPE_NORMAL
- en: This level of sophistication in finding and executing a variety of types of
    tests makes pytest a very powerful tool. It makes it easy to create tests in a
    variety of forms to create confidence that our software will work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 15.7.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding the -v option provides a more detailed view of the tests found by the
    pytest tool. Here’s how the additional details are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Each individual test is identified, providing us with a detailed explanation
    of the test processing. This can help confirm that all of the expected doctest
    examples were properly located in the module under test.
  prefs: []
  type: TYPE_NORMAL
- en: 15.7.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For examples of doctest, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe earlier in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)
    recipe earlier in this chapter has the pytest test cases used for this recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For examples of the unittest version of these tests, see the [Unit testing with
    the unittest module](ch019_split_000.xhtml#x1-8190004) recipe earlier in this
    chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.8 Testing things that involve dates or times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many applications rely on functions like datetime.datetime.now() or time.time()
    to create a timestamp. When we use one of these functions with a unit test, the
    results are essentially impossible to predict. This is an interesting dependency
    injection problem here: our application depends on a class that we would like
    to replace only when we’re testing.'
  prefs: []
  type: TYPE_NORMAL
- en: One option is to design our application to avoid functions like now(). Instead
    of using this method directly, we can create a factory function that emits timestamps.
    For test purposes, this function can be replaced with one that produces known
    results.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative is called monkey-patching – injecting a new object at test time.
    This can reduce the design complexity; it tends to increase the test complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll write tests with datetime objects. We’ll need to create
    mock objects for datetime instances to create repeatable test values. We’ll use
    the pytest package features for monkey-patching.
  prefs: []
  type: TYPE_NORMAL
- en: 15.8.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll work with a small function that creates a CSV file. This file’s name will
    include the date and time in the format of YYYYMMDDHHMMSS as a long string of
    digits. This kind of file-naming convention might be used by a long-running server
    application. The name helps match a file and related log events. It can help to
    trace the work being done by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application uses this function to create these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This function has the use of now(), which produces a distinct value each time
    this is run. Since this value is difficult to predict, it makes test assertions
    difficult to write.
  prefs: []
  type: TYPE_NORMAL
- en: To create a reproducible test output, we can create a mock version of the datetime
    module. We can then monkey patch the test context to use this mock object instead
    of the actual datetime module. Within the mocked module, we can create a mock
    class with a mock now() method to provide a fixed, easy-to-test response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this case, we have a scenario like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This can be implemented as a test case using the pytest constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 15.8.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will create and patch mock objects to create a test fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need to import a number of modules required by the module we’re testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also need the core tools for creating mock objects and test fixtures.
    Also, we’ll need the module we’re going to test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must create an object that will behave like the datetime module for the
    purposes of the test scenario. This mocked module must contain a name that appears
    to be a class, also named datetime. The class must appear to contain a method,
    now(), which returns a known object rather than a date that changes each time
    the test is run. We’ll create a fixture, and the fixture will return this mock
    object with a small set of attributes and behaviors defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Mock object is a namespace, a feature that packages, modules, and classes
    all share. In this example, each attribute name is another Mock object. The most
    deeply-buried object has a return_value attribute to make it behave like a function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also need a way to isolate the behavior of the filesystem into test directories.
    The tmppath fixture is built in to pytest and provides temporary directories into
    which test files can be written safely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now define a test function that will use the mock_datetime fixture and
    the tmppath fixture. It will use the monkeypatch fixture to adjust the context
    of the module under test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use the monkeypatch fixture to replace an attribute of the recipe_08
    module. The datetime attribute value will be replaced with the Mock object created
    by the mock_datetime fixture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Between the fixture definitions and this patch, we’ve created a Given step that
    defines the test arrangement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now exercise the save_data() function in a controlled test environment.
    This is the When step that exercises the code under test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the date and time are fixed by the Mock object, the output file has a
    known, predictable name. We can read and validate the expected data in the file.
    Further, we can interrogate the Mock object to be sure it was called exactly once
    with no argument values. This is a Then step to confirm the expected results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test confirms the application’s save_data() function will create the expected
    file with the proper content.
  prefs: []
  type: TYPE_NORMAL
- en: 15.8.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The unittest.mock module has a wonderfully sophisticated class definition, the
    Mock class. A Mock object can behave like other Python objects, while offering
    a limited subset of behaviors. In this example, we’ve created three different
    kinds of Mock objects.
  prefs: []
  type: TYPE_NORMAL
- en: The Mock(wraps="datetime", ...) object mocks a complete module. It will behave,
    to the extent needed by this test scenario, like the standard library datetime
    module. Within this object, we created a mock class definition but didn’t assign
    it to any variable.
  prefs: []
  type: TYPE_NORMAL
- en: The Mock(now=...) object behaves like a mock class definition inside the mock
    module. We’ve created a single now attribute value, which will behave like a static
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The Mock(return_value=...) object behaves like an ordinary function or method.
    We provide the return value required for this test.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to returning the given value, a Mock object records the history
    of calls. This means an assertion can checks those calls. The call() function
    from the Mock module provides a way to describe the arguments that are expected
    in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 15.8.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we created a mock for the datetime module that had a very narrow
    feature set for this test. The module contained a mocked class named datetime.
    This class has a single attribute, a mocked function, now().
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the return_value attribute, we can use the side_effect attribute
    to raise an exception instead of returning a value. We can use this to spot code
    that’s not using the now() method properly, but using the deprecated utcnow()
    or the today() methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend this pattern and mock more than one attribute to behave like
    a function. Here’s an example that mocks several functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Two of the mocked methods, utcnow() and today(), each define a side effect that
    will raise an exception. This allows us confirm legacy code has been converted
    to make proper use of the now() method.
  prefs: []
  type: TYPE_NORMAL
- en: 15.8.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe earlier in this chapter has more information about the basic use of the
    unittest module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.9 Testing things that involve randomness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications rely on the random module to create random values or put values
    into a random order. In many statistical tests, repeated random shuffling or random
    selection is done. When we want to test one of these algorithms, any intermediate
    results or details of the processing are essentially impossible to predict.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two choices for trying to make the random module predictable enough
    to write detailed unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the random module with a known seed value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a Mock object to replace the random module with a Mock object to produce
    predictable values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at ways to unit test algorithms that involve randomness.
  prefs: []
  type: TYPE_NORMAL
- en: 15.9.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a sample dataset, we can compute a statistical measure such as a mean
    or median. A common next step is to determine the likely values of these statistical
    measures for some overall population. This can be done by a technique called bootstrapping.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to resample the initial set of data repeatedly. Each of the resamples
    provides a different estimate of the statistical measures for the population.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be sure that a resampling algorithm is implemented correctly, it
    helps to eliminate randomness from the processing. We can resample a carefully
    planned set of data with a non-randomized version of the random.choice() function.
    If this works properly, then we have confidence that the randomized version will
    also work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our candidate resampling function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'For our example, we’ll compute alternative values of the mean based on resampling.
    The overall resampling procedure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This evaluates the resample() function to create a number of subsets. Each subset’s
    mean populates the means collection. The histogram created by this mean_distribution()
    function will provide a helpful estimate for population variance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that the most likely value for the mean of the overall population
    could be between 7.1 and 7.8\. There’s more to this kind of analysis than we’re
    showing here. Our focus is limited to the narrow question of testing the resample()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test for resampling involves a scenario like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 15.9.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll define a mock object that can be used instead of the random.choice()
    function. With this fixture in place, the results are fixed and predictable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need the core tools for creating mock objects and test fixtures. Also,
    we’ll need the module we’re going to test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll need an object that will behave like the choice() function. We’ll create
    a fixture built on another fixture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The expected_resample_data fixture provides a specific list of values that will
    provide expected results. Using this fixture, the mock_random_choice choice fixture
    returns the expected values in response to the choice() function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now define a test function that will use the mock_random_choice fixture,
    which creates a mock object, and the monkeypatch fixture, which lets us adjust
    the context of the module under test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use the monkeypatch fixture to replace the choice attribute of the random
    module with the Mock object created by the mock_random_choice fixture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Between the fixture definitions and this patch, we’ve created a Given step that
    defines the test arrangement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now exercise the resample() function in a controlled test environment.
    This is the When step that exercises the code under test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the random choices are fixed by the Mock object, the result is fixed.
    We can confirm that the data created by the mock_random_choice fixture was used
    for resampling. We can also confirm that the mocked choice function was properly
    called with the input data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test helps to confirm that our resample() function will create the output
    based on the given input and the random.choice() function.
  prefs: []
  type: TYPE_NORMAL
- en: 15.9.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create a Mock object, we must provide the methods and attributes to
    define the behavior of the object being mocked. When we create an instance of
    Mock that provides the side_effect argument value, we’re creating a callable object.
    The callable object will return the next value from the side_effect sequence each
    time the Mock object is called. This gives us a handy way to mock iterators.
  prefs: []
  type: TYPE_NORMAL
- en: If any value in side_effect is an exception, this is raised.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see the call history using the mock_calls attribute of a Mock object.
    This lets us confirm that the callable was provided proper argument values.
  prefs: []
  type: TYPE_NORMAL
- en: 15.9.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The resample() function has an interesting pattern to it. When we take a step
    back from the details, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The X argument value is simply passed through to another function without any
    processing. For testing purposes, it doesn’t matter what the value of X is. What
    we’re testing is that the parameter’s value in the resample() function is provided
    to the another_function() function, untouched.
  prefs: []
  type: TYPE_NORMAL
- en: The mock library provides an object called sentinel that can be used to create
    an opaque argument value in these circumstances. When we refer to an attribute
    of the sentinel object, this reference creates a distinct object. We might use
    sentinel.POPULATION as a kind of mock for a collection of values. The exact collection
    doesn’t matter since it’s simply passed as an argument to another function (called
    random.choice() in the actual code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how this use of a sentinel object can change this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The output from the mocked choice() function is a recognizable sentinel object.
    Similarly, the parameter to the resample() function is a different sentinel object.
    We expect this to be called 8 times, because the N parameter is set to 8 in the
    test case.
  prefs: []
  type: TYPE_NORMAL
- en: When an object should pass through a function untouched, we can write test assertions
    to confirm this expected behavior. If the code we’re testing uses the population
    object improperly, the test can fail when the result is not the untouched sentinel
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 1.7.1 release of the mypy tool struggles with the imports in the recipe_09
    module. We used a # type: ignore [attr-defined] comment to suppress a confusing
    mypy message.'
  prefs: []
  type: TYPE_NORMAL
- en: This test gives us confidence that the population of values is provided, untouched,
    to the random.choice() function and the N parameter value defines the size of
    the returned set of items from the population.
  prefs: []
  type: TYPE_NORMAL
- en: 15.9.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Building sets – literals, adding, comprehensions, and operators](ch008_split_001.xhtml#x1-2670007)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004), and the [Creating dictionaries
    – inserting and updating](ch009.xhtml#x1-2900001) recipe in Chapter [5](ch009.xhtml#x1-2890005),
    the [Using cmd to create command-line applications](ch010.xhtml#x1-3610006) recipe
    in Chapter [6](ch010.xhtml#x1-3300006) show how to seed the random number generator
    to create a predictable sequence of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Chapter [7](ch011_split_000.xhtml#x1-3760007), there are several other recipes
    that show an alternative approach, for example, [Using a class to encapsulate
    data and processing](ch011_split_000.xhtml#x1-3770001), [Designing classes with
    lots of processing](ch011_split_000.xhtml#x1-3890003), [Optimizing small objects
    with __slots__](ch011_split_001.xhtml#x1-4130007), and [Using properties for lazy
    attributes](ch011_split_001.xhtml#x1-43100010).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, in Chapter [8](ch012.xhtml#x1-4520008), see the [Choosing between inheritance
    and composition – the ”is-a” question](ch012.xhtml#x1-4530001), [Separating concerns
    via multiple inheritance](ch012.xhtml#x1-4610002), [Leveraging Python’s duck typing](ch012.xhtml#x1-4670003),
    and [Creating a class that has orderable objects](ch012.xhtml#x1-4870006) recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.10 Mocking external resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier recipes in this chapter, namely, [Testing things that involve dates
    or times](ch019_split_001.xhtml#x1-8430008) and [Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009),
    we wrote tests for involving resources with states that we could predict and mock.
    In one case, we created a mock datetime module that had a fixed response for the
    current time. In the other case, we created a mock function from the random module.
  prefs: []
  type: TYPE_NORMAL
- en: A Python application can use the os, subprocess, and pathlib modules to make
    significant changes to the internal states of a running computer. We’d like to
    be able to test these external requests in a safe environment, using mocked objects,
    and avoid the horror of corrupting a working system with a misconfigured test.
    Another example is database access, which requires mock objects to respond to
    create, retrieve, update, and delete requests.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at ways to create more sophisticated mock objects.
    These will allow the safe testing of changes to precious OS resources like files
    and directories.
  prefs: []
  type: TYPE_NORMAL
- en: 15.10.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll revisit an application that makes a number of OS changes. In Chapter [11](ch015_split_000.xhtml#x1-61500011),
    the [Replacing a file while preserving the previous version](ch015_split_000.xhtml#x1-6260002)
    recipe showed how to write a new file and then rename it so that the previous
    copy was always preserved.
  prefs: []
  type: TYPE_NORMAL
- en: A thorough set of test cases would present a variety of failure modes. Having
    tests for several different kinds of errors can help provide confidence that the
    function behaves properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential design was a definition of a class of objects, Quotient, and
    a save_data() function to write one of those objects to a file. Here’s an overview
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider what happens when there’s a failure in the middle of the save_data()
    function. Outcomes include a file that’s partially rewritten, and useless to other
    applications. To prevent this, the recipe presented a safe_write() function that
    included several steps to create a temporary file and then rename that file to
    be the desired output file. Essentially, the function looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The safe_write() function is shown in detail in Chapter [11](ch015_split_000.xhtml#x1-61500011).
    This is designed to handle a number of scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything works – sometimes called the ”happy path” – and the file is created
    properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The save_data() function raises an exception. The corrupted file is removed
    and the original left in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failure occurs elsewhere in the processing of the safe_write() processing. There
    are three scenarios where a Path method raises an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each of the above scenarios can be translated into Gherkin to help clarify
    precisely what it means; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Detailing each of the five scenarios helps us define Mock objects to provide
    the various kinds of external resource behaviors we need. Each scenario suggests
    a distinct fixture to reflect the distinct failure mode.
  prefs: []
  type: TYPE_NORMAL
- en: 15.10.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll use a variety of testing techniques. The pytest package offers the tmp_path
    fixture, which can be used to create isolated files and directories. In addition
    to an isolated directory, we’ll also want to use a Mock to stand in for the parts
    of the application that we’re not testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify all of the fixtures required for the various scenarios. For the happy
    path, where the mocking is minimal, the tmp_path fixture is all we need. For scenario
    two, where the save_data() function is broken, this function should be mocked.
    For the remaining three scenarios, mock objects can be defined that will replace
    methods of Path objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This test will use a number of features from the pytest and unittest.mock modules.
    It will be creating Path objects and test functions defined in the recipe_10 module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a test fixture to create the original file, which should not be disturbed
    unless everything works correctly. We’ll use a sentinel object to provide some
    text that is unique and recognizable as part of this test scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a mock to replace the save_data() function. This will create mock data
    used to validate that the safe_write() function works. In this, too, we’ll use
    a sentinel object to create a unique string that is recognizable later in the
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the happy path scenario. The save_data_good() function can be given as
    the side_effect of a Mock object and used in place of the original save_data()
    function. Using a Mock means the call history will be tracked. This helps to confirm
    that the overall safe_write() function being tested really does use the save_data()
    function to create the expected resulting file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a mock for scenario two, in which the save_data() function fails to work
    correctly. The mock can rely on a save_data_failure() function to write recognizably
    corrupt data, and then also raise an unexpected exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the test case for scenario two, using the save_data_failure() function
    as the side_effect of a Mock object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The save_data_failure() function wrote corrupt data, but the safe_write() function
    preserved the original file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This recipe produced two test scenarios that confirm the safe_write() function
    will work. We’ll turn to the remaining three scenarios in the There’s more… section
    later in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 15.10.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When testing software that makes OS, network, or database requests, it’s imperative
    to include cases where the external resource fails to operate as expected. The
    principal tools for doing this are Mock objects and the monkeypatch fixture. A
    test can replace Python library functions with Mock objects that raise exceptions
    instead of working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: For the happy path scenario, we replaced the save_data() function with a Mock
    object that wrote some recognizable data. Because we’re using the tmp_path fixture,
    the file was written into a safe, temporary directory, where it could be examined
    to confirm that new, good data replaced the original data.
  prefs: []
  type: TYPE_NORMAL
- en: For the first of the failure scenarios, we used the monkeypatch fixture to replace
    the save_data() function with a function that both wrote corrupt data and also
    raised an exception as if an OS problem occurred. This is one way to simulate
    a broad spectrum of application failures that involve some kind of persistent
    filesystem artifact. In simpler cases, where there is no artifact, a Mock object
    with an exception class as the value of the side_effect parameter is all that’s
    required to simulate a failure.
  prefs: []
  type: TYPE_NORMAL
- en: These test scenarios also made use of unique sentinel objects. Evaluating the
    value of the hex(id(x)) provides a distinct string value that’s difficult to predict.
  prefs: []
  type: TYPE_NORMAL
- en: 15.10.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The remaining scenarios are very similar; they can all share the following
    test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This function uses the save_data_good() function as the side effect when the
    mocked save_data() function is invoked. The given save_data_good() function will
    be executed and will write a known good test file. Each of these scenarios involve
    exceptions from Path operations after the good file was created.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve omitted showing any scenario-specific details. The key feature of this
    test is preserving the original good data in spite of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: To support multiple exception scenarios, we want to use three different versions
    of the mock_pathlib_path mock object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a parameterized fixture to spell out these three alternative configurations
    of the mock objects. First, we’ll package the choices as three separate dictionaries
    that provide the side_effect values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used RuntimeError as the exception to raise, triggering alternative execution
    paths. In some cases, it may be necessary to use a IOError exception. In this
    case, any exception would be fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given these three dictionary objects, we can plug the values into a fixture
    via the request.params option provided by pytest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Because this fixture has three parameter values, any test using this fixture
    will be run three times, once with each of the values. This lets us reuse the
    test_safe_write_scenarios() test case to be sure it works with a variety of system
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve created a variety of mock objects to inject failures throughout the processing
    in a complex function. Using parameterized fixture helps to define consistent
    mock objects for these tests.
  prefs: []
  type: TYPE_NORMAL
- en: There’s yet another scenario that involves a successful operation followed by
    a failing operation on the same file. This doesn’t fit the above pattern and requires
    another test case with a slightly more sophisticated set of mock objects. We leave
    this as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 15.10.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Testing things that involve dates or times](ch019_split_001.xhtml#x1-8430008)
    and [Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009)
    recipes earlier in this chapter show techniques for dealing with unpredictable
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements of this can be tested with the doctest module. See the [Using docstrings
    for testing](ch019_split_000.xhtml#x1-7950001) recipe earlier in this chapter
    for examples. It’s also important to combine these tests with any doctests. See
    the [Combining pytest and doctest tests](ch019_split_001.xhtml#x1-8370007) recipe
    earlier in this chapter for more information on how to do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
