- en: '15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '15'
- en: Testing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: 'Testing is central to creating working software. Here’s the canonical statement
    describing the importance of testing:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于创建可工作的软件至关重要。以下是描述测试重要性的经典陈述：
- en: ”Any program feature without an automated test simply doesn’t exist”.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “任何没有自动化测试的程序功能实际上是不存在的”。
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(Kent Beck, Extreme Programming Explained: Embrace Change)'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (Kent Beck，《极限编程解释：拥抱变化》)
- en: 'We can distinguish several kinds of testing:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分几种测试类型：
- en: 'Unit testing:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试：
- en: 'This applies to independent units of software: functions, classes, or modules.
    The unit is tested in isolation to confirm that it works correctly.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于独立的软件单元：函数、类或模块。单元在隔离状态下进行测试，以确认其正确性。
- en: Integration testing
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试
- en: ': This combines units to be sure they integrate properly.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ': 这将组合单位以确保它们正确集成。'
- en: System testing
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试
- en: ': This tests an entire application or a system of interrelated applications
    to be sure that the suite of software components works properly. This is also
    called end-to-end testing or functional testing. This is often used for acceptance
    testing to confirm that software is fit for use.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ': 这测试整个应用程序或一系列相互关联的应用程序，以确保软件组件套件正常工作。这也被称为端到端测试或功能测试。这通常用于验收测试，以确认软件适合使用。'
- en: Performance testing
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试
- en: ': This ensures that a unit, subsystem, or whole system meets performance objectives
    (also often known as load testing). In some cases, performance testing includes
    the study of resources such as memory, threads, or file descriptors. The goal
    is to be sure that software makes appropriate use of system resources. This is
    sometimes called benchmarking, when the goal is to measure resource usage instead
    of ensuring that the usage is below some threshold.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ': 这确保了单元、子系统或整个系统满足性能目标（也常称为负载测试）。在某些情况下，性能测试包括对资源（如内存、线程或文件描述符）的研究。目标是确保软件适当地使用系统资源。这有时被称为基准测试，当目标是衡量资源使用而不是确保使用低于某个阈值时。'
- en: These are some of the more common types. In this chapter, we’ll focus on unit
    testing since it is foundational to creating trust that software works reliably.
    Other forms of testing rest on the foundation of reasonably complete unit tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些更常见的类型。在本章中，我们将重点关注单元测试，因为它是创建对软件可靠工作的信任的基础。其他测试形式建立在合理完整的单元测试的基础上。
- en: 'It’s sometimes helpful to summarize a test scenario following the Gherkin language.
    In this test specification language, each scenario is described by GIVEN-WHEN-THEN
    steps. Here’s an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时根据 Gherkin 语言总结测试场景是有帮助的。在这种测试规范语言中，每个场景都由 GIVEN-WHEN-THEN 步骤描述。以下是一个示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This approach to writing tests describes the given starting state or arrangement,
    an action to perform, and one or more assertions about the resulting state after
    the action. This is sometimes called the ”arrange-act-assert” pattern.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编写测试的方法描述了给定的起始状态或安排，要执行的操作，以及关于操作后结果状态的一个或多个断言。这有时被称为“安排-执行-断言”模式。
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下食谱：
- en: '[Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 docstrings 进行测试](ch019_split_000.xhtml#x1-7950001)'
- en: '[Testing functions that raise exceptions](ch019_split_000.xhtml#x1-8040002)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试引发异常的函数](ch019_split_000.xhtml#x1-8040002)'
- en: '[Handling common doctest issues](ch019_split_000.xhtml#x1-8100003)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[处理常见的 doctest 问题](ch019_split_000.xhtml#x1-8100003)'
- en: '[Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 unittest 模块进行单元测试](ch019_split_000.xhtml#x1-8190004)'
- en: '[Combining unittest and doctest tests](ch019_split_000.xhtml#x1-8250005)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结合 unittest 和 doctest 测试](ch019_split_000.xhtml#x1-8250005)'
- en: '[Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 pytest 模块进行单元测试](ch019_split_001.xhtml#x1-8310006)'
- en: '[Combining pytest and doctest tests](ch019_split_001.xhtml#x1-8370007)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结合 pytest 和 doctest 测试](ch019_split_001.xhtml#x1-8370007)'
- en: '[Testing things that involve dates or times](ch019_split_001.xhtml#x1-8430008)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试涉及日期或时间的事物](ch019_split_001.xhtml#x1-8430008)'
- en: '[Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试涉及随机性的事物](ch019_split_001.xhtml#x1-8490009)'
- en: '[Mocking external resources](ch019_split_001.xhtml#x1-85500010)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模拟外部资源](ch019_split_001.xhtml#x1-85500010)'
- en: We’ll start by including tests within the docstring of a module, class, or function.
    This makes the test case act as both documentation of the design intent and a
    verifiable confirmation that it really does work as advertised.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在模块、类或函数的 docstring 中包含测试开始。这使得测试案例既充当设计意图的文档，也充当可验证的确认，确实按广告宣传的方式工作。
- en: 15.1 Using docstrings for testing
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.1 使用文档字符串进行测试
- en: Good Python includes docstrings inside every module, class, function, and method.
    Many tools can create useful, informative documentation from docstrings. Refer
    back to the [Writing clear documentation strings with RST markup](ch007_split_001.xhtml#x1-2030007)
    recipe in Chapter [3](ch007_split_000.xhtml#x1-1610003) for an example of how
    to create docstrings.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的 Python 代码在每个模块、类、函数和方法中都包含文档字符串。许多工具可以从文档字符串中创建有用、信息丰富的文档。请参考第 3 章（ch007_split_000.xhtml#x1-1610003）中关于如何创建文档字符串的示例菜谱
    [Writing clear documentation strings with RST markup](ch007_split_001.xhtml#x1-2030007)。
- en: One important element of a docstring is a concrete example. The examples provided
    in docstrings can become unit-test cases that are exercised by Python’s doctest
    tool.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串的一个重要元素是具体的示例。文档字符串中提供的示例可以成为由 Python 的 doctest 工具执行的单元测试用例。
- en: In this recipe, we’ll look at ways to turn examples into proper automated test
    cases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何将示例转换为合适的自动化测试用例。
- en: 15.1.1 Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.1 准备工作
- en: We’ll look at a small function definition as well as a class definition. Each
    of these will contain docstrings that include examples that can be used as automated
    tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个小的函数定义以及一个类定义。每个都将包含包含可以用于自动化测试的示例的文档字符串。
- en: 'We’ll use a function to compute the binomial coefficient of two numbers. It
    shows the number of combinations of n things taken in groups of size k. For example,
    how many ways a 52-card deck can be dealt into 5-card hands is computed like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个函数来计算两个数字的二项式系数。它显示了从大小为 k 的组中取 n 件事物的组合数。例如，如何计算一副 52 张牌被分成 5 张牌的手牌的方法如下：
- en: '![( ) n = ----n!--- k k!(n− k)! ](img/file80.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![公式](img/file80.png)'
- en: 'This can be implemented by a Python function that looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一个类似这样的 Python 函数来实现：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Functions, generally, have no internal state, making a function like this relatively
    easy to test. This will be one of the examples used for showing the unit testing
    tools available.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数没有内部状态，这使得像这样的函数相对容易测试。这将是用于展示可用的单元测试工具的示例之一。
- en: We’ll also look at a class that uses lazy calculation of the mean and median
    of a collection of numbers. Objects often have internal state, defined by the
    various self. attributes. State changes are often difficult. This is similar to
    the classes shown in Chapter [7](ch011_split_000.xhtml#x1-3760007). The [Designing
    classes with lots of processing](ch011_split_000.xhtml#x1-3890003) and [Using
    properties for lazy attributes](ch011_split_001.xhtml#x1-43100010) recipes both
    have classes similar to this.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看一个使用一组数字的平均值和中位数进行懒计算的类。对象通常具有由各种 self. 属性定义的内部状态。状态变化通常是困难的。这与第 7 章（ch011_split_000.xhtml#x1-3760007）中展示的类类似。[Designing
    classes with lots of processing](ch011_split_000.xhtml#x1-3890003) 和 [Using properties
    for lazy attributes](ch011_split_001.xhtml#x1-43100010) 菜谱中都有类似的类。
- en: 'Here is an outline of the Summary class, with some implementation details omitted:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Summary 类的概述，省略了一些实现细节：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The add() method changes the internal state of a Summary object. Because of
    this state change to the self.counts attribute, we’ll need to provide more sophisticated
    examples to show how an instance of the Summary class behaves.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: add() 方法改变了 Summary 对象的内部状态。由于这个状态变化到 self.counts 属性，我们需要提供更复杂的示例来展示 Summary
    类的实例是如何表现的。
- en: 15.1.2 How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.2 如何做...
- en: We’ll show two variations in this recipe. The first variation can be applied
    to functions like the binom() function where there is no object with a mutable
    state. The second is more appropriate for stateful operations, such as the Summary
    class. We’ll look at them together because they’re very similar, even though they
    apply to different kinds of applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示两种变体。第一种变体可以应用于 binom() 函数这样的函数，其中没有具有可变状态的对象。第二种更适合状态操作，如 Summary
    类。我们将一起查看它们，因为它们非常相似，尽管它们适用于不同类型的应用。
- en: Writing examples for functions
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为函数编写示例
- en: 'This recipe starts by creating the function’s docstring, and then adds an example
    of how the function works:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱首先创建函数的文档字符串，然后添加一个示例来说明函数的工作方式：
- en: 'Start the docstring with a summary:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档字符串中开始一个总结：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Include the parameter definitions and the return value definition:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含参数定义和返回值定义：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Mock up an example of using the function at Python’s >>> prompt:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Python 的 >>> 提示符下模拟使用该函数的示例：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Close the docstring with the appropriate quotation marks:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的引号关闭文档字符串：
- en: '[PRE6]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Writing examples for stateful objects
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为状态对象编写示例
- en: 'This recipe also starts with writing a docstring. The docstring will show several
    steps using the stateful object to show the object’s internal state changes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a class-level docstring with a summary. It can help to leave some blank
    lines in front of the doctest example:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Extend the class-level docstring with a concrete example of how the class works.
    In this case, we’ll show how the add() method sets the state of the object. We’ll
    also show how to interrogate the state of the object:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finish with the triple quotes to end the docstring for this class:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because this example uses floating-point values, we’ve rounded the result of
    the mean in the docstring example. Floating-point values might not have the exact
    same text representation on all platforms and an exact test for equality may fail
    unexpectedly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we run the doctest program, we’ll generally get a silent response because
    the test passed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The interaction looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the tests pass, there is no output. We can add a -v command-line option
    to see an enumeration of the tests run. This can be helpful to confirm that all
    of the tests in the module were found.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when something doesn’t work? We’ll modify a test case to have
    a wrong answer and force a failure. When we run the doctest program – using a
    broken test case – we’ll see output like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This shows where the error is. It shows an expected value from the test example,
    and the actual answer that failed to match the expected answer. Ordinarily – without
    the -v option – silence means all tests were passed successfully.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 15.1.3 How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The doctest module includes a main program – as well as several functions –
    that scan a Python file for examples. The scanning operation looks for blocks
    of text that have a characteristic pattern of the Python REPL: a >>> prompt with
    code, followed by lines that show the response from the code, followed by a blank
    line to end the example output. Clearly, these must be formatted to precisely
    match the Python REPL output to be found.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The doctest parser creates a small test case object from the prompt line and
    the block of response text. There are three common cases:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'No expected response text: We saw this pattern when we defined the tests for
    the add() method of the Summary class.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A single line of response text: This was exemplified by the binom() function
    and the mean() method of the Summary class.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple lines of response: Responses are bounded by either the next >>> prompt
    or a blank line. This was exemplified by the str() example of the Summary class.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless special annotations are used, the output text must precisely match the
    expectation text. In general, every space counts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: This testing protocol imposes some software design constraints. Functions and
    classes must be designed to work from the >>> prompt. Because it can become awkward
    to create very complex objects as part of a docstring example, class designs must
    be kept simple enough to be demonstrated at the interactive prompt. These constraints
    often have the benefit of keeping a design understandable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试协议对软件设计施加了一些限制。函数和类必须设计成可以从`>>>`提示符工作。因为将非常复杂的对象作为文档字符串示例的一部分可能会变得尴尬，所以类设计必须足够简单，以便在交互式提示符中演示。这些限制通常有助于保持设计可理解。
- en: The simplicity of the final comparison with the expected result can create some
    complications. In the example, we rounded the value of the mean to two decimal
    places. This is because the display of floating-point values may vary slightly
    from platform to platform.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与预期结果的最终比较的简单性可能会造成一些复杂性。在示例中，我们将平均值四舍五入到两位小数。这是因为浮点数的显示可能会因平台而异。
- en: 15.1.4 There’s more...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.4 更多内容...
- en: One of the important considerations in test design is identifying edge cases.
    An edge case generally focuses on the limits for which a calculation is designed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设计中一个重要的考虑因素是识别边缘情况。边缘情况通常关注计算设计的极限。
- en: 'There are, for example, two edge cases for the binomial function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，二项式函数有两个边缘情况：
- en: '![( ) ( ) n n 0 = n = 1 ](img/file81.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![（ ）（ ） n n 0 = n = 1](img/file81.png)'
- en: 'We can add these to the examples to be sure that our implementation is sound.
    This leads to a docstring that looks like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些添加到示例中，以确保我们的实现是可靠的。这将导致一个看起来像以下的文档字符串：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To keep the examples straight in the source code files, we’ve changed the name
    of this function to binom2\. This hack lets us keep both examples in a single
    Python module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在源代码文件中保持示例的一致性，我们已经将此函数的名称更改为`binom2`。这个技巧让我们可以在单个Python模块中保持两个示例。
- en: In some cases, we might need to test values that are outside the valid range
    of values. These cases raise exceptions, which means they aren’t really ideal
    for putting into the docstring. The examples can clutter the explanation with
    details of things that should never normally happen. Fortunately, we have a place
    to put additional examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要测试超出有效值范围的值。这些情况会引发异常，这意味着它们实际上不适合放入文档字符串中。示例可能会用应该永远不会发生的事情的细节来杂乱无章地解释说明。幸运的是，我们有一个地方可以放置额外的示例。
- en: In addition to reading docstrings, the tool also looks for test cases in a global
    variable named __test__. This variable must refer to a mapping. The keys to the
    mapping will be test case names, and the values of the mapping must be doctest
    examples. Generally, each value will need to be a triple-quoted string.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阅读文档字符串外，该工具还会在一个名为`__test__`的全局变量中查找测试用例。此变量必须引用一个映射。映射的键将是测试用例名称，映射的值必须是doctest示例。通常，每个值都需要是一个三引号字符串。
- en: Because the examples in the __test__ variable are not inside the docstrings,
    they don’t show up when using the built-in help() function. Nor do they show up
    when using other tools to create documentation from source code. This might be
    a place to put examples of failures or complex exceptions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`__test__`变量中的示例不在文档字符串中，所以在使用内置的`help()`函数时它们不会显示。同样，当使用其他工具从源代码创建文档时，它们也不会显示。这可能是一个放置失败示例或复杂异常示例的地方。
- en: 'We might add something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能添加如下内容：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can use this for tests that don’t need to be as visible as the docstring
    examples.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这来测试那些不需要像文档字符串示例那样可见的测试。
- en: 15.1.5 See also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.5 参见
- en: In the [Testing functions that raise exceptions](ch019_split_000.xhtml#x1-8040002)
    and [Handling common doctest issues](ch019_split_000.xhtml#x1-8100003) recipes
    later in this chapter, we’ll look at two additional doctest techniques.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章后面的[测试引发异常的函数](ch019_split_000.xhtml#x1-8040002)和[处理常见的doctest问题](ch019_split_000.xhtml#x1-8100003)的食谱中，我们将探讨两种额外的doctest技术。
- en: For more background to the concept of stateless functions, see Chapter [3](ch007_split_000.xhtml#x1-1610003)
    and Chapter [9](ch013_split_000.xhtml#x1-5020009).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于无状态函数概念的更多背景信息，请参阅第[3](ch007_split_000.xhtml#x1-1610003)章和第[9](ch013_split_000.xhtml#x1-5020009)章。
- en: 15.2 Testing functions that raise exceptions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.2 测试引发异常的函数
- en: Python permits docstrings inside packages, modules, classes, functions, and
    methods. A good docstring should contain an example of how the feature is used.
    The example may need to include common exceptions, too. There’s one complicating
    factor, however, to including exceptions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许在包、模块、类、函数和方法中包含文档字符串。一个好的文档字符串应该包含一个如何使用该功能的示例。示例可能还需要包括常见的异常。然而，包含异常有一个复杂因素。
- en: When an exception is raised, the traceback messages created by Python are not
    completely predictable. The message may include object ID values that are impossible
    to predict or module line numbers that may vary slightly depending on the context
    in which the test is executed. The general matching rules for doctest compare
    expected and actual results precisely. In this recipe, we’ll look at additional
    techniques to add flexibility.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当引发异常时，Python创建的跟踪消息并不完全可预测。消息可能包括无法预测的对象ID值或可能根据测试执行的上下文略有变化的模块行号。doctest的一般匹配规则精确地比较预期和实际结果。在本食谱中，我们将探讨额外的技术来增加灵活性。
- en: 15.2.1 Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.1 准备工作
- en: We’ll look at a small function definition as well as a class definition. Each
    of these will contain docstrings that include examples that can be used as formal
    tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个小的函数定义以及一个类定义。每个都将包含包含可以用于正式测试的示例的文档字符串。
- en: We’ll use the function from the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe, shown earlier in this chapter, that computes the binomial coefficient
    of two numbers. It shows the number of combinations of n things taken in groups
    of k. For example, it shows how many ways a 52-card deck can be dealt into 5-card
    hands.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章前面展示的[使用文档字符串进行测试](ch019_split_000.xhtml#x1-7950001)食谱中的函数，该函数计算两个数字的二项式系数。它显示了n个事物以k组取出的组合数。例如，它显示了52张牌的牌组如何被分成5张牌的手牌。
- en: This function does a simple calculation and returns a value; it lacks any internal
    state, making each request independent. We’d like to include some additional test
    cases in the __test__ variable to show what this does when given values outside
    the expected ranges.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数执行简单的计算并返回一个值；它没有内部状态，使得每个请求都是独立的。我们希望在`__test__`变量中包含一些额外的测试用例，以显示当给定预期范围之外的值时会发生什么。
- en: 15.2.2 How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.2 如何做...
- en: 'We start by running the binom function we defined previously. This output provides
    a handy template to show the expected output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先运行之前定义的binom函数。这个输出提供了一个方便的模板来显示预期的输出：
- en: Run the function manually at the interactive Python prompt to collect the actual
    exception details. Copy and paste these results.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交互Python提示符下手动运行函数以收集实际的异常详情。复制并粘贴这些结果。
- en: 'Create a global __test__ variable at the end of the module. One approach is
    to build the mapping from all global variables with names that start with test_:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块的末尾创建一个全局的`__test__`变量。一种方法是从所有以test_开头的全局变量中构建映射：
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Define each test case as a global variable with a block of text containing the
    doctest example. This can include additional notes about the scenario. These variables
    must be set before the final creation of the __test__ mapping.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个测试用例定义为全局变量，包含包含doctest示例的文本块。这可以包括关于场景的额外说明。这些变量必须在创建最终的`__test__`映射之前设置。
- en: Paste in the interactive session session output.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将交互会话的输出粘贴进来。
- en: 'It will start like this:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将像这样开始：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Replace the traceback details with .... Leave the initial line and the final
    exception in place. Add a directive to doctest, by putting # doctest: +ELLIPSIS
    after the line to be executed. It will look like this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将跟踪回溯详情替换为......保留初始行和最终异常。在要执行的行后添加一个doctest指令，通过放置`# doctest: +ELLIPSIS`来实现。它看起来像这样：'
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now use a command like this to test the entire module’s features:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这样的命令来测试整个模块的功能：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because each test is a separate global variable, we can easily add test scenarios.
    All of the names starting with test_ will become part of the final __test__ mapping
    that’s used by the doctest tool.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个测试都是一个单独的全局变量，我们可以轻松地添加测试场景。所有以test_开头的名称都将成为doctest工具使用的最终`__test__`映射的一部分。
- en: 15.2.3 How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.3 它是如何工作的...
- en: Because eliding traceback details is so common, the doctest tool recognizes
    the ellipsis (...) in the context of a traceback. The ellipsis is also available
    in other contexts as one of many directives to modify the testing behavior. The
    directives are included as special comments with the line of code that performs
    the test action. They can also be provided as general instructions on the command
    line.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于省略跟踪信息非常常见，doctest工具识别跟踪信息上下文中的省略号(...)。省略号也在其他上下文中作为修改测试行为的许多指令之一可用。这些指令包含在执行测试操作的代码行的特殊注释中。它们也可以作为命令行上的通用指令提供。
- en: 'We have two additional ways to handle tests that include an exception:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种处理包含异常的测试的额外方法：
- en: 'We can use a # doctest: +IGNORE_EXCEPTION_DETAIL directive on the line of code
    that will raise the exception. This lets us provide a full traceback error message.
    The details of the traceback are ignored, and only the final exception line is
    matched against the expected value. This makes it possible to copy an actual error
    and paste it into the documentation.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以在将引发异常的代码行上使用#doctest: +IGNORE_EXCEPTION_DETAIL指令。这让我们可以提供一个完整的跟踪错误消息。跟踪信息的细节被忽略，并且只有最后的异常行与预期值匹配。这使得将实际错误复制并粘贴到文档中成为可能。'
- en: 'We can use a # doctest: +ELLIPSIS directive and replace parts of the traceback
    message with .... This directive is redundant for traceback messages.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以使用#doctest: +ELLIPSIS指令，并用...替换跟踪消息的部分。此指令对于跟踪消息是多余的。'
- en: The use of an explicit directive can help to make it clear what the intent is.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 显式指令的使用可以帮助清楚地表明意图。
- en: 15.2.4 There’s more...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.4 更多...
- en: 'There are two more directives that are often useful:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个其他指令通常很有用：
- en: '+NORMALIZE_WHITESPACE: Using this directive allows some flexibility in the
    whitespace for the expected value.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +NORMALIZE_WHITESPACE：使用此指令允许在预期值中对空白有一些灵活性。
- en: '+SKIP: The test is skipped.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +SKIP：跳过测试。
- en: There are a few more directives, but they’re rarely needed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个更多的指令，但它们很少需要。
- en: 15.2.5 See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.5 参见
- en: See the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001) recipe
    earlier in this chapter. This recipe shows the basics of doctest.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面，请参阅[使用文档字符串进行测试](ch019_split_000.xhtml#x1-7950001)的配方。这个配方展示了doctest的基本知识。
- en: See the [Handling common doctest issues](ch019_split_000.xhtml#x1-8100003) recipe
    next in this chapter. This shows other special cases that require doctest directives.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，接下来请参阅[处理常见的doctest问题](ch019_split_000.xhtml#x1-8100003)的配方。这展示了需要doctest指令的其他特殊案例。
- en: 15.3 Handling common doctest issues
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.3 处理常见的doctest问题
- en: A docstring that contains an example is part of good Python programming. The
    way the doctest tool uses literal matching of the expected text output against
    the actual text can make testing complicated for Python objects that do not have
    a consistent text representation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 包含示例的文档字符串是良好Python编程的一部分。doctest工具通过将预期的文本输出与实际文本进行字面匹配的方式来使用，这可能会使得对于没有一致文本表示的Python对象进行测试变得复杂。
- en: 'For example, object hash values are randomized. This often results in the order
    of elements in a set collection being unpredictable. We have several choices for
    creating test case example output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对象的哈希值是随机的。这通常会导致集合集合中元素顺序不可预测。我们有几种选择来创建测试用例示例输出：
- en: Write examples that can tolerate randomization. One technique is by sorting
    the elements of a set into a defined order.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可以容忍随机化的示例。一种技术是将集合的元素排序到定义的顺序中。
- en: Stipulate a specific value for the PYTHONHASHSEED environment variable.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定PYTHONHASHSEED环境变量的特定值。
- en: 'There are several other considerations beyond simple variability in the location
    of keys or items in a set. Here are some other concerns:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的键或集合中项的位置变化之外，还有其他一些考虑因素。以下是一些其他关注点：
- en: The id() and repr() functions may expose an internal object ID. No guarantees
    can be made about these values.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: id()和repr()函数可能会暴露内部对象ID。无法对这些值做出保证。
- en: Floating-point values may vary across platforms.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点值可能在平台之间有所不同。
- en: The current date, time, and local timezone cannot meaningfully be used in a
    test case.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前日期、时间和本地时区在测试用例中无法有意义地使用。
- en: Random numbers using the default seed are difficult to predict.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认种子生成的随机数难以预测。
- en: OS resources may not exist, or may not be in the proper state.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OS资源可能不存在，或者可能不在适当的状态。
- en: It’s important to note that doctest examples require an exact match with the
    text. This means our test cases must avoid unpredictable results stemming from
    hash randomization or floating-point implementation details.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，doctest 示例需要与文本完全匹配。这意味着我们的测试用例必须避免由哈希随机化或浮点实现细节引起的不可预测的结果。
- en: 15.3.1 Getting ready
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.1 准备工作
- en: 'We’ll look at three separate versions of this recipe. The first will include
    a function where the output includes the contents of a set. Because the order
    of items in a set can vary, this isn’t as easy to test as we’d like. Here’s the
    function definition:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看这个配方的三个不同版本。第一个将包括一个输出包括集合内容的函数。由于集合中元素的顺序可能变化，这不像我们希望的那样容易测试。以下是函数定义：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Testing the unique_letters() function is difficult because the order of items
    within a set is unpredictable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 unique_letters() 函数很困难，因为集合内元素的顺序是不可预测的。
- en: 'The second example will be a class that doesn’t define a unique __repr__()
    definition. The default definition of the __repr__() method will expose an internal
    object ID. Since these vary, the test results will vary. Here’s the class definition:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例将是一个没有定义唯一 __repr__() 定义的类。__repr__() 方法的默认定义将暴露内部对象ID。由于这些ID是可变的，因此测试结果也会变化。以下是类定义：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the third example, we’ll look at a real-valued function so that we can
    work with floating-point values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三个示例，我们将查看一个实值函数，这样我们就可以处理浮点值：
- en: '![ϕ (n) = 1[1 + erf√n-] 2 2 ](img/file82.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![ϕ (n) = 1[1 + erf√n-] 2 2 ](img/file82.png)'
- en: This function is the cumulative probability density function for standard z-scores.
    See the [Creating a partial function](ch013_split_001.xhtml#x1-5560008) recipe
    in Chapter [9](ch013_split_000.xhtml#x1-5020009), for more information on the
    idea of normalized scores.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是标准z分数的累积概率密度函数。参见第[9](ch013_split_000.xhtml#x1-5020009)章中关于创建部分函数的[Creating
    a partial function](ch013_split_001.xhtml#x1-5560008)配方，了解更多关于标准化分数的概念。
- en: 'Here’s the Python implementation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Python 实现：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The phi() and frequency() functions involve some rather complicated numeric
    processing. The unit tests have to reflect the floating-point precision issues.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: phi() 和 frequency() 函数涉及一些相当复杂的数值处理。单元测试必须反映浮点精度问题。
- en: 15.3.2 How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.2 如何操作...
- en: We’ll look at set ordering and object representation in three mini-recipes.
    We’ll start with set ordering, then look at object IDs, and finally, floating-point
    values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个小配方中查看集合排序和对象表示。我们首先查看集合排序，然后查看对象ID，最后查看浮点值。
- en: Writing doctest examples with unpredictable set ordering
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写具有不可预测集合排序的 doctest 示例
- en: 'Write a draft of the test that seems to capture the essence:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个似乎能够捕捉本质的测试草案：
- en: '[PRE21]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This test will work when the hash values for these strings happen to fall into
    this specific order.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当这些字符串的哈希值恰好落入这个特定顺序时，这个测试将有效。
- en: One possible fix is to sort the results to impose an order.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是对结果进行排序以强制执行顺序。
- en: 'Another alternative is to compare the output to a set object. The two choices
    look like this:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个替代方案是将输出与集合对象进行比较。这两个选择看起来像这样：
- en: '[PRE22]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A third choice is to set the PYTHONHASHSEED environment variable to force known
    orderings. We’ll look at this alternative below.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选择是将 PYTHONHASHSEED 环境变量设置为强制已知顺序。我们将在下面查看这个替代方案。
- en: Writing doctest examples with object IDs
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写具有对象ID的 doctest 示例
- en: 'Ideally, our applications won’t display object IDs. These are essentially impossible
    to predict. Here’s what we can do:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们的应用程序不会显示对象ID。这些基本上是不可预测的。以下是我们可以做的事情：
- en: 'Define a happy path doctest scenario to show that the class performs its essential
    methods correctly. In this case, we’ll create a Point instance and use the text
    property to see a representation of the point:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个快乐的路径 doctest 场景，以显示类正确执行其基本方法。在这种情况下，我们将创建一个 Point 实例，并使用文本属性来查看点的表示：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we define a test that displays the object’s representation string, the
    test will include results that include the unpredictable object ID. The doctest
    might look like the following:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们定义一个显示对象表示字符串的测试时，该测试将包括包含不可预测对象ID的结果。doctest可能看起来像以下这样：
- en: '[PRE24]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We need to change the test by using a # doctest: +ELLIPSIS directive. This
    means changing the >>> Point(36.8439, -76.2936) line in the test, and using an
    ellipsis on the exception displayed in the expected output to look like this:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们需要通过使用 # doctest: +ELLIPSIS 指令来更改测试。这意味着更改测试中的 >>> Point(36.8439, -76.2936)
    行，并在预期输出中显示的异常上使用省略号，使其看起来像这样：'
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This kind of test suggest a design improvement. It’s often best to define __repr__().
    Another choice is to avoid tests where __repr__() may be used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这类测试建议进行设计改进。通常最好定义 __repr__(). 另一个选择是避免使用 __repr__() 可能被使用的测试。
- en: Writing doctest examples for floating-point values
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为浮点值编写 doctest 示例
- en: 'We have two choices when working with float values. We can round the values
    to a certain number of decimal places. An alternative is to use the math.isclose()
    function. We’ll show both:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理浮点值时，我们有两种选择。我们可以将值四舍五入到一定的小数位数。另一种选择是使用 math.isclose() 函数。我们将展示两者：
- en: Import the necessary libraries and define the phi() and frequency() functions
    as shown previously.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库，并定义如前所述的 phi() 和 frequency() 函数。
- en: 'For each example, include an explicit use of round():'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个示例，包括一个显式的 round() 使用：
- en: '[PRE26]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An alternative is to use the isclose() function from the math module:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个选择是使用 math 模块中的 isclose() 函数：
- en: '[PRE27]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because float values can’t be compared exactly, it’s best to display values
    that have been rounded to an appropriate number of decimal places. It’s sometimes
    nicer for readers of examples to use round() because it may be slightly easier
    to visualize how the function works, compared to the isclose() alternative.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点值无法精确比较，最好显示已四舍五入到适当小数位数的值。对于示例的读者来说，有时使用 round() 更为方便，因为它可能比 isclose()
    选项更容易可视化函数的工作方式。
- en: 15.3.3 How it works...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.3 它是如何工作的...
- en: 'Because of hash randomization, the hash keys used for sets are unpredictable.
    This is an important security feature, used to defeat a subtle denial-of-service
    attack. For details, see url: [http://www.ocert.org/advisories/ocert-2011-003.html.](https://packt.link/dHrHU)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希随机化，集合使用的哈希键是不可预测的。这是一个重要的安全特性，用于抵御一种微妙的拒绝服务攻击。有关详细信息，请参阅url：[http://www.ocert.org/advisories/ocert-2011-003.html.](https://packt.link/dHrHU)
- en: Since Python 3.7, dictionary keys are guaranteed to be kept in insertion order.
    This means that an algorithm that builds a dictionary will provide a consistent
    sequence of key values. The same ordering guarantee is not made for sets. Interestingly,
    sets of integers tend to have a consistent ordering because of the way hash values
    are computed for numbers. Sets of other types of objects, however, will not show
    consistent ordering of items.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Python 3.7 开始，字典键的插入顺序得到了保证。这意味着构建字典的算法将提供一系列一致的键值序列。对于集合，并没有做出相同的顺序保证。有趣的是，由于整数哈希值的计算方式，整数集合往往具有一致的顺序。然而，其他类型对象的集合则不会显示一致的元素顺序。
- en: When confronted with unpredictable results like set ordering or internal object
    identification revealed by the __repr__() method, we have a testability issue.
    We can either change the software to be more testable, or we can change the test
    to tolerate some unpredictability.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对如集合顺序或由 __repr__() 方法揭示的内部对象标识等不可预测的结果时，我们遇到了一个可测试性问题。我们可以要么修改软件使其更具可测试性，要么修改测试以容忍一些不可预测性。
- en: Most floating-point implementations are reasonably consistent. However, there
    are few formal guarantees about the last few bits of any given floating-point
    number. Rather than trusting that all of the bits have exactly the right value,
    it’s often a good practice to round the value to a precision consistent with other
    values in the problem domain.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浮点数实现都是相当一致的。然而，对于任何给定浮点数的最后几位，很少有正式的保证。与其相信所有位都恰好具有正确的值，不如通常将值四舍五入到与问题域中其他值一致的精度。
- en: Being tolerant of unpredictability can be taken too far, allowing the test to
    tolerate bugs. For more in-depth testing of mathematical functions, the [hypothesis](https://hypothesis.readthedocs.io/en/latest/)
    package provides ways to define a domain of robust test cases.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对不可预测性的容忍可能过度，允许测试容忍错误。对于数学函数的更深入测试，[hypothesis](https://hypothesis.readthedocs.io/en/latest/)
    包提供了定义稳健测试案例域的方法。
- en: 15.3.4 There’s more...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.4 更多...
- en: 'We can run the tests with the PYTHONHASHSEED environment variable set. In Linux
    (and macOS X) we can do this in a single command-line statement:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置 PYTHONHASHSEED 环境变量来运行测试。在 Linux（以及 macOS X）中，我们可以在单个命令行语句中完成此操作：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will provide a fixed, reproducible hash randomization while running doctest.
    We can also use PYTHONHASHSEED=0 to disable hash randomization.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在运行 doctest 时提供固定的、可重复的哈希随机化。我们还可以使用 PYTHONHASHSEED=0 来禁用哈希随机化。
- en: The tox tool has a --hashseed=x option to allow setting a consistent hash seed
    to an integer value prior to running tests.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: tox 工具有一个 --hashseed=x 选项，允许在运行测试之前将一致的哈希种子设置为整数值。
- en: 15.3.5 See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Testing things that involve dates or times](ch019_split_001.xhtml#x1-8430008)
    recipe, in particular, the now() method of datetime requires some care.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009)
    recipe shows how to test processing that involves using the random module.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at how to work with external resources in the [Mocking external resources](ch019_split_001.xhtml#x1-85500010)
    recipe later in this chapter.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.4 Unit testing with the unittest module
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unittest module allows us to step beyond the examples used by doctest. Each
    test case can have one more scenario built as a subclass of the TestCase class.
    These use result checks that are more sophisticated than the literal text matching
    used by the doctest tool.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The unittest module also allows us to package tests outside docstrings. This
    can be helpful for tests for edge cases that might be too detailed to be helpful
    documentation. Often, doctest cases focus on the happy path – the most common
    use cases, where everything works as expected. We can use the unittest module
    to more easily define test cases that diverge from the happy path.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how we can use the unittest module to create more sophisticated
    tests.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.1 Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s sometimes helpful to summarize a test following ideas behind the Gherkin
    language. In this test specification language, each scenario is described by GIVEN-WHEN-THEN
    steps. For this case, we have a scenario like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The TestCase class doesn’t precisely follow this three-part given-when-then
    (or arrange-act-assert) structure. A TestCase class generally has two parts:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: A setUp() method must implement the Given steps of the test case.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A runTest() method must handle the Then steps to confirm the results using a
    number of assertion methods to confirm the actual results match the expected results.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The When steps can be in either method. The choice of where to implement the
    When steps is often tied to the question of reuse. For example, a class or function
    may have a number of methods to take different actions or make a number of state
    changes. In this case, it makes sense to pair each When step with distinct Then
    steps to confirm correct operation. The runTest() method can implement both When
    and Then steps. A number of subclasses can share the common setUp() method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: As another example, a class hierarchy may offer a number of alternative implementations
    for the same algorithm. In this case, the Then step confirmation of correct behavior
    is in the runTest() method. Each alternative implementation has a distinct subclass
    with a unique setup() method for the Given and When steps.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: An optional tearDown() method is available for those tests that need to perform
    some cleanup of left-over resources. This is outside the test’s essential scenario
    specification.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create some tests for a class that is designed to compute some basic descriptive
    statistics. The unittest test cases let us define sample data that’s larger than
    anything we’d ever choose to enter as doctest examples. We can easily use thousands
    of data points rather than two or three as part of evaluating performance.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of the code that we’re going to test was shown in the [Using docstrings
    for testing](ch019_split_000.xhtml#x1-7950001) recipe earlier in this chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Because we’re not looking at the implementation details, we can think of this
    as opaque-box testing; the implementation details are not known to the tester.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: We’d like to be sure that when we use thousands of samples, the class performs
    correctly. We’d also like to ensure that it works quickly; we’ll use this as part
    of an overall performance test, as well as a unit test.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.2 How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need to create a separate module and a subclass of TestCase in that module.
    Tools like pytest can discover test modules if their names begin with test_, giving
    us a naming convention for these additional modules. Here’s how we can creates
    tests separate from the module’s code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Create a file with a name related to the module under test. If the module was
    named summary.py, then a good name for a test module would be test_summary.py.
    Using the test_ prefix makes it easier for tools like pytest to find the test.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll use the unittest module for creating test classes. We’ll also be using
    the random module to scramble the input data. We’ll also import the module under
    test:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a subclass of TestCase. Provide this class with a name that shows the
    intent of the test. We’ve chosen a name with a summary of the three steps:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define a setUp() method in this class that handles the Given step of the test.
    We’ve created a collection of 1,001 samples shuffled into a random order:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define a runTest() method that handles the When step of the test:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add assertions to the runTest() method to implement the Then steps of the test:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If our test module is called recipe_04.py, we can use the following command
    to find TestCase classes in the recipe_04 module and run them:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If all of the assertions pass, then the test suite will pass and the test run
    will be successful overall.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.3 How it works...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TestCase class is used to define one test case. The class can have a setUp()
    method to create the unit and possibly the request. The class must have at least
    a runTest() method to make a request of the unit and check the response.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'A single test often isn’t sufficient. If we created three separate test classes
    in the recipe_04.py module, then we would see output that looks like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As each test is passed, a . is displayed. This shows that the test suite is
    making progress. The summary shows the number of tests run and the time. If there
    are failures or exceptions, the counts shown at the end will reflect these.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there’s a summary line. In this case, it consists of OK, showing that
    all the tests passed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'If we include a test that fails, we’ll see the following output when we use
    the -v option to get verbose output:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There’s a final summary of FAILED. This includes (failures=1) to show how many
    tests failed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.4 There’s more...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In these examples, we have two assertions for the two Then steps inside the
    runTest() method. If one fails, the test stops as a failure, and the other step
    is not exercised.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: This is a weakness in the design of this test. If the first assertion fails,
    we may not get all of the diagnostic information we might want. We should avoid
    having a sequence of otherwise independent assertions in the runTest() method.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want more diagnostic details, we have two general choices:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Use multiple test methods instead of a single runTest(). We can create multiple
    methods with names that start with test_. The default implementation of the test
    loader will execute the setUp() method prior to each separate test_ method when
    there is no overall runTest() method. This is often the simplest way to group
    a number of related tests together.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use multiple subclasses of the TestCase subclass, each with a separate Then
    step implementation. When the setUp() is inherited, this will be shared by each
    subclass.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following the first alternative, the test class would look like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We’ve refactored the setUp() method to include the Given and When steps of the
    test. The two independent Then steps are refactored into their own separate test_mean()
    and test_median() methods. These two methods are used instead of the runTest()
    method.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Since each test is run separately, we’ll see separate error reports for problems
    with computing the mean or with computing the median.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The TestCase class defines numerous assertions that can be used as part of the
    Then steps. We encourage careful study of the unittest section of the Python Standard
    Library documentation to see all of the variations available.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In all but the smallest projects, it’s common practice to sequester the test
    files into a separate directory, often called tests. When this is done, we can
    rely on the discovery application that’s part of the unittest framework.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The unittest loader can search each module in a given directory for all classes
    that are derived from the TestCase class. This collection of classes within the
    larger collection of modules becomes the complete TestSuite.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this with the discover command of the unittest package:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will locate all test cases in all test modules in the tests directory of
    a project.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.5 See also
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll combine unittest and doctest in the [Combining pytest and doctest tests](ch019_split_001.xhtml#x1-8370007)
    recipe next in this chapter. We’ll look at mocking external objects in the [Mocking
    external resources](ch019_split_001.xhtml#x1-85500010) recipe later in this chapter.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)
    recipe later in this chapter covers the same test case from the perspective of
    the pytest tool.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.5 Combining unittest and doctest tests
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, we’ll want to combine tests written for the unittest and doctest
    tools. For examples of using the doctest tool, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe earlier in this chapter. For examples of using the unittest tool, see the
    [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004) recipe
    earlier in this chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The doctest examples are an essential element of the documentation strings on
    modules, classes, methods, and functions. The unittest cases will often be in
    a separate tests directory in files with names that match the pattern test_*.py.
    An important part of creating trustworthy software is running as wide a variety
    of tests as possible.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at ways to combine a variety of tests into one tidy
    package.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.1 Getting ready
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll refer back to the example from the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe, shown earlier in this chapter. This recipe created tests for a class,
    Summary, that does some statistical calculations. In that recipe, we included
    examples in the docstrings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In the [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe earlier in this chapter, we wrote some TestCase classes to provide additional
    tests for this class.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'As context, we’ll assume there’s a project folder structure that looks like
    the following directory tree:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This means tests are in both the src/summary.py module and in the tests/test_summary.py
    file.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: We need to combine all of the tests into a single, comprehensive test suite.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The recipe examples use recipe_01.py instead of some cooler name such as summary.py.
    Ideally, a module should have a memorable, meaningful name. The book content is
    quite large, and the names are designed to match the overall chapter and recipe
    outline.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.2 How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To combine unittest and doctest test cases, we’ll start with an existing test
    module, and add a load_tests() function to merge the relevant doctest with the
    existing unittest test cases. A function named load_tests() must be provided.
    This name is required so the unittest loader will use it:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'To use doctest tests, import the doctest module. To write TestCase classes,
    import the unittest module. We’ll also need the random module so we can control
    the random seeds in use:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Import the modules containing doctest examples:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To implement the load_tests protocol, define a load_tests() function in the
    test module. We’ll combine the standard tests automatically discovered by unittest
    with the additional tests found by the doctest module:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The loader argument value to the load_tests() function is the test case loader
    currently being used; this is generally ignored. The standard_tests argument value
    will be all of the tests loaded by default. Generally, this is the suite of all
    subclasses of TestCase. The function updates this object with the additional tests.
    The pattern value is the value provided to the loader to locate tests; this is
    also ignored.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this from the OS command prompt, we see the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This shows us that the unittest test cases were included as well as doctest
    test cases.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.3 How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The unittest.main() application uses a test loader to find all of the relevant
    test cases. The loader is designed to find all classes that extend TestCase. It
    will also look for a load_tests() function. This function can provide a suite
    of additional tests. It can also do non-default searches for tests when that’s
    needed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we can import a module with docstrings and use a DocTestSuite to
    build a test suite from the imported module. We can, of course, import other modules
    or even scan the README file for more examples to test. The goal is to make sure
    every example in both the code and the documentation actually works.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.4 There’s more...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, a module may be quite complicated; this can lead to multiple
    test modules. The test modules may have names such as tests/test_module_feature_X.py
    to show that there are tests for separate features of a very complex module. The
    volume of code for test cases can be quite large, and keeping the features separate
    can be helpful.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, we might have a test module that has tests for several different
    but closely related small modules. A single test module may employ inheritance
    techniques to cover all the modules in a package.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'When combining many smaller modules, there may be multiple suites built in
    the load_tests() function. The body might look like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will incorporate doctest examples from multiple modules into a single,
    comprehensive test suite.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.5 See also
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For examples of doctest, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe earlier in the chapter. For examples of unittest, see the [Unit testing
    with the unittest module](ch019_split_000.xhtml#x1-8190004) recipe earlier in
    this chapter.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.6 Unit testing with the pytest module
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pytest tool allows us to step beyond the examples used by doctest in docstrings.
    Instead of using a subclass of TestCase, the pytest tool lets us use function
    definitions. The pytest approach uses Python’s built-in assert statement, leaving
    the test case looking somewhat simpler.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'The pytest tool is not part of Python; it needs to be installed separately.
    Use a command like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this recipe, we’ll look at how we can use pytest to simplify our test cases.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.1 Getting ready
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Gherkin language can help to structure a test. For this recipe, we have
    a scenario like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A pytest test function doesn’t precisely follow the Gherkin three-part structure.
    A test function generally has two parts:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, fixtures are defined to establish the Given steps. Fixtures are
    designed for reuse as well as composition. A fixture can also tear down resources
    after a test has finished.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the function will usually handle the When steps to exercise the
    object being tested and the Then steps to confirm the results.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These boundaries are not fixed. A fixture might, for example, create an object
    and also take action, executing both the Given and When steps. This permits multiple
    test functions to apply several independent Then steps.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create some tests for a class that is designed to compute some basic descriptive
    statistics. The bulk of the code was shown in the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an outline of the class, provided as a reminder of what the method
    names are:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We want to duplicate testing shown in the [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe. We’ll use the pytest features to do this.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.2 How to do it...
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s often best to start with a separate test file, perhaps even a separate
    tests directory:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Create a test file with a name similar to the module under test. If the module
    file was named summary.py, then a good name for a test module would be test_summary.py.
    Using the test_ prefix makes the test easier to find.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll use the pytest module for creating test classes. We’ll also be using
    the random module to scramble the input data. Also, we need to import the module
    under test:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement the Given step as a fixture. This is marked with the @pytest.fixture
    decorator. It creates a function that can return a useful object, data for creating
    an object, or a mocked object:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement the When and Then steps as a test function with a name visible to
    pytest. This means the function name must begin with test_:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When a parameter name in a test function definition is the name of a fixture
    function, the fixture function is evaluated automatically. The results of the
    fixture function are provided at runtime. This means the shuffled set of 1,000
    values will be provided as an argument value for the flat_data parameter.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a When step to perform an operation on an object:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement the Then steps to validate the outcome:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If our test module is called test_summary.py, we can often execute the tests
    found in it with a command like the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This will invoke the main application that’s part of the pytest package. It
    will search the given file for functions with names starting with test_ and execute
    those test functions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.3 How it works...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re using several parts of the pytest package:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: The @fixture decorator can be used to create reusable test fixtures with objects
    in known states, ready for further processing.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pytest application to do several things:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover tests. By default, it searches a directory named tests for module names
    starting with test_. Within those, it looks for functions with names starting
    with test_. It also finds unittest.TestCase classes.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run all of the tests, evaluating the fixtures as needed.
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a summary of the results.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we run the pytest command, we’ll see output that looks like this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As each test is passed, a . is displayed. This shows that the test suite is
    making progress. The summary shows the number of tests run and the time. If there
    are failures or exceptions, the counts on the last line will reflect this.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change one test slightly to be sure that it fails, we’ll see the following
    output:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This shows a summary of passing and failing tests and the details of each failure.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.4 There’s more...
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have two Then steps inside the test_flat() function. These
    are implemented as two assert statements. If the first one fails, the test stops
    as a failure, and the following step will be skipped. This means we might not
    see all the diagnostic information we might need.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'A better design is to use multiple test functions. All of the functions can
    share a common fixture. In this case, we can create a second fixture that depends
    on the flat_data fixture and builds a Summary object to be used by a number of
    tests:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Since each of these test functions are run separately, we’ll see separate error
    reports for problems when computing the mean and the median, or possibly when
    computing both.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.5 See also
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe in this chapter covers the same test case from the perspective of the unittest
    module.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.7 Combining pytest and doctest tests
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, we’ll have a combination of pytest and doctest test cases. For
    examples of using the doctest tool, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe. For examples of using the pytest tool, see the [Unit testing with the
    pytest module](ch019_split_001.xhtml#x1-8310006) recipe.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, documentation will contain doctest. We need to be sure all examples
    – in docstrings and documentation – work correctly. In this recipe, we’ll combine
    these doctest examples and the pytest test cases into one tidy package.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 15.7.1 Getting ready
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll refer back to the example from the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe. This recipe created tests for a class, Summary, that does some statistical
    calculations. In that recipe, we included examples in the docstrings.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: In the [Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)
    recipe, we wrote some test functions to provide additional tests for this class.
    These tests were put into a separate module, with a name starting with test_,
    specifically, test_summary.py.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the [Combining unittest and doctest tests](ch019_split_000.xhtml#x1-8250005)
    recipe, we’ll also assume there’s a project folder structure that looks like the
    following directory tree:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The tests directory should contain all the module files with tests. We’ve chosen
    the directory named tests and a module named test_*.py so that they fit well with
    the automated test discovery features of the pytest tool.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The recipe examples use recipe_07 instead of a cooler name such as summary.
    As a general practice, a module should have a memorable, meaningful name. The
    book’s content is quite large, and the names are designed to match the overall
    chapter and recipe outline.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 15.7.2 How to do it...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It turns out that we don’t need to write any Python code to combine the tests.
    The pytest module will locate test functions. It can also be used to locate doctest
    cases:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a shell command to run the test suite in the recipe_07.py file, as well
    as to examine the recipe_01.py module for the additional doctest cases:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When we run this from the OS command prompt, we see the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The pytest command worked with both files. The dots after recipe_07.py show
    that two test cases were found in this file. This was 28% of the test suite. The
    dots after recipe_01.py show that five test cases more were found; this was the
    remaining 72% of the suite.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: This shows us that the pytest test cases were included as well as doctest test
    cases. What’s helpful is that we don’t have to adjust anything in either of the
    test suites to execute all of the available test cases.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 15.7.3 How it works...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pytest application has a variety of ways to search for test cases. The default
    is to search the given paths for all functions with names that start with test_
    in a given module. It will also search for all subclasses of TestCase. If we provide
    a directory, it will search it for all modules with names that begin with test_.
    Often, we’ll collect our test files in a directory named tests because this is
    the default directory that will be searched.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The --doctest-modules command-line option is used to mark modules that contain
    doctest examples. These examples are also added to the test suite as test cases.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: This level of sophistication in finding and executing a variety of types of
    tests makes pytest a very powerful tool. It makes it easy to create tests in a
    variety of forms to create confidence that our software will work as intended.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 15.7.4 There’s more...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding the -v option provides a more detailed view of the tests found by the
    pytest tool. Here’s how the additional details are displayed:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Each individual test is identified, providing us with a detailed explanation
    of the test processing. This can help confirm that all of the expected doctest
    examples were properly located in the module under test.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 15.7.5 See also
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For examples of doctest, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe earlier in this chapter.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)
    recipe earlier in this chapter has the pytest test cases used for this recipe.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For examples of the unittest version of these tests, see the [Unit testing with
    the unittest module](ch019_split_000.xhtml#x1-8190004) recipe earlier in this
    chapter.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.8 Testing things that involve dates or times
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many applications rely on functions like datetime.datetime.now() or time.time()
    to create a timestamp. When we use one of these functions with a unit test, the
    results are essentially impossible to predict. This is an interesting dependency
    injection problem here: our application depends on a class that we would like
    to replace only when we’re testing.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: One option is to design our application to avoid functions like now(). Instead
    of using this method directly, we can create a factory function that emits timestamps.
    For test purposes, this function can be replaced with one that produces known
    results.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: The alternative is called monkey-patching – injecting a new object at test time.
    This can reduce the design complexity; it tends to increase the test complexity.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll write tests with datetime objects. We’ll need to create
    mock objects for datetime instances to create repeatable test values. We’ll use
    the pytest package features for monkey-patching.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 15.8.1 Getting ready
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll work with a small function that creates a CSV file. This file’s name will
    include the date and time in the format of YYYYMMDDHHMMSS as a long string of
    digits. This kind of file-naming convention might be used by a long-running server
    application. The name helps match a file and related log events. It can help to
    trace the work being done by the server.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'The application uses this function to create these files:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This function has the use of now(), which produces a distinct value each time
    this is run. Since this value is difficult to predict, it makes test assertions
    difficult to write.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: To create a reproducible test output, we can create a mock version of the datetime
    module. We can then monkey patch the test context to use this mock object instead
    of the actual datetime module. Within the mocked module, we can create a mock
    class with a mock now() method to provide a fixed, easy-to-test response.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'For this case, we have a scenario like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This can be implemented as a test case using the pytest constructs.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 15.8.2 How to do it...
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will create and patch mock objects to create a test fixture:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need to import a number of modules required by the module we’re testing:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We’ll also need the core tools for creating mock objects and test fixtures.
    Also, we’ll need the module we’re going to test:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We must create an object that will behave like the datetime module for the
    purposes of the test scenario. This mocked module must contain a name that appears
    to be a class, also named datetime. The class must appear to contain a method,
    now(), which returns a known object rather than a date that changes each time
    the test is run. We’ll create a fixture, and the fixture will return this mock
    object with a small set of attributes and behaviors defined:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The Mock object is a namespace, a feature that packages, modules, and classes
    all share. In this example, each attribute name is another Mock object. The most
    deeply-buried object has a return_value attribute to make it behave like a function.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also need a way to isolate the behavior of the filesystem into test directories.
    The tmppath fixture is built in to pytest and provides temporary directories into
    which test files can be written safely.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now define a test function that will use the mock_datetime fixture and
    the tmppath fixture. It will use the monkeypatch fixture to adjust the context
    of the module under test:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can use the monkeypatch fixture to replace an attribute of the recipe_08
    module. The datetime attribute value will be replaced with the Mock object created
    by the mock_datetime fixture:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Between the fixture definitions and this patch, we’ve created a Given step that
    defines the test arrangement.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now exercise the save_data() function in a controlled test environment.
    This is the When step that exercises the code under test:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Since the date and time are fixed by the Mock object, the output file has a
    known, predictable name. We can read and validate the expected data in the file.
    Further, we can interrogate the Mock object to be sure it was called exactly once
    with no argument values. This is a Then step to confirm the expected results:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This test confirms the application’s save_data() function will create the expected
    file with the proper content.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 15.8.3 How it works...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The unittest.mock module has a wonderfully sophisticated class definition, the
    Mock class. A Mock object can behave like other Python objects, while offering
    a limited subset of behaviors. In this example, we’ve created three different
    kinds of Mock objects.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: The Mock(wraps="datetime", ...) object mocks a complete module. It will behave,
    to the extent needed by this test scenario, like the standard library datetime
    module. Within this object, we created a mock class definition but didn’t assign
    it to any variable.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: The Mock(now=...) object behaves like a mock class definition inside the mock
    module. We’ve created a single now attribute value, which will behave like a static
    function.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The Mock(return_value=...) object behaves like an ordinary function or method.
    We provide the return value required for this test.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: In addition to returning the given value, a Mock object records the history
    of calls. This means an assertion can checks those calls. The call() function
    from the Mock module provides a way to describe the arguments that are expected
    in the function call.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 15.8.4 There’s more...
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we created a mock for the datetime module that had a very narrow
    feature set for this test. The module contained a mocked class named datetime.
    This class has a single attribute, a mocked function, now().
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the return_value attribute, we can use the side_effect attribute
    to raise an exception instead of returning a value. We can use this to spot code
    that’s not using the now() method properly, but using the deprecated utcnow()
    or the today() methods.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend this pattern and mock more than one attribute to behave like
    a function. Here’s an example that mocks several functions:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Two of the mocked methods, utcnow() and today(), each define a side effect that
    will raise an exception. This allows us confirm legacy code has been converted
    to make proper use of the now() method.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 15.8.5 See also
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe earlier in this chapter has more information about the basic use of the
    unittest module.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.9 Testing things that involve randomness
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications rely on the random module to create random values or put values
    into a random order. In many statistical tests, repeated random shuffling or random
    selection is done. When we want to test one of these algorithms, any intermediate
    results or details of the processing are essentially impossible to predict.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two choices for trying to make the random module predictable enough
    to write detailed unit tests:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Use the random module with a known seed value.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a Mock object to replace the random module with a Mock object to produce
    predictable values.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at ways to unit test algorithms that involve randomness.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 15.9.1 Getting ready
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a sample dataset, we can compute a statistical measure such as a mean
    or median. A common next step is to determine the likely values of these statistical
    measures for some overall population. This can be done by a technique called bootstrapping.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to resample the initial set of data repeatedly. Each of the resamples
    provides a different estimate of the statistical measures for the population.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: In order to be sure that a resampling algorithm is implemented correctly, it
    helps to eliminate randomness from the processing. We can resample a carefully
    planned set of data with a non-randomized version of the random.choice() function.
    If this works properly, then we have confidence that the randomized version will
    also work.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our candidate resampling function:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'For our example, we’ll compute alternative values of the mean based on resampling.
    The overall resampling procedure looks like this:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This evaluates the resample() function to create a number of subsets. Each subset’s
    mean populates the means collection. The histogram created by this mean_distribution()
    function will provide a helpful estimate for population variance.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the output looks like:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This shows us that the most likely value for the mean of the overall population
    could be between 7.1 and 7.8\. There’s more to this kind of analysis than we’re
    showing here. Our focus is limited to the narrow question of testing the resample()
    function.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'The test for resampling involves a scenario like the following:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 15.9.2 How to do it...
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll define a mock object that can be used instead of the random.choice()
    function. With this fixture in place, the results are fixed and predictable:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need the core tools for creating mock objects and test fixtures. Also,
    we’ll need the module we’re going to test:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We’ll need an object that will behave like the choice() function. We’ll create
    a fixture built on another fixture:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The expected_resample_data fixture provides a specific list of values that will
    provide expected results. Using this fixture, the mock_random_choice choice fixture
    returns the expected values in response to the choice() function.
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now define a test function that will use the mock_random_choice fixture,
    which creates a mock object, and the monkeypatch fixture, which lets us adjust
    the context of the module under test:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can use the monkeypatch fixture to replace the choice attribute of the random
    module with the Mock object created by the mock_random_choice fixture:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Between the fixture definitions and this patch, we’ve created a Given step that
    defines the test arrangement.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now exercise the resample() function in a controlled test environment.
    This is the When step that exercises the code under test:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Since the random choices are fixed by the Mock object, the result is fixed.
    We can confirm that the data created by the mock_random_choice fixture was used
    for resampling. We can also confirm that the mocked choice function was properly
    called with the input data:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This test helps to confirm that our resample() function will create the output
    based on the given input and the random.choice() function.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 15.9.3 How it works...
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create a Mock object, we must provide the methods and attributes to
    define the behavior of the object being mocked. When we create an instance of
    Mock that provides the side_effect argument value, we’re creating a callable object.
    The callable object will return the next value from the side_effect sequence each
    time the Mock object is called. This gives us a handy way to mock iterators.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: If any value in side_effect is an exception, this is raised.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: We can also see the call history using the mock_calls attribute of a Mock object.
    This lets us confirm that the callable was provided proper argument values.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 15.9.4 There’s more...
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The resample() function has an interesting pattern to it. When we take a step
    back from the details, we see this:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The X argument value is simply passed through to another function without any
    processing. For testing purposes, it doesn’t matter what the value of X is. What
    we’re testing is that the parameter’s value in the resample() function is provided
    to the another_function() function, untouched.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: The mock library provides an object called sentinel that can be used to create
    an opaque argument value in these circumstances. When we refer to an attribute
    of the sentinel object, this reference creates a distinct object. We might use
    sentinel.POPULATION as a kind of mock for a collection of values. The exact collection
    doesn’t matter since it’s simply passed as an argument to another function (called
    random.choice() in the actual code).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how this use of a sentinel object can change this test:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The output from the mocked choice() function is a recognizable sentinel object.
    Similarly, the parameter to the resample() function is a different sentinel object.
    We expect this to be called 8 times, because the N parameter is set to 8 in the
    test case.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: When an object should pass through a function untouched, we can write test assertions
    to confirm this expected behavior. If the code we’re testing uses the population
    object improperly, the test can fail when the result is not the untouched sentinel
    object.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'The 1.7.1 release of the mypy tool struggles with the imports in the recipe_09
    module. We used a # type: ignore [attr-defined] comment to suppress a confusing
    mypy message.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: This test gives us confidence that the population of values is provided, untouched,
    to the random.choice() function and the N parameter value defines the size of
    the returned set of items from the population.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 15.9.5 See also
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Building sets – literals, adding, comprehensions, and operators](ch008_split_001.xhtml#x1-2670007)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004), and the [Creating dictionaries
    – inserting and updating](ch009.xhtml#x1-2900001) recipe in Chapter [5](ch009.xhtml#x1-2890005),
    the [Using cmd to create command-line applications](ch010.xhtml#x1-3610006) recipe
    in Chapter [6](ch010.xhtml#x1-3300006) show how to seed the random number generator
    to create a predictable sequence of values.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Chapter [7](ch011_split_000.xhtml#x1-3760007), there are several other recipes
    that show an alternative approach, for example, [Using a class to encapsulate
    data and processing](ch011_split_000.xhtml#x1-3770001), [Designing classes with
    lots of processing](ch011_split_000.xhtml#x1-3890003), [Optimizing small objects
    with __slots__](ch011_split_001.xhtml#x1-4130007), and [Using properties for lazy
    attributes](ch011_split_001.xhtml#x1-43100010).
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, in Chapter [8](ch012.xhtml#x1-4520008), see the [Choosing between inheritance
    and composition – the ”is-a” question](ch012.xhtml#x1-4530001), [Separating concerns
    via multiple inheritance](ch012.xhtml#x1-4610002), [Leveraging Python’s duck typing](ch012.xhtml#x1-4670003),
    and [Creating a class that has orderable objects](ch012.xhtml#x1-4870006) recipes.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.10 Mocking external resources
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier recipes in this chapter, namely, [Testing things that involve dates
    or times](ch019_split_001.xhtml#x1-8430008) and [Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009),
    we wrote tests for involving resources with states that we could predict and mock.
    In one case, we created a mock datetime module that had a fixed response for the
    current time. In the other case, we created a mock function from the random module.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: A Python application can use the os, subprocess, and pathlib modules to make
    significant changes to the internal states of a running computer. We’d like to
    be able to test these external requests in a safe environment, using mocked objects,
    and avoid the horror of corrupting a working system with a misconfigured test.
    Another example is database access, which requires mock objects to respond to
    create, retrieve, update, and delete requests.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at ways to create more sophisticated mock objects.
    These will allow the safe testing of changes to precious OS resources like files
    and directories.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 15.10.1 Getting ready
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll revisit an application that makes a number of OS changes. In Chapter [11](ch015_split_000.xhtml#x1-61500011),
    the [Replacing a file while preserving the previous version](ch015_split_000.xhtml#x1-6260002)
    recipe showed how to write a new file and then rename it so that the previous
    copy was always preserved.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: A thorough set of test cases would present a variety of failure modes. Having
    tests for several different kinds of errors can help provide confidence that the
    function behaves properly.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential design was a definition of a class of objects, Quotient, and
    a save_data() function to write one of those objects to a file. Here’s an overview
    of the code:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Consider what happens when there’s a failure in the middle of the save_data()
    function. Outcomes include a file that’s partially rewritten, and useless to other
    applications. To prevent this, the recipe presented a safe_write() function that
    included several steps to create a temporary file and then rename that file to
    be the desired output file. Essentially, the function looked like this:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The safe_write() function is shown in detail in Chapter [11](ch015_split_000.xhtml#x1-61500011).
    This is designed to handle a number of scenarios:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Everything works – sometimes called the ”happy path” – and the file is created
    properly.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The save_data() function raises an exception. The corrupted file is removed
    and the original left in place.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failure occurs elsewhere in the processing of the safe_write() processing. There
    are three scenarios where a Path method raises an exception.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each of the above scenarios can be translated into Gherkin to help clarify
    precisely what it means; for example:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Detailing each of the five scenarios helps us define Mock objects to provide
    the various kinds of external resource behaviors we need. Each scenario suggests
    a distinct fixture to reflect the distinct failure mode.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 15.10.2 How to do it...
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll use a variety of testing techniques. The pytest package offers the tmp_path
    fixture, which can be used to create isolated files and directories. In addition
    to an isolated directory, we’ll also want to use a Mock to stand in for the parts
    of the application that we’re not testing:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Identify all of the fixtures required for the various scenarios. For the happy
    path, where the mocking is minimal, the tmp_path fixture is all we need. For scenario
    two, where the save_data() function is broken, this function should be mocked.
    For the remaining three scenarios, mock objects can be defined that will replace
    methods of Path objects.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This test will use a number of features from the pytest and unittest.mock modules.
    It will be creating Path objects and test functions defined in the recipe_10 module:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Write a test fixture to create the original file, which should not be disturbed
    unless everything works correctly. We’ll use a sentinel object to provide some
    text that is unique and recognizable as part of this test scenario:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Write a mock to replace the save_data() function. This will create mock data
    used to validate that the safe_write() function works. In this, too, we’ll use
    a sentinel object to create a unique string that is recognizable later in the
    test:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Write the happy path scenario. The save_data_good() function can be given as
    the side_effect of a Mock object and used in place of the original save_data()
    function. Using a Mock means the call history will be tracked. This helps to confirm
    that the overall safe_write() function being tested really does use the save_data()
    function to create the expected resulting file:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Write a mock for scenario two, in which the save_data() function fails to work
    correctly. The mock can rely on a save_data_failure() function to write recognizably
    corrupt data, and then also raise an unexpected exception:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Write the test case for scenario two, using the save_data_failure() function
    as the side_effect of a Mock object:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The save_data_failure() function wrote corrupt data, but the safe_write() function
    preserved the original file.
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This recipe produced two test scenarios that confirm the safe_write() function
    will work. We’ll turn to the remaining three scenarios in the There’s more… section
    later in this recipe.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 15.10.3 How it works...
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When testing software that makes OS, network, or database requests, it’s imperative
    to include cases where the external resource fails to operate as expected. The
    principal tools for doing this are Mock objects and the monkeypatch fixture. A
    test can replace Python library functions with Mock objects that raise exceptions
    instead of working correctly.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: For the happy path scenario, we replaced the save_data() function with a Mock
    object that wrote some recognizable data. Because we’re using the tmp_path fixture,
    the file was written into a safe, temporary directory, where it could be examined
    to confirm that new, good data replaced the original data.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: For the first of the failure scenarios, we used the monkeypatch fixture to replace
    the save_data() function with a function that both wrote corrupt data and also
    raised an exception as if an OS problem occurred. This is one way to simulate
    a broad spectrum of application failures that involve some kind of persistent
    filesystem artifact. In simpler cases, where there is no artifact, a Mock object
    with an exception class as the value of the side_effect parameter is all that’s
    required to simulate a failure.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: These test scenarios also made use of unique sentinel objects. Evaluating the
    value of the hex(id(x)) provides a distinct string value that’s difficult to predict.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 15.10.4 There’s more...
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The remaining scenarios are very similar; they can all share the following
    test function:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This function uses the save_data_good() function as the side effect when the
    mocked save_data() function is invoked. The given save_data_good() function will
    be executed and will write a known good test file. Each of these scenarios involve
    exceptions from Path operations after the good file was created.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: We’ve omitted showing any scenario-specific details. The key feature of this
    test is preserving the original good data in spite of exceptions.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: To support multiple exception scenarios, we want to use three different versions
    of the mock_pathlib_path mock object.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a parameterized fixture to spell out these three alternative configurations
    of the mock objects. First, we’ll package the choices as three separate dictionaries
    that provide the side_effect values:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We’ve used RuntimeError as the exception to raise, triggering alternative execution
    paths. In some cases, it may be necessary to use a IOError exception. In this
    case, any exception would be fine.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'Given these three dictionary objects, we can plug the values into a fixture
    via the request.params option provided by pytest:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Because this fixture has three parameter values, any test using this fixture
    will be run three times, once with each of the values. This lets us reuse the
    test_safe_write_scenarios() test case to be sure it works with a variety of system
    failures.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: We’ve created a variety of mock objects to inject failures throughout the processing
    in a complex function. Using parameterized fixture helps to define consistent
    mock objects for these tests.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: There’s yet another scenario that involves a successful operation followed by
    a failing operation on the same file. This doesn’t fit the above pattern and requires
    another test case with a slightly more sophisticated set of mock objects. We leave
    this as an exercise for you.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 15.10.5 See also
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Testing things that involve dates or times](ch019_split_001.xhtml#x1-8430008)
    and [Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009)
    recipes earlier in this chapter show techniques for dealing with unpredictable
    data.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements of this can be tested with the doctest module. See the [Using docstrings
    for testing](ch019_split_000.xhtml#x1-7950001) recipe earlier in this chapter
    for examples. It’s also important to combine these tests with any doctests. See
    the [Combining pytest and doctest tests](ch019_split_001.xhtml#x1-8370007) recipe
    earlier in this chapter for more information on how to do this.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
