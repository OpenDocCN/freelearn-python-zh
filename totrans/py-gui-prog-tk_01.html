<html><head></head><body>
  <div id="_idContainer023">
    <h1 class="chapterNumber">1</h1>
    <h1 id="_idParaDest-15" class="chapterTitle">Introduction to Tkinter</h1>
    <p class="normal">Welcome, Python coder! If you've learned the basics of Python and want to start designing powerful GUI applications, this book is for you.</p>
    <p class="normal">By now, you have no doubt experienced the power and simplicity of Python. Perhaps you've written web services, performed data analysis, or administered servers. Perhaps you've written a game, automated routine tasks, or simply played around with code. But now you're ready to tackle the GUI.</p>
    <p class="normal">With so much emphasis on web, mobile, and server-side programming, the development of simple desktop GUI applications seems increasingly like a lost art; many otherwise experienced developers have never learned to create one. What a tragedy! Desktop computers still play a vital role in work and home computing, and the ability to build simple, functional applications for this ubiquitous platform should be a part of every software developer's toolbox. Fortunately, for Python coders, that ability is well within reach thanks to Tkinter.</p>
    <p class="normal">In this chapter, you will cover the following topics:</p>
    <ul>
      <li class="bullet">In <em class="italic">Introducing Tkinter and Tk</em>, you'll learn about Tkinter, a fast, fun, easy-to-learn GUI library built in to the Python Standard Library; and IDLE, an editor and development environment written in Tkinter.</li>
      <li class="bullet">In <em class="italic">An overview of basic Tkinter</em>, you'll learn the basics of Tkinter with a "Hello World" program and create a Survey application.</li>
    </ul>
    <h1 id="_idParaDest-16" class="title">Introducing Tkinter and Tk</h1>
    <p class="normal">The Tk widget library originates<a id="_idIndexMarker000"/> from the <strong class="keyword">Tool Command Language</strong> (<strong class="keyword">Tcl</strong>) programming language. Tcl and Tk were created by John Ousterhout while he was a professor at Berkeley in the late 1980s as an easier way to program the engineering tools being used at the university. Because of its speed and relative simplicity, Tcl/Tk rapidly grew in popularity among academic, engineering, and Unix programmers. Much<a id="_idIndexMarker001"/> like Python itself, Tcl/Tk originated on the Unix platform and only later migrated to macOS and Windows. Tk's practical intent and Unix roots still inform its design today, and its simplicity compared to other toolkits is still a major strength.</p>
    <p class="normal"><strong class="keyword">Tkinter</strong> is <a id="_idIndexMarker002"/>a Python interface to the Tk GUI library and has been a part of the Python standard library since 1994 with the release of Python version 1.1, making it the <em class="italic">de-facto</em> GUI library for Python. Documentation for Tkinter, along with links for further study, can be <a id="_idIndexMarker003"/>found in the standard library documentation at <a href="https://docs.python.org/3/library/tkinter.html"><span class="url">https://docs.python.org/3/library/tkinter.html</span></a>.</p>
    <h2 id="_idParaDest-17" class="title">Choosing Tkinter</h2>
    <p class="normal">Python coders <a id="_idIndexMarker004"/>who want to build a GUI have several toolkit options to choose from; unfortunately, Tkinter is often maligned or ignored as a legacy option. To be fair, it's not a glamorous technology that you can describe in trendy buzzwords and glowing hype. However, Tkinter is not only adequate for a wide variety of applications but also has some advantages that can't be ignored:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Tkinter is in the standard library</strong>: With <a id="_idIndexMarker005"/>few exceptions, Tkinter is available wherever Python is available. There is no need to install pip, create virtual environments, compile binaries, or search the web for installation packages. For simple projects that need to be done quickly, this is a clear advantage.</li>
      <li class="bullet"><strong class="keyword">Tkinter is stable</strong>: While Tkinter development has not stopped, it is slow and evolutionary. The API has been stable for years, the changes mainly being additional functionality and bug fixes. Your Tkinter code will likely run unaltered for years or decades to come.</li>
      <li class="bullet"><strong class="keyword">Tkinter is only a GUI toolkit</strong>: Unlike some other GUI libraries, Tkinter doesn't have its own threading library, network stack, or filesystem API. It relies on regular Python libraries for such things, so it's perfect for applying a GUI to existing Python code.</li>
      <li class="bullet"><strong class="keyword">Tkinter is simple and no-nonsense</strong>: Tkinter is very basic and to-the-point; it can be used effectively in both procedural and object-oriented GUI designs. To use Tkinter, you don't have to learn hundreds of widget classes, a markup or templating language, a new programming paradigm, client-server technologies, or a different programming language.</li>
    </ul>
    <p class="normal">Tkinter is not perfect, of course. It also has some disadvantages:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Tkinter's default look and feel is dated</strong>: Tkinter's default appearance has long lagged behind current trends, and it still bears a few artifacts from the 1990s Unix world. While<a id="_idIndexMarker006"/> it lacks niceties like animated widgets, gradients, or scalable graphics, it has nevertheless improved a great deal in the last few years, thanks to updates in Tk itself and the addition of themed widget libraries. We'll learn how to fix or avoid some of Tkinter's more archaic defaults throughout the book.</li>
      <li class="bullet"><strong class="keyword">Tkinter lacks more complex widgets</strong>: Tkinter is missing advanced widgets like rich text editors, 3D graphics embedding, HTML viewers, or specialized input widgets. As we'll see later in this book, Tkinter gives us the ability to create complex widgets by customizing and combining its simple ones.</li>
    </ul>
    <p class="normal">Tkinter might be the wrong choice for a game UI or slick commercial application; however, for data-driven applications, simple utilities, configuration dialogs, and other business logic applications, Tkinter offers all that is needed and more. In this book we're going to be working through the development of data entry application for a workplace environment, something that Tkinter can handle admirably.</p>
    <h2 id="_idParaDest-18" class="title">Installing Tkinter</h2>
    <p class="normal">Tkinter is<a id="_idIndexMarker007"/> included in the Python standard library for the Windows and macOS distributions. So, if you have installed Python on these platforms using the official installers, you don't need to do anything to install Tkinter.</p>
    <p class="normal">However, we're going to be exclusively focused on Python 3.9 for this book; so, you need to make sure that you have this version or later installed.</p>
    <h3 id="_idParaDest-19" class="title">Installing Python 3.9 on Windows</h3>
    <p class="normal">You can obtain<a id="_idIndexMarker008"/> Python 3 installers for Windows<a id="_idIndexMarker009"/> from<a id="_idIndexMarker010"/> the <a href="http://python.org"><span class="url">python.org</span></a> website by performing the following steps:</p>
    <ol>
      <li class="numbered">Go to <a href="https://www.python.org/downloads/windows/"><span class="url">https://www.python.org/downloads/windows</span></a>.</li>
      <li class="numbered">Select the latest Python 3 release. At the time of writing, the latest version is 3.9.2.</li>
      <li class="numbered">Under the <strong class="screenText">Files</strong> section, select the Windows executable installer appropriate to your system's architecture (x86 for 32-bit Windows, x86-64 for 64-bit Windows; if you're unsure, x86 will work on either).</li>
      <li class="numbered">Launch the downloaded installer.</li>
      <li class="numbered">Click on <strong class="screenText">Customize installation</strong>. Make <a id="_idIndexMarker011"/>sure the <strong class="screenText">tcl/tk and IDLE</strong> option is checked (it should be by default).</li>
      <li class="numbered">Continue<a id="_idIndexMarker012"/> through the installer with all defaults.</li>
    </ol>
    <h3 id="_idParaDest-20" class="title">Installing Python 3 on macOS</h3>
    <p class="normal">As of this <a id="_idIndexMarker013"/>writing, macOS ships with Python 2.7 built in. However, Python 2 was officially deprecated in 2020, and the code in this book will not <a id="_idIndexMarker014"/>work with it, so<a id="_idIndexMarker015"/> macOS users will need to install Python 3 to follow this book.</p>
    <p class="normal">Follow this procedure to install Python3 on macOS:</p>
    <ol>
      <li class="numbered" value="1">Go to <a href="https://www.python.org/downloads/mac-osx/"><span class="url">https://www.python.org/downloads/mac-osx/</span></a>.</li>
      <li class="numbered">Select the latest Python 3 release. At the time of writing, the latest version is 3.9.2.</li>
      <li class="numbered">Under the <strong class="screenText">Files</strong> section, select and download the macOS 64-bit/32-bit installer.</li>
      <li class="numbered">Launch the <code class="Code-In-Text--PACKT-">.pkg</code> file that you've downloaded and follow the steps of the install wizard, selecting defaults.</li>
    </ol>
    <h3 id="_idParaDest-21" class="title">Installing Python 3 and Tkinter on Linux</h3>
    <p class="normal">Most <a id="_idIndexMarker016"/>Linux distributions<a id="_idIndexMarker017"/> include both Python 2 and Python 3; however, Tkinter<a id="_idIndexMarker018"/> is not always<a id="_idIndexMarker019"/> bundled with it or installed by default. To find out if Tkinter is installed, open a Terminal and try the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ python3 -m tkinter
</code></pre>
    <p class="normal">This should open a simple window showing some information about Tkinter. If you get <code class="Code-In-Text--PACKT-">ModuleNotFoundError</code> instead, you will need to use your package manager to install your distribution's Tkinter package for Python 3. In most major distributions, including Debian, Ubuntu, Fedora, and openSUSE, this package is called <code class="Code-In-Text--PACKT-">python3-tk</code>.</p>
    <h2 id="_idParaDest-22" class="title">Introducing IDLE</h2>
    <p class="normal"><strong class="keyword">IDLE</strong> is <a id="_idIndexMarker020"/>an integrated development environment that is bundled with the official Python software distributions for Windows and macOS (it's readily available in most Linux distributions as well, usually as <code class="Code-In-Text--PACKT-">idle</code> or <code class="Code-In-Text--PACKT-">idle3</code>). </p>
    <p class="normal">IDLE is written in Python using Tkinter, and it provides us with not only an editing environment for Python but also a great example of Tkinter in action. So, while IDLE's rudimentary feature set may not be considered professional grade by experienced Python coders, and while you may already have a <a id="_idIndexMarker021"/>preferred environment for writing Python code, I encourage you to spend some time using IDLE as you go through this book.</p>
    <p class="normal">IDLE has two primary modes: shell mode and editor mode. We'll take a look at those in this section.</p>
    <h3 id="_idParaDest-23" class="title">Using the shell mode of IDLE</h3>
    <p class="normal">When you<a id="_idIndexMarker022"/> launch IDLE, you begin in shell mode, which is simply a Python <strong class="keyword">Read-Evaluate-Print-Loop</strong> (<strong class="keyword">REPL</strong>) similar <a id="_idIndexMarker023"/>to what<a id="_idIndexMarker024"/> you get when you type <code class="Code-In-Text--PACKT-">python</code> in a Terminal window.</p>
    <p class="normal">You can see IDLE's shell mode in this screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B17578_01_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.1: IDLE's shell mode</p>
    <p class="normal">IDLE's shell has some nice features that you don't get from the command-line REPL, like syntax highlighting and tab completion. The REPL is essential to the Python development process, as it gives you the ability to test code in real time and inspect classes and APIs without having to write complete scripts. We'll use the shell mode in later chapters to explore the features and behaviors of modules. If you don't have a shell window open, you can open one by clicking on <strong class="screenText">Run</strong> | <strong class="screenText">Python Shell</strong> in the IDLE menu.</p>
    <h3 id="_idParaDest-24" class="title">Using the editor mode of IDLE</h3>
    <p class="normal">Editor mode is<a id="_idIndexMarker025"/> for creating <a id="_idIndexMarker026"/>Python script files, which you can later run. When the book tells you to create a new file, this is the mode you'll use. To open a new file in the editor mode, simply navigate to <strong class="screenText">File</strong> | <strong class="screenText">New File</strong> in the menu or hit <span class="keyStroke">Ctrl</span> + <span class="keyStroke">N</span> on the keyboard.</p>
    <p class="normal">This image shows IDLE's file editor:</p>
    <figure class="mediaobject"><img src="../Images/B17578_01_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.2: IDLE's file editor</p>
    <p class="normal">You can<a id="_idIndexMarker027"/> run <a id="_idIndexMarker028"/>your script without leaving IDLE by hitting the <span class="keyStroke">F5</span> key in the editor mode; IDLE will open a shell-mode window to execute the script and display the output.</p>
    <h3 id="_idParaDest-25" class="title">IDLE as a Tkinter example</h3>
    <p class="normal">Before we start <a id="_idIndexMarker029"/>coding with Tkinter, let's take a quick look at what you can do with it by inspecting some of IDLE's UI. Navigate to <strong class="screenText">Options</strong> | <strong class="screenText">Configure IDLE</strong> from the main menu to open IDLE's configuration settings. Here you can change IDLE's fonts, colors and theme, keyboard shortcuts, and default behaviors, as shown in this screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B17578_01_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.3: IDLE configuration settings</p>
    <p class="normal">Consider <a id="_idIndexMarker030"/>some<a id="_idIndexMarker031"/> of the following components that make up <a id="_idIndexMarker032"/>this user interface:</p>
    <ul>
      <li class="bullet">There are drop-down menus that allow you to select between large sets of options.</li>
      <li class="bullet">There are checkable buttons that allow you to select between small sets of options.</li>
      <li class="bullet">There are many push buttons that you can click on to execute actions.</li>
      <li class="bullet">There is a text window that can display multi-colored text.</li>
      <li class="bullet">There are<a id="_idIndexMarker033"/> labeled frames that contain groups of components.</li>
      <li class="bullet">There are tabs across the top of the screen to select different sections of the configuration.</li>
    </ul>
    <p class="normal">In <a id="_idIndexMarker034"/>Tkinter (as in most GUI libraries), each of these components is known as a <strong class="keyword">widget</strong>; we're going to meet these widgets and more throughout this book and learn how to use them as they've been used here. We'll begin, however, with something much simpler.</p>
    <h2 id="_idParaDest-26" class="title">Creating a Tkinter Hello World</h2>
    <p class="normal">One of the <a id="_idIndexMarker035"/>grand traditions in any programming language or library is to create a "Hello World" program: that is, a program that displays <code class="Code-In-Text--PACKT-">Hello World</code> and exits. Let's walk through creating a "Hello World" application for Tkinter and talk about the pieces of it along the way.</p>
    <p class="normal">First, create a new file called <code class="Code-In-Text--PACKT-">hello_tkinter.py</code> in IDLE or your favorite editor, and enter the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"""Hello World application for Tkinter"""</span>
<span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk
</code></pre>
    <p class="normal">The first line is <a id="_idIndexMarker036"/>called a <strong class="keyword">docstring</strong>, and every Python script should start with one. At a minimum, it should give the name of the program but can also include details about how to use it, who wrote it, and what it requires.</p>
    <p class="normal">The second line imports the <code class="Code-In-Text--PACKT-">tkinter</code> module into our program. Although Tkinter is in the standard library, we have to import it before we can use any of its classes or functions.</p>
    <p class="normal">Sometimes, you may see this import written as <code class="Code-In-Text--PACKT-">from tkinter import *</code>. That approach is called a <strong class="keyword">wildcard import</strong>, and<a id="_idIndexMarker037"/> it results in all the objects being brought into the <a id="_idIndexMarker038"/>global <strong class="keyword">namespace</strong>. While popular in tutorials for its simplicity, it's a bad idea in actual code as there is a possibility of a collision between our own variable names and all names in the <code class="Code-In-Text--PACKT-">tkinter</code> module, which can cause subtle bugs. </p>
    <p class="normal">To avoid this, we're going to keep <code class="Code-In-Text--PACKT-">tkinter</code> in its own <strong class="keyword">namespace</strong>; however, to keep the code concise, we'll alias <code class="Code-In-Text--PACKT-">tkinter</code> to <code class="Code-In-Text--PACKT-">tk</code>. This convention will be used throughout the book.</p>
    <p class="normal">Every Tkinter program <a id="_idIndexMarker039"/>must have exactly one <strong class="keyword">root window</strong>, which <a id="_idIndexMarker040"/>represents both the top-level window of our application, and the application itself. Let's create our <code class="Code-In-Text--PACKT-">root</code> window, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">root = Tk()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">root</code> window is an instance of the <code class="Code-In-Text--PACKT-">Tk</code> class. We create it by calling <code class="Code-In-Text--PACKT-">Tk()</code> as we've done here. This object must exist before we can create any other Tkinter objects, and when it is destroyed, the application quits.</p>
    <p class="normal">Now, let's create a widget to put in our window:</p>
    <pre class="programlisting code"><code class="hljs-code">label = Label(root, text=<span class="hljs-string">"Hello World"</span>)
</code></pre>
    <p class="normal">This is a <code class="Code-In-Text--PACKT-">Label</code> widget, which is just a panel that can display some text. The first argument to any Tkinter widget is always the <a id="_idIndexMarker041"/><strong class="keyword">parent widget</strong> (sometimes called <strong class="keyword">master widget</strong>); in <a id="_idIndexMarker042"/>this case, we've passed in a reference to our root window. The parent widget is the widget on which our <code class="Code-In-Text--PACKT-">Label</code> will be placed, so this <code class="Code-In-Text--PACKT-">Label</code> will be directly on the root window of the application. Widgets in a Tkinter GUI are arranged in a hierarchy, each widget being contained by another all the way up to the root window.</p>
    <p class="normal">We've also passed in a keyword argument, <code class="Code-In-Text--PACKT-">text</code>. This argument, of course, defines the text that will be placed on the widget. For most Tkinter widgets, the majority of configuration is done using keyword arguments like this.</p>
    <p class="normal">Now that we've created a widget, we need to actually place it on the GUI:</p>
    <pre class="programlisting code"><code class="hljs-code">label.pack()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">pack()</code> method of the <code class="Code-In-Text--PACKT-">Label</code> widget is called <a id="_idIndexMarker043"/>a <strong class="keyword">geometry manager method</strong>. Its job is to determine how the widget will be attached to its parent widget, and to draw it there. Without this call, your widget would exist but you wouldn't see it anywhere on the window. <code class="Code-In-Text--PACKT-">pack()</code> is one of three geometry managers, which we'll learn more about in the next section.</p>
    <p class="normal">The last line of our program looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">root.mainloop()
</code></pre>
    <p class="normal">This line starts our application's <strong class="keyword">event loop</strong>. The event loop is an infinite loop that continually processes <a id="_idIndexMarker044"/>any <strong class="keyword">events</strong> that <a id="_idIndexMarker045"/>happen during the execution of the program. Events can be things<a id="_idIndexMarker046"/> like keystrokes, mouse clicks, or other user-generated activity. This loop runs until the program exits, so any code after this line will not be run until the main window is closed. For this reason, this line is usually the last one in any Tkinter program.</p>
    <p class="normal">Run the program in IDLE by hitting <span class="keyStroke">F5</span>, or in your Terminal by typing the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ python hello_tkinter.py
</code></pre>
    <p class="normal">You should see a very tiny window pop up with the text <strong class="screenText">Hello World</strong> as shown here:</p>
    <figure class="mediaobject"><img src="../Images/B17578_01_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.4: Our "Hello World" application</p>
    <p class="normal">Feel free to play around with this script by adding more widgets before the <code class="Code-In-Text--PACKT-">root.mainloop()</code> call. You can add more <code class="Code-In-Text--PACKT-">Label</code> objects, or try some <code class="Code-In-Text--PACKT-">Button</code> (which creates a clickable button) or <code class="Code-In-Text--PACKT-">Entry</code> (which creates a text field) widgets. Just like <code class="Code-In-Text--PACKT-">Label</code>, these widgets are initialized with a parent object (use <code class="Code-In-Text--PACKT-">root</code>) and a <code class="Code-In-Text--PACKT-">text</code> parameter. Don't forget to call <code class="Code-In-Text--PACKT-">pack()</code> on each widget to place them on the root window.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Example code for all chapters in this book can be downloaded from <a href="https://github.com/PacktPublishing/Python-GUI-Programming-with-Tkinter-2E"><span class="url">https://github.com/PacktPublishing/Python-GUI-Programming-with-Tkinter-2E</span></a>. You may want to download these now so you can follow along.</p>
    </div>
    <p class="normal">When you're ready, move on to the next section where we'll create a more interesting application.</p>
    <h1 id="_idParaDest-27" class="title">An overview of basic Tkinter</h1>
    <p class="normal">As exciting as it <a id="_idIndexMarker047"/>may be to see that first GUI window pop up on the screen, "Hello World" is not a terribly interesting application. Let's start again and dig a little deeper into Tkinter as we build a slightly larger program. Since the next chapter will see you landing a job at a fictitious agricultural laboratory studying fruit plants, let's create a little program to gauge your opinions about bananas.</p>
    <h2 id="_idParaDest-28" class="title">Building a GUI with Tkinter widgets</h2>
    <p class="normal">Start a new file <a id="_idIndexMarker048"/>in your editor called <code class="Code-In-Text--PACKT-">banana_survey.py</code>, and begin<a id="_idIndexMarker049"/> by importing <code class="Code-In-Text--PACKT-">tkinter</code> like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># banana_survey.py</span>
<span class="hljs-string">"""A banana preferences survey written in Python with Tkinter"""</span>
<span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk
</code></pre>
    <p class="normal">As with <code class="Code-In-Text--PACKT-">hello_tkinter.py</code>, we need to create a <code class="Code-In-Text--PACKT-">root</code> window before we can create any widgets or other Tkinter objects:</p>
    <pre class="programlisting code"><code class="hljs-code">root = tk.Tk()
</code></pre>
    <p class="normal">Once again, we've called this object <code class="Code-In-Text--PACKT-">root</code>. The <code class="Code-In-Text--PACKT-">root</code> window can be configured in various ways; for example, we can give it a window title or set its size like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># set the title</span>
root.title(<span class="hljs-string">'Banana interest survey'</span>)
<span class="hljs-comment"># set the root window size</span>
root.geometry(<span class="hljs-string">'640x480+300+300'</span>)
root.resizable(<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">title()</code> method sets our window title (that is, the name that shows up in the task manager and in the window decorations), while <code class="Code-In-Text--PACKT-">geometry()</code> sets the window size. In this case, we're telling the root window to be 640 by 480 pixels. The <code class="Code-In-Text--PACKT-">+300+300</code> sets the position of the window on the screen — in this case, 300 pixels from the top and 300 pixels from the left (the position portion is optional, if you only care about the size). Notice that the argument to <code class="Code-In-Text--PACKT-">geometry()</code> is a string. In Tcl/Tk, every argument is treated as a string. Since Tkinter is just a wrapper that passes arguments on to Tcl/Tk, we'll often find that strings are used to configure Tkinter objects – even when we might expect to use integers or floats.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">resizable()</code> method sets whether or not our window can be resized horizontally and vertically, respectively. <code class="Code-In-Text--PACKT-">True</code> means the window can be resized in that direction, <code class="Code-In-Text--PACKT-">False</code> means its <a id="_idIndexMarker050"/>dimension is fixed. In this case, we want to prevent the resizing of the window so that we don't have to worry about making the<a id="_idIndexMarker051"/> layout flexible to window size changes.</p>
    <p class="normal">Now let's start adding widgets to our survey. We've already met the <code class="Code-In-Text--PACKT-">Label</code> widget, so let's add one:</p>
    <pre class="programlisting code"><code class="hljs-code">title = tk.Label(
  root,
  text=<span class="hljs-string">'Please take the survey'</span>,
  font=(<span class="hljs-string">'Arial 16 bold'</span>),
  bg=<span class="hljs-string">'brown'</span>,
  fg=<span class="hljs-string">'#FF0'</span>
)
</code></pre>
    <p class="normal">As we saw in our "Hello World" example, the first argument passed to any Tkinter widget is the <strong class="keyword">parent</strong> widget <a id="_idIndexMarker052"/>on which the new widget will be placed. In this case, we'll be placing this <code class="Code-In-Text--PACKT-">Label</code> widget on the <code class="Code-In-Text--PACKT-">root</code> window. The remaining arguments to a widget are specified as <a id="_idIndexMarker053"/>keyword arguments. Here, we've specified the following:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">text</code>, which is the text the label will display.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">font</code>, which specifies the family, size, and weight of the font used to display the text. Notice again that the font settings are specified as a simple string, just as our <code class="Code-In-Text--PACKT-">geometry</code> settings were.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">bg</code>, which sets the background color for the widget. We've used a color name here; Tkinter recognizes a great many color names, similar to those used by CSS or X11.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">fg</code>, which sets the foreground (text) color for the widget. In this case, we've specified a short hexadecimal string, in which the three characters represent the red, green, and blue values respectively. We can also use a six-character hex string (for example, <code class="Code-In-Text--PACKT-">#FFE812</code>) for finer-grained control over the color.</li>
    </ul>
    <p class="normal">In <em class="chapterRef">Chapter 9</em>, <em class="italic">Improving the Look with Styles and Themes</em>, we'll learn more sophisticated ways to set up fonts and colors, but this will work just fine for now.</p>
    <p class="normal">Tkinter has many interactive widgets for data entry, of course, the simplest being the <code class="Code-In-Text--PACKT-">Entry</code> widget:</p>
    <pre class="programlisting code"><code class="hljs-code">name_label = tk.Label(root, text=<span class="hljs-string">'What is your name?'</span>)
name_inp = tk.Entry(root)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Entry</code> widget <a id="_idIndexMarker054"/>is just a simple text-input box designed for a single line of text. Most input widgets in Tkinter do not include a label of any kind, so we've added one to make it clear to <a id="_idIndexMarker055"/>our user what the entry box is for.</p>
    <p class="normal">One exception <a id="_idIndexMarker056"/>to that is the <code class="Code-In-Text--PACKT-">Checkbutton</code> widget, which we'll create next:</p>
    <pre class="programlisting code"><code class="hljs-code">eater_inp = tk.Checkbutton(
  root,
  text=<span class="hljs-string">'Check this box if you eat bananas'</span>
)
</code></pre>
    <p class="normal">A <code class="Code-In-Text--PACKT-">Checkbutton</code> creates a check box input; it includes a label that sits next to the box, and we can set its text using the <code class="Code-In-Text--PACKT-">text</code> argument.</p>
    <p class="normal">For entering numbers, Tkinter provides the <code class="Code-In-Text--PACKT-">Spinbox</code> widget. Let's add one:</p>
    <pre class="programlisting code"><code class="hljs-code">num_label = tk.Label(
  root,
  text=<span class="hljs-string">'How many bananas do you eat per day?'</span>
)
num_inp = tk.Spinbox(root, from_=<span class="hljs-number">0</span>, to=<span class="hljs-number">1000</span>, increment=<span class="hljs-number">1</span>)
</code></pre>
    <p class="normal">A <code class="Code-In-Text--PACKT-">Spinbox</code> is like an <code class="Code-In-Text--PACKT-">Entry</code>, but features arrow buttons that can increment and decrement the <a id="_idIndexMarker057"/>number in the box. We've used several arguments to configure it here:</p>
    <ul>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">from_</code> and <code class="Code-In-Text--PACKT-">to</code> arguments set the minimum and maximum values that the buttons will decrement or increment to, respectively. Notice that <code class="Code-In-Text--PACKT-">from_</code> has an extra underscore at the end; this is not a typo! Since <code class="Code-In-Text--PACKT-">from</code> is a Python keyword (used in importing modules), it can't be used as a variable name, so the Tkinter authors chose to use <code class="Code-In-Text--PACKT-">from_</code> instead.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">increment</code> argument sets how much the arrow buttons will increase or decrease the number.</li>
    </ul>
    <p class="normal">Tkinter has several widgets that allow you to choose from preset selection values; one of the simplest is <code class="Code-In-Text--PACKT-">Listbox</code>, which looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">color_label = tk.Label(
  root,
  text=<span class="hljs-string">'What is the best color for a banana?'</span>
)
color_inp = tk.Listbox(root, height=<span class="hljs-number">1</span>)  <span class="hljs-comment"># Only show selected item</span>
<span class="hljs-comment"># add choices</span>
color_choices = (
  <span class="hljs-string">'Any'</span>, <span class="hljs-string">'Green'</span>, <span class="hljs-string">'Green-Yellow'</span>,
  <span class="hljs-string">'Yellow'</span>, <span class="hljs-string">'Brown Spotted'</span>, <span class="hljs-string">'Black'</span>
  )
<span class="hljs-keyword">for</span> choice <span class="hljs-keyword">in</span> color_choices:
  color_inp.insert(tk.END, choice)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Listbox</code> takes a <code class="Code-In-Text--PACKT-">height</code> argument that specifies how many lines are visible; by default the box is big enough to show all the options. We've changed that to <code class="Code-In-Text--PACKT-">1</code> so that only the currently selected option is visible. The others can be accessed using the arrow keys.</p>
    <p class="normal">To add <a id="_idIndexMarker058"/>options to the box, we need to call its <code class="Code-In-Text--PACKT-">insert()</code> method and add each option one at a time. We've done that here using a <code class="Code-In-Text--PACKT-">for</code> loop to save<a id="_idIndexMarker059"/> repetitive coding. The first argument to <code class="Code-In-Text--PACKT-">insert</code> specifies where we want to insert the option; note that we've used a special <strong class="keyword">constant</strong><strong class="keyword"><a id="_idIndexMarker060"/></strong> provided by <code class="Code-In-Text--PACKT-">tkinter</code>, <code class="Code-In-Text--PACKT-">tk.END</code>. This is one of many special constants defined in Tkinter for certain configuration values. In this case, <code class="Code-In-Text--PACKT-">tk.END</code> means the end of the widget, so that each choice that we insert will be placed at the end.</p>
    <p class="normal">Another way to let a user select between a small number of options is the <code class="Code-In-Text--PACKT-">Radiobutton</code> widget; these are like <code class="Code-In-Text--PACKT-">Checkbutton</code> widgets, but, similar to the mechanical preset buttons in (very, very old) car radios, they only allow one to be checked at a time. Let's create a few <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets:</p>
    <pre class="programlisting code"><code class="hljs-code">plantain_label = tk.Label(root, text=<span class="hljs-string">'Do you eat plantains?'</span>)
plantain_frame = tk.Frame(root)
plantain_yes_inp = tk.Radiobutton(plantain_frame, text=<span class="hljs-string">'Yes'</span>)
plantain_no_inp = tk.Radiobutton(plantain_frame, text=<span class="hljs-string">'Ewww, no!'</span>)
</code></pre>
    <p class="normal">Notice what we've done here with <code class="Code-In-Text--PACKT-">plantain_frame</code>: we've created a <code class="Code-In-Text--PACKT-">Frame</code> object and used it as the parent widget for each of the <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets. A <code class="Code-In-Text--PACKT-">Frame</code> is simply a blank panel with nothing on it, and it's useful for organizing our layout hierarchically. We'll use <code class="Code-In-Text--PACKT-">Frame</code> widgets quite often in this book for keeping groups of widgets together.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">Entry</code> widgets work fine for single-line strings, but how about multi-line strings? For those, Tkinter offers us the <code class="Code-In-Text--PACKT-">Text</code> widget, which we create like this:</p>
    <pre class="programlisting code"><code class="hljs-code">banana_haiku_label = tk.Label(
  root, 
  text=<span class="hljs-string">'Write a haiku about bananas'</span>
)
banana_haiku_inp = tk.Text(root, height=<span class="hljs-number">3</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Text</code> widget is capable of much more than just multi-line text, and we'll explore a few of its more advanced capabilities in <em class="chapterRef">Chapter 9</em>, <em class="italic">Improving the Look with Styles and Themes</em>. For now, though, we'll just use it for text.</p>
    <p class="normal">Our GUI would not be complete without a submit button for our survey, which is provided by the <code class="Code-In-Text--PACKT-">Button</code> class, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">submit_btn = tk.Button(root, text=<span class="hljs-string">'Submit Survey'</span>)
</code></pre>
    <p class="normal">We'll use this <a id="_idIndexMarker061"/>button to submit the survey and display <a id="_idIndexMarker062"/>some output. What widget could we use to display that output? It turns out that <code class="Code-In-Text--PACKT-">Label</code> objects are useful for more than just static messages; we can use them to display messages at runtime as well. </p>
    <p class="normal">Let's add one for our program output:</p>
    <pre class="programlisting code"><code class="hljs-code">output_line = tk.Label(root, text=<span class="hljs-string">''</span>, anchor=<span class="hljs-string">'w'</span>, justify=<span class="hljs-string">'left'</span>)
</code></pre>
    <p class="normal">Here we've created the <code class="Code-In-Text--PACKT-">Label</code> widget with no text (since we have no output yet). We're also using a couple of additional <a id="_idIndexMarker063"/>arguments for <code class="Code-In-Text--PACKT-">Label</code>:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">anchor</code> determines which side of the widget the text will be stuck to if the widget is wider than the text. Tkinter sometimes uses cardinal directions (North, South, East, and West) abbreviated to their first letter whenever it needs to specify a side of a widget; in this case, the string <code class="Code-In-Text--PACKT-">'w'</code> indicates the West (or left) side of the widget.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">justify</code> determines which side the text will align to when there are multiple lines of code. Unlike <code class="Code-In-Text--PACKT-">anchor</code>, it uses conventional <code class="Code-In-Text--PACKT-">'left'</code>, <code class="Code-In-Text--PACKT-">'right'</code>, and <code class="Code-In-Text--PACKT-">'center'</code> options.</li>
    </ul>
    <p class="normal"><code class="Code-In-Text--PACKT-">anchor</code> and <code class="Code-In-Text--PACKT-">justify</code> may seem redundant, but they have slightly different behavior. In a multiline text situation, the text could be aligned to the center of each line, but the whole collection of lines could be anchored to the west side of the widget, for example. In other words, <code class="Code-In-Text--PACKT-">anchor</code> affects the whole block of text with respect to the containing widget, while <code class="Code-In-Text--PACKT-">justify</code> affects the individual lines of text with respect to the other lines.</p>
    <p class="normal">Tkinter has many more widgets, and we'll meet many of them throughout the remainder of the book.</p>
    <h2 id="_idParaDest-29" class="title">Arranging our widgets with geometry managers</h2>
    <p class="normal">If you<a id="_idIndexMarker064"/> were to add <code class="Code-In-Text--PACKT-">root.mainloop()</code> to this script and execute it as-is, you would see… a blank window. Hmmm, what happened to <a id="_idIndexMarker065"/>all those widgets we just created? Well, you may remember from <code class="Code-In-Text--PACKT-">hello_tkinter.py</code> that we need to use a geometry manager like <code class="Code-In-Text--PACKT-">pack()</code> to actually place them somewhere on their parent widgets.</p>
    <p class="normal">Tkinter has three geometry manager methods available:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">pack()</code> is the<a id="_idIndexMarker066"/> oldest, and simply adds widgets to one of the four sides of a window sequentially.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">grid()</code> is <a id="_idIndexMarker067"/>newer and preferred, and allows you to place widgets within a 2-dimensional grid table.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">place()</code> is a<a id="_idIndexMarker068"/> third option, which allows you to put widgets at specific pixel coordinates. It is not recommended, as it responds poorly to changes in window sizes, font sizes, and screen resolution, so we won't be using it in this book.</li>
    </ul>
    <p class="normal">While <code class="Code-In-Text--PACKT-">pack()</code> is certainly fine for simple layouts involving a handful of widgets, it doesn't scale so well to more complex layouts without an inordinate amount of <code class="Code-In-Text--PACKT-">Frame</code> widget nesting. For this reason, most Tkinter programmers rely on the more modern <code class="Code-In-Text--PACKT-">grid()</code> geometry manager. As the name suggests, <code class="Code-In-Text--PACKT-">grid()</code> allows you to lay out widgets on a 2-dimensional grid, much like a spreadsheet document or HTML table. In this book, we'll focus primarily on <code class="Code-In-Text--PACKT-">grid()</code>.</p>
    <p class="normal">Let's start laying out the widgets of our GUI using <code class="Code-In-Text--PACKT-">grid()</code>, beginning with the <code class="Code-In-Text--PACKT-">title</code> label:</p>
    <pre class="programlisting code"><code class="hljs-code">title.grid()
</code></pre>
    <p class="normal">By default, a call to <code class="Code-In-Text--PACKT-">grid()</code> will place the widget in the <em class="italic">first column</em> (column 0) of the <em class="italic">next empty row</em>. Thus, if we were to simply call <code class="Code-In-Text--PACKT-">grid()</code> on the next widget, it would end up directly under the first. However, we can also be explicit about this using the <code class="Code-In-Text--PACKT-">row</code> and <code class="Code-In-Text--PACKT-">column</code> arguments, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">name_label.grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>)
</code></pre>
    <p class="normal">Rows and columns count from the top-left corner of the widget, starting with <code class="Code-In-Text--PACKT-">0</code>. Thus, <code class="Code-In-Text--PACKT-">row=1, column=0</code> places the widget in the second row at the first column. If we want an additional column, all we need to do is place a widget in it, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">name_inp.grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>)
</code></pre>
    <p class="normal">The grid automatically expands whenever we add a widget to a new row or column. If a widget is larger than the current width of the column, or height of the row, all the cells in that <a id="_idIndexMarker069"/>column or row are expanded to<a id="_idIndexMarker070"/> accommodate it. We can tell a widget to span multiple columns or multiple rows using the <code class="Code-In-Text--PACKT-">columnspan</code> and <code class="Code-In-Text--PACKT-">rowspan</code> arguments, respectively. For example, it might be nice to have our title span the width of the form, so let's amend it accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code">title.grid(columnspan=<span class="hljs-number">2</span>)
</code></pre>
    <p class="normal">As columns and rows expand, the widgets do not expand with them by default. If we want them to expand, we need to use the <code class="Code-In-Text--PACKT-">sticky</code> argument, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">eater_inp.grid(row=<span class="hljs-number">2</span>, columnspan=<span class="hljs-number">2</span>, sticky=<span class="hljs-string">'we'</span>)
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">sticky</code> tells Tkinter to stick the sides of the widget to the sides of its containing cell so that the widget will stretch as the cell expands. Like the <code class="Code-In-Text--PACKT-">anchor</code> argument we learned about above, <code class="Code-In-Text--PACKT-">sticky</code> takes cardinal directions: <code class="Code-In-Text--PACKT-">n</code>, <code class="Code-In-Text--PACKT-">s</code>, <code class="Code-In-Text--PACKT-">e</code>, and <code class="Code-In-Text--PACKT-">w</code>. In this case we've specified West and East, which will cause the widget to stretch horizontally if the column expands further.</p>
    <p class="normal">As an alternative to the strings, we can also use Tkinter's constants as arguments to <code class="Code-In-Text--PACKT-">sticky</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">num_label.grid(row=<span class="hljs-number">3</span>, sticky=tk.W)
num_inp.grid(row=<span class="hljs-number">3</span>, column=<span class="hljs-number">1</span>, sticky=(tk.W + tk.E))
</code></pre>
    <p class="normal">There is no real difference between using constants and string literals as far as Tkinter is concerned; however, the advantage of using constants is that your editing software can more easily identify if you've used a constant that doesn't exist than an invalid string.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">grid()</code> method allows us to add padding to our widgets as well, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">color_label.grid(row=<span class="hljs-number">4</span>, columnspan=<span class="hljs-number">2</span>, sticky=tk.W, pady=<span class="hljs-number">10</span>)
color_inp.grid(row=<span class="hljs-number">5</span>, columnspan=<span class="hljs-number">2</span>, sticky=tk.W + tk.E, padx=<span class="hljs-number">25</span>)
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">padx</code> and <code class="Code-In-Text--PACKT-">pady</code> indicate <em class="italic">external</em> padding – that is, they will expand the containing cell, but not the widget. <code class="Code-In-Text--PACKT-">ipadx</code> and <code class="Code-In-Text--PACKT-">ipady</code>, on the other hand, indicate <em class="italic">internal</em> padding. Specifying these arguments will expand the widget itself (and consequently the containing cell).</p>
    <figure class="mediaobject"><img src="../Images/B17578_01_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.5: Internal padding (ipadx, ipady) versus external padding (padx, pady)</p>
    <p class="normal">Tkinter <a id="_idIndexMarker071"/>does not allow us to mix geometry managers on the same parent widget; once we've called <code class="Code-In-Text--PACKT-">grid()</code> on any child widget, a call to the <code class="Code-In-Text--PACKT-">pack()</code> or <code class="Code-In-Text--PACKT-">place()</code> method on a sibling widget will generate an error, and <a id="_idIndexMarker072"/>vice versa. </p>
    <p class="normal">We can, however, use a different geometry manager on the sibling widget's children. For example, we can use <code class="Code-In-Text--PACKT-">pack()</code> to place the child widgets on the <code class="Code-In-Text--PACKT-">plantain_frame</code> widgets, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">plantain_yes_inp.pack(side=<span class="hljs-string">'left'</span>, fill=<span class="hljs-string">'x'</span>, ipadx=<span class="hljs-number">10</span>, ipady=<span class="hljs-number">5</span>)
plantain_no_inp.pack(side=<span class="hljs-string">'left'</span>, fill=<span class="hljs-string">'x'</span>, ipadx=<span class="hljs-number">10</span>, ipady=<span class="hljs-number">5</span>)
plantain_label.grid(row=<span class="hljs-number">6</span>, columnspan=<span class="hljs-number">2</span>, sticky=tk.W)
plantain_frame.grid(row=<span class="hljs-number">7</span>, columnspan=<span class="hljs-number">2</span>, stick=tk.W)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">plantain_label</code> and <code class="Code-In-Text--PACKT-">plantain_frame</code> widgets, as children of <code class="Code-In-Text--PACKT-">root</code>, must be placed with <code class="Code-In-Text--PACKT-">grid()</code>; <code class="Code-In-Text--PACKT-">plantain_yes</code> and <code class="Code-In-Text--PACKT-">plantain_no</code> are children of <code class="Code-In-Text--PACKT-">plantain_frame</code>, though, so we can choose to use <code class="Code-In-Text--PACKT-">pack()</code> (or <code class="Code-In-Text--PACKT-">place()</code>) on them if we wish. The following diagram illustrates this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_01_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.6: Each widget's children must use the same geometry manager method</p>
    <p class="normal">This <a id="_idIndexMarker073"/>ability to choose the geometry manager for each container widget gives us enormous flexibility in how we lay out a GUI. While the <code class="Code-In-Text--PACKT-">grid()</code> method is certainly capable of specifying most layouts, there are times <a id="_idIndexMarker074"/>when the semantics of <code class="Code-In-Text--PACKT-">pack()</code> or <code class="Code-In-Text--PACKT-">place()</code> make more sense for a piece of our interface.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Although the <code class="Code-In-Text--PACKT-">pack()</code> geometry manager shares some arguments with <code class="Code-In-Text--PACKT-">grid()</code>, like <code class="Code-In-Text--PACKT-">padx</code> and <code class="Code-In-Text--PACKT-">pady</code>, most of the arguments are different. For example, the <code class="Code-In-Text--PACKT-">side</code> argument used in the example determines which side widgets will be packed from, and the <code class="Code-In-Text--PACKT-">fill</code> argument determines on which axis the widget will expand.</p>
    </div>
    <p class="normal">Let's add the last few widgets to our window:</p>
    <pre class="programlisting code"><code class="hljs-code">banana_haiku_label.grid(row=<span class="hljs-number">8</span>, sticky=tk.W)
banana_haiku_inp.grid(row=<span class="hljs-number">9</span>, columnspan=<span class="hljs-number">2</span>, sticky=<span class="hljs-string">'NSEW'</span>)
submit_btn.grid(row=<span class="hljs-number">99</span>)
output_line.grid(row=<span class="hljs-number">100</span>, columnspan=<span class="hljs-number">2</span>, sticky=<span class="hljs-string">'NSEW'</span>)
</code></pre>
    <p class="normal">Note that we've stuck the <code class="Code-In-Text--PACKT-">Text</code> widget (<code class="Code-In-Text--PACKT-">banana_haiku_inp</code>) to all four sides of its container. This will cause it to expand both vertically and horizontally as the grid is stretched. Also notice that we've skipped to rows 99 and 100 for the last two widgets. Remember that unused rows are collapsed into nothing, so by skipping rows or columns we can leave space for future expansion of our GUI.</p>
    <p class="normal">By default, Tkinter<a id="_idIndexMarker075"/> will make our window just large enough to contain all the widgets we place on it; but what happens if our window (or containing frame) becomes larger than the space required by our widgets? By default, the widgets will remain as they are, stuck to the upper-left side of the application. If we want the GUI to expand and fill the space available, we have to tell the parent widget which columns and rows of the grid will expand. We do this by using the parent widget's <code class="Code-In-Text--PACKT-">columnconfigure()</code> and <code class="Code-In-Text--PACKT-">rowconfigure()</code> methods.</p>
    <p class="normal">For example, if we <a id="_idIndexMarker076"/>want our second column (the one containing most of the input widgets) to expand into unused space, we can do this:</p>
    <pre class="programlisting code"><code class="hljs-code">root.columnconfigure(<span class="hljs-number">1</span>, weight=<span class="hljs-number">1</span>)
</code></pre>
    <p class="normal">The first argument specifies which column (counting from 0) we want to affect. The keyword argument <code class="Code-In-Text--PACKT-">weight</code> takes an integer which will determine how much of the extra space the column will get. With only one column specified, any value greater than 0 will cause that column to expand into the leftover space.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">rowconfigure()</code> method works the same way:</p>
    <pre class="programlisting code"><code class="hljs-code">root.rowconfigure(<span class="hljs-number">99</span>, weight=<span class="hljs-number">2</span>)
root.rowconfigure(<span class="hljs-number">100</span>, weight=<span class="hljs-number">1</span>)
</code></pre>
    <p class="normal">This time, we've given two rows a <code class="Code-In-Text--PACKT-">weight</code> value, but note that row <code class="Code-In-Text--PACKT-">99</code> is given a weight of <code class="Code-In-Text--PACKT-">2</code> while <code class="Code-In-Text--PACKT-">100</code> is given a weight of <code class="Code-In-Text--PACKT-">1</code>. In this configuration, any extra vertical space will be divided between rows <code class="Code-In-Text--PACKT-">99</code> and <code class="Code-In-Text--PACKT-">100</code>, but row <code class="Code-In-Text--PACKT-">99</code> will get twice as much of it as row <code class="Code-In-Text--PACKT-">100</code>.</p>
    <p class="normal">As you can see, using a combination of <code class="Code-In-Text--PACKT-">grid()</code>, <code class="Code-In-Text--PACKT-">pack()</code> sub-frames, and some careful planning, we can achieve complex GUI layouts fairly easily in Tkinter.</p>
    <h2 id="_idParaDest-30" class="title">Making the form actually do something</h2>
    <p class="normal">We've got a nice <a id="_idIndexMarker077"/>form all laid out now, complete with a submit button; so how do we make it actually do something? If you have only written procedural code in the past, you may be confused about how the flow of code works in a GUI application. Unlike a procedural script, the GUI cannot simply execute all the code from top to bottom. Instead, it has to respond to user actions, such as a button click or a keystroke, whenever and in whatever order they happen. Such actions are known<a id="_idIndexMarker078"/> as <strong class="keyword">events</strong>. To make the program respond to an event, we need to <strong class="keyword">bind</strong> the event to a function, which we call<a id="_idIndexMarker079"/> a <strong class="keyword">callback</strong>.</p>
    <p class="normal">There are a few ways to bind events to callback functions in Tkinter; for a button, the simplest is to configure its <code class="Code-In-Text--PACKT-">command</code> attribute, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">submit_btn.configure(command=on_submit)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">command</code> argument<a id="_idIndexMarker080"/> can be specified when creating a widget (for example, <code class="Code-In-Text--PACKT-">submit_btn = Button(root, command=on_submit)</code>), or after creation of the widget using its <code class="Code-In-Text--PACKT-">configure()</code> method. <code class="Code-In-Text--PACKT-">configure()</code> allows you to change a widget's configuration after it's created, by passing in arguments just as you would when creating the widget.</p>
    <p class="normal">In either case, <code class="Code-In-Text--PACKT-">command</code> specifies a <em class="italic">reference</em> to a callback function to be called when the button is clicked. Note that we do not put parentheses after the function name here; doing so would cause the function to be called and its return value would be assigned to <code class="Code-In-Text--PACKT-">command</code>. We only want a reference to the function here.</p>
    <p class="normal">The callback function needs to exist before we can pass it to <code class="Code-In-Text--PACKT-">command</code>. So, before the call to <code class="Code-In-Text--PACKT-">submit_btn.configure()</code>, let's create the <code class="Code-In-Text--PACKT-">on_submit()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">on_submit</span><span class="hljs-function">():</span>
  <span class="hljs-string">"""To be run when the user submits the form"""</span>
  <span class="hljs-keyword">pass</span>
submit_btn.configure(command=on_submit)
</code></pre>
    <p class="normal">It is conventional to name callback functions in the format <code class="Code-In-Text--PACKT-">on_&lt;event_name&gt;</code> when they are specifically created to respond to a particular event. However, it's not required, nor always appropriate (for example, if a function is a callback for many events).</p>
    <p class="normal">A more powerful method of binding events is to use the widget's <code class="Code-In-Text--PACKT-">bind()</code> method, which we will discuss in more detail in <em class="chapterRef">Chapter 6</em>, <em class="italic">Planning for the Expansion of Our Application</em>.</p>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">on_submit()</code> callback is rather boring at the moment, so let's make it better. Remove the <code class="Code-In-Text--PACKT-">pass</code> statement and add in this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">on_submit</span><span class="hljs-function">():</span>
  <span class="hljs-string">"""To be run when the user submits the form"""</span>
  name = name_inp.get()
  number = num_inp.get()
  selected_idx = color_inp.curselection()
  <span class="hljs-keyword">if</span> selected_idx:
    color = color_inp.get(selected_idx)
  <span class="hljs-keyword">else</span>:
    color = <span class="hljs-string">''</span>
  haiku = banana_haiku_inp.get(<span class="hljs-string">'1.0'</span>, tk.END)
  message = (
    <span class="hljs-string">f'Thanks for taking the survey, </span><span class="hljs-subst">{name}</span><span class="hljs-string">.\n'</span>
    <span class="hljs-string">f'Enjoy your </span><span class="hljs-subst">{number}</span><span class="hljs-string"> </span><span class="hljs-subst">{color}</span><span class="hljs-string"> bananas!'</span>
  )
  output_line.configure(text=message)
  <span class="hljs-built_in">print</span>(haiku)
</code></pre>
    <p class="normal">The first <a id="_idIndexMarker081"/>thing we'll do in this function is retrieve values from some of the inputs. For many inputs, the <code class="Code-In-Text--PACKT-">get()</code> method is used to retrieve the current value of the widget. Note that this value will be returned as a string, even in the case of our <code class="Code-In-Text--PACKT-">Spinbox</code>.</p>
    <p class="normal">For our list widget, <code class="Code-In-Text--PACKT-">color</code>, things are more complicated. Its <code class="Code-In-Text--PACKT-">get()</code> method requires an index number for a choice, and returns the text for that index number. We can use the widget's <code class="Code-In-Text--PACKT-">curselection()</code> method to get the selected index. If there are no selections made, the selected index will be an empty tuple. In that case, we'll just set <code class="Code-In-Text--PACKT-">color</code> to an empty string. If there is a selection, we can pass the value to <code class="Code-In-Text--PACKT-">get()</code>.</p>
    <p class="normal">Getting data from the <code class="Code-In-Text--PACKT-">Text</code> widget is again slightly different. Its <code class="Code-In-Text--PACKT-">get()</code> method requires two values, one for a starting location and another for an ending location. These follow a special syntax (which we'll discuss in <em class="chapterRef">Chapter 3</em>, <em class="italic">Creating Basic Forms with Tkinter and Ttk Widgets</em>), but basically <code class="Code-In-Text--PACKT-">1.0</code> means the first character of the first line, and <code class="Code-In-Text--PACKT-">tk.END</code> is a constant that represents the end of the <code class="Code-In-Text--PACKT-">Text</code> widget.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Retrieving data from our <code class="Code-In-Text--PACKT-">Checkbutton</code> and <code class="Code-In-Text--PACKT-">Radiobutton</code> is not possible without using Tkinter control variables, which we'll talk about in the section below, <em class="italic">Handling data with Tkinter control variables</em>.</p>
    </div>
    <p class="normal">Having gathered the data, our callback ends by updating the <code class="Code-In-Text--PACKT-">text</code> property of the output <code class="Code-In-Text--PACKT-">Label</code> widget with a string containing some of the entered data, then printing the user's haiku to the console.</p>
    <p class="normal">To make this script runnable, finish with this line:</p>
    <pre class="programlisting code"><code class="hljs-code">root.mainloop()
</code></pre>
    <p class="normal">This executes the event loop of the script so that Tkinter can begin responding to events. Save your script and execute it, and you should see something like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_01_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.7: Our banana survey application</p>
    <p class="normal">Congratulations, your <a id="_idIndexMarker082"/>banana survey works! Well, kind of. Let's see if we can get it fully working.</p>
    <h2 id="_idParaDest-31" class="title">Handling data with Tkinter control variables</h2>
    <p class="normal">We've got<a id="_idIndexMarker083"/> the GUI layout well in hand, but our GUI has <a id="_idIndexMarker084"/>some problems. Retrieving data from our widgets is a bit of a mess, and we have no idea how to even get the values of the <code class="Code-In-Text--PACKT-">Checkbutton</code> or <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets yet. In fact, if you try to operate the <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets, you'll see they are broken altogether. It seems we're missing a big piece of the puzzle.</p>
    <p class="normal">What we're missing are<a id="_idIndexMarker085"/> Tkinter <strong class="keyword">control variables</strong>. Control variables are special Tkinter objects that allow us to store data; there are four types of control variables:</p>
    <ul>
      <li class="bullet"><strong class="keyword">StringVar</strong>: Used<a id="_idIndexMarker086"/> to store <a id="_idIndexMarker087"/>strings of any length</li>
      <li class="bullet"><strong class="keyword">IntVar</strong>: Used<a id="_idIndexMarker088"/> to store<a id="_idIndexMarker089"/> integers</li>
      <li class="bullet"><strong class="keyword">DoubleVar</strong>: Used<a id="_idIndexMarker090"/> to store<a id="_idIndexMarker091"/> floating-point values</li>
      <li class="bullet"><strong class="keyword">BooleanVar</strong>: Used <a id="_idIndexMarker092"/>to <a id="_idIndexMarker093"/>store Boolean (True/False) values</li>
    </ul>
    <p class="normal">But wait! Python <a id="_idIndexMarker094"/>already has variables that can store those types of data and much more. Why do we need these classes? Simply put, these variable classes have some special abilities that regular Python variables lack, for example:</p>
    <ul>
      <li class="bullet">We can create a <a id="_idIndexMarker095"/><strong class="keyword">two-way binding</strong> between a control variable and a widget, so that if either the widget contents are changed or the variable contents are changed, both will be kept in sync.</li>
      <li class="bullet">We can set <a id="_idIndexMarker096"/>up a <strong class="keyword">trace</strong> on the variable. A trace binds a variable event (such as reading or updating the variable) to a callback function. (Traces will be discussed in <em class="chapterRef">Chapter 4</em>, <em class="italic">Organizing Our Code with Classes</em>.)</li>
      <li class="bullet">We can establish relationships between widgets. For example, we can tell our two <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets that they're connected.</li>
    </ul>
    <p class="normal">Let's look at how control variables can help our survey application. Go back up to the top where the name input is defined and let's add a variable:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">name_var = tk.StringVar(root)</strong></span>
name_label = tk.Label(root, text=<span class="hljs-string">'What is your name?'</span>)
name_inp = tk.Entry(root, <span class="code-highlight"><strong class="hljs-slc">textvariable=name_var</strong></span>)
</code></pre>
    <p class="normal">We can create a <code class="Code-In-Text--PACKT-">StringVar</code> object by calling <code class="Code-In-Text--PACKT-">StringVar()</code>; note that we've passed in the <code class="Code-In-Text--PACKT-">root</code> window as the first argument. Control variables require a reference to a <code class="Code-In-Text--PACKT-">root</code> window; however, in almost every case, they can work this out for themselves automatically, so it's rarely necessary to actually specify the <code class="Code-In-Text--PACKT-">root</code> window here. It's important to understand, though, that <em class="italic">no control variable objects</em><em class="italic"> can be created until a Tk object exists</em>.</p>
    <p class="normal">Once we have a <code class="Code-In-Text--PACKT-">StringVar</code> object, we can bind it to our <code class="Code-In-Text--PACKT-">Entry</code> widget by passing it to the <code class="Code-In-Text--PACKT-">textvariable</code> argument. By doing this, the contents of the <code class="Code-In-Text--PACKT-">name_inp</code> widget and the <code class="Code-In-Text--PACKT-">name_var</code> variable are kept in sync. A call to the variable's <code class="Code-In-Text--PACKT-">get()</code> method will return the current contents of the box, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(name_var.get())
</code></pre>
    <p class="normal">For a checkbox, a <code class="Code-In-Text--PACKT-">BooleanVar</code> is used:</p>
    <pre class="programlisting code"><code class="hljs-code">eater_var = tk.BooleanVar()
eater_inp = tk.Checkbutton(
  root, variable=eater_var, text=<span class="hljs-string">'Check this box if you eat bananas'</span>
)
</code></pre>
    <p class="normal">This <a id="_idIndexMarker097"/>time, we've passed the variable to the <code class="Code-In-Text--PACKT-">Checkbutton</code> using the <code class="Code-In-Text--PACKT-">variable</code> argument. Button widgets will use the keyword <code class="Code-In-Text--PACKT-">variable</code> to bind a <a id="_idIndexMarker098"/>control variable, while widgets that you type into or that return string values typically use the keyword <code class="Code-In-Text--PACKT-">textvariable</code>.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Button widgets do take a <code class="Code-In-Text--PACKT-">textvariable</code> argument as well, but it does not bind the value of the button; rather it binds to the text of the button's label. This feature allows you to dynamically update a button's text. </p>
    </div>
    <p class="normal">Variables can be initialized with a default value using the <code class="Code-In-Text--PACKT-">value</code> argument, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">num_var = tk.IntVar(value=<span class="hljs-number">3</span>)
num_label = tk.Label(text=<span class="hljs-string">'How many bananas do you eat per day?'</span>)
num_inp = tk.Spinbox(
  root, textvariable=num_var, from_=<span class="hljs-number">0</span>, to=<span class="hljs-number">1000</span>, increment=<span class="hljs-number">1</span>
)
</code></pre>
    <p class="normal">Here, we've created an integer variable using <code class="Code-In-Text--PACKT-">IntVar()</code> and set its value to <code class="Code-In-Text--PACKT-">3</code>; when we launch the form, the <code class="Code-In-Text--PACKT-">num_inp</code> widget will be set to <code class="Code-In-Text--PACKT-">3</code>. Notice that, even though we think of the <code class="Code-In-Text--PACKT-">Spinbox</code> as a number entry, it uses the <code class="Code-In-Text--PACKT-">textvariable</code> argument to bind its control variable. A <code class="Code-In-Text--PACKT-">Spinbox</code> widget can actually be used for more than just numbers, and as such its data is internally stored as text. However, by binding an <code class="Code-In-Text--PACKT-">IntVar</code> or <code class="Code-In-Text--PACKT-">DoubleVar</code> to it, the value retrieved will automatically be converted into an integer or float.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The automatic conversion to integer or float done by <code class="Code-In-Text--PACKT-">IntVar</code> and <code class="Code-In-Text--PACKT-">DoubleVar</code> can be a problem if users are able to type letters, symbols, or other invalid characters into an entry. Calling <code class="Code-In-Text--PACKT-">get()</code> on an integer or double variable bound to a widget containing an invalid number string (for example, <code class="Code-In-Text--PACKT-">'1.1.2'</code> or <code class="Code-In-Text--PACKT-">'I like plantains'</code>) will raise an exception, causing our application to crash. In <em class="chapterRef">Chapter 5</em>, <em class="italic">Reducing User Error with Validation and Automation</em>, we'll learn how to address this problem.</p>
    </div>
    <p class="normal">Previously, we'd used <code class="Code-In-Text--PACKT-">Listbox</code> to display a list of options to the user. Unfortunately, <code class="Code-In-Text--PACKT-">Listbox</code> doesn't work well with control variables, but there is another widget, <code class="Code-In-Text--PACKT-">OptionMenu</code>, that does.</p>
    <p class="normal">Let's replace our <code class="Code-In-Text--PACKT-">color_inp</code> with an <code class="Code-In-Text--PACKT-">OptionMenu</code> widget:</p>
    <pre class="programlisting code"><code class="hljs-code">color_var = tk.StringVar(value=<span class="hljs-string">'Any'</span>)
color_label = tk.Label(
  root, 
  text=<span class="hljs-string">'What is the best color for a banana?'</span>
)
color_choices = (
  <span class="hljs-string">'Any'</span>, <span class="hljs-string">'Green'</span>, <span class="hljs-string">'Green Yellow'</span>, <span class="hljs-string">'Yellow'</span>, <span class="hljs-string">'Brown Spotted'</span>, <span class="hljs-string">'Black'</span>
)
<span class="code-highlight"><strong class="hljs-slc">color_inp = tk.OptionMenu(</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  root, color_var, *color_choices</strong></span>
<span class="code-highlight"><strong class="hljs-slc">)</strong></span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">OptionMenu</code> holds <a id="_idIndexMarker099"/>a list of options as strings, so we need to create a <code class="Code-In-Text--PACKT-">StringVar</code> to bind to it. Note that, unlike the <code class="Code-In-Text--PACKT-">ListBox</code> widget, the <code class="Code-In-Text--PACKT-">OptionMenu</code> allows us to specify the options as <a id="_idIndexMarker100"/>we create it. The <code class="Code-In-Text--PACKT-">OptionMenu</code> constructor is also a bit different from other Tkinter widget constructors in that it takes the control variable and options as positional arguments, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Example, don't add this to the program</span>
menu = tk.OptionMenu(parent, ctrl_var, opt1, opt2, ..., optN)
</code></pre>
    <p class="normal">In our survey code, we've added the options by using the unpack operator (<code class="Code-In-Text--PACKT-">*</code>) to expand our <code class="Code-In-Text--PACKT-">color_choices</code> list into positional arguments. We could also have just listed them explicitly, but doing it this way keeps our code a little neater.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">We're going to learn about a better option for a drop-down list box when we discuss the Ttk widget set in <em class="chapterRef">Chapter 3</em>, <em class="italic">Creating Basic Forms with Tkinter and Ttk Widgets</em>.</p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Radiobutton</code> widget handles variables slightly differently from other widgets as well. To use <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets effectively, we bind all the buttons that are grouped together to the same control variable, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">plantain_var = tk.BooleanVar()
plantain_yes_inp = tk.Radiobutton(
  plantain_frame, text=<span class="hljs-string">'Yes'</span>, value=<span class="hljs-literal">True</span>, variable=plantain_var
)
plantain_no_inp = tk.Radiobutton(
  plantain_frame, 
  text=<span class="hljs-string">'Ewww, no!'</span>, 
  value=<span class="hljs-literal">False</span>, 
  variable=plantain_var
)
</code></pre>
    <p class="normal">We can bind any <a id="_idIndexMarker101"/>kind of control variable to a <code class="Code-In-Text--PACKT-">Radiobutton</code> widget, but we have to make sure to give each widget a <code class="Code-In-Text--PACKT-">value</code> that matches the variable type. In this case, we're using the buttons for a <code class="Code-In-Text--PACKT-">True</code>/<code class="Code-In-Text--PACKT-">False</code> question, so <code class="Code-In-Text--PACKT-">BooleanVar</code> is appropriate; we use the <code class="Code-In-Text--PACKT-">value</code> argument to set one button to <code class="Code-In-Text--PACKT-">True</code> and the other to <code class="Code-In-Text--PACKT-">False</code>. When we call the variable's <code class="Code-In-Text--PACKT-">get()</code> method, it will return the <code class="Code-In-Text--PACKT-">value</code> argument of the selected button.</p>
    <p class="normal">Unfortunately, not <a id="_idIndexMarker102"/>all Tkinter widgets work with control variables. Notably, our <code class="Code-In-Text--PACKT-">Text</code> widget used for the <code class="Code-In-Text--PACKT-">banana_haiku_inp</code> input cannot be bound to a variable, and (unlike <code class="Code-In-Text--PACKT-">Listbox</code>) there is no alternative available. For the time being, we'll have to handle the <code class="Code-In-Text--PACKT-">Text</code> entry widget as we have already done.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The Tkinter <code class="Code-In-Text--PACKT-">Text</code> box does not support variables because it is much more than just multi-line text; it can contain images, rich text, and other objects that can't be represented in a simple string. However, in <em class="chapterRef">Chapter 4</em>, <em class="italic">Organizing Our Code with Classes</em>, we'll implement a workaround for this that will allow us to bind a variable to a multi-line string widget.</p>
    </div>
    <p class="normal">Control variables are not just for binding to input widgets; we can also use them to update strings in non-interactive widgets like <code class="Code-In-Text--PACKT-">Label</code>. For example:</p>
    <pre class="programlisting code"><code class="hljs-code">output_var = tk.StringVar(value=<span class="hljs-string">''</span>)
output_line = tk.Label(
  root, textvariable=output_var, anchor=<span class="hljs-string">'w'</span>, justify=<span class="hljs-string">'left'</span>
)
</code></pre>
    <p class="normal">With the <code class="Code-In-Text--PACKT-">output_var</code> control variable bound to the <code class="Code-In-Text--PACKT-">textvariable</code> argument of this <code class="Code-In-Text--PACKT-">Label</code> widget, we can alter the text displayed by the label at runtime by updating <code class="Code-In-Text--PACKT-">output_var</code>.</p>
    <h3 id="_idParaDest-32" class="title">Using control variables in a callback function</h3>
    <p class="normal">Now that we've <a id="_idIndexMarker103"/>created all these variables and bound them to our widgets, what can we do with them? Skip down to the callback function, <code class="Code-In-Text--PACKT-">on_submit()</code>, and delete the code that is in it. We will re-write it using our control variables.</p>
    <p class="normal">Start with the <code class="Code-In-Text--PACKT-">name</code> value:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">on_submit</span><span class="hljs-function">():</span>
  <span class="hljs-string">"""To be run when the user submits the form"""</span>
  name = name_var.get()
</code></pre>
    <p class="normal">As mentioned earlier, the <code class="Code-In-Text--PACKT-">get()</code> method is used to retrieve a variable's value. The data type returned by <code class="Code-In-Text--PACKT-">get()</code> depends on the type of variable, as follows:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">StringVar</code> returns a <code class="Code-In-Text--PACKT-">str</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">IntVar</code> returns an <code class="Code-In-Text--PACKT-">int</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">DoubleVar</code> returns a <code class="Code-In-Text--PACKT-">float</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">BooleanVar</code> returns a <code class="Code-In-Text--PACKT-">bool</code></li>
    </ul>
    <p class="normal">Note that type conversion is performed whenever <code class="Code-In-Text--PACKT-">get()</code> is called, so any incompatibility between what the widget contains and what the variable expects will raise an exception at this time. For example, if an <code class="Code-In-Text--PACKT-">IntVar</code> is bound to an empty <code class="Code-In-Text--PACKT-">Spinbox</code>, <code class="Code-In-Text--PACKT-">get()</code> will raise an exception because an empty string cannot be cast to <code class="Code-In-Text--PACKT-">int</code>.</p>
    <p class="normal">For that reason, it is sometimes wise to put <code class="Code-In-Text--PACKT-">get()</code> in a <code class="Code-In-Text--PACKT-">try/except</code> block, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">try</span>:
    number = num_var.get()
  <span class="hljs-keyword">except</span> tk.TclError:
    number = <span class="hljs-number">10000</span>
</code></pre>
    <p class="normal">Contrary to what an experienced Python programmer might expect, the exception raised for an invalid value is <em class="italic">not</em> <code class="Code-In-Text--PACKT-">ValueError</code>. The conversion is actually done in Tcl/Tk, not in Python, so the exception raised is a <code class="Code-In-Text--PACKT-">tkinter.TclError</code>. Here, we've caught the <code class="Code-In-Text--PACKT-">TclError</code> and handled it by setting the number of bananas to <code class="Code-In-Text--PACKT-">10,000</code>.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-"><code class="Code-In-Text--PACKT-">TclError</code> exceptions are raised <em class="italic">any time</em> Tcl/Tk has difficulty executing our translated Python calls, so to properly handle them you may need to extract the actual error string from the exception. This is a bit ugly and un-Pythonic, but Tkinter doesn't leave us much choice.</p>
    </div>
    <p class="normal">Extracting the <a id="_idIndexMarker104"/>value of our <code class="Code-In-Text--PACKT-">OptionMenu</code>, <code class="Code-In-Text--PACKT-">Checkbutton</code>, and <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets is much cleaner now, as you can see here:</p>
    <pre class="programlisting code"><code class="hljs-code">  color = color_var.get()
  banana_eater = eater_var.get()
  plantain_eater = plantain_var.get()
</code></pre>
    <p class="normal">For the <code class="Code-In-Text--PACKT-">OptionMenu</code>, <code class="Code-In-Text--PACKT-">get()</code> returns the selected string. For <code class="Code-In-Text--PACKT-">Checkbutton</code>, it returns <code class="Code-In-Text--PACKT-">True</code> if the button is checked, or <code class="Code-In-Text--PACKT-">False</code> if it is not. For the <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets, <code class="Code-In-Text--PACKT-">get()</code> returns the <code class="Code-In-Text--PACKT-">value</code> of the selected widget. The nice thing about control variables is that we don't have to know or care what kind of widget they were bound to; simply calling <code class="Code-In-Text--PACKT-">get()</code> is sufficient to retrieve the user's input.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Text</code> widget, as mentioned before, doesn't support control variables, so we have to get its content the old-fashioned way:</p>
    <pre class="programlisting code"><code class="hljs-code">  haiku = banana_haiku_inp.get(<span class="hljs-string">'1.0'</span>, tk.END)
</code></pre>
    <p class="normal">Now that we have all that data, let's build a message string for the survey taker:</p>
    <pre class="programlisting code"><code class="hljs-code">    message = <span class="hljs-string">f'Thanks for taking the survey, </span><span class="hljs-subst">{name}</span><span class="hljs-string">.\n'</span>
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> banana_eater:
    message += <span class="hljs-string">"Sorry you don't like bananas!\n"</span>
  <span class="hljs-keyword">else</span>:
    message += <span class="hljs-string">f'Enjoy your </span><span class="hljs-subst">{number}</span><span class="hljs-string"> </span><span class="hljs-subst">{color}</span><span class="hljs-string"> bananas!\n'</span>
  <span class="hljs-keyword">if</span> plantain_eater:
    message += <span class="hljs-string">'Enjoy your plantains!'</span>
  <span class="hljs-keyword">else</span>:
    message += <span class="hljs-string">'May you successfully avoid plantains!'</span>
  <span class="hljs-keyword">if</span> haiku.strip():
    message += <span class="hljs-string">f'\n\nYour Haiku:\n</span><span class="hljs-subst">{haiku}</span><span class="hljs-string">'</span>
</code></pre>
    <p class="normal">To display our message for the user, we need to update the <code class="Code-In-Text--PACKT-">output_var</code> variable. This is done using its <code class="Code-In-Text--PACKT-">set()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  output_var.<span class="hljs-built_in">set</span>(message)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">set()</code> method will update the control variable, which in turn will update the <code class="Code-In-Text--PACKT-">Label</code> widget to which it is <a id="_idIndexMarker105"/>bound. This way, we can dynamically update displayed messages, widget labels, and other text in our application.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Remember to use <code class="Code-In-Text--PACKT-">set()</code> to change a control variable's value! Using the assignment operator (<code class="Code-In-Text--PACKT-">=</code>) will just overwrite the control variable object with a different object and you won't be able to work with it anymore. For example, <code class="Code-In-Text--PACKT-">output_var = message</code> would just reassign the name <code class="Code-In-Text--PACKT-">output_var</code> to the string object <code class="Code-In-Text--PACKT-">message</code>, and the control variable object currently bound to <code class="Code-In-Text--PACKT-">output_line</code> would become nameless.</p>
    </div>
    <h3 id="_idParaDest-33" class="title">The importance of control variables</h3>
    <p class="normal">Hopefully, you <a id="_idIndexMarker106"/>see that control variables are a powerful and essential part of a Tkinter GUI. We will use them extensively in our applications to store and communicate data between Tkinter objects. In fact, once we've bound a variable to a widget, it's often unnecessary to keep a reference to our widget. For example, our survey code would work just fine if we defined the output section like this:</p>
    <pre class="programlisting code"><code class="hljs-code">output_var = tk.StringVar(value=<span class="hljs-string">''</span>)
<span class="hljs-comment"># remove the call to output_line.grid() in the layout section!</span>
tk.Label(
  root, textvariable=output_var, anchor=<span class="hljs-string">'w'</span>, justify=<span class="hljs-string">'left'</span>
).grid(row=<span class="hljs-number">100</span>, columnspan=<span class="hljs-number">2</span>, sticky=<span class="hljs-string">"NSEW"</span>)
</code></pre>
    <p class="normal">Since we don't need to interact directly with the output <code class="Code-In-Text--PACKT-">Label</code>, we can just create it and place it all in one line, without bothering to save a reference. Since the widget's parent retains a reference to the object, Python won't destroy the object, and we can retrieve its contents at any time using the control variable. Of course, if we later want to manipulate the widget in some way (changing its <code class="Code-In-Text--PACKT-">font</code> value, for example), we'll need to keep a reference to it.</p>
    <h1 id="_idParaDest-34" class="title">Summary</h1>
    <p class="normal">In this chapter, you learned how to install Tkinter and IDLE, and you've gotten a taste of how easy it is to start building a GUI with Tkinter. You learned how to create widgets, how to arrange them in the main window with the <code class="Code-In-Text--PACKT-">grid()</code> geometry manager, and how to bind their contents to control variables like <code class="Code-In-Text--PACKT-">StringVar</code> and <code class="Code-In-Text--PACKT-">BooleanVar</code>. You also learned how to bind events like button clicks to callback functions, and how to retrieve and process widget data.</p>
    <p class="normal">In the next chapter, you'll start your new job at ABQ AgriLabs and be presented with a problem that will require your GUI programming skills. You will learn how to dissect this problem, develop a program specification, and design a user-friendly application that will be part of the solution.</p>
  </div>
</body></html>