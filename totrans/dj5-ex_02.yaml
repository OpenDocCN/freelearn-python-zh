- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Your Blog and Adding Social Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we learned the main components of Django by developing
    a simple blog application using views, templates, and URLs. In this chapter, we
    will extend the functionalities of the blog application with features that can
    be found in many blogging platforms nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using canonical URLs for models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating SEO-friendly URLs for posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding pagination to the post list view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building class-based views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending emails with Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Django forms to share posts via email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding comments to posts using forms from models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 2.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Diagram of functionalities built in Chapter 2'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add pagination to the post list page to navigate through
    all posts. We will also learn how to build class-based views with Django and convert
    the `post_list` view to a class-based view named `PostListView`.
  prefs: []
  type: TYPE_NORMAL
- en: We will create the `post_share` view to share posts via email. We will use Django
    forms to share posts and send email recommendations via **Simple Mail Transfer
    Protocol** (**SMTP**). To add comments to posts, we will create a `Comment` model
    to store comments, and we will build the `post_comment` view using forms for models.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: All Python packages used in this chapter are included in the `requirements.txt`
    file in the source code for the chapter. You can follow the instructions to install
    each Python package in the following sections, or you can install all the requirements
    at once with the `python -m pip install -r requirements.txt` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using canonical URLs for models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A website might have different pages that display the same content. In our application,
    the initial part of the content for each post is displayed both on the post list
    page and the post detail page. A canonical URL is the preferred URL for a resource.
    You can think of it as the URL of the most representative page for specific content.
    There might be different pages on your site that display posts, but there is a
    single URL that you use as the main URL for a post.
  prefs: []
  type: TYPE_NORMAL
- en: Canonical URLs allow you to specify the URL for the master copy of a page. Django
    allows you to implement the `get_absolute_url()` method in your models to return
    the canonical URL for the object.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `post_detail` URL defined in the URL patterns of the application
    to build the canonical URL for `Post` objects. Django provides different URL resolver
    functions that allow you to build URLs dynamically using their name and any required
    parameters. We will use the `reverse()` utility function of the `django.urls`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `blog` application to import the `reverse()`
    function and add the `get_absolute_url()` method to the `Post` model as follows.
    The new code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `reverse()` function will build the URL dynamically using the URL name defined
    in the URL patterns. We have used the `blog` namespace followed by a colon and
    the `post_detail` URL name. Remember that the `blog` namespace is defined in the
    main `urls.py` file of the project when including the URL patterns from `blog.urls`.
    The `post_detail` URL is defined in the `urls.py` file of the `blog` application.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting string, `blog:post_detail`, can be used globally in your project
    to refer to the post detail URL. This URL has a required parameter, which is the
    `id` of the blog post to retrieve. We have included the `id` of the `Post` object
    as a positional argument by using `args=[self.id]`.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the URL’s utility functions at [https://docs.djangoproject.com/en/5.0/ref/urlresolvers/](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s replace the post detail URLs in the templates with the new `get_absolute_url()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/list.html` file and replace the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding line with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `blog/post/list.html` file should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the shell prompt and execute the following command to start the development
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://127.0.0.1:8000/blog/` in your browser. Links to individual blog
    posts should still work. Django now builds the post URLs using the `get_absolute_url()`
    method of the `Post` model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating SEO-friendly URLs for posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The canonical URL for a blog post detail view currently looks like `/blog/1/`.
    We will change the URL pattern to create SEO-friendly URLs for posts. We will
    be using both the `publish` date and `slug` values to build the URLs for single
    posts. By combining dates, we will make a post detail URL to look like `/blog/2024/1/1/who-was-django-reinhardt/`.
    We will provide search engines with friendly URLs to index, containing both the
    title and date of the post.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve single posts with the combination of publication date and slug,
    we need to ensure that no post can be stored in the database with the same `slug`
    and `publish` date as an existing post. We will prevent the `Post` model from
    storing duplicated posts by defining slugs to be unique for the publication date
    of the post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file and add the following `unique_for_date` parameter
    to the `slug` field of the `Post` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By using `unique_for_date`, the `slug` field is now required to be unique for
    the date stored in the `publish` field. Note that the `publish` field is an instance
    of `DateTimeField`, but the check for unique values will be done only against
    the date (not the time). Django will prevent you from saving a new post with the
    same slug as an existing post for a given publication date. We have now ensured
    that slugs are unique for the publication date, so we can now retrieve single
    posts by the `publish` and `slug` fields.
  prefs: []
  type: TYPE_NORMAL
- en: We have changed our models, so, let’s create migrations. Note that `unique_for_date`
    is not enforced at the database level, so no database migration is required. However,
    Django uses migrations to keep track of all model changes. We will create a migration
    just to keep migrations aligned with the current state of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the shell prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Django just created the `0002_alter_post_slug.py` file inside the `migrations`
    directory of the `blog` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command in the shell prompt to apply existing migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get an output that ends with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Django will consider that all migrations have been applied and the models are
    in sync. No action will be done in the database because `unique_for_date` is not
    enforced at the database level.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the URL patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s modify the URL patterns to use the publication date and slug for the post
    detail URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `blog` application and replace the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding line with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `urls.py` file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The URL pattern for the `post_detail` view takes the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`year`: This requires an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`month`: This requires an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`day`: This requires an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post`: This requires a slug (a string that contains only letters, numbers,
    underscores, or hyphens)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `int` path converter is used for the `year`, `month`, and `day` parameters,
    whereas the `slug` path converter is used for the `post` parameter. You learned
    about path converters in the previous chapter. You can see all path converters
    provided by Django at [https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters](https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters).
  prefs: []
  type: TYPE_NORMAL
- en: Our posts have now an SEO-friendly URL that is built with the date and slug
    of each post. Let’s modify the `post_detail` view accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will change the parameters of the `post_detail` view to match the new URL
    parameters and use them to retrieve the corresponding `Post` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file and edit the `post_detail` view like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have modified the `post_detail` view to take the `year`, `month`, `day`,
    and `post` arguments and retrieve a published post with the given slug and publication
    date. By adding `unique_for_date='publish'` to the `slug` field of the `Post`
    model, we ensured that there would be only one post with a slug for a given date.
    Thus, you can retrieve single posts using the date and slug.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the canonical URL for posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We also have to modify the parameters of the canonical URL for blog posts to
    match the new URL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `blog` application and edit the `get_absolute_url()`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the development server by typing the following command in the shell prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can return to your browser and click on one of the post titles to
    take a look at the detail view of the post. You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The page for the post’s detail view'
  prefs: []
  type: TYPE_NORMAL
- en: You have designed SEO-friendly URLs for the blog posts. The URL for a post now
    looks like `/blog/2024/1/1/who-was-django-reinhardt/`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have implemented SEO-friendly URLs, let’s focus on implementing
    navigation through posts using pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Adding pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start adding content to your blog, you can easily store tens or hundreds
    of posts in your database. Instead of displaying all the posts on a single page,
    you may want to split the list of posts across several pages and include navigation
    links to the different pages. This functionality is called pagination, and you
    can find it in almost every web application that displays long lists of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Google uses pagination to divide search results across multiple
    pages. *Figure 2.3* shows Google’s pagination links for search result pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon  Description automatically generated](img/B21088_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Google pagination links for search result pages'
  prefs: []
  type: TYPE_NORMAL
- en: Django has a built-in pagination class that allows you to manage paginated data
    easily. You can define the number of objects you want to be returned per page
    and you can retrieve the posts that correspond to the page requested by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Adding pagination to the post list view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will add pagination to the list of posts so that users can easily navigate
    through all posts published on the blog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application to import the Django `Paginator`
    class and modify the `post_list` view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s review the new code we have added to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: We instantiate the `Paginator` class with the number of objects to return per
    page. We will display three posts per page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We retrieve the `page` `GET` HTTP parameter and store it in the `page_number`
    variable. This parameter contains the requested page number. If the `page` parameter
    is not in the `GET` parameters of the request, we use the default value `1` to
    load the first page of results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We obtain the objects for the desired page by calling the `page()` method of
    `Paginator`. This method returns a `Page` object that we store in the `posts`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pass the `posts` object to the template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a pagination template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to create a page navigation for users to browse through the different
    pages. In this section, we will create a template to display the pagination links,
    and we’ll make it generic so that we can reuse the template for any object pagination
    on our website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `templates/` directory, create a new file and name it `pagination.html`.
    Add the following HTML code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is the generic pagination template. The template expects to have a `Page`
    object in the context to render the previous and next links and to display the
    current page and total pages of results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the `blog/post/list.html` template and include the `pagination.html`
    template at the bottom of the `{% content %}` block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `{% include %}` template tag loads the given template and renders it using
    the current template context. We use `with` to pass additional context variables
    to the template. The pagination template uses the `page` variable to render, while
    the `Page` object that we pass from our view to the template is called `posts`.
    We use `with page=posts` to pass the variable expected by the pagination template.
    You can follow this method to use the pagination template for any type of object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server by typing the following command in the shell prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://127.0.0.1:8000/admin/blog/post/` in your browser and use the administration
    site to create a total of four different posts. Make sure to set the status to
    **Published**for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open `http://127.0.0.1:8000/blog/` in your browser. You should see the
    first three posts in reverse chronological order, and then the navigation links
    at the bottom of the post list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: The post list page including pagination'
  prefs: []
  type: TYPE_NORMAL
- en: If you click on **Next**, you will see the last post. The URL for the second
    page contains the `?page=2` `GET` parameter. This parameter is used by the view
    to load the requested page of results using the paginator.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: The second page of results'
  prefs: []
  type: TYPE_NORMAL
- en: Great! The pagination links are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Handling pagination errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the pagination is working, we can add exception handling for pagination
    errors in the view. The `page` parameter used by the view to retrieve the given
    page could potentially be used with wrong values, such as non-existing page numbers
    or a string value that cannot be used as a page number. We will implement appropriate
    error handling for those cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/blog/?page=3` in your browser. You should see the
    following error page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: The EmptyPage error page'
  prefs: []
  type: TYPE_NORMAL
- en: The `Paginator` object throws an `EmptyPage` exception when retrieving page
    `3` because it’s out of range. There are no results to display. Let’s handle this
    error in our view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application to add the necessary imports
    and modify the `post_list` view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have added a try and except block to manage the `EmptyPage` exception when
    retrieving a page. If the page requested is out of range, we return the last page
    of results. We get the total number of pages with `paginator.num_pages`. The total
    number of pages is the same as the last page number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/blog/?page=3` in your browser again. Now, the exception
    is managed by the view, and the last page of results is returned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: The last page of results'
  prefs: []
  type: TYPE_NORMAL
- en: Our view should also handle the case when something different than an integer
    is passed in the `page` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/blog/?page=asdf` in your browser. You should see
    the following error page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: The PageNotAnInteger error page'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `Paginator` object throws a `PageNotAnInteger` exception when
    retrieving the page `asdf` because page numbers can only be integers. Let’s handle
    this error in our view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application to add the necessary imports
    and modify the `post_list` view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have added a new `except` block to manage the `PageNotAnInteger` exception
    when retrieving a page. If the page requested is not an integer, we return the
    first page of results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/blog/?page=asdf` in your browser again. Now, the
    exception is managed by the view and the first page of results is returned as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: The first page of results'
  prefs: []
  type: TYPE_NORMAL
- en: The pagination for blog posts is now fully implemented.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the `Paginator` class at [https://docs.djangoproject.com/en/5.0/ref/paginator/](https://docs.djangoproject.com/en/5.0/ref/paginator/).
  prefs: []
  type: TYPE_NORMAL
- en: Having learned how to paginate your blog, we will now turn to transforming the
    `post_list` view into an equivalent view that is built using Django generic views
    and built-in pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Building class-based views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have built the blog application using function-based views. Function-based
    views are simple and powerful, but Django also allows you to build views using
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Class-based views are an alternative way to implement views as Python objects
    instead of functions. Since a view is a function that takes a web request and
    returns a web response, you can also define your views as class methods. Django
    provides base view classes that you can use to implement your own views. All of
    them inherit from the `View` class, which handles HTTP method dispatching and
    other common functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Why use class-based views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Class-based views offer some advantages over function-based views that are
    useful for specific use cases. Class-based views allow you to:'
  prefs: []
  type: TYPE_NORMAL
- en: Organize code related to HTTP methods, such as `GET`, `POST`, or `PUT`, in separate
    methods, instead of using conditional branching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use multiple inheritance to create reusable view classes (also known as *mixins*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a class-based view to list posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand how to write class-based views, we will create a new class-based
    view that is equivalent to the `post_list` view. We will create a class that will
    inherit from the generic `ListView` view offered by Django. `ListView` allows
    you to list any type of object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PostListView` view is analogous to the `post_list` view we built previously.
    We have implemented a class-based view that inherits from the `ListView` class.
    We have defined a view with the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `queryset` to use a custom QuerySet instead of retrieving all objects.
    Instead of defining a `queryset` attribute, we could have specified `model = Post`
    and Django would have built the generic `Post.objects.all()` QuerySet for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the context variable `posts` for the query results. The default variable
    is `object_list` if you don’t specify any `context_object_name`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define the pagination of results with `paginate_by`, returning three objects
    per page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use a custom template to render the page with `template_name`. If you don’t
    set a default template, `ListView` will use `blog/post_list.html` by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, edit the `urls.py` file of the `blog` application, comment the preceding
    `post_list` URL pattern, and add a new URL pattern using the `PostListView` class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to keep pagination working, we have to use the right page object that
    is passed to the template. Django’s `ListView` generic view passes the page requested
    in a variable called `page_obj`. We have to edit the `post/list.html` template
    accordingly to include the paginator using the right variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://127.0.0.1:8000/blog/` in your browser and verify that the pagination
    links work as expected. The behavior of the pagination links should be the same
    as with the previous `post_list` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception handling in this case is a bit different. If you try to load
    a page out of range or pass a non-integer value in the `page` parameter, the view
    will return an HTTP response with the status code `404` (page not found) like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: HTTP 404 Page not found response'
  prefs: []
  type: TYPE_NORMAL
- en: The exception handling that returns the HTTP `404` status code is provided by
    the `ListView` view.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example of how to write class-based views. You will learn more
    about class-based views in *Chapter 13*, *Creating a Content Management System*,
    and successive chapters.
  prefs: []
  type: TYPE_NORMAL
- en: You can read an introduction to class-based views at [https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/](https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/).
  prefs: []
  type: TYPE_NORMAL
- en: After learning how to use class-based views and using built-in object pagination,
    we will implement the functionality for sharing posts by email to engage your
    blog readers.
  prefs: []
  type: TYPE_NORMAL
- en: Recommending posts by email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will allow users to share blog posts with others by sending post recommendations
    via email. You will learn how to create forms in Django, handle data submission,
    and send emails with Django, enhancing your blog with a personal touch.
  prefs: []
  type: TYPE_NORMAL
- en: Take a minute to think about how you could use *views*, *URLs*, and *templates*
    to create this functionality using what you learned in the preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow users to share posts via email, we will need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a form for users to fill in their name, their email address, the recipient’s
    email address, and optional comments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a view in the `views.py` file that handles the posted data and sends
    the email
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a URL pattern for the new view in the `urls.py` file of the blog application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a template to display the form
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating forms with Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by building the form to share posts. Django has a built-in forms
    framework that allows you to create forms easily. The forms framework makes it
    simple to define the fields of the form, specify how they have to be displayed,
    and indicate how they have to validate input data. The Django forms framework
    offers a flexible way to render forms in HTML and handle data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django comes with two base classes to build forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Form`: This allows you to build standard forms by defining fields and validations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ModelForm`: This allows you to build forms tied to model instances. It provides
    all the functionalities of the base `Form` class, but form fields can be explicitly
    declared, or automatically generated, from model fields. The form can be used
    to create or edit model instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, create a `forms.py` file inside the directory of your `blog` application
    and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have defined our first Django form. The `EmailPostForm` form inherits from
    the base `Form` class. We use different field types to validate data accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Forms can reside anywhere in your Django project. The convention is to place
    them inside a `forms.py` file for each application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: An instance of `CharField` with a maximum length of `25` characters.
    We will use it for the name of the person sending the post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: An instance of `EmailField`. We will use the email of the person sending
    the post recommendation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to`: An instance of `EmailField`. We will use the email address of the recipient,
    who will receive an email recommending the post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comments`: An instance of `CharField`. We will use it for comments to include
    in the post recommendation email. We have made this field optional by setting
    `required` to `False`, and we have specified a custom widget to render the field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each field type has a default widget that determines how the field is rendered
    in HTML. The `name` field is an instance of `CharField`. This type of field is
    rendered as an `<input type="text">` HTML element. The default widget can be overridden
    with the `widget` attribute. In the `comments` field, we use the `Textarea` widget
    to display it as a `<textarea>` HTML element instead of the default `<input>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Field validation also depends on the field type. For example, the `email` and
    `to` fields are `EmailField` fields. Both fields require a valid email address;
    the field validation will otherwise raise a `forms.ValidationError` exception
    and the form will not validate. Other parameters are also taken into account for
    the form field validation, such as the `name` field having a maximum length of
    `25` or the `comments` field being optional.
  prefs: []
  type: TYPE_NORMAL
- en: These are only some of the field types that Django provides for forms. You can
    find a list of all field types available at [https://docs.djangoproject.com/en/5.0/ref/forms/fields/](https://docs.djangoproject.com/en/5.0/ref/forms/fields/).
  prefs: []
  type: TYPE_NORMAL
- en: Handling forms in views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have defined the form to recommend posts via email. Now, we need a view to
    create an instance of the form and handle the form submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the `post_share` view that takes the `request` object and the
    `post_id` variable as parameters. We use the `get_object_or_404()` shortcut to
    retrieve a published post by its `id`.
  prefs: []
  type: TYPE_NORMAL
- en: We use the same view both for displaying the initial form and processing the
    submitted data. The HTTP `request` method allows us to differentiate whether the
    form is being submitted. A `GET` request will indicate that an empty form has
    to be displayed to the user and a `POST` request will indicate the form is being
    submitted. We use `request.method == 'POST'` to differentiate between the two
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the process to display the form and handle the form submission:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the page is loaded for the first time, the view receives a `GET` request.
    In this case, a new `EmailPostForm` instance is created and stored in the `form`
    variable. This form instance will be used to display the empty form in the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the user fills in the form and submits it via `POST`, a form instance
    is created using the submitted data contained in `request.POST`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this, the data submitted is validated using the form’s `is_valid()` method.
    This method validates the data introduced in the form and returns `True` if all
    fields contain valid data. If any field contains invalid data, then `is_valid()`
    returns `False`. The list of validation errors can be obtained with `form.errors`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the form is not valid, the form is rendered in the template again, including
    the data submitted. Validation errors will be displayed in the template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the form is valid, the validated data is retrieved with `form.cleaned_data`.
    This attribute is a dictionary of form fields and their values. Forms not only
    validate the data but also *clean* the data by normalizing it to a consistent
    format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your form data does not validate, `cleaned_data` will contain only the valid
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented the view to display the form and handle the form submission.
    We will now learn how to send emails using Django and then we will add that functionality
    to the `post_share` view.
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails with Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sending emails with Django is very straightforward. You need to have a local
    SMTP server, or you need to access an external SMTP server, like your email service
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following settings allow you to define the SMTP configuration to send emails
    with Django:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EMAIL_HOST`: The SMTP server host; the default is `localhost`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_PORT`: The SMTP port; the default is `25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_HOST_USER`: The username for the SMTP server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_HOST_PASSWORD`: The password for the SMTP server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_USE_TLS`: Whether to use a **Transport Layer Security** (**TLS**) secure
    connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_USE_SSL`: Whether to use an implicit TLS secure connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you can use the `DEFAULT_FROM_EMAIL` setting to specify the default
    sender when sending emails with Django. For this example, we will use Google’s
    SMTP server with a standard Gmail account.
  prefs: []
  type: TYPE_NORMAL
- en: Working with environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add SMTP configuration settings to the project, and we will load the
    SMTP credentials from environment variables. By using environment variables, we
    will avoid embedding credentials in the source code. There are multiple reasons
    to keep configuration separate from the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: Credentials or secret keys in the code can lead to unintentional
    exposure, especially if you push the code to public repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Keeping the configuration separate will allow you to use the
    same code base across different environments without any changes. You will learn
    how to build multiple environments in *Chapter 17*, *Going Live*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Changing a configuration won’t require a code change,
    ensuring that your project remains consistent across versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To facilitate the separation of configuration from code, we are going to use
    `python-decouple`. This library simplifies the use of environment variables in
    your projects. You can find information about `python-decouple` at [https://github.com/HBNetwork/python-decouple](https://github.com/HBNetwork/python-decouple).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install `python-decouple` via `pip` by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new file inside your project’s root directory and name it `.env`.
    The `.env` file will contain key-value pairs of environment variables. Add the
    following lines to the new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you have a Gmail account, replace `your_account@gmail.com` with your Gmail
    account. The `EMAIL_HOST_PASSWORD` variable has no value yet, we will add it later.
    The `DEFAULT_FROM_EMAIL` variable will be used to specify the default sender for
    our emails. If you don’t have a Gmail account, you can use the SMTP credentials
    for your email service provider.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a `git` repository for your code, make sure to include `.env`
    in the `.gitignore` file of your repository. By doing so, you ensure that credentials
    are excluded from the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of your project and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `EMAIL_HOST_USER`, `EMAIL_HOST_PASSWORD` and `DEFAULT_FROM_EMAIL` settings
    are now loaded from environment variables defined in the `.env` file.
  prefs: []
  type: TYPE_NORMAL
- en: The provided `EMAIL_HOST`, `EMAIL_PORT` and `EMAIL_USE_TLS` settings are for
    Gmail’s SMTP server. If you don’t have a Gmail account, you can use the SMTP server
    configuration of your email service provider.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of Gmail, you can also use a professional, scalable email service that
    allows you to send emails via SMTP using your own domain, such as SendGrid ([https://sendgrid.com/](https://sendgrid.com/))
    or Amazon **Simple Email Service** (**SES**) ([https://aws.amazon.com/ses/](https://aws.amazon.com/ses/)).
    Both services will require you to verify your domain and sender email accounts
    and will provide you with SMTP credentials to send emails. The `django-anymail`
    application simplifies the task of adding email service providers to your project
    like SendGrid or Amazon SES. You can find installation instructions for `django-anymail`
    at [https://anymail.dev/en/stable/installation/](https://anymail.dev/en/stable/installation/),
    and the list of supported email service providers at [https://anymail.dev/en/stable/esps/](https://anymail.dev/en/stable/esps/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can’t use an SMTP server, you can tell Django to write emails to the
    console by adding the following setting to the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By using this setting, Django will output all emails to the shell instead of
    sending them. This is very useful for testing your application without an SMTP
    server.
  prefs: []
  type: TYPE_NORMAL
- en: In order to send emails with Gmail’s SMTP server, make sure that two-step verification
    is active in your Gmail account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://myaccount.google.com/security](https://myaccount.google.com/security)
    in your browser and enable **2-Step Verification** for your account, as shown
    in *Figure 2.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: The sign in to Google page for Google accounts'
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to create an app password and use it for your SMTP credentials.
    An app password is a 16-digit passcode that gives a *less secure* app or device
    permission to access your Google account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an app password, open [https://myaccount.google.com/apppasswords](https://myaccount.google.com/apppasswords)
    in your browser. You will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Form to generate a new Google app password'
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot access **App passwords**, it might be that 2-Step Verification
    is not set for your account, your account is an organization account instead of
    a standard Gmail account, or you turned on Google’s advanced protection. Make
    sure to use a standard Gmail account and activate 2-Step Verification for your
    Google account. You can find more information at [https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833).
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the name `Blog` and click the **Create** button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Form to generate a new Google app password'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new password will be generated and displayed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Generated Google app password'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the generated app password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit the `.env` file of your project and add the app password to the
    `EMAIL_HOST_PASSWORD` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the Python shell by running the following command in the system shell
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following code in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `send_mail()` function takes the subject, message, sender, and list of recipients
    as required arguments. By setting the optional argument `fail_silently=False`,
    we are telling it to raise an exception if the email cannot be sent. If the output
    you see is `1`, then your email was successfully sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get a `CERTIFICATE_VERIFY_FAILED` error, install the `certify` module
    with the command `pip install --upgrade certifi`. If you are using macOS, run
    the following command on the shell to install `certify` and let Python access
    macOS root certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Check your inbox. You should have received the email as displayed in *Figure
    2.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: Test email sent displayed in Gmail'
  prefs: []
  type: TYPE_NORMAL
- en: You just sent your first email with Django! You can find more information about
    sending emails with Django at [https://docs.djangoproject.com/en/5.0/topics/email/](https://docs.djangoproject.com/en/5.0/topics/email/).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add this functionality to the `post_share` view.
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails in views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `post_share` view in the `views.py` file of the `blog` application,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have declared a `sent` variable with the initial `False`
    value. We set this variable to `True` after the email is sent. We will use the
    `sent` variable later in the template to display a success message when the form
    is successfully submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have to include a link to the post in the email, we retrieve the absolute
    path of the post using its `get_absolute_url()` method. We use this path as an
    input for `request.build_absolute_uri()` to build a complete URL, including the
    HTTP schema and hostname.
  prefs: []
  type: TYPE_NORMAL
- en: We create the subject and the message body of the email using the cleaned data
    of the validated form. Finally, we send the email to the email address contained
    in the `to` field of the form. In the `from_email` parameter, we pass the `None`
    value, so the value of the `DEFAULT_FROM_EMAIL` setting will be used for the sender.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the view is complete, we have to add a new URL pattern for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `urls.py` file of your `blog` application and add the `post_share`
    URL pattern, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Rendering forms in templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating the form, programming the view, and adding the URL pattern, the
    only thing missing is the template for the view.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in the `blog/templates/blog/post/` directory and name it `share.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the new `share.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is the template that is used to both display the form to share a post via
    email and to display a success message when the email has been sent. We differentiate
    between both cases with `{% if sent %}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the form, we have defined an HTML form element, indicating that
    it has to be submitted by the `POST` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We have included the form instance with `{{ form.as_p }}`. We tell Django to
    render the form fields using HTML paragraph `<p>` elements by using the `as_p`
    method. We could also render the form as an unordered list with `as_ul` or as
    an HTML table with `as_table`.
  prefs: []
  type: TYPE_NORMAL
- en: We have added a `{% csrf_token %}` template tag. This tag introduces a hidden
    field with an autogenerated token to avoid **cross-site request forgery** (**CSRF**)
    attacks. These attacks consist of a malicious website or program performing an
    unwanted action for a user on the site. You can find more information about CSRF
    at [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{% csrf_token %}` template tag generates a hidden field that is rendered
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: By default, Django checks for the CSRF token in all `POST` requests. Remember
    to include the `csrf_token` tag in all forms that are submitted via `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/detail.html` template and make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We have added a link to the `post_share` URL. The URL is built dynamically with
    the `{% url %}` template tag provided by Django. We use the namespace called `blog`
    and the URL named `post_share`. We pass the `id` post as a parameter to build
    the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the shell prompt and execute the following command to start the development
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://127.0.0.1:8000/blog/` in your browser and click on any post title
    to view the post detail page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the post body, you should see the link that you just added, as shown
    in *Figure 2.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: The post detail page, including a link to share the post'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Share this post**, and you should see the page, including the form
    to share this post by email, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21088_02_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: The page to share a post via email'
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS styles for the form are included in the example code in the `static/css/blog.css`
    file. When you click on the **SEND E-MAIL** button, the form is submitted and
    validated. If all fields contain valid data, you get a success message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated with medium confidence](img/B21088_02_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: A success message for a post shared via email'
  prefs: []
  type: TYPE_NORMAL
- en: 'Send a post to your own email address and check your inbox. The email you receive
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: Test email sent displayed in Gmail'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you submit the form with invalid data, the form will be rendered again,
    including all validation errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, Teams  Description automatically
    generated](img/B21088_02_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.20: The share post form displaying invalid data errors'
  prefs: []
  type: TYPE_NORMAL
- en: Most modern browsers will prevent you from submitting a form with empty or erroneous
    fields. This is because the browser validates the fields based on their attributes
    before submitting the form. In this case, the form won’t be submitted, and the
    browser will display an error message for the fields that are wrong. To test the
    Django form validation using a modern browser, you can skip the browser form validation
    by adding the `novalidate` attribute to the HTML `<form>` element, like `<form
    method="post" novalidate>`. You can add this attribute to prevent the browser
    from validating fields and test your own form validation. After you are done testing,
    remove the `novalidate` attribute to keep the browser form validation.
  prefs: []
  type: TYPE_NORMAL
- en: The functionality for sharing posts by email is now complete. You can find more
    information about working with forms at [https://docs.djangoproject.com/en/5.0/topics/forms/](https://docs.djangoproject.com/en/5.0/topics/forms/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a comment system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will continue extending our blog application with a comment system that
    will allow users to comment on posts. To build the comment system, we will need
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A comment model to store user comments on posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Django form that allows users to submit comments and manages the data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view that processes the form and saves a new comment to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of comments and the HTML form to add a new comment that can be included
    in the post detail template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model for comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by building a model to store user comments on posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `models.py` file of your `blog` application and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is the `Comment` model. We have added a `ForeignKey` field to associate
    each comment with a single post. This many-to-one relationship is defined in the
    `Comment` model because each comment will be made on one post, and each post may
    have multiple comments.
  prefs: []
  type: TYPE_NORMAL
- en: The `related_name` attribute allows you to name the attribute that you use for
    the relationship from the related object back to this one. We can retrieve the
    post of a comment object using `comment.post` and retrieve all comments associated
    with a post object using `post.comments.all()`. If you don’t define the `related_name`
    attribute, Django will use the name of the model in lowercase, followed by `_set`
    (that is, `comment_set`) to name the relationship of the related object to the
    object of the model, where this relationship has been defined.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about many-to-one relationships at [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/).
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the `active` Boolean field to control the status of the comments.
    This field will allow us to manually deactivate inappropriate comments using the
    administration site. We use `default=True` to indicate that all comments are active
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the `created` field to store the date and time when the comment
    was created. By using `auto_now_add`, the date will be saved automatically when
    creating an object. In the `Meta` class of the model, we have added `ordering
    = ['created']` to sort comments in chronological order by default, and we have
    added an index for the `created` field in ascending order. This will improve the
    performance of database lookups or ordering results using the `created` field.
  prefs: []
  type: TYPE_NORMAL
- en: The `Comment` model that we have built is not synchronized with the database.
    We need to generate a new database migration to create the corresponding database
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command from the shell prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Django has generated a `0003_comment.py` file inside the `migrations/` directory
    of the `blog` application. We need to create the related database schema and apply
    the changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to apply existing migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get an output that includes the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The migration has been applied and the `blog_comment` table has been created
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding comments to the administration site
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will add the new model to the administration site to manage comments
    through a simple interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `admin.py` file of the `blog` application, import the `Comment` model,
    and add the following `ModelAdmin` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the shell prompt and execute the following command to start the development
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/admin/` in your browser. You should see the new
    model included in the **BLOG** section, as shown in *Figure 2.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.21: Blog application models on the Django administration index page'
  prefs: []
  type: TYPE_NORMAL
- en: The model is now registered on the administration site.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Comments** row, click on **Add**. You will see the form to add a new
    comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.22: Form to add a new comment in the Django administration site'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can manage `Comment` instances using the administration site.
  prefs: []
  type: TYPE_NORMAL
- en: Creating forms from models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to build a form to let users comment on blog posts. Remember that Django
    has two base classes that can be used to create forms: `Form` and `ModelForm`.
    We used the `Form` class to allow users to share posts by email. Now, we will
    use `ModelForm` to take advantage of the existing `Comment` model and build a
    form dynamically for it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `forms.py` file of your `blog` application and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To create a form from a model, we just indicate which model to build the form
    for in the `Meta` class of the form. Django will introspect the model and build
    the corresponding form dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Each model field type has a corresponding default form field type. The attributes
    of model fields are taken into account for form validation. By default, Django
    creates a form field for each field contained in the model. However, we can explicitly
    tell Django which fields to include in the form using the `fields` attribute or
    define which fields to exclude using the `exclude` attribute. In the `CommentForm`
    form, we have explicitly included the `name`, `email`, and `body` fields. These
    are the only fields that will be included in the form.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about creating forms from models at [https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/](https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/).
  prefs: []
  type: TYPE_NORMAL
- en: Handling ModelForms in views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For sharing posts by email, we used the same view to display the form and manage
    its submission. We used the HTTP method to differentiate between both cases: `GET`
    to display the form and `POST` to submit it. In this case, we will add the comment
    form to the post detail page, and we will build a separate view to handle the
    form submission. The new view that processes the form will allow the user to return
    to the post detail view once the comment has been stored in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the `post_comment` view that takes the `request` object and
    the `post_id` variable as parameters. We will be using this view to manage the
    post submission. We expect the form to be submitted using the HTTP `POST` method.
    We use the `require_POST` decorator provided by Django to only allow `POST` requests
    for this view. Django allows you to restrict the HTTP methods allowed for views.
    Django will throw an HTTP `405` (method not allowed) error if you try to access
    the view with any other HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this view, we have implemented the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve a published post by its `id` using the `get_object_or_404()` shortcut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `comment` variable with the initial value `None`. This variable
    will be used to store the comment object when it is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We instantiate the form using the submitted `POST` data and validate it using
    the `is_valid()` method. If the form is invalid, the template is rendered with
    the validation errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the form is valid, we create a new `Comment` object by calling the form’s
    `save()` method and assign it to the `comment` variable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `save()` method creates an instance of the model that the form is linked
    to and saves it to the database. If you call it using `commit=False`, the model
    instance is created but not saved to the database. This allows us to modify the
    object before finally saving it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `save()` method is available for `ModelForm` but not for `Form` instances
    since they are not linked to any model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We assign the post to the comment we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We save the new comment to the database by calling its `save()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We render the `blog/post/comment.html` template, passing the `post`, `form`,
    and `comment` objects in the template context. This template doesn’t exist yet;
    we will create it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s create a URL pattern for this view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `blog` application and add the following URL
    pattern to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We have implemented the view to manage the submission of comments and their
    corresponding URL. Let’s create the necessary templates.
  prefs: []
  type: TYPE_NORMAL
- en: Creating templates for the comment form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a template for the comment form that we will use in two places:'
  prefs: []
  type: TYPE_NORMAL
- en: In the post detail template associated with the `post_detail` view to let users
    publish comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the post comment template associated with the `post_comment` view to display
    the form again if there are any form errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create the form template and use the `{% include %}` template tag to
    include it in the two other templates.
  prefs: []
  type: TYPE_NORMAL
- en: In the `templates/blog/post/` directory, create a new `includes/` directory.
    Add a new file inside this directory and name it `comment_form.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file structure should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the new `blog/post/includes/comment_form.html` template and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this template, we build the `action` URL of the HTML `<form>` element dynamically
    using the `{% url %}` template tag. We build the URL of the `post_comment` view
    that will process the form. We display the form rendered in paragraphs and we
    include `{% csrf_token %}` for CSRF protection because this form will be submitted
    with the `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in the `templates/blog/post/` directory of the `blog` application
    and name it `comment.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file structure should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the new `blog/post/comment.html` template and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the template for the post comment view. In this view, we expect the
    form to be submitted via the `POST` method. The template covers two different
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: If the form data submitted is valid, the `comment` variable will contain the
    `comment` object that was created and a success message will be displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the form data submitted is not valid, the `comment` variable will be `None`.
    In this case, we will display the comment form. We use the `{% include %}` template
    tag to include the `comment_form.html` template that we have previously created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding comments to the post detail view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete the comment functionality, we will add the list of comments and
    the comment form to the `post_detail` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and edit the `post_detail`
    view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s review the code we have added to the `post_detail` view:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added a QuerySet to retrieve all active comments for the post, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This QuerySet is built using the `post` object. Instead of building a QuerySet
    for the `Comment` model directly, we leverage the `post` object to retrieve the
    related `Comment` objects. We use the `comments` manager for the related `Comment`
    objects that we previously defined in the `Comment` model, using the `related_name`
    attribute of the `ForeignKey` field to the `Post` model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have also created an instance of the comment form with `form = CommentForm()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding comments to the post detail template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to edit the `blog/post/detail.html` template to implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Display the total number of comments for a post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the list of comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the form for users to add a new comment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by adding the total number of comments for a post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/detail.html` template and change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We use the Django **object relational mapper** (**ORM**) in the template, executing
    the `comments.count()` QuerySet. Note that the Django template language doesn’t
    use parentheses for calling methods. The `{% with %}` tag allows you to assign
    a value to a new variable that will be available in the template until the `{%
    endwith %}` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The `{% with %}` template tag is useful for avoiding hitting the database or
    accessing expensive methods multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `pluralize` template filter to display a plural suffix for the word
    “comment,” depending on the `total_comments` value. Template filters take the
    value of the variable they are applied to as their input and return a computed
    value. We will learn more about template filters in *Chapter 3*, *Extending Your
    Blog Application*.
  prefs: []
  type: TYPE_NORMAL
- en: The `pluralize` template filter returns a string with the letter “s” if the
    value is different from `1`. The preceding text will be rendered as *0 comments*,
    *1 comment*, or *N comments*, depending on the number of active comments for the
    post.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s add the list of active comments to the post detail template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/detail.html` template and implement the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We have added a `{% for %}` template tag to loop through the post comments.
    If the `comments` list is empty, we display a message that informs users that
    there are no comments for this post. We enumerate comments with the `{{ forloop.counter
    }}` variable, which contains the loop counter in each iteration. For each post,
    we display the name of the user who posted it, the date, and the body of the comment.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s add the comment form to the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/detail.html` template and include the comment form template
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser and click on a post title
    to take a look at the post detail page. You will see something like *Figure 2.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.23: The post detail page, including the form to add a comment'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the comment form with valid data and click on **Add comment**. You
    should see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.24: The comment added success page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Back to the post** link. You should be redirected back to the
    post detail page, and you should be able to see the comment that you just added,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.25: The post detail page, including a comment'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add one more comment to the post. The comments should appear below the post
    contents in chronological order, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.26: The comment list on the post detail page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/admin/blog/comment/` in your browser. You will
    see the administration page with the list of comments you created, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.27: List of comments on the administration site'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the name of one of the posts to edit it. Uncheck the **Active** checkbox
    as follows and click on the **Save** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.28: Editing a comment on the administration site'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be redirected to the list of comments. The **Active** column will
    display an inactive icon for the comment, as shown in *Figure 2.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.29: Active/inactive comments on the administration site'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you return to the post detail view, you will note that the inactive comment
    is no longer displayed, neither is it counted for the total number of active comments
    for the post:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.30: A single active comment displayed on the post detail page'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the `active` field, you can deactivate inappropriate comments and
    avoid showing them on your posts.
  prefs: []
  type: TYPE_NORMAL
- en: Using simplified templates for form rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have used `{{ form.as_p }}` to render the forms using HTML paragraphs. This
    is a very straightforward method for rendering forms, but there may be occasions
    when you need to employ custom HTML markup for rendering forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use custom HTML for rendering form fields, you can access each form field
    directly, or iterate through the form fields, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we use `{{ field.errors }}` to render any field errors of the
    form, `{{ field.label_tag }}` to render the form HTML label, `{{ field }}` to
    render the actual field, and `{{ field.help_text|safe }}` to render the field’s
    help text HTML.
  prefs: []
  type: TYPE_NORMAL
- en: This method is helpful to customize how forms are rendered, but you might need
    to add certain HTML elements for specific fields or include some fields in containers.
    Django 5.0 introduces field groups and field group templates. Field groups simplify
    the rendering of labels, widgets, help texts, and field errors. Let’s use this
    new feature to customize the comment form.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use custom HTML markup to reposition the `name` and `email`
    form fields using additional HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/includes/comment_form.html` template and modify it as follows.
    The new code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We have added `<div>` containers for the `name` and `email` fields with a custom
    CSS class to float both fields to the left.The `as_field_group` method renders
    each field including help text and errors. This method uses the `django/forms/field.html`
    template by default. You can see the contents of this template at [https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html](https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html).
    You can also create custom field templates and reuse them by adding the `template_name`
    attribute to any form field. You can read more about reusable form templates at
    [https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates](https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a blog post and take a look at the comment form. The form should now look
    like *Figure 2.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.31: The comment form with the new HTML markup'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` and `email` fields are now displayed next to each other. Field groups
    allow you to easily customize form rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to define canonical URLs for models. You created
    SEO-friendly URLs for blog posts, and you implemented object pagination for your
    post list. You also learned how to work with Django forms and model forms. You
    created a system to recommend posts by email and created a comment system for
    your blog.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will create a tagging system for the blog. You will
    learn how to build complex QuerySets to retrieve objects by similarity. You will
    learn how to create custom template tags and filters. You will also build a custom
    sitemap and feed for your blog posts and implement full-text search functionality
    for your posts.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'URL utility functions: [https://docs.djangoproject.com/en/5.0/ref/urlresolvers/](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'URL path converters: [https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters](https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django paginator class: [https://docs.djangoproject.com/en/5.0/ref/paginator/](https://docs.djangoproject.com/en/5.0/ref/paginator/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to class-based views – [https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/](https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sending emails with Django: [https://docs.djangoproject.com/en/5.0/topics/email/](https://docs.djangoproject.com/en/5.0/topics/email/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `python-decouple` library: [https://github.com/HBNetwork/python-decouple](https://github.com/HBNetwork/python-decouple)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `django-anymail` library: [https://anymail.dev/en/stable/installation/](https://anymail.dev/en/stable/installation/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `django-anymail` supported email service providers: [https://anymail.dev/en/stable/esps/](https://anymail.dev/en/stable/esps/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django form field types: [https://docs.djangoproject.com/en/5.0/ref/forms/fields/](https://docs.djangoproject.com/en/5.0/ref/forms/fields/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with forms: [https://docs.djangoproject.com/en/5.0/topics/forms/](https://docs.djangoproject.com/en/5.0/topics/forms/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating forms from models: [https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/](https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many-to-one model relationships: [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default form field template: [https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html](https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reusable field group templates: [https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates](https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
