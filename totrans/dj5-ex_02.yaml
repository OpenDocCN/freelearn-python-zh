- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Enhancing Your Blog and Adding Social Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升您的博客并添加社交功能
- en: In the preceding chapter, we learned the main components of Django by developing
    a simple blog application using views, templates, and URLs. In this chapter, we
    will extend the functionalities of the blog application with features that can
    be found in many blogging platforms nowadays.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过使用视图、模板和URL开发一个简单的博客应用程序，学习了Django的主要组件。在本章中，我们将通过添加现在许多博客平台都有的功能来扩展博客应用程序的功能。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Using canonical URLs for models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为模型使用规范URL
- en: Creating SEO-friendly URLs for posts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为帖子创建SEO友好的URL
- en: Adding pagination to the post list view
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为帖子列表视图添加分页
- en: Building class-based views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基于类的视图
- en: Sending emails with Django
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django发送电子邮件
- en: Using Django forms to share posts via email
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django表单通过电子邮件分享帖子
- en: Adding comments to posts using forms from models
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型表单添加帖子评论
- en: Functional overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能概述
- en: '*Figure 2.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.1*展示了本章将要构建的视图、模板和功能表示：'
- en: '![](img/B21088_02_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_01.png)'
- en: 'Figure 2.1: Diagram of functionalities built in Chapter 2'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：第二章构建的功能图
- en: In this chapter, we will add pagination to the post list page to navigate through
    all posts. We will also learn how to build class-based views with Django and convert
    the `post_list` view to a class-based view named `PostListView`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为帖子列表页面添加分页功能以浏览所有帖子。我们还将学习如何使用Django构建基于类的视图，并将`post_list`视图转换为名为`PostListView`的基于类的视图。
- en: We will create the `post_share` view to share posts via email. We will use Django
    forms to share posts and send email recommendations via **Simple Mail Transfer
    Protocol** (**SMTP**). To add comments to posts, we will create a `Comment` model
    to store comments, and we will build the `post_comment` view using forms for models.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`post_share`视图，通过电子邮件分享帖子。我们将使用Django表单来分享帖子并通过**简单邮件传输协议**（**SMTP**）发送电子邮件推荐。为了给帖子添加评论，我们将创建一个`Comment`模型来存储评论，并使用模型表单构建`post_comment`视图。
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02)找到。
- en: All Python packages used in this chapter are included in the `requirements.txt`
    file in the source code for the chapter. You can follow the instructions to install
    each Python package in the following sections, or you can install all the requirements
    at once with the `python -m pip install -r requirements.txt` command.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有Python包都包含在章节源代码的`requirements.txt`文件中。您可以在以下部分按照说明安装每个Python包，或者可以使用`python
    -m pip install -r requirements.txt`命令一次性安装所有依赖。
- en: Using canonical URLs for models
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为模型使用规范URL
- en: A website might have different pages that display the same content. In our application,
    the initial part of the content for each post is displayed both on the post list
    page and the post detail page. A canonical URL is the preferred URL for a resource.
    You can think of it as the URL of the most representative page for specific content.
    There might be different pages on your site that display posts, but there is a
    single URL that you use as the main URL for a post.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网站可能有不同的页面显示相同的内容。在我们的应用程序中，每个帖子的内容初始部分既在帖子列表页面上显示，也在帖子详情页面上显示。规范URL是资源的首选URL。您可以将其视为特定内容的代表性页面的URL。您的网站上可能有不同的页面显示帖子，但只有一个URL用作帖子的主要URL。
- en: Canonical URLs allow you to specify the URL for the master copy of a page. Django
    allows you to implement the `get_absolute_url()` method in your models to return
    the canonical URL for the object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 规范URL允许您指定页面的主副本的URL。Django允许您在模型中实现`get_absolute_url()`方法以返回对象的规范URL。
- en: We will use the `post_detail` URL defined in the URL patterns of the application
    to build the canonical URL for `Post` objects. Django provides different URL resolver
    functions that allow you to build URLs dynamically using their name and any required
    parameters. We will use the `reverse()` utility function of the `django.urls`
    module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在应用程序的URL模式中定义的`post_detail` URL来构建`Post`对象的规范URL。Django提供了不同的URL解析器函数，允许您使用它们的名称和任何所需的参数动态构建URL。我们将使用`django.urls`模块的`reverse()`实用函数。
- en: 'Edit the `models.py` file of the `blog` application to import the `reverse()`
    function and add the `get_absolute_url()` method to the `Post` model as follows.
    The new code is highlighted in bold:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`models.py`文件以导入`reverse()`函数并将`get_absolute_url()`方法添加到`Post`模型中，如下所示。新的代码以粗体显示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `reverse()` function will build the URL dynamically using the URL name defined
    in the URL patterns. We have used the `blog` namespace followed by a colon and
    the `post_detail` URL name. Remember that the `blog` namespace is defined in the
    main `urls.py` file of the project when including the URL patterns from `blog.urls`.
    The `post_detail` URL is defined in the `urls.py` file of the `blog` application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse()`函数将使用在URL模式中定义的URL名称动态构建URL。我们使用了`blog`命名空间，后面跟着一个冒号和`post_detail`
    URL名称。记住，当从`blog.urls`包含URL模式时，`blog`命名空间在项目的`urls.py`主文件中定义。`post_detail` URL在`blog`应用的`urls.py`文件中定义。'
- en: The resulting string, `blog:post_detail`, can be used globally in your project
    to refer to the post detail URL. This URL has a required parameter, which is the
    `id` of the blog post to retrieve. We have included the `id` of the `Post` object
    as a positional argument by using `args=[self.id]`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的字符串`blog:post_detail`可以在你的项目中全局使用来引用文章详细URL。此URL有一个必需的参数，即要检索的博客文章的`id`。我们通过使用`args=[self.id]`将`Post`对象的`id`作为位置参数包含在内。
- en: You can learn more about the URL’s utility functions at [https://docs.djangoproject.com/en/5.0/ref/urlresolvers/](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.djangoproject.com/en/5.0/ref/urlresolvers/](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/)了解更多关于URL实用函数的信息。
- en: Let’s replace the post detail URLs in the templates with the new `get_absolute_url()`
    method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将模板中的文章详细URL替换为新的`get_absolute_url()`方法。
- en: 'Edit the `blog/post/list.html` file and replace the following line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog/post/list.html`文件并替换以下行：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Replace the preceding line with the following line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行替换为以下行：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `blog/post/list.html` file should now look as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`blog/post/list.html`文件应该看起来如下：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the shell prompt and execute the following command to start the development
    server:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打开shell提示符并执行以下命令以启动开发服务器：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open `http://127.0.0.1:8000/blog/` in your browser. Links to individual blog
    posts should still work. Django now builds the post URLs using the `get_absolute_url()`
    method of the `Post` model.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`http://127.0.0.1:8000/blog/`。指向单个博客文章的链接仍然应该有效。Django现在使用`Post`模型的`get_absolute_url()`方法构建文章URL。
- en: Creating SEO-friendly URLs for posts
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对SEO友好的文章URL
- en: The canonical URL for a blog post detail view currently looks like `/blog/1/`.
    We will change the URL pattern to create SEO-friendly URLs for posts. We will
    be using both the `publish` date and `slug` values to build the URLs for single
    posts. By combining dates, we will make a post detail URL to look like `/blog/2024/1/1/who-was-django-reinhardt/`.
    We will provide search engines with friendly URLs to index, containing both the
    title and date of the post.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前博客文章详细视图的规范URL看起来像`/blog/1/`。我们将更改URL模式以创建对SEO友好的文章URL。我们将使用发布日期和`slug`值来构建单个文章的URL。通过组合日期，我们将文章详细URL设置为`/blog/2024/1/1/who-was-django-reinhardt/`。我们将为搜索引擎提供友好的URL以进行索引，包含文章的标题和日期。
- en: To retrieve single posts with the combination of publication date and slug,
    we need to ensure that no post can be stored in the database with the same `slug`
    and `publish` date as an existing post. We will prevent the `Post` model from
    storing duplicated posts by defining slugs to be unique for the publication date
    of the post.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过发布日期和`slug`的组合检索单个文章，我们需要确保没有文章可以存储在数据库中，其`slug`和`publish`日期与现有文章相同。我们将通过定义`slug`为文章发布日期的唯一值来防止`Post`模型存储重复的文章。
- en: 'Edit the `models.py` file and add the following `unique_for_date` parameter
    to the `slug` field of the `Post` model:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`models.py`文件并在`Post`模型的`slug`字段中添加以下`unique_for_date`参数：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By using `unique_for_date`, the `slug` field is now required to be unique for
    the date stored in the `publish` field. Note that the `publish` field is an instance
    of `DateTimeField`, but the check for unique values will be done only against
    the date (not the time). Django will prevent you from saving a new post with the
    same slug as an existing post for a given publication date. We have now ensured
    that slugs are unique for the publication date, so we can now retrieve single
    posts by the `publish` and `slug` fields.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `unique_for_date`，`slug` 字段现在必须对于存储在 `publish` 字段中的日期是唯一的。请注意，`publish`
    字段是 `DateTimeField` 的一个实例，但唯一值的检查将仅针对日期（而不是时间）进行。Django 将防止你保存一个与给定发布日期的现有文章具有相同slug的新文章。我们现在确保slug对于发布日期是唯一的，因此我们现在可以通过
    `publish` 和 `slug` 字段检索单个文章。
- en: We have changed our models, so, let’s create migrations. Note that `unique_for_date`
    is not enforced at the database level, so no database migration is required. However,
    Django uses migrations to keep track of all model changes. We will create a migration
    just to keep migrations aligned with the current state of the model.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了模型，所以，让我们创建迁移。请注意，`unique_for_date` 并不在数据库级别强制执行，因此不需要数据库迁移。然而，Django
    使用迁移来跟踪所有模型更改。我们将创建一个迁移，只是为了保持迁移与当前模型状态的一致。
- en: 'Run the following command in the shell prompt:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell提示符中运行以下命令：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should get the following output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Django just created the `0002_alter_post_slug.py` file inside the `migrations`
    directory of the `blog` application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Django 已经在 `blog` 应用程序的 `migrations` 目录中创建了 `0002_alter_post_slug.py` 文件。
- en: 'Execute the following command in the shell prompt to apply existing migrations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell提示符中执行以下命令以应用现有迁移：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will get an output that ends with the following line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个以以下行结束的输出：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Django will consider that all migrations have been applied and the models are
    in sync. No action will be done in the database because `unique_for_date` is not
    enforced at the database level.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Django 将认为所有迁移都已应用，并且模型是一致的。由于 `unique_for_date` 并不在数据库级别强制执行，因此数据库中不会执行任何操作。
- en: Modifying the URL patterns
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改URL模式
- en: Let’s modify the URL patterns to use the publication date and slug for the post
    detail URL.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改URL模式以使用发布日期和slug为文章详情URL。
- en: 'Edit the `urls.py` file of the `blog` application and replace the following
    line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog` 应用的 `urls.py` 文件并替换以下行：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Replace the preceding line with the following lines:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行替换为以下行：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `urls.py` file should now look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`urls.py` 文件现在应该看起来像这样：'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The URL pattern for the `post_detail` view takes the following arguments:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_detail` 视图的URL模式接受以下参数：'
- en: '`year`: This requires an integer'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`year`：这需要一个整数'
- en: '`month`: This requires an integer'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`month`：这需要一个整数'
- en: '`day`: This requires an integer'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`day`：这需要一个整数'
- en: '`post`: This requires a slug (a string that contains only letters, numbers,
    underscores, or hyphens)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`：这需要一个slug（一个只包含字母、数字、下划线或连字符的字符串）'
- en: The `int` path converter is used for the `year`, `month`, and `day` parameters,
    whereas the `slug` path converter is used for the `post` parameter. You learned
    about path converters in the previous chapter. You can see all path converters
    provided by Django at [https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters](https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 路径转换器用于 `year`、`month` 和 `day` 参数，而 `slug` 路径转换器用于 `post` 参数。你可以在上一章中了解到路径转换器。你可以在
    Django 提供的所有路径转换器中看到 [https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters](https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters)。'
- en: Our posts have now an SEO-friendly URL that is built with the date and slug
    of each post. Let’s modify the `post_detail` view accordingly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文章现在有一个SEO友好的URL，它是用每篇文章的日期和slug构建的。让我们相应地修改 `post_detail` 视图。
- en: Modifying the views
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改视图
- en: We will change the parameters of the `post_detail` view to match the new URL
    parameters and use them to retrieve the corresponding `Post` object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改 `post_detail` 视图的参数以匹配新的URL参数并使用它们来检索相应的 `Post` 对象。
- en: 'Edit the `views.py` file and edit the `post_detail` view like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `views.py` 文件并修改 `post_detail` 视图如下：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have modified the `post_detail` view to take the `year`, `month`, `day`,
    and `post` arguments and retrieve a published post with the given slug and publication
    date. By adding `unique_for_date='publish'` to the `slug` field of the `Post`
    model, we ensured that there would be only one post with a slug for a given date.
    Thus, you can retrieve single posts using the date and slug.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已修改`post_detail`视图，以接受`year`、`month`、`day`和`post`参数，并检索具有给定slug和发布日期的已发布文章。通过在`Post`模型的`slug`字段中添加`unique_for_date='publish'`，我们确保了对于给定日期只有一个具有slug的文章。因此，您可以使用日期和slug检索单个文章。
- en: Modifying the canonical URL for posts
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改文章的规范URL
- en: We also have to modify the parameters of the canonical URL for blog posts to
    match the new URL parameters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须修改博客文章的规范URL参数，以匹配新的URL参数。
- en: 'Edit the `models.py` file of the `blog` application and edit the `get_absolute_url()`
    method as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`models.py`文件，并按照以下方式编辑`get_absolute_url()`方法：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Start the development server by typing the following command in the shell prompt:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell提示符中键入以下命令以启动开发服务器：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, you can return to your browser and click on one of the post titles to
    take a look at the detail view of the post. You should see something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以在浏览器中点击其中一个文章标题，查看文章的详细视图。您应该看到如下内容：
- en: '![](img/B21088_02_02.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_02.png)'
- en: 'Figure 2.2: The page for the post’s detail view'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：文章详细视图页面
- en: You have designed SEO-friendly URLs for the blog posts. The URL for a post now
    looks like `/blog/2024/1/1/who-was-django-reinhardt/`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经为博客文章设计了SEO友好的URL。现在文章的URL看起来像这样：`/blog/2024/1/1/who-was-django-reinhardt/`。
- en: Now that you have implemented SEO-friendly URLs, let’s focus on implementing
    navigation through posts using pagination.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经实现了SEO友好的URL，让我们专注于使用分页实现文章导航。
- en: Adding pagination
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分页
- en: When you start adding content to your blog, you can easily store tens or hundreds
    of posts in your database. Instead of displaying all the posts on a single page,
    you may want to split the list of posts across several pages and include navigation
    links to the different pages. This functionality is called pagination, and you
    can find it in almost every web application that displays long lists of items.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始向博客添加内容时，您可以在数据库中轻松存储数十或数百篇文章。而不是在单页上显示所有文章，您可能希望将文章列表分页显示在几个页面上，并包含导航链接到不同的页面。这种功能称为分页，您几乎可以在显示长列表项的每个Web应用程序中找到它。
- en: 'For example, Google uses pagination to divide search results across multiple
    pages. *Figure 2.3* shows Google’s pagination links for search result pages:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Google使用分页将搜索结果分散在多个页面上。*图2.3*展示了Google搜索结果页面的分页链接：
- en: '![Icon  Description automatically generated](img/B21088_02_03.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图标描述自动生成](img/B21088_02_03.png)'
- en: 'Figure 2.3: Google pagination links for search result pages'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Google搜索结果页面的分页链接
- en: Django has a built-in pagination class that allows you to manage paginated data
    easily. You can define the number of objects you want to be returned per page
    and you can retrieve the posts that correspond to the page requested by the user.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Django有一个内置的分页类，允许您轻松管理分页数据。您可以定义每页要返回的对象数量，并且可以检索用户请求的页面对应的文章。
- en: Adding pagination to the post list view
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文章列表视图中添加分页
- en: We will add pagination to the list of posts so that users can easily navigate
    through all posts published on the blog.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向文章列表添加分页，以便用户可以轻松浏览博客上发布的所有文章。
- en: 'Edit the `views.py` file of the `blog` application to import the Django `Paginator`
    class and modify the `post_list` view as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`views.py`文件，导入Django的`Paginator`类，并按照以下方式修改`post_list`视图：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s review the new code we have added to the view:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们添加到视图中的新代码：
- en: We instantiate the `Paginator` class with the number of objects to return per
    page. We will display three posts per page.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用每页要返回的对象数量实例化`Paginator`类。我们将每页显示三篇文章。
- en: We retrieve the `page` `GET` HTTP parameter and store it in the `page_number`
    variable. This parameter contains the requested page number. If the `page` parameter
    is not in the `GET` parameters of the request, we use the default value `1` to
    load the first page of results.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检索`page` `GET` HTTP参数并将其存储在`page_number`变量中。此参数包含请求的页码。如果`page`参数不在请求的`GET`参数中，我们使用默认值`1`来加载结果的第一页。
- en: We obtain the objects for the desired page by calling the `page()` method of
    `Paginator`. This method returns a `Page` object that we store in the `posts`
    variable.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过调用 `Paginator` 的 `page()` 方法来获取所需页面的对象。此方法返回一个 `Page` 对象，我们将其存储在 `posts`
    变量中。
- en: We pass the `posts` object to the template.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `posts` 对象传递给模板。
- en: Creating a pagination template
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建分页模板
- en: We need to create a page navigation for users to browse through the different
    pages. In this section, we will create a template to display the pagination links,
    and we’ll make it generic so that we can reuse the template for any object pagination
    on our website.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为用户创建页面导航，以便浏览不同的页面。在本节中，我们将创建一个模板来显示分页链接，并将其设计为通用，以便我们可以在网站上为任何对象分页重用该模板。
- en: 'In the `templates/` directory, create a new file and name it `pagination.html`.
    Add the following HTML code to the file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `templates/` 目录下创建一个新文件，并将其命名为 `pagination.html`。将以下HTML代码添加到文件中：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is the generic pagination template. The template expects to have a `Page`
    object in the context to render the previous and next links and to display the
    current page and total pages of results.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用的分页模板。该模板期望在上下文中有一个 `Page` 对象来渲染上一页和下一页的链接，并显示当前页和总页数。
- en: 'Let’s return to the `blog/post/list.html` template and include the `pagination.html`
    template at the bottom of the `{% content %}` block, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `blog/post/list.html` 模板，并在 `{% content %}` 块的底部包含 `pagination.html` 模板，如下所示：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `{% include %}` template tag loads the given template and renders it using
    the current template context. We use `with` to pass additional context variables
    to the template. The pagination template uses the `page` variable to render, while
    the `Page` object that we pass from our view to the template is called `posts`.
    We use `with page=posts` to pass the variable expected by the pagination template.
    You can follow this method to use the pagination template for any type of object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% include %}` 模板标签加载给定的模板，并使用当前的模板上下文来渲染它。我们使用 `with` 来向模板传递额外的上下文变量。分页模板使用
    `page` 变量进行渲染，而我们从视图传递给模板的 `Page` 对象被称为 `posts`。我们使用 `with page=posts` 来传递分页模板期望的变量。您可以使用这种方法为任何类型的对象使用分页模板。'
- en: 'Start the development server by typing the following command in the shell prompt:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在shell提示符中输入以下命令来启动开发服务器：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Open `http://127.0.0.1:8000/admin/blog/post/` in your browser and use the administration
    site to create a total of four different posts. Make sure to set the status to
    **Published**for all of them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开 `http://127.0.0.1:8000/admin/blog/post/` 并使用管理站点创建总共四篇不同的帖子。确保将所有帖子的状态设置为**已发布**。
- en: 'Now, open `http://127.0.0.1:8000/blog/` in your browser. You should see the
    first three posts in reverse chronological order, and then the navigation links
    at the bottom of the post list like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的浏览器中打开 `http://127.0.0.1:8000/blog/`。您应该看到按倒序排列的前三篇帖子，然后在帖子列表底部的导航链接如下所示：
- en: '![](img/B21088_02_04.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_04.png)'
- en: 'Figure 2.4: The post list page including pagination'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：包含分页的帖子列表页面
- en: If you click on **Next**, you will see the last post. The URL for the second
    page contains the `?page=2` `GET` parameter. This parameter is used by the view
    to load the requested page of results using the paginator.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击**下一页**，您将看到最后一篇帖子。第二页的URL包含 `?page=2` 的 `GET` 参数。此参数由视图用于通过分页器加载请求的页面。
- en: '![](img/B21088_02_05.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_05.png)'
- en: 'Figure 2.5: The second page of results'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：结果页的第二页
- en: Great! The pagination links are working as expected.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，分页链接按预期工作。
- en: Handling pagination errors
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理分页错误
- en: Now that the pagination is working, we can add exception handling for pagination
    errors in the view. The `page` parameter used by the view to retrieve the given
    page could potentially be used with wrong values, such as non-existing page numbers
    or a string value that cannot be used as a page number. We will implement appropriate
    error handling for those cases.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在分页功能已经正常工作，我们可以在视图中添加对分页错误的异常处理。视图使用的 `page` 参数可能被用于错误值，例如不存在的页码或无法用作页码的字符串值。我们将为这些情况实现适当的错误处理。
- en: 'Open `http://127.0.0.1:8000/blog/?page=3` in your browser. You should see the
    following error page:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `http://127.0.0.1:8000/blog/?page=3`。您应该看到以下错误页面：
- en: '![](img/B21088_02_06.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_06.png)'
- en: 'Figure 2.6: The EmptyPage error page'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：空页错误页面
- en: The `Paginator` object throws an `EmptyPage` exception when retrieving page
    `3` because it’s out of range. There are no results to display. Let’s handle this
    error in our view.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当检索第`3`页时，`Paginator`对象抛出`EmptyPage`异常，因为它超出了范围。没有结果可以显示。让我们在我们的视图中处理这个错误。
- en: 'Edit the `views.py` file of the `blog` application to add the necessary imports
    and modify the `post_list` view as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`views.py`文件，添加必要的导入并修改`post_list`视图如下：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have added a try and except block to manage the `EmptyPage` exception when
    retrieving a page. If the page requested is out of range, we return the last page
    of results. We get the total number of pages with `paginator.num_pages`. The total
    number of pages is the same as the last page number.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个try和except块来管理检索页面时出现的`EmptyPage`异常。如果请求的页面超出范围，我们返回最后一页的结果。我们通过`paginator.num_pages`获取总页数。总页数与最后一页的页码相同。
- en: 'Open `http://127.0.0.1:8000/blog/?page=3` in your browser again. Now, the exception
    is managed by the view, and the last page of results is returned as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在浏览器中打开`http://127.0.0.1:8000/blog/?page=3`。现在，异常由视图管理，并返回如下最后页的结果：
- en: '![](img/B21088_02_07.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_07.png)'
- en: 'Figure 2.7: The last page of results'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：结果的最后一页
- en: Our view should also handle the case when something different than an integer
    is passed in the `page` parameter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图也应该处理当`page`参数传递的不是整数时的情况。
- en: 'Open `http://127.0.0.1:8000/blog/?page=asdf` in your browser. You should see
    the following error page:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://127.0.0.1:8000/blog/?page=asdf`。你应该看到以下错误页面：
- en: '![](img/B21088_02_08.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_08.png)'
- en: 'Figure 2.8: The PageNotAnInteger error page'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：`PageNotAnInteger`错误页面
- en: In this case, the `Paginator` object throws a `PageNotAnInteger` exception when
    retrieving the page `asdf` because page numbers can only be integers. Let’s handle
    this error in our view.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当检索页面`asdf`时，`Paginator`对象抛出`PageNotAnInteger`异常，因为页码只能是整数。让我们在我们的视图中处理这个错误。
- en: 'Edit the `views.py` file of the `blog` application to add the necessary imports
    and modify the `post_list` view as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`views.py`文件，添加必要的导入并修改`post_list`视图如下：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have added a new `except` block to manage the `PageNotAnInteger` exception
    when retrieving a page. If the page requested is not an integer, we return the
    first page of results.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的`except`块来管理检索页面时出现的`PageNotAnInteger`异常。如果请求的页面不是整数，我们返回结果的第一页。
- en: 'Open `http://127.0.0.1:8000/blog/?page=asdf` in your browser again. Now, the
    exception is managed by the view and the first page of results is returned as
    follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在浏览器中打开`http://127.0.0.1:8000/blog/?page=asdf`。现在，异常由视图管理，并返回如下第一页的结果：
- en: '![](img/B21088_02_09.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_09.png)'
- en: 'Figure 2.9: The first page of results'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：结果的第一页
- en: The pagination for blog posts is now fully implemented.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 博客文章的分页现在已经完全实现。
- en: You can learn more about the `Paginator` class at [https://docs.djangoproject.com/en/5.0/ref/paginator/](https://docs.djangoproject.com/en/5.0/ref/paginator/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.djangoproject.com/en/5.0/ref/paginator/](https://docs.djangoproject.com/en/5.0/ref/paginator/)了解更多关于`Paginator`类的信息。
- en: Having learned how to paginate your blog, we will now turn to transforming the
    `post_list` view into an equivalent view that is built using Django generic views
    and built-in pagination.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了如何分页你的博客后，我们现在将转向将`post_list`视图转换为使用Django通用视图和内置分页构建的等效视图。
- en: Building class-based views
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基于类的视图
- en: We have built the blog application using function-based views. Function-based
    views are simple and powerful, but Django also allows you to build views using
    classes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用基于函数的视图构建了博客应用。基于函数的视图简单而强大，但Django还允许你使用类来构建视图。
- en: Class-based views are an alternative way to implement views as Python objects
    instead of functions. Since a view is a function that takes a web request and
    returns a web response, you can also define your views as class methods. Django
    provides base view classes that you can use to implement your own views. All of
    them inherit from the `View` class, which handles HTTP method dispatching and
    other common functionalities.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类的视图是实现视图作为Python对象而不是函数的另一种方式。由于视图是一个接收网络请求并返回网络响应的函数，你还可以将你的视图定义为类方法。Django提供了你可以用来实现你自己的视图的基础视图类。所有这些类都继承自`View`类，该类处理HTTP方法调度和其他常见功能。
- en: Why use class-based views
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用基于类的视图
- en: 'Class-based views offer some advantages over function-based views that are
    useful for specific use cases. Class-based views allow you to:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类的视图相对于基于函数的视图在特定用例中提供了一些优势。基于类的视图允许您：
- en: Organize code related to HTTP methods, such as `GET`, `POST`, or `PUT`, in separate
    methods, instead of using conditional branching
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将与HTTP方法相关的代码，如`GET`、`POST`或`PUT`，组织在单独的方法中，而不是使用条件分支
- en: Use multiple inheritance to create reusable view classes (also known as *mixins*)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多重继承来创建可重用的视图类（也称为*mixins*）
- en: Using a class-based view to list posts
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于类的视图来列出帖子
- en: To understand how to write class-based views, we will create a new class-based
    view that is equivalent to the `post_list` view. We will create a class that will
    inherit from the generic `ListView` view offered by Django. `ListView` allows
    you to list any type of object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何编写基于类的视图，我们将创建一个新的与`post_list`视图等效的基于类的视图。我们将创建一个继承自Django提供的通用`ListView`视图的类。`ListView`允许您列出任何类型的对象。
- en: 'Edit the `views.py` file of the `blog` application and add the following code
    to it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`views.py`文件，并向其中添加以下代码：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `PostListView` view is analogous to the `post_list` view we built previously.
    We have implemented a class-based view that inherits from the `ListView` class.
    We have defined a view with the following attributes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostListView`视图与之前构建的`post_list`视图类似。我们已经实现了一个继承自`ListView`类的基于类的视图。我们定义了一个具有以下属性的视图：'
- en: We use `queryset` to use a custom QuerySet instead of retrieving all objects.
    Instead of defining a `queryset` attribute, we could have specified `model = Post`
    and Django would have built the generic `Post.objects.all()` QuerySet for us.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`queryset`来使用自定义QuerySet，而不是检索所有对象。我们可以在不定义`queryset`属性的情况下指定`model = Post`，Django将为我们构建通用的`Post.objects.all()`
    QuerySet。
- en: We use the context variable `posts` for the query results. The default variable
    is `object_list` if you don’t specify any `context_object_name`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用上下文变量`posts`来表示查询结果。如果没有指定任何`context_object_name`，默认变量是`object_list`。
- en: We define the pagination of results with `paginate_by`, returning three objects
    per page.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`paginate_by`定义结果分页，每页返回三个对象。
- en: We use a custom template to render the page with `template_name`. If you don’t
    set a default template, `ListView` will use `blog/post_list.html` by default.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用自定义模板来渲染带有`template_name`的页面。如果您没有设置默认模板，`ListView`将默认使用`blog/post_list.html`。
- en: 'Now, edit the `urls.py` file of the `blog` application, comment the preceding
    `post_list` URL pattern, and add a new URL pattern using the `PostListView` class,
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑`blog`应用的`urls.py`文件，注释掉之前的`post_list` URL模式，并使用`PostListView`类添加一个新的URL模式，如下所示：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to keep pagination working, we have to use the right page object that
    is passed to the template. Django’s `ListView` generic view passes the page requested
    in a variable called `page_obj`. We have to edit the `post/list.html` template
    accordingly to include the paginator using the right variable, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使分页功能正常工作，我们必须使用传递给模板的正确页面对象。Django的`ListView`通用视图通过一个名为`page_obj`的变量传递请求的页面。我们必须相应地编辑`post/list.html`模板，以包含使用正确变量的分页器，如下所示：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open `http://127.0.0.1:8000/blog/` in your browser and verify that the pagination
    links work as expected. The behavior of the pagination links should be the same
    as with the previous `post_list` view.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/blog/`并验证分页链接是否按预期工作。分页链接的行为应该与之前的`post_list`视图相同。
- en: 'The exception handling in this case is a bit different. If you try to load
    a page out of range or pass a non-integer value in the `page` parameter, the view
    will return an HTTP response with the status code `404` (page not found) like
    this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，异常处理略有不同。如果您尝试加载超出范围的页面或传递`page`参数中的非整数值，视图将返回一个带有状态码`404`（页面未找到）的HTTP响应，如下所示：
- en: '![](img/B21088_02_10.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_10.png)'
- en: 'Figure 2.10: HTTP 404 Page not found response'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：HTTP 404 页面未找到响应
- en: The exception handling that returns the HTTP `404` status code is provided by
    the `ListView` view.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 返回HTTP `404`状态码的异常处理由`ListView`视图提供。
- en: This is a simple example of how to write class-based views. You will learn more
    about class-based views in *Chapter 13*, *Creating a Content Management System*,
    and successive chapters.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何编写基于类的视图的简单示例。您将在第13章“创建内容管理系统”和随后的章节中了解更多关于基于类的视图的内容。
- en: You can read an introduction to class-based views at [https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/](https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/](https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/)阅读关于基于类的视图的介绍。
- en: After learning how to use class-based views and using built-in object pagination,
    we will implement the functionality for sharing posts by email to engage your
    blog readers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何使用基于类的视图和使用内置的对象分页后，我们将实现通过电子邮件分享帖子以吸引博客读者的功能。
- en: Recommending posts by email
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过电子邮件推荐帖子
- en: We will allow users to share blog posts with others by sending post recommendations
    via email. You will learn how to create forms in Django, handle data submission,
    and send emails with Django, enhancing your blog with a personal touch.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许用户通过发送帖子推荐通过电子邮件与他人分享博客帖子。您将学习如何在Django中创建表单、处理数据提交以及发送电子邮件，为您的博客增添个性化特色。
- en: Take a minute to think about how you could use *views*, *URLs*, and *templates*
    to create this functionality using what you learned in the preceding chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间思考一下，您如何可以使用*视图*、*URL*和*模板*来创建此功能，使用您在前一章中学到的知识。
- en: 'To allow users to share posts via email, we will need to:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户通过电子邮件分享帖子，我们需要做以下事情：
- en: Create a form for users to fill in their name, their email address, the recipient’s
    email address, and optional comments
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表单，让用户填写他们的姓名、他们的电子邮件地址、收件人的电子邮件地址以及可选的评论
- en: Create a view in the `views.py` file that handles the posted data and sends
    the email
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`views.py`文件中创建一个视图来处理提交的数据并发送电子邮件
- en: Add a URL pattern for the new view in the `urls.py` file of the blog application
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在博客应用的`urls.py`文件中为新的视图添加一个URL模式
- en: Create a template to display the form
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模板来显示表单
- en: Creating forms with Django
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Django创建表单
- en: Let’s start by building the form to share posts. Django has a built-in forms
    framework that allows you to create forms easily. The forms framework makes it
    simple to define the fields of the form, specify how they have to be displayed,
    and indicate how they have to validate input data. The Django forms framework
    offers a flexible way to render forms in HTML and handle data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建分享帖子的表单开始。Django内置了一个表单框架，允许您轻松创建表单。表单框架使得定义表单字段、指定它们的显示方式以及指示如何验证输入数据变得简单。Django表单框架提供了一个灵活的方式来在HTML中渲染表单并处理数据。
- en: 'Django comes with two base classes to build forms:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了两个基础类来构建表单：
- en: '`Form`: This allows you to build standard forms by defining fields and validations.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Form`: 这允许您通过定义字段和验证来构建标准表单。'
- en: '`ModelForm`: This allows you to build forms tied to model instances. It provides
    all the functionalities of the base `Form` class, but form fields can be explicitly
    declared, or automatically generated, from model fields. The form can be used
    to create or edit model instances.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModelForm`: 这允许您构建与模型实例相关的表单。它提供了基础`Form`类的所有功能，但表单字段可以显式声明，或从模型字段自动生成。该表单可用于创建或编辑模型实例。'
- en: 'First, create a `forms.py` file inside the directory of your `blog` application
    and add the following code to it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的`blog`应用目录中创建一个`forms.py`文件，并将其中的以下代码添加到该文件中：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have defined our first Django form. The `EmailPostForm` form inherits from
    the base `Form` class. We use different field types to validate data accordingly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的第一个Django表单。`EmailPostForm`表单从基础`Form`类继承。我们使用不同的字段类型来相应地验证数据。
- en: Forms can reside anywhere in your Django project. The convention is to place
    them inside a `forms.py` file for each application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 表单可以位于您的Django项目的任何位置。惯例是将它们放置在每个应用的`forms.py`文件中。
- en: 'The form contains the following fields:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表单包含以下字段：
- en: '`name`: An instance of `CharField` with a maximum length of `25` characters.
    We will use it for the name of the person sending the post.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 一个最大长度为`25`字符的`CharField`实例。我们将用它来表示发送帖子的个人姓名。'
- en: '`email`: An instance of `EmailField`. We will use the email of the person sending
    the post recommendation.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`: `EmailField`的一个实例。我们将使用发送帖子推荐的个人电子邮件。'
- en: '`to`: An instance of `EmailField`. We will use the email address of the recipient,
    who will receive an email recommending the post.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`: `EmailField`的一个实例。我们将使用收件人的电子邮件地址，该收件人将收到一封推荐帖子的电子邮件。'
- en: '`comments`: An instance of `CharField`. We will use it for comments to include
    in the post recommendation email. We have made this field optional by setting
    `required` to `False`, and we have specified a custom widget to render the field.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each field type has a default widget that determines how the field is rendered
    in HTML. The `name` field is an instance of `CharField`. This type of field is
    rendered as an `<input type="text">` HTML element. The default widget can be overridden
    with the `widget` attribute. In the `comments` field, we use the `Textarea` widget
    to display it as a `<textarea>` HTML element instead of the default `<input>`
    element.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Field validation also depends on the field type. For example, the `email` and
    `to` fields are `EmailField` fields. Both fields require a valid email address;
    the field validation will otherwise raise a `forms.ValidationError` exception
    and the form will not validate. Other parameters are also taken into account for
    the form field validation, such as the `name` field having a maximum length of
    `25` or the `comments` field being optional.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: These are only some of the field types that Django provides for forms. You can
    find a list of all field types available at [https://docs.djangoproject.com/en/5.0/ref/forms/fields/](https://docs.djangoproject.com/en/5.0/ref/forms/fields/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Handling forms in views
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have defined the form to recommend posts via email. Now, we need a view to
    create an instance of the form and handle the form submission.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and add the following code
    to it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have defined the `post_share` view that takes the `request` object and the
    `post_id` variable as parameters. We use the `get_object_or_404()` shortcut to
    retrieve a published post by its `id`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We use the same view both for displaying the initial form and processing the
    submitted data. The HTTP `request` method allows us to differentiate whether the
    form is being submitted. A `GET` request will indicate that an empty form has
    to be displayed to the user and a `POST` request will indicate the form is being
    submitted. We use `request.method == 'POST'` to differentiate between the two
    scenarios.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the process to display the form and handle the form submission:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'When the page is loaded for the first time, the view receives a `GET` request.
    In this case, a new `EmailPostForm` instance is created and stored in the `form`
    variable. This form instance will be used to display the empty form in the template:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When the user fills in the form and submits it via `POST`, a form instance
    is created using the submitted data contained in `request.POST`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After this, the data submitted is validated using the form’s `is_valid()` method.
    This method validates the data introduced in the form and returns `True` if all
    fields contain valid data. If any field contains invalid data, then `is_valid()`
    returns `False`. The list of validation errors can be obtained with `form.errors`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the form is not valid, the form is rendered in the template again, including
    the data submitted. Validation errors will be displayed in the template.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表单无效，表单将在模板中再次渲染，包括提交的数据。验证错误将在模板中显示。
- en: If the form is valid, the validated data is retrieved with `form.cleaned_data`.
    This attribute is a dictionary of form fields and their values. Forms not only
    validate the data but also *clean* the data by normalizing it to a consistent
    format.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表单有效，将通过`form.cleaned_data`检索验证后的数据。这个属性是表单字段及其值的字典。表单不仅验证数据，而且通过将其规范化为一致格式来*清理*数据。
- en: If your form data does not validate, `cleaned_data` will contain only the valid
    fields.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的表单数据无效，`cleaned_data`将只包含有效的字段。
- en: We have implemented the view to display the form and handle the form submission.
    We will now learn how to send emails using Django and then we will add that functionality
    to the `post_share` view.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了显示表单和处理表单提交的视图。现在我们将学习如何使用Django发送邮件，然后我们将将该功能添加到`post_share`视图中。
- en: Sending emails with Django
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Django发送邮件
- en: Sending emails with Django is very straightforward. You need to have a local
    SMTP server, or you need to access an external SMTP server, like your email service
    provider.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Django发送邮件非常直接。你需要有一个本地的SMTP服务器，或者你需要访问一个外部SMTP服务器，比如你的电子邮件服务提供商。
- en: 'The following settings allow you to define the SMTP configuration to send emails
    with Django:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下设置允许你定义SMTP配置以使用Django发送邮件：
- en: '`EMAIL_HOST`: The SMTP server host; the default is `localhost`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST`：SMTP服务器主机；默认为`localhost`'
- en: '`EMAIL_PORT`: The SMTP port; the default is `25`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_PORT`：SMTP端口；默认为`25`'
- en: '`EMAIL_HOST_USER`: The username for the SMTP server'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST_USER`：SMTP服务器的用户名'
- en: '`EMAIL_HOST_PASSWORD`: The password for the SMTP server'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST_PASSWORD`：SMTP服务器的密码'
- en: '`EMAIL_USE_TLS`: Whether to use a **Transport Layer Security** (**TLS**) secure
    connection'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_USE_TLS`：是否使用**传输层安全**（**TLS**）安全连接'
- en: '`EMAIL_USE_SSL`: Whether to use an implicit TLS secure connection'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_USE_SSL`：是否使用隐式TLS安全连接'
- en: Additionally, you can use the `DEFAULT_FROM_EMAIL` setting to specify the default
    sender when sending emails with Django. For this example, we will use Google’s
    SMTP server with a standard Gmail account.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用`DEFAULT_FROM_EMAIL`设置来指定发送Django邮件时的默认发送者。在这个例子中，我们将使用Google的SMTP服务器和一个标准的Gmail账户。
- en: Working with environment variables
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与环境变量一起工作
- en: 'We will add SMTP configuration settings to the project, and we will load the
    SMTP credentials from environment variables. By using environment variables, we
    will avoid embedding credentials in the source code. There are multiple reasons
    to keep configuration separate from the code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向项目中添加SMTP配置设置，并从环境变量中加载SMTP凭据。通过使用环境变量，我们将避免在源代码中嵌入凭据。将配置与代码分离有多个原因：
- en: '**Security**: Credentials or secret keys in the code can lead to unintentional
    exposure, especially if you push the code to public repositories.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：代码中的凭据或密钥可能导致意外泄露，尤其是如果你将代码推送到公共仓库时。'
- en: '**Flexibility**: Keeping the configuration separate will allow you to use the
    same code base across different environments without any changes. You will learn
    how to build multiple environments in *Chapter 17*, *Going Live*.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：保持配置与代码分离将允许你在不同的环境中使用相同的代码库而无需任何更改。你将在第17章“上线”中学习如何构建多个环境。'
- en: '**Maintainability**: Changing a configuration won’t require a code change,
    ensuring that your project remains consistent across versions.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：更改配置不需要修改代码，确保你的项目在各个版本之间保持一致性。'
- en: To facilitate the separation of configuration from code, we are going to use
    `python-decouple`. This library simplifies the use of environment variables in
    your projects. You can find information about `python-decouple` at [https://github.com/HBNetwork/python-decouple](https://github.com/HBNetwork/python-decouple).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于将配置与代码分离，我们将使用`python-decouple`。这个库简化了在项目中使用环境变量的操作。你可以在[https://github.com/HBNetwork/python-decouple](https://github.com/HBNetwork/python-decouple)找到关于`python-decouple`的信息。
- en: 'First, install `python-decouple` via `pip` by running the following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过运行以下命令使用`pip`安装`python-decouple`：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, create a new file inside your project’s root directory and name it `.env`.
    The `.env` file will contain key-value pairs of environment variables. Add the
    following lines to the new file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的项目根目录内创建一个新文件，并将其命名为`.env`。`.env`文件将包含环境变量的键值对。将以下行添加到新文件中：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you have a Gmail account, replace `your_account@gmail.com` with your Gmail
    account. The `EMAIL_HOST_PASSWORD` variable has no value yet, we will add it later.
    The `DEFAULT_FROM_EMAIL` variable will be used to specify the default sender for
    our emails. If you don’t have a Gmail account, you can use the SMTP credentials
    for your email service provider.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a `git` repository for your code, make sure to include `.env`
    in the `.gitignore` file of your repository. By doing so, you ensure that credentials
    are excluded from the repository.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of your project and add the following code to it:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `EMAIL_HOST_USER`, `EMAIL_HOST_PASSWORD` and `DEFAULT_FROM_EMAIL` settings
    are now loaded from environment variables defined in the `.env` file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The provided `EMAIL_HOST`, `EMAIL_PORT` and `EMAIL_USE_TLS` settings are for
    Gmail’s SMTP server. If you don’t have a Gmail account, you can use the SMTP server
    configuration of your email service provider.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Instead of Gmail, you can also use a professional, scalable email service that
    allows you to send emails via SMTP using your own domain, such as SendGrid ([https://sendgrid.com/](https://sendgrid.com/))
    or Amazon **Simple Email Service** (**SES**) ([https://aws.amazon.com/ses/](https://aws.amazon.com/ses/)).
    Both services will require you to verify your domain and sender email accounts
    and will provide you with SMTP credentials to send emails. The `django-anymail`
    application simplifies the task of adding email service providers to your project
    like SendGrid or Amazon SES. You can find installation instructions for `django-anymail`
    at [https://anymail.dev/en/stable/installation/](https://anymail.dev/en/stable/installation/),
    and the list of supported email service providers at [https://anymail.dev/en/stable/esps/](https://anymail.dev/en/stable/esps/).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can’t use an SMTP server, you can tell Django to write emails to the
    console by adding the following setting to the `settings.py` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By using this setting, Django will output all emails to the shell instead of
    sending them. This is very useful for testing your application without an SMTP
    server.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In order to send emails with Gmail’s SMTP server, make sure that two-step verification
    is active in your Gmail account.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://myaccount.google.com/security](https://myaccount.google.com/security)
    in your browser and enable **2-Step Verification** for your account, as shown
    in *Figure 2.11*:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_11.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: The sign in to Google page for Google accounts'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to create an app password and use it for your SMTP credentials.
    An app password is a 16-digit passcode that gives a *less secure* app or device
    permission to access your Google account.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an app password, open [https://myaccount.google.com/apppasswords](https://myaccount.google.com/apppasswords)
    in your browser. You will see the following screen:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_12.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Form to generate a new Google app password'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot access **App passwords**, it might be that 2-Step Verification
    is not set for your account, your account is an organization account instead of
    a standard Gmail account, or you turned on Google’s advanced protection. Make
    sure to use a standard Gmail account and activate 2-Step Verification for your
    Google account. You can find more information at [https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the name `Blog` and click the **Create** button, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_13.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Form to generate a new Google app password'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'A new password will be generated and displayed like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_14.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Generated Google app password'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Copy the generated app password.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit the `.env` file of your project and add the app password to the
    `EMAIL_HOST_PASSWORD` variable, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Open the Python shell by running the following command in the system shell
    prompt:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Execute the following code in the Python shell:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `send_mail()` function takes the subject, message, sender, and list of recipients
    as required arguments. By setting the optional argument `fail_silently=False`,
    we are telling it to raise an exception if the email cannot be sent. If the output
    you see is `1`, then your email was successfully sent.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get a `CERTIFICATE_VERIFY_FAILED` error, install the `certify` module
    with the command `pip install --upgrade certifi`. If you are using macOS, run
    the following command on the shell to install `certify` and let Python access
    macOS root certificates:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Check your inbox. You should have received the email as displayed in *Figure
    2.15*:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_15.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: Test email sent displayed in Gmail'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: You just sent your first email with Django! You can find more information about
    sending emails with Django at [https://docs.djangoproject.com/en/5.0/topics/email/](https://docs.djangoproject.com/en/5.0/topics/email/).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add this functionality to the `post_share` view.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails in views
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `post_share` view in the `views.py` file of the `blog` application,
    as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we have declared a `sent` variable with the initial `False`
    value. We set this variable to `True` after the email is sent. We will use the
    `sent` variable later in the template to display a success message when the form
    is successfully submitted.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Since we have to include a link to the post in the email, we retrieve the absolute
    path of the post using its `get_absolute_url()` method. We use this path as an
    input for `request.build_absolute_uri()` to build a complete URL, including the
    HTTP schema and hostname.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: We create the subject and the message body of the email using the cleaned data
    of the validated form. Finally, we send the email to the email address contained
    in the `to` field of the form. In the `from_email` parameter, we pass the `None`
    value, so the value of the `DEFAULT_FROM_EMAIL` setting will be used for the sender.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Now that the view is complete, we have to add a new URL pattern for it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `urls.py` file of your `blog` application and add the `post_share`
    URL pattern, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Rendering forms in templates
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating the form, programming the view, and adding the URL pattern, the
    only thing missing is the template for the view.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in the `blog/templates/blog/post/` directory and name it `share.html`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the new `share.html` template:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is the template that is used to both display the form to share a post via
    email and to display a success message when the email has been sent. We differentiate
    between both cases with `{% if sent %}`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the form, we have defined an HTML form element, indicating that
    it has to be submitted by the `POST` method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We have included the form instance with `{{ form.as_p }}`. We tell Django to
    render the form fields using HTML paragraph `<p>` elements by using the `as_p`
    method. We could also render the form as an unordered list with `as_ul` or as
    an HTML table with `as_table`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: We have added a `{% csrf_token %}` template tag. This tag introduces a hidden
    field with an autogenerated token to avoid **cross-site request forgery** (**CSRF**)
    attacks. These attacks consist of a malicious website or program performing an
    unwanted action for a user on the site. You can find more information about CSRF
    at [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{% csrf_token %}` template tag generates a hidden field that is rendered
    like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By default, Django checks for the CSRF token in all `POST` requests. Remember
    to include the `csrf_token` tag in all forms that are submitted via `POST`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/detail.html` template and make it look like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have added a link to the `post_share` URL. The URL is built dynamically with
    the `{% url %}` template tag provided by Django. We use the namespace called `blog`
    and the URL named `post_share`. We pass the `id` post as a parameter to build
    the URL.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the shell prompt and execute the following command to start the development
    server:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Open `http://127.0.0.1:8000/blog/` in your browser and click on any post title
    to view the post detail page.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the post body, you should see the link that you just added, as shown
    in *Figure 2.16*:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_16.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: The post detail page, including a link to share the post'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Share this post**, and you should see the page, including the form
    to share this post by email, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21088_02_17.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: The page to share a post via email'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS styles for the form are included in the example code in the `static/css/blog.css`
    file. When you click on the **SEND E-MAIL** button, the form is submitted and
    validated. If all fields contain valid data, you get a success message, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated with medium confidence](img/B21088_02_18.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: A success message for a post shared via email'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Send a post to your own email address and check your inbox. The email you receive
    should look like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_19.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: Test email sent displayed in Gmail'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'If you submit the form with invalid data, the form will be rendered again,
    including all validation errors:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, Teams  Description automatically
    generated](img/B21088_02_20.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.20: The share post form displaying invalid data errors'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Most modern browsers will prevent you from submitting a form with empty or erroneous
    fields. This is because the browser validates the fields based on their attributes
    before submitting the form. In this case, the form won’t be submitted, and the
    browser will display an error message for the fields that are wrong. To test the
    Django form validation using a modern browser, you can skip the browser form validation
    by adding the `novalidate` attribute to the HTML `<form>` element, like `<form
    method="post" novalidate>`. You can add this attribute to prevent the browser
    from validating fields and test your own form validation. After you are done testing,
    remove the `novalidate` attribute to keep the browser form validation.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The functionality for sharing posts by email is now complete. You can find more
    information about working with forms at [https://docs.djangoproject.com/en/5.0/topics/forms/](https://docs.djangoproject.com/en/5.0/topics/forms/).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Creating a comment system
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will continue extending our blog application with a comment system that
    will allow users to comment on posts. To build the comment system, we will need
    the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: A comment model to store user comments on posts
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Django form that allows users to submit comments and manages the data validation
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view that processes the form and saves a new comment to the database
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of comments and the HTML form to add a new comment that can be included
    in the post detail template
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model for comments
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by building a model to store user comments on posts.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `models.py` file of your `blog` application and add the following
    code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is the `Comment` model. We have added a `ForeignKey` field to associate
    each comment with a single post. This many-to-one relationship is defined in the
    `Comment` model because each comment will be made on one post, and each post may
    have multiple comments.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The `related_name` attribute allows you to name the attribute that you use for
    the relationship from the related object back to this one. We can retrieve the
    post of a comment object using `comment.post` and retrieve all comments associated
    with a post object using `post.comments.all()`. If you don’t define the `related_name`
    attribute, Django will use the name of the model in lowercase, followed by `_set`
    (that is, `comment_set`) to name the relationship of the related object to the
    object of the model, where this relationship has been defined.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about many-to-one relationships at [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the `active` Boolean field to control the status of the comments.
    This field will allow us to manually deactivate inappropriate comments using the
    administration site. We use `default=True` to indicate that all comments are active
    by default.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the `created` field to store the date and time when the comment
    was created. By using `auto_now_add`, the date will be saved automatically when
    creating an object. In the `Meta` class of the model, we have added `ordering
    = ['created']` to sort comments in chronological order by default, and we have
    added an index for the `created` field in ascending order. This will improve the
    performance of database lookups or ordering results using the `created` field.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: The `Comment` model that we have built is not synchronized with the database.
    We need to generate a new database migration to create the corresponding database
    table.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command from the shell prompt:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should see the following output:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Django has generated a `0003_comment.py` file inside the `migrations/` directory
    of the `blog` application. We need to create the related database schema and apply
    the changes to the database.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to apply existing migrations:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You will get an output that includes the following line:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The migration has been applied and the `blog_comment` table has been created
    in the database.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Adding comments to the administration site
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will add the new model to the administration site to manage comments
    through a simple interface.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `admin.py` file of the `blog` application, import the `Comment` model,
    and add the following `ModelAdmin` class:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Open the shell prompt and execute the following command to start the development
    server:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Open `http://127.0.0.1:8000/admin/` in your browser. You should see the new
    model included in the **BLOG** section, as shown in *Figure 2.21*:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_21.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.21: Blog application models on the Django administration index page'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: The model is now registered on the administration site.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Comments** row, click on **Add**. You will see the form to add a new
    comment:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_22.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.22: Form to add a new comment in the Django administration site'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Now we can manage `Comment` instances using the administration site.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Creating forms from models
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to build a form to let users comment on blog posts. Remember that Django
    has two base classes that can be used to create forms: `Form` and `ModelForm`.
    We used the `Form` class to allow users to share posts by email. Now, we will
    use `ModelForm` to take advantage of the existing `Comment` model and build a
    form dynamically for it.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `forms.py` file of your `blog` application and add the following lines:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To create a form from a model, we just indicate which model to build the form
    for in the `Meta` class of the form. Django will introspect the model and build
    the corresponding form dynamically.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Each model field type has a corresponding default form field type. The attributes
    of model fields are taken into account for form validation. By default, Django
    creates a form field for each field contained in the model. However, we can explicitly
    tell Django which fields to include in the form using the `fields` attribute or
    define which fields to exclude using the `exclude` attribute. In the `CommentForm`
    form, we have explicitly included the `name`, `email`, and `body` fields. These
    are the only fields that will be included in the form.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about creating forms from models at [https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/](https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Handling ModelForms in views
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For sharing posts by email, we used the same view to display the form and manage
    its submission. We used the HTTP method to differentiate between both cases: `GET`
    to display the form and `POST` to submit it. In this case, we will add the comment
    form to the post detail page, and we will build a separate view to handle the
    form submission. The new view that processes the form will allow the user to return
    to the post detail view once the comment has been stored in the database.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and add the following code:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We have defined the `post_comment` view that takes the `request` object and
    the `post_id` variable as parameters. We will be using this view to manage the
    post submission. We expect the form to be submitted using the HTTP `POST` method.
    We use the `require_POST` decorator provided by Django to only allow `POST` requests
    for this view. Django allows you to restrict the HTTP methods allowed for views.
    Django will throw an HTTP `405` (method not allowed) error if you try to access
    the view with any other HTTP method.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'In this view, we have implemented the following actions:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve a published post by its `id` using the `get_object_or_404()` shortcut.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `comment` variable with the initial value `None`. This variable
    will be used to store the comment object when it is created.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We instantiate the form using the submitted `POST` data and validate it using
    the `is_valid()` method. If the form is invalid, the template is rendered with
    the validation errors.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the form is valid, we create a new `Comment` object by calling the form’s
    `save()` method and assign it to the `comment` variable, as follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `save()` method creates an instance of the model that the form is linked
    to and saves it to the database. If you call it using `commit=False`, the model
    instance is created but not saved to the database. This allows us to modify the
    object before finally saving it.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `save()` method is available for `ModelForm` but not for `Form` instances
    since they are not linked to any model.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We assign the post to the comment we created:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We save the new comment to the database by calling its `save()` method:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We render the `blog/post/comment.html` template, passing the `post`, `form`,
    and `comment` objects in the template context. This template doesn’t exist yet;
    we will create it later.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s create a URL pattern for this view.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `blog` application and add the following URL
    pattern to it:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We have implemented the view to manage the submission of comments and their
    corresponding URL. Let’s create the necessary templates.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Creating templates for the comment form
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a template for the comment form that we will use in two places:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: In the post detail template associated with the `post_detail` view to let users
    publish comments.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the post comment template associated with the `post_comment` view to display
    the form again if there are any form errors.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create the form template and use the `{% include %}` template tag to
    include it in the two other templates.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: In the `templates/blog/post/` directory, create a new `includes/` directory.
    Add a new file inside this directory and name it `comment_form.html`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'The file structure should look as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Edit the new `blog/post/includes/comment_form.html` template and add the following
    code:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this template, we build the `action` URL of the HTML `<form>` element dynamically
    using the `{% url %}` template tag. We build the URL of the `post_comment` view
    that will process the form. We display the form rendered in paragraphs and we
    include `{% csrf_token %}` for CSRF protection because this form will be submitted
    with the `POST` method.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in the `templates/blog/post/` directory of the `blog` application
    and name it `comment.html`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'The file structure should now look as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Edit the new `blog/post/comment.html` template and add the following code:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is the template for the post comment view. In this view, we expect the
    form to be submitted via the `POST` method. The template covers two different
    scenarios:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: If the form data submitted is valid, the `comment` variable will contain the
    `comment` object that was created and a success message will be displayed.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the form data submitted is not valid, the `comment` variable will be `None`.
    In this case, we will display the comment form. We use the `{% include %}` template
    tag to include the `comment_form.html` template that we have previously created.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding comments to the post detail view
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete the comment functionality, we will add the list of comments and
    the comment form to the `post_detail` view.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and edit the `post_detail`
    view as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let’s review the code we have added to the `post_detail` view:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added a QuerySet to retrieve all active comments for the post, as follows:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This QuerySet is built using the `post` object. Instead of building a QuerySet
    for the `Comment` model directly, we leverage the `post` object to retrieve the
    related `Comment` objects. We use the `comments` manager for the related `Comment`
    objects that we previously defined in the `Comment` model, using the `related_name`
    attribute of the `ForeignKey` field to the `Post` model.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have also created an instance of the comment form with `form = CommentForm()`.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding comments to the post detail template
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to edit the `blog/post/detail.html` template to implement the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Display the total number of comments for a post
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the list of comments
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the form for users to add a new comment
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by adding the total number of comments for a post.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/detail.html` template and change it as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We use the Django **object relational mapper** (**ORM**) in the template, executing
    the `comments.count()` QuerySet. Note that the Django template language doesn’t
    use parentheses for calling methods. The `{% with %}` tag allows you to assign
    a value to a new variable that will be available in the template until the `{%
    endwith %}` tag.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The `{% with %}` template tag is useful for avoiding hitting the database or
    accessing expensive methods multiple times.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: We use the `pluralize` template filter to display a plural suffix for the word
    “comment,” depending on the `total_comments` value. Template filters take the
    value of the variable they are applied to as their input and return a computed
    value. We will learn more about template filters in *Chapter 3*, *Extending Your
    Blog Application*.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: The `pluralize` template filter returns a string with the letter “s” if the
    value is different from `1`. The preceding text will be rendered as *0 comments*,
    *1 comment*, or *N comments*, depending on the number of active comments for the
    post.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s add the list of active comments to the post detail template.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/detail.html` template and implement the following changes:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We have added a `{% for %}` template tag to loop through the post comments.
    If the `comments` list is empty, we display a message that informs users that
    there are no comments for this post. We enumerate comments with the `{{ forloop.counter
    }}` variable, which contains the loop counter in each iteration. For each post,
    we display the name of the user who posted it, the date, and the body of the comment.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s add the comment form to the template.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/detail.html` template and include the comment form template
    as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser and click on a post title
    to take a look at the post detail page. You will see something like *Figure 2.23*:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_23.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.23: The post detail page, including the form to add a comment'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the comment form with valid data and click on **Add comment**. You
    should see the following page:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_24.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.24: The comment added success page'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Back to the post** link. You should be redirected back to the
    post detail page, and you should be able to see the comment that you just added,
    as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_25.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.25: The post detail page, including a comment'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Add one more comment to the post. The comments should appear below the post
    contents in chronological order, as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_26.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.26: The comment list on the post detail page'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/admin/blog/comment/` in your browser. You will
    see the administration page with the list of comments you created, like this:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_27.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.27: List of comments on the administration site'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the name of one of the posts to edit it. Uncheck the **Active** checkbox
    as follows and click on the **Save** button:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_28.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.28: Editing a comment on the administration site'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be redirected to the list of comments. The **Active** column will
    display an inactive icon for the comment, as shown in *Figure 2.29*:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_29.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.29: Active/inactive comments on the administration site'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'If you return to the post detail view, you will note that the inactive comment
    is no longer displayed, neither is it counted for the total number of active comments
    for the post:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_30.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.30: A single active comment displayed on the post detail page'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the `active` field, you can deactivate inappropriate comments and
    avoid showing them on your posts.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Using simplified templates for form rendering
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have used `{{ form.as_p }}` to render the forms using HTML paragraphs. This
    is a very straightforward method for rendering forms, but there may be occasions
    when you need to employ custom HTML markup for rendering forms.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'To use custom HTML for rendering form fields, you can access each form field
    directly, or iterate through the form fields, as in the following example:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this code, we use `{{ field.errors }}` to render any field errors of the
    form, `{{ field.label_tag }}` to render the form HTML label, `{{ field }}` to
    render the actual field, and `{{ field.help_text|safe }}` to render the field’s
    help text HTML.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: This method is helpful to customize how forms are rendered, but you might need
    to add certain HTML elements for specific fields or include some fields in containers.
    Django 5.0 introduces field groups and field group templates. Field groups simplify
    the rendering of labels, widgets, help texts, and field errors. Let’s use this
    new feature to customize the comment form.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use custom HTML markup to reposition the `name` and `email`
    form fields using additional HTML elements.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/includes/comment_form.html` template and modify it as follows.
    The new code is highlighted in bold:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We have added `<div>` containers for the `name` and `email` fields with a custom
    CSS class to float both fields to the left.The `as_field_group` method renders
    each field including help text and errors. This method uses the `django/forms/field.html`
    template by default. You can see the contents of this template at [https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html](https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html).
    You can also create custom field templates and reuse them by adding the `template_name`
    attribute to any form field. You can read more about reusable form templates at
    [https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates](https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a blog post and take a look at the comment form. The form should now look
    like *Figure 2.31*:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_02_31.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.31: The comment form with the new HTML markup'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: The `name` and `email` fields are now displayed next to each other. Field groups
    allow you to easily customize form rendering.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to define canonical URLs for models. You created
    SEO-friendly URLs for blog posts, and you implemented object pagination for your
    post list. You also learned how to work with Django forms and model forms. You
    created a system to recommend posts by email and created a comment system for
    your blog.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will create a tagging system for the blog. You will
    learn how to build complex QuerySets to retrieve objects by similarity. You will
    learn how to create custom template tags and filters. You will also build a custom
    sitemap and feed for your blog posts and implement full-text search functionality
    for your posts.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02)'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'URL utility functions: [https://docs.djangoproject.com/en/5.0/ref/urlresolvers/](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'URL path converters: [https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters](https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters)'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django paginator class: [https://docs.djangoproject.com/en/5.0/ref/paginator/](https://docs.djangoproject.com/en/5.0/ref/paginator/)'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to class-based views – [https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/](https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/)
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sending emails with Django: [https://docs.djangoproject.com/en/5.0/topics/email/](https://docs.djangoproject.com/en/5.0/topics/email/)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `python-decouple` library: [https://github.com/HBNetwork/python-decouple](https://github.com/HBNetwork/python-decouple)'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `django-anymail` library: [https://anymail.dev/en/stable/installation/](https://anymail.dev/en/stable/installation/)'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `django-anymail` supported email service providers: [https://anymail.dev/en/stable/esps/](https://anymail.dev/en/stable/esps/)'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django form field types: [https://docs.djangoproject.com/en/5.0/ref/forms/fields/](https://docs.djangoproject.com/en/5.0/ref/forms/fields/)'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with forms: [https://docs.djangoproject.com/en/5.0/topics/forms/](https://docs.djangoproject.com/en/5.0/topics/forms/)'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating forms from models: [https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/](https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/)'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many-to-one model relationships: [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/)'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default form field template: [https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html](https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html)'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reusable field group templates: [https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates](https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates)'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
