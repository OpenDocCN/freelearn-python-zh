<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Introduction to Web Scraping</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Introduction to Web Scraping</h1>
            </header>

            <article>
                
<p>Welcome to the wide world of web scraping! Web scraping is used by many fields to collect data not easily available in other formats. You could be a journalist, working on a new story, or a data scientist extracting a new dataset. Web scraping is a useful tool even for just a casual programmer, if you need to check your latest homework assignments on your university page and have them emailed to you. Whatever your motivation, we hope you are ready to learn!</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introducing the field of web scraping</li>
<li>Explaining the legal challenges</li>
<li>Explaining Python 3 setup</li>
<li>Performing background research on our target website</li>
<li>Progressively building our own advanced web crawler</li>
<li>Using non-standard libraries to help scrape the Web</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">When is web scraping useful?</h1>
            </header>

            <article>
                
<p>Suppose I have a shop selling shoes and want to keep track of my competitor's prices. I could go to my competitor's website each day and compare each shoe's price with my own; however this will take a lot of time and will not scale well if I sell&#160;thousands of shoes or need to check price changes frequently. Or maybe I just want to buy a shoe when it's on sale. I could come back and check the shoe website each day until I get lucky, but the shoe I want might not be on sale for months. These repetitive manual processes could instead be replaced with an automated solution using the web scraping techniques covered in this book.</p>
<p>In an ideal world, web scraping wouldn't be necessary and each website would provide an API to share data in a structured format. Indeed, some websites do provide APIs, but they typically restrict the data that is available and how frequently it can be accessed. Additionally, a website developer might change, remove, or restrict&#160;the backend API. In short, we cannot rely on APIs to access the online data we may want. Therefore we need to learn about web scraping techniques.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Is web scraping legal?</h1>
            </header>

            <article>
                
<p>Web scraping, and what is legally permissible when web scraping, are still being established despite numerous rulings over the past two&#160;decades. If the scraped data is being used for personal and private use, and within fair use of&#160;copyright laws, there is usually no problem. However, if the data is going to be republished, if the scraping is aggressive enough to take down the site, or if the content is copyrighted and the scraper violates the terms of service, then there are several legal precedents to note.</p>
<p>In <em>Feist Publications, Inc. v. Rural Telephone Service Co.</em>, the United States Supreme Court decided scraping and republishing facts, such as telephone listings, are allowed. A similar case in Australia, <em>Telstra Corporation Limited v. Phone Directories Company Pty Ltd</em>, demonstrated that only data with an identifiable author can be copyrighted. Another scraped content case in the United States, evaluating the reuse of Associated Press stories for an aggregated news product, was ruled a violation of copyright in&#160;<em>Associated Press v. Meltwater.</em>&#160; A European Union case in Denmark, <em>ofir.dk vs home.dk</em>, concluded that regular crawling and deep linking is permissible.</p>
<p>There have also been several cases in which companies have charged the plaintiff with aggressive scraping and attempted to stop the scraping via a legal order. The most recent case,&#160;<em>QVC v. Resultly</em>, ruled that, unless the scraping resulted in private property damage, it could not be considered intentional harm, despite the crawler activity leading to some site stability issues.</p>
<p>These cases suggest that, when the scraped data constitutes public facts (such as business locations and telephone listings), it can be republished following fair use rules. However, if the data is original (such as opinions and reviews or private user data), it most likely cannot be republished for copyright reasons. In any case, when you are scraping data from a website, remember you are their guest and need to behave politely; otherwise, they may ban your IP address or proceed with legal action. This means you should make download requests at a reasonable rate and define a user agent to identify your crawler. You should also take measures to review the Terms of Service of the site and ensure the data you are taking is not considered private or copyrighted.</p>
<p>If you have doubts or questions, it may be worthwhile to consult a media lawyer regarding the precedents in your area of residence.&#160;</p>
<p><span>You can read more about these legal cases at the following sites:<br/></span></p>
<ul>
<li>&#160;<strong>Feist Publications&#160;Inc. v. Rural Telephone Service Co.</strong><br/>
(<a href="http://caselaw.lp.findlaw.com/scripts/getcase.pl?court=US&amp;vol=499&amp;invol=340">http://caselaw.lp.findlaw.com/scripts/getcase.pl?court=US&amp;vol=499&amp;invol=340</a>)</li>
<li><strong>Telstra Corporation Limited v. Phone Directories Company Pvt Ltd</strong>&#160;<br/>
(<a href="http://www.austlii.edu.au/au/cases/cth/FCA/2010/44.html">http://www.austlii.edu.au/au/cases/cth/FCA/2010/44.html</a>)</li>
</ul>
<ul>
<li><strong>Associated Press v.Meltwater</strong>&#160;<br/>
(<a href="http://www.nysd.uscourts.gov/cases/show.php?db=special&amp;id=279">http://www.nysd.uscourts.gov/cases/show.php?db=special&amp;id=279</a>)</li>
</ul>
<ul>
<li><strong>ofir.dk vs home.dk</strong><br/>
(<a href="http://www.bvhd.dk/uploads/tx_mocarticles/S_-_og_Handelsrettens_afg_relse_i_Ofir-sagen.pdf">http://www.bvhd.dk/uploads/tx_mocarticles/S_-_og_Handelsrettens_afg_relse_i_Ofir-sagen.pdf</a>)</li>
</ul>
<ul>
<li><strong>QVC v. Resultly</strong><br/>
(<a href="https://www.paed.uscourts.gov/documents/opinions/16D0129P.pdf">https://www.paed.uscourts.gov/documents/opinions/16D0129P.pdf</a>)</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Python 3</h1>
            </header>

            <article>
                
<p>Throughout this second edition of <em>Web Scraping with Python</em>, we will use Python 3. The Python Software Foundation has announced Python 2 will be phased out of development and support in 2020; for this reason, we and many other Pythonistas aim to move development to the support of Python 3, which at the time of this publication is at version 3.6. This book is complaint with Python 3.4+.</p>
<p>If you are familiar with using <a href="https://docs.python.org/3/library/venv.html">Python Virtual Environments</a>&#160;or <a href="https://www.continuum.io/downloads">Anaconda</a>, you likely already know how to set up Python 3 in a new environment. If you'd like to install Python 3 globally, we recommend searching for your operating system-specific documentation. For my part, I simply use <strong>Virtual Environment Wrapper</strong>&#160;(<a href="https://virtualenvwrapper.readthedocs.io/en/latest/">https://virtualenvwrapper.readthedocs.io/en/latest/</a>) to easily maintain many different environments for different projects and versions of Python. Using either Conda environments or virtual environments is highly recommended, so that you can easily change dependencies based on your project needs without affecting other work you are doing. For beginners, I recommend using Conda as it requires less setup. The Conda&#160;<em>introductory documentation</em>&#160;(<a href="https://conda.io/docs/intro.html">https://conda.io/docs/intro.html</a>) is a good place to start!</p>
<div class="packt_infobox">From this point forward, all code and commands will assume you have Python 3 properly installed and are working with a Python 3.4+ environment. If you see Import or Syntax errors, please check that you are in the proper environment and look for pesky Python 2.7 file paths in your Traceback.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Background research</h1>
            </header>

            <article>
                
<p>Before diving into crawling a website, we should develop an understanding about the scale and structure of our target website. The website itself can help us via&#160;the&#160;<kbd>robots.txt</kbd> and <kbd>Sitemap</kbd> files, and there are also external tools available to provide further details such as Google Search and <kbd>WHOIS</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Checking robots.txt</h1>
            </header>

            <article>
                
<p>Most websites define a <kbd>robots.txt</kbd> file to let crawlers know of any restrictions when&#160;crawling their website. These restrictions are just a suggestion but good web citizens will follow them. The <kbd>robots.txt</kbd> file is a valuable resource to check before crawling to minimize the chance of being blocked, and to discover clues about the website's structure. More information about the <kbd>robots.txt</kbd> protocol is available at <a href="http://www.robotstxt.org"><span class="URLPACKT">http://www.robotstxt.org</span></a>. The following code is the content of our example <kbd>robots.txt</kbd>, which is available at <a href="http://example.webscraping.com/robots.txt"><span class="URLPACKT">http://example.webscraping.com/robots.txt</span></a>:</p>
<pre># section 1 <br/>User-agent: BadCrawler <br/>Disallow: / <br/><br/># section 2 <br/>User-agent: * <br/>Crawl-delay: 5 <br/>Disallow: /trap <br/><br/># section 3 <br/>Sitemap: http://example.webscraping.com/sitemap.xml 
</pre>
<p>In section 1, the <kbd>robots.txt</kbd> file asks a crawler with user agent <kbd>BadCrawler</kbd> not to crawl their website, but this is unlikely to help because a malicious crawler would not respect <kbd>robots.txt</kbd> anyway. A later example in this chapter will show you how to make your crawler follow <kbd>robots.txt</kbd> automatically.</p>
<p>Section 2 specifies a crawl delay of 5 seconds between download requests for all user-agents, which should be respected to avoid overloading their server(s). There is also a <kbd>/trap</kbd> link to try to block malicious crawlers who follow disallowed links. If you visit this link, the server will block your IP for one minute! A real website would block your IP for much longer, perhaps permanently, but then we could not continue with this example.</p>
<p>Section 3 defines a <kbd>Sitemap</kbd> file, which will be examined in the next section.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Examining the Sitemap</h1>
            </header>

            <article>
                
<p><kbd>Sitemap</kbd> files are provided bywebsites to help crawlers locate their updated content without needing to crawl every web page. For further details, the sitemap standard is defined at <a href="http://www.sitemaps.org/protocol.html"><span class="URLPACKT">http://www.sitemaps.org/protocol.html</span></a>. Many web publishing platforms have the ability to generate a sitemap automatically. Here is the content of the &#160;<kbd>Sitemap</kbd> file located in the listed&#160;<kbd>robots.txt</kbd> file:</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"&gt; <br/>  &lt;url&gt;&lt;loc&gt;http://example.webscraping.com/view/Afghanistan-1&lt;/loc&gt;&lt;/url&gt; <br/>  &lt;url&gt;&lt;loc&gt;http://example.webscraping.com/view/Aland-Islands-2&lt;/loc&gt;&lt;/url&gt; <br/>  &lt;url&gt;&lt;loc&gt;http://example.webscraping.com/view/Albania-3&lt;/loc&gt;&lt;/url&gt; <br/>  ... <br/>&lt;/urlset&gt; 
</pre>
<p>This sitemap provides links to all the web pages, which will be used in the next section to build our first crawler. <kbd>Sitemap</kbd> files provide an efficient way to crawl a website, but need to be treated carefully because they can be&#160;missing, out-of-date, or incomplete.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Estimating the size of a website</h1>
            </header>

            <article>
                
<p>The size of the target website will affect how we crawl it. If the website is just a few hundred URLs, such as our example website, efficiency is not important. However, if the website has over a million web pages, downloading each sequentially would take months. This problem is addressed later in <a href="py-web-scrp-2e_ch04.html"><span class="ChapterrefPACKT">Chapter 4</span></a> , <em>Concurrent Downloading</em>, on distributed downloading.</p>
<p>A quick way to estimate the size of a website is to check the results of Google's crawler, which has quite likely already crawled the website we are interested in. We can access this information through a Google search with the <kbd>site</kbd> keyword to filter the results to our domain. An interface to this and other advanced search parameters are available at <a href="http://www.google.com/advanced_search"><span class="URLPACKT">http://www.google.com/advanced_search</span></a>.</p>
<p>Here are the site search results for our example website when searching Google for <kbd><span class="URLPACKT">site:example.webscraping.com</span></kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="images/image_01_001.jpg" width="443" height="348"/></div>
<p>As we can see, Google currently estimates more than 200 web pages (this result may vary), which is around the website size. For larger websites, Google's estimates may be less accurate.</p>
<p>We can filter these results to certain parts of the website by adding a URL path to the domain. Here are the results for <kbd>site:example.webscraping.com/view</kbd>, which restricts the site search to the country web pages:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="images/image_01_002.jpg" width="444" height="343"/></div>
<p>Again, your results may vary in size; however, this additional filter is useful because ideally you only want to crawl the part of a website containing useful data rather than every page.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Identifying the technology used by a website</h1>
            </header>

            <article>
                
<p>The type of technology used to build a websitewill&#160;affect how we crawl it. A useful tool to check the kind of technologies a website is built with is the module <kbd>detectem</kbd>, which requires Python 3.5+ and Docker. If you don't already have Docker installed, follow the instructions for your operating system at&#160;<a href="https://www.docker.com/products/overview">https://www.docker.com/products/overview</a>. Once Docker is installed, you can run the following commands.</p>
<pre><strong>docker pull scrapinghub/splash</strong><br/><strong>pip install detectem</strong>
</pre>
<p>This will pull the latest Docker image from ScrapingHub and install the package via <kbd>pip</kbd>. It is recommended to use a Python virtual environment (<a href="https://docs.python.org/3/library/venv.html">https://docs.python.org/3/library/venv.html</a>) or a Conda environment (<a href="https://conda.io/docs/using/envs.html)">https://conda.io/docs/using/envs.html)</a> and to check the project's ReadMe page (<a href="https://github.com/spectresearch/detectem">https://github.com/spectresearch/detectem</a>) for any updates or changes.</p>
<div class="packt_infobox"><span class="packt_screen">Why use environments?<br/></span>Imagine if your project was developed with an earlier version of a library such as&#160;<kbd>detectem</kbd>, and then, in a later version, <kbd><span><span>detectem</span></span></kbd>&#160;introduced some backwards-incompatible changes that break your project. However, different&#160;projects you are working on would like to use the newer version.&#160;If your project uses the system-installed <kbd>detectem</kbd>, it is eventually going to break when libraries&#160;are updated to support other projects.<br/>
Ian Bicking's <kbd>virtualenv</kbd> provides a clever hack to this problem by copying the system Python executable and its dependencies into a local directory to create an isolated Python environment. This allows a project to install specific versions of Python libraries locally and independently of the wider system. You can even utilize different versions of Python in different virtual environments. Further details are available in the documentation at <a href="https://virtualenv.pypa.io"><span class="URLPACKT">https://virtualenv.pypa.io</span></a>. Conda environments offer similar functionality using the Anaconda Python path.</div>
<p>The <kbd>detectem</kbd>&#160;module uses a series of requests and responses to detect technologies used by the website, based on a series of extensible modules. It uses Splash (<a href="https://github.com/scrapinghub/splash">https://github.com/scrapinghub/splash</a>), a scriptable browser developed by ScrapingHub (<a href="https://scrapinghub.com/">https://scrapinghub.com/</a>). To run the module, simply use the <kbd>det</kbd> command:</p>
<pre>    <strong>   $</strong> <strong>det</strong> <strong>http://example.webscraping.com<br/>       [('jquery', '1.11.0')]</strong>
</pre>
<p>We can see the example website uses a&#160;common JavaScript library, so its content is likely embedded in the HTML and should be relatively straightforward to scrape.</p>
<p>Detectem is still fairly young and aims to eventually have Python parity to Wappalyzer (<a href="https://github.com/AliasIO/Wappalyzer">https://github.com/AliasIO/Wappalyzer</a>), a Node.js-based project supporting parsing of many different backends as well as ad networks, JavaScript libraries, and server setups. You can also run Wappalyzer via Docker. To first download the Docker image, run:</p>
<pre><strong>$ docker pull wappalyzer/cli</strong>
</pre>
<p>Then, you can run the script from the Docker instance:</p>
<pre><strong>$ docker run wappalyzer/cli http://example.webscraping.com</strong>
</pre>
<p>The output is a bit hard to read, but if we copy and paste it into a JSON linter, we can see the many different libraries and technologies detected:</p>
<pre>{'applications': <br/>[{'categories': ['Javascript Frameworks'],<br/>     'confidence': '100',<br/>     'icon': 'Modernizr.png',<br/>     'name': 'Modernizr',<br/>     'version': ''},<br/> {'categories': ['Web Servers'],<br/>     'confidence': '100',<br/>     'icon': 'Nginx.svg',<br/>     'name': 'Nginx',<br/>     'version': ''},<br/> {'categories': ['Web Frameworks'],<br/>     'confidence': '100',<br/>     'icon': 'Twitter Bootstrap.png',<br/>     'name': 'Twitter Bootstrap',<br/>     'version': ''},<br/> {'categories': ['Web Frameworks'],<br/>     'confidence': '100',<br/>     'icon': 'Web2py.png',<br/>     'name': 'Web2py',<br/>     'version': ''},<br/> {'categories': ['Javascript Frameworks'],<br/>     'confidence': '100',<br/>     'icon': 'jQuery.svg',<br/>     'name': 'jQuery',<br/>     'version': ''},<br/> {'categories': ['Javascript Frameworks'],<br/>     'confidence': '100',<br/>     'icon': 'jQuery UI.svg',<br/>     'name': 'jQuery UI',<br/>     'version': '1.10.3'},<br/> {'categories': ['Programming Languages'],<br/>     'confidence': '100',<br/>     'icon': 'Python.png',<br/>     'name': 'Python',<br/>     'version': ''}],<br/> 'originalUrl': 'http://example.webscraping.com',<br/> 'url': 'http://example.webscraping.com'}
</pre>
<p>Here, we can see that Python and the <kbd>web2py</kbd> frameworks were detected with very high confidence. We can also see that the frontend CSS framework Twitter Bootstrap is used. Wappalyzer also detected Modernizer.js and the use of Nginx as the backend server. Because the site is only using JQuery and Modernizer, it is unlikely the entire page is loaded by JavaScript.&#160;If the website was instead built with AngularJS or React, then its content would likely be loaded dynamically. Or, if the website used ASP.NET, it would be necessary to use sessions and form submissions to crawl web pages. Working with these more difficult cases will be covered later in <a href="py-web-scrp-2e_ch05.html" target="_blank"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Dynamic Content</em> and <a href="py-web-scrp-2e_ch06.html" target="_blank"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Interacting with Forms</em>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Finding the owner of a website</h1>
            </header>

            <article>
                
<p>For some websites it may matter to us who&#160;the owner is. For example, if the owner is known to block web crawlers then it would be wise to be more conservative in our download rate. To find who owns a website we can use the <kbd>WHOIS</kbd> protocol to see who is the registered owner of the domain name. A Python wrapper to this protocol, documented at <a href="https://pypi.python.org/pypi/python-whois"><span class="URLPACKT">https://pypi.python.org/pypi/python-whois</span></a>, can be installed via <kbd>pip</kbd>:</p>
<pre>   <strong>pip install python-whois</strong>
</pre>
<p>Here is the most informative&#160;part of the <kbd>WHOIS</kbd> response when querying the appspot.com domain with this module:</p>
<pre>   <strong>&gt;&gt;&gt; import whois</strong><br/><strong>   &gt;&gt;&gt; print(whois.whois('appspot.com'))</strong><br/><strong>    {</strong><br/><strong>      ...</strong><br/><strong>      "name_servers": [</strong><br/><strong>        "NS1.GOOGLE.COM", </strong><br/><strong>        "NS2.GOOGLE.COM", </strong><br/><strong>        "NS3.GOOGLE.COM", </strong><br/><strong>        "NS4.GOOGLE.COM", </strong><br/><strong>        "ns4.google.com", </strong><br/><strong>        "ns2.google.com", </strong><br/><strong>        "ns1.google.com", </strong><br/><strong>        "ns3.google.com"</strong><br/><strong>      ], </strong><br/><strong>      "org": "Google Inc.", </strong><br/><strong>      "emails": [</strong><br/><strong>        "abusecomplaints@markmonitor.com", </strong><br/><strong>        "dns-admin@google.com"</strong><br/><strong>      ]</strong><br/><strong>    }</strong>
</pre>
<p>We can see here that this domain is owned by Google, which is correct; this domain is for the Google App Engine service. Google often blocks web crawlers despite being fundamentally a web crawling business themselves. We would need to be careful when crawling this domain because Google often blocks IPs that quickly scrape their services; and you, or someone you live or work with, might need to use Google services. I have experienced being asked to enter captchas to use Google services for short periods, even after running only simple search crawlers on Google domains.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Crawling your first website</h1>
            </header>

            <article>
                
<p>In order to scrape a website, we first need to download its web pages containing the data of interest, a process known as <strong>crawling</strong>. There are a number of approaches that can be used to crawl a website, and the appropriate choice will depend on the structure of the target website. This chapter will explore how to download web pages safely, and then introduce the following three common approaches to crawling a website:</p>
<ul>
<li>Crawling a sitemap</li>
<li>Iterating each page using database IDs&#160;</li>
<li>Following web page links</li>
</ul>
<p>We have so far used the terms scraping and crawling interchangeably, but let's take a moment to define the similarities and differences in these two approaches.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Scraping versus crawling</h1>
            </header>

            <article>
                
<p>Depending on the information you are after and the site content and structure, you may need to either build a web scraper or a website crawler. What is the difference?</p>
<p>A web scraper is usually built to target a particular website or sites and to garner specific information on those sites. A web scraper is built to access these specific pages and will need to be modified if the site changes or if the information location on the site is changed. For example, you might want to build a web scraper to check the daily specials at your favorite local restaurant, and to do so you would scrape the part of their site where they regularly update that information.&#160;</p>
<p>In contrast, a web crawler is usually built in a generic way; targeting either websites from a series of top-level domains or for the entire web. Crawlers can be built to gather more specific information, but are usually used to <em>crawl</em> the web, picking up small and generic bits of information from many different sites or pages and following links to other pages.</p>
<p>In addition to crawlers and scrapers, we will also cover web spiders in <a href="py-web-scrp-2e_ch08.html" target="_blank">Chapter 8</a>,&#160;<em>Scrapy.</em> Spiders&#160;can be used for crawling a specific set of sites or for broader crawls across many sites or even the Internet.</p>
<p>Generally, we will use specific&#160;terms to reflect our use cases; as you develop your web scraping, you may notice distinctions in technologies, libraries, and packages you may want to use. In these cases, your knowledge of the differences in these terms will help you select an appropriate package or technology based on the terminology used (<span>such as,</span>&#160;is it only for scraping? Is it also for spiders?).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Downloading a web page</h1>
            </header>

            <article>
                
<p>To scrape web pages, we first need to download them. Here is a simple Python script that uses Python's <kbd>urllib</kbd>&#160;module to download a URL:</p>
<pre>import urllib.request<br/>def download(url): <br/>    return urllib.request.urlopen(url).read() 
</pre>
<p>When a URL is passed, this function will download the web page and return the HTML. The problem with this snippet is that, when downloading the web page, we might encounter errors that are beyond our control; for example, the requested page may no longer exist. In these cases, <kbd>urllib</kbd>&#160;will raise an exception and exit the script. To be safer, here is a more robust version to catch these exceptions:</p>
<pre>import urllib.request<br/>from urllib.error import URLError, HTTPError, ContentTooShortError<br/><br/>def download(url):<br/>    print('Downloading:', url)<br/>    try:<br/>        html = urllib.request.urlopen(url).read()<br/>    except (URLError, HTTPError, ContentTooShortError) as e:<br/>        print('Download error:', e.reason)<br/>        html = None<br/>    return html
</pre>
<p>Now, when a download or URL error is encountered, the exception is caught and the function returns <kbd>None</kbd>.</p>
<div class="packt_infobox packt_tip">Throughout this book, we will assume you are creating files with code that is presented without prompts (like the code above). When you see code that begins with a Python prompt <kbd>&gt;&gt;&gt;</kbd>&#160;or and IPython prompt <kbd>In [1]:</kbd>, you will need to either enter that into the main file you have been using, or save the file and import those functions and classes into your Python interpreter. If you run into any issues, please take a look at the code in the book repository at <a href="https://github.com/kjam/wswp">https://github.com/kjam/wswp</a>.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Retrying downloads</h1>
            </header>

            <article>
                
<p>Often, the errors encountered when downloading are temporary; an example is when the web server is overloaded and returns a <kbd>503 Service Unavailable</kbd> error. For these errors, we can retry the download after a short time because the server problem may now be resolved. However, we do not want to retry downloading for all errors. If the server returns <kbd>404 Not Found</kbd>, then the web page does not currently exist and the same request is unlikely to produce a different result.</p>
<p>The full list of possible HTTP errors is defined by the <em>Internet Engineering Task Force</em>, and is available for viewing at <a href="https://tools.ietf.org/html/rfc7231#section-6"><span class="URLPACKT">https://tools.ietf.org/html/rfc7231#section-6</span></a>. In this document, we can see that&#160;<kbd>4xx</kbd> errors occur when there is something wrong with our request and&#160;<kbd>5xx</kbd> errors occur when there is something wrong with the server. So, we will ensure our <kbd>download</kbd> function only retries the <kbd>5xx</kbd> errors. Here is the updated version to support this:</p>
<pre>def download(url, num_retries=2): <br/>    print('Downloading:', url)<br/>    try: <br/>        html = urllib.request.urlopen(url).read()<br/>    except (URLError, HTTPError, ContentTooShortError) as e: <br/>        print('Download error:', e.reason)<br/>        html = None <br/>        if num_retries &gt; 0: <br/>                 if hasattr(e, 'code') and 500 &lt;= e.code &lt; 600: <br/>                # recursively retry 5xx HTTP errors <br/>                return download(url, num_retries - 1) <br/>    return html
</pre>
<p>Now, when a <kbd>download</kbd> error is encountered with a <kbd>5xx</kbd> code, the <kbd>download</kbd>&#160;error is retried by recursively calling itself. The function now also takes an additional argument for the number of times the download can be retried, which is set to two times by default. We limit the number of times we attempt to download a web page because the server error may not recover. To test this functionality we can try downloading <a href="http://httpstat.us/500"><span class="URLPACKT">http://httpstat.us/500</span></a>, which returns the 500 error code:</p>
<pre><strong>    &gt;&gt;&gt; download('http://httpstat.us/500')</strong><br/><strong>Downloading: http://httpstat.us/500</strong><br/><strong>Download error: Internal Server Error</strong><br/><strong>Downloading: http://httpstat.us/500</strong><br/><strong>Download error: Internal Server Error</strong><br/><strong>Downloading: http://httpstat.us/500</strong><br/><strong>Download error: Internal Server Error</strong>
</pre>
<p>As expected, the <kbd>download</kbd> function now tries downloading the web page, and then, on receiving the 500 error, it retries the download twice before giving up.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Setting a user agent</h1>
            </header>

            <article>
                
<p>By default, <kbd>urllib</kbd>&#160;will download content with the <kbd>Python-urllib/3.x</kbd>&#160;user agent, where <kbd><span><span>3.x</span></span></kbd>&#160;is the environment's current version of <kbd>Python</kbd>. It would be preferable to use an identifiable user agent in case problems occur with our web crawler. Also, some websites block this default user agent, perhaps after they have experienced a poorly made Python web crawler overloading their server. For example, &#160;<a href="http://www.meetup.com/"><span class="URLPACKT">http://www.meetup.com/</span></a> currently returns a <kbd>403 Forbidden&#160;</kbd>when requesting the page with&#160;<kbd>urllib</kbd>'s default user agent.</p>
<p>To download sites reliably, we will need to have control over setting the user agent. Here is an updated version of our <kbd>download</kbd> function with the default user agent set to <kbd>'wswp'</kbd> (which stands for<strong>Web Scraping with Python</strong>):</p>
<pre>def download(url, user_agent='wswp', num_retries=2): <br/>    print('Downloading:', url) <br/>    request = urllib.request.Request(url) <br/>    request.add_header('User-agent', user_agent)<br/>    try: <br/>        html = urllib.request.urlopen(request).read() <br/>    except (URLError, HTTPError, ContentTooShortError) as e:<br/>        print('Download error:', e.reason)<br/>        html = None <br/>        if num_retries &gt; 0: <br/>            if hasattr(e, 'code') and 500 &lt;= e.code &lt; 600: <br/>                # recursively retry 5xx HTTP errors <br/>                return download(url, num_retries - 1) <br/>    return html
</pre>
<p>If you now try meetup.com, you will see valid HTML. Our download function can now be reused in later code&#160;to catch errors, retry the site&#160;when possible, and set the user agent.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Sitemap crawler</h1>
            </header>

            <article>
                
<p>For our first simple crawler, we will use the sitemap discovered in the example website's <kbd>robots.txt</kbd> to download all the web pages. To parse the sitemap, we will use a simple regular expression to extract URLs within the <kbd>&lt;loc&gt;</kbd> tags.</p>
<p>We will need to update our code to handle encoding conversions as our current <kbd>download</kbd> function simply returns bytes.&#160;Note that a more robust parsing approach called <strong>CSS selectors</strong> will be introduced in the next chapter. Here is our first example crawler:</p>
<pre>import re<br/><br/>def download(url, user_agent='wswp', num_retries=2, charset='utf-8'): <br/>    print('Downloading:', url) <br/>    request = urllib.request.Request(url) <br/>    request.add_header('User-agent', user_agent)<br/>    try: <br/>        resp = urllib.request.urlopen(request)<br/>        cs = resp.headers.get_content_charset()<br/>        if not cs:<br/>            cs = charset<br/>        html = resp.read().decode(cs)<br/>    except (URLError, HTTPError, ContentTooShortError) as e:<br/>        print('Download error:', e.reason)<br/>        html = None <br/>        if num_retries &gt; 0: <br/>            if hasattr(e, 'code') and 500 &lt;= e.code &lt; 600: <br/>            # recursively retry 5xx HTTP errors <br/>            return download(url, num_retries - 1) <br/>    return html<br/><br/>def crawl_sitemap(url): <br/>    # download the sitemap file <br/>    sitemap = download(url) <br/>    # extract the sitemap links <br/>    links = re.findall('&lt;loc&gt;(.*?)&lt;/loc&gt;', sitemap) <br/>    # download each link <br/>    for link in links: <br/>        html = download(link) <br/>        # scrape html here <br/>        # ... 
</pre>
<p>Now, we can run the sitemap crawler to download all countries from the example website:</p>
<pre>    <strong>&gt;&gt;&gt; crawl_sitemap('http://example.webscraping.com/sitemap.xml')</strong><br/><strong>Downloading: http://example.webscraping.com/sitemap.xml</strong><br/><strong>Downloading: http://example.webscraping.com/view/Afghanistan-1</strong><br/><strong>Downloading: http://example.webscraping.com/view/Aland-Islands-2</strong><br/><strong>Downloading: http://example.webscraping.com/view/Albania-3</strong><br/><strong>...</strong>
</pre>
<p>As shown in our <kbd>download</kbd> method above, we had to update the character encoding to utilize regular expressions with the website response. The Python&#160;<kbd>read</kbd> method on the response will return bytes, and the&#160;<kbd>re</kbd> module expects a string. Our code depends on the website maintainer to include the proper character encoding in the response headers. If the character encoding header is not returned, we default to UTF-8 and hope for the best. Of course, this decoding will throw an error if either the header encoding returned is incorrect or if the encoding is not set and also not UTF-8. There are some more complex ways to guess encoding (see:&#160;<a href="https://pypi.python.org/pypi/chardet">https://pypi.python.org/pypi/chardet</a>), which are fairly easy&#160;to implement.</p>
<p>For now, the Sitemap crawler works as expected. But as discussed earlier, <kbd>Sitemap</kbd> files often cannot be relied on to provide links to every web page. In the next section, another simple crawler will be introduced that does not depend on the <kbd>Sitemap</kbd> file.</p>
<div class="packt_infobox">If you don't want to continue the crawl at any time you can hit <em>Ctrl + C</em> or c<em>md</em> + <em>C</em> to exit the Python interpreter or program execution.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">ID iteration crawler</h1>
            </header>

            <article>
                
<p>In this section, we will take advantage of a weakness in the website structure to easily access all the content. Here are the URLs of some sample countries:</p>
<ul>
<li><a href="http://example.webscraping.com/view/Afghanistan-1"><span class="URLPACKT">http://example.webscraping.com/view/Afghanistan-1</span></a></li>
<li><a href="http://example.webscraping.com/view/Australia-2"><span class="URLPACKT">http://example.webscraping.com/view/Australia-2</span></a></li>
<li><a href="http://example.webscraping.com/view/Brazil-3"><span class="URLPACKT">http://example.webscraping.com/view/Brazil-3</span></a></li>
</ul>
<p>We can see that the URLs only differ in the final section of the URL path, with the country name (known as a slug) and ID. It is a common practice to include a slug in the URL to help with search engine optimization. Quite often, the web server will ignore the slug and only use the ID to match relevant records in the database. Let's check whether this works with our example website by removing the slug and checking the page&#160;<span class="URLPACKT"><a href="http://example.webscraping.com/view/1">http://example.webscraping.com/view/1</a>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/chp1_using_id_to_load_page.png" width="897" height="674"/></div>
<p>The web page still loads! This is useful to know because now we can ignore the slug and simply utilize database IDs to download all the countries. Here is an example code snippet that takes advantage of this trick:</p>
<pre>import itertools <br/><br/>def crawl_site(url):<br/>    for page in itertools.count(1): <br/>        pg_url = '{}{}'.format(url, page) <br/>        html = download(pg_url) <br/>        if html is None: <br/>            break <br/>        # success - can scrape the result
</pre>
<p>Now we can use the function by passing in the base URL:</p>
<pre><strong>&gt;&gt;&gt; crawl_site('http://example.webscraping.com/view/-')<br/>Downloading: http://example.webscraping.com/view/-1<br/>Downloading: http://example.webscraping.com/view/-2<br/>Downloading: http://example.webscraping.com/view/-3<br/>Downloading: http://example.webscraping.com/view/-4<br/>[...]</strong>
</pre>
<p>Here, we iterate the ID until we encounter a download error, which we assume means our scraper has reached the last country. A weakness in this implementation is that some records may have been deleted, leaving gaps in the database IDs. Then, when one of these gaps is reached, the crawler will immediately exit. Here is an improved version of the code that allows a number of consecutive download errors before exiting:</p>
<pre>def crawl_site(url, max_errors=5):<br/>    for page in itertools.count(1): <br/>        pg_url = '{}{}'.format(url, page) <br/>        html = download(pg_url) <br/>        if html is None: <br/>            num_errors += 1<br/>            if num_errors == max_errors:<br/>                # max errors reached, exit loop<br/>                break<br/>        else:<br/>            num_errors = 0<br/>            # success - can scrape the result
</pre>
<p>The crawler in the preceding code now needs to encounter five consecutive <kbd>download</kbd> errors to stop iteration, which decreases the risk of stopping iteration prematurely when some records have been deleted or hidden.</p>
<p>Iterating the IDs is a convenient approach to crawling a website, but is similar to the sitemap approach in that it will not always be available. For example, some websites will check whether the slug is found in the URL and if not return a <kbd>404 Not Found</kbd> error. Also, other websites use large nonsequential or nonnumeric IDs, so iterating is not practical. For example, Amazon uses ISBNs, as the ID for the available books, that have at least ten digits. Using an ID iteration for ISBNs&#160;would require testing billions of possible combinations, which is certainly not the most efficient approach to scraping the website content.</p>
<p>As you've been following along, you might have noticed some download errors with the message&#160;<kbd>TOO MANY REQUESTS</kbd>&#160;. Don't worry about them at the moment; we will cover more about handling these types of error in the <em>Advanced Features</em>&#160;section of this chapter.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Link crawlers</h1>
            </header>

            <article>
                
<p>So far, we have implemented two simple crawlers that take advantage of the structure of our sample website to download all published&#160;countries. These techniques should be used when available, because they minimize the number of web pages to download. However, for other websites, we need to make our crawler act more like a typical user and follow links to reach the interesting content.</p>
<p>We could simply download the entire website by following every link. However, this would likely download many&#160;web pages we don't need. For example, to scrape user account details from an online forum, only account pages need to be downloaded and not discussion threads. The link crawler we use in this chapter&#160;will use regular expressions to determine which web pages it should download. Here is an initial version of the code:</p>
<pre>import re <br/><br/>def link_crawler(start_url, link_regex): <br/>    """ Crawl from the given start URL following links matched by link_regex <br/>    """ <br/>    crawl_queue = [start_url] <br/>    while crawl_queue: <br/>        url = crawl_queue.pop() <br/>        html = download(url) <br/>        if html is not None:<br/>            continue<br/>        # filter for links matching our regular expression <br/>        for link in get_links(html): <br/>            if re.match(link_regex, link): <br/>                crawl_queue.append(link) <br/><br/>def get_links(html): <br/>    """ Return a list of links from html <br/>    """ <br/>    # a regular expression to extract all links from the webpage <br/>    webpage_regex = re.compile("""&lt;a[^&gt;]+href=["'](.*?)["']""", re.IGNORECASE) <br/>    # list of all links from the webpage <br/>    return webpage_regex.findall(html) 
</pre>
<p>To run this code, simply call the <kbd>link_crawler</kbd> function with the URL of the website you want to crawl and a regular expression&#160;to match&#160;links you want&#160;to follow. For the example website, we want to crawl the index with the list of countries and the countries themselves.</p>
<p>We know from looking at the site that the index links follow this format:</p>
<ul>
<li><a href="http://example.webscraping.com/index/1"><span class="URLPACKT">http://example.webscraping.com/index/1</span></a></li>
<li><a href="http://example.webscraping.com/index/2"><span class="URLPACKT">http://example.webscraping.com/index/2</span></a></li>
</ul>
<p>The country web pages follow this format:</p>
<ul>
<li><a href="http://example.webscraping.com/view/Afghanistan-1"><span class="URLPACKT">http://example.webscraping.com/view/Afghanistan-1</span></a></li>
<li><a href="http://example.webscraping.com/view/Aland-Islands-2"><span class="URLPACKT">http://example.webscraping.com/view/Aland-Islands-2</span></a></li>
</ul>
<p>So a simple regular expression to match both types of web page is <kbd>/(index|view)/</kbd>. What happens when the crawler is run with these inputs? You receive the following <kbd>download</kbd> error:</p>
<pre><strong>&gt;&gt;&gt; link_crawler('http://example.webscraping.com', '/(index|view)/') <br/>Downloading: http://example.webscraping.com <br/>Downloading: /index/1 <br/>Traceback (most recent call last): <br/>  ... <br/>ValueError: unknown url type: /index/1</strong> 
</pre>
<div class="packt_infobox">Regular expressions are great tools for extracting information from strings, and I recommend every programmer <a href="https://regexone.com/">learn how to read and write a few of them</a>. That said, they tend to be quite brittle and easily break. We'll cover more advanced ways to extract links and identify their pages as we advance through the book.</div>
<p>The problem with downloading <kbd>/index/1</kbd> is that it only includes the path of the web page and leaves out the protocol and server, which is known as a <strong>relative link</strong>. Relative links work when browsing because the web browser knows which web page you are currently viewing and takes the steps necessary to resolve the link. However, <kbd>urllib</kbd> doesn't have&#160;this context. To help <kbd>urllib</kbd>&#160;locate the web page, we need to convert this link into an <strong>absolute link</strong>, which includes all the details to locate the web page. As might be expected, Python includes a module in <kbd>urllib</kbd>&#160;to do just this, called <kbd>parse</kbd>. Here is an improved version of <kbd>link_crawler</kbd> that uses the <kbd>urljoin</kbd>&#160;method to create the absolute links:</p>
<pre>from urllib.parse import urljoin<br/><br/>def link_crawler(start_url, link_regex): <br/>    """ Crawl from the given start URL following links matched by link_regex <br/>    """ <br/>    crawl_queue = [start_url] <br/>    while crawl_queue: <br/>        url = crawl_queue.pop() <br/>        html = download(url) <br/>        if not html:<br/>            continue<br/>        for link in get_links(html): <br/>            if re.match(link_regex, link): <br/>                abs_link = urljoin(start_url, link) <br/>                crawl_queue.append(abs_link) 
</pre>
<p>When this example is run, you can see it&#160;downloads the matching web&#160;pages; however, it keeps downloading the same locations over and over. The reason for this behavior is that these locations have links to each other. For example, Australia links to Antarctica and Antarctica links back to Australia, so&#160;the crawler will continue to queue the URLs and never reach the end of the queue. To prevent re-crawling the same links, we need to keep track of what's already been crawled. The following updated version of <kbd>link_crawler</kbd>&#160;stores the URLs seen before, to avoid downloading duplicates:</p>
<pre>def link_crawler(start_url, link_regex): <br/>    crawl_queue = [start_url] <br/>    # keep track which URL's have seen before <br/>    seen = set(crawl_queue) <br/>    while crawl_queue: <br/>        url = crawl_queue.pop() <br/>        html = download(url)<br/>        if not html:<br/>            continue <br/>        for link in get_links(html): <br/>            # check if link matches expected regex <br/>            if re.match(link_regex, link): <br/>                abs_link = urljoin(start_url, link) <br/>                # check if have already seen this link <br/>                if abs_link not in seen: <br/>                    seen.add(abs_link) <br/>                    crawl_queue.append(abs_link) 
</pre>
<p>When this script is run, it will crawl the locations and then stop as expected. We finally have a working link crawler!</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Advanced features</h1>
            </header>

            <article>
                
<p>Now, let's add some features to make our link crawler more useful for crawling other websites.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Parsing robots.txt</h1>
            </header>

            <article>
                
<p>First, we need to interpret <kbd>robots.txt</kbd> to avoid downloading blocked URLs. Python <kbd>urllib</kbd>&#160;comes with the <kbd>robotparser</kbd> module, which makes this straightforward, as follows:</p>
<pre>    <strong>&gt;&gt;&gt; from urllib import robotparser</strong><br/><strong>&gt;&gt;&gt; rp = robotparser.RobotFileParser()</strong><br/><strong>&gt;&gt;&gt; rp.set_url('http://example.webscraping.com/robots.txt')</strong><br/><strong>&gt;&gt;&gt; rp.read()</strong><br/><strong>&gt;&gt;&gt; url = 'http://example.webscraping.com'</strong><br/><strong>&gt;&gt;&gt; user_agent = 'BadCrawler'</strong><br/><strong>&gt;&gt;&gt; rp.can_fetch(user_agent, url)</strong><br/><strong>False</strong><br/><strong>&gt;&gt;&gt; user_agent = 'GoodCrawler'</strong><br/><strong>&gt;&gt;&gt; rp.can_fetch(user_agent, url)</strong><br/><strong>True</strong>
</pre>
<p>The <kbd>robotparser</kbd> module loads a <kbd>robots.txt</kbd> file and then provides a <kbd>can_fetch()</kbd>function, which tells you whether a particular user agent is allowed to access a web page or not. Here, when the user agent is set to <kbd>'BadCrawler'</kbd>, the <kbd>robotparser</kbd> module says that this web page can not be fetched, as we saw in the definition in the example site's&#160;<kbd>robots.txt</kbd>.</p>
<p>To integrate <kbd>robotparser</kbd>&#160;into the link crawler, we first want to create a new function to return the &#160;<kbd>robotparser</kbd> object:</p>
<pre>def get_robots_parser(robots_url):<br/>    " Return the robots parser object using the robots_url "<br/>    rp = robotparser.RobotFileParser()<br/>    rp.set_url(robots_url)<br/>    rp.read()<br/>    return rp
</pre>
<p>We need to reliably set the <kbd>robots_url</kbd>; we can do so by passing an extra keyword argument to our function. We can also set a default value catch in case the user does not pass the variable. Assuming the crawl will start at the root of the site, we can simply add <kbd>robots.txt</kbd> to the end of the URL. We also need to define the&#160;<kbd>user_agent</kbd>:</p>
<pre>def link_crawler(start_url, link_regex, robots_url=None, user_agent='wswp'):<br/>    ...<br/>    if not robots_url:<br/>        robots_url = '{}/robots.txt'.format(start_url)<br/>    rp = get_robots_parser(robots_url)
</pre>
<p>Finally, we add the parser check in the <kbd>crawl</kbd> loop:</p>
<pre>... <br/>while crawl_queue: <br/>    url = crawl_queue.pop() <br/>    # check url passes robots.txt restrictions <br/>    if rp.can_fetch(user_agent, url):<br/>         html = download(url, user_agent=user_agent) <br/>         ... <br/>    else: <br/>        print('Blocked by robots.txt:', url) 
</pre>
<p>We can test our advanced link crawler and its use of&#160;<kbd>robotparser</kbd> by using the bad user agent string.</p>
<pre><strong>&gt;&gt;&gt; link_crawler('http://example.webscraping.com', '/(index|view)/', user_agent='BadCrawler')<br/>Blocked by robots.txt: http://example.webscraping.com<br/></strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Supporting proxies</h1>
            </header>

            <article>
                
<p>Sometimes it's necessary to access a website through a proxy. For example, Hulu&#160;is blocked in many countries outside the United States as are some videos on YouTube.&#160;Supporting proxies with <kbd>urllib</kbd>&#160;is not as easy as it could be. We will cover <kbd>requests</kbd>&#160;for a more user-friendly Python HTTP module that can also handle proxies later in this chapter. Here's how to support a proxy with <kbd>urllib</kbd>:</p>
<pre>proxy = 'http://myproxy.net:1234' # example string <br/>proxy_support = urllib.request.ProxyHandler({'http': proxy})<br/>opener = urllib.request.build_opener(proxy_support)<br/>urllib.request.install_opener(opener) <br/># now requests via urllib.request will be handled via proxy
</pre>
<p>Here is an updated version of the <kbd>download</kbd> function to integrate this:</p>
<pre>def download(url, user_agent='wswp', num_retries=2, charset='utf-8', proxy=None): <br/>    print('Downloading:', url) <br/>    request = urllib.request.Request(url) <br/>    request.add_header('User-agent', user_agent)<br/>    try: <br/>        if proxy:<br/>            proxy_support = urllib.request.ProxyHandler({'http': proxy})<br/>            opener = urllib.request.build_opener(proxy_support)<br/>            urllib.request.install_opener(opener)<br/>        resp = urllib.request.urlopen(request)<br/>        cs = resp.headers.get_content_charset()<br/>        if not cs:<br/>            cs = charset<br/>        html = resp.read().decode(cs)<br/>    except (URLError, HTTPError, ContentTooShortError) as e:<br/>        print('Download error:', e.reason)<br/>        html = None <br/>        if num_retries &gt; 0: <br/>            if hasattr(e, 'code') and 500 &lt;= e.code &lt; 600: <br/>            # recursively retry 5xx HTTP errors <br/>            return download(url, num_retries - 1) <br/>    return html
</pre>
<p>The current&#160;<kbd>urllib</kbd> module does not support&#160;<kbd>https</kbd> proxies by default (Python 3.5). This may change with future versions of Python, so check the latest documentation. Alternatively, you can use the documentation's recommended recipe (<a href="https://code.activestate.com/recipes/456195/">https://code.activestate.com/recipes/456195/</a>) or keep reading to learn how to use the&#160;<kbd>requests</kbd> library.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Throttling downloads</h1>
            </header>

            <article>
                
<p>If we crawl a website too quickly, we risk being blocked or overloading the server(s). To minimize these risks, we can throttle our crawl by waiting for a set delay between downloads. Here is a class to implement this:</p>
<pre>from urllib.parse import urlparse<br/>import time<br/><br/>class Throttle: <br/>    """Add a delay between downloads to the same domain <br/>    """ <br/>    def __init__(self, delay): <br/>        # amount of delay between downloads for each domain <br/>        self.delay = delay <br/>        # timestamp of when a domain was last accessed <br/>        self.domains = {} <br/><br/>    def wait(self, url): <br/>        domain = urlparse(url).netloc <br/>        last_accessed = self.domains.get(domain) <br/><br/>        if self.delay &gt; 0 and last_accessed is not None: <br/>            sleep_secs = self.delay - (time.time() - last_accessed) <br/>            if sleep_secs &gt; 0: <br/>                # domain has been accessed recently <br/>                # so need to sleep <br/>                time.sleep(sleep_secs) <br/>        # update the last accessed time <br/>        self.domains[domain] = time.time() 
</pre>
<p>This <kbd>Throttle</kbd> class keeps track of when each domain was last accessed and will sleep if the time since the last access is shorter than the specified delay. We can add throttling to the crawler by calling <kbd>throttle</kbd> before every download:</p>
<pre>throttle = Throttle(delay) <br/>... <br/>throttle.wait(url) <br/>html = download(url, user_agent=user_agent, num_retries=num_retries, <br/>                proxy=proxy, charset=charset) 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Avoiding spider traps</h1>
            </header>

            <article>
                
<p>Currently, our crawler will follow any link it hasn't seen before. However, some websites dynamically generate their content and can have an infinite number of web pages. For example, if the website has an online calendar with links provided for the next month and year, then the next month will also have links to the next month, and so on for however long the widget is set (this can be a LONG time). The site may offer the same functionality with simple pagination navigation, essentially paginating over empty search result pages until the maximum pagination is reached. This situation is known as a <strong>spider trap</strong>.</p>
<p>A simple way to avoid getting stuck in a spider trap is to track how many links have been followed to reach the current web page, which we will refer to as <kbd>depth</kbd>. Then, when a maximum depth is reached, the crawler does not add links from that web page to the queue. To implement maximum depth, we will change the <kbd>seen</kbd> variable, which currently tracks visited web pages, into a dictionary to also record the depth the links were found at:</p>
<pre>def link_crawler(..., max_depth=4): <br/>    seen = {} <br/>    ... <br/>    if rp.can_fetch(user_agent, url): <br/>        depth = seen.get(url, 0)<br/>        if depth == max_depth:<br/>            print('Skipping %s due to depth' % url)<br/>            continue<br/>        ...<br/>        for link in get_links(html):<br/>            if re.match(link_regex, link):<br/>                abs_link = urljoin(start_url, link)<br/>                if abs_link not in seen: <br/>                    seen[abs_link] = depth + 1 <br/>                    crawl_queue.append(abs_link) 
</pre>
<p>Now, with this feature, we can be confident the crawl will complete eventually. To disable this feature, <kbd>max_depth</kbd> can be set to a negative number so the current depth will never be equal to it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Final version</h1>
            </header>

            <article>
                
<p>The full source code for this advanced link crawler can be downloaded at <a href="https://github.com/kjam/wswp/blob/master/code/chp1/advanced_link_crawler.py"><span class="URLPACKT">https://github.com/kjam/wswp/blob/master/code/chp1/advanced_link_crawler.py</span></a>. Each of the sections in this chapter has matching code in the repository at<a href="https://github.com/kjam/wswp">&#160;</a>https://github.com/kjam/wswp. To easily follow along, feel free to fork the repository and use it to compare and test your own code.</p>
<p>To test the link crawler, let's try setting the user agent to <kbd>BadCrawler</kbd>, which, as we saw earlier in this chapter, was blocked by <kbd>robots.txt</kbd>. As expected, the crawl is blocked and finishes immediately:</p>
<pre>    <strong>&gt;&gt;&gt; start_url = 'http://example.webscraping.com/index'</strong><br/><strong>&gt;&gt;&gt; link_regex = '/(index|view)'</strong><br/><strong>&gt;&gt;&gt; link_crawler(start_url, link_regex, user_agent='BadCrawler')</strong><br/><strong>Blocked by robots.txt: http://example.webscraping.com/</strong>
</pre>
<p>Now, let's try using the default user agent and setting the maximum depth to <kbd>1</kbd> so that only the links from the home page are downloaded:</p>
<pre>    <strong>&gt;&gt;&gt; link_crawler(start_url, link_regex, max_depth=1)</strong><br/><strong>Downloading: http://example.webscraping.com//index</strong><br/><strong>Downloading: http://example.webscraping.com/index/1</strong><br/><strong>Downloading: http://example.webscraping.com/view/Antigua-and-Barbuda-10</strong><br/><strong>Downloading: http://example.webscraping.com/view/Antarctica-9</strong><br/><strong>Downloading: http://example.webscraping.com/view/Anguilla-8</strong><br/><strong>Downloading: http://example.webscraping.com/view/Angola-7</strong><br/><strong>Downloading: http://example.webscraping.com/view/Andorra-6</strong><br/><strong>Downloading: http://example.webscraping.com/view/American-Samoa-5</strong><br/><strong>Downloading: http://example.webscraping.com/view/Algeria-4</strong><br/><strong>Downloading: http://example.webscraping.com/view/Albania-3</strong><br/><strong>Downloading: http://example.webscraping.com/view/Aland-Islands-2</strong><br/><strong>Downloading: http://example.webscraping.com/view/Afghanistan-1</strong>
</pre>
<p>As expected, the crawl stopped after downloading the first page of countries.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Using the requests library</h1>
            </header>

            <article>
                
<p>Although we have built a fairly advanced parser using only&#160;<kbd>urllib</kbd>, the majority of scrapers written in Python today utilize the&#160;<kbd>requests</kbd> library to manage complex HTTP requests. What started as a small library to help wrap&#160;<kbd>urllib</kbd> features in something "human-readable" is now a very large project with hundreds of contributors. Some of the features available include built-in handling of encoding, important updates to SSL and security, as well as easy handling of POST requests, JSON, cookies, and proxies.</p>
<div class="packt_infobox">Throughout most of this book, we will utilize the requests library for its simplicity and ease of use, and because it has become the de facto standard for most web scraping.</div>
<p>To install&#160;<kbd>requests</kbd>, simply use <kbd>pip:</kbd></p>
<pre><strong>pip install requests</strong>
</pre>
<p>For an in-depth overview of all features, you should&#160;read the documentation at <a href="http://python-requests.org">http://python-requests.org</a> or browse the source code at&#160;<a href="https://github.com/kennethreitz/requests">https://github.com/kennethreitz/requests</a>.&#160;</p>
<p>To compare differences using the two libraries, I've also built the advanced link crawler so that it can use requests. You can see the code at&#160;<a href="https://github.com/kjam/wswp/blob/master/code/chp1/advanced_link_crawler_using_requests.py">https://github.com/kjam/wswp/blob/master/code/chp1/advanced_link_crawler_using_requests.py</a>. The main&#160;<kbd>download</kbd> function shows the key differences. The&#160;<kbd>requests</kbd>&#160;version is as follows:</p>
<pre>def download(url, user_agent='wswp', num_retries=2, proxies=None):<br/>    print('Downloading:', url)<br/>    headers = {'User-Agent': user_agent}<br/>    try:<br/>        resp = requests.get(url, headers=headers, proxies=proxies)<br/>        html = resp.text<br/>        if resp.status_code &gt;= 400:<br/>            print('Download error:', resp.text)<br/>            html = None<br/>            if num_retries and 500 &lt;= resp.status_code &lt; 600:<br/>                # recursively retry 5xx HTTP errors<br/>                return download(url, num_retries - 1)<br/>    except requests.exceptions.RequestException as e:<br/>        print('Download error:', e.reason)<br/>        html = None
</pre>
<p>One notable difference is the ease of use of having&#160;<kbd>status_code</kbd> as an available attribute for each request. Additionally, we no longer need to test for character encoding, as the&#160;<kbd>text</kbd>&#160;attribute on our&#160;<kbd>Response</kbd> object does so automatically. In the rare case of an non-resolvable URL or timeout, they are all handled by&#160;<kbd>RequestException</kbd> so it makes for an easy catch statement. Proxy handling is also taken care of&#160;by simply passing a dictionary of proxies (that is <kbd>{'http': 'http://myproxy.net:1234', 'https': 'https://myproxy.net:1234'}</kbd>).</p>
<p>We will continue to compare and use both libraries, so that you are familiar with them depending on your needs and use case.&#160;<span>I strongly recommend using&#160;</span><kbd>requests</kbd> <span>whenever you are handling more complex websites, or need to handle important humanizing methods such as using cookies or sessions</span><span>. We will talk more about these methods in <a href="py-web-scrp-2e_ch06.html">Chapter 6</a>,&#160;<em>Interacting with Forms</em>.</span></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>This chapter introduced web scraping and developed a sophisticated crawler that will be reused in the following chapters. We covered the usage of external tools and modules to get an understanding of a website, user agents, sitemaps, crawl delays, and various advanced crawling techniques.</p>
<p>In the next chapter, we will explore how to scrape data from crawled web pages.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>
</body>
</html>