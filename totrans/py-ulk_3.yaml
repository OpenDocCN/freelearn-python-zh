- en: Chapter 3. Functions and Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 函数和实用工具
- en: 'After learning about how objects are linked to one another, let''s take a look
    at the functions that are the means to execute code in language. We will discuss
    how to define and call functions with various combinations. Then, we will cover
    some very useful utilities that are available to us to use in day-to-day programming.
    We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解对象之间是如何相互链接之后，让我们来看看在语言中执行代码的手段——函数。我们将讨论如何使用各种组合来定义和调用函数。然后，我们将介绍一些在日常生活中编程中非常有用的实用工具。我们将涵盖以下主题：
- en: Defining functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数
- en: Decorating callables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰可调用对象
- en: Utilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用工具
- en: Defining functions
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数
- en: '**Key 1: How to define functions.**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点1：如何定义函数。**'
- en: Functions are used to group a set of instructions and logic that performs a
    specific task. So, we should make functions perform one specific task and choose
    a name that gives us a hint about that. If a function is important and performs
    complex stuff, we should always add docstrings to this function so that it is
    easy for us to later visit and modify this function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 函数用于将一组指令和执行特定任务的逻辑组合在一起。因此，我们应该让函数执行一个特定的任务，并选择一个能给我们提示该任务的名称。如果一个函数很重要并且执行复杂操作，我们应该始终为此函数添加文档字符串，这样我们以后就可以轻松地访问和修改此函数。
- en: 'While defining a function, we can define the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，我们可以定义以下内容：
- en: 'Positional arguments (simply pass the object according to position), which
    are as follows:'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位置参数（简单按照位置传递对象），如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Default arguments (if value is not passed, the default is used), which are
    as follows:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认参数（如果没有传递值，则使用默认值），如下所示：
- en: '[PRE1]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Keyword only arguments (must be passed as a positional or as a keyword argument),
    which are as follows:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键字参数（必须以位置或关键字参数的形式传递），如下所示：
- en: '[PRE2]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An argument list, which is as follows:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数列表，如下所示：
- en: '[PRE3]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A keyword argument dictionary, which is as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键字参数字典，如下所示：
- en: '[PRE4]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When a function is called, this is how arguments are passed on:'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当函数被调用时，这是参数传递的方式：
- en: All positional arguments that are passed are consumed.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有传递的位置参数都被消耗。
- en: 'If the function takes an argument list and there are more passed positional
    arguments after the first step, then the rest of the arguments are collected in
    an argument list:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数接受一个参数列表，并且在第一步之后还有更多的位置参数传递，那么其余的参数将收集在一个参数列表中：
- en: '[PRE5]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If passed position arguments are less than the defined positional arguments,
    then the passed keyword arguments are used for values for positional arguments.
    If no keyword argument is found for the positional argument, we get an error:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果传递的位置参数少于定义的位置参数，则使用传递的关键字参数作为位置参数的值。如果没有找到位置参数的关键字参数，我们将得到一个错误：
- en: '[PRE6]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Passed keyword variables are used only for keyword arguments:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递的关键字变量仅用于关键字参数：
- en: '[PRE7]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If more keywords remain and the called function takes a keyword argument list,
    then the rest of the keyword arguments are passed as a keyword argument list.
    If the keyword argument list is not taken by the function, we get an error:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还有更多的关键字参数，并且被调用的函数接受一个关键字参数列表，那么其余的关键字参数将作为关键字参数列表传递。如果函数没有接受关键字参数列表，我们将得到一个错误：
- en: '[PRE8]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is an example function that uses all of the preceding combinations:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一个示例函数，它使用了前面所有组合：
- en: '[PRE9]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Decorating callables
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰可调用对象
- en: '**Key 2: Changing the behavior of callables.**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点2：改变可调用对象的行为。**'
- en: Decorators are callable objects, which replace the original callable objects
    with some other objects. In this case, as we are replacing a callable with another
    object, what we mostly want mostly is the replaced object to be callable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是可调用对象，它们用其他对象替换原始的可调用对象。在这种情况下，因为我们用另一个对象替换了一个可调用对象，所以我们主要希望被替换的对象仍然是可调用的。
- en: 'Language provides syntax to do so easily, but first, let''s take a look at
    how we can manually do this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 语言提供了易于实现的语法，但首先，让我们看看我们如何手动完成这个任务：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the decorator syntax, it becomes easy. Taking the definition of wrap and
    `newfunc` from the preceding code snippet, we get this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器语法，变得很容易。从前面的代码片段中获取wrap和`newfunc`的定义，我们得到这个：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To store some kind of state in the decorator function, say to make decorator
    more useful and applicable to wider application code base, we can use closures
    or class instances as decorators. In the second chapter, we saw that closures
    can be used to store state; let''s look at how we can utilize them to store information
    in decorators. In this snippet, the `deco` function is the new function that will
    replace the add function. A prefix variable is available in the closure of this
    function. This variable can be injected at decorator creation time:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在装饰器函数中存储某种状态，比如说使装饰器更有用，并适用于更广泛的代码库，我们可以使用闭包或类实例作为装饰器。在第二章中，我们了解到闭包可以用来存储状态；让我们看看我们如何利用它们在装饰器中存储信息。在这个片段中，`deco`函数是替换添加函数的新函数。这个函数的闭包中有一个前缀变量。这个变量可以在装饰器创建时注入：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We could have used a class to do the same thing as well. Here, we save state
    on an instance of class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用类来做同样的事情。在这里，我们在类的实例上保存状态：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As decorator works on any callable, it works similarly on methods and class
    definitions as well, but when doing so, we should take into consideration the
    different arguments that are implicitly passed for the method that is being decorated.
    Let''s first take a simple method being decorated like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于装饰器作用于任何可调用对象，它同样适用于方法和类定义，但在这样做的时候，我们应该考虑被装饰的方法隐式传递的不同参数。让我们先考虑一个简单的被装饰方法如下：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As the function that is replaced becomes the method of the class itself, this
    works perfectly. This is not true for static and class methods. They employ descriptors
    to call methods, hence, their behavior breaks with decorators and the returned
    function behaves like a simple method. We can make this work by first checking
    whether the overridden function is a descriptor and if yes, then calling its `__get__`
    method instead:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于被替换的函数成为类本身的方法，这工作得很好。对于静态方法和类方法来说，这就不成立了。它们使用描述符来调用方法，因此，它们的行性行为与装饰器不匹配，返回的函数表现得像一个简单的方法。我们可以通过首先检查被覆盖的函数是否是描述符，如果是，则调用它的`__get__`方法来解决这个问题：
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can also make this work easily using static and class methods decorators
    on top of any other decorator. This makes the actual method that is found by the
    attribute look up as a descriptor and normal execution happens for `staticmethod`
    and `classmethod`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过在任意其他装饰器之上使用静态方法和类方法装饰器来轻松实现这一点。这使得通过属性查找找到的实际方法看起来像描述符，并且对于`staticmethod`和`classmethod`，正常执行发生。
- en: 'This works fine, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，如下所示：
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use decorators for classes as class is just a type of callable. Hence,
    we can use decorators to alter the instance creation process so that when we call
    class, we get an instance. A class object will be passed to decorator and then
    decorator can replace it with another callable or class. Here, the `cdeco` decorator
    is passing a new class that replaced `cls`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用装饰器来处理类，因为类本质上是一种可调用对象。因此，我们可以使用装饰器来改变实例创建过程，以便当我们调用类时，我们得到一个实例。类对象将被传递到装饰器，然后装饰器可以用另一个可调用对象或类来替换它。在这里，`cdeco`装饰器正在传递一个新的类来替换`cls`：
- en: '[PRE17]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Normally, we use this to change the attributes, and add new attributes to the
    class definition. We can also use this to register the class to some registry,
    and so on. In the following code snippet, we check whether class has a do method.
    If we find one, we replace it with `newfunc`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用它来更改属性，并为类定义添加新属性。我们也可以用它来将类注册到某个注册表中，等等。在下面的代码片段中，我们检查类是否有do方法。如果我们找到一个，我们就用`newfunc`来替换它：
- en: '[PRE18]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Utilities
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用工具
- en: '**Key 3: Easy iterations by comprehensions.**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键3：通过推导式轻松迭代。**'
- en: We have various syntax and utilities to iterate efficiently over iterators.
    Comprehensions work on iterator and provide results as another iterator. They
    are implemented in native C, and hence, they are faster than for loops.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有各种语法和实用工具来有效地迭代迭代器。推导式在迭代器上工作，并提供另一个迭代器作为结果。它们是用原生C实现的，因此，它们比循环更快。
- en: 'We have list, dictionary, and set comprehensions, which produce list, dictionary,
    and set as result, respectively. Also, iterators avoid declaring extra variables
    that we need in a loop:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有列表、字典和集合推导式，分别产生列表、字典和集合作为结果。此外，迭代器避免了在循环中声明额外的变量：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Generator expression creates generators, which can be used to produce generators
    for an iteration like this. To materialize a generator, we use it to create `set`,
    `dict`, or `list`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式创建生成器，可以用来为迭代产生生成器。要实现生成器，我们使用它来创建`set`、`dict`或`list`：
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Generator objects do not compute all the values of the iterable at once but
    one by one when requested by a loop. This conserves memory, and we may not be
    interested in using the whole iterable. Generators are not silver bullets to be
    used everywhere. They do not always result in a performance increase. It depends
    on the consumer, and the cost of generating one sequence:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象不会一次性计算可迭代对象的所有值，而是在被循环请求时逐个计算。这节省了内存，我们可能对使用整个可迭代对象不感兴趣。生成器不是可以到处使用的银弹。它们并不总是导致性能提升。这取决于消费者和生成一个序列的成本：
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Key 4: Some helpful utilities.**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键4：一些有用的工具。**'
- en: 'The `itertools` utility is a good module with many helpful functions for iterations.
    Some of my favorites are the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 工具是一个很好的模块，包含许多对迭代有帮助的函数。以下是我最喜欢的几个：'
- en: '**itertools.chain(* iterable)**: This returns a single iterable from a list
    of iterables. First, all the elements of the first iterable are exhausted, and
    then of the second, and so on until all iterables are exhausted:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**itertools.chain(*iterable)**：这从一个可迭代对象的列表返回一个单一的迭代器。首先，第一个可迭代对象的所有元素都被耗尽，然后是第二个，依此类推，直到所有可迭代对象都被耗尽：'
- en: '[PRE22]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**itertools.cycle**: This creates a copy of the iterator and continues to replay
    the results infinitely:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**itertools.cycle**：这会创建一个迭代器的副本，并无限期地重复播放结果：'
- en: '[PRE23]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**itertools.tee(iterable,number)**: This returns `n` independent iterables
    from a single iterable:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**itertools.tee(iterable,number)**：这从一个单一的迭代器返回 `n` 个独立的迭代器：'
- en: '[PRE24]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**functools.lru_cache**: This decorator uses memorizing. It saves the results
    that are mapped to arguments. Hence, it is very useful to speed up functions that
    take a similar argument, and whose results are not dependent on time or state:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**functools.lru_cache**：这个装饰器使用记忆功能。它保存映射到参数的结果。因此，它对于加速具有相似参数且结果不依赖于时间或状态的函数非常有用：'
- en: '[PRE25]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**functools.wraps**: We have just seen how to create decorators, and how to
    wrap functions. The returned function from decorator retains its name and attributes,
    such as docstrings, which is not helpful for the users or fellow developers. We
    can use this decorator to match the returned function to the decorated function.
    The following snippet shows how it is used:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**functools.wraps**：我们刚刚看到了如何创建装饰器以及如何包装函数。装饰器返回的函数保留了其名称和属性，如文档字符串，这对用户或开发者来说可能没有帮助。我们可以使用这个装饰器将返回的函数与装饰的函数匹配。以下代码片段展示了它的用法：'
- en: '[PRE26]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Lambda functions**: These functions are simple anonymous functions.Lambda
    functions cannot have statements or annotations. They are very useful in creating
    closures and callbacks in GUI programming:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda函数**：这些函数是简单的匿名函数。Lambda函数不能有语句或注解。它们在创建GUI编程中的闭包和回调时非常有用：'
- en: '[PRE27]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Sometimes, lambda functions make code easy to understand.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，lambda函数使代码更容易理解。
- en: 'The following is a small program to create the diamond pattern using the iterations
    technique and the lambda function:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个使用迭代技术和lambda函数创建菱形图案的小程序：
- en: '[PRE28]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to define functions and pass arguments to them.
    Then, we discussed decorators in detail; decorators are very popular in frameworks.
    Toward the end, we collected various utilities that are available in Python, which
    makes coding a little easier for us.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何定义函数并将参数传递给它们。然后，我们详细讨论了装饰器；装饰器在框架中非常受欢迎。在结尾部分，我们收集了Python中可用的各种工具，这使得我们的编码工作变得稍微容易一些。
- en: In the next chapter, we will discuss algorithms and data structures.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论算法和数据结构。
