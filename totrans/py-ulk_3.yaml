- en: Chapter 3. Functions and Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After learning about how objects are linked to one another, let''s take a look
    at the functions that are the means to execute code in language. We will discuss
    how to define and call functions with various combinations. Then, we will cover
    some very useful utilities that are available to us to use in day-to-day programming.
    We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorating callables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 1: How to define functions.**'
  prefs: []
  type: TYPE_NORMAL
- en: Functions are used to group a set of instructions and logic that performs a
    specific task. So, we should make functions perform one specific task and choose
    a name that gives us a hint about that. If a function is important and performs
    complex stuff, we should always add docstrings to this function so that it is
    easy for us to later visit and modify this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'While defining a function, we can define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional arguments (simply pass the object according to position), which
    are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Default arguments (if value is not passed, the default is used), which are
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Keyword only arguments (must be passed as a positional or as a keyword argument),
    which are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An argument list, which is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A keyword argument dictionary, which is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When a function is called, this is how arguments are passed on:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All positional arguments that are passed are consumed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the function takes an argument list and there are more passed positional
    arguments after the first step, then the rest of the arguments are collected in
    an argument list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If passed position arguments are less than the defined positional arguments,
    then the passed keyword arguments are used for values for positional arguments.
    If no keyword argument is found for the positional argument, we get an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Passed keyword variables are used only for keyword arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If more keywords remain and the called function takes a keyword argument list,
    then the rest of the keyword arguments are passed as a keyword argument list.
    If the keyword argument list is not taken by the function, we get an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is an example function that uses all of the preceding combinations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Decorating callables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 2: Changing the behavior of callables.**'
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are callable objects, which replace the original callable objects
    with some other objects. In this case, as we are replacing a callable with another
    object, what we mostly want mostly is the replaced object to be callable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Language provides syntax to do so easily, but first, let''s take a look at
    how we can manually do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With the decorator syntax, it becomes easy. Taking the definition of wrap and
    `newfunc` from the preceding code snippet, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To store some kind of state in the decorator function, say to make decorator
    more useful and applicable to wider application code base, we can use closures
    or class instances as decorators. In the second chapter, we saw that closures
    can be used to store state; let''s look at how we can utilize them to store information
    in decorators. In this snippet, the `deco` function is the new function that will
    replace the add function. A prefix variable is available in the closure of this
    function. This variable can be injected at decorator creation time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have used a class to do the same thing as well. Here, we save state
    on an instance of class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As decorator works on any callable, it works similarly on methods and class
    definitions as well, but when doing so, we should take into consideration the
    different arguments that are implicitly passed for the method that is being decorated.
    Let''s first take a simple method being decorated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As the function that is replaced becomes the method of the class itself, this
    works perfectly. This is not true for static and class methods. They employ descriptors
    to call methods, hence, their behavior breaks with decorators and the returned
    function behaves like a simple method. We can make this work by first checking
    whether the overridden function is a descriptor and if yes, then calling its `__get__`
    method instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can also make this work easily using static and class methods decorators
    on top of any other decorator. This makes the actual method that is found by the
    attribute look up as a descriptor and normal execution happens for `staticmethod`
    and `classmethod`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works fine, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use decorators for classes as class is just a type of callable. Hence,
    we can use decorators to alter the instance creation process so that when we call
    class, we get an instance. A class object will be passed to decorator and then
    decorator can replace it with another callable or class. Here, the `cdeco` decorator
    is passing a new class that replaced `cls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, we use this to change the attributes, and add new attributes to the
    class definition. We can also use this to register the class to some registry,
    and so on. In the following code snippet, we check whether class has a do method.
    If we find one, we replace it with `newfunc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 3: Easy iterations by comprehensions.**'
  prefs: []
  type: TYPE_NORMAL
- en: We have various syntax and utilities to iterate efficiently over iterators.
    Comprehensions work on iterator and provide results as another iterator. They
    are implemented in native C, and hence, they are faster than for loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have list, dictionary, and set comprehensions, which produce list, dictionary,
    and set as result, respectively. Also, iterators avoid declaring extra variables
    that we need in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Generator expression creates generators, which can be used to produce generators
    for an iteration like this. To materialize a generator, we use it to create `set`,
    `dict`, or `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Generator objects do not compute all the values of the iterable at once but
    one by one when requested by a loop. This conserves memory, and we may not be
    interested in using the whole iterable. Generators are not silver bullets to be
    used everywhere. They do not always result in a performance increase. It depends
    on the consumer, and the cost of generating one sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Key 4: Some helpful utilities.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `itertools` utility is a good module with many helpful functions for iterations.
    Some of my favorites are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**itertools.chain(* iterable)**: This returns a single iterable from a list
    of iterables. First, all the elements of the first iterable are exhausted, and
    then of the second, and so on until all iterables are exhausted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**itertools.cycle**: This creates a copy of the iterator and continues to replay
    the results infinitely:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**itertools.tee(iterable,number)**: This returns `n` independent iterables
    from a single iterable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**functools.lru_cache**: This decorator uses memorizing. It saves the results
    that are mapped to arguments. Hence, it is very useful to speed up functions that
    take a similar argument, and whose results are not dependent on time or state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**functools.wraps**: We have just seen how to create decorators, and how to
    wrap functions. The returned function from decorator retains its name and attributes,
    such as docstrings, which is not helpful for the users or fellow developers. We
    can use this decorator to match the returned function to the decorated function.
    The following snippet shows how it is used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Lambda functions**: These functions are simple anonymous functions.Lambda
    functions cannot have statements or annotations. They are very useful in creating
    closures and callbacks in GUI programming:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sometimes, lambda functions make code easy to understand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is a small program to create the diamond pattern using the iterations
    technique and the lambda function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to define functions and pass arguments to them.
    Then, we discussed decorators in detail; decorators are very popular in frameworks.
    Toward the end, we collected various utilities that are available in Python, which
    makes coding a little easier for us.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss algorithms and data structures.
  prefs: []
  type: TYPE_NORMAL
