["```py\n# srp_1.py\nclass SystemMonitor:\n    def load_activity(self):\n        \"\"\"Get the events from a source, to be processed.\"\"\"\n    def identify_events(self):\n        \"\"\"Parse the source raw data into events (domain objects).\"\"\"\n    def stream_events(self):\n        \"\"\"Send the parsed events to an external agent.\"\"\" \n```", "```py\n# openclosed_1.py\n@dataclass\nclass Event:\n    raw_data: dict \nclass UnknownEvent(Event):\n    \"\"\"A type of event that cannot be identified from its data.\"\"\"\nclass LoginEvent(Event):\n    \"\"\"A event representing a user that has just entered the system.\"\"\"\nclass LogoutEvent(Event):\n    \"\"\"An event representing a user that has just left the system.\"\"\"\nclass SystemMonitor:\n    \"\"\"Identify events that occurred in the system.\"\"\"\n    def __init__(self, event_data):\n        self.event_data = event_data\n    def identify_event(self):\n        if (\n            self.event_data[\"before\"][\"session\"] == 0\n            and self.event_data[\"after\"][\"session\"] == 1\n        ):\n            return LoginEvent(self.event_data)\n        elif (\n            self.event_data[\"before\"][\"session\"] == 1\n            and self.event_data[\"after\"][\"session\"] == 0\n        ):\n            return LogoutEvent(self.event_data)\n        return UnknownEvent(self.event_data) \n```", "```py\n>>> l1 = SystemMonitor({\"before\": {\"session\": 0}, \"after\": {\"session\": 1}})\n>>> l1.identify_event().__class__.__name__\n'LoginEvent'\n>>> l2 = SystemMonitor({\"before\": {\"session\": 1}, \"after\": {\"session\": 0}})\n>>> l2.identify_event().__class__.__name__\n'LogoutEvent'\n>>> l3 = SystemMonitor({\"before\": {\"session\": 1}, \"after\": {\"session\": 1}})\n>>> l3.identify_event().__class__.__name__\n'UnknownEvent' \n```", "```py\n# openclosed_2.py\nclass Event:\n    def __init__(self, raw_data):\n        self.raw_data = raw_data\n    @staticmethod\n    def meets_condition(event_data: dict) -> bool:\n        return False\nclass UnknownEvent(Event):\n    \"\"\"A type of event that cannot be identified from its data\"\"\"\nclass LoginEvent(Event):\n    @staticmethod\n    def meets_condition(event_data: dict):\n        return (\n            event_data[\"before\"][\"session\"] == 0\n            and event_data[\"after\"][\"session\"] == 1\n        )\nclass LogoutEvent(Event):\n    @staticmethod\n    def meets_condition(event_data: dict):\n        return (\n            event_data[\"before\"][\"session\"] == 1\n            and event_data[\"after\"][\"session\"] == 0\n        )\nclass SystemMonitor:\n    \"\"\"Identify events that occurred in the system.\"\"\"\n    def __init__(self, event_data):\n        self.event_data = event_data\n    def identify_event(self):\n        for event_cls in Event.__subclasses__():\n            try:\n                if event_cls.meets_condition(self.event_data):\n                    return event_cls(self.event_data)\n            except KeyError:\n                continue\n        return UnknownEvent(self.event_data) \n```", "```py\n# openclosed_3.py\nclass TransactionEvent(Event):\n    \"\"\"Represents a transaction that has just occurred on the system.\"\"\"\n    @staticmethod\n    def meets_condition(event_data: dict):\n        return event_data[\"after\"].get(\"transaction\") is not None \n```", "```py\n>>> l1 = SystemMonitor({\"before\": {\"session\": 0}, \"after\": {\"session\": 1}})\n>>> l1.identify_event().__class__.__name__\n'LoginEvent'\n>>> l2 = SystemMonitor({\"before\": {\"session\": 1}, \"after\": {\"session\": 0}})\n>>> l2.identify_event().__class__.__name__\n'LogoutEvent'\n>>> l3 = SystemMonitor({\"before\": {\"session\": 1}, \"after\": {\"session\": 1}})\n>>> l3.identify_event().__class__.__name__\n'UnknownEvent'\n>>> l4 = SystemMonitor({\"after\": {\"transaction\": \"Tx001\"}})\n>>> l4.identify_event().__class__.__name__\n'TransactionEvent' \n```", "```py\nclass Event:\n    ...\n    def meets_condition(self, event_data: dict) -> bool:\n        return False\nclass LoginEvent(Event):\n    def meets_condition(self, event_data: list) -> bool:\n        return bool(event_data) \n```", "```py\nerror: Argument 1 of \"meets_condition\" incompatible with supertype \"Event\" \n```", "```py\n# lsp_1.py\nclass LogoutEvent(Event):\n    def meets_condition(self, event_data: dict, override: bool) -> bool:\n        if override:\n            return True\n        ... \n```", "```py\nParameters differ from overridden 'meets_condition' method (arguments-differ) \n```", "```py\n# lsp_2.py\nfrom collections.abc import Mapping\n\nclass Event:\n    def __init__(self, raw_data):\n        self.raw_data = raw_data\n\n    @staticmethod\n    def meets_condition(event_data: dict) -> bool:\n        return False\n\n    @staticmethod\n    def validate_precondition(event_data: dict):\n        \"\"\"Precondition of the contract of this interface.\n\n        Validate that the ``event_data`` parameter is properly formed.\n        \"\"\"\n        if not isinstance(event_data, Mapping):\n            raise ValueError(f\"{event_data!r} is not a dict\")\n        for moment in (\"before\", \"after\"):\n            if moment not in event_data:\n                raise ValueError(f\"{moment} not in {event_data}\")\n            if not isinstance(event_data[moment], Mapping):\n                raise ValueError(f\"event_data[{moment!r}] is not a dict\") \n```", "```py\n# lsp_2.py\nclass SystemMonitor:\n    \"\"\"Identify events that occurred in the system.\"\"\"\n    def __init__(self, event_data):\n        self.event_data = event_data\n    def identify_event(self):\n        Event.validate_precondition(self.event_data)\n        event_cls = next(\n            (\n                event_cls\n                for event_cls in Event.__subclasses__()\n                if event_cls.meets_condition(self.event_data)\n            ),\n            UnknownEvent,\n        )\n        return event_cls(self.event_data) \n```", "```py\n# lsp_2.py\nclass TransactionEvent(Event):\n    \"\"\"Represents a transaction that has just occurred on the system.\"\"\"\n    @staticmethod\n    def meets_condition(event_data: dict) -> bool:\n        return event_data[\"after\"].get(\"transaction\") is not None \n```", "```py\n>>> l1 = SystemMonitor({\"before\": {\"session\": 0}, \"after\": {\"session\": 1}})\n>>> l1.identify_event().__class__.__name__\n'LoginEvent'\n>>> l2 = SystemMonitor({\"before\": {\"session\": 1}, \"after\": {\"session\": 0}})\n>>> l2.identify_event().__class__.__name__\n'LogoutEvent'\n>>> l3 = SystemMonitor({\"before\": {\"session\": 1}, \"after\": {\"session\": 1}})\n>>> l3.identify_event().__class__.__name__'UnknownEvent'\n>>> l4 = SystemMonitor({\"before\": {}, \"after\": {\"transaction\": \"Tx001\"}})\n>>> l4.identify_event().__class__.__name__\n'TransactionEvent' \n```", "```py\nfrom abc import ABCMeta, abstractmethod\nclass XMLEventParser(metaclass=ABCMeta):\n    @abstractmethod\n    def from_xml(xml_data: str):\n        \"\"\"Parse an event from a source in XML representation.\"\"\"\n\nclass JSONEventParser(metaclass=ABCMeta):\n    @abstractmethod\n    def from_json(json_data: str):\n        \"\"\"Parse an event from a source in JSON format.\"\"\"\n\nclass EventParser(XMLEventParser, JSONEventParser):\n    \"\"\"An event parser that can create an event from source data either in XML or JSON format.\n    \"\"\"\n\n    def from_xml(xml_data):\n        pass\n\n    def from_json(json_data: str):\n        pass \n```", "```py\n>>> from src.isp import EventParser\n>>> EventParser()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: Can't instantiate abstract class EventParser with abstract methods from_json, from_xml \n```", "```py\nclass EventStreamer:\n    def __init__(self):\n        self._target = Syslog()\n    def stream(self, events: list[Event]) -> None:\n        for event in events:\n            self._target.send(event.serialise()) \n```", "```py\nclass EventStreamer:\n    def __init__(self, target: DataTargetClient):\n        self._target = target\n    def stream(self, events: list[Event]) -> None:\n        for event in events:\n            self._target.send(event.serialise()) \n```", "```py\nclass EventStreamer:\n    def __init__(self, target: DataTargetClient):\n        self.target = target\n    def stream(self, events: list[Event]) -> None:\n        for event in events:\n            self.target.send(event.serialise())\nclass _EventStreamerBindingSpec(pinject.BindingSpec):\n    def provide_target(self):\n        return Syslog()\nobject_graph = pinject.new_object_graph(\n    binding_specs=[_EventStreamerBindingSpec()]) \n```", "```py\nevent_streamer = object_graph.provide(EventStreamer) \n```"]