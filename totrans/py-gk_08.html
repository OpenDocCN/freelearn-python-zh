<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-150"><em class="italic"><a id="_idTextAnchor188"/>Chapter 6</em>: Advanced Tips and Tricks in Python</h1>
			<p>In this chapter, we will introduce some advanced tips and tricks that can be used as powerful programming techniques when writing code in Python. These include the advanced use of Python functions, such as nested functions, lambda functions, and building decorators with functions. Additionally, we will cover data transformations with the filter, mapper, and reducer functions. This will be followed by some tricks that can be used with data structures, such as the use of nested dictionaries and comprehension with different collection types. Finally, we will investigate the advanced functionality of the pandas library for DataFrame objects. These advanced tips and tricks will not only demonstrate Python's power in achieving advanced features with less code, but it will also help you code faster and more efficiently. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Learning advanced tricks for using functions </li>
				<li>Understanding advanced concepts with data structures </li>
				<li>Introducing advanced tricks with pandas DataFrame</li>
			</ul>
			<p>By the end of this chapter, you will have gained an understanding of how to use Python functions for advanced features such as data transformations and building decorators. Additionally, you will learn how to use data structures including pandas DataFrame for analytics-based applications.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor189"/>Technical requirements</h1>
			<p>The technical requirements for this chapter are as follows:</p>
			<ul>
				<li>You need to have Python 3.7 or later installed on your computer.</li>
				<li>You need to register an account with TestPyPI and create an API token under your account.</li>
			</ul>
			<p>The sample code for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter06">https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter06</a>.</p>
			<p>We will start our discussion with the advanced concepts for using functions in Python. </p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor190"/>Learning advanced tricks for using functions </h1>
			<p>The use of functions in <a id="_idIndexMarker629"/>Python and other programming languages is key for reusability and modularization. However, with new advances to modern programming languages, the role of functions has been extended beyond reusability, which includes writing simple, short, and concise code without using complex loops and conditional statements. </p>
			<p>We will start with the use of the <strong class="source-inline">counter</strong>, <strong class="source-inline">zip</strong>, and <strong class="source-inline">itertools</strong> functions, which we will discuss next.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor191"/>Introducing the counter, itertools, and zip functions for iterative tasks</h2>
			<p>For any data processing tasks, developers extensively use iterators. We have covered iterators, in detail, in <a href="B17189_04_Final_PG_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 4</em></a>, <em class="italic">Python Libraries for Advanced Programming</em>. In this section, we will learn about the next level of utility functions to help you conveniently work with iterators and iterables. These include the <strong class="source-inline">counter</strong> module, the <strong class="source-inline">zip</strong> function, and the <strong class="source-inline">itertools</strong> module. We will discuss each of these in the following subsections.</p>
			<h3>Counter</h3>
			<p><strong class="bold">Counter</strong> is a type of <a id="_idIndexMarker630"/>container that keeps track of the count of each element that is <a id="_idIndexMarker631"/>present in a container. The count of elements in a container is useful for finding the data frequency, which is a prerequisite for many data analysis applications. To illustrate the concept and use of the <strong class="source-inline">Counter</strong> class, we will present a simple code example, as follows: </p>
			<p class="source-code">#<strong class="bold">counter.py</strong></p>
			<p class="source-code">from collections import Counter</p>
			<p class="source-code">#applying counter on a string object</p>
			<p class="source-code">print(<strong class="bold">Counter</strong>("people"))</p>
			<p class="source-code">#applying counter on a list object</p>
			<p class="source-code">my_counter = Counter([1,2,1,2,3,4,1,3])</p>
			<p class="source-code">print(my_counter.<strong class="bold">most_common</strong>(1))</p>
			<p class="source-code">print(list(my_counter.<strong class="bold">elements</strong>()))</p>
			<p class="source-code">#applying counter on a dict object</p>
			<p class="source-code">print(Counter({'A': 2, 'B': 2, 'C': 2, 'C': 3}))</p>
			<p>In the preceding code <a id="_idIndexMarker632"/>example, we created multiple <strong class="source-inline">Counter</strong> instances using a <strong class="source-inline">String</strong> object, a list object, and a dictionary object. The <strong class="source-inline">Counter</strong> class has methods such as <strong class="source-inline">most_common</strong> and <strong class="source-inline">elements</strong>. We used the <strong class="source-inline">most_common</strong> method with a value of <strong class="source-inline">1</strong>, which <a id="_idIndexMarker633"/>gives us the element that appears the most in the <strong class="source-inline">my-counter</strong> container. Additionally, we used the <strong class="source-inline">elements</strong> method to return the original list from the <strong class="source-inline">Counter</strong> instance. The console output of this program should be as follows:</p>
			<p class="source-code">Counter({'p': 2, 'e': 2, 'o': 1, 'l': 1})</p>
			<p class="source-code">[(1, 3)]</p>
			<p class="source-code">[1, 1, 1, 2, 2, 3, 3, 4]</p>
			<p class="source-code">Counter({'C': 4, 'A': 2, 'B': 2}) </p>
			<p>It is important to note that in the case of the dictionary object, we deliberately used a repeated key, but in the <strong class="source-inline">Counter</strong> instance, we get only one key-value pair, which is the last one in the dictionary. Additionally, the elements in the <strong class="source-inline">Counter</strong> instance are ordered based on the values for each element. Note that the <strong class="source-inline">Counter</strong> class converts the dictionary object into a hashtable object. </p>
			<h3>zip</h3>
			<p>The <strong class="source-inline">zip</strong> function is used to create an aggregated iterator based on two or more individual iterators. The <strong class="source-inline">zip</strong> function is useful when we are required to iterate on multiple iterations in parallel. For example, we<a id="_idIndexMarker634"/> can use the <strong class="source-inline">zip</strong> function when implementing mathematical algorithms that involve interpolation or pattern recognition. This is also helpful in digital signal processing where we combine multiple signals (data sources) into a single signal. Here is a simple code example that uses a <strong class="source-inline">zip</strong> function: </p>
			<p class="source-code">#<strong class="bold">zip.py</strong></p>
			<p class="source-code">num_list = [1, 2, 3, 4, 5]</p>
			<p class="source-code">lett_list = ['alpha', 'bravo', 'charlie']</p>
			<p class="source-code">zipped_iter = <strong class="bold">zip</strong>(num_list,lett_list)</p>
			<p class="source-code">print(next(zipped_iter))</p>
			<p class="source-code">print(next(zipped_iter))</p>
			<p class="source-code">print(list(zipped_iter))</p>
			<p>In the preceding code example, we combined the two lists for iteration purposes by using the <strong class="source-inline">zip</strong> function. Note that one list is larger than the other in terms of the number of elements. The console output of this program should be as follows: </p>
			<p class="source-code">(1, 'alpha')</p>
			<p class="source-code">(2, 'bravo')</p>
			<p class="source-code">[(3, 'charlie'), (4, 'delta')]</p>
			<p>As expected, we get the first two tuples using the <strong class="source-inline">next</strong> function, which is a combination of corresponding elements from each list. In the end, we used the <strong class="source-inline">list</strong> constructor to iterate over the rest of the tuples from the <strong class="source-inline">zip</strong> iterator. This gives us a list of the remaining tuples in a list format. </p>
			<h3>itertools</h3>
			<p>Python offers a module, called <strong class="source-inline">itertools</strong>, that provides useful functions to work with iterators. When working with a large set of data, the use of iterators is a must, and that is where the utility functions provided by the <strong class="source-inline">itertool</strong> module prove to be very helpful. There are many functions available with the <strong class="source-inline">itertools</strong> module. We will briefly introduce a<a id="_idIndexMarker635"/> few key functions here:</p>
			<ul>
				<li><strong class="source-inline">count</strong>: This function is used to <a id="_idIndexMarker636"/>create an iterator for counting numbers. We can provide a starting number (default = 0) and, optionally, set a size of the counting step for the increment. The following code example will return an iterator that provides counting numbers, such as 10, 12, and 14: <p class="source-code">#<strong class="bold">itertools_count.py</strong></p><p class="source-code">import itertools</p><p class="source-code">iter = <strong class="bold">itertools.count</strong>(10, 2)</p><p class="source-code">print(next(iter))</p><p class="source-code">print(next(iter))</p></li>
				<li><strong class="source-inline">cycle</strong>: This function allows you to cycle through an iterator endlessly. The following code snippet illustrates how you can use this function for a list of alphabet letters:<p class="source-code">letters = {'A','B','C'}</p><p class="source-code">for letter in <strong class="bold">itertools.cycle</strong>(letters):</p><p class="source-code">    print(letter)</p></li>
				<li><strong class="source-inline">Repeat</strong>: This function provides us with an iterator that returns an object over and over again unless there is a <strong class="source-inline">times</strong> argument set with it. The following code snippet will repeat the <strong class="source-inline">Python</strong> string object five times: <p class="source-code">for x in <strong class="bold">itertools.repeat</strong>('Python', times=5):</p><p class="source-code">    print(x)</p></li>
				<li><strong class="source-inline">accumulate</strong>: This function will return an iterator that provides us with an accumulated sum or other accumulated results based on an aggregator function that was passed to this <strong class="source-inline">accumulate</strong> function as an argument. It is easier to understand the use <a id="_idIndexMarker637"/>of this function with a code example, as<a id="_idIndexMarker638"/> follows: <p class="source-code">#<strong class="bold">itertools_accumulate.py</strong></p><p class="source-code">import itertools, operator</p><p class="source-code">list1 = [1, 3, 5]</p><p class="source-code">res = itertools.<strong class="bold">accumulate</strong>(list1)</p><p class="source-code">print("default:")</p><p class="source-code">for x in res:</p><p class="source-code">    print(x)</p><p class="source-code">res = itertools.<strong class="bold">accumulate</strong>(list1, <strong class="bold">operator.mul</strong>)</p><p class="source-code">print("Multiply:" )</p><p class="source-code">for x in res:</p><p class="source-code">    print(x)</p><p>In this code example, first, we used the <strong class="source-inline">accumulate</strong> function without providing an aggregator function for any accumulated results. By default, the <strong class="source-inline">accumulate</strong> function will add two numbers (<strong class="source-inline">1</strong> and <strong class="source-inline">3</strong>) from the original list. This process is repeated for all numbers, and the results are stored inside an iterable (in our case, this is <strong class="source-inline">res</strong>). In the second part of this code example, we provided the <strong class="source-inline">mul</strong> (multiplication) function from the <strong class="source-inline">operator</strong> module, and this time, the accumulated results are based on the multiplication of two numbers.</p></li>
				<li><strong class="source-inline">chain</strong>: This function combines two or more iterables and returns a combined iterable. Take a look at the following example code showing two iterables (lists) along with the <strong class="source-inline">chain</strong> function:<p class="source-code">list1 = ['A','B','C']</p><p class="source-code">list2 = ['W','X','Y','Z']</p><p class="source-code">chained_iter = itertools.chain(list1, list2)</p><p class="source-code">for x in chained_iter:</p><p class="source-code">    print(x)</p><p>Note that this function will<a id="_idIndexMarker639"/> combine the iterables in a serial manner. This means that items in <strong class="source-inline">list1</strong> will be accessible first, followed by the items in <strong class="source-inline">list2</strong>.  </p></li>
				<li><strong class="source-inline">compress</strong>: This function can<a id="_idIndexMarker640"/> be used to filter elements from one iterable based on another iterable. In the example code snippet, we have selected alphabet letters from a list based on a <strong class="source-inline">selector</strong> iterable:<p class="source-code">letters = ['A','B','C']</p><p class="source-code">selector = [True, 0, 1]</p><p class="source-code">for x in <strong class="bold">itertools.compress</strong>(letters, selector):</p><p class="source-code">    print (x)</p><p>For the <strong class="source-inline">selector</strong> iterable, we can use <strong class="source-inline">True</strong><em class="italic">/</em><strong class="source-inline">False</strong> or <strong class="source-inline">1</strong><em class="italic">/</em><strong class="source-inline">0</strong>. The output of this program will be the letters <strong class="source-inline">A</strong> and <strong class="source-inline">C</strong>.</p></li>
				<li><strong class="source-inline">groupby</strong>: This function identifies the keys for each item in an iterable object and groups the items based on the identified keys. This function requires another function (known as <strong class="source-inline">key_func</strong>) that identifies a key in each element of an iterable object. The following example code explains the use of this function along with how to implement a <strong class="source-inline">key_func</strong> function:<p class="source-code">#<strong class="bold">itertools_groupby.py</strong></p><p class="source-code">import itertools</p><p class="source-code">mylist = [("A", 100), ("A", 200), ("B", 30), \</p><p class="source-code">("B", 10)]</p><p class="source-code">def <strong class="bold">get_key</strong>(group):</p><p class="source-code">    return group[0]</p><p class="source-code">for key, grp in itertools.<strong class="bold">groupby</strong>(mylist, <strong class="bold">get_key</strong>):</p><p class="source-code">    print(key + "--&gt;", list(grp))</p></li>
				<li><strong class="source-inline">tee</strong>: This is another useful<a id="_idIndexMarker641"/> function that can be used to duplicate iterators <a id="_idIndexMarker642"/>from a single iterator. Here is an example code that duplicates two iterators from a single list iterable:<p class="source-code">letters = ['A','B','C']</p><p class="source-code"><strong class="bold">iter1</strong>, <strong class="bold">iter2</strong> = itertools.<strong class="bold">tee</strong>(letters)</p><p class="source-code">for x in iter1:</p><p class="source-code">    print(x)</p><p class="source-code">for x in iter2:</p><p class="source-code">    print(x)</p></li>
			</ul>
			<p>Next, we will discuss another category of functions that is extensively used for data transformation. </p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor192"/>Using filters, mappers, and reducers for data transformations</h2>
			<p><strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and <strong class="source-inline">reduce</strong> <a id="_idIndexMarker643"/>are three functions available in Python that are used to simplify and write concise code. These three functions are applied to iterables in a single shot without using iterative statements. The <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> functions are available as built-in functions, while the <strong class="source-inline">reduce</strong> function requires you to import the <strong class="source-inline">functtools</strong> module. These functions are extensively used by data scientists for data processing. The <strong class="source-inline">map</strong> function and the <strong class="source-inline">filter</strong> function are used to transform or<a id="_idIndexMarker644"/> filter data, whereas the <strong class="source-inline">reduce</strong> function is used in data analysis<a id="_idIndexMarker645"/> to get meaningful results from a large dataset. </p>
			<p>In the following subsections, we will evaluate each function with its application and code examples. </p>
			<h3>map</h3>
			<p>The <strong class="source-inline">map</strong> function in Python is defined using the following syntax:</p>
			<p class="source-code">map(func, iter, ...)</p>
			<p>The <strong class="source-inline">func</strong> argument is the name of the <a id="_idIndexMarker646"/>function that will be applied to each item of the <strong class="source-inline">iter</strong> object. The three dots indicate that it is possible to pass multiple iterable objects. However, it is important to understand that the number of arguments of the function (<strong class="source-inline">func</strong>) must match the number of iterable objects. The output of the <strong class="source-inline">map</strong> function is a <strong class="source-inline">map</strong> object, which is a generator object. The return value can be converted into a list by passing the <strong class="source-inline">map</strong> object to the <strong class="source-inline">list</strong> constructor. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In Python 2, the <strong class="source-inline">map</strong> function returns a list. This behavior has been changed in Python 3.</p>
			<p>Before discussing the use of a <strong class="source-inline">map</strong> function, first, we will implement a simple transformation function that converts a list of numbers into their square values. The code example is provided next:</p>
			<p class="source-code">#<strong class="bold">map1.py</strong> to get square of each item in a list</p>
			<p class="source-code">mylist = [1, 2, 3, 4, 5]</p>
			<p class="source-code">new_list = []</p>
			<p class="source-code">for item in mylist:</p>
			<p class="source-code">    square = item*item</p>
			<p class="source-code">    new_list.append(square)</p>
			<p class="source-code">print(new_list)</p>
			<p>Here, the code example uses a <strong class="source-inline">for</strong> loop structure to iterate through a list, calculates the square of each entry in the list, and then adds it to a new list. This style of writing code is common, but it is definitely not a Pythonic way to write code. The console output of this program is as follows:</p>
			<p class="source-code">[1, 4, 9, 16, 25]</p>
			<p>With the use<a id="_idIndexMarker647"/> of the <strong class="source-inline">map</strong> function, this code can be simplified and shortened, as follows:</p>
			<p class="source-code"># <strong class="bold">map2.py</strong> to get square of each item in a list</p>
			<p class="source-code">def <strong class="bold">square</strong>(num):</p>
			<p class="source-code">    return num * num</p>
			<p class="source-code">mylist = [1, 2, 3, 4, 5]</p>
			<p class="source-code">new_list = list(<strong class="bold">map</strong>(<strong class="bold">square</strong>, <strong class="bold">mylist</strong>))</p>
			<p class="source-code">print(new_list)</p>
			<p>By using the <strong class="source-inline">map</strong> function, we provided the name of the function (in this example, it is <strong class="source-inline">square</strong>) and the reference of the list (in this example, it is <strong class="source-inline">mylist</strong>). The <strong class="source-inline">map</strong> object that is returned by the <strong class="source-inline">map</strong> function is converted into a list object by using the <strong class="source-inline">list</strong> constructor. The console output of this code example is the same as the previous code example. </p>
			<p>In the following code example, we will provide two lists as input for the <strong class="source-inline">map</strong> function: </p>
			<p class="source-code"># <strong class="bold">map3.py</strong> to get product of each item in two lists</p>
			<p class="source-code">def <strong class="bold">product</strong>(num1, num2):</p>
			<p class="source-code">    return num1 * num2</p>
			<p class="source-code">mylist1 = [1, 2, 3, 4, 5]</p>
			<p class="source-code">mylist2 = [6, 7, 8, 9]</p>
			<p class="source-code">new_list = list(<strong class="bold">map</strong>(<strong class="bold">product</strong>, <strong class="bold">mylist1</strong>, <strong class="bold">mylist2</strong>))</p>
			<p class="source-code">print(new_list)</p>
			<p>This time, the goal of the <strong class="source-inline">map</strong> function that has been implemented is to use the <strong class="source-inline">product</strong> function. The <strong class="source-inline">product</strong> function takes each item from two lists and multiplies the corresponding item in each list before returning it to the <strong class="source-inline">map</strong> function. </p>
			<p>The console output of this code example is as follows:</p>
			<p class="source-code">[6, 14, 24, 36] </p>
			<p>An analysis of this <a id="_idIndexMarker648"/>console output tells us that only the first four items from each list are used by the <strong class="source-inline">map</strong> function. The <strong class="source-inline">map</strong> function automatically stops when it runs out of the items in any of the iterables (in our case, these are the two lists). This means that even if we provide iterables of different sizes, the <strong class="source-inline">map</strong> function will not raise any exception but will work for the number of items that are possible to map across iterables using the function provided. In our code example, we have a smaller number of items in the <strong class="source-inline">mylist2</strong> list, which is four. That is why we only have four items in the output list (in our case, this is <strong class="source-inline">new_list</strong>). Next, we will discuss the <strong class="source-inline">filter</strong> function with some code examples.</p>
			<h3>filter</h3>
			<p>The <strong class="source-inline">filter</strong> function<a id="_idIndexMarker649"/> also operates on iterables but only on one iterable object. As its name suggests, it provides a filtering functionality on the iterable object. The filtering criteria are provided through the function definition. The syntax of a <strong class="source-inline">filter</strong> function is as follows:</p>
			<p class="source-code"> filter (func, iter)</p>
			<p>The <strong class="source-inline">func</strong> function provides the filtering criteria, and it has to return <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong>. Since only one iterable is allowed alongside the <strong class="source-inline">filter</strong> function, only one argument is allowed for the <strong class="source-inline">func</strong> function. The following code example uses a <strong class="source-inline">filter</strong> function to select the items whose values are even numbers. To implement the selection criteria, the function <strong class="source-inline">is_even</strong> is implemented to evaluate whether a number provided to it is an even number or not. The<a id="_idIndexMarker650"/> sample code is as follows:</p>
			<p class="source-code"># <strong class="bold">filter1</strong>.py to get even numbers from a list</p>
			<p class="source-code">def <strong class="bold">is_even</strong>(num):</p>
			<p class="source-code">    return (num % 2 == 0)</p>
			<p class="source-code">mylist = [1, 2, 3, 4, 5,6,7,8,9]</p>
			<p class="source-code">new_list = list(<strong class="bold">filter</strong>(<strong class="bold">is_even</strong>, <strong class="bold">mylist</strong>))</p>
			<p class="source-code">print(new_list)</p>
			<p>The console output of the preceding code example is as follows: </p>
			<p class="source-code">[2, 4, 6, 8]</p>
			<p>Next, we will discuss the <strong class="source-inline">reduce</strong> function. </p>
			<h3>reduce</h3>
			<p>The <strong class="source-inline">reduce</strong> function is used to apply a cumulative processing function on each element of a sequence, which is passed to it as an argument. This cumulative <a id="_idIndexMarker651"/>processing function is not for transformation or filtration purposes. As its name suggests, the cumulative processing function is used to get a single result at the end based on all of the elements in a sequence. The syntax of using the <strong class="source-inline">reduce</strong> function is as follows:</p>
			<p class="source-code">reduce (func, iter[,initial])</p>
			<p>The <strong class="source-inline">func</strong> function is a function that is used to apply cumulative processing on each element of the iterable. Additionally, <strong class="source-inline">initial</strong> is an optional value that can be passed to the <strong class="source-inline">func</strong> function to be used as an initial value for cumulative processing. It is important to understand that there will always be two arguments to the <strong class="source-inline">func</strong> function for the <strong class="source-inline">reduce</strong> function case: the first argument will either be the initial value (if provided) or the first element of the sequence, and the second argument will be the next element from the sequence. </p>
			<p>In the following code example, we will use a simple list of the first five numbers. We will implement a custom method to add the two numbers and then use the <strong class="source-inline">reduce</strong> method to sum all of the elements in the list. The code example is shown next:</p>
			<p class="source-code"># <strong class="bold">reduce1</strong>.py to get sum of numbers from a list</p>
			<p class="source-code">from functools import reduce</p>
			<p class="source-code">def <strong class="bold">seq_sum</strong>(num1, num2):</p>
			<p class="source-code">    return num1+num2</p>
			<p class="source-code">mylist = [1, 2, 3, 4, 5]</p>
			<p class="source-code">result = <strong class="bold">reduce</strong>(seq_sum, mylist)</p>
			<p class="source-code">print(result) </p>
			<p>The output of this program is <strong class="source-inline">15</strong>, which is a numerical sum of all the elements of the list (in our example, this is called <strong class="source-inline">mylist</strong>). If we provide the initial value to the <strong class="source-inline">reduce</strong> function, the result will be appended as per the initial value. For example, the output of the same program with the following statement will be <strong class="source-inline">25</strong>:</p>
			<p class="source-code">result = reduce(seq_sum, mylist, 10)</p>
			<p>As mentioned previously, the result or <a id="_idIndexMarker652"/>return value of the <strong class="source-inline">reduce</strong> function is a single value, which is as per the <strong class="source-inline">func</strong> function. In this example, it will be an integer. </p>
			<p>In this section, we discussed the <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and <strong class="source-inline">reduce</strong> functions that are available within Python. These functions are used extensively by data scientists for data transformation and data refinement. One problem of using functions such as <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> is that they return an object of the <strong class="source-inline">map</strong> or <strong class="source-inline">filter</strong> type, and we have to convert the results explicitly into a <strong class="source-inline">list</strong> data type for further processing. The comprehensions and generators do not have such limitations but provide similar functionality, and they are relatively <a id="_idIndexMarker653"/>easier to use. That is why they are getting more traction than the <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and <strong class="source-inline">reduce</strong> functions. We will discuss comprehension and generators in the <em class="italic">Understanding advanced concepts with data structures</em> section. Next, we will investigate the use of lambda functions. </p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor193"/>Learning how to build lambda functions</h2>
			<p>Lambda functions are <a id="_idIndexMarker654"/>anonymous functions that are based on a single-line expression. Just as the <strong class="source-inline">def</strong> keyword is used to define regular functions, the <strong class="source-inline">lambda</strong> keyword is used to define anonymous functions. Lambda functions are restricted to a single line. This means they cannot use multiple statements, and they cannot use a return statement. The return value is automatically returned after the evaluation of the single-line expression. </p>
			<p>The lambda functions can be used anywhere a regular function is used. The easiest and most convenient usage of lambda functions is with the <strong class="source-inline">map</strong>, <strong class="source-inline">reduce</strong>, and <strong class="source-inline">filter</strong> functions. Lambda functions are helpful when you wish to make the code more concise. </p>
			<p>To illustrate a lambda function, we will reuse the map and filter code examples that we discussed earlier. In these code examples, we will replace <strong class="source-inline">func</strong> with a lambda function, as highlighted in the following code snippet:</p>
			<p class="source-code"># <strong class="bold">lambda1</strong>.py to get square of each item in a list</p>
			<p class="source-code">mylist = [1, 2, 3, 4, 5]</p>
			<p class="source-code">new_list = list(map(<strong class="bold">lambda x</strong>: x*x, mylist))</p>
			<p class="source-code">print(new_list)</p>
			<p class="source-code"># <strong class="bold">lambda2</strong>.py to get even numbers from a list</p>
			<p class="source-code">mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
			<p class="source-code">new_list = list(filter(<strong class="bold">lambda x</strong>: x % 2 == 0, mylist))</p>
			<p class="source-code">print(new_list)</p>
			<p class="source-code"><strong class="bold"># lambda3.py to get product of corresponding item in the\</strong></p>
			<p class="source-code"><strong class="bold"> two lists</strong></p>
			<p class="source-code"><strong class="bold">mylist1 = [1, 2, 3, 4, 5]</strong></p>
			<p class="source-code"><strong class="bold">mylist2 = [6, 7, 8, 9]</strong></p>
			<p class="source-code"><strong class="bold">new_list = list(map(lambda x,y: x*y, mylist1, mylist2))</strong></p>
			<p class="source-code"><strong class="bold">print(new_list)</strong></p>
			<p>Although the code has become more concise, we should be careful about using lambda functions. These functions are not reusable, and they are not easy to maintain. We need to rethink this before<a id="_idIndexMarker655"/> introducing a lambda function into our program. Any changes or additional functionality will not be easy to add. A rule of thumb is to only use lambda functions for simple expressions when writing a separate function would be an overhead. </p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor194"/>Embedding a function within another function</h2>
			<p>When we add <a id="_idIndexMarker656"/>a function within an <a id="_idIndexMarker657"/>existing function, it is called an <strong class="bold">inner function</strong> or a <strong class="bold">nested function</strong>. The advantage of having inner functions is that they have direct access to the variables that are either defined or available in the scope <a id="_idIndexMarker658"/>of an outer function. Creating an inner function is the same as defining a regular function with the <strong class="source-inline">def</strong> keyword and with the appropriate indentation. The inner functions cannot be executed or called by the outside program. However, if the outer function returns a reference of the inner function, it can be used by the caller to execute the inner function. We will take a look at examples of returning inner function references for many use cases in the following subsections. </p>
			<p>Inner functions have many advantages and applications. We will describe a few of them next.</p>
			<h3>Encapsulation</h3>
			<p>A common use case of <a id="_idIndexMarker659"/>an inner function is being able to hide its functionality from the outside world. The inner function is only available within the outer function scope and is not visible to the global scope. The following code example shows one outer function that is hiding an inner function:</p>
			<p class="source-code">#<strong class="bold">inner1</strong>.py</p>
			<p class="source-code">def <strong class="bold">outer_hello</strong>():</p>
			<p class="source-code">    print ("Hello from outer function")</p>
			<p class="source-code">    <strong class="bold">def inner_hello</strong>():</p>
			<p class="source-code">        print("Hello from inner function")</p>
			<p class="source-code">    <strong class="bold">inner_hello</strong>()</p>
			<p class="source-code">outer_hello()</p>
			<p>From the outside of the outer function, we can only call the outer function. The inner function can only be called from the body of the outer function.</p>
			<h3>Helper functions</h3>
			<p>In some cases, we can find ourselves<a id="_idIndexMarker660"/> in a situation where the code within a function code is reusable. We can turn such reusable code into a separate function; otherwise, if the code is reusable only within the scope of a function, then it is a case of building an inner function. This type of inner function is also called the helper function. The following code snippet illustrates this concept:</p>
			<p class="source-code">def <strong class="bold">outer_fn</strong>(x, y):</p>
			<p class="source-code">    <strong class="bold">def get_prefix</strong>(s):</p>
			<p class="source-code">        return s[:2] </p>
			<p class="source-code">    <strong class="bold">x2 = get_prefix(x)</strong></p>
			<p class="source-code"><strong class="bold">    y2 = get_prefix(y)</strong></p>
			<p class="source-code"><strong class="bold">    #process x2 and y2 further</strong></p>
			<p>In the preceding sample code, we defined an inner function, called <strong class="source-inline">get_prefix</strong> (a helper function), inside an outer function to filter the first two letters of an argument value. Since we have to repeat<a id="_idIndexMarker661"/> this filtering process for all arguments, we added a helper function for reusability within the scope of this function as it is specific to this function.</p>
			<h3>The closure and factory functions</h3>
			<p>This is a type of use case in<a id="_idIndexMarker662"/> which the inner functions shine. A <strong class="bold">closure</strong> is an inner function along with its enclosing environment. A closure is a dynamically created function that can be returned by another function. The real magic of a closure is that the returned <a id="_idIndexMarker663"/>function has full access to the variables and namespaces where it was created. This is true even when the enclosing function (in this context, it is the outer function) has finished executing. </p>
			<p>The closure concept can be illustrated by a code example. The following code example shows a use case where we have implemented a closure factory to create a function to calculate the power of the base value, and the base value is retained by the closure:</p>
			<p class="source-code"># <strong class="bold">inner2</strong>.py</p>
			<p class="source-code">def <strong class="bold">power_calc_factory</strong>(base):</p>
			<p class="source-code">    def <strong class="bold">power_calc</strong>(exponent):</p>
			<p class="source-code">        return base**exponent</p>
			<p class="source-code">    return <strong class="bold">power_calc</strong></p>
			<p class="source-code">power_calc_2 = power_gen_factory(2)</p>
			<p class="source-code">power_calc_3 = power_gen_factory(3)</p>
			<p class="source-code">print(power_calc_2(2))</p>
			<p class="source-code">print(power_calc_2(3))</p>
			<p class="source-code">print(power_calc_3(2))</p>
			<p class="source-code">print(power_calc_3(4))</p>
			<p>In the preceding code example, the outer function (that is, <strong class="source-inline">power_calc_factory</strong>) acts as a closure factory function because it creates a new closure every time it is called, and then it returns the closure to the caller. Additionally, <strong class="source-inline">power_calc</strong> is an inner function that takes one variable (that is, <strong class="source-inline">base</strong>) from the closure namespace and then takes the second variable (that is, <strong class="source-inline">exponent</strong>), which is passed to it as an argument. Note that the most important statement is <strong class="source-inline">return power_calc</strong>. This statement returns the inner function as an object with its enclosure.</p>
			<p>When we call the <strong class="source-inline">power_calc_factory</strong> function for the first time along with the <strong class="source-inline">base</strong> argument, a closure is created with its namespace, including the argument that was passed to it, and the closure is returned to the caller. When we call the same function again, we get a new closure with the inner function object. In this code example, we created 2 closures: one with a <strong class="source-inline">base</strong> value of 2 and the other with a <strong class="source-inline">base</strong> value of 3. When we called the inner function by passing different values for the <strong class="source-inline">exponent</strong> variable, the <a id="_idIndexMarker664"/>code inside the inner function (in this case, the <strong class="source-inline">power_calc</strong> function) will also have access to the <strong class="source-inline">base</strong> value that was already passed to the outer function. </p>
			<p>These code examples illustrated<a id="_idIndexMarker665"/> the use of outer and inner functions to create functions dynamically. Traditionally, inner functions are used for hiding or encapsulating functionality inside a function. But when they are used along with the outer functions acting as a factory for creating dynamic functions, it becomes the most powerful application of the inner functions. Inner functions are also used to implement decorators. We will discuss this in more detail in the following section. </p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor195"/>Modifying function behavior using decorators</h2>
			<p>The concept of decorators <a id="_idIndexMarker666"/>in Python is based on the <strong class="bold">Decorator</strong> design pattern, which is a type of structural design pattern. This pattern allows you to add new behavior to objects without changing anything in the object implementation. This new behavior is added inside the special wrapper objects. </p>
			<p>In Python, <strong class="bold">decorators</strong> are special<a id="_idIndexMarker667"/> high-order functions that enable developers to add new functionality to an existing function (or a method) without adding or changing anything within the function. Typically, these decorators are added before the definition of a function. Decorators are used for implementing many features of an application, but they are particularly popular in data validation, logging, caching, debugging, encryption, and transaction management. </p>
			<p>To create a decorator, we have to define a callable entity (that is, a function, a method, or a class) that accepts a function as an argument. The callable entity will return another function object with a decorator-defined behavior. The function that is decorated (we will call it a <em class="italic">decorated function</em> for the remainder of this section) is passed as an argument to the function that is implementing a decorator (which will be called a <em class="italic">decorator function</em> for the<a id="_idIndexMarker668"/> remainder of this section). The decorator function executes the function passed to it in addition to the additional behavior that was added as part of the decorator function. </p>
			<p>A simple example of a decorator is shown in the following code example in which we define a decorator to add a timestamp before and after the execution of a function:</p>
			<p class="source-code"># <strong class="bold">decorator1</strong>.py</p>
			<p class="source-code">from datetime import datetime</p>
			<p class="source-code">def <strong class="bold">add_timestamps</strong>(myfunc):</p>
			<p class="source-code">    def <strong class="bold">_add_timestamps</strong>():</p>
			<p class="source-code">        print(datetime.now())</p>
			<p class="source-code">        myfunc()</p>
			<p class="source-code">        print(datetime.now())</p>
			<p class="source-code">    return <strong class="bold">_add_timestamps</strong></p>
			<p class="source-code">@<strong class="bold">add_timestamps</strong></p>
			<p class="source-code">def hello_world():</p>
			<p class="source-code">    print("hello world")</p>
			<p class="source-code">hello_world()</p>
			<p>In this code example, we define a <strong class="source-inline">add_timestamps</strong> decorator function that takes any function as an argument. In the inner function (<strong class="source-inline">_add_timestamps</strong>), we take the current time before and after the execution of the function, which is then passed as an argument. The decorator function returns the inner function object with a closure. The decorators are doing nothing more than using inner functions smartly, as we discussed in the previous section. The use of the <strong class="source-inline">@</strong> symbol to decorate a function is equivalent to the following lines of codes: </p>
			<p class="source-code">hello = add_timestamps(hello_world)</p>
			<p class="source-code">hello()</p>
			<p>In this case, we are calling the<a id="_idIndexMarker669"/> decorator function explicitly by passing the function name as a parameter. In other words, the decorated function is equal to the inner function, which is defined inside the decorator function. This is exactly how Python interprets and calls the decorator function when it sees a decorator with the <strong class="source-inline">@</strong> symbol before the definition of a function. </p>
			<p>However, a problem arises when we have to obtain additional details about the invocation of functions, which is important for debugging. When we use the built-in <strong class="source-inline">help</strong> function with the <strong class="source-inline">hello_world</strong> function, we only receive help for the inner function. The same happens if we use the docstring, which will also work for the inner function but not the decorated function. Additionally, serializing the code is going to be a challenge for decorated functions. There is a simple solution that is available in Python for all of these problems; that solution is to use the <strong class="source-inline">wraps</strong> decorator from the <strong class="source-inline">functools</strong> library. We will revise our previous code example to include the <strong class="source-inline">wraps</strong> decorator. The complete code example is as follows:</p>
			<p class="source-code"># <strong class="bold">decorator2</strong>.py</p>
			<p class="source-code">from datetime import datetime</p>
			<p class="source-code">from functools import wraps</p>
			<p class="source-code">def <strong class="bold">add_timestamps</strong>(myfunc):</p>
			<p class="source-code">    @<strong class="bold">wraps(myfunc)</strong></p>
			<p class="source-code">    def <strong class="bold">_add_timestamps</strong>():</p>
			<p class="source-code">        print(datetime.now())</p>
			<p class="source-code">        myfunc()</p>
			<p class="source-code">        print(datetime.now())</p>
			<p class="source-code">    return _add_timestamps</p>
			<p class="source-code">@add_timestamps</p>
			<p class="source-code">def hello_world():</p>
			<p class="source-code">    print("hello world")</p>
			<p class="source-code">hello_world()</p>
			<p class="source-code"><strong class="bold">help</strong>(hello_world)</p>
			<p class="source-code"><strong class="bold">print</strong>(hello_world)</p>
			<p>The use of the <strong class="source-inline">wraps</strong> decorators <a id="_idIndexMarker670"/>will provide additional details about the executions of the nested functions, and we can view these in the console output if we run the example code that has been provided. </p>
			<p>So far, we have looked at a simple example of a decorator to explain this concept. For the remainder of this section, we will learn how to pass arguments with a function to a decorator, how to return value from a decorator, and how to chain multiple decorators. To begin, we will learn how to pass attributes and return a value with decorators. </p>
			<h3>Using a decorated function with a return value and argument </h3>
			<p>When our decorated<a id="_idIndexMarker671"/> function takes arguments, then decorating such a function requires some additional tricks. One trick is to use <strong class="source-inline">*args</strong> and <strong class="source-inline">**kwargs</strong> in the inner wrapper function. This will make the inner function accept any arbitrary number of positional and keyword arguments. Here is a simple example of a decorated function with arguments along with the return value:</p>
			<p class="source-code"># <strong class="bold">decorator3</strong>.py</p>
			<p class="source-code">from functools import wraps</p>
			<p class="source-code">def power(func):</p>
			<p class="source-code">    @wraps(func)</p>
			<p class="source-code">    def <strong class="bold">inner_calc(*args, **kwargs</strong>):</p>
			<p class="source-code">        print("Decorating power func")</p>
			<p class="source-code">        <strong class="bold">n = func(*args, **kwargs)</strong></p>
			<p class="source-code">        return n</p>
			<p class="source-code">    return inner_calc</p>
			<p class="source-code">@<strong class="bold">power</strong></p>
			<p class="source-code">def <strong class="bold">power_base2</strong>(n):</p>
			<p class="source-code">    return 2**n</p>
			<p class="source-code">print(power_base2(3))</p>
			<p>In the preceding example, the inner function of <strong class="source-inline">inner_calc</strong> takes the generic parameters of <strong class="source-inline">*args</strong> and <strong class="source-inline">**kwargs</strong>. To return a value from an inner function (in our code example, <strong class="source-inline">inner_calc</strong>), we can hold the returned value from the function (in our code example, this is<a id="_idIndexMarker672"/> either <strong class="source-inline">func</strong> or <strong class="source-inline">power_base2(n)</strong>) that is executed inside our inner function and return the final return value from the inner function of <strong class="source-inline">inner_calc</strong>.</p>
			<h3>Building a decorator with its own arguments</h3>
			<p>In the previous examples, we<a id="_idIndexMarker673"/> used what we call <strong class="bold">standard decorators</strong>. A standard decorator is a function that gets the decorated function <a id="_idIndexMarker674"/>name as an argument and returns an inner function that works as a decorator function. However, it is a bit different when we have a decorator with its own arguments. Such decorators are built on top of standard decorators. Put simply, a decorator with arguments is another function that actually returns a standard decorator (not the inner function inside a decorator). This concept of a standard decorator function wrapped within another decorator function can be understood better with a revised version of the <strong class="source-inline">decorator3.py</strong> example. In the revised version, we calculate the power of a base value that is passed as an argument to the decorator. You can view a complete code example using nested decorator functions as follows:</p>
			<p class="source-code"># <strong class="bold">decorator4</strong>.py</p>
			<p class="source-code">from functools import wraps</p>
			<p class="source-code">def <strong class="bold">power_calc</strong>(base):</p>
			<p class="source-code">    def <strong class="bold">inner_decorator</strong>(func):</p>
			<p class="source-code">        @wraps(func)</p>
			<p class="source-code">        def <strong class="bold">inner_calc</strong>(*args, **kwargs):</p>
			<p class="source-code">            exponent = func(*args, **kwargs)</p>
			<p class="source-code">            return base**exponent</p>
			<p class="source-code">        return inner_calc</p>
			<p class="source-code">    return <strong class="bold">inner_decorator</strong></p>
			<p class="source-code">@<strong class="bold">power_calc</strong>(base=3)</p>
			<p class="source-code">def power_n(n):</p>
			<p class="source-code">    return n</p>
			<p class="source-code">print(power_n(2))</p>
			<p class="source-code">print(power_n(4))</p>
			<p>The working of this code <a id="_idIndexMarker675"/>example is as follows:</p>
			<ul>
				<li>The <strong class="source-inline">power_calc</strong> decorator function takes one argument base and returns the <strong class="source-inline">inner_decorator</strong> function, which is a standard decorator implementation. </li>
				<li>The <strong class="source-inline">inner_decorator</strong> function takes a function as an argument and returns the <strong class="source-inline">inner_calc</strong> function to do the actual calculation.</li>
				<li>The <strong class="source-inline">inner_calc</strong> function calls the decorated function to get the <strong class="source-inline">exponent</strong> attribute (in this case) and then uses the <strong class="source-inline">base</strong> attribute, which is passed to the outer decorator function as an argument. As expected, the closure around the inner function makes the value of the <strong class="source-inline">base</strong> attribute available to the <strong class="source-inline">inner_calc</strong> function.  </li>
			</ul>
			<p>Next, we will discuss how to<a id="_idIndexMarker676"/> use more than one decorator with a function or a method. </p>
			<h3>Using multiple decorators</h3>
			<p>We have learned numerous<a id="_idIndexMarker677"/> times that there is a possibility of using more than one decorator with a function. This is possible by chaining the decorators. Chained decorators can either be the same or different. This can be achieved by placing the decorators one after the other before the function definition. When more than one decorator is used with a function, the decorated function is only executed once. To illustrate its implementation and practical use, we have selected an example in which we log a message to a target system using a timestamp. The timestamp is added through a separate decorator, and the target system is also selected based on another decorator. The following code sample shows the definitions of three decorators, that is, <strong class="source-inline">add_time_stamp</strong>, <strong class="source-inline">file</strong>, and <strong class="source-inline">console</strong>:</p>
			<p class="source-code"># <strong class="bold">decorator5.py (part 1)</strong></p>
			<p class="source-code">from datetime import datetime</p>
			<p class="source-code">from functools import wraps</p>
			<p class="source-code">def <strong class="bold">add_timestamp</strong>(func):</p>
			<p class="source-code">    @wraps(func)</p>
			<p class="source-code">    def inner_func(*args, **kwargs):</p>
			<p class="source-code">        res = "{}:{}\n".format(datetime.now(),func(*args,\</p>
			<p class="source-code">          **kwargs))</p>
			<p class="source-code">        return res</p>
			<p class="source-code">    return inner_func</p>
			<p class="source-code">def <strong class="bold">file</strong>(func):</p>
			<p class="source-code">    @wraps(func)</p>
			<p class="source-code">    def inner_func(*args, **kwargs):</p>
			<p class="source-code">        res = func(*args, **kwargs)</p>
			<p class="source-code">        with open("log.txt", 'a') as file:</p>
			<p class="source-code">           file.write(res)</p>
			<p class="source-code">        return res</p>
			<p class="source-code">    return inner_func</p>
			<p class="source-code">def <strong class="bold">console</strong>(func):</p>
			<p class="source-code">    @wraps(func)</p>
			<p class="source-code">    def inner_func(*args, **kwargs):</p>
			<p class="source-code">        res = func(*args, **kwargs)</p>
			<p class="source-code">        print(res)</p>
			<p class="source-code">        return res</p>
			<p class="source-code">    return inner_func</p>
			<p>In the preceding code <a id="_idIndexMarker678"/>example, we implemented three decorator functions. They are as follows:</p>
			<ul>
				<li><strong class="source-inline">file</strong>: This decorator uses a predefined text file and adds the message provided by the decorated function to the file.</li>
				<li><strong class="source-inline">console</strong>: This decorator outputs the message provided by the decorated function to the console. </li>
				<li><strong class="source-inline">add_timestamp</strong>: This decorator adds a timestamp prior to the message provided by the decorated function. The execution of this decorator function has to occur before the file or console decorators, which means this decorator has to be placed last in the chain of decorators.</li>
			</ul>
			<p>In the following code snippet, we can use these decorators for different functions inside our main program:</p>
			<p class="source-code">#<strong class="bold">decorator5.py (part 2)</strong></p>
			<p class="source-code">@<strong class="bold">file</strong></p>
			<p class="source-code">@<strong class="bold">add_timestamp</strong></p>
			<p class="source-code">def log(msg):</p>
			<p class="source-code">    return msg</p>
			<p class="source-code">@<strong class="bold">file</strong></p>
			<p class="source-code">@<strong class="bold">console</strong></p>
			<p class="source-code">@<strong class="bold">add_timestamp</strong></p>
			<p class="source-code">def log1(msg):</p>
			<p class="source-code">    return msg</p>
			<p class="source-code">@<strong class="bold">console</strong></p>
			<p class="source-code">@<strong class="bold">add_timestamp</strong></p>
			<p class="source-code">def log2(msg):</p>
			<p class="source-code">    return msg</p>
			<p class="source-code">log("This is a test message for file only")</p>
			<p class="source-code">log1("This is a test message for both file and console")</p>
			<p class="source-code">log2("This message is for console only")</p>
			<p>In the preceding code sample, we<a id="_idIndexMarker679"/> used the three decorator functions defined earlier in different combinations to exhibit the different behaviors from the same logging function. In the first combination, we output the message to the file only after adding the timestamp. In the second combination, we output the message to both the file and the console. In the final combination, we output the message to the console only. This shows the flexibility that the decorators provide without needing to change the functions. It is worth mentioning that the decorators are very useful in simplifying the code and adding behavior in a concise way, but they have the cost of additional <a id="_idIndexMarker680"/>overheads during execution. The use of decorators should be limited to those scenarios where the benefit is enough to compensate for any overhead costs. </p>
			<p>This concludes our discussion regarding advanced function concepts and tricks. In the next section, we will switch gears to some advanced concepts related to data structures. </p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor196"/>Understanding advanced concepts with data structures</h1>
			<p>Python offers comprehensive support for data structures, including key tools for storing data and accessing data for processing and retrieving. In <a href="B17189_04_Final_PG_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 4</em></a>, <em class="italic">Python Libraries for Advanced Programming</em>, we discussed the data structure objects that are available in Python. In this section, we <a id="_idIndexMarker681"/>will cover a number of advanced concepts such as a dictionary within a dictionary and how to use comprehension with a data structure. We will start by embedding a dictionary inside a dictionary.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor197"/>Embedding a dictionary inside a dictionary</h2>
			<p>A dictionary in a dictionary or a nested dictionary is the process of putting a dictionary inside another dictionary. A nested <a id="_idIndexMarker682"/>dictionary is useful in many real-world examples, particularly when you are processing and transforming data from one format into the other. </p>
			<p><em class="italic">Figure 6.1</em> shows a nested dictionary. The root dictionary has two dictionaries against key <strong class="source-inline">1</strong> and key <strong class="source-inline">3</strong>. The dictionary against key <strong class="source-inline">1</strong> has further dictionaries inside it. The dictionary against key <strong class="source-inline">3</strong> is a regular dictionary with key-value pairs as its entries:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B17189_06_01.jpg" alt="Figure 6.1: An example of a dictionary inside a dictionary&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: An example of a dictionary inside a dictionary</p>
			<p>The root dictionary shown in <em class="italic">Figure 6.1</em> can be written as follows:</p>
			<p class="source-code">root_dict = {'1': {'A': {dictA}, 'B':{dictB}},</p>
			<p class="source-code">             '2': [list2],</p>
			<p class="source-code">             '3': {'X': val1,'Y':val2,'Z': val3}</p>
			<p class="source-code">            }</p>
			<p>Here, we created a root <a id="_idIndexMarker683"/>dictionary with a mix of dictionary objects and list objects inside it. </p>
			<h3>Creating or defining a nested dictionary </h3>
			<p>A nested dictionary can be <a id="_idIndexMarker684"/>defined or created by placing comma-separated dictionaries <a id="_idIndexMarker685"/>within curly brackets. To demonstrate how to create a nested dictionary, we will create a dictionary for students. Each student entry will have another dictionary with <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong> as its elements, which are mapped to their student number:</p>
			<p class="source-code"># <strong class="bold">dictionary1</strong>.py</p>
			<p class="source-code">dict1 = {<strong class="bold">100</strong>:{'name':'John', 'age':24},</p>
			<p class="source-code">         <strong class="bold">101</strong>:{'name':'Mike', 'age':22},</p>
			<p class="source-code">         <strong class="bold">102</strong>:{'name':'Jim', 'age':21} }</p>
			<p class="source-code">print(dict1)</p>
			<p class="source-code">print(dict1.get(100))</p>
			<p>Next, we will learn how to<a id="_idIndexMarker686"/> create a dictionary dynamically and how to <a id="_idIndexMarker687"/>add or update nested dictionary elements. </p>
			<h3>Adding to a nested dictionary</h3>
			<p>To create a dictionary in a <a id="_idIndexMarker688"/>dictionary dynamically or to add elements to an existing nested dictionary, we can use multiple approaches. In the following code example, we will used three different approaches to build a nested dictionary. They are the same as the ones we defined in the <strong class="source-inline">dictionary1.py</strong> module: </p>
			<ul>
				<li>In the first case, we will build an inner dictionary (that is, <strong class="source-inline">student101</strong>) through the direct assignment of key-value pair items and then by assigning it to a key in the root dictionary. This is the preferred approach whenever possible because the code is both easier to read and manage. </li>
				<li>In the second case, we created an empty inner dictionary (that is, <strong class="source-inline">student102</strong>) and assigned the values to the keys through assignment statements. This is also a preferred approach when the values are available to us through other data structures. </li>
				<li>In the third case, we directly initiate an empty directory for the third key of the root dictionary. After the initialization process, we assign the values using double indexing (that is, two keys): the first key is for the root dictionary, and the second key is for the inner dictionary. This approach makes the code concise, but it is not a preferred approach if code readability is important for maintenance reasons. </li>
			</ul>
			<p>The complete code example for these three different cases is as follows:</p>
			<p class="source-code"># <strong class="bold">dictionary2</strong>.py</p>
			<p class="source-code">#<strong class="bold">defining inner dictionary 1</strong></p>
			<p class="source-code">student100 = {'name': 'John', 'age': 24}</p>
			<p class="source-code">#<strong class="bold">defining inner dictionary 2</strong></p>
			<p class="source-code">student101 = {}</p>
			<p class="source-code">student101['name'] = 'Mike'</p>
			<p class="source-code">student101['age'] = '22'</p>
			<p class="source-code">#<strong class="bold">assigning inner dictionaries 1 and 2 to a root dictionary</strong></p>
			<p class="source-code">dict1 = {}</p>
			<p class="source-code">dict1[100] = student100</p>
			<p class="source-code">dict1[101] = student101</p>
			<p class="source-code">#<strong class="bold">creating inner dictionary directly inside a root \</strong></p>
			<p class="source-code"><strong class="bold">dictionary</strong></p>
			<p class="source-code">dict1[102] = {}</p>
			<p class="source-code">dict1[102]['name'] = 'Jim'</p>
			<p class="source-code">dict1[102]['age'] = '21'</p>
			<p class="source-code">print(dict1)</p>
			<p class="source-code">print(dict1.get(102))</p>
			<p>Next, we will discuss how to access different<a id="_idIndexMarker689"/> elements from a nested dictionary. </p>
			<h3>Accessing elements from a nested dictionary </h3>
			<p>As we discussed earlier, to <a id="_idIndexMarker690"/>add values and dictionaries inside a dictionary, we can use double indexing. Alternatively, we can use the <strong class="source-inline">get</strong> method of the dictionary object. The same approach is applicable to access different elements from an inner dictionary. The following is an example code that illustrates how to access different elements from the inner dictionaries using the <strong class="source-inline">get</strong> method and double indexes:</p>
			<p class="source-code"># <strong class="bold">dictionary3</strong>.py</p>
			<p class="source-code">dict1 = {100:{'name':'John', 'age':24},</p>
			<p class="source-code">         101:{'name':'Mike', 'age':22},</p>
			<p class="source-code">         102:{'name':'Jim', 'age':21} }</p>
			<p class="source-code">print(<strong class="bold">dict1.get(100)</strong>)</p>
			<p class="source-code">print(<strong class="bold">dict1.get(100).get('name')</strong>)</p>
			<p class="source-code">print(<strong class="bold">dict1[101]</strong>)</p>
			<p class="source-code">print(<strong class="bold">dict1[101]['age']</strong>)</p>
			<p>Next, we will examine how to delete an inner dictionary or a key-value pair item from an inner dictionary. </p>
			<h3>Deleting from a nested dictionary</h3>
			<p>To delete a dictionary or an <a id="_idIndexMarker691"/>element from a dictionary, we can use the generic <strong class="source-inline">del</strong> function, or we can use the <strong class="source-inline">pop</strong> method of the <strong class="source-inline">dictionary</strong> object. In the following example code, we will present both the <strong class="source-inline">del</strong> function and the <strong class="source-inline">pop</strong> method to demonstrate their usage: </p>
			<p class="source-code"># <strong class="bold">dictionary4</strong>.py</p>
			<p class="source-code">dict1 = {100:{'name':'John', 'age':24},</p>
			<p class="source-code">         101:{'name':'Mike', 'age':22},</p>
			<p class="source-code">         102:{'name':'Jim', 'age':21} }</p>
			<p class="source-code"><strong class="bold">del</strong> (dict1[101]['age'])</p>
			<p class="source-code">print(dict1)</p>
			<p class="source-code">dict1[102].<strong class="bold">pop</strong>('age')</p>
			<p class="source-code">print(dict1)</p>
			<p>In the next section, we <a id="_idIndexMarker692"/>will discuss how comprehension helps to process data from different data structure types.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor198"/>Using comprehension</h2>
			<p><strong class="bold">Comprehension</strong> is a quick way in <a id="_idIndexMarker693"/>which to build new sequences such as lists, sets, and dictionaries from existing sequences. Python supports four different types <a id="_idIndexMarker694"/>of comprehension, as follows:</p>
			<ul>
				<li>List comprehension</li>
				<li>Dictionary comprehension</li>
				<li>Set comprehension</li>
				<li>Generator comprehension</li>
			</ul>
			<p>We will discuss a brief overview, with code examples, for each of these comprehension types in the following subsections. </p>
			<h3>List comprehension</h3>
			<p><strong class="bold">List comprehension</strong> involves<a id="_idIndexMarker695"/> creating a dynamic list using a loop and a conditional statement if needed. </p>
			<p>A few examples of how to use<a id="_idIndexMarker696"/> list comprehension will help us to understand the concept better. In the first example (that is, <strong class="source-inline">list1.py</strong>), we will create a new list from an original list by adding 1 to each element of the original list. Here is the code snippet: </p>
			<p class="source-code">#<strong class="bold">list1</strong>.py</p>
			<p class="source-code">list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</p>
			<p class="source-code">list2 = [<strong class="bold">x+1</strong> for <strong class="bold">x in list1</strong>]</p>
			<p class="source-code">print(list2)</p>
			<p>In this case, the new list will be created using the <strong class="source-inline">x+1</strong> expression, where <strong class="source-inline">x</strong> is an element in the<a id="_idIndexMarker697"/> original list. This is equivalent to the following traditional code:</p>
			<p class="source-code">list2 = []</p>
			<p class="source-code">for x in list1:</p>
			<p class="source-code">    list2.append(x+1)</p>
			<p>Using list comprehension, we can achieve these three lines of code with only one line of code. </p>
			<p>In the second example (that is, <strong class="source-inline">list2.py</strong>), we will create a new list from the original list of numbers from 1 to 10 but only include even numbers. We can do this by simply adding a condition to the previous code example, as follows:</p>
			<p class="source-code">#<strong class="bold">list2</strong>.py</p>
			<p class="source-code">list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
			<p class="source-code">list2 = [x for x in list1 <strong class="bold">if x % 2 == 0]</strong></p>
			<p class="source-code">print(list2)</p>
			<p>As you can see, the condition is added to the end of the comprehension expression. Next, we will discuss how to build dictionaries using comprehension. </p>
			<h3>Dictionary comprehension</h3>
			<p>Dictionaries can also be <a id="_idIndexMarker698"/>created by using <strong class="bold">dictionary comprehension</strong>. Dictionary comprehension, which is similar to list comprehension, is an approach of creating a dictionary from another dictionary in such a way that the items from the source dictionary are selected or transformed conditionally. The following code snippet shows an example of creating a dictionary from existing dictionary elements that are less than or equal to 200 and by dividing each selected value by 2. Note that the values are also converted back into integers as part of the comprehension expression:</p>
			<p class="source-code">#<strong class="bold">dictcomp1</strong>.py</p>
			<p class="source-code">dict1 = {'a': 100, 'b': 200, 'c': 300}</p>
			<p class="source-code">dict2 = {<strong class="bold">x:int(y/2)</strong> for (x, y) in dict1.items() if y &lt;=200}</p>
			<p class="source-code">print(dict2)</p>
			<p>This dictionary<a id="_idIndexMarker699"/> comprehension code is equivalent to the following code snippet if done using traditional programming:</p>
			<p class="source-code">Dict2 = {}</p>
			<p class="source-code">for x,y in dict1.items():</p>
			<p class="source-code">    if y &lt;= 200:</p>
			<p class="source-code">        dict2[x] = int(y/2)</p>
			<p>Note that comprehension reduces the code significantly. Next, we will discuss set comprehension. </p>
			<h3>Set comrehension</h3>
			<p>Sets can also be created using <strong class="bold">set comprehension</strong>, just like list comprehension. The code syntax for creating<a id="_idIndexMarker700"/> sets using set comprehension is similar to list comprehension. The exception is that we will be using curly brackets instead of square brackets. In the following code snippet, you can view an example of creating a set from a list using set comprehension:</p>
			<p class="source-code">#<strong class="bold">setcomp1</strong>.py</p>
			<p class="source-code">list1 = [1, 2, 6, 4, 5, 6, 7, 8, 9, 10, 8]</p>
			<p class="source-code">set1 = {x for x in list1 if x % 2 == 0}</p>
			<p class="source-code">print(set1)</p>
			<p>This set comprehension code is equivalent to the following code snippet with traditional programming:</p>
			<p class="source-code">Set1 = set()</p>
			<p class="source-code">for x in list1:</p>
			<p class="source-code">    if x % 2 == 0:</p>
			<p class="source-code">        set1.add(x)</p>
			<p>As expected, the duplicate entries will be discarded in the set.</p>
			<p>This concludes our discussion regarding the types of comprehension that are available in Python for different data <a id="_idIndexMarker701"/>structures. Next, we will discuss the filtering options that are available with data structures. </p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor199"/>Introducing advanced tricks with pandas DataFrame</h1>
			<p><strong class="bold">pandas</strong> is an open source Python<a id="_idIndexMarker702"/> library that provides tools for high-performance data manipulation to make data analysis quick and easy. The typical uses of the pandas library are to reshape, sort, slice, aggregate, and merge data. </p>
			<p>The pandas library is built on <a id="_idIndexMarker703"/>top of the <strong class="bold">NumPy</strong> library, which is another Python library that is used for working with arrays. The NumPy library is significantly faster than traditional Python lists because data is stored at one continuous location in memory, which is not the case with traditional lists. </p>
			<p>The pandas library deals with three key<a id="_idIndexMarker704"/> data structures, as follows:</p>
			<ul>
				<li><strong class="source-inline">Series</strong>: This is a single-dimensional array-like object that contains an array of data and an array of data labels. The array of data labels is called an <strong class="source-inline">index</strong>. The <strong class="source-inline">index</strong> can be specified automatically using integers from <em class="italic">0 to n-1</em> if not explicitly specified by a user. </li>
				<li><strong class="source-inline">DataFrame</strong>: This is a representation of tabular data such as a spreadsheet containing a list of columns. The DataFrame object helps to store and manipulate tabular data in rows and columns. Interestingly, the DataFrame object has an index for both columns and rows.</li>
				<li><strong class="source-inline">Panel</strong>: This is a three-dimensional container of data. </li>
			</ul>
			<p>The DataFrame is the key data structure that is used in data analysis. In the remainder of this section, we will be using the DataFrame object extensively in our code examples. Before we discuss any<a id="_idIndexMarker705"/> advanced tricks regarding these pandas DataFrame objects, we will do a quick review of the fundamental operations available for DataFrame objects. </p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor200"/>Learning DataFrame operations</h2>
			<p>We will start by creating <a id="_idIndexMarker706"/>DataFrame objects. There are several ways to create a DataFrame, such as from a dictionary, a CSV file, an Excel sheet, or from a NumPy array. One of the easiest ways is to use the data in a dictionary as input. The following code snippet shows how you can build a DataFrame object based on weekly weather data stored in a dictionary: </p>
			<p class="source-code"># <strong class="bold">pandas1</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">weekly_data = {'day':['Monday','Tuesday', 'Wednesday', \</p>
			<p class="source-code">'Thursday','Friday', 'Saturday', 'Sunday'],</p>
			<p class="source-code">               'temperature':[40, 33, 42, 31, 41, 40, 30],</p>
			<p class="source-code">               'condition':['Sunny','Cloudy','Sunny','Rain'</p>
			<p class="source-code">               ,'Sunny','Cloudy','Rain']</p>
			<p class="source-code">        }</p>
			<p class="source-code">df = <strong class="bold">pd.DataFrame(weekly_data)</strong></p>
			<p class="source-code">print(df)</p>
			<p>The console output will show the contents of the DataFrame as follows:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B17189_06_02.jpg" alt="Figure 6.2 – The contents of the DataFrame"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – The contents of the DataFrame</p>
			<p>The pandas library is very rich in terms of methods and attributes. However, it is beyond the scope of this section to cover all of them. Instead, we will present a quick summary of the commonly used <a id="_idIndexMarker707"/>attributes and methods of DataFrame objects next to refresh our knowledge before using them in the upcoming code examples:</p>
			<ul>
				<li><strong class="source-inline">index</strong>: This attribute provides a list of indexes (or labels) of the DataFrame object.</li>
				<li><strong class="source-inline">columns</strong>: This attribute provides a list of columns in the DataFrame object.</li>
				<li><strong class="source-inline">size</strong>: This returns the size of the DataFrame object in terms of the number of rows multiplied by the number of columns.</li>
				<li><strong class="source-inline">shape</strong>: This provides us with a tuple representing the dimension of the DataFrame object.</li>
				<li><strong class="source-inline">axes</strong>: This attribute returns a list that represents the axes of the DataFrame object. Put simply, it includes rows and columns.</li>
				<li><strong class="source-inline">describe</strong>: This powerful method generates statistics data such as the count, mean, standard deviation, and minimum and maximum values.</li>
				<li><strong class="source-inline">head</strong>: This method returns <em class="italic">n</em> (default = 5) rows from a DataFrame object similar to the head command on files.</li>
				<li><strong class="source-inline">tail</strong>: This method returns the last <em class="italic">n</em> (default = 5) rows from a DataFrame object.</li>
				<li><strong class="source-inline">drop_duplicates</strong>: This method drops duplicate rows based on all of the columns in a DataFrame.</li>
				<li><strong class="source-inline">dropna</strong>: This method removes missing values (such as rows or columns) from a DataFrame. By passing appropriate arguments to this method, we can either remove rows or columns. Additionally, we can set whether the rows or columns will be removed based on a single occurrence of a missing value or only when all of the values in a row<a id="_idIndexMarker708"/> or column are missing.</li>
				<li><strong class="source-inline">sort_values</strong>: This method can be used to sort the rows based on single or multiple columns. </li>
			</ul>
			<p>In the following sections, we will review some fundamental operations for DataFrame objects. </p>
			<h3>Setting a custom index </h3>
			<p>The column labels (index) are<a id="_idIndexMarker709"/> normally added as per the data provided with a dictionary or according to whatever other input data stream has been used. We can change the index of the DataFrame by using one of the following options: </p>
			<ul>
				<li>Set one of the data columns as an index, such as <strong class="source-inline">day</strong> in the previously mentioned example, by using a simple statement like this:<p class="source-code">df_new = df.set_index('day')</p><p>The DataFrame will start using the <strong class="source-inline">day</strong> column as an index column, and its contents will be as follows:</p><div id="_idContainer044" class="IMG---Figure"><img src="image/B17189_06_03.jpg" alt="Figure 6.3 – The contents of the DataFrame after using the day column as an index&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 6.3 – The contents of the DataFrame after using the <strong class="source-inline">day</strong> column as an index</p>
			<ul>
				<li>Set the index <a id="_idIndexMarker710"/>manually by providing it through a list, such as in the following code snippet:<p class="source-code"># <strong class="bold">pandas2</strong>.py</p><p class="source-code">weekly_data = &lt;same as previous example&gt;</p><p class="source-code">df = pd.DataFrame(weekly_data)</p><p class="source-code"><strong class="bold">df.index</strong> = [<strong class="bold">'MON','TUE','WED','THU','FRI','SAT','SUN'</strong>]</p><p class="source-code">print(df)</p><p>With this code snippet, the DataFrame will start using the index as provided by us through a list object. The contents of the DataFrame will show this change as follows:</p></li>
			</ul>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B17189_06_04.jpg" alt="Figure 6.4 – The contents of the DataFrame after setting custom entries for an index column&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The contents of the DataFrame after setting custom entries for an index column</p>
			<p>Next, we will discuss how to navigate inside a DataFrame using a certain index and column. </p>
			<h3>Navigating inside a DataFrame</h3>
			<p>There are a few dozen ways in which to<a id="_idIndexMarker711"/> get a row of data or a particular location from a DataFrame object. The typical methods that are used to navigate inside a DataFrame are the <strong class="source-inline">loc</strong> and <strong class="source-inline">iloc</strong> methods. We will explore a few options of how to navigate through a DataFrame object using the same sample data that we used in the previous example: </p>
			<p class="source-code"># <strong class="bold">pandas3</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">weekly_data = <strong class="bold">&lt;same as in pandas1.py example&gt;</strong></p>
			<p class="source-code">df = pd.DataFrame(weekly_data)</p>
			<p class="source-code">df.index = ['MON', 'TUE','WED','THU','FRI','SAT','SUN']</p>
			<p>Next, we will discuss a few techniques, with code samples, regarding how to select a row or location in this DataFrame object: </p>
			<ul>
				<li>We can select one or more rows by using index labels with the <strong class="source-inline">loc</strong> method. The index label is provided as a single item or a list. In the following code snippet, we have illustrated two examples of how to select one or more rows:<p class="source-code">print(<strong class="bold">df.loc['TUE']</strong>)</p><p class="source-code">print(<strong class="bold">df.loc[['TUE','WED']]</strong>)</p></li>
				<li>We can select a value from a location in a DataFrame object using the row index label and the column label, as follows:<p class="source-code">print(<strong class="bold">df.loc['FRI','temp']</strong>)</p></li>
				<li>We can also select a row by using an index value without providing any labels:<p class="source-code">#Provide a row with index 2</p><p class="source-code">print(<strong class="bold">df.iloc[2]</strong>)</p></li>
				<li>We can select a value from a location using the row index value and the column index value by treating the DataFrame object like a two-dimensional array. In the next code snippet, we will get a value from a location in which the row index = 2 and the column index = 2:<p class="source-code">print(<strong class="bold">df.iloc[2,2]</strong>)</p></li>
			</ul>
			<p>Next, we will discuss how to <a id="_idIndexMarker712"/>add a row or a column to a DataFrame object.</p>
			<h3>Adding a row or column to a DataFrame</h3>
			<p>The easiest<a id="_idIndexMarker713"/> way to add a row to a DataFrame object is by assigning a list of values to an index location or an index label. For example, we can add a new row with the <strong class="source-inline">TST</strong> label for the previous example (that is, <strong class="source-inline">pandas3.py</strong>) by using the following statement:</p>
			<p class="source-code"> df.loc['TST'] = ['Test day 1', 50, 'NA']</p>
			<p>It is important to note that if the row label already exists in the DataFrame object, the same line of code can update the row with new values. </p>
			<p>If we are not using the index label but the default index instead, we can use the index number to update an existing row or add a new row by using the following line of code:</p>
			<p class="source-code">df.loc[8] = ['Test day 2', 40, 'NA']</p>
			<p>A complete code example is shown for reference:</p>
			<p class="source-code"># <strong class="bold">pandas4</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">weekly_data = <strong class="bold">&lt;same as in pandas1.py example&gt;</strong></p>
			<p class="source-code">df = pd.DataFrame(weekly_data)</p>
			<p class="source-code">df.index = ['MON', 'TUE','WED','THU','FRI','SAT','SUN']</p>
			<p class="source-code"><strong class="bold">df.loc['TST1']</strong> = ['Test day 1', 50, 'NA']</p>
			<p class="source-code"><strong class="bold">df.loc[7]</strong> = ['Test day 2', 40, 'NA']</p>
			<p class="source-code">print(df)</p>
			<p>To add a new column to a DataFrame object, multiple options are available in the pandas library. We will only illustrate three options, as follows:</p>
			<ul>
				<li><strong class="bold">By adding a list of values next to the column label</strong>: This approach will add a column after the existing<a id="_idIndexMarker714"/> columns. If we use an existing column label, this approach can also be used to update or replace an existing column.</li>
				<li><strong class="bold">By using the insert method</strong>: This method will take a label and a list of values as arguments. This is particularly useful when you want to insert a column at any location. Note that this method does not allow you to insert a column if there is already an existing column inside the DataFrame object with the same label. This means this method <a id="_idIndexMarker715"/>cannot be used to update an existing column.</li>
				<li><strong class="bold">By using the assign method</strong>: This method is useful when you want to add multiple columns in one go. If we use an existing column label, this method can be used to update or replace an existing column.</li>
			</ul>
			<p>In the following code example, we will use all three approaches to insert a new column to a DataFrame object:</p>
			<p class="source-code"><strong class="bold"># pandas5.py</strong></p>
			<p class="source-code"><strong class="bold">import pandas as pd</strong></p>
			<p class="source-code">weekly_data = &lt;same as in pandas1.py example&gt;</p>
			<p class="source-code">df = pd.DataFrame(weekly_data)</p>
			<p class="source-code">#Adding a new column and then updating it</p>
			<p class="source-code">df['Humidity1'] = [60, 70, 65,62,56,25,'']</p>
			<p class="source-code">df['Humidity1'] = [60, 70, 65,62,56,251,'']</p>
			<p class="source-code">#Inserting a column at column index of 2 using the insert method</p>
			<p class="source-code"><strong class="bold">df.insert</strong>(2, "Humidity2",[60, 70, 65,62,56,25,''])</p>
			<p class="source-code">#Adding two columns using the assign method</p>
			<p class="source-code">df1 = <strong class="bold">df.assign</strong>(Humidity3 = [60, 70, 65,62,56,25,''],  Humidity4 = [60, 70, 65,62,56,25,''])</p>
			<p class="source-code">print(df1)</p>
			<p>Next, we will evaluate <a id="_idIndexMarker716"/>how to delete rows and columns from a DataFrame object.</p>
			<h3>Deleting an index, a row, or a column from a DataFrame</h3>
			<p>Removing an index is<a id="_idIndexMarker717"/> relatively straightforward, and you can do so by using the <strong class="source-inline">reset_index</strong> method. However, the <strong class="source-inline">reset_index</strong> method adds default indexes and keeps <a id="_idIndexMarker718"/>the custom index column as a data column. To <a id="_idIndexMarker719"/>remove the custom index column completely, we have to use the <strong class="source-inline">drop</strong> argument with the <strong class="source-inline">reset_index</strong> method. The following code snippet uses the <strong class="source-inline">reset_index</strong> method:</p>
			<p class="source-code"># <strong class="bold">pandas6</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">weekly_data = <strong class="bold">&lt;same as in pandas1.py example&gt;</strong></p>
			<p class="source-code"><strong class="bold">df = pd.DataFrame(weekly_data)</strong></p>
			<p class="source-code">df.index = ['MON', 'TUE','WED','THU','FRI','SAT','SAT']</p>
			<p class="source-code">print(df)</p>
			<p class="source-code">print(<strong class="bold">df.reset_index(drop=True)</strong>)</p>
			<p>To delete a duplicate row from a DataFrame object, we can use the <strong class="source-inline">drop_duplicate</strong> method. To delete a particular row or column, we can use the <strong class="source-inline">drop</strong> method. In the following code example, we will remove any rows with the <strong class="source-inline">SAT</strong> and <strong class="source-inline">SUN</strong> labels and any columns with the <strong class="source-inline">condition</strong> label:</p>
			<p class="source-code">#<strong class="bold">pandas7</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">weekly_data = <strong class="bold">&lt;same as in pandas1.py example&gt;</strong></p>
			<p class="source-code">df = pd.DataFrame(weekly_data)</p>
			<p class="source-code">df.index = ['MON', 'TUE','WED','THU','FRI','SAT','SUN']</p>
			<p class="source-code">print(df)</p>
			<p class="source-code">df1= <strong class="bold">df.drop(index=['SUN','SAT'])</strong></p>
			<p class="source-code">df2= <strong class="bold">df1.drop(columns=['condition'])</strong></p>
			<p class="source-code">print(df2)</p>
			<p>Next, we <a id="_idIndexMarker720"/>will examine how<a id="_idIndexMarker721"/> to rename an index or a column.</p>
			<h3>Renaming indexes and columns in a DataFrame</h3>
			<p>To rename an index or <a id="_idIndexMarker722"/>a column label, we will use the <strong class="source-inline">rename</strong> method. A code example of how to rename an index and a column is as follows:</p>
			<p class="source-code">#<strong class="bold">pandas8</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">weekly_data = <strong class="bold">&lt;same as in pandas1.py example&gt;</strong></p>
			<p class="source-code">df = pd.DataFrame(weekly_data)</p>
			<p class="source-code">df.index = ['MON', 'TUE','WED','THU','FRI','SAT','SUN']</p>
			<p class="source-code">df1=df.<strong class="bold">rename(index={'SUN': 'SU', 'SAT': 'SA'})</strong></p>
			<p class="source-code">df2=df1.<strong class="bold">rename(columns={'condition':'cond'})</strong></p>
			<p class="source-code">print(df2)</p>
			<p>It is important to note <a id="_idIndexMarker723"/>that the current label and the new label for the index and column are provided as a dictionary. Next, we will discuss some advanced tricks for using DataFrame objects.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor201"/>Learning advanced tricks for a DataFrame object</h2>
			<p>In the previous section, we <a id="_idIndexMarker724"/>evaluated the fundamental operations that can be performed on a DataFrame object. In this section, we will investigate the next level of operations on a DataFrame object for data evaluation and transformation. These operations are discussed in the following subsections. </p>
			<h3>Replacing data </h3>
			<p>One common requirement is to <a id="_idIndexMarker725"/>replace numeric data or string data with another set of values. The pandas library is full of options in which to carry out such data replacements. The most popular method for these operations is to use the <strong class="source-inline">at</strong> method. The <strong class="source-inline">at</strong> method provides an easy way to access or update data in any cell in a DataFrame. For bulk replacement operations, you can also use a <strong class="source-inline">replace</strong> method, and we can use this method in many ways. For example, we can use this method to replace a number with another number or a string with another string, or we can replace anything that matches a regular expression. Additionally, we can use this method to replace any entries provided through a list or a dictionary. In the following code example (that is, <strong class="source-inline">pandastrick1.py</strong>), we will cover most of these replacement options. For this code example, we will use the same DataFrame object that we used in previous code examples. Here is the sample code:</p>
			<p class="source-code"># <strong class="bold">pandastrick1</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">weekly_data = <strong class="bold">&lt;same as in pandas1.py example&gt;</strong></p>
			<p class="source-code">df = pd.DataFrame(weekly_data)</p>
			<p>Next, we will explore several replacement operations on this DataFrame object, one by one:</p>
			<ul>
				<li>Replace any occurrences of the numeric value of <strong class="source-inline">40</strong> with <strong class="source-inline">39</strong> across the DataFrame object using the following statement:<p class="source-code">df.replace(40,39, inplace=True)</p></li>
				<li>Replace any occurrences of a <strong class="source-inline">Sunny</strong> string with <strong class="source-inline">Sun</strong> across the DataFrame object using the following statement:<p class="source-code">df.replace("Sunny","Sun",inplace=True)</p></li>
				<li>Replace any occurrences of a string based on a regular expression (the aim is to replace <strong class="source-inline">Cloudy</strong> with <strong class="source-inline">Cloud</strong>) using the following statement:<p class="source-code">df.replace(to_replace="^Cl.*",value="Cloud", inplace=True,regex=True)</p><p class="source-code">#or we can apply on a specific column as well. </p><p class="source-code">df["condition"].replace(to_replace="^Cl.*",value="Cloud", inplace=True,regex=True)</p><p>Note that the use of the <strong class="source-inline">to_replace</strong> and <strong class="source-inline">value</strong> argument labels is optional. </p></li>
				<li>Replace any <a id="_idIndexMarker726"/>occurrences of multiple strings represented by a list with another list of strings using the following statement:<p class="source-code">df.replace(["Monday","Tuesday"],["Mon","Tue"], inplace=True)</p><p>In this code, we replaced <strong class="source-inline">Monday</strong> and <strong class="source-inline">Tuesday</strong> with <strong class="source-inline">Mon</strong> and <strong class="source-inline">Tue</strong>. </p></li>
				<li>Replace any occurrences of multiple strings in a DataFrame object using the key-value pairs in a dictionary. You can do this by using the following statement: <p class="source-code">df.replace({"Wednesday":"Wed","Thursday":"Thu"}, inplace=True)</p><p>In this case, the keys of the dictionary (that is, <strong class="source-inline">Wednesday</strong> and <strong class="source-inline">Thursday</strong>) will be replaced by their corresponding values (that is, <strong class="source-inline">Wed</strong> and <strong class="source-inline">Thu</strong>).  </p></li>
				<li>Replace any occurrences of <a id="_idIndexMarker727"/>a string for a certain column using multiple dictionaries. You can do this by using the column name as a key in the dictionary and a sample statement such as the following: <p class="source-code">df.replace({"day":"Friday"}, {"day":"Fri"}, inplace=True)</p><p>In this scenario, the first dictionary is used to indicate the column name and the value to be replaced. The second dictionary is used to indicate the same column name but with a value that will replace the original value. In our case, we will replace all instances of <strong class="source-inline">Friday</strong> in the <strong class="source-inline">day</strong> column with the value of <strong class="source-inline">Fri</strong>.</p></li>
				<li>Replace any occurrences of multiple strings using a nested dictionary. You can do this by using a code sample such as the following:<p class="source-code">df.replace({"day":{"Saturday":"Sat", "Sunday":"Sun"},</p><p class="source-code">            "condition":{"Rainy":"Rain"}}, inplace=True)</p><p>In this scenario, the outer dictionary (with the <strong class="source-inline">day</strong> and <strong class="source-inline">condition</strong> keys in our code sample) is used to identify the columns for this operation and the inner dictionary is used to hold the data to be replaced along with the replacing value. By using this approach, we replaced <strong class="source-inline">Saturday</strong> and <strong class="source-inline">Sunday</strong> with <strong class="source-inline">Sat</strong> and <strong class="source-inline">Sun</strong> inside the <strong class="source-inline">day</strong> column and the <strong class="source-inline">Rainy</strong> string with <strong class="source-inline">Rain</strong> inside the <strong class="source-inline">condition</strong> column.</p></li>
			</ul>
			<p>The complete code with all these sample operations is available within the source code of this chapter as <strong class="source-inline">pandastrick1.py</strong>. Note that we can either trigger the replacement operation <a id="_idIndexMarker728"/>across the DataFrame object or we can limit it to a certain column or a row. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <strong class="source-inline">inplace=True</strong> argument is used with all <strong class="source-inline">replace</strong> method calls. This argument is used to set the output of the <strong class="source-inline">replace</strong> method within the same DataFrame object. The default option is to return a new DataFrame object without changing the original object. This argument is available with many DataFrame methods for convenience. </p>
			<h3>Applying a function to the column or row of a DataFrame object </h3>
			<p>Sometimes, we want to <a id="_idIndexMarker729"/>clean up the data, adjust the data, or transform the data before starting data analysis. There is an easy way in which to apply some type of function on a DataFrame using the <strong class="source-inline">apply</strong>, <strong class="source-inline">applymap</strong>, or <strong class="source-inline">map</strong> methods. The <strong class="source-inline">apply</strong> method is applicable to columns or rows, while the <strong class="source-inline">applymap</strong> method works element by element for the whole DataFrame. In comparison, the <strong class="source-inline">map</strong> method works element by element for a single series. Now, we will discuss a couple of code examples to illustrate the use of the <strong class="source-inline">apply</strong> and <strong class="source-inline">map</strong> methods.</p>
			<p>It is common to have data imported into a DataFrame object that might need some cleaning up. For example, it could have trailing or leading whitespaces, new line characters, or any unwanted characters. These can be removed from the data easily by using the <strong class="source-inline">map</strong> method and the lambda function on a column series. The lambda function is used on each element of the column. In our code example, first, we will remove the trailing whitespace, dot, and comma. Then, we will remove the leading whitespace, underscore, and dash for the <strong class="source-inline">condition</strong> column. </p>
			<p>After cleaning up the data inside the <strong class="source-inline">condition</strong> column, the next step is to create a new <strong class="source-inline">temp_F</strong> column from the values of the <strong class="source-inline">temp</strong> column and convert them from Celsius units into Fahrenheit units. Note that we will use another lambda function for this conversion and use the <strong class="source-inline">apply</strong> method. When we get the result from the <strong class="source-inline">apply</strong> method, we will store it inside a new column label, <strong class="source-inline">temp_F</strong>, to create a new column. Here is the complete code example:</p>
			<p class="source-code"># <strong class="bold">pandastrick2</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">weekly_data = {'day':['Monday','Tuesday', 'Wednesday',                    'Thursday','Friday', 'Saturday', 'Sunday'],</p>
			<p class="source-code">                'temp':[40, 33, 42, 31, 41, 40, 30],</p>
			<p class="source-code">                'condition':['Sunny,','_Cloudy ',                'Sunny','Rainy','--Sunny.','Cloudy.','Rainy']</p>
			<p class="source-code">        }</p>
			<p class="source-code">df = pd.DataFrame(weekly_data)</p>
			<p class="source-code">print(df)</p>
			<p class="source-code">df["condition"] = df["condition"].<strong class="bold">map</strong>(</p>
			<p class="source-code">                <strong class="bold">lambda x: x.lstrip('_- ').rstrip(',. ')</strong>)</p>
			<p class="source-code">df["temp_F"] = df["temp"].<strong class="bold">apply</strong>(<strong class="bold">lambda x: 9/5*x+32</strong> )</p>
			<p class="source-code">print(df)</p>
			<p>Note that for the<a id="_idIndexMarker730"/> preceding code example, we provided the same input data as in previous examples except that we added trailing and leading characters to the <strong class="source-inline">condition</strong> column data.</p>
			<h3>Querying rows in a DataFrame object</h3>
			<p>To query rows based on the <a id="_idIndexMarker731"/>values in a certain column, one common approach is to apply a filter using <em class="italic">AND</em> or <em class="italic">OR</em> logical operations. However, this quickly becomes a messy approach for simple requirements such as searching a row with a value in between a range of values. The pandas library offers a cleaner tool: the <strong class="source-inline">between</strong> method, which is somewhat similar to the <em class="italic">between</em> keyword in SQL. </p>
			<p>The following code example uses the same <strong class="source-inline">weekly_data</strong> DataFrame object that we used in the previous example. First, we will show the use of a traditional filter, and then we will show the use of the <strong class="source-inline">between</strong> method to query the rows that have temperature values between 30 and 40 inclusively: </p>
			<p class="source-code"># <strong class="bold">pandastrick3</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">weekly_data = <strong class="bold">&lt;same as in pandas1.py example&gt;</strong></p>
			<p class="source-code">df = pd.DataFrame(weekly_data)</p>
			<p class="source-code">print(df[<strong class="bold">(df.temp &gt;= 30) &amp; (df.temp&lt;=40)</strong>])</p>
			<p class="source-code">print(df[<strong class="bold">df.temp.between(30,40)</strong>])</p>
			<p>We get the same console output for both approaches we used. However, using the <strong class="source-inline">between</strong> method is far more convenient than writing conditional filters. </p>
			<p>Querying rows based on text data is also very well supported in the pandas library. This can be achieved by using the <strong class="source-inline">str</strong> accessor on the string-type columns of the DataFrame object. For example, if we want to search rows in our <strong class="source-inline">weekly_data</strong> DataFrame object based on the condition of a day, such as <strong class="source-inline">Rainy</strong> or <strong class="source-inline">Sunny</strong>, we can either write a traditional filter or we can use the <strong class="source-inline">str</strong> accessor on the column with the <strong class="source-inline">contains</strong> method. The following code <a id="_idIndexMarker732"/>example illustrates the use of both options to get the rows with <strong class="source-inline">Rainy</strong> or <strong class="source-inline">Sunny</strong> as data values in the <strong class="source-inline">condition</strong> column:</p>
			<p class="source-code"># <strong class="bold">pandastrick4</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">weekly_data = <strong class="bold">&lt;same as in pandas1.py example&gt;</strong></p>
			<p class="source-code">df = pd.DataFrame(weekly_data)</p>
			<p class="source-code">print(df<strong class="bold">[(df.condition=='Rainy') | (df.condition=='Sunny')]</strong>)</p>
			<p class="source-code">print(df[<strong class="bold">df['condition'].str.contains('Rainy|Sunny')</strong>])</p>
			<p>If you run the preceding code, you will find that the console output is the same for both of the approaches we used for <a id="_idIndexMarker733"/>searching the data.</p>
			<h3>Getting statistics on the DataFrame object data</h3>
			<p>To get statistical data such as<a id="_idIndexMarker734"/> central tendency, standard deviation, and shape, we can use the <strong class="source-inline">describe</strong> method. The output of the <strong class="source-inline">describe</strong> method for numeric columns includes the following:</p>
			<ul>
				<li><strong class="source-inline">count </strong></li>
				<li><strong class="source-inline">mean </strong></li>
				<li><strong class="source-inline">standard deviation</strong></li>
				<li><strong class="source-inline">min</strong></li>
				<li><strong class="source-inline">max</strong></li>
				<li><strong class="source-inline">25</strong><span class="superscript">th</span><strong class="source-inline"> percentiles, 50</strong><span class="superscript">th</span><strong class="source-inline"> percentile, 75</strong><span class="superscript">th</span><strong class="source-inline"> percentile</strong> </li>
			</ul>
			<p>The default breakdown of percentiles can be changed by using the <strong class="source-inline">percentiles</strong> argument with the desired breakdown. </p>
			<p>If the <strong class="source-inline">describe</strong> method is used for non-numeric data, such as strings, we will get <em class="italic">count</em>, <em class="italic">unique</em>, <em class="italic">top</em>, and <em class="italic">freq</em>. The <em class="italic">top</em> value is the most common value, whereas <em class="italic">freq</em> is the most common value frequency. By default, only numeric columns are evaluated by the <strong class="source-inline">describe</strong> method unless we provide the <strong class="source-inline">include</strong> argument with an appropriate value. </p>
			<p>In the following code example, we will evaluate the following for the same <strong class="source-inline">weekly_date</strong> DataFrame object:</p>
			<ul>
				<li>The use of the <strong class="source-inline">describe</strong> method with or without the <strong class="source-inline">include</strong> argument</li>
				<li>The use of the <strong class="source-inline">percentiles</strong> argument with the <strong class="source-inline">describe</strong> method</li>
				<li>The use of the <strong class="source-inline">groupby</strong> method to group data on a column basis and then using the <strong class="source-inline">describe</strong> method on top of it</li>
			</ul>
			<p>The complete code example is <a id="_idIndexMarker735"/>as follows:</p>
			<p class="source-code"># <strong class="bold">pandastrick5</strong>.py</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">pd.set_option('display.max_columns', None)</p>
			<p class="source-code">weekly_data = <strong class="bold">&lt;same as in pandas1.py example&gt;</strong></p>
			<p class="source-code">df = pd.DataFrame(weekly_data)</p>
			<p class="source-code">print(df.<strong class="bold">describe</strong>())</p>
			<p class="source-code">print(df.<strong class="bold">describe(include="all")</strong>)</p>
			<p class="source-code">print(df.<strong class="bold">describe(percentiles=np.arange(0, 1, 0.1))</strong>)</p>
			<p class="source-code">print(df.<strong class="bold">groupby</strong>('condition').<strong class="bold">describe(percentiles=np.arange</strong>(0,   1, 0.1)))</p>
			<p>Note that we changed the <strong class="source-inline">max_columns</strong> options for the pandas library at the beginning in order to display all of the columns that we expected in the console output. Without this, some of the columns will be truncated for the console output of the <strong class="source-inline">groupby</strong> method. </p>
			<p>This concludes our discussion of the advanced tricks of working with a DataFrame object. This set of tricks and tips will empower anyone to start using the pandas library for data analysis. For additional advanced concepts, we recommend that you refer to the official documentation of the pandas library. </p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor202"/>Summary</h1>
			<p>In this chapter, we introduced some advanced tricks that are important when you want to write efficient and concise programs in Python. We started with advanced functions such as the mapper, reducer, and filter functions. We also discussed several advanced concepts of functions, such as inner functions, lambda functions, and decorators. This was followed by a discussion of how to use data structures, including nested dictionaries and comprehensions. Finally, we reviewed the fundamental operations of a DataFrame object, and then we evaluated a few use cases using some advanced operations of the DataFrame object. </p>
			<p>This chapter mainly focused on hands-on knowledge and experience of how to use advanced concepts in Python. This is important for anyone who wants to develop Python applications, especially for data analysis. The code examples provided in this chapter are very helpful for you to begin learning the advanced tricks that are available for functions, data structures, and the pandas library. </p>
			<p>In the next chapter, we will explore multiprocessing and multithreading in Python.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor203"/>Questions</h1>
			<ol>
				<li>Which of the <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and <strong class="source-inline">reduce</strong> functions are built-in Python functions?</li>
				<li>What are standard decorators?</li>
				<li>Would you prefer a generator comprehension or a list comprehension for a large dataset? </li>
				<li>What is a DataFrame in the context of the pandas library?</li>
				<li>What is the purpose of the <strong class="source-inline">inplace</strong> argument in pandas' library methods?</li>
			</ol>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor204"/>Further reading</h1>
			<ul>
				<li><em class="italic">Mastering Python Design Patterns</em>, by Sakis Kasampalis</li>
				<li><em class="italic">Python for Data Analysis</em>, by Wes McKinney</li>
				<li><em class="italic">Hands-On Data Analysis with Pandas</em>, <em class="italic">Second Edition</em>, by Stefanie Molin</li>
				<li><em class="italic">The official Pandas documentation</em>, which is available at <a href="https://pandas.pydata.org/docs/">https://pandas.pydata.org/docs/</a></li>
			</ul>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor205"/>Answers</h1>
			<ol>
				<li value="1">The <strong class="source-inline">map</strong> and the <strong class="source-inline">filter</strong> functions are built-in.</li>
				<li>Standard decorators are the ones without any arguments.</li>
				<li>The generator comprehension is preferred in this case. It is memory efficient as the values are generated one by one. </li>
				<li>The DataFrame is a representation of tabular data, such as a spreadsheet, and is a commonly used object for data analysis using the pandas library. </li>
				<li>When the <strong class="source-inline">inplace</strong> argument in pandas' library methods is set to <strong class="source-inline">True</strong>, the result of the operation is saved to the same DataFrame object on which the operation is applied.</li>
			</ol>
		</div>
	</body></html>