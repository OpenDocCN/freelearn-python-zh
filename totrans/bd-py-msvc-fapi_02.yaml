- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring the Core Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we found out how easy it is to install and start developing
    REST APIs using the **FastAPI** framework. Handling requests, cookies, and form
    data was fast, easy, and straightforward with FastAPI, as was building the different
    HTTP path operations.
  prefs: []
  type: TYPE_NORMAL
- en: To learn about the framework’s features further, this chapter will guide us
    on how to upgrade our REST APIs by adding some essential FastAPI features to the
    implementation. These include some handlers that can help minimize unchecked exceptions,
    JSON encoders that can directly manage endpoint responses, background jobs that
    can create audit trails and logs, and multiple threads to run some API methods
    asynchronously with the **uvicorn**’s main thread. Moreover, issues such as managing
    source files, modules, and packages for huge enterprise projects will also be
    addressed in this chapter. This chapter will use and dissect an *intelligent tourist
    system* prototype to assist with elaborating upon and exemplifying FastAPI’s core
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these aforementioned features, this chapter will discuss the following
    major concepts that can help us extend our learning about this framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring and organizing huge projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing API-related exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting objects to JSON-compatible types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing API responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating background processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using asynchronous path operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying middleware to filter path operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will implement a prototype of an intelligent tourist system designed
    to provide booking information and reservation about tourist spots. It can provide
    user details, tourist spot details, and location grids. It also allows users or
    tourists to comment on tours and rate them. The prototype has an administrator
    account for adding and removing all the tour details, managing users, and providing
    some listings. The application will not use any database management system yet,
    so all the data is temporarily stored in Python collections. The code is all uploaded
    at [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch02](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch02).
  prefs: []
  type: TYPE_NORMAL
- en: Structuring and organizing huge projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In FastAPI, big projects are organized and structured by adding *packages* and
    *modules* without destroying the setup, configuration, and purpose. The project
    should always be flexible and scalable in case of additional features and requirements.
    One component must correspond to one package, with several modules equivalent
    to a *blueprint* in a Flask framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this prototypical intelligent tourist system, the application has several
    modules such as the login, administration, visit, destination, and feedback-related
    functionalities. The two most crucial are the *visit* module, which manages all
    the travel bookings of the users, and the *feedback* module, which enables clients
    to post their feedback regarding their experiences at every destination. These
    modules should be separated from the rest since they provide the core transactions.
    *Figure 2.1* shows how to group implementations and separate a module from the
    rest using **packages**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The FastAPI project structure](img/Figure_2.1_B17975.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The FastAPI project structure
  prefs: []
  type: TYPE_NORMAL
- en: Each package in *Figure 2.1* contains all the modules where the API services
    and some dependencies are implemented. All the aforementioned modules now have
    their own respective packages that make it easy to test, debug, and expand the
    application. Testing FastAPI components will be discussed in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI does not require adding the `__init__.py` file into each Python package
    when using *VS Code Editor* and *Python 3.8* during development, unlike in Flask.
    The `__pycache__` folder generated inside a package during compilation contains
    binaries of the module scripts accessed and utilized by other modules. The main
    folder will also become a package since it will have its own `__pycache__` folder
    together with the others. But we must exclude `__pycache__` when deploying the
    application to the repository, since it may take up a lot of space.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, what remains in the main folder are the core components such
    as the *background tasks*, *custom exception handlers*, *middleware,* and the
    `main.py` file. Now, let us learn about how FastAPI can bundle all these packages
    as one huge application when deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the API services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For these module packages to function, the `main.py` file must call and register
    all their API implementations through the FastAPI instance. The scripts inside
    each package are already REST API implementations of the microservices, except
    that they are built by `APIRouter` instead of the `FastAPI` object. `APIRouter`
    also has the same path operations, query and request parameter setup, handling
    of form data, generation of responses, and parameter injection of model objects.
    What is lacking in `APIRouter` is the support for an exception handler, middleware
    declaration, and customization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `list_all_tourists()` API method operation here is part of the `manager.py`
    module in the `admin` package, implemented using `APIRouter` due to project structuring.
    The method returns a list of tourist records that are allowed to access the application,
    which can only be provided by the `user.py` module in the `login` package.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the module components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Module scripts can share their *containers*, `BaseModel` *classes*, and other
    *resource objects* to other modules using Python’s `from… import` statement. Python’s
    `from… import` statement is better since it allows us to import specific components
    from a module, instead of including unnecessary ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `update_tour_destination()` operation here will not work without importing
    the `Tour`, `TourBasicInfo`, and `TourLocation` model classes from `destination.py`
    in the `places` package. It shows the dependency between modules that happens
    when structuring is imposed on big enterprise web projects.
  prefs: []
  type: TYPE_NORMAL
- en: Module scripts can also import components from the main project folder when
    needed by the implementation. One such example is accessing the *middleware*,
    *exception* *handlers*, and *tasks* from the `main.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Avoid cycles when dealing with the `from… import` statement. A `a.py`, accesses
    components from `b.py` that import resource objects from `a.py`. FastAPI does
    not accept this scenario and will issue an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the new main.py file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Technically, the project’s packages and its module scripts will not be recognized
    by the framework unless their respective `router` object is added or injected
    into the application’s core through the `main.py` file. `main.py`, just as the
    other project-level scripts do, uses `FastAPI` and not `APIRouter` to create and
    register components, as well as the package’s modules. The FastAPI class has an
    `include_router()` method that adds all these routers and injects them into the
    framework to make them part of the project structure. Beyond registering the routers,
    this method can also add other attributes and components to the router such as
    *URL prefixes*, *tags*, *dependencies such as exception handlers*, and *status
    codes*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is the `main.py` implementation of the intelligent tourist system
    prototype tasked to import all the registers of the module’s scripts from the
    different packages, before adding them as components to the framework. Run the
    application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will allow you to access all the APIs of these modules at `http://localhost:8000/docs`.
  prefs: []
  type: TYPE_NORMAL
- en: What happens to the application when API services encounter runtime problems
    during execution? Is there a way to manage these problems besides applying Python’s
    `try-except` block? Let us explore implementing API services with exception-handling
    mechanisms further.
  prefs: []
  type: TYPE_NORMAL
- en: Managing API-related exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The FastAPI framework has a built-in exception handler derived from its Starlette
    toolkit that always returns default JSON responses whenever `HTTPException` is
    encountered during the execution of the REST API operation. For instance, accessing
    the API at `http://localhost:8000/ch02/user/login` without providing the `username`
    and `password` will give us the default JSON output depicted in *Figure 2.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The default exception result](img/Figure_2.2_B17975.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The default exception result
  prefs: []
  type: TYPE_NORMAL
- en: In some rare cases, the framework sometimes chooses to return the HTTP response
    status instead of the default JSON content. But developers can still opt to override
    these default handlers to choose which responses to return whenever a specific
    exception cause happens.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now explore how to formulate a standardized and appropriate way of managing
    runtime errors in our API implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A single status code response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way of managing the exception-handling mechanism of your application is
    to apply a `try-except` block to manage the return responses of your API when
    it encounters an exception or none. After applying `try-block`, the operation
    should trigger a single `FastAPI` and `APIRouter` has a `status_code` parameter
    that we can use to indicate the type of status code we want to raise.
  prefs: []
  type: TYPE_NORMAL
- en: In FastAPI, status codes are integer constants that are found in the `status`
    module. It also allows integer literals to indicate the needed status code if
    they are a valid status code number.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: A status code is a 3-digit number that indicates a reason for, information on,
    or status of the HTTP response of a REST API operation. The status code range
    200 to 299 denotes a successful response, 300 to 399 pertains to redirection,
    400-499 pertains to client-related problems, and 500 to 599 is related to server
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is rarely used because there are times that an operation needs
    to be clear in recognizing every exception that it encounters, which can only
    be done by returning `HTTPException` instead of a custom error message wrapped
    in a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `list_all_tours()` method shown here is the kind of REST API service that
    should emit Status Code 200 – it gives an error-free result just by rendering
    the Python collection with data. Observe that the literal integer value, `200`,
    or *SC 200*, assigned to the `status_code` parameter of the `GET` path operation
    always raises an *OK* status. On the other hand, the `update_tour_destination()`
    method shows another approach in emitting status codes by using a `try-except`
    block, wherein both blocks return a custom JSON response. Whichever scenario happens,
    it will always trigger *SC 202*, which may not apply to some REST implementations.
    After the `status` module is imported, its `HTTP_202_ACCEPTED` constant is used
    to set the value of the `status_code` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need each block in `try-except` to return their respective status code,
    we need to avoid using the `status_code` parameter of the path operations and
    use `JSONResponse` instead. `JSONResponse` is one of the FastAPI classes used
    to render a JSON response to the client. It is instantiated, constructor-injected
    with values for its `content` and `status_code` parameters, and returned by the
    path operations. By default, the framework uses this API to help path operations
    render responses as JSON types. Its `content` parameter should be a JSON-type
    object, while the `status_code` parameter can be an integer constant and a valid
    status code number, or it can be a constant from the module status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `add_tour_destination()` operation here has a `try-except` block where its
    `try` block returns the tour details and *SC 201*, while its `catch` block returns
    an error message inside a JSON-type object with a server error of *SC 500*.
  prefs: []
  type: TYPE_NORMAL
- en: Raising HTTPException
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way of managing possible errors is by letting the REST API throw the
    `HTTPException` object. `HTTPException` is a FastAPI class that has required constructor
    parameters: `detail`, which needs an error message in the `str` type, and `status_code`,
    which asks for a valid integer value. The `detail` part is converted to JSON-type
    and returned to the user as a response after the `HTTPException` instance is thrown
    by the operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To throw `HTTPException`, a validation process using any variations of `if`
    statements is more appropriate than using the `try-except` block because the cause
    of the error needs to be identified before throwing the `HTTPException` object
    using the `raise` statement. Once `raise` is executed, the whole operation will
    halt and send the HTTP error message in JSON-type to the client with the specified
    status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `create_booking()` operation here simulates a booking process for a *tourist*
    account, but before the procedure starts, it first checks whether the *tourist*
    is still a valid user; otherwise, it will raise `HTTPException`, halting all the
    operations in order to return an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Custom exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to create a user-defined `HTTPException` object to handle
    business-specific problems. This custom exception requires a custom handler needed
    to manage its response to the client whenever an operation raises it. These custom
    components should be available to all API methods across the project structure;
    thus, they must be implemented at the project-folder level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, there are two custom exceptions created in `handler_exceptions.py`,
    the `PostFeedbackException` and `PostRatingFeedback` exceptions, which handle
    problems related to posting feedback and ratings on a particular tour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A valid FastAPI exception is a subclass of an `HTTPException` object inheriting
    the essential attributes, namely the `status_code` and `detail` attributes. We
    need to supply values to these attributes before the path operation raises the
    exception. After creating these custom exceptions, a specific handler is implemented
    and mapped to an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FastAPI `@app` decorator in `main.py` has an `exception_handler()` method,
    used to define a custom handler and map it to the appropriate custom exception.
    A handler is simply a Python function with two local parameters, `Request` and
    the *custom exception* that it manages. The purpose of the `Request` object is
    to retrieve cookies, payloads, headers, query parameters, and path parameters
    from the path operation if the handler expects any of this request data. Now,
    once the custom exception is raised, the handler is set to generate a JSON-type
    response to the client containing the `detail` and the `status_code` attributes
    provided by the path operation that raised the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When an operation in `post.py` raises `PostFeedbackException`, the `feedback_exception_handler()`
    given here will trigger its execution to generate a response that can provide
    details about what has caused the feedback problem. The same thing will happen
    to `PostRatingException` and its `rating_exception_handler()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`post_tourist_feedback()` and `update_tour_rating()` here are the API operations
    that will raise the `PostFeedbackException` and `PostRatingException` custom exceptions,
    respectively, triggering the execution of their handlers. The `detail` and `status_code`
    values injected into the constructor are passed to the handlers to create the
    response.'
  prefs: []
  type: TYPE_NORMAL
- en: A default handler override
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The optimum way to override the exception-handling mechanism of your application
    is to replace the global exception handler of the FastAPI framework that manages
    its core Starlette’s `HTTPException` and the `RequestValidationError` triggered
    by `raise` from JSON-type to plain text, we can create custom handlers for each
    of the aforementioned core exceptions that will pursue the format conversion.
    The following snippets of `main.py` show these types of custom handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Both the `global_exception_handler()` and `validationerror_exception_handler()`
    handlers are implemented to change the framework’s JSON-type exception response
    to `PlainTextResponse`. An alias, `GlobalStarletteHTTPException`, is assigned
    to Starlette’s `HTTPException` class to distinguish it from FastAPI’s `HTTPException`,
    which we previously used to build custom exceptions. On the other hand, `PostFeedbackException`
    and `PostRatingException` are both implemented in the `handler_exceptions.py`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: JSON objects are all over the FastAPI framework’s REST API implementation, from
    the incoming request to the outgoing responses. However, what if the JSON data
    involved in the process is not a FastAPI JSON-compatible type? The following discussion
    will expound more upon this kind of object.
  prefs: []
  type: TYPE_NORMAL
- en: Converting objects to JSON-compatible types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is easier for FastAPI to process JSON-compatible types such as `dict`, `list`,
    and `BaseModel` objects because they can be easily converted to JSON by the framework
    using its default JSON editor. However, there are circumstances in which runtime
    exceptions are raised when processing BaseModel, data model, or JSON objects containing
    data. One of the many reasons for this is that these data objects have attributes
    that are not supported by JSON rules, such as UUID and non-built-in date types.
    Regardless, using a framework’s module classes, these objects can still be utilized
    by converting them into JSON-compatible ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to the direct handling of the API operation’s responses, FastAPI
    has a built-in method that can encode typical model objects to convert them to
    JSON-compatible types before persisting them to any datastore or passing them
    to the `detail` parameter of `JSONResponse`. This method, `jsonable_encoder()`,
    returns a `dict` type with all the keys and values compatible with JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our application has a `POST` operation, `signup()`, shown here that captures
    the profile of a newly created user to be approved by the administrator. If you
    observe the `Tourist` model class, it has a `date_signed` attribute that is declared
    as `datettime`, and temporal types are not always JSON-friendly. Having model
    objects with non-JSON-friendly components in FastAPI-related operations can cause
    serious exceptions. To avoid these Pydantic validation issues, it is always advisable
    to use `jsonable_encoder()` to manage the conversion of all the attributes of
    our model object into JSON-types.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `json` module with its `dumps()` and `loads()` utility methods can be used
    instead of `jsonable_encoder()` but a custom JSON encoder should be created to
    successfully map the `UUID` type, the formatted `date` type, and other complex
    attribute types to `str`.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B17975_09.xhtml#_idTextAnchor266), *Utilizing Other Advanced
    Features*, will discuss other JSON encoders that can encode and decode JSON responses
    faster than the `json` module.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing API responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The use of `jsonable_encoder()` can help an API method not only with data persistency
    problems but also with the integrity and correctness of its response. In the `signup()`
    service method, `JSONResponse` returns the encoded `Tourist` model instead of
    the original object to ensure that the client always received a JSON response.
    Aside from raising status codes and providing error messages, `JSONResponse` can
    also do some tricks in handling the API responses to the client. Although optional
    in many circumstances, applying the encoder method when generating responses is
    recommended to avoid runtime errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`check_tour_profile()` here uses `JSONResponse` to ensure that its response
    is JSON-compatible and is fetched from the purpose of managing its exceptions.
    Moreover, it can also be used to return headers together with the JSON-type response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The application’s `list_tour_destinations()` here returns three cookies: `AppName`,
    `Max-Age`, and `Version`, and two user-defined response headers. Headers that
    have names beginning with `X-` are custom headers. Besides `JSONResponse`, the
    `fastapi` module also has a `Response` class that can create response headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our prototype’s `check_recommend_tour()` uses `Response` to create two custom
    response headers and a known `str` types and are stored in the browser for many
    reasons, such as creating an identity for the application, leaving user trails,
    dropping advertisement-related data, or leaving an error message to the browser
    when an API encounters one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`HTTPException`, as shown in the `show_booked_tours()` service method here,
    not only contains the status code and error message but also some headers in case
    the operation needs to leave some error information to the browser once it is
    raised.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us now explore the capability of FastAPI to create and manage transactions
    that are designed to run in the background using some server threads.
  prefs: []
  type: TYPE_NORMAL
- en: Creating background processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FastAPI framework is also capable of running background jobs as part of
    an API service execution. It can even run more than one job almost simultaneously
    without intervening in the main service execution. The class responsible for this
    is `BackgroundTasks`, which is part of the `fastapi` module. Conventionally, we
    declare this at the end of the parameter list of the API service method for the
    framework to inject the `BackgroundTask` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, the task is to create audit logs of all API service executions
    and store them in an `audit_log.txt` file. This operation is part of the `background.py`
    script that is part of the main project folder, and the code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `audit_log_transaction()` must be injected into the application using
    `BackgroundTasks`’s `add_task()` method to become a background process that will
    be executed by the framework later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `login()` service method is just one of the services of our application
    that logs its details. It uses the `bg_task` object to add `audit_log_transaction()`
    into the framework to be processed later. Transactions such as logging, *SMTP*-/*FTP*-related
    requirements, events, and some database-related triggers are the best candidates
    for background jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Clients will always get their response from the REST API method despite the
    execution time of the background task. Background tasks are for processes that
    will take enough time that including them in the API operation could cause performance
    degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous path operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to improving performance, FastAPI is an asynchronous framework,
    and it uses Python’s `async` to the `func` signature of the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our application has a `show_tourist_post()` service that can retrieve all the
    feedback posted by a certain `touristId` about a vacation tour that they have
    experienced. The application will not be affected no matter how long the service
    will take because its execution will be simultaneous to the `main` thread.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `feedback` APIRouter uses a `/ch02/post` prefix indicated in its `main.py`’s
    `include_router()` registration. So, to run `show_tourist_post()`, the URL should
    be `http://localhost:8000/ch02/post`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An asynchronous API endpoint can invoke both synchronous and asynchronous Python
    functions that can be DAO (Data Access Object), native services, or utility. Since
    FastAPI also follows the `Async/Await` design pattern, the asynchronous endpoint
    can call an asynchronous non-API operation using the `await` keyword, which halts
    the API operation until the non-API transaction is done processing a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`delete_tourist_feedback()` here is an asynchronous REST API endpoint that
    calls an asynchronous Python function, `check_post_owner()`, from the `utility.py`
    script. For the two components to have a handshake, the API service invokes `check_post_owner()`,
    using an `await` keyword for the former to wait for the latter to finish its validation,
    and retrieves the promise that it can get from `await`.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `await` keyword can only be used with the `async` REST API and native transactions,
    not with synchronous ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve performance, you can add more threads within the `uvicorn` thread
    pool by including the `--workers` option when running the server. Indicate your
    preferred number of threads after calling the option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[*Chapter 8*](B17975_08.xhtml#_idTextAnchor229), *Creating Coroutines, Events,
    and Message-Driven Transactions*, will discuss the *AsyncIO* platform and the
    use of *coroutines* in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: And now, the last, most important core feature that FastAPI can provide is the
    middleware or the "request-response filter."
  prefs: []
  type: TYPE_NORMAL
- en: Applying middleware to filter path operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are FastAPI components that are inherently asynchronous and one of them
    is the middleware. It is an asynchronous function that acts as a filter for the
    REST API services. It filters out the incoming request to pursue validation, authentication,
    logging, background processing, or content generation from the cookies, headers,
    request parameters, query parameters, form data, or authentication details of
    the request body before it reaches the API service method. Equally, it takes the
    outgoing response body to pursue rendition change, response header updates and
    additions, and other kinds of transformation that could possibly be applied to
    the response before it reaches the client. Middleware should be implemented at
    the project level and can even be part of `main.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement middleware, first, create an `async` function that has two local
    parameters: the first one is `Request` and the second one is a function called
    `call_next()`, which takes the `Request` parameter as its argument to return the
    response. Then, decorate the method with `@app.middleware("http")` to inject the
    component into the framework.'
  prefs: []
  type: TYPE_NORMAL
- en: The tourist application has one middleware implemented by the asynchronous `add_transaction_filter()`
    here that logs the necessary request data of a particular API method before its
    execution and modifies its response object by adding a response header, `X-Time-Elapsed`,
    which carries the running time of the execution.
  prefs: []
  type: TYPE_NORMAL
- en: The execution of `await call_next(request)` is the most crucial part of the
    middleware because it explicitly controls the execution of the REST API service.
    It is the area of the component where `Request` passes through to the API execution
    for processing. Equally, it is where `Response` tunnels out, going to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Besides logging, middleware can also be used for implementing one-way or two-way
    authentication, checking user roles and permissions, global exception handling,
    and other filtering-related operations right before the execution of `call_next()`.
    When it comes to controlling the outgoing `Response`, it can be used to modify
    the content type of the response, remove some existing browser cookies, modify
    the response detail and status code, redirections, and other response transformation-related
    transactions. [*Chapter 9*](B17975_09.xhtml#_idTextAnchor266), *Utilizing Other
    Advanced Features*, will discuss the types of middleware, middleware chaining,
    and other means to customize middleware to help build a better microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The FastAPI framework has some built-in middleware that is ready to be injected
    into the application such as `GzipMiddleware`, `ServerErrorMiddleware`, `TrustedHostMiddleware`,
    `ExceptionMiddleware`, `CORSMiddleware`, `SessionMiddleware`, and `HTTPSRedirectionMiddleware`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring the core details of a framework always helps us create a comprehensive
    plan and design to build quality applications to the required standards. We have
    learned that FastAPI injects all its incoming form data, request parameters, query
    parameters, cookies, request headers, and authentication details into the `Request`
    object, and the outgoing cookies, response headers, and response data are carried
    out to the client by the `Response` object. When managing the response data, the
    framework has a built-in `jsonable_encoder()` function that can convert the model
    into JSON types to be rendered by the `JSONResponse` object. Its middleware is
    one powerful feature of FastAPI because we can customize it to handle the `Request`
    object before it reaches the API execution and the `Response` object before the
    client receives it.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the exceptions is always the first step to consider before creating
    a practical and sustainable solution for the resiliency and health of a microservice
    architecture. Alongside its robust default **Starlette** global exception handler
    and **Pydantic** model validator, FastAPI allows exception-handling customization
    that provides the flexibility needed when business processes become intricate.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI follows Python’s **AsyncIO** principles and standards for creating async
    REST endpoints, which makes implementation easy, handy, and reliable. This kind
    of platform is helpful for building complex architectures that require more threads
    and asynchronous transactions.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is a great leap toward fully learning about the principles and
    standards of how FastAPI manages its web containers. The features highlighted
    in this chapter hitherto open up a new level of knowledge that we need to explore
    further if we want to utilize FastAPI to build great microservices. In the next
    chapter, we will be discussing FastAPI dependency injection and how this design
    pattern affects our FastAPI projects.
  prefs: []
  type: TYPE_NORMAL
