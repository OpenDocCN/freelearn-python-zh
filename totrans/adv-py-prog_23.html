<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer185">
			<h1 id="_idParaDest-336"><em class="italic"><a id="_idTextAnchor317"/>Chapter 20</em>: The Decorator Pattern</h1>
			<p>As we saw in the previous chapter, using an <strong class="bold">adapter</strong>, the first structural design pattern, you can adapt an object implementing a given interface to implement another interface. This is called <strong class="bold">interface</strong> <strong class="bold">adaptation</strong> and<a id="_idIndexMarker1240"/> includes the kinds of patterns that encourage composition over inheritance, and it could bring benefits when you have to maintain a large codebase.</p>
			<p>A second interesting structural pattern to learn about is the <strong class="bold">decorator</strong> pattern, which allows us to add responsibilities to an object dynamically and transparently (without affecting other objects); this will be the topic of this chapter. Throughout our discussions, we will learn more about a specific usage of this design pattern: <strong class="bold">memoization</strong>.</p>
			<p>We will discuss the following topics:</p>
			<ul>
				<li>Introducing the decorator pattern </li>
				<li>Real-world examples</li>
				<li>Use cases</li>
				<li>Implementation</li>
			</ul>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor318"/>Technical requirements</h1>
			<p>The code files for this chapter can be accessed through this link: <a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter20">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter20</a>.</p>
			<h1 id="_idParaDest-338"><a id="_idTextAnchor319"/>Introducing the decorator pattern</h1>
			<p>As Python developers, we <a id="_idIndexMarker1241"/>can write decorators in a <strong class="bold">Pythonic</strong> way (meaning using the language's features), thanks to <a id="_idIndexMarker1242"/>the built-in decorator feature (<a href="https://docs.python.org/3/reference/compound_stmts.html#function">https://docs.python.org/3/reference/compound_stmts.html#function</a>). What exactly is this feature? A Python decorator is <a id="_idIndexMarker1243"/>a <strong class="bold">callable</strong> (function, method, or class) that<a id="_idIndexMarker1244"/> gets a function object, <strong class="source-inline">func_in</strong>, as input and returns another function object, <strong class="source-inline">func_out</strong>. It is a commonly used technique for extending the behavior of a function, method, or class.</p>
			<p>But this feature<a id="_idIndexMarker1245"/> should not be completely new to you. We have already seen how to use the built-in <strong class="source-inline">property</strong> decorator, which makes a method appear as a variable in both <a href="B17499_16_Final_SS_ePub.xhtml#_idTextAnchor276"><em class="italic">Chapter 16</em></a>, <em class="italic">The Factory Pattern</em>, and <a href="B17499_17_Final_SS_ePub.xhtml#_idTextAnchor289"><em class="italic">Chapter 17</em></a>, <em class="italic">The Builder Pattern</em>. There are also several other useful built-in decorators in Python. In the <em class="italic">Implementation</em> section of this chapter, we will learn how to implement and use our own decorators.</p>
			<p>Note that there is no one-to-one relationship between the decorator pattern and Python's decorator feature. Python decorators can actually do much more than the decorator pattern. One of the things they can be used for is to implement the decorator pattern (<a href="http://j.mp/moinpydec">j.mp/moinpydec</a>).</p>
			<p>Now, let's discuss some examples where the decorator pattern applies.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor320"/>Real-world examples</h1>
			<p>The decorator pattern<a id="_idIndexMarker1246"/> is generally used for extending the functionality of an object. In everyday life, examples of functionality extensions are adding a holder stand to a phone or using different camera lenses.</p>
			<p>In the Django framework, which uses decorators a lot, we have the <strong class="source-inline">View</strong> decorators, which can be used for the<a id="_idIndexMarker1247"/> following (<a href="http://j.mp/djangodec">j.mp/djangodec</a>):</p>
			<ul>
				<li>Restricting access to views based on the HTTP request</li>
				<li>Controlling the caching behavior on specific views</li>
				<li>Controlling compression on a per-view basis</li>
				<li>Controlling caching based on specific HTTP request headers</li>
			</ul>
			<p>Both the Pyramid framework and the Zope application server also use decorators to achieve various goals, such as the following:</p>
			<ul>
				<li>Registering a function as an event subscriber</li>
				<li>Protecting a method with a specific permission</li>
				<li>Implementing the adapter pattern</li>
			</ul>
			<p>To be more<a id="_idIndexMarker1248"/> concrete, we will iterate the specific use cases of the design pattern in the next section.</p>
			<h1 id="_idParaDest-340"><a id="_idTextAnchor321"/>Use cases</h1>
			<p>The decorator pattern <a id="_idIndexMarker1249"/>shines when used for implementing<a id="_idIndexMarker1250"/> cross-cutting concerns (<a href="http://j.mp/wikicrosscut">j.mp/wikicrosscut</a>). Examples <a id="_idIndexMarker1251"/>of cross-cutting concerns are as follows:</p>
			<ul>
				<li>Data validation</li>
				<li>Caching</li>
				<li>Logging</li>
				<li>Monitoring</li>
				<li>Debugging</li>
				<li>Business rules</li>
				<li>Encryption</li>
			</ul>
			<p>In general, all parts of an application that are generic and can be applied to many different parts of it are considered to be cross-cutting concerns.</p>
			<p>Another popular example of using the decorator pattern is <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) toolkits. In a GUI toolkit, we<a id="_idIndexMarker1252"/> want to be able to add features such as borders, shadows, colors, and scrolling to individual components/widgets.</p>
			<p>Now, let's move on to the implementation part of the chapter, in which we will see how the decorator pattern helps with memoization.</p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor322"/>Implementation</h1>
			<p>Python decorators are generic and very powerful. You can find many examples of how they can be used in the <a id="_idIndexMarker1253"/>decorator library of <strong class="source-inline">python.org</strong> (<a href="http://j.mp/pydeclib">j.mp/pydeclib</a>). In this section, we will see how we can implement a<a id="_idIndexMarker1254"/> memoization decorator (<a href="http://j.mp/memoi">j.mp/memoi</a>). All recursive functions can benefit from memoization, so let's try a function, <strong class="source-inline">number_sum()</strong>, that returns the sum of the first <strong class="source-inline">n</strong> numbers. Note <a id="_idIndexMarker1255"/>that this function is already available in the <strong class="source-inline">math</strong> module as <strong class="source-inline">fsum()</strong>, but let's pretend it is not.</p>
			<p>First, let's look at the naive implementation (the <strong class="source-inline">number_sum_naive.py</strong> file):</p>
			<p class="source-code">def number_sum(n): </p>
			<p class="source-code">    '''Returns the sum of the first n numbers''' </p>
			<p class="source-code">    assert(n &gt;= 0), 'n must be &gt;= 0' </p>
			<p class="source-code">    </p>
			<p class="source-code">    if n == 0:</p>
			<p class="source-code">        return 0</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        return n + number_sum(n-1)  </p>
			<p class="source-code"> </p>
			<p class="source-code">if __name__ == '__main__': </p>
			<p class="source-code">    from timeit import Timer </p>
			<p class="source-code">    t = Timer('number_sum(30)', 'from __main__ import \</p>
			<p class="source-code">       number_sum')</p>
			<p class="source-code">    print('Time: ', t.timeit())</p>
			<p>A sample execution of this example shows how slow this implementation is. It takes roughly 3 seconds to calculate the sum of the first 30 numbers on a MacBook, which can be seen when executing the <strong class="source-inline">python number_sum_naive.py</strong> command:</p>
			<p class="source-code">Time:  3.023907012</p>
			<p>Let's see whether using memoization can help us improve the performance number. In the following code, we use <strong class="source-inline">dict</strong> for caching the already computed sums. We also change the parameter passed to the <strong class="source-inline">number_sum()</strong> function. We want to calculate the sum of the<a id="_idIndexMarker1256"/> first 300 numbers instead of only the first 30.</p>
			<p>Here is the new version of the code, using memoization:</p>
			<p class="source-code">sum_cache = {0:0}</p>
			<p class="source-code">  </p>
			<p class="source-code">def number_sum(n): </p>
			<p class="source-code">    '''Returns the sum of the first n numbers''' </p>
			<p class="source-code">    assert(n &gt;= 0), 'n must be &gt;= 0'</p>
			<p class="source-code">    </p>
			<p class="source-code">    if n in sum_cache:</p>
			<p class="source-code">        return sum_cache[n]</p>
			<p class="source-code">    res = n + number_sum(n-1)</p>
			<p class="source-code">    # Add the value to the cache</p>
			<p class="source-code">    sum_cache[n] = res</p>
			<p class="source-code">    return res</p>
			<p class="source-code">         </p>
			<p class="source-code">if __name__ == '__main__': </p>
			<p class="source-code">    from timeit import Timer </p>
			<p class="source-code">    t = Timer('number_sum(300)', 'from __main__ import \</p>
			<p class="source-code">      number_sum')</p>
			<p class="source-code">    print('Time: ', t.timeit())</p>
			<p>Executing the memoization-based code shows that performance improves dramatically and is acceptable even for computing large values.</p>
			<p>A sample execution, using <strong class="source-inline">python number_sum.py</strong>, is as follows:</p>
			<p class="source-code">Time:  0.12304591899999999</p>
			<p>But there are already a few problems with this approach. While the performance is not an issue any longer, the code is not as clean as it is when not using memoization. And what happens if we decide to extend the code with more math functions and turn it into a module? We can think of several functions that would be useful for our module, for problems such as Pascal's triangle or the Fibonacci numbers suite algorithm.</p>
			<p>So, if we <a id="_idIndexMarker1257"/>wanted a function in the same module as <strong class="source-inline">number_sum()</strong>, for the Fibonacci numbers suite, using the same memoization technique, we would add code that looks as follows:</p>
			<p class="source-code">cache_fib = {0:0, 1:1} </p>
			<p class="source-code"> </p>
			<p class="source-code">def fibonacci(n): </p>
			<p class="source-code">    '''Returns the suite of Fibonacci numbers''' </p>
			<p class="source-code">    assert(n &gt;= 0), 'n must be &gt;= 0' </p>
			<p class="source-code">    </p>
			<p class="source-code">    if n in cache_fib: </p>
			<p class="source-code">        return cache_fib[n] </p>
			<p class="source-code">    res = fibonacci(n-1) + fibonacci(n-2) </p>
			<p class="source-code">    cache_fib[n] = res </p>
			<p class="source-code">    return res</p>
			<p>Do you notice the problem already? We ended up with a new <strong class="source-inline">dict</strong> called <strong class="source-inline">cache_fib</strong>, which acts as our cache for the <strong class="source-inline">fibonacci()</strong> function, and a function that is more complex than it would be without using memoization. Our module is becoming unnecessarily complex. Is it possible to write these functions keeping them as simple as the naive versions, but achieving performance similar to the performance of the functions that use memoization?</p>
			<p>Fortunately, it is, and the solution is to use the decorator pattern.</p>
			<p>First, we create a <strong class="source-inline">memoize()</strong> decorator, as shown in the following example. Our decorator accepts the <strong class="source-inline">fn</strong> function, which needs to be memoized, as an input. It uses <strong class="source-inline">dict</strong> named <strong class="source-inline">cache</strong> as the cached data container. The <strong class="source-inline">functools.wraps()</strong> function is<a id="_idIndexMarker1258"/> used for convenience when creating decorators. It is not mandatory but a good practice to<a id="_idIndexMarker1259"/> use it since it makes sure that the documentation, and the signature of the function that is<a id="_idIndexMarker1260"/> decorated, is preserved (<a href="http://j.mp/funcwraps">j.mp/funcwraps</a>). The <strong class="source-inline">*args</strong> argument list is required in this case because the functions that we want to decorate accept input arguments (such as the <strong class="source-inline">n</strong> argument for our two functions):</p>
			<p class="source-code">import functools </p>
			<p class="source-code"> </p>
			<p class="source-code">def memoize(fn): </p>
			<p class="source-code">    cache = dict() </p>
			<p class="source-code"> </p>
			<p class="source-code">    @functools.wraps(fn) </p>
			<p class="source-code">    def memoizer(*args): </p>
			<p class="source-code">        if args not in cache: </p>
			<p class="source-code">            cache[args] = fn(*args) </p>
			<p class="source-code">        return cache[args] </p>
			<p class="source-code"> </p>
			<p class="source-code">    return memoizer</p>
			<p>Now, we can use our <strong class="source-inline">memoize()</strong> decorator with the naive version of our functions. This has the benefit of readable code without performance impact. We apply a decorator using what is known as decoration (or a decoration line). A decoration uses the <strong class="source-inline">@name</strong> syntax, where <strong class="source-inline">name</strong> is the name of the decorator that we want to use. It is nothing more than syntactic sugar for simplifying the usage of decorators. We can even bypass this syntax and execute our decorator manually, but that is left as an exercise for you.</p>
			<p>So, the <strong class="source-inline">memoize()</strong> decorator can be used with our recursive functions as follows:</p>
			<p class="source-code">@memoize </p>
			<p class="source-code">def number_sum(n): </p>
			<p class="source-code">    '''Returns the sum of the first n numbers''' </p>
			<p class="source-code">    assert(n &gt;= 0), 'n must be &gt;= 0' </p>
			<p class="source-code">    if n == 0:</p>
			<p class="source-code">        return 0</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        return n + number_sum(n-1)</p>
			<p class="source-code"> </p>
			<p class="source-code">@memoize </p>
			<p class="source-code">def fibonacci(n): </p>
			<p class="source-code">    '''Returns the suite of Fibonacci numbers''' </p>
			<p class="source-code">    assert(n &gt;= 0), 'n must be &gt;= 0'</p>
			<p class="source-code">    if n in (0, 1):</p>
			<p class="source-code">        return n</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        return fibonacci(n-1) + fibonacci(n-2)</p>
			<p>In the <a id="_idIndexMarker1261"/>last part of the code, via the <strong class="source-inline">main()</strong> function, we show how to use the decorated functions and measure their performance. The <strong class="source-inline">to_execute</strong> variable is used to hold a list of tuples containing the reference to each function and the corresponding <strong class="source-inline">timeit.Timer()</strong> call (to execute it while measuring the time spent), thus avoiding code repetition. Note how the <strong class="source-inline">__name__</strong> and <strong class="source-inline">__doc__</strong> method attributes show the proper function names and documentation values, respectively. Try removing the <strong class="source-inline">@functools.wraps(fn)</strong> decoration from <strong class="source-inline">memoize()</strong>, and see whether this is still the case.</p>
			<p>Here is the last part of the code:</p>
			<p class="source-code">def main():</p>
			<p class="source-code">    from timeit import Timer</p>
			<p class="source-code">    to_execute = [</p>
			<p class="source-code">        (number_sum, </p>
			<p class="source-code">         Timer('number_sum(300)', 'from __main__ import \</p>
			<p class="source-code">           number_sum')),</p>
			<p class="source-code">        (fibonacci, </p>
			<p class="source-code">         Timer('fibonacci(100)', 'from __main__ import \</p>
			<p class="source-code">           fibonacci'))    </p>
			<p class="source-code">    ]</p>
			<p class="source-code">    </p>
			<p class="source-code">    for item in to_execute:</p>
			<p class="source-code">        fn = item[0]</p>
			<p class="source-code">        print(f'Function "{fn.__name__}": {fn.__doc__}')</p>
			<p class="source-code">        t = item[1]</p>
			<p class="source-code">        print(f'Time: {t.timeit()}')</p>
			<p class="source-code">        print()</p>
			<p class="source-code">if __name__ == '__main__': </p>
			<p class="source-code">    main()</p>
			<p>Let's recapitulate how <a id="_idIndexMarker1262"/>we write the complete code of our math module (the <strong class="source-inline">mymath.py</strong> file):</p>
			<ol>
				<li>After the import of Python's <strong class="source-inline">functools</strong> module that we will be using, we define the <strong class="source-inline">memoize()</strong> decorator function.</li>
				<li>Then, we define the <strong class="source-inline">number_sum()</strong> function, decorated using <strong class="source-inline">memoize()</strong>.</li>
				<li>We also define the <strong class="source-inline">fibonacci()</strong> function, as decorated.</li>
				<li>Finally, we add the <strong class="source-inline">main()</strong> function, as shown earlier, and use the usual trick to call it.</li>
			</ol>
			<p>Here is a sample output when executing the <strong class="source-inline">python mymath.py</strong> command:</p>
			<p class="source-code">Function "number_sum": Returns the sum of the first n </p>
			<p class="source-code">numbers</p>
			<p class="source-code">Time: 0.152614356</p>
			<p class="source-code">Function "fibonacci": Returns the suite of Fibonacci </p>
			<p class="source-code">numbers</p>
			<p class="source-code">Time: 0.142395913</p>
			<p>(The execution times might differ in your case.)</p>
			<p>At this point, we end up with readable code and acceptable performance. Now, you might argue <a id="_idIndexMarker1263"/>that this is not the decorator pattern, since we don't apply it at runtime. The truth is that a decorated function cannot be undecorated, but you can still decide at runtime whether the decorator will be executed or not. That's an interesting exercise left for you.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Use a decorator that acts as a wrapper, which decides whether or not the real decorator is executed based on some condition.</p>
			<p>Another interesting property of decorators not covered in this chapter is that you can decorate a function with more than one decorator. So, here's another exercise: create a decorator that helps you to debug recursive functions, apply it to <strong class="source-inline">number_sum()</strong> and <strong class="source-inline">fibonacci()</strong>, and finally, determine the order in which the multiple decorators are executed.</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor323"/>Summary</h1>
			<p>This chapter covered the decorator pattern and its relationship to the Python programming language. We used the decorator pattern conveniently to extend the behavior of an object without using inheritance. Python, with its built-in decorator feature, extends the decorator concept even more, by allowing us to extend the behavior of any callable (function, method, or class) without using inheritance or composition.</p>
			<p>We have seen a few examples of real-world objects that are decorated, such as cameras. From a software point of view, both Django and Pyramid use decorators to achieve different goals, such as controlling HTTP compression and caching.</p>
			<p>The decorator pattern is a great solution for implementing cross-cutting concerns because they are generic and do not fit well into the OOP paradigm. We mentioned several categories of cross-cutting concerns in the <em class="italic">Use cases</em> section. In fact, in the <em class="italic">Implementation</em> section, a cross-cutting concern was demonstrated: memoization. We saw how decorators can help us to keep our functions clean, without sacrificing performance.</p>
			<p>The next chapter covers the bridge pattern.</p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor324"/>Questions</h1>
			<ol>
				<li value="1">What is the main motivation for the decorator pattern?</li>
				<li>Why is the decorator pattern particularly relevant in Python?</li>
				<li>How does the decorator pattern help with memoization?</li>
			</ol>
		</div>
	</div>
</div>
</body></html>