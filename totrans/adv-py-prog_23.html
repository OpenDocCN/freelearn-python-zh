<html><head></head><body>
<div><div><div><h1 id="_idParaDest-336"><em class="italic"><a id="_idTextAnchor317"/>Chapter 20</em>: The Decorator Pattern</h1>
			<p>As we saw in the previous chapter, using an <strong class="bold">adapter</strong>, the first structural design pattern, you can adapt an object implementing a given interface to implement another interface. This is called <strong class="bold">interface</strong> <strong class="bold">adaptation</strong> and<a id="_idIndexMarker1240"/> includes the kinds of patterns that encourage composition over inheritance, and it could bring benefits when you have to maintain a large codebase.</p>
			<p>A second interesting structural pattern to learn about is the <strong class="bold">decorator</strong> pattern, which allows us to add responsibilities to an object dynamically and transparently (without affecting other objects); this will be the topic of this chapter. Throughout our discussions, we will learn more about a specific usage of this design pattern: <strong class="bold">memoization</strong>.</p>
			<p>We will discuss the following topics:</p>
			<ul>
				<li>Introducing the decorator pattern </li>
				<li>Real-world examples</li>
				<li>Use cases</li>
				<li>Implementation</li>
			</ul>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor318"/>Technical requirements</h1>
			<p>The code files for this chapter can be accessed through this link: <a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter20">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter20</a>.</p>
			<h1 id="_idParaDest-338"><a id="_idTextAnchor319"/>Introducing the decorator pattern</h1>
			<p>As Python developers, we <a id="_idIndexMarker1241"/>can write decorators in a <code>func_in</code>, as input and returns another function object, <code>func_out</code>. It is a commonly used technique for extending the behavior of a function, method, or class.</p>
			<p>But this feature<a id="_idIndexMarker1245"/> should not be completely new to you. We have already seen how to use the built-in <code>property</code> decorator, which makes a method appear as a variable in both <a href="B17499_16_Final_SS_ePub.xhtml#_idTextAnchor276"><em class="italic">Chapter 16</em></a>, <em class="italic">The Factory Pattern</em>, and <a href="B17499_17_Final_SS_ePub.xhtml#_idTextAnchor289"><em class="italic">Chapter 17</em></a>, <em class="italic">The Builder Pattern</em>. There are also several other useful built-in decorators in Python. In the <em class="italic">Implementation</em> section of this chapter, we will learn how to implement and use our own decorators.</p>
			<p>Note that there is no one-to-one relationship between the decorator pattern and Python's decorator feature. Python decorators can actually do much more than the decorator pattern. One of the things they can be used for is to implement the decorator pattern (<a href="http://j.mp/moinpydec">j.mp/moinpydec</a>).</p>
			<p>Now, let's discuss some examples where the decorator pattern applies.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor320"/>Real-world examples</h1>
			<p>The decorator pattern<a id="_idIndexMarker1246"/> is generally used for extending the functionality of an object. In everyday life, examples of functionality extensions are adding a holder stand to a phone or using different camera lenses.</p>
			<p>In the Django framework, which uses decorators a lot, we have the <code>View</code> decorators, which can be used for the<a id="_idIndexMarker1247"/> following (<a href="http://j.mp/djangodec">j.mp/djangodec</a>):</p>
			<ul>
				<li>Restricting access to views based on the HTTP request</li>
				<li>Controlling the caching behavior on specific views</li>
				<li>Controlling compression on a per-view basis</li>
				<li>Controlling caching based on specific HTTP request headers</li>
			</ul>
			<p>Both the Pyramid framework and the Zope application server also use decorators to achieve various goals, such as the following:</p>
			<ul>
				<li>Registering a function as an event subscriber</li>
				<li>Protecting a method with a specific permission</li>
				<li>Implementing the adapter pattern</li>
			</ul>
			<p>To be more<a id="_idIndexMarker1248"/> concrete, we will iterate the specific use cases of the design pattern in the next section.</p>
			<h1 id="_idParaDest-340"><a id="_idTextAnchor321"/>Use cases</h1>
			<p>The decorator pattern <a id="_idIndexMarker1249"/>shines when used for implementing<a id="_idIndexMarker1250"/> cross-cutting concerns (<a href="http://j.mp/wikicrosscut">j.mp/wikicrosscut</a>). Examples <a id="_idIndexMarker1251"/>of cross-cutting concerns are as follows:</p>
			<ul>
				<li>Data validation</li>
				<li>Caching</li>
				<li>Logging</li>
				<li>Monitoring</li>
				<li>Debugging</li>
				<li>Business rules</li>
				<li>Encryption</li>
			</ul>
			<p>In general, all parts of an application that are generic and can be applied to many different parts of it are considered to be cross-cutting concerns.</p>
			<p>Another popular example of using the decorator pattern is <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) toolkits. In a GUI toolkit, we<a id="_idIndexMarker1252"/> want to be able to add features such as borders, shadows, colors, and scrolling to individual components/widgets.</p>
			<p>Now, let's move on to the implementation part of the chapter, in which we will see how the decorator pattern helps with memoization.</p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor322"/>Implementation</h1>
			<p>Python decorators are generic and very powerful. You can find many examples of how they can be used in the <a id="_idIndexMarker1253"/>decorator library of <code>python.org</code> (<a href="http://j.mp/pydeclib">j.mp/pydeclib</a>). In this section, we will see how we can implement a<a id="_idIndexMarker1254"/> memoization decorator (<a href="http://j.mp/memoi">j.mp/memoi</a>). All recursive functions can benefit from memoization, so let's try a function, <code>number_sum()</code>, that returns the sum of the first <code>n</code> numbers. Note <a id="_idIndexMarker1255"/>that this function is already available in the <code>math</code> module as <code>fsum()</code>, but let's pretend it is not.</p>
			<p>First, let's look at the naive implementation (the <code>number_sum_naive.py</code> file):</p>
			<pre>def number_sum(n): 
    '''Returns the sum of the first n numbers''' 
    assert(n &gt;= 0), 'n must be &gt;= 0' 
    
    if n == 0:
        return 0
    else:
        return n + number_sum(n-1)  
 
if __name__ == '__main__': 
    from timeit import Timer 
    t = Timer('number_sum(30)', 'from __main__ import \
       number_sum')
    print('Time: ', t.timeit())</pre>
			<p>A sample execution of this example shows how slow this implementation is. It takes roughly 3 seconds to calculate the sum of the first 30 numbers on a MacBook, which can be seen when executing the <code>python number_sum_naive.py</code> command:</p>
			<pre>Time:  3.023907012</pre>
			<p>Let's see whether using memoization can help us improve the performance number. In the following code, we use <code>dict</code> for caching the already computed sums. We also change the parameter passed to the <code>number_sum()</code> function. We want to calculate the sum of the<a id="_idIndexMarker1256"/> first 300 numbers instead of only the first 30.</p>
			<p>Here is the new version of the code, using memoization:</p>
			<pre>sum_cache = {0:0}
  
def number_sum(n): 
    '''Returns the sum of the first n numbers''' 
    assert(n &gt;= 0), 'n must be &gt;= 0'
    
    if n in sum_cache:
        return sum_cache[n]
    res = n + number_sum(n-1)
    # Add the value to the cache
    sum_cache[n] = res
    return res
         
if __name__ == '__main__': 
    from timeit import Timer 
    t = Timer('number_sum(300)', 'from __main__ import \
      number_sum')
    print('Time: ', t.timeit())</pre>
			<p>Executing the memoization-based code shows that performance improves dramatically and is acceptable even for computing large values.</p>
			<p>A sample execution, using <code>python number_sum.py</code>, is as follows:</p>
			<pre>Time:  0.12304591899999999</pre>
			<p>But there are already a few problems with this approach. While the performance is not an issue any longer, the code is not as clean as it is when not using memoization. And what happens if we decide to extend the code with more math functions and turn it into a module? We can think of several functions that would be useful for our module, for problems such as Pascal's triangle or the Fibonacci numbers suite algorithm.</p>
			<p>So, if we <a id="_idIndexMarker1257"/>wanted a function in the same module as <code>number_sum()</code>, for the Fibonacci numbers suite, using the same memoization technique, we would add code that looks as follows:</p>
			<pre>cache_fib = {0:0, 1:1} 
 
def fibonacci(n): 
    '''Returns the suite of Fibonacci numbers''' 
    assert(n &gt;= 0), 'n must be &gt;= 0' 
    
    if n in cache_fib: 
        return cache_fib[n] 
    res = fibonacci(n-1) + fibonacci(n-2) 
    cache_fib[n] = res 
    return res</pre>
			<p>Do you notice the problem already? We ended up with a new <code>dict</code> called <code>cache_fib</code>, which acts as our cache for the <code>fibonacci()</code> function, and a function that is more complex than it would be without using memoization. Our module is becoming unnecessarily complex. Is it possible to write these functions keeping them as simple as the naive versions, but achieving performance similar to the performance of the functions that use memoization?</p>
			<p>Fortunately, it is, and the solution is to use the decorator pattern.</p>
			<p>First, we create a <code>memoize()</code> decorator, as shown in the following example. Our decorator accepts the <code>fn</code> function, which needs to be memoized, as an input. It uses <code>dict</code> named <code>cache</code> as the cached data container. The <code>functools.wraps()</code> function is<a id="_idIndexMarker1258"/> used for convenience when creating decorators. It is not mandatory but a good practice to<a id="_idIndexMarker1259"/> use it since it makes sure that the documentation, and the signature of the function that is<a id="_idIndexMarker1260"/> decorated, is preserved (<a href="http://j.mp/funcwraps">j.mp/funcwraps</a>). The <code>*args</code> argument list is required in this case because the functions that we want to decorate accept input arguments (such as the <code>n</code> argument for our two functions):</p>
			<pre>import functools 
 
def memoize(fn): 
    cache = dict() 
 
    @functools.wraps(fn) 
    def memoizer(*args): 
        if args not in cache: 
            cache[args] = fn(*args) 
        return cache[args] 
 
    return memoizer</pre>
			<p>Now, we can use our <code>memoize()</code> decorator with the naive version of our functions. This has the benefit of readable code without performance impact. We apply a decorator using what is known as decoration (or a decoration line). A decoration uses the <code>@name</code> syntax, where <code>name</code> is the name of the decorator that we want to use. It is nothing more than syntactic sugar for simplifying the usage of decorators. We can even bypass this syntax and execute our decorator manually, but that is left as an exercise for you.</p>
			<p>So, the <code>memoize()</code> decorator can be used with our recursive functions as follows:</p>
			<pre>@memoize 
def number_sum(n): 
    '''Returns the sum of the first n numbers''' 
    assert(n &gt;= 0), 'n must be &gt;= 0' 
    if n == 0:
        return 0
    else:
        return n + number_sum(n-1)
 
@memoize 
def fibonacci(n): 
    '''Returns the suite of Fibonacci numbers''' 
    assert(n &gt;= 0), 'n must be &gt;= 0'
    if n in (0, 1):
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)</pre>
			<p>In the <a id="_idIndexMarker1261"/>last part of the code, via the <code>main()</code> function, we show how to use the decorated functions and measure their performance. The <code>to_execute</code> variable is used to hold a list of tuples containing the reference to each function and the corresponding <code>timeit.Timer()</code> call (to execute it while measuring the time spent), thus avoiding code repetition. Note how the <code>__name__</code> and <code>__doc__</code> method attributes show the proper function names and documentation values, respectively. Try removing the <code>@functools.wraps(fn)</code> decoration from <code>memoize()</code>, and see whether this is still the case.</p>
			<p>Here is the last part of the code:</p>
			<pre>def main():
    from timeit import Timer
    to_execute = [
        (number_sum, 
         Timer('number_sum(300)', 'from __main__ import \
           number_sum')),
        (fibonacci, 
         Timer('fibonacci(100)', 'from __main__ import \
           fibonacci'))    
    ]
    
    for item in to_execute:
        fn = item[0]
        print(f'Function "{fn.__name__}": {fn.__doc__}')
        t = item[1]
        print(f'Time: {t.timeit()}')
        print()
if __name__ == '__main__': 
    main()</pre>
			<p>Let's recapitulate how <a id="_idIndexMarker1262"/>we write the complete code of our math module (the <code>mymath.py</code> file):</p>
			<ol>
				<li>After the import of Python's <code>functools</code> module that we will be using, we define the <code>memoize()</code> decorator function.</li>
				<li>Then, we define the <code>number_sum()</code> function, decorated using <code>memoize()</code>.</li>
				<li>We also define the <code>fibonacci()</code> function, as decorated.</li>
				<li>Finally, we add the <code>main()</code> function, as shown earlier, and use the usual trick to call it.</li>
			</ol>
			<p>Here is a sample output when executing the <code>python mymath.py</code> command:</p>
			<pre>Function "number_sum": Returns the sum of the first n 
numbers
Time: 0.152614356
Function "fibonacci": Returns the suite of Fibonacci 
numbers
Time: 0.142395913</pre>
			<p>(The execution times might differ in your case.)</p>
			<p>At this point, we end up with readable code and acceptable performance. Now, you might argue <a id="_idIndexMarker1263"/>that this is not the decorator pattern, since we don't apply it at runtime. The truth is that a decorated function cannot be undecorated, but you can still decide at runtime whether the decorator will be executed or not. That's an interesting exercise left for you.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Use a decorator that acts as a wrapper, which decides whether or not the real decorator is executed based on some condition.</p>
			<p>Another interesting property of decorators not covered in this chapter is that you can decorate a function with more than one decorator. So, here's another exercise: create a decorator that helps you to debug recursive functions, apply it to <code>number_sum()</code> and <code>fibonacci()</code>, and finally, determine the order in which the multiple decorators are executed.</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor323"/>Summary</h1>
			<p>This chapter covered the decorator pattern and its relationship to the Python programming language. We used the decorator pattern conveniently to extend the behavior of an object without using inheritance. Python, with its built-in decorator feature, extends the decorator concept even more, by allowing us to extend the behavior of any callable (function, method, or class) without using inheritance or composition.</p>
			<p>We have seen a few examples of real-world objects that are decorated, such as cameras. From a software point of view, both Django and Pyramid use decorators to achieve different goals, such as controlling HTTP compression and caching.</p>
			<p>The decorator pattern is a great solution for implementing cross-cutting concerns because they are generic and do not fit well into the OOP paradigm. We mentioned several categories of cross-cutting concerns in the <em class="italic">Use cases</em> section. In fact, in the <em class="italic">Implementation</em> section, a cross-cutting concern was demonstrated: memoization. We saw how decorators can help us to keep our functions clean, without sacrificing performance.</p>
			<p>The next chapter covers the bridge pattern.</p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor324"/>Questions</h1>
			<ol>
				<li value="1">What is the main motivation for the decorator pattern?</li>
				<li>Why is the decorator pattern particularly relevant in Python?</li>
				<li>How does the decorator pattern help with memoization?</li>
			</ol>
		</div>
	</div>
</div>
</body></html>