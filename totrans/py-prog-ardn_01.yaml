- en: Chapter 1. Getting Started with Python and Arduino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the Python programming language and the open source
    electronic prototyping platform Arduino. The first section of the chapter focuses
    on Python and briefly describes the benefits of Python along with installation
    and configuration steps. The remaining part of the chapter describes Arduino and
    Arduino's development environment.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you will have configured a programming environment
    for both Python and Arduino for your favorite operating system. If you are a beginner
    with either or both platforms (that is, Python and Arduino), it is advisable that
    you follow the given steps in this chapter, as the later chapters will assume
    that you have the exact configuration described here. If you have previous experience
    of working with these platforms, you can skip to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since its introduction by Guido van Rossum in 1991, Python has grown into one
    of the most widely used general-purpose, high-level programming languages, and
    is supported by one of the largest open source developer communities. Python is
    an open source programming language that includes a lot of supporting libraries.
    These libraries are the best feature of Python, making it one of the most extensible
    platforms. Python is a dynamic programming language, and it uses an interpreter
    to execute code at runtime rather than using a compiler to compile and create
    executable byte codes.
  prefs: []
  type: TYPE_NORMAL
- en: The philosophy behind the development of Python was to create flexible, readable,
    and clear code to easily express concepts. The emphasis on using whitespace indentation
    in a unique way differentiates Python from other popular high-level languages.
    Python supports functional, imperative, and object-oriented programming with automatic
    memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Why we use Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python is considered to be one of the easiest languages to learn for first-time
    programmers. Compared to other popular object-oriented languages such as C++ and
    Java, Python has the following major benefits for programmers:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to read and understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables rapid prototyping and reduces development time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a humongous amount of free library packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has a huge open source community that drives forth the effort for continuous
    improvement of Python as a programming language. The Python community is also
    responsible for the development of a large amount of open library packages, which
    can be used to build applications that span from dynamic websites to complex data
    analysis applications, as well as the development of simple GUI-based applications
    to plot charts from complex math functions. The majority of Python library packages
    have systematically maintained the code that was obtained from the community with
    regular updates. The de facto repository that indexes the largest number of Python
    packages is PyPI ([http://pypi.python.org](http://pypi.python.org)). PyPI also
    provides simple ways to install various packages on your operating system, which
    will be covered in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: While working with the hardware platform, it is necessary to have some means
    of communication between the hardware and the computer that you are using for
    development. Among the common computer to hardware interfacing methods, serial-
    port-based communication is the most popular, and it is really simple to establish,
    especially for the Arduino platform. Python provides a library called `pySerial`
    that is really easy to use and quick to implement to interface a serial port.
    It is really simple to use similar libraries and Python's interactive programming
    abilities to rapidly test and implement your project ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, complex **Internet of Things** (**IoT**) applications not only require
    serial communication support, but they also need additional high-level features
    such as **graphical user interfaces** (**GUIs**) for operating systems, web interfaces
    for remote access, plots for data visualization, tools for data analysis, interfaces
    for data storage, and so on. Using any other programming language such as C++
    or Java, the development of these features would require a large amount of programming
    effort due to the distributed and unorganized nature of the supporting tools.
    Thankfully, Python has been very successful at providing support for these types
    of applications for years. Python has a number of libraries to support the development
    of each of the features mentioned here, which are available through PyPI. These
    libraries are open source, easy to use, and widely supported by the community.
    This makes Python a language of choice for IoT applications. Additionally, Python
    also has support to create and ship your custom-built applications as libraries
    so that everyone else can also utilize them in their projects. This is a helpful
    feature if you are developing custom protocols, APIs, or algorithms for your own
    hardware products.
  prefs: []
  type: TYPE_NORMAL
- en: When do we use other languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, when should we not use Python for our projects? As mentioned earlier, Python
    is a dynamic language that reduces development time, but it also makes the execution
    of your code slower as compared to other static high-level languages such as C,
    C++, and Java. These static languages use a compiler to compile the code and create
    binaries that get executed during runtime, thereby increasing the runtime performance.
    When the performance of the code is more important than a longer development time
    and higher cost, you should consider these static languages. Some other drawbacks
    of Python include being memory heavy, not having the proper support for threading,
    and lacking data protection features. In short, we can say that even though Python
    provides quicker and easier ways for quick prototyping, we should consider other
    static high-level languages for development after we are done testing our prototype
    and we are ready to ship our product. Nowadays, this scenario is changing rapidly
    and companies have started utilizing Python for their industrial products.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can obtain more Python-related information from the official website at
    [http://www.python.org](http://www.python.org).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python and Setuptools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python comes in two versions: Python v2.x and Python v3.x. (Here, x represents
    an appropriate version number.) While Python v2.x is a legacy branch and has better
    library support, Python v3.x is the future of Python. Most Linux distributions
    and Mac OS X operating systems are equipped with Python, and they have v2.x as
    their preferred and default version of Python. We will be using Python v2.7 as
    the default version of Python for the rest of the book due to the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It is the most current version of the Python v2.x branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has large community support and solutions for its known issues are available
    through support forums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is supported by most of the major Python libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though the code samples, exercises, and projects provided in this book
    should work in any variant of Python 2.7.x, it's better to have the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your fondness for an operating system is developed due to multiple factors,
    and you can never ignore someone''s bias towards a particular OS. Thus, this book
    provides installation and configuration guidelines for three of the most popular
    operating systems: Linux, Mac OS X, and Windows. Let''s begin by configuring Python
    for a Linux computer.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The majority of Linux distributions come with Python preinstalled. To check
    the latest version of the installed Python, use the following command at the terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you are using an uppercase `V` as the option for the previous
    command. Once you execute it on the terminal, it will print the complete version
    number of your current Python installation. If the version is 2.7.x, you are good
    to go and your Linux is updated with the latest version of Python that is required
    for this book. However, if you have any version that is less than or equal to
    2.6.x, you will need to first upgrade Python to the latest version. This process
    will require root privileges, as Python will be installed as a system component
    that will replace the previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are using Ubuntu 11.10 or later versions, you should already have Python
    v2.7.x installed on your machine. You can still upgrade Python to the latest revision
    of v2.7.x using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running an older version of Ubuntu (such as 10.04 or older), you
    should have 2.6 as the default version. In this case, you will need to run the
    following set of commands to install version 2.7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first command will add an external Ubuntu repository, which will allow you
    to install any version of Python. The next command will update and index the list
    of available packages. The last command will install the latest version of Python
    2.7.
  prefs: []
  type: TYPE_NORMAL
- en: Fedora and Red Hat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fedora and Red Hat Linux also ships with Python as an in-built package. If
    you want to upgrade the version of Python to the latest one, run the following
    command at the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installation and configuration of Python on Windows is not as straightforward
    as it is for Linux. First of all, you'll need to download a copy of Python from
    [http://www.python.org/getit](http://www.python.org/getit).
  prefs: []
  type: TYPE_NORMAL
- en: You need to be careful about the version of Python that you are downloading.
    From the system properties of your Windows OS, check whether the operating system
    is of 32 bit or 64 bit. At the time this book was being written, the latest version
    of Python was 2.7.6\. So, download the latest available version of Python, but
    make sure that it is 2.7.x and not 3.x.
  prefs: []
  type: TYPE_NORMAL
- en: For many third-party Python libraries, the installation binary files for Windows
    are compiled for the 32-bit version. Due to this reason, we will recommend that
    you install the 32-bit version of Python for your Windows OS.
  prefs: []
  type: TYPE_NORMAL
- en: If you are really familiar with Python and know your way around installing libraries,
    you can install the 64-bit version of Python. Select and run the downloaded file
    to install Python. Although you can install it to any custom location, it is advisable
    to use the default installation location as the upcoming configuration steps use
    the default location. Once the installation is complete, you can find the Python
    command-line tool and IDLE (Python GUI) from the **Start** menu.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can always open these tools from the **Start** menu for basic scripting,
    we will modify the Windows system parameters to make Python accessible through
    the Windows command prompt. To accomplish this, we will have to set up `PATH`
    in environment variables for the location of the Python installation directory.
    Let's open **System Properties** by right-clicking on **My Computer** and then
    selecting **Properties**. Otherwise, you can also navigate to **Start** | **Control
    Panel** | **System and Security** | **System**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be able to see a window similar to the one that is displayed in the
    following screenshot. The **System** window shows you the basic information about
    your computer, including the type of Windows operating system that you are using
    (such as the 32-bit or the 64-bit version):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows](img/5938OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the **System** window, click on **Advanced system settings** in the left
    navigation bar to open a window called **System Properties**. Click on the **Environment
    Variables…** button in the **System Properties** window, which is located at the
    bottom of the window. This will open an interface similar to the one shown in
    the following screenshot. In **Environment Variables**, you need to update the
    **PATH** system variable to add Python to the default operating system's path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **PATH** option as displayed in the following screenshot, which
    will pop up an **Edit System Variable** window. Add `C:\Python27` or the full
    path of your custom Python installation directory at the end of your existing
    **PATH** variable. It is required to put a semicolon (`;`) before the Python installation
    path. If you already see Python''s location in the **Path** variable, your system
    is set up for Python and you don''t need to perform any changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows](img/5938OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The main benefit of adding Python to the environment variables is to enable
    access to the Python interpreter from the command prompt. In case you don't know,
    the Windows command prompt can be accessed by navigating to **Start** | **Programs**
    | **Accessories** | **Command Prompt**.
  prefs: []
  type: TYPE_NORMAL
- en: Mac OS X
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mac OS X ships with a preinstalled copy of Python, but due to the long release
    cycle of the operating system, the frequency of updates for the default Python
    application is slow. The latest version of Mac OS X, which is 10.9 Maverick, comes
    equipped with Python 2.7.5, which is the latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Previous versions such as Mac OS X 10.8 Mountain Lion and Mac OS X 10.7 Lion
    included Python 2.7.2 and Python 2.7.1 respectively, which are also compatible
    versions for this book. If you are an experienced Python user or someone who wants
    to work with the latest version of Python, you can download the latest version
    from [http://www.python.org/getit](http://www.python.org/getit).
  prefs: []
  type: TYPE_NORMAL
- en: Older versions of Mac OS X such as Snow Leopard and later, which came with an
    older version of Python, can be updated to the latest version by downloading and
    installing it from [http://www.python.org/getit](http://www.python.org/getit).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Setuptools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setuptools is a library containing a collection of utilities for building and
    distributing Python packages. The most important tool from this collection is
    called `easy_install`. It allows a user to look into PyPI, the Python package
    repository that we mentioned previously, and provides a simple interface to install
    any package by name. The `easy_install` utility automatically downloads, builds,
    installs, and manages packages for the user. This utility has been used in the
    later part of this book to install the necessary packages required for the upcoming
    projects of Python and Arduino. Although `easy_install` has been used as a simple
    way of installing Python packages, it misses out on a few useful features such
    as tracking actions, support for uninstallation, and support for other version
    control systems. In recent years, the Python community has started adopting another
    tool called `pip` over `easy_install` that supports these features. As both `easy_install`
    and `pip` utilize the same PyPI repository, going forward, you can use any of
    these utilities to install the required Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: Just to narrow down the scope, we will be focusing on methods to install Setuptools
    and the default utilities that get installed with it, that is, `easy_install`.
    Later in this section, we will also install `pip`, just in case you want to use
    it too. Let's first begin by installing Setuptools for the various operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Ubuntu, Setuptools is available in the default repository and it can be
    installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For Fedora, it can be installed using the default software manager `yum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For other Linux distributions, it can be downloaded and built using the following
    single-line script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once it is installed on your Linux distribution, `easy_install` can be directly
    accessed from the terminal as a built-in command.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installation of Setuptools is not that straightforward for Windows as compared
    to Linux. It requires the user to download the `ez_setup.py` file from the Windows
    section at [https://pypi.python.org/pypi/setuptools](https://pypi.python.org/pypi/setuptools).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is downloaded, press *Shift* and right-click in the folder where
    you downloaded the `ez_setup.py` file. Select **Open command window here** and
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will install Setuptools in the `Scripts` folder of your default Python
    installation folder. Using the same method that we used when we added Python to
    **Environment Variables**, now include Setuptools by adding `C:\Python27\Scripts`
    to **PATH**, followed by the semicolon (;).
  prefs: []
  type: TYPE_NORMAL
- en: This will enable the installation of various Python packages using `easy_install`
    to your Python packages folder called `Libs`. Once you have added the package
    manager to the environment variables, you need to close and reopen the command
    prompt for these changes to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: Mac OS X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setuptools can be installed in Mac OS X using any of the following methods.
    It is advisable for beginners to use the first method, as the second method requires
    the external package manager Homebrew.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have never worked with Homebrew before, you will need to follow these
    steps to install Setuptools on your Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: Download `ez_setup.py` from the Unix/Mac section at [https://pypi.python.org/pypi/setuptools](https://pypi.python.org/pypi/setuptools).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and navigate to the directory where you downloaded this file.
    For most browsers, the file gets saved to the `Download` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command in the terminal to build and set up Setuptools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are familiar with Homebrew-based software installation, just follow
    these quick steps to install Setuptools:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install `wget` from Homebrew if you don''t have it already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have installed `wget`, run the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More information regarding the Homebrew utility can be obtained from [http://brew.sh](http://brew.sh).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can install Homebrew on your Mac by running the following simple script
    in the terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing pip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have successfully installed Setuptools, let''s use it to install `pip`.
    For Linux or Mac OS X, you can run the following command in the terminal to install
    `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, open the command prompt and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have already installed `pip` on your computer, please make sure that
    you upgrade it to the latest version to overcome the few bugs that are associated
    with the upgrade. You can upgrade `pip` using the following command at the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since you have already used `easy_install` to install a Python package, let's
    get ourselves more familiar with Python package management.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the installation of `pip`, you have two different options to install any
    third-party Python package listed on the PyPi repository ([http://pypi.python.org](http://pypi.python.org)).
    The following are the various procedures that you need to know to work with the
    installation of Python packages. In the following examples, the term `PackageName`
    is a pseudo name that is used for a Python package that you want to work with.
    For your package of choice, identify the appropriate package name from the PyPi
    website and put its name in place of `PackageName`. In some cases, you will need
    root (super user) privileges to install or uninstall a package. You can use `sudo`
    followed by an appropriate command for these cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a Python package, execute the following command at the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you can also execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to install a specific version of a package, you can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not aware of the exact version number, you can also use comparison
    operators such as `>`, `<`, `>=`, or `<=` to specify a range for the version number.
    Both `easy_install` and `pip` will select the best matching version of the package
    from the repository and install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, for `pip`, you can use the following identical commands to perform
    similar operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, if you want to install a version between 1.0 and 3.0, you will
    need to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It is really easy to upgrade a package using either `easy_install` or `pip`.
    The command options used by both are also very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `easy_install` doesn''t support clean uninstallation of a package,
    you can use the following command to make sure that Python stops searching for
    the specified package. Later, carefully remove the package files from the installation
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A much better way to perform a clean uninstallation of the majority of packages
    is to use `pip` instead of `easy_install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A detailed list of the Python packages supported by Setuptools can be found
    at the PyPI website at [https://pypi.python.org/](https://pypi.python.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals of Python programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have previous experience of working with any other programming language,
    Python is very easy to get started with. If you have never done programming before,
    this section will walk you through some of the basics of Python. If you have already
    worked with Python, you should skip this section and move on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the setup instructions are followed correctly, let's open the
    Python interpreter by executing the Python command at the terminal or the command
    prompt. You should get results similar to those displayed in the following screenshot.
    If you have installed Python by downloading the setup files from the website,
    you should have the Python **integrated development environment** (**IDLE**) installed
    as well. You can also start the Python interpreter by opening its IDLE from the
    location where it was installed.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, after printing some system information, the interpreter opens
    a prompt with three greater-than signs (`>>>`), which is also known as the primary
    prompt. The interpreter is now in the interactive mode and it is ready to execute
    scripts from the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '![The fundamentals of Python programming](img/5938OS_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To close the interactive mode of the Python interpreter, run the either `exit()`
    or `quit()`, at the primary prompt. Another method to exit from the interactive
    mode is to use the keyboard shortcut *Ctrl* + *D*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that Python''s built-in functions are case sensitive. This means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: exit() ≠ EXIT() ≠ Exit()
  prefs: []
  type: TYPE_NORMAL
- en: The official Python website provides comprehensive tutorials for beginners to
    get started with Python programming. It is highly recommended that you visit the
    official Python tutorials at [https://docs.python.org/2/tutorial/index.html](https://docs.python.org/2/tutorial/index.html)
    if you are looking for detailed programming tutorials as compared to the upcoming
    brief overviews.
  prefs: []
  type: TYPE_NORMAL
- en: Python operators and built-in types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have a brief idea regarding the Python prompt, let''s get you
    familiar with some of the basic Python commands. For these exercises, we will
    be using the Python IDLE, which also opens with the Python interactive prompt.
    You will require a method to describe the code segments, tasks, and comments when
    writing large and complex code. Non-executable content is called comments in any
    programming language, and in Python, they start with the hashtag character (`#`).
    Like comments, you will be frequently required to check the output by printing
    on the prompt using the print command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of IDLE, you can also access the Python interactive prompt from the
    terminal. When using Python from the terminal, make sure that you are taking care
    of the indentation properly.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python supports the usage of basic mathematical operators such as +, -, *,
    and /, directly from the interpreter. Using these operators, you can perform basic
    calculations in the prompt, as shown in the following examples. Try these operations
    in your prompt in order to start using the Python interpreter as a calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with the Python interpreter, it is recommended that you follow
    the Style Guide for Python Code, which is also popularly known as PEP-8 or pep8\.
    For more information about PEP-8, visit [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/).
  prefs: []
  type: TYPE_NORMAL
- en: Built-in types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python is a dynamically typed language, which means that you don''t have to
    explicitly declare the type of the variables when initializing them. When you
    assign a value to a variable, the Python interpreter automatically deduces the
    data type. For example, let''s declare the following variables in the interactive
    mode of the interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'While assigning the value to the `weight` variable, we didn''t specify the
    data type, but the Python interpreter assigned it as an integer type, `int`. The
    interpreter assigned the `int` type due to the reason that the numerical value
    didn''t contain any decimal points. Let''s now declare a variable with a value
    containing a decimal point. The built-in function `type()` that can be used to
    find out the data type of a specified variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the interpreter assigns the data type as `float`. The interpreter
    can also deduce the type of complex numbers, as shown in following examples. You
    can access the real and imaginary value of a complex number using the dot (`.`)
    operator followed by `real` and `imag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to play more with complex numbers, let''s try the `abs()` and `round()`
    functions as displayed in the following examples. They are built-in Python functions
    to obtain the absolute value and the rounded number respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Like numbers, the Python interpreter can also automatically identify the declaration
    of string data types. In Python, string values are assigned using single or double
    quotes around the value. When the interpreter sees any value enclosed within quotes,
    it considers it to be a string. Python supports the usage of the `+` operator
    to concatenate strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A character type is a string of size one and the individual characters of a
    string can be accessed by using index numbers. The first character of a string
    is indexed as 0\. Play with the following scripts to understand indexing (subscripting)
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the primary prompt with default notation `>>>`, the Python interactive
    interpreter also has a secondary prompt that uses three dots (…) when it is being
    used from the terminal. You won''t be able to see the three dots in IDLE when
    you use the secondary prompt. The secondary prompt is used for a multiline construct,
    which requires continuous lines. Execute the following commands by manually typing
    them in the interpreter, and do not forget to indent the next line after the `if`
    statement with a tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Data structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python supports four main data structures (`list`, `tuple`, `set`, and `dictionary`)
    and there are a number of important built-in methods around these data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lists are used to group together values of single or multiple data types. The
    `list` structure can be assigned by stating values in square brackets with a comma
    (,) as a separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Like strings, values in a list can be accessed using index numbers, which starts
    from 0\. A feature called **slicing** is used by Python to obtain a specific subset
    or element of the data structure using the colon operator. In a standard format,
    slicing can be specified using the `myList[start:end:increment]` notation. Here
    are a few examples to better understand the notion of slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access a single element in a list as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can access all the elements in the list by having empty start and end values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can provide start and end index values to obtain a specific subset of the
    list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use of the minus symbol with an index number tells the interpreter to use that
    index number backwards. In the following example, `-1` backwards actually represents
    the index number `5`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can obtain every other element of the list by providing the increment value
    with start and end values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can check the length of a list variable using the `len()` method. The usage
    of this method will be handy in the upcoming projects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also perform various operations to add or delete elements in the existing
    list. For example, if you want to add an element at the end of the list, use the
    `append()` method on the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add an element at a specific location, you can use the `insert(i, x)` method,
    where `i` denotes the index value, while `x` is the actual value that you want
    to add to the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, you can use `pop()` to remove an element from the list. A simple
    `pop()` function will remove the last element of the list, while an element at
    a specific location can be removed using `pop(i)`, where `i` is the index number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tuples are immutable data structures supported by Python (different from the
    mutable structures of lists). An immutable data structure means that you cannot
    add or remove elements from the tuple data structure. Due to their immutable properties,
    tuples are faster to access compared to lists and are mostly used to store a constant
    set of values that never change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tuple` data structure is declared like `list`, but by using parentheses
    or without any brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in a `list` data structure, values in `tuple` can be accessed using
    index numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As tuples are immutable, list manipulation methods such as `append()`, `insert()`,
    and `pop()` don't apply for tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `set` data structure in Python is implemented to support mathematical set
    operations. The `set` data structure includes an unordered collection of elements
    without duplicates. With its mathematical use cases, this data structure is mostly
    used to find duplicates in lists, as conversion of a list to a set using the `set()`
    function removes duplicates from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `dict` data structure is used to store key-value pairs indexed by keys,
    which are also known in other languages as associative arrays, hashes, or hashmaps.
    Unlike other data structures, `dict` values can be extracted using associated
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about Python data structures and associated methods at [https://docs.python.org/2/tutorial/datastructures.html](https://docs.python.org/2/tutorial/datastructures.html).
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the flow of your program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like any other language, Python supports controlling the program flow using
    compound statements. In this section, we will briefly introduce these statements
    to you. You can get detailed information about them from the official Python documentation
    at [https://docs.python.org/2/reference/compound_stmts.html](https://docs.python.org/2/reference/compound_stmts.html).
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if` statement is the most basic and standard statement used to set up
    conditional flow. To better understand the `if` statement, execute the following
    code in the Python interpreter with different values of the `age` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This will result in `Teen` being printed on the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: The for statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python''s `for` statement iterates over the elements of any sequence according
    to the order of the elements in that sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the Python interpreter generating the following output
    that will display the calculated Fahrenheit values from the given Celsius values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The while statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` statement is used to create a continuous loop in a Python program.
    A `while` loop keeps iterating over the code block until the condition is proved
    true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `while` statement will keep iterating and printing the value of the variable
    count and also reduce its value by 1 until the condition, that is (`count > 0`),
    becomes true. As soon as the value of `count` is lower than or equal to 0, the
    `while` loop will exit the code block and stop iterating.
  prefs: []
  type: TYPE_NORMAL
- en: The other compound statements supported by Python are `try/catch` and `with`.
    These statements will be explained in detail in the upcoming chapters. Python
    also provides loop control statements such as `break`, `continue`, and `pass`
    that can be used while a loop is being executed using the compound statements
    mentioned earlier. You can learn more about these Python features from [https://docs.python.org/2/tutorial/controlflow.html](https://docs.python.org/2/tutorial/controlflow.html).
  prefs: []
  type: TYPE_NORMAL
- en: Built-in functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python supports a number of useful built-in functions that do not require any
    external libraries to be imported. We have described a few of these functions
    as a collection of a respective category, according to their functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conversion methods such as `int()`, `float()`, and `str()` can convert other
    data types into integer, float, or string data types respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, `list()`, `set()`, and `tuple()` can be used to convert one data
    structure into another.
  prefs: []
  type: TYPE_NORMAL
- en: Math operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python also supports built-in mathematical functions that can find the minimum
    and/or maximum values from a list. Check out the following examples and play around
    with the different data structures to understand these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pow(x,y)` function returns the value of `x` to the power of `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: String operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python provides easy access to string manipulation through built-in functions
    that are optimized for performance. Let''s take a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code to replace occurrences of a string or substring with a different one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code to split a string with a separating character where the default character
    is space:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code to split a string from a separating character for any other character:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code to convert an entire string value into uppercase or lowercase:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python documentation on the official website covers every built-in function
    in detail with examples. For better understanding of Python programming, visit
    [https://docs.python.org/2/library/functions.html](https://docs.python.org/2/library/functions.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Introduction to Arduino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any electronic product that needs computation or interfacing with other computers
    first requires a quick prototyping of the concept using simple tools. Arduino
    is an open source hardware prototyping platform designed around a popular microcontroller
    family, and it includes a simple software development environment. Besides prototyping,
    you can also use Arduino for the development of your own **do-it-yourself** (**DIY**)
    projects. Arduino bridges the computational world with the physical world by letting
    you simply connect the sensors and actuators with a computer. Basically, you can
    write code to monitor and control various electronic components in your daily
    life by using Arduino's input/output pins and microcontroller. Examples of these
    components include motors, thermostats, lights, switches, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: History
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2005, Massimo Banzi, the Italian cofounder of Arduino, developed the technology
    for his students at **Interaction Design Institute Ivrea** (**IDII**). Since then,
    Arduino has developed into one of the largest open source hardware platforms.
    All software components and schematics of the Arduino design are open source,
    and you can buy the hardware at a very low cost—approximately 30 dollars—or you
    can even make it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Why Arduino?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The major goal of the Arduino community is to continuously improve the Arduino
    platform with the following objectives in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino platform should be an affordable platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be easy to use and easy to code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be an open source and extensible software platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be an open source and extensible hardware platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should have community-supported DIY projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These simple but powerful objectives have made Arduino a popular and widely
    used prototyping platform. Arduino uses Atmel''s ATmega series of microcontrollers
    that are based on the popular hardware architecture of AVR. The huge support that
    is available for AVR architecture also makes Arduino a hardware platform of choice.
    The following image shows the basic version of the Arduino board, which is called
    Arduino Uno (Uno means one in Italian):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why Arduino?](img/5938OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Arduino variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like any other project, hardware requirements are driven by project specifications.
    If you are developing a project that requires you to interface with a large number
    of external components, you need a prototyping platform that has a sufficient
    number of **input/output** (**I/O**) pins for interfacing. If you are working
    on a project that needs to perform a huge amount of complex calculations, you
    require a platform with more computation capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the Arduino board exists in 16 different official versions, and
    each version of Arduino differs from the others in terms of form factor, computational
    power, I/O pins, and other on-board features. Arduino Uno is the basic and most
    popular version, which is sufficient enough for simple DIY projects. For the majority
    of exercises in this book, we will be using the Arduino Uno board. You can also
    use another popular variant called Arduino Mega, which is a larger board with
    extra pins and a powerful microcontroller. The following table shows the comparison
    of some of the more popular and active variants of the Arduino board:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Processor | Processor frequency | Digital I/O | Digital I/O with PWM
    | Analog I/O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino Uno | ATmega328 | 16 MHz | 14 | 6 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino Leonardo | ATmega32u4 | 16 MHz | 14 | 6 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino Mega | ATmega2560 | 16 MHz | 54 | 14 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino Nano | ATmega328 | 16 MHz | 14 | 6 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino Due | AT91SAM3X8E | 84 MHz | 54 | 12 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| LilyPad Arduino | ATmega168v or ATmega328v | 8 MHz | 14 | 6 | 6 |'
  prefs: []
  type: TYPE_TB
- en: Any of these variants can be programmed using a common integrated development
    environment called **Arduino IDE**, which is described in the upcoming section.
    You can select any one of these Arduino boards according to your project requirements,
    and the Arduino IDE should be able to compile and download the program to the
    board.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino Uno board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As Uno is going to be the de facto board for the majority of the projects in
    this book, let's get ourselves familiar with the board. The latest revision of
    the Uno board is based on Atmel's ATmega328 microcontroller. The board extends
    the I/O pins of the microcontroller to the peripheral, which can then be utilized
    to interface components using wires. The board has a total of 20 pins to interface,
    out of which 14 are digital I/O pins and 6 are analog input pins. From the 14
    digital I/O pins, 6 pins also support **pulse-width modulation** (**PWM**), which
    supports the controlled delivery of power to connected components.
  prefs: []
  type: TYPE_NORMAL
- en: The board operates on 5V. The maximum current rating of the digital I/O pins
    is 40 mA, which is sufficient to drive most of the DIY electronic components,
    excluding motors with high current requirements.
  prefs: []
  type: TYPE_NORMAL
- en: While the previous image provided an overview of the Uno board, the following
    diagram describes the pins on the Uno board. As you can see, the digital pins
    are located on one side of the board while the analog pins are on the opposite
    side. The board also has a couple of power pins that can be used to provide 5V
    and 3.3V of power to external components. The board contains ground pins on both
    sides of the board as well. We will be extensively using 5V of power and ground
    pins for our projects. Digital pins **D0** and **D1** support serial interfacing
    through the **Tx** (**transmission**) and **Rx** (**receiver**) interfaces respectively.
    The USB port on the board can be used to connect Arduino with a computer.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Arduino Uno board](img/5938OS_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we are familiar with the Arduino hardware, let's move on to programming
    the Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Arduino IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to start getting familiar with Arduino is to install the Arduino
    **integrated development environment** (**IDE**). According to the operating system
    that you selected at the beginning of the Python installation section, follow
    the appropriate subsection to install the correct IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The installation of the Arduino IDE is really simple in Ubuntu. The Ubuntu repository
    already includes the Arduino IDE with the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Ubuntu 12.04 or a newer version, execute the following command in the terminal
    to install Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The latest version of the Arduino IDE in the Ubuntu repository is 1.0.3\. You
    can obtain more information regarding other Ubuntu-related questions at [http://playground.arduino.cc/Linux/Ubuntu](http://playground.arduino.cc/Linux/Ubuntu).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Fedora 17 or a newer version of Red Hat Linux, execute the following script
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Answers to additional installation questions for Fedora can be obtained at [http://playground.arduino.cc/Linux/Fedora](http://playground.arduino.cc/Linux/Fedora).
  prefs: []
  type: TYPE_NORMAL
- en: Mac OS X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install the Arduino IDE on Mac OS X (10.7 or newer), perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From [http://arduino.cc/en/Main/Software](http://arduino.cc/en/Main/Software),
    download the latest version of the Arduino IDE for Mac OS X, which was 1.0.5 when
    this book was being written.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip and drag Arduino to the application folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Arduino IDE is built in Java and requires that your computer is equipped
    with the appropriate version of Java. Open the IDE from your applications. If
    you don't have Java installed on your Mac, the program will prompt you with a
    pop-up window and ask you to install Java SE 6 runtime. Go ahead and install Java
    (as per the request) as the OS X will automatically install it for you.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installation of Arduino for Windows is very simple. Download the setup file
    from [http://arduino.cc/en/Main/Software](http://arduino.cc/en/Main/Software).
    Select the most recent version of the Arduino IDE, that is, 1.0.x or a newer version.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you download the appropriate version of the Arduino IDE according
    to your operating system, that is, 32 bit or 64 bit. Install the IDE to the default
    location as specified in the installation wizard. Once installed, you can open
    the IDE by navigating to **Start** | **Programs**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the Arduino IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Arduino IDE is a cross-platform application developed in Java that can
    be used to develop, compile, and upload programs to the Arduino board. On launching
    the Arduino IDE, you will find an interface similar to the one displayed in the
    following screenshot. The IDE contains a text editor for coding, a menu bar to
    access the IDE components, a toolbar to easily access the most common functions,
    and a text console to check the compiler outputs. A status bar at the bottom shows
    the selected Arduino board and the port name that it is connected to, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with the Arduino IDE](img/5938OS_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What is an Arduino sketch?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Arduino program that is developed using the IDE is called a **sketch**. Sketches
    are coded in Arduino language, which is based on a custom version of C/C++. Once
    you are done with writing the code in the built-in text editor, you can save it
    using the`.ino` extension. When you save these sketch files, the IDE automatically
    creates a folder to store them. If you are using any other supporting files for
    a sketch, such as header files or library files, they are all stored at this location
    (which is also called a **sketchbook**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To open a new sketchbook, open the Arduino IDE and select **New** from the
    **File** menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is an Arduino sketch?](img/5938OS_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will be prompted with an empty text editor. The text editor supports standard
    features (that is, copy/paste, select, find/replace, and so on). Before we go
    ahead with an Arduino program, let's explore the other tools provided by the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino IDE version prior to 1.0 used the `.pde` extension to save sketchbooks.
    Starting from 1.0, they are saved with the `.ino` extension. You can still open
    files with the `.pde` extension in the latest IDE. Later, the IDE will convert
    it to the `.ino` extension when you save them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Arduino IDE uses libraries to extend the functionalities of existing sketches.
    Libraries are a set of functions combined to perform tasks around a specific component
    or concept. The majority of the built-in Arduino libraries provide methods to
    start working with external hardware components. You can import any library by
    navigating to **Sketch** | **Import Library…**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with libraries](img/5938OS_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also use a library for your sketch by just specifying the library with
    the `#include` statement at the beginning of the sketch, that is, `#include <Wire.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IDE also provides the capability to add an external library that
    supports a specific hardware or provides additional features. In the upcoming
    chapters, we will be dealing with some of these external libraries, and we will
    go through the process of importing them at that time.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about built-in Arduino libraries from [http://arduino.cc/en/Reference/Libraries](http://arduino.cc/en/Reference/Libraries).
  prefs: []
  type: TYPE_NORMAL
- en: Using Arduino examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Arduino IDE contains a large number of built-in example sketches. These
    examples are designed to get the user familiar with basic Arduino concepts and
    built-in Arduino libraries. The examples are well maintained by the Arduino community
    since they have comprehensive support for each example through the Arduino website
    ([http://arduino.cc/en/Tutorial/HomePage](http://arduino.cc/en/Tutorial/HomePage)).
    In the Arduino IDE, you can access these examples by navigating to **File** |
    **Examples**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Arduino examples](img/5938OS_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with a simple in-built example. Open the **Blink** example by
    navigating to **File** | **Examples** | **01.Basics** | **Blink**. The IDE will
    open a new window containing code that is similar to the code in the following
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This Arduino sketch is designed to blink an LED on digital pin 13\. You must
    be wondering why we didn't discuss or ask you to bring any hardware. That's because
    the Arduino Uno board is equipped with an on-board LED that is connected to digital
    pin 13\. Now, instead of diving deeper into the Arduino code, we are going to
    focus on the process of dealing with the Arduino board through the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and uploading sketches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have your code opened in the IDE, the first thing you need to do is
    to select the type of Arduino board on which you are going to upload your sketch.
    The Arduino IDE needs to know the type of board in order to compile the program
    for the appropriate microcontroller, as different Arduino boards can have different
    Atmel microcontrollers. Therefore, you need to perform this step before you go
    ahead with the compiling or uploading of the program to the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can select the Arduino board by navigating to **Tools** | **Board**, as
    displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling and uploading sketches](img/5938OS_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select Arduino Uno from the list of boards, unless you are using a different
    Arduino board. Once you have selected the board, you can go ahead and compile
    the sketch. You can compile the sketch by navigating to **Sketch** | **Verify
    / Compile** from the menu bar or by using the keyboard shortcut *Ctrl* + *R*.
    If everything is set up well, you should be able to compile the code without any
    error.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully compiling the sketch, it is time to upload the compiled code
    to the Arduino board. To do this, you need to make sure that your Arduino IDE
    is properly connected to your computer. If it is not already connected, connect
    your Arduino board to your computer using a USB port. Now, it is time to let your
    IDE know the serial port on which the board is connected. Navigate to **Tools**
    | **Serial Ports** and select the appropriate serial port.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the case of some Linux distributions, you may not be able to see or upload
    the Arduino program to the board due to permission restriction(s) on the serial
    port. Running the following command on the terminal should solve that problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You can now upload the compiled sketch to your Arduino board by navigating to
    **File** | **Upload**. This process will use the serial connection to burn the
    compiled firmware in the microcontroller. Please wait for some time or until the
    LEDs (Tx and Rx LEDs) on the board stop flashing. Now, you have your Arduino board
    ready with your first sketch. You can observe the performance of the blinking
    LED near digital pin 13.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Serial Monitor window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous process, we used a **Universal Serial Bus (USB)** cable to connect
    your Arduino board to a USB port of your computer. The USB port is an industrial
    standard to provide an interface for connecting various electronic components
    to a computer using the serial interface. When you connect an Arduino board using
    USB, the computer actually interfaces it as a serial peripheral device. Throughout
    the book, we are going to refer to the connections made using a USB as serial
    connections. The **Serial Monitor** window is a built-in utility of the Arduino
    IDE. The **Serial Monitor** window can be accessed by navigating to **Tools**
    | **Serial Monitor** or by using the *Ctrl* + *Shift* + *M* keyboard shortcut.
    It can be configured to observe data that is being sent or received on the serial
    port that is used to connect the Arduino board to the computer. You can also set
    the baud rate for the serial communication using the drop-down menu option. This
    utility is going to be very useful (further on in the book) when testing your
    prototypes and their performances.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Arduino programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arduino platform was introduced to simplify electronic hardware prototyping
    for everyone. For this reason, Arduino programming was intended to be easy to
    learn by nonprogrammers such as designers, artists, and students. The Arduino
    language is implemented in C/C++, while the fundamentals of the sketch and program
    structures are derived from an open source programming language called **Processing**
    and an open source electronic prototyping language called **Wiring**.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arduino follows a commenting format that is adopted from C and it is similar
    to higher-level languages; however, it is different from the Python comment format
    that we learned earlier in this chapter. There are various methods of commenting,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block comment**: This is done by covering the commented text between `/*`
    and `*/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Single-line or inline comment**: This is done by using `//` before the line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Usually, a block comment at the beginning of the sketch is mostly used to describe
    the program as a whole. Single-line comments are used to describe specific functions
    or to-do notes, such as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like any other high-level language, a variable is used to store data with three
    components: a name, a value, and a type. For example, consider the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, `pin` is the variable name that is defined with the type `int` and holds
    the value `10`. Later in the code, all occurrences of the `pin` variable will
    retrieve data from the declaration that we just made here. You can use any combination
    of alpha-numeric characters to select the variable name as long as the first character
    is not a number.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Arduino language, constants are predefined variables that are used to
    simplify the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HIGH, LOW`: While working with digital pins on the Arduino board, only two
    distinct voltage stages are possible at these pins. If a pin is being used to
    obtain an input, any measure above 3V is considered a `HIGH` state. If you are
    using a pin for output, then the `HIGH` state will set the pin voltage to 5V.
    The opposite voltage levels are considered as `LOW` states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false, true`: These are used to represent logical true and false levels. `false`
    is defined as `0` and `true` is mostly defined as `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INPUT, OUTPUT`: These constants are used to define the roles of the Arduino
    pins. If you set the mode of an Arduino pin as `INPUT`, the Arduino program will
    prepare the pin to read sensors. Similarly, the `OUTPUT` setting prepares the
    pins to provide a sufficient amount of current to the connected sensors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will utilize these constants later in the book and we will also explain them
    with example code.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The declaration of each custom variable requires the user to specify the data
    type that is associated with the variable. The Arduino language uses a standard
    set of data types that are used in the C language. A list of these data types
    and their descriptions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void`: This is used in the function declaration to indicate that the function
    is not going to return any value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`boolean`: Variables defined with the data type `boolean` can only hold one
    of two values, `true` or `false`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`byte`: This is used to store an 8-bit unsigned number, which is basically
    any number from 0 to 255:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`int`: This is short for integers. It stores 16-bit (Arduino Uno) or 32-bit
    (Arduino Due) numbers and it is one of the primary number storage data types for
    the Arduino language. Although `int` will be used to declare numbers throughout
    the book, the Arduino language also has `long` and `short` number data types for
    special cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`float`: This data type is used for numbers with decimal points. These are
    also known as floating-point numbers. `float` is one of the more widely used data
    types along with `int` to represent numbers in the Arduino language:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`char`: This data type stores a character value and occupies 1 byte of memory.
    When providing a value to `char` data types, character literals are declared with
    single quotes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`array`: An `array` stores a collection of variables that is accessible by
    an index number. If you are familiar with arrays in C/C++, it will be easier for
    you to get started, as the Arduino language uses the same C/C++ arrays. The following
    are some of the methods to initialize an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An array can be accessed using an index number (where the index starts from
    number 0):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conversion functions are used to convert any data type value into the provided
    data types. The Arduino language implements the following conversion functions
    that can be utilized during programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '`char()`: This converts the value of any data type to the character data type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte()`: This converts the value of any data type to the byte data type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int()`: This converts the value of any data type to the integer data type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float()`: This converts the value of any data type to the floating-point number
    data type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a demonstration of using these functions, check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of the preceding code will create a floating-point variable,
    `myFloat`, with value `10.0` using the integer value initialized by the `myInt`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions, also called **subroutines** or **procedures**, are a piece of code
    implemented to do specific tasks. The Arduino language has some predefined functions
    and the user can also write custom functions to implement certain program logic.
    These custom functions can then be called from any part of the sketch to perform
    a specific task. Functions help programmers to simplify debugging, to reduce chances
    for error, and to organize coding concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The Arduino language has a set of library functions to simplify the programming
    experience. Although not all of these library functions are required by an Arduino
    sketch, `setup()` and `loop()` are mandatory functions and they are required to
    successfully compile the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: The setup() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When Arduino runs a sketch, it first looks for the `setup()` function. The
    `setup()` function is used to execute important programming subroutines before
    the rest of the program, such as declaring constants, setting up pins, initializing
    serial communication, or initializing external libraries. When Arduino runs the
    program, it executes the `setup()` functions only once. If you check out the **Blink**
    sketch that we used in the previous section, you can see the initialization of
    the `setup()` function, as displayed in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in our example, we used the `pinMode()` function to assign the
    role of the LED pin in the `setup()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The loop() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once Arduino has executed the `setup()` function, it starts iterating the `loop()`
    function continuously. While `setup()` contains the initialization parameters,
    `loop()` contains the logical parameters of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code snippet from the **Blink** sketch, the
    `loop()` function executes the main code that blinks the LED and repeats the process
    iteratively.
  prefs: []
  type: TYPE_NORMAL
- en: The pinMode() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pinMode()` function is used to set the behavior of Arduino. As we saw
    in the `setup()` function of the **Blink** sketch, the `pinMode()` function configures
    the LED pin for `OUTPUT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `led` variable is assigned to digital pin 13, whose mode will be changed
    by the `pinMode()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Working with pins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you are done configuring the pins that will be used by your program, you
    also need help in reading the input from these pins or for sending signals to
    them. Arduino provides a few specific functions to handle these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '`digitalWrite()`: This was developed for digital I/O pins. This function sets
    the pin to `HIGH` (5V) or `LOW` (0V), which are already configured as `OUTPUT`
    using `pinMode()`. For example, the following line of code sets digital pin 13
    to `HIGH`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`digitalRead()`: Similar to `digitalWrite()`, this function helps you to read
    the state of a digital pin that is configured as `INPUT`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`analogRead()`: This function reads the value from a specific analog pin. The
    value is linearly mapped between the integer value of 0 and 1023 to represent
    the voltage from 0V to 5V:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`analogWrite()`: This function is used to provide analog output results at
    a digital pin. The technique is called PWM, and this will be explained in [Chapter
    4](ch04.html "Chapter 4. Diving into Python-Arduino Prototyping"), *Diving into
    Python-Arduino Prototyping*. It is still important to note that this function
    is not designed for all digital pins, but it is only for pins that are designated
    as PWM pins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are familiar with any other object-oriented programming language, you
    must have used statements extensively for your programs. The Arduino language
    uses traditional C/C++ statements such as `if/else`, `while`, `switch/case`, and
    `for` to control the flow of your program. Instead of diving deep into these statements
    right now, they are described later in the book with practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright! You have successfully completed the comparatively mundane tasks of
    installing and configuring Python and the Arduino IDE. Your system, whether it
    is a Mac OS X, Linux, or Windows system, is now ready for the upcoming chapters.
    In this chapter, we went through the history and building blocks of Arduino. We
    also learned the basics of Python programming and the Arduino language. Now, you
    are ready to get your hands on real hardware and start exploring computer to hardware
    interfacing. In the next chapter, we will go through the first step of interfacing,
    that is, connecting Arduino to the computer using a serial interface.
  prefs: []
  type: TYPE_NORMAL
