- en: Exploring Compilers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索编译器
- en: Python is a mature and widely used language and there is a large interest in
    improving its performance by compiling functions and methods directly to machine
    code rather than executing instructions in the interpreter. We have already seen
    a compiler example in [Chapter 4](ce893a62-a46c-4575-8163-01921cf8bb7b.xhtml),
    *C Performance with Cython*, where Python code is enhanced with types, compiled
    to efficient C code, and the interpreter calls are side-stepped.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种成熟且广泛使用的语言，人们对其性能的改进有着浓厚的兴趣，这包括直接将函数和方法编译成机器代码，而不是在解释器中执行指令。我们已经在[第4章](ce893a62-a46c-4575-8163-01921cf8bb7b.xhtml)中看到了一个编译器的例子，即使用
    Cython 进行 C 性能优化，其中 Python 代码通过添加类型被增强，编译成高效的 C 代码，并且解释器调用被绕过。
- en: In this chapter, we will explore two projects--Numba and PyPy--that approach
    compilation in a slightly different way. **Numba** is a library designed to compile
    small functions on the fly. Instead of transforming Python code to C, Numba analyzes
    and compiles Python functions directly to machine code. **PyPy** is a replacement
    interpreter that works by analyzing the code at runtime and optimizing the slow
    loops automatically.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两个项目——Numba 和 PyPy——它们以略微不同的方式处理编译。**Numba** 是一个设计用于即时编译小函数的库。Numba
    不将 Python 代码转换为 C 代码，而是分析和直接编译 Python 函数到机器代码。**PyPy** 是一个替换解释器，它通过在运行时分析代码并自动优化慢速循环来工作。
- en: These tools are called **Just**-**In**-**Time** (**JIT**) compilers because
    the compilation is performed at runtime rather than before running the code (in
    other cases, the compiler is called ahead-of-time or AOT).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具被称为 **即时**（**Just-In-Time**，**JIT**）编译器，因为编译是在运行时而不是在运行代码之前（在其他情况下，编译器是在编译时或
    AOT 调用）进行的。
- en: 'The list of topics to be covered in this chapter is as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要涵盖的主题列表如下：
- en: Getting started with Numba
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Numba
- en: Implementing fast functions with native mode compilation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地模式编译实现快速函数
- en: Understanding and implementing universal functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现通用函数
- en: JIT classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT 类
- en: Setting up PyPy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 PyPy
- en: Running the particle simulator with PyPy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PyPy 运行粒子模拟器
- en: Other interesting compilers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他有趣的编译器
- en: Numba
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Numba
- en: Numba was started in 2012 by Travis Oliphant, the original author of NumPy,
    as a library for compiling individual Python functions at runtime using the **Low-Level
    Virtual Machine** (**LLVM**) toolchain.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 是由 NumPy 的原始作者 Travis Oliphant 在 2012 年启动的，作为一个在运行时使用 **低级虚拟机**（**LLVM**）工具链编译单个
    Python 函数的库。
- en: LLVM is a set of tools designed to write compilers. LLVM is language agnostic
    and is used to write compilers for a wide range of languages (an important example
    is the clang compiler). One of the core aspects of LLVM is the intermediate representation
    (the LLVM IR), a very low-level platform-agnostic language similar to assembly,
    that can be compiled to machine code for the specific target platform.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 是一套用于编写编译器的工具。LLVM 是语言无关的，用于编写广泛语言的编译器（一个重要例子是 clang 编译器）。LLVM 的一个核心方面是中间表示（LLVM
    IR），这是一种非常低级的、平台无关的语言，类似于汇编语言，它可以编译为特定目标平台的机器代码。
- en: Numba works by inspecting Python functions and by compiling them, using LLVM,
    to the IR. As we have already seen in the last chapter, the speed gains can be
    obtained when we introduce types for variables and functions. Numba implements
    clever algorithms to guess the types (this is called type inference) and compiles
    type-aware versions of the functions for fast execution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 通过检查 Python 函数并使用 LLVM 编译它们到 IR 来工作。正如我们在上一章中看到的，当我们为变量和函数引入类型时，可以获得速度提升。Numba
    实现了聪明的算法来猜测类型（这被称为类型推断），并为快速执行编译了类型感知版本的函数。
- en: Note that Numba was developed to improve the performance of numerical code.
    The development efforts often prioritize the optimization of applications that
    intensively use NumPy arrays.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Numba 是为了提高数值代码的性能而开发的。开发工作通常优先考虑优化那些大量使用 NumPy 数组的应用程序。
- en: Numba is evolving really fast and can have substantial improvements between
    releases and, sometimes, backward incompatible changes.  To keep up, ensure that
    you refer to the release notes for each version. In the rest of this chapter,
    we will use Numba version 0.30.1; ensure that you install the correct version
    to avoid any error.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 发展非常快，在版本之间可能会有实质性的改进，有时甚至会有向后不兼容的更改。为了跟上进度，请确保您参考每个版本的发布说明。在本章的其余部分，我们将使用
    Numba 版本 0.30.1；请确保您安装了正确的版本，以避免任何错误。
- en: The complete code examples in this chapter can be found in the `Numba.ipynb` notebook.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的完整代码示例可以在 `Numba.ipynb` 笔记本中找到。
- en: First steps with Numba
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Numba 的第一步
- en: 'Getting started with Numba is fairly straightforward. As a first example, we
    will implement a function that calculates the sum of squares of an array. The
    function definition is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Numba 相对简单。作为一个示例，我们将实现一个计算数组平方和的函数。函数定义如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To set up this function with Numba, it is sufficient to apply the `nb.jit`
    decorator:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Numba 设置此函数，只需应用 `nb.jit` 装饰器即可。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `nb.jit` decorator won't do much when applied. However, when the function
    will be invoked for the first time, Numba will detect the type of the input argument, `a`
    , and compile a specialized, performant version of the original function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用 `nb.jit` 装饰器时，它不会做太多。然而，当函数第一次被调用时，Numba 将检测输入参数 `a` 的类型，并编译原始函数的专用、高性能版本。
- en: 'To measure the performance gain obtained by the Numba compiler, we can compare
    the timings of the original and the specialized functions. The original, undecorated
    function can be easily accessed through the `py_func` attribute. The timings for
    the two functions are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要衡量 Numba 编译器带来的性能提升，我们可以比较原始函数和专用函数的运行时间。原始的未装饰函数可以通过 `py_func` 属性轻松访问。两个函数的运行时间如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From the previous code, you can see how the Numba version (11.7 µs) is one
    order of magnitude faster than the Python version (6.11 ms). We can also compare
    how this implementation stacks up against NumPy standard operators:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，你可以看到 Numba 版本（11.7 µs）比 Python 版本（6.11 ms）快一个数量级。我们还可以将这种实现与 NumPy
    标准运算符进行比较：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the Numba compiled function is marginally faster than NumPy vectorized
    operations. The reason for the extra speed of the Numba version is likely that
    the NumPy version allocates an extra array before performing the sum in comparison
    with the in-place operations performed by our `sum_sq` function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Numba 编译的函数略快于 NumPy 向量化操作。Numba 版本额外速度的原因可能是与我们的 `sum_sq` 函数执行的就地操作相比，NumPy
    版本在执行求和之前分配了一个额外的数组。
- en: 'As we didn''t use array-specific methods in `sum_sq`, we can also try to apply
    the same function on a regular Python list of floating point numbers. Interestingly,
    Numba is able to obtain a substantial speed up even in this case, as compared
    to a list comprehension:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `sum_sq` 中没有使用特定于数组的函数，我们也可以尝试在常规 Python 浮点数列表上应用相同的函数。有趣的是，与列表推导相比，Numba
    在这种情况下也能获得显著的速度提升。
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Considering that all we needed to do was apply a simple decorator to obtain
    an incredible speed up over different data types, it's no wonder that what Numba
    does looks like magic. In the following sections, we will dig deeper and understand
    how Numba works and evaluate the benefits and limitations of the Numba compiler.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们只需要应用一个简单的装饰器就能在不同数据类型上获得令人难以置信的速度提升，Numba 所做的看起来就像是魔法。在接下来的章节中，我们将深入了解
    Numba 的工作原理，并评估 Numba 编译器的优点和局限性。
- en: Type specializations
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型专用化
- en: As shown earlier, the `nb.jit` decorator works by compiling a specialized version
    of the function once it encounters a new argument type. To better understand how
    this works, we can inspect the decorated function in the `sum_sq` example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`nb.jit` 装饰器通过在遇到新的参数类型时编译函数的专用版本来工作。为了更好地理解其工作原理，我们可以检查 `sum_sq` 示例中的装饰函数。
- en: 'Numba exposes the specialized types using the `signatures` attribute. Right
    after the `sum_sq` definition, we can inspect the available specialization by
    accessing the `sum_sq.signatures`, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 通过 `signatures` 属性公开专用类型。在 `sum_sq` 定义之后，我们可以通过访问 `sum_sq.signatures`
    来检查可用的专用化，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we call this function with a specific argument, for instance, an array of
    `float64` numbers, we can see how Numba compiles a specialized version on the
    fly. If we also apply the function on an array of `float32`, we can see how a
    new entry is added to the `sum_sq.signatures` list:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用特定的参数调用这个函数，例如一个 `float64` 数字数组，我们可以看到 Numba 如何即时编译一个专用版本。如果我们也对 `float32`
    数组应用这个函数，我们可以看到一个新的条目被添加到 `sum_sq.signatures` 列表中：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is possible to explicitly compile the function for certain types by passing
    a signature to the `nb.jit` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过传递签名到 `nb.jit` 函数来显式地为某些类型编译函数。
- en: 'An individual signature can be passed as a tuple that contains the type we
    would like to accept. Numba provides a great variety of types that can be found
    in the `nb.types` module, and they are also available in the top-level `nb` namespace.
    If we want to specify an array of a specific type, we can use the slicing operator, `[:]`,
    on the type itself. In the following example, we demonstrate how to declare a
    function that takes an array of `float64` as its only argument:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将单个签名作为包含我们希望接受的类型的元组传递。Numba 提供了 `nb.types` 模块中可以找到的多种类型，它们也存在于顶级 `nb` 命名空间中。如果我们想指定特定类型的数组，我们可以在类型本身上使用切片运算符
    `[:]`。在以下示例中，我们演示了如何声明一个接受 `float64` 数组作为唯一参数的函数：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that when we explicitly declare a signature, we are prevented from using
    other types, as demonstrated in the following example. If we try to pass an array, `x`,
    as `float32`, Numba will raise a `TypeError`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们显式声明一个签名时，我们将无法使用其他类型，以下示例进行了演示。如果我们尝试将数组 `x` 作为 `float32` 传递，Numba 将引发一个
    `TypeError`：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another way to declare signatures is through type strings. For example, a function
    that takes a `float64` as input and returns a `float64` as output can be declared
    with the `float64(float64)` string. Array types can be declared using a `[:]`
    suffix. To put this together, we can declare a signature for our `sum_sq` function,
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 声明签名的另一种方式是通过类型字符串。例如，一个接受 `float64` 作为输入并返回 `float64` 作为输出的函数可以使用 `float64(float64)`
    字符串声明。可以使用 `[:]` 后缀声明数组类型。将它们组合起来，我们可以按照以下方式为我们的 `sum_sq` 函数声明一个签名：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also pass multiple signatures by passing a list:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过传递一个列表来传递多个签名：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Object mode versus native mode
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象模式与原生模式
- en: So far, we have shown how Numba behaves when handling a fairly simple function.
    In this case, Numba worked exceptionally well, and we obtained great performance
    on arrays and lists.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了 Numba 在处理相对简单的函数时的行为。在这种情况下，Numba 工作得非常好，我们在数组和列表上获得了出色的性能。
- en: The degree of optimization obtainable from Numba depends on how well Numba is
    able to infer the variable types and how well it can translate those standard
    Python operations to fast type-specific versions. If this happens, the interpreter
    is side-stepped and we can get performance gains similar to those of Cython.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Numba 获得的优化程度取决于 Numba 能够多好地推断变量类型以及它能够多好地将这些标准 Python 操作转换为快速的类型特定版本。如果发生这种情况，解释器将被绕过，我们可以获得类似于
    Cython 的性能提升。
- en: When Numba cannot infer variable types, it will still try and compile the code,
    reverting to the interpreter when the types can't be determined or when certain
    operations are unsupported. In Numba, this is called **object mode** and is in
    contrast to the interpreter-free scenario, called **native mode**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Numba 无法推断变量类型时，它仍然会尝试编译代码，在类型无法确定或某些操作不受支持时回退到解释器。在 Numba 中，这被称为 **对象模式**，与称为
    **原生模式** 的无解释器场景相对。
- en: 'Numba provides a function, called `inspect_types`, that helps understand how
    effective the type inference was and which operations were optimized. As an example,
    we can take a look at the types inferred for our `sum_sq` function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 提供了一个名为 `inspect_types` 的函数，有助于了解类型推断的有效性以及哪些操作被优化。作为一个例子，我们可以查看 `sum_sq`
    函数推断出的类型：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When this function is called, Numba will print the type inferred for each specialized
    version of the function. The output consists of blocks that contain information
    about variables and types associated with them. For example, we can examine the `N
    = len(a)` line:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此函数时，Numba 将打印出为函数的每个专用版本推断出的类型。输出由包含与变量及其类型相关的信息的块组成。例如，我们可以检查 `N = len(a)`
    这一行：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For each line, Numba prints a thorough description of variables, functions,
    and intermediate results. In the preceding example, you can see (second line)
    that the argument `a` is correctly identified as an array of `float64` numbers.
    At `LINE 4`, the input and return type of the `len` function is also correctly
    identified (and likely optimized) as taking an array of `float64` numbers and
    returning an `int64`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行，Numba 都会打印出关于变量、函数和中间结果的详细描述。在前面的示例中，你可以看到（第二行），参数 `a` 被正确地识别为 `float64`
    数字数组。在 `LINE 4`，`len` 函数的输入和返回类型也被正确地识别（并且可能已优化）为接受 `float64` 数字数组并返回 `int64`。
- en: If you scroll through the output, you can see how all the variables have a well-defined
    type. Therefore, we can be certain that Numba is able to compile the code quite
    efficiently. This form of compilation is called **native mode**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你滚动查看输出，你可以看到所有变量都有一个明确定义的类型。因此，我们可以确信 Numba 能够相当高效地编译代码。这种编译形式被称为 **原生模式**。
- en: As a counter example, we can see what happens if we write a function with unsupported
    operations. For example, as of version 0.30.1, Numba has limited support for string
    operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为反例，我们可以看看如果我们编写一个包含不支持的操作的函数会发生什么。例如，截至版本 0.30.1，Numba 对字符串操作的支持有限。
- en: 'We can implement a function that concatenates a series of strings, and compiles
    it as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现一个连接一系列字符串的函数，并按以下方式编译它：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can invoke this function with a list of strings and inspect the types:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用字符串列表调用这个函数并检查其类型：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Numba will return the output of the function for the `reflected list (str)` type.
    We can, for instance, examine how line 3 gets inferred. The output of `concatenate.inspect_types()`
    is reproduced here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 将返回 `reflected list (str)` 类型的函数输出。例如，我们可以检查第 3 行是如何推断出来的。`concatenate.inspect_types()`
    的输出如下所示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see how this time, each variable or function is of the generic `pyobject`
    type rather than a specific one. This means that, in this case, Numba is unable
    to compile this operation without the help of the Python interpreter. Most importantly,
    if we time the original and compiled function, we note that the compiled function
    is about three times *slower* than the pure Python counterpart:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这次，每个变量或函数都是通用的 `pyobject` 类型，而不是特定的类型。这意味着在这种情况下，Numba 没有Python解释器的帮助无法编译这个操作。最重要的是，如果我们对原始函数和编译后的函数进行计时，我们会注意到编译后的函数大约比纯Python版本慢三倍：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is because the Numba compiler is not able to optimize the code and adds
    some extra overhead to the function call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Numba 编译器无法优化代码，并在函数调用中添加了一些额外的开销。
- en: As you may have noted, Numba compiled the code without complaints even if it
    is inefficient. The main reason for this is that Numba can still compile other
    sections of the code in an efficient manner while falling back to the Python interpreter
    for other parts of the code. This compilation strategy is called **object mode**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，即使效率不高，Numba 也能无怨无悔地编译代码。主要原因在于 Numba 仍然能够以高效的方式编译代码的其他部分，而对于其他部分则回退到
    Python 解释器。这种编译策略被称为 **对象模式**。
- en: 'It is possible to force the use of native mode by passing the `nopython=True`
    option to the `nb.jit` decorator. If, for example, we apply this decorator to
    our concatenate function, we observe that Numba throws an error on first invocation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将 `nopython=True` 选项传递给 `nb.jit` 装饰器来强制使用原生模式。例如，如果我们将这个装饰器应用于我们的连接函数，我们会观察到
    Numba 在第一次调用时抛出错误：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This feature is quite useful for debugging and ensuring that all the code is
    fast and correctly typed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性对于调试和确保所有代码都快速且正确类型非常有用。
- en: Numba and NumPy
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Numba 和 NumPy
- en: Numba was originally developed to easily increase performance of code that uses
    NumPy arrays. Currently, many NumPy features are implemented efficiently by the
    compiler.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 最初是为了方便提高使用 NumPy 数组的代码的性能而开发的。目前，许多 NumPy 功能都由编译器高效实现。
- en: Universal functions with Numba
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Numba 中的通用函数
- en: Universal functions are special functions defined in NumPy that are able to
    operate on arrays of different sizes and shapes according to the broadcasting
    rules. One of the best features of Numba is the implementation of fast `ufuncs`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数是在 NumPy 中定义的特殊函数，能够根据广播规则在不同的数组大小和形状上操作。Numba 的最佳特性之一是实现快速的 `ufuncs`。
- en: We have already seen some `ufunc` examples in [Chapter 3](fb5356db-d238-4571-b5de-663a8400ad6d.xhtml)*,
    Fast Array Operations with NumPy and Pandas*. For instance, the `np.log` function
    is a `ufunc` because it can accept scalars and arrays of different sizes and shapes.
    Also, universal functions that take multiple arguments still work according to
    the  broadcasting rules. Examples of universal functions that take multiple arguments
    are `np.sum` or `np.difference`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 3 章](fb5356db-d238-4571-b5de-663a8400ad6d.xhtml)*，使用 NumPy 和 Pandas
    的快速数组操作* 中看到了一些 `ufunc` 示例。例如，`np.log` 函数是一个 `ufunc`，因为它可以接受不同大小和形状的标量和数组。此外，接受多个参数的通用函数仍然遵循广播规则。接受多个参数的通用函数的例子有
    `np.sum` 或 `np.difference`。
- en: Universal functions can be defined in standard NumPy by implementing the scalar
    version and using the `np.vectorize` function to enhance the function with the
    broadcasting feature. As an example, we will see how to write the *Cantor pairing
    function*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数可以通过实现标量版本并使用`np.vectorize`函数来增强广播功能来在标准NumPy中定义。作为一个例子，我们将看到如何编写*Cantor配对函数*。
- en: 'A pairing function is a function that encodes two natural numbers into a single
    natural number so that you can easily interconvert between the two representations.
    The Cantor pairing function can be written as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 配对函数是一个将两个自然数编码为单个自然数的函数，这样你可以轻松地在两种表示之间进行转换。Cantor配对函数可以写成如下形式：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As already mentioned, it is possible to create a ufunc in pure Python using
    the `np.vectorized` decorator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可以使用`np.vectorized`装饰器在纯Python中创建一个ufunc：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Except for the convenience, defining universal functions in pure Python is not
    very useful as it requires a lot of function calls affected by interpreter overhead.
    For this reason, ufunc implementation is usually done in C or Cython, but Numba
    beats all these methods by its convenience.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了方便之外，在纯Python中定义通用函数并不很有用，因为它需要大量的函数调用，这些调用受解释器开销的影响。因此，ufunc的实现通常在C或Cython中完成，但Numba凭借其便利性击败了所有这些方法。
- en: 'All that is needed to do in order to perform the conversion is using the equivalent
    decorator, `nb.vectorize`. We can compare the speed of the standard `np.vectorized`
    version which, in the following code, is called `cantor_py`, and the same function
    is implemented using standard NumPy operations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行转换，所需做的只是使用等效的装饰器`nb.vectorize`。我们可以比较标准`np.vectorized`版本的速度，在以下代码中称为`cantor_py`，以及使用标准NumPy操作实现相同功能的函数：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see how the Numba version beats all the other options by a large margin!
    Numba works extremely well because the function is simple and type inference is
    possible.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到Numba版本如何以很大的优势击败所有其他选项！Numba工作得非常好，因为函数简单，可以进行类型推断。
- en: An additional advantage of universal functions is that, since they depend on
    individual values, their evaluation can also be executed in parallel. Numba provides
    an easy way to parallelize such functions by passing the `target="cpu"` or `target="gpu"`
    keyword argument to the `nb.vectorize` decorator.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数的另一个优点是，由于它们依赖于单个值，它们的评估也可以并行执行。Numba通过将`target="cpu"`或`target="gpu"`关键字参数传递给`nb.vectorize`装饰器，提供了一个轻松并行化此类函数的方法。
- en: Generalized universal functions
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广义通用函数
- en: One of the main limitations of universal functions is that they must be defined
    on scalar values. A generalized universal function, abbreviated `gufunc`, is an
    extension of universal functions to procedures that take arrays.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数的一个主要限制是它们必须在标量值上定义。广义通用函数（简称`gufunc`）是通用函数的扩展，它将数组作为过程。
- en: 'A classic example is the matrix multiplication. In NumPy, matrix multiplication
    can be applied using the `np.matmul` function, which takes two 2D arrays and returns
    another 2D array. An example usage of `np.matmul` is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的例子是矩阵乘法。在NumPy中，可以使用`np.matmul`函数进行矩阵乘法，该函数接受两个二维数组并返回另一个二维数组。`np.matmul`的一个示例用法如下：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we saw in the previous subsection, a `ufunc` broadcasts the operation over
    arrays of *scalars*, its natural generalization will be to broadcast over an array
    of *arrays*. If, for instance, we take two arrays of 3 by 3 matrices, we will
    expect `np.matmul` to take to match the matrices and take their product. In the
    following example, we take two arrays containing 10 matrices of shape `(3, 3)`.
    If we apply `np.matmul`, the product will be applied *matrix-wise* to obtain a
    new array containing the 10 results (which are, again, `(3, 3)` matrices):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ufunc会将操作广播到标量数组上，其自然推广将是广播到数组数组上。例如，如果我们取两个3x3矩阵的数组，我们期望`np.matmul`会匹配矩阵并取它们的乘积。在以下示例中，我们取包含10个形状为`(3,
    3)`矩阵的数组。如果我们应用`np.matmul`，乘法将按矩阵方式应用，以获得包含10个结果的新数组（这些结果再次是`(3, 3)`矩阵）：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The usual rules for broadcasting will work in a similar way. For example, if
    we have an array of `(3, 3)` matrices, which will have a shape of `(10, 3, 3)`,
    we can use `np.matmul` to calculate the matrix multiplication of each element
    with a single `(3, 3)` matrix. According to the broadcasting rules, we obtain
    that the single matrix will be repeated to obtain a size of `(10, 3, 3)`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 广播的常规规则将以类似的方式工作。例如，如果我们有一个 `(3, 3)` 矩阵的数组，它将具有 `(10, 3, 3)` 的形状，我们可以使用 `np.matmul`
    来计算每个元素与单个 `(3, 3)` 矩阵的矩阵乘法。根据广播规则，我们得到单个矩阵将被重复以获得 `(10, 3, 3)` 的大小：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Numba supports the implementation of efficient generalized universal functions
    through the `nb.guvectorize` decorator. As an example, we will implement a function
    that computes the euclidean distance between two arrays as a `gufunc`. To create
    a `gufunc`, we have to define a function that takes the input arrays, plus an
    output array where we will store the result of our calculation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 通过 `nb.guvectorize` 装饰器支持高效通用函数的实现。作为一个例子，我们将实现一个函数，该函数计算两个数组之间的欧几里得距离作为一个
    `gufunc`。要创建一个 `gufunc`，我们必须定义一个函数，该函数接受输入数组，以及一个输出数组，我们将在这里存储计算结果。
- en: 'The `nb.guvectorize` decorator requires two arguments:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`nb.guvectorize` 装饰器需要两个参数：'
- en: 'The types of the input and output: two 1D arrays as input and a scalar as output'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出的类型：两个一维数组作为输入，一个标量作为输出
- en: The so called layout string, which is a representation of the input and output
    sizes; in our case, we take two arrays of the same size (denoted arbitrarily by
    `n`), and we output a scalar
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所说的布局字符串，它是输入和输出大小的表示；在我们的情况下，我们取两个相同大小的数组（任意表示为 `n`），并输出一个标量
- en: 'In the following example, we show the implementation of the `euclidean` function
    using the `nb.guvectorize` decorator:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们展示了使用 `nb.guvectorize` 装饰器实现 `euclidean` 函数的方法：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are a few very important points to be made. Predictably, we declared the
    types of the inputs `a` and `b` as `float64[:]`, because they are 1D arrays. However, what
    about the output argument? Wasn't it supposed to be a scalar? Yes, however, **Numba
    treats scalar argument as arrays of size 1**. That's why it was declared as `float64[:]`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个非常重要的要点需要说明。可以预见的是，我们将输入 `a` 和 `b` 的类型声明为 `float64[:]`，因为它们是一维数组。然而，输出参数呢？它不是应该是一个标量吗？是的，然而，**Numba
    将标量参数视为大小为 1 的数组**。这就是为什么它被声明为 `float64[:]`。
- en: Similarly, the layout string indicates that we have two arrays of size `(n)`
    and the output is a scalar, denoted by empty brackets--`()`. However, the array
    out will be passed as an array of size 1.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，布局字符串表示我们有两个大小为 `(n)` 的数组，输出是一个标量，用空括号 `()` 表示。然而，输出数组将以大小为 1 的数组形式传递。
- en: Also, note that we don't return anything from the function; all the output has
    to be written in the `out` array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们从函数中不返回任何内容；所有输出都必须写入 `out` 数组。
- en: The letter `n` in the layout string is completely arbitrary; you may choose
    to use `k`  or other letters of your liking. Also, if you want to combine arrays
    of uneven sizes, you can use layouts strings, such as `(n, m)`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 布局字符串中的字母 `n` 完全任意；你可以选择使用 `k` 或其他你喜欢的字母。此外，如果你想组合不同大小的数组，你可以使用布局字符串，例如 `(n,
    m)`。
- en: 'Our brand new `euclidean` function can be conveniently used on arrays of different
    shapes, as shown in the following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们全新的 `euclidean` 函数可以方便地用于不同形状的数组，如下面的示例所示：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'How does the speed of `euclidean` compare to standard NumPy? In the following
    code, we benchmark a NumPy vectorized version with our previously defined `euclidean`
    function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`euclidean` 的速度与标准 NumPy 相比如何？在下面的代码中，我们使用先前定义的 `euclidean` 函数与 NumPy 向量化版本进行基准测试：'
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Numba version, again, beats the NumPy version by a large margin!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Numba 版本在性能上大幅领先于 NumPy 版本！
- en: JIT classes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JIT 类
- en: As of today, Numba doesn't support optimization of generic Python objects. This
    limitation, however, doesn't have a huge impact on numerical codes as they usually
    involve arrays and math operations exclusively.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，Numba 不支持通用 Python 对象的优化。然而，这个限制对数值代码的影响并不大，因为它们通常只涉及数组和数学运算。
- en: Nevertheless, certain data structures are much more naturally implemented using
    objects; therefore, Numba provides support for defining classes that can be used
    and compiled to fast, native code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，某些数据结构使用对象实现起来更为自然；因此，Numba 提供了对定义可以用于并编译为快速原生代码的类的支持。
- en: Bear in mind that this is one of the newest (almost experimental) features,
    and it is extremely useful as it allows us to extend Numba to support fast data
    structures that are not easily implemented with arrays.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是最新（几乎是实验性的）功能之一，它非常有用，因为它允许我们将Numba扩展以支持那些难以用数组实现的快速数据结构。
- en: 'As an example, we will show how to implement a simple linked list using JIT
    classes. A linked list can be implemented by defining a `Node` class that contains
    two fields: a value and the next item in the list. As you can see in the following
    figure, each **Node** connects to the next and holds a value, and the last node
    contains a broken link, to which we assign a value of **None**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将展示如何使用JIT类实现一个简单的链表。链表可以通过定义一个包含两个字段的`Node`类来实现：一个值和列表中的下一个项目。如图所示，每个**Node**连接到下一个节点并持有值，最后一个节点包含一个断开链接，我们将其赋值为**None**：
- en: '![](img/linked_list.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![链表](img/linked_list.png)'
- en: 'In Python, we can define the `Node` class as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以将`Node`类定义为如下：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can manage the collection of `Node` instances by creating another class,
    called `LinkedList`. This class will keep track of the head of the list (in the
    preceding figure, this corresponds to the **Node** with **value** **3**). To insert
    an element in the front of the list, we can simply create a new **Node** and link
    it to the current head.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建另一个名为`LinkedList`的类来管理`Node`实例的集合。这个类将跟踪列表的头部（在先前的图中，这对应于**值**为**3**的**Node**）。为了在列表前面插入一个元素，我们可以简单地创建一个新的**Node**并将其链接到当前头部。
- en: 'In the following code, we develop the initialization function for `LinkedList`
    and the `LinkedList.push_back` method that inserts an element in the front of
    the list using the strategy outlined earlier:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们开发了`LinkedList`的初始化函数和`LinkedList.push_back`方法，该方法使用前面概述的策略在列表前面插入一个元素：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For debugging purposes, we can also implement the `LinkedList.show` method
    that traverses and prints each element in the list. The method is shown in the
    following snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试目的，我们还可以实现一个`LinkedList.show`方法，该方法遍历并打印列表中的每个元素。该方法在下面的代码片段中展示：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At this point, we can test our `LinkedList` and see whether it behaves correctly.
    We can create an empty list, add a few elements, and print its content. Note that
    since we are pushing elements at the front of the list, the last elements inserted
    will be the first to be printed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以测试我们的`LinkedList`并查看它是否表现正确。我们可以创建一个空列表，添加一些元素，并打印其内容。请注意，由于我们是在列表前面推入元素，最后插入的元素将是首先打印的：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we can implement a function, `sum_list`, that returns the sum of the
    elements in the linked list. We will use this method to time differences between
    the Numba and pure Python version:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现一个函数，`sum_list`，它返回链表中元素的总和。我们将使用此方法来测量Numba和纯Python版本之间的差异：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we measure the execution time of the original `sum_list` version and the
    `nb.jit` version, we see that there is not much difference. The reason is that
    Numba cannot infer the type of classes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测量原始`sum_list`版本和`nb.jit`版本的执行时间，我们会看到没有太大的差异。原因是Numba无法推断类的类型：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can improve the performance of `sum_list` by compiling the `Node` and `LinkedList`
    classes using the `nb.jitclass` decorator.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`nb.jitclass`装饰器编译`Node`和`LinkedList`类来提高`sum_list`的性能。
- en: The `nb.jitclass` decorator takes a single argument that contains the attribute
    types. In the `Node` class, the attribute types are `int64` for `value` and `Node`
    for `next`. The `nb.jitclass` decorator will also compile all the methods defined
    for the class. Before delving into the code, there are two observations that need
    to be made.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`nb.jitclass`装饰器接受一个包含属性类型的单个参数。在`Node`类中，属性类型为`value`的`int64`和`next`的`Node`。`nb.jitclass`装饰器还将编译为该类定义的所有方法。在深入代码之前，需要提出两个观察点。'
- en: First, the attribute declaration has to be done before the class is defined,
    but how do we declare a type we haven't defined yet? Numba provides the `nb.deferred_type()`
    function, which can be used for this purpose.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，属性声明必须在定义类之前完成，但我们如何声明尚未定义的类型？Numba提供了`nb.deferred_type()`函数，可用于此目的。
- en: Second, the `next` attribute can be either `None` or a `Node` instance. This
    is what is called an optional type, and Numba provides a utility, called `nb.optional`,
    that lets you declare variables that can be (optionally) `None`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，`next`属性可以是`None`或`Node`实例。这被称为可选类型，Numba提供了一个名为`nb.optional`的实用工具，允许你声明可以（可选地）为`None`的变量。
- en: 'This `Node` class is illustrated in the following code sample. As you can see, 
    `node_type` is predeclared using `nb.deferred_type()`. The attributes are declared
    as a list of pairs containing the attribute name and the type (also note the use
    of `nb.optional`). After the class declaration, we are required to declare the
    deferred type:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了这个`Node`类。正如你所见，`node_type`是使用`nb.deferred_type()`预先声明的。属性被声明为一个包含属性名和类型的对列表（也请注意`nb.optional`的使用）。在类声明之后，我们需要声明延迟类型：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `LinkedList` class can be easily compiled, as follows. All that''s needed
    is to define the `head` attribute and to apply the `nb.jitclass` decorator:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`类可以很容易地编译，如下所示。所需做的只是定义`head`属性并应用`nb.jitclass`装饰器：'
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now measure the execution time of the `sum_list` function when we pass
    a JIT `LinkedList`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测量当我们传递一个JIT `LinkedList`给`sum_list`函数时的执行时间：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Interestingly, when using a JIT class from a compiled function, we obtain a
    substantial performance improvement against the pure Python version. However,
    using the JIT class from the original `sum_list.py_func` actually results in worse
    performance. Ensure that you use JIT classes only inside compiled functions!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当使用编译函数中的JIT类时，我们获得了与纯Python版本相比的显著性能提升。然而，从原始的`sum_list.py_func`中使用JIT类实际上会导致性能下降。确保你只在编译函数内部使用JIT类！
- en: Limitations in Numba
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Numba的限制
- en: 'There are some instances where Numba cannot properly infer the variable types
    and will refuse to compile. In the following example, we define a function that
    takes a nested list of integers and returns the sum of the element in every sublist.
    In this case, Numba will raise `ValueError` and refuse to compile:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，Numba无法正确推断变量类型，并将拒绝编译。在以下示例中，我们定义了一个函数，它接受一个整数嵌套列表并返回每个子列表中元素的求和。在这种情况下，Numba将引发`ValueError`并拒绝编译：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The problem with this code is that Numba is not able to determine the type
    of the list and fails. A way to fix this problem is to help the compiler determine
    the right type by initializing the list with a sample element and removing it
    at the end:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码的问题在于Numba无法确定列表的类型，从而导致失败。解决这个问题的一个方法是通过用一个样本元素初始化列表并在结束时移除它来帮助编译器确定正确的类型：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Among other features that are not yet implemented in the Numba compiler are
    function and class definitions, list, set and dict comprehension, generators,
    the `with` statement, and `try` `except` blocks. Note, however, that many of these
    features may become supported in the future.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Numba编译器中尚未实现的其他特性包括函数和类定义、列表、集合和字典推导、生成器、`with`语句以及`try` `except`块。然而，值得注意的是，许多这些特性可能在将来得到支持。
- en: The PyPy project
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyPy项目
- en: PyPy is a very ambitious project at improving the performance of the Python
    interpreter. The way PyPy improves performance is by automatically compiling slow
    sections of the code at runtime.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy是一个旨在提高Python解释器性能的非常雄心勃勃的项目。PyPy提高性能的方式是在运行时自动编译代码中的慢速部分。
- en: PyPy is written in a special language called RPython (rather than C) that allows
    developers to quickly and reliably implement advanced features and improvements.
    RPython means *Restricted Python* because it implements a restricted subset of
    the Python language targeted to the compiler development.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy是用一种称为RPython的特殊语言编写的（而不是C语言），这使得开发者能够快速且可靠地实现高级功能和改进。RPython意味着*受限Python*，因为它实现了一个针对编译器开发的Python语言的受限子集。
- en: As of today, PyPy version 5.6 supports a lot of Python features and is a possible
    choice for a large variety of applications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，PyPy版本5.6支持许多Python特性，并且是各种应用的一个可能选择。
- en: PyPy compiles code using a very clever strategy, called *tracing JIT compilation*.
    At first, the code is executed normally using interpreter calls. PyPy then starts
    to profile the code and identifies the most intensive loops. After the identification
    takes place, the compiler then observes (*traces*) the operations and is able
    to compile its optimized, interpreter-free version.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy使用一种非常巧妙的策略来编译代码，称为*跟踪JIT编译*。最初，代码是使用解释器调用正常执行的。然后PyPy开始分析代码并识别最密集的循环。在识别完成后，编译器随后观察（跟踪）操作，并能够编译其优化、无解释器的版本。
- en: Once an optimized version of the code is present, PyPy is able to run the slow
    loop much faster than the interpreted version.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了代码的优化版本，PyPy就能比解释版本更快地运行慢速循环。
- en: This strategy can be contrasted with what Numba does. In Numba, the units of
    compilation are methods and functions, while the PyPy focus is just slow loops.
    Overall, the focus of the projects is also very different as Numba has a limited
    scope for numerical code and requires a lot of instrumentation while PyPy aims
    at replacing the CPython interpreter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略可以与 Numba 的做法进行对比。在 Numba 中，编译的单位是方法和函数，而 PyPy 的重点是慢速循环。总体而言，项目的重点也非常不同，因为
    Numba 对数值代码的范围有限，并且需要大量的仪器，而 PyPy 的目标是替换 CPython 解释器。
- en: In this section, we will demonstrate and benchmark PyPy on our particle simulator
    application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示并基准测试 PyPy 在我们的粒子模拟器应用程序上的使用。
- en: Setting up PyPy
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 PyPy
- en: PyPy is distributed as a precompiled binary that can be downloaded from [http://pypy.org/download.html](http://pypy.org/download.html),
    and it currently supports Python versions 2.7 (beta support in PyPy 5.6) and 3.3
    (alpha support in PyPy 5.5). In this chapter, we will demonstrate the usage of
    the 2.7 version.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy 以预编译的二进制形式分发，可以从 [http://pypy.org/download.html](http://pypy.org/download.html)
    下载，并且目前支持 Python 版本 2.7（PyPy 5.6 中的 beta 支持）和 3.3（PyPy 5.5 中的 alpha 支持）。在本章中，我们将演示
    2.7 版本的使用。
- en: 'Once PyPy is downloaded and unpacked, you can locate the interpreter in the
    `bin/pypy` directory relative to the unpacked archive. You can initialize a new
    virtual environment where we can install additional packages using the following
    command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载并解压 PyPy，你可以在解压存档的 `bin/pypy` 目录中找到解释器。你可以使用以下命令初始化一个新的虚拟环境，在该环境中我们可以使用以下命令安装额外的包：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To activate the environment, we will use the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活环境，我们将使用以下命令：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At this point, you can verify that the binary Python is linked to the PyPy
    executable by typing `python -V`. At this point, we can go ahead and install some
    packages we may need. As of version 5.6, PyPy has limited support for software
    that uses the Python C API (most notably, packages such as `numpy` and `matplotlib`).
    We can go ahead and install them in the usual way:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以通过输入 `python -V` 来验证二进制 Python 是否链接到 PyPy 可执行文件。到这一点，我们可以继续安装我们可能需要的包。截至版本
    5.6，PyPy 对使用 Python C API 的软件支持有限（最著名的是 `numpy` 和 `matplotlib` 等包）。我们可以按照常规方式继续安装它们：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: On certain platforms, installation of `numpy` and `matplotlib` can be tricky.
    You can skip the installation step and remove any imports on these two packages
    from the scripts we will run.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些平台上，安装 `numpy` 和 `matplotlib` 可能很棘手。你可以跳过安装步骤，并从我们将运行的脚本中移除这两个包的任何导入。
- en: Running a particle simulator in PyPy
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 PyPy 中运行粒子模拟器
- en: 'Now that we have successfully set up the PyPy installation, we can go ahead
    and run our particle simulator. As a first step, we will time the particle simulator
    from [Chapter 1](4db2c3e6-3485-41a5-8450-07220f6d80ec.xhtml), *Benchmarking and
    Profiling*, on the standard Python interpreter. If the virtual environment is
    still active, you can issue the command deactivate to exit the environment. We
    can confirm that the Python interpreter is the standard one by using the `python
    -V` command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功设置了 PyPy 安装，我们可以继续运行我们的粒子模拟器。作为第一步，我们将对来自 [第 1 章](4db2c3e6-3485-41a5-8450-07220f6d80ec.xhtml)，*基准测试和性能分析*
    的粒子模拟器在标准 Python 解释器上进行计时。如果虚拟环境仍然处于活动状态，你可以输入命令 deactivate 退出环境。我们可以通过使用 `python
    -V` 命令来确认 Python 解释器是标准的：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At this point, we can time our code using the `timeit` command-line interface:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以使用 `timeit` 命令行界面来计时我们的代码：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can reactivate the environment and run the exact same code from PyPy. On
    Ubuntu, you may have problems importing the `matplotlib.pyplot` module. You can
    try issuing the following `export` command to fix the issue or removing the `matplotlib`
    imports from `simul.py`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新激活环境并运行与 PyPy 完全相同的代码。在 Ubuntu 上，你可能会在导入 `matplotlib.pyplot` 模块时遇到问题。你可以尝试执行以下
    `export` 命令来修复问题，或者从 `simul.py` 中移除 `matplotlib` 的导入：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we can go ahead and time the code using PyPy:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 PyPy 来计时代码：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note that we obtained a large, more than eight times, speedup! PyPy, however,
    warns us that the `timeit` module can be unreliable. We can confirm our timings
    using the `perf` module, as suggested by PyPy:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们获得了很大的加速，超过八倍！然而，PyPy 警告我们 `timeit` 模块可能不可靠。我们可以使用 PyPy 建议的 `perf` 模块来确认我们的计时：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Other interesting projects
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有趣的项目
- en: Over the years, many projects attempted to improve Python performance through
    several strategies and, sadly, many of them failed. As of today, there are a few
    projects that survive and hold the promise for a faster Python.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，许多项目试图通过多种策略提高 Python 的性能，但遗憾的是，许多项目失败了。截至目前，有一些项目幸存下来，并承诺将带来更快的 Python。
- en: Numba and PyPy are mature projects that are steadily improving over the years.
    Features are continuously being added and they hold great promise for the future
    of Python.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 和 PyPy 是成熟的项目，多年来一直在稳步改进。功能持续被添加，并且它们对未来 Python 的前景有着巨大的承诺。
- en: '**Nuitka** is a program developed by Kay Hayen that compiles Python code to
    C. As of right now (version 0.5.x), it provides extreme compatibility with the
    Python language and produces efficient code that results in moderate performance
    improvements over CPython.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**Nuitka** 是由 Kay Hayen 开发的一个程序，它将 Python 代码编译成 C 语言。截至目前（版本 0.5.x），它提供了与 Python
    语言的极致兼容性，并生成高效的代码，与 CPython 相比，实现了适度的性能提升。'
- en: Nuitka is quite different than Cython in the sense that it focuses on extreme
    compatibility with the Python language, and it doesn't extend the language with
    additional constructs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Nuitka 与 Cython 在意义上相当不同，因为它专注于与 Python 语言的极致兼容性，并且不通过额外的结构扩展语言。
- en: '**Pyston** is a new interpreter developed by Dropbox that powers JIT compilers.
    It differs substantially from PyPy as it doesn''t employ a tracing JIT, but rather
    a method-at-a-time JIT (similar to what Numba does). Pyston, like Numba, is also
    built on top of the LLVM compiler infrastructure.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pyston** 是 Dropbox 开发的一个新的解释器，它为 JIT 编译器提供动力。它与 PyPy 有很大不同，因为它不使用追踪 JIT，而是使用逐方法
    JIT（类似于 Numba 所做的）。Pyston，像 Numba 一样，也是建立在 LLVM 编译器基础设施之上的。'
- en: Pyston is still in early development (alpha stage) and only supports Python
    2.7\. Benchmarks show that it is faster than CPython but slower than PyPy; that
    said, it is still an interesting project to follow as new features are added and
    compatibility is increased.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Pyston 目前仍处于早期开发阶段（alpha 版本），仅支持 Python 2.7。基准测试显示，它的速度比 CPython 快，但比 PyPy 慢；尽管如此，随着新功能的添加和兼容性的提高，它仍然是一个值得关注的有趣项目。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Numba is a tool that compiles fast, specialized versions of Python functions
    at runtime. In this chapter, we learned how to compile, inspect, and analyze functions
    compiled by Numba. We also learned how to implement fast NumPy universal functions
    that are useful in a wide array of numerical applications. Finally, we implemented
    more complex data structures using the `nb.jitclass` decorator.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 是一个工具，它在运行时编译 Python 函数的快速、专用版本。在本章中，我们学习了如何编译、检查和分析由 Numba 编译的函数。我们还学习了如何实现快速
    NumPy 通用函数，这些函数在广泛的数值应用中非常有用。最后，我们使用 `nb.jitclass` 装饰器实现了更复杂的数据结构。
- en: Tools such as PyPy allow us to run Python programs unchanged to obtain significant
    speed improvements. We demonstrated how to set up PyPy, and we assessed the performance
    improvements on our particle simulator application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 工具如 PyPy 允许我们在不改变 Python 程序的情况下运行，以获得显著的速度提升。我们展示了如何设置 PyPy，并评估了我们在粒子模拟应用程序上的性能提升。
- en: We also, briefly, described the current ecosystem of the Python compilers and
    compared them with each other.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也简要地描述了当前 Python 编译器的生态系统，并相互比较了它们。
- en: In the next chapter, we will learn about concurrency and asynchronous programming.
    Using these techniques, we will be able to improve the responsiveness and design of
    applications that spend a lot of time waiting for network and disk resources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习并发和异步编程。使用这些技术，我们将能够提高那些花费大量时间等待网络和磁盘资源的应用程序的响应性和设计。
