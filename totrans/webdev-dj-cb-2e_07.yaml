- en: Chapter 7. Django CMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating templates for Django CMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring the page menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting an app to a CMS app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching your own navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own CMS plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new fields to the CMS page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django CMS is an open source content management system that is based on Django
    and created by Divio AG, Switzerland. Django CMS takes care of a website's structure,
    provides navigation menus, makes it easy to edit page content in the frontend,
    and supports multiple languages in a website. You can also extend it according
    to your needs using the provided hooks. To create a website, you need to create
    a hierarchical structure of the pages, where each page has a template. Templates
    have placeholders that can be assigned different plugins with the content. Using
    special template tags, the menus can be generated out of the hierarchical page
    structure. The CMS takes care of URL mapping to specific pages.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at Django CMS 3.1 from a developer's perspective.
    We will see what is necessary for the templates to function and take a look at
    the possible page structure for header and footer navigation. You will also learn
    how to attach the URL rules of an app to a CMS page tree node. Then, we will attach
    the custom navigation to the page menu and create our own CMS content plugins.
    Finally, you will learn how to add new fields to the CMS pages.
  prefs: []
  type: TYPE_NORMAL
- en: Although in this book, I won't guide you through all the bits and pieces of
    using Django CMS; by the end of this chapter, you will be aware of its purpose
    and use. The rest can be learned from the official documentation at [http://docs.django-cms.org/en/develop/](http://docs.django-cms.org/en/develop/)
    and by trying out the frontend user interface of the CMS.
  prefs: []
  type: TYPE_NORMAL
- en: Creating templates for Django CMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For every page in your page structure, you need to choose a template from the
    list of templates that are defined in the settings. In this recipe, we will look
    at the minimum requirements for these templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to start a new Django CMS project, execute the following commands
    in a virtual environment and answer all the prompted questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `project/myproject` is the path where the project will be created and
    `myproject` is the project name.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you want to integrate Django CMS in an existing project,
    check the official documentation at [http://docs.django-cms.org/en/latest/how_to/install.html](http://docs.django-cms.org/en/latest/how_to/install.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will update the Bootstrap-powered `base.html` template so that it contains
    everything that Django CMS needs. Then, we will create and register two templates,
    `default.html` and `start.html`, to choose from for CMS pages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will update the base template that we created in the *Arranging
    the base.html template* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will create a `cms` directory under `templates` and add two templates
    for CMS pages: `default.html` for normal pages and `start.html` for the home page,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we will set the paths of these two templates in the settings, as shown
    in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, the `base.html` template is the main template that is extended by
    all the other templates. In this template, Django CMS uses the `{% render_block
    %}` template tag from the `django-sekizai` module to inject CSS and JavaScript
    in the templates that create a toolbar and other administration widgets in the
    frontend. We will insert the `{% cms_toolbar %}` template tag at the beginning
    of the `<body>` section—that's where the toolbar will be placed. We will use the
    `{% show_menu_below_id %}` template tag to render the header and footer menus
    from the specific page menu trees. Also, we will use the `{% language_chooser
    %}` template tag to render the language chooser that switches to the same page
    in different languages.
  prefs: []
  type: TYPE_NORMAL
- en: The `default.html` and `start.html` templates that are defined in the `CMS_TEMPLATES`
    setting will be available as a choice when creating a CMS page. In these templates,
    for each area that needs to have dynamically entered content, add a `{% placeholder
    %}` template tag when you need page-specific content or `{% static_placeholder
    %}` when you need the content that is shared among different pages. Logged-in
    administrators can add content plugins to the placeholders when they switch from
    the **Live** mode to the **Draft** mode in the CMS toolbar and switch to the **Structure**
    section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Arranging the base.html template* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Structuring the page menu* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring the page menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss some guidelines about defining the tree structures
    for the pages of your website.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is good practice to set the available languages for your website before
    creating the structure of your pages (although the Django CMS database structure
    also allows you to add new languages later). Besides `LANGUAGES`, make sure that
    you have `CMS_LANGUAGES` set in your settings. The `CMS_LANGUAGES` setting defines
    which languages should be active for each Django site, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The page navigation is set in tree structures. The first tree is the main tree
    and, contrary to the other trees, the root node of the main tree is not reflected
    in the URL structure. The root node of this tree is the home page of the website.
    Usually, this page has a specific template, where you add the content aggregated
    from different apps; for example, a slideshow, actual news, newly registered users,
    latest tweets, or other latest or featured objects. For a convenient way to render
    items from different apps, check the *Creating a template tag to a QuerySet in
    a template* recipe in [Chapter 5](ch05.html "Chapter 5. Custom Template Filters
    and Tags"), *Custom Template Filters and Tags*.
  prefs: []
  type: TYPE_NORMAL
- en: If your website has multiple navigations such as a top, meta, and footer navigation,
    give an ID to the root node of each tree in the **Advanced** settings of the page.
    This ID will be used in the base template by the `{% show_menu_below_id %}` template
    tag. You can read more about this and other menu-related template tags in the
    official documentation at [http://docs.django-cms.org/en/latest/reference/navigation.html](http://docs.django-cms.org/en/latest/reference/navigation.html).
  prefs: []
  type: TYPE_NORMAL
- en: The first tree defines the main structure of the website. If you want a page
    under the root-level URL, for example, `/en/search/` but not `/en/meta/search/`,
    put this page under the home page. If you don't want a page to be shown in the
    menu as it will be linked from an icon or widget, just hide it from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: The footer navigation usually shows different items than the top navigation
    with some of the items being repeated, for example, the page for developers will
    be shown only in the footer; whereas, the page for news will be shown in both
    header and footer. For all the repeated items, just create a page with the **Redirect**
    setting in the advanced settings of the page and set it to the original page in
    the main tree. By default, when you create a secondary tree structure, all pages
    under the root of that tree will include the slug of the root page in their URL
    paths. If you want to skip the slug of the root in the URL path, you will need
    to set the **Overwrite URL** setting in the advanced settings of the page. For
    example, the developers page should be under `/en/developers/` and not `/en/secondary/developers/`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, your page structure will look similar to the following image (of course,
    the page structure can be much more complex too):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04912_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a template tag to load a QuerySet in a template* recipe in [Chapter
    5](ch05.html "Chapter 5. Custom Template Filters and Tags"), *Custom Template
    Filters and Tags*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating templates for Django CMS* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Attaching your own navigation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting an app to a CMS app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest Django CMS website will have the whole page tree created using
    administration interface. However, for real-world cases, you will probably need
    to show forms or lists of objects under some page nodes. If you have created an
    app that is responsible for some type of objects in your website, such as `movies`,
    you can easily convert it to a Django CMS app and attach it to one of the pages.
    This will ensure that the root URL of the app is translatable and the menu item
    is highlighted when selected. In this recipe, we will convert the `movies` app
    to a CMS app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the `movies` app that we created in the *Filtering object lists*
    recipe in [Chapter 3](ch03.html "Chapter 3. Forms and Views"), *Forms and Views*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to convert a usual `movies` Django app to a Django CMS app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, remove or comment out the inclusion of the URL configuration
    of the app as it will be included by an apphook in Django CMS, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `cms_app.py` file in the `movies` directory and create `MoviesApphook`
    there, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the newly created apphook in the settings, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in all the movie templates, change the first line to extend from the
    template of the current CMS page instead of `base.html`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apphooks are the interfaces that join the URL configuration of apps to the CMS
    pages. Apphooks need to extend from `CMSApp`. To define the name, which will be
    shown in the **Application** selection list under the **Advanced** settings of
    a page, put the path of the apphook in the `CMS_APPHOOKS` project setting and
    restart the web server; the apphook will appear as one of the applications in
    the advanced page settings. After selecting an application for a page, you need
    to restart the server for the URLs to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: The templates of the app should extend the page template if you want them to
    contain the placeholders or attributes of the page, for example, the `title` or
    the `description` meta tag.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Filtering object lists* recipe in [Chapter 3](ch03.html "Chapter 3. Forms
    and Views"), *Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Attaching your own navigation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching your own navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have an app hooked in the CMS pages, all the URL paths under the page
    node will be controlled by the `urls.py` file of the app. To add some menu items
    under this page, you need to add a dynamical branch of navigation to the page
    tree. In this recipe, we will improve the `movies` app and add new navigation
    items under the **Movies** page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say that we have a URL configuration for different lists of movies:
    editor''s picks, commercial movies, and independent movies, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these two steps to attach the **Editor''s Picks**, **Commercial Movies**,
    and **Independent Movies** menu choices to the navigational menu under the **Movies**
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `menu.py` file in the `movies` app and add the following `MoviesMenu`
    class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Restart the web server and then edit the **Advanced** settings of the **Movies**
    page and select **Movies Menu** for the **Attached** menu setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the frontend, you will see the new menu items attached to the **Movies**
    page, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04912_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Dynamic menus that are attachable to pages need to extend `CMSAttachMenu`,
    define the name by which they will be selected, and define the `get_nodes()` method
    that returns a list of `NavigationNode` objects. The `NavigationNode` class takes
    at least three parameters: the title of the menu item, the URL path of the menu
    item, and the ID of the node. The IDs can be chosen freely with the only requirement
    being that they have to be unique among this attached menu. The other optional
    parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parent_id`: This is the ID of the parent node if you want to create a hierarchical
    dynamical menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent_namespace`: This is the name of another menu if this node is to be
    attached to a different menu tree, for example, the name of this menu is "`MoviesMenu`"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attr`: This is a dictionary of the additional attributes that can be used
    in a template or menu modifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visible`: This sets whether or not the menu item should be visible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other examples of attachable menus, refer to the official documentation
    at [https://django-cms.readthedocs.org/en/latest/how_to/menus.html](https://django-cms.readthedocs.org/en/latest/how_to/menus.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Structuring the page menu* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Converting an app to a CMS app* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own CMS plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django CMS comes with a lot of content plugins that can be used in template
    placeholders, such as the text, flash, picture, and Google map plugins. However,
    for more structured and better styled content, you will need your own custom plugins,
    which are not too difficult to implement. In this recipe, we will see how to create
    a new plugin and have a custom layout for its data, depending on the chosen template
    of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create an `editorial` app and mention it in the `INSTALLED_APPS` setting.
    Also, we will need the `cms/magazine.html` template that was created and mentioned
    in the `CMS_TEMPLATES` setting; you can simply duplicate the `cms/default.html`
    template for this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the `EditorialContent` plugin, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `models.py` file of the newly created app, add the `EditorialContent`
    model extending from `CMSPlugin`. The `EditorialContent` model will have the following
    fields: title, subtitle, description, website, image, image caption, and a CSS
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same app, create a `cms_plugins.py` file and add a `EditorialContentPlugin`
    class extending `CMSPluginBase`. This class is a little bit like `ModelAdmin`—it
    defines the appearance of administration settings for the plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To specify which plugins go to which placeholders, you have to define the `CMS_PLACEHOLDER_CONF`
    setting. You can also define the extra context for the templates of the plugins
    that are rendered in a specific placeholder. Let''s allow `EditorialContentPlugin`
    for the `main_content` placeholder and set the `editorial_content_template` context
    variable for the `main_content` placeholder in the `cms/magazine.html` template,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will create two templates. One of them will be the `editorial_content.html`
    template. It checks whether the `editorial_content_template` context variable
    exists. If the variable exists, it is included. Otherwise, it shows the default
    layout for editorial content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second template is a specific template for the `EditorialContent` plugin
    in the `cms/magazine.html` template. There''s nothing too fancy here, just an
    additional Bootstrap-specific `well` CSS class for the container to make the plugin
    stand out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you go to the **Draft** mode of any CMS page and switch to the **Structure**
    section, you can add the **Editorial Content** plugin to a placeholder. The content
    of this plugin will be rendered with a specified template and it can also be customized,
    depending on the template of the page where the plugin is chosen. For example,
    choose the `cms/magazine.html` template for the **News** page and then add the
    **Editorial Content** plugin. The **News** page will look similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04912_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the **Test Title** with an image and description is the custom plugin
    inserted in the `main_content` placeholder in the `magazine.html` page template.
    If the page template was different, the plugin would be rendered without the Bootstrap-specific
    `well` CSS class; therefore, it would not have a gray background.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating templates for Django CMS* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Structuring the page menu* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new fields to the CMS page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMS pages have several multilingual fields such as title, slug, menu title,
    page title, description meta tag, and overwrite URL. They also have several common
    nonlanguage-specific fields such as template, ID used in template tags, attached
    application, and attached menu. However, that might not be enough for more complex
    websites. Thankfully, Django CMS features a manageable mechanism to add new database
    fields for CMS pages. In this recipe, you will see how to add fields for the CSS
    classes for the navigational menu items and page body.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create the `cms_extensions` app and put it under `INSTALLED_APPS` in the
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a CMS page extension with the CSS class fields for the navigational
    menu items and page body, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `models.py` file, create a `CSSExtension` class extending `PageExtension`
    and put fields for the menu item''s CSS class and `<body>` CSS class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `admin.py` file, let''s add administration options for the `CSSExtension`
    model that we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to show the CSS extension in the toolbar for each page. This
    can be done by putting the following code in the `cms_toolbar.py` file of the
    app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code checks whether the user has the permission to change the current page,
    and if so, it loads the page menu from the current toolbar and adds a new menu
    item, CSS, with the link to create or edit `CSSExtension`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we want to access the CSS extension in the navigation menu in order to attach
    a CSS class, we need to create a menu modifier in the `menu.py` file of the same
    app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will add the body CSS class to the `<body>` element in the `base.html`
    template, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we will modify the `menu.html` file, which is the default template
    for the navigation menu, and add the menu item''s CSS class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PageExtension` class is a model mixin with a one-to-one relationship with
    the `Page` model. To be able to administrate the custom extension model in Django
    CMS, there is a specific `PageExtensionAdmin` class to extend. Then, in the `cms_toolbar.py`
    file, we will create the `CSSExtensionToolbar` class, inheriting from the `CMSToolbar`
    class, to create an item in the Django CMS toolbar. In the `populate()` method,
    we will perform the general routine to check the page permissions and then we
    will add a CSS menu item to the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the administrator has the permission to edit the page, then they will see
    a **CSS** option in the toolbar under the **Page** menu item, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04912_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the administrator clicks on the new **CSS** menu item, a pop-up window
    opens and they can select the **CSS** classes for the navigation menu item and
    body, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04912_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To show a specific CSS class from the `Page` extension in the navigation menu,
    we need to attach the `CSSExtension` object to the navigation items accordingly.
    Then, these objects can be accessed in the `menu.html` template as `{{ child.cssextension
    }}`. In the end, you will have some navigation menu items highlighted, such as
    the **Music** item shown here (depending on your CSS):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04912_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To show a specific CSS class for `<body>` of the current page is much simpler.
    We can use `{{ request.current_page.cssextension.body_css_class }}` right away.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating templates for Django CMS* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
