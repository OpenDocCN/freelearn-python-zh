- en: Chapter 14. Fit and Finish – Unit Testing, Packaging, and Documentation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。完善与测试 - 单元测试、打包和文档
- en: Beyond the Python language and its libraries, there are several other aspects
    to Python programming. We'll start by looking closely at the docstrings, which
    should be viewed as an essential ingredient in every package, module, class, and
    function definition. These have several purposes, one of which is to clarify what
    the object does.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python语言及其库之外，Python编程还有其他几个方面。我们将首先仔细研究文档字符串，它们应被视为每个包、模块、类和函数定义的基本组成部分。它们有几个目的，其中之一是阐明对象的功能。
- en: In this chapter, we'll also look at the different approaches to unit testing.
    The `doctest` and `unittest` modules provide a comprehensive suite of tools. External
    tools like Nose are also widely used.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将探讨单元测试的不同方法。`doctest`和`unittest`模块提供了一套全面的工具。外部工具如Nose也被广泛使用。
- en: We'll also look at how we can leverage the `logging` module as part of a complete
    application. The Python logger is quite sophisticated as well, so we'll focus
    on a few of the essential features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨如何利用`logging`模块作为完整应用程序的一部分。Python的记录器也非常复杂，因此我们将关注一些基本功能。
- en: We'll examine some tools that are used to build Python documentation from the
    embedded docstring comments. Using tools to extract documentation allows us to
    focus on writing proper code and deriving the reference documents from the code.
    In order to create complete documentation—more than just an API reference—many
    developers use the Sphinx tool.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查一些用于从嵌入的文档字符串注释构建Python文档的工具。使用工具提取文档使我们能够专注于编写正确的代码，并从代码中派生出参考文档。为了创建完整的文档——而不仅仅是API参考——许多开发者使用Sphinx工具。
- en: We'll also address the organization of files in a large Python project. Because
    Python is used in so many different contexts and has so many different frameworks,
    the layout for a web application built with Flask will look nothing like a web
    application built with Django. However, there are a few essential principles that
    we can follow for keeping Python programs neat and well organized.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论在大型Python项目中文件的组织结构。由于Python被用于许多不同的环境和框架，使用Flask构建的Web应用程序的布局将与使用Django构建的Web应用程序大相径庭。然而，我们可以遵循一些基本原则，以保持Python程序整洁和井然有序。
- en: Writing docstrings
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写文档字符串
- en: In [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"), *Basic Function
    Definitions*, we noted that all functions should have a docstring that describes
    the function. In [Chapter 11](ch11.html "Chapter 11. Class Definitions"), *Class
    Definitions*, and [Chapter 12](ch12.html "Chapter 12. Scripts, Modules, Packages,
    Libraries, and Applications"), *Scripts, Modules, Packages, Libraries, and Applications*,
    we offered similar advice, without providing many details.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。基本函数定义")，*基本函数定义*中，我们指出所有函数都应该有一个描述函数的文档字符串。在[第11章](ch11.html
    "第11章。类定义")，*类定义*和[第12章](ch12.html "第12章。脚本、模块、包、库和应用程序")，*脚本、模块、包、库和应用程序*中，我们提供了类似的建议，但没有提供很多细节。
- en: The `def` statement and the `class` statement should, universally, be followed
    by a triple-quoted string that describes the function, method, or class. It's
    not required by the language—it's required by all of the people who will try to
    read, understand, extend, improve, or repair our code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`def`语句和`class`语句应该普遍地后面跟着一个三引号字符串，描述函数、方法或类。这不是语言的要求——这是所有试图阅读、理解、扩展、改进或修复我们代码的人的要求。'
- en: 'We''ll revisit an example from [Chapter 11](ch11.html "Chapter 11. Class Definitions"),
    *Class Definitions*, to show the kinds of docstrings that were omitted. Here''s
    how we might create a more complete class definition:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾[第11章](ch11.html "第11章。类定义")中的一个示例，*类定义*，以展示省略的文档字符串类型。以下是我们可能创建的更完整的类定义示例：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this class definition, we've provided four separate docstrings. For the class
    as a whole, we provided an overview of what the class does, plus an example of
    how the class behaves. This is shown as a copy and paste from the Python REPL,
    showing the input prefixed with `>>>` prompts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类定义中，我们提供了四个独立的文档字符串。对于整个类，我们提供了一个概述，说明了类的作用，以及一个展示类行为的示例。这显示了从Python交互式解释器（REPL）复制粘贴的内容，输入前带有`>>>`提示符。
- en: For each method function, we've provided a docstring that shows what the method
    function does. In the case of the `dist()` method, we've included another example
    interaction in the docstring to show an example of the expected behavior of the
    method.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个方法函数，我们提供了一个文档字符串，显示了方法函数的作用。在 `dist()` 方法的例子中，我们在文档字符串中包含了另一个交互示例，以展示该方法预期行为的示例。
- en: The documentation of parameters and return values uses the **ReStructuredText**
    (**RST**) markup language. This is widely used because of tools like `docutils`
    and Sphinx, which can format RST into nice-looking HTML or LaTeX. We'll look at
    RST in the section *Writing documentation with RST markup* later in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和返回值的文档使用 **ReStructuredText** （**RST**） 标记语言。这因其工具如 `docutils` 和 Sphinx 而被广泛使用，这些工具可以将
    RST 格式化为漂亮的 HTML 或 LaTeX。我们将在本章后面的 *使用 RST 标记编写文档* 部分查看 RST。
- en: For now, we can focus on `:param name:` and `:returns:` as markup syntax that
    helps tools understand the semantics of these constructs. The tool can then give
    them special formatting to reflect their meaning.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以关注 `:param name:` 和 `:returns:` 作为帮助工具理解这些构造语义的标记语法。然后，工具可以给予它们特殊的格式化以反映其含义。
- en: Writing unit tests with doctest
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 doctest 编写单元测试
- en: 'It is a widely adopted practice to provide concrete examples of classes and
    functions in docstrings. As shown in the preceding example, we can provide the
    following kind of example text in a docstring:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档字符串中提供类和函数的具体示例是一种广泛采用的实践。正如前面示例所示，我们可以在文档字符串中提供以下类型的示例文本：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A concrete example has many benefits. The goal of Python code is to be beautiful
    and readable. If the code sample is obscure or confusing, this is a design problem
    that really should be resolved. Writing more words in comments to try to explain
    bad code is a symptom of a deeper problem. A concrete example should be as clear
    and expressive as the code itself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 具体示例有许多好处。Python 代码的目标是美观和可读。如果代码示例晦涩或令人困惑，这是一个真正应该解决的问题的设计问题。在注释中写更多文字来尝试解释糟糕的代码是更深层次问题的症状。具体示例应该像代码本身一样清晰和富有表现力。
- en: An additional benefit of concrete examples is that they are test cases. The
    `doctest` module can scan each docstring to locate these examples, build, and
    execute test cases. This will confirm that the output in the example matches the
    actual output.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 具体示例的另一个好处是它们是测试用例。`doctest` 模块可以扫描每个文档字符串以定位这些示例，构建并执行测试用例。这将确认示例中的输出与实际输出相匹配。
- en: 'One common approach to using `doctest` is to include the following in a `library`
    module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `doctest` 的一个常见方法是在 `library` 模块中包含以下内容：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the module is executed as the main script instead of being imported, then
    it will import `doctest`, scan the module for docstrings, and execute all the
    tests in those docstrings. We've set the verbose level to one, which produces
    output that shows the tests in some detail. If we leave the verbose level to it's
    default value of zero, success is silent; not even an `Ok` is displayed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块作为主脚本执行而不是被导入，那么它将导入 `doctest`，扫描模块以查找文档字符串，并执行这些文档字符串中的所有测试。我们已将详细级别设置为一级，这将产生显示测试的详细输出。如果我们保留详细级别为其默认值零，则成功将是静默的；甚至不会显示
    `Ok`。
- en: 'We can also run `doctest` as a command-line application. Here''s an example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将 `doctest` 作为命令行应用程序运行。以下是一个示例：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ve run the `doctest` module as an application, providing it with the name
    of a file that should be examined to locate test examples inside docstrings. The
    output starts with the first example found. The example is this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `doctest` 模块作为应用程序运行，向其提供要检查以定位文档字符串中测试示例的文件名。输出从找到的第一个示例开始。该示例是：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The verbose output shows the expression and the expected results. The output
    of `ok` indicates that the test was passed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 详细输出显示了表达式和预期结果。`ok` 的输出表示测试通过。
- en: What about the one item that had no tests? That's the docstring for the module
    itself. This shows us that our test case coverage is incomplete. We should consider
    adding a test in the module docstring.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么那个没有测试的项目呢？这是模块本身的文档字符串。这表明我们的测试用例覆盖率不完整。我们应该考虑在模块文档字符串中添加一个测试。
- en: The summary showed that 9 items had 19 tests. The items are identified with
    strings such as `ch01_ex1.__test__.assignment`. The special name `__test__` is
    neither a function nor a class; it's a global variable. If there's a variable
    named `__test__`, it must be a dictionary. The keys in the `__test__` dictionary
    are documentation, and the values are strings that must include `doctest` examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 总结显示有 9 个项目有 19 个测试。这些项目用字符串如 `ch01_ex1.__test__.assignment` 来标识。特殊名称 `__test__`
    既不是函数也不是类；它是一个全局变量。如果存在名为 `__test__` 的变量，它必须是一个字典。`__test__` 字典中的键是文档，值是必须包含 `doctest`
    示例的字符串。
- en: 'The `__test__` variable might look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`__test__` 变量可能看起来像这样：'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each key identifies the test. Each value is a triple-quoted string that includes
    a snippet of REPL interaction showing the expected results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键标识一个测试。每个值是一个包含预期结果的 REPL 交互片段的三引号字符串。
- en: As a practical matter, this particular test suffers from one of the potential
    limitations of `doctest` examples.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项实际措施，这个特定的测试受到了 `doctest` 示例潜在局限性之一的影响。
- en: As we noted in [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"),
    *Logic, Comparisons, and Conditions*, we should not use exact equality tests between
    floating point values. The proper way to write a test like this is to use `round(355/113,
    6)` to truncate the trailing digits; the final digits might differ slightly depending
    on the hardware or underlying floating point libraries. It's better to write tests
    that are independent of implementation nuances.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 5 章](ch05.html "第 5 章。逻辑、比较和条件") 中提到的，*逻辑、比较和条件*，我们不应该在浮点值之间使用精确相等测试。编写这种测试的正确方式是使用
    `round(355/113, 6)` 来截断尾数；最终数字可能会因硬件或底层浮点库而略有不同。编写与实现细节无关的测试会更好。
- en: There are a number of potential limitations with `doctest` examples. Dictionary
    keys have no defined order. Therefore, a `doctest` can fail when the keys are
    displayed in an order that differs from the expected output in the test. Similarly,
    set items have no defined order. Additionally, an error traceback message may
    not match precisely because it will have a line like `File "<stdin>", line 1,
    in <module>` that may vary depending on the context in which the test runs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 示例存在一些潜在的局限性。字典键没有定义的顺序。因此，当键以与测试中预期输出不同的顺序显示时，`doctest` 可能会失败。同样，集合项也没有定义的顺序。此外，错误跟踪消息可能不会精确匹配，因为它将包含类似
    `File "<stdin>", line 1, in <module>` 的行，这可能会根据测试运行的上下文而变化。'
- en: 'For some of these potential limitations, `doctest` offers directives that can
    be used to annotate the tests. The directives appear as special comments like
    this: `# doctest: +ELLIPSIS`. This will enable flexible pattern matching to cope
    with the variations in displayed output. For other limitations, we need to construct
    our test cases properly. We can use `sorted(some_dict.values())` to transform
    a dictionary result into a sorted list of tuples where the order is guaranteed.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '对于这些潜在的局限性，`doctest` 提供了可以用来注释测试的指令。这些指令以特殊的注释形式出现，例如：`# doctest: +ELLIPSIS`。这将启用灵活的模式匹配，以应对显示输出的变化。对于其他局限性，我们需要正确构建我们的测试用例。我们可以使用
    `sorted(some_dict.values())` 将字典结果转换为有序的元组列表，其中顺序是有保证的。'
- en: Docstrings are an essential feature of good Python programming. Examples are
    an essential feature of well-written documentation. Given a tool that can verify
    the correctness of the examples, this kind of testing should be considered mandatory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docstrings 是良好 Python 编程的一个基本特性。示例是良好文档的一个基本特性。给定一个可以验证示例正确性的工具，这种测试应该被认为是强制性的。
- en: Using the unittest library for testing
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 unittest 库进行测试
- en: For more complex testing, the `doctest` examples may not provide enough depth
    or flexibility. A docstring with a large number of cases would become too long
    to be effective as documentation. A docstring with complex test setup, teardown,
    or mock objects may not be useful as documentation either.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的测试，`doctest` 示例可能不足以提供深度或灵活性。包含大量案例的文档字符串可能太长，无法作为有效的文档。包含复杂测试设置、拆卸或模拟对象的文档字符串也可能不适用于文档。
- en: For these cases, we'll use the `unittest` module to define test cases and test
    suites. When using `unittest`, we'll generally create separate modules. These
    test modules will contain `TestCase` classes that contain test methods.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，我们将使用 `unittest` 模块来定义测试用例和测试套件。当使用 `unittest` 时，我们通常会创建单独的模块。这些测试模块将包含包含测试方法的
    `TestCase` 类。
- en: 'Here''s a quick overview of a typical test case class definition:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的测试用例类定义的快速概述：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've shown a `setUp()` method and two test methods. The default `runTest()`
    method will search for all methods with a name that begins with `test`; it will
    then run the `setUp()` method that is executed prior to each individual `test...`
    method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了 `setUp()` 方法以及两个测试方法。默认的 `runTest()` 方法将搜索所有以 `test` 开头名称的方法；然后运行在各个
    `test...` 方法之前执行的 `setUp()` 方法。
- en: We can use the Python `assert` statement to compare actual and expected results.
    Because there are so many common comparisons, the `TestCase` class offers handy
    methods for comparing different kinds of expected results with actual results.
    We've shown `assertEqual()` and `assertAlmostEqual()`. Each of these methods parallels
    the `assert` statement—they succeed silently. If there's a problem, they raise
    an `AssertionError` exception.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python 的 `assert` 语句来比较实际和预期结果。因为有很多常见的比较，`TestCase` 类提供了方便的方法来比较不同类型的预期结果与实际结果。我们已经展示了
    `assertEqual()` 和 `assertAlmostEqual()`。这些方法中的每一个都与 `assert` 语句平行——它们无声地成功。如果有问题，它们将引发
    `AssertionError` 异常。
- en: Using the `unittest` module allows us to write voluminous test cases. A `doctest`
    string is most useful when it expresses a few helpful concrete examples. A unit
    test is a better way to include many edge and corner cases.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `unittest` 模块允许我们编写大量的测试用例。`doctest` 字符串在表达几个有用的具体示例时最有用。单元测试是包含许多边缘和角落情况的更好方式。
- en: The `unittest` module is also handy for test examples that involve interaction
    with the filesystem. We might have a `.csv` format file that has a number of examples.
    We can write a `runTest()` method that reads this file and treats each row as
    a test case.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 模块也便于测试涉及与文件系统交互的示例。我们可能有一个包含多个示例的 `.csv` 格式文件。我们可以编写一个 `runTest()`
    方法来读取这个文件，并将每一行作为测试用例处理。'
- en: When pursuing **acceptance test-driven development** (**ATDD**), the test cases
    themselves can become quite complex. The test case setup may involve seeding a
    database with sample data prior to executing a big application feature, and then
    examining the resulting database contents. The essential structure of ATDD testing
    fits the unit testing design patterns offered by the `unittest` module. The "unit"
    under test is not an isolated class; instead, we're testing a complete web API
    or command-line application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在追求**验收测试驱动开发**（**ATDD**）时，测试用例本身可能变得相当复杂。测试用例设置可能涉及在执行大型应用程序功能之前用样本数据填充数据库，然后检查结果数据库的内容。ATDD
    测试的基本结构符合 `unittest` 模块提供的单元测试设计模式。被测试的“单元”不是一个孤立的类；相反，我们正在测试一个完整的 Web API 或命令行应用程序。
- en: Combining doctest and unittest
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合 doctest 和 unittest
- en: We can incorporate `doctest` test cases into the `unittest` suite of tests.
    This assures us that the `doctest` examples are not overlooked when using `unittest`
    cases. We'll do this by using the `TestSuite` class, which can contain other `TestCase`
    classes as well as `TestSuite` classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `doctest` 测试用例纳入 `unittest` 测试套件中。这确保了在使用 `unittest` 测试用例时不会遗漏 `doctest`
    示例。我们将通过使用可以包含其他 `TestCase` 类以及 `TestSuite` 类的 `TestSuite` 类来实现这一点。
- en: 'A `doctest.DocTestSuite` object will create a proper `unittest.TestSuite` method
    from the `doctest` strings embedded in a given module. We can use a function like
    the following to locate all test cases in a large collection of packages and modules:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `doctest.DocTestSuite` 对象将从给定模块中嵌入的 `doctest` 字符串创建一个合适的 `unittest.TestSuite`
    方法。我们可以使用以下类似的功能来定位大量包和模块中的所有测试用例：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function will return a `TestSuite` object built from other `TestSuite`
    objects. This function has five steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将返回一个由其他 `TestSuite` 对象构建的 `TestSuite` 对象。这个函数有五个步骤：
- en: It uses `glob.glob()` to get a list of all matching module names in the packages.
    This particular pattern will locate all of the example code for this book. We
    might have to change this to pass or reject other kinds of names that might be
    available.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `glob.glob()` 来获取包中所有匹配的模块名称列表。这个特定的模式将定位到本书的所有示例代码。我们可能需要更改这个模式以通过或拒绝其他可能存在的名称。
- en: It defines a lambda object that extracts the chapter number from the module,
    ignoring the package. The expression uses `name.partition(".")` to split the complete
    module name into the package, the dot character, and the module name. Item number
    2 from this sequence is the module name. This is partitioned on the `"_"` into
    chapter prefix, underscore, and example suffix. We use item number 0, the chapter
    prefix, as the sort order for the modules.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它定义了一个 lambda 对象，该对象从模块中提取章节号，忽略包。该表达式使用 `name.partition(".")` 将完整的模块名称拆分为包、点字符和模块名称。序列中的第
    2 项是模块名称。这是在 `"_"` 上分割的，包括章节前缀、下划线和示例后缀。我们使用序列中的第 0 项，即章节前缀，作为模块的排序顺序。
- en: The input to the `sorted()` function is a sequence of filenames restructured
    into module names. This transformation involves replacing the `".py"` filename
    suffix and then splitting the filename on the OS path separator ("/" on most OSes,
    but on Windows it is "\") into separate substrings. When we join the substrings
    using "." we get a module name, which we can use for sorting and test case discovery.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sorted()` 函数的输入是一个重新结构化为模块名称的文件名序列。这种转换涉及替换 `".py"` 文件名后缀，然后在操作系统路径分隔符（在大多数操作系统中是
    "/"，但在 Windows 中是 "\") 上分割文件名，得到单独的子字符串。当我们使用 "." 连接这些子字符串时，我们得到一个模块名称，我们可以用它来进行排序和测试用例发现。'
- en: We build a list comprehension of the test suites that can be built from the
    `doctest` examples in each module. This includes over 100 individual tests culled
    from the examples throughout this book.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构建了一个列表推导式，该推导式可以构建每个模块中的 doctest 示例可以构建的测试套件。这包括从本书的示例中提取的超过 100 个单独的测试。
- en: We assemble a single test suite from the list of test suites. This can then
    be executed to confirm that all of the examples produce the expected results.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从测试套件列表中组装一个单独的测试套件。然后可以执行它以确认所有示例都产生预期的结果。
- en: We can merge this doctest `TestSuite` object with a `TestSuite` object built
    from tests based on the `unittest.TestCase` definitions. This complete suite can
    then be executed to show that the code works as expected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个 doctest `TestSuite` 对象与从基于 `unittest.TestCase` 定义的测试构建的 `TestSuite`
    对象合并。然后，这个完整的测试套件可以执行以证明代码按预期工作。
- en: 'We often use something like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用以下类似的方法：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will create a test runner that produces a summary of tests and test failures.
    The `suite()` function—not shown—returns a `TestSuite()` method built from the
    `doctest_suite()` function and a function that scans files for `unittest.TestCase`
    classes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个测试运行器，它可以生成测试和测试失败的摘要。`suite()` 函数（未显示）返回一个由 `doctest_suite()` 函数和一个扫描文件以查找
    `unittest.TestCase` 类的函数构建的 `TestSuite()` 方法。
- en: The output summarizes the tests run and the failures. When we build a comprehensive
    test suite like this, we include both `unittest` and `doctest` cases. This allows
    us to freely mix complex suites with simple docstring examples.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出总结了运行的测试和失败情况。当我们构建这样的综合测试套件时，我们包括 `unittest` 和 `doctest` 测试用例。这允许我们自由地混合复杂的测试套件和简单的文档字符串示例。
- en: Using other add-on test libraries
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他附加测试库
- en: The `doctest` and `unittest` modules allow us to write a number unit tests conveniently.
    In many cases, we want even more sophistication. One of the more popular additional
    features is test discovery. The `nose` package gives us a way to painlessly examine
    modules and packages for tests. See [http://nose.readthedocs.org/en/latest/](http://nose.readthedocs.org/en/latest/)
    for more information.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 和 `unittest` 模块允许我们方便地编写单元测试。在许多情况下，我们希望有更多的复杂性。更受欢迎的附加功能之一是测试发现。`nose`
    包为我们提供了一种轻松检查模块和包以查找测试的方法。有关更多信息，请参阅 [http://nose.readthedocs.org/en/latest/](http://nose.readthedocs.org/en/latest/)。'
- en: There are several benefits of using `nose` as an extension to `unittest`. The
    `nose` module can collect tests from `unittest.TestCase` subclasses, as well as
    simple test functions, and also from test classes that are not subclasses of `unittest.TestCase`.
    We can use `nose` for writing timing tests too—something that can be a little
    awkward in `unittest`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `nose` 作为 `unittest` 的扩展有几个好处。`nose` 模块可以从 `unittest.TestCase` 子类、简单的测试函数以及不是
    `unittest.TestCase` 子类的测试类中收集测试。我们还可以使用 `nose` 来编写计时测试——这在 `unittest` 中可能有点尴尬。
- en: Because `nose` is particularly good at collecting tests automatically, there's
    no need to manually collect test cases into test suites; we don't need some of
    the examples shown earlier. Furthermore, `nose` supports test fixtures at the
    package, module, and class level, so expensive initialization can be done as infrequently
    as possible. This allows us to populate a test database for multiple modules of
    related testing—something that `unittest` can't do as easily.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`nose`特别擅长自动收集测试，因此无需手动将测试用例收集到测试套件中；我们不需要之前展示的一些示例。此外，`nose`支持在包、模块和类级别上使用测试固定装置，因此可以尽可能少地执行昂贵的初始化。这使得我们可以为多个相关测试模块填充测试数据库——这是`unittest`难以轻松做到的。
- en: Logging events and conditions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录事件和条件
- en: A well-behaved application can produce a variety of processing summaries. For
    command-line applications, the summary might be a simple "everything went okay"
    message. For GUI applications, this summary is inverted—silence means things are
    working well, and a dialog box with an error message indicates things didn't work
    properly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表现良好的应用程序可以生成各种处理摘要。对于命令行应用程序，摘要可能是一条简单的“一切正常”的消息。对于图形用户界面应用程序，这种摘要正好相反——沉默意味着一切正常，而带有错误消息的对话框则表明事情没有按预期进行。
- en: In some command-line processing contexts, the summary might include some additional
    details on the number of objects that were processed. In financial applications,
    some counts and the total values of various objects must balance properly to show
    that all objects that were received as input became proper outputs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些命令行处理上下文中，摘要可能包括一些关于处理的对象数量的额外细节。在金融应用程序中，一些计数和不同对象的总额必须正确平衡，以显示所有接收到的输入对象都变成了适当的输出。
- en: When we need additional details, beyond a simple "works or breaks" summary,
    we can leverage the `print()` function. The output can be redirected to the `sys.stderr`
    file to produce a handy log. While this is effective in small programs, it has
    a number of desirable features offered by the `logging` module.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要比简单的“工作或失败”摘要更多的详细信息时，我们可以利用`print()`函数。输出可以重定向到`sys.stderr`文件以生成一个方便的日志。虽然这在小型程序中很有效，但`logging`模块提供了许多期望的特性。
- en: 'The first step in using the `logging` module is to create logger objects and
    use the loggers to produce useful output. Each logger has a name that fits into
    a tree using names delimited with the `.` character. The logger names parallel
    the standards for module names; we can use the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`logging`模块的第一步是创建记录器对象并使用记录器生成有用的输出。每个记录器都有一个名称，该名称使用`.`字符分隔，并适合到一个树结构中。记录器名称与模块名称的标准平行；我们可以使用以下方法：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will create a module-wide `logger` object with a name that matches the
    module name. The root logger has the name `""`; that is, an empty string.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个与模块名称匹配的模块级`logger`对象。根记录器具有名称`""`；即一个空字符串。
- en: We can also create class-wide loggers as well as object-specific loggers. We
    can, for example, create a logger during the `__init__()` method part of object
    creation. We might use the `__qualname__` attribute of an object's class to provide
    a qualified class name for the logger. To create a logger for a specific instance
    of a class, we can suffix the class name with the `.` character and some unique
    identifier for the instance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建类级别的记录器以及对象特定的记录器。例如，我们可以在对象创建的`__init__()`方法部分创建一个记录器。我们可能会使用对象类的`__qualname__`属性为记录器提供有资格的类名。要为类的特定实例创建记录器，我们可以在类名后缀一个`.`字符和一些唯一的实例标识符。
- en: 'We use the logger to create messages with a severity level from `DEBUGGING`
    (the least severe) to `FATAL` or `CRITICAL` (synonyms for the most severe level.)
    We do this with a method name that reflects the severity level. Messages are created
    with methods like these:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用记录器创建具有从`DEBUGGING`（最不严重）到`FATAL`或`CRITICAL`（最严重级别的同义词）严重级别的消息。我们通过反映严重级别的名称来执行此操作。使用如下方法创建消息：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `logging` module has a default configuration that does nothing. This means
    that we can include logging requests in an application without any further consideration.
    As long as we properly create a `Logger` instance and use methods of the logger
    instance, we don't need to do anything else.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块有一个默认配置，不执行任何操作。这意味着我们可以在应用程序中包含日志请求而不需要进一步考虑。只要我们正确创建`Logger`实例并使用记录器实例的方法，我们就不需要做任何事情。'
- en: To see output, we'll need to create a handler that will write the messages to
    a particular stream or file. This is usually done as part of the overall configuration
    of the logging system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看输出，我们需要创建一个处理器，将消息写入特定的流或文件。这通常作为日志系统整体配置的一部分来完成。
- en: Configuring the logging system
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置日志系统
- en: We have several ways to configure the logging system. For small applications,
    we might provide the logging setup using the `logging.basicConfig()` function.
    We've shown this in [Chapter 13](ch13.html "Chapter 13. Metaprogramming and Decorators"),
    *Metaprogramming and Decorators*. A simple initialization will send the output
    to the standard error stream and explicitly set a level that filters the messages
    being displayed. This uses the `stream` and `level` keyword arguments.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种配置日志系统的方式。对于小型应用程序，我们可能会使用`logging.basicConfig()`函数来提供日志设置。这在[第13章](ch13.html
    "第13章。元编程和装饰器") *元编程和装饰器* 中已经展示过。简单的初始化会将输出发送到标准错误流，并显式设置一个级别来过滤显示的消息。这使用了`stream`和`level`关键字参数。
- en: 'A slightly more complex configuration might look like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微复杂一些的配置可能看起来像这样：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've opened a named file, assigned a mode of `a` to append, and set the level
    to show messages with a severity that's equal to or greater than `INFO`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经打开了一个命名的文件，将其模式设置为`a`以追加，并将级别设置为显示严重性等于或大于`INFO`的消息。
- en: 'Since each individual logger is named, we can adjust the level of detail for
    a specific logger. We can include a line like the following to enable debugging
    on a specific logger:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个单独的日志记录器都有名称，我们可以调整特定日志记录器的详细程度。我们可以包含以下类似行来在特定日志记录器上启用调试：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This allows us to see details for a specific class or module. This is often
    a great help when debugging.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们查看特定类或模块的详细信息。这在调试时通常非常有帮助。
- en: The `logging.handlers` module offers a large number of handlers for routing,
    printing, or saving the sequence of logging messages. The preceding example shows
    the file handler. The stream handler is used to write to the standard error stream.
    In some cases, we need to have multiple handlers. We can apply filters to each
    handler, so that the handlers will reflect different kinds of details.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging.handlers`模块提供了大量用于路由、打印或保存日志消息序列的处理程序。前面的示例显示了文件处理器。流处理器用于写入标准错误流。在某些情况下，我们需要有多个处理器。我们可以对每个处理器应用过滤器，这样处理器将反映不同类型的细节。'
- en: Logging configurations often get too complex for the `basicConfig()` function.
    The `logging.config` module offers several functions that can be used to configure
    the logging for an application. One general approach is to use the `logging.config.dictConfig()`
    function. We can create a Python `dict` object directly in Python, or read some
    serialized version of the `dict` object. The standard library documentation uses
    examples written in the YAML markup language because it's simple and flexible.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 日志配置通常过于复杂，无法使用`basicConfig()`函数。`logging.config`模块提供了几个可用于配置应用程序日志的函数。一种通用方法是用`logging.config.dictConfig()`函数。我们可以在Python中直接创建Python
    `dict`对象，或者读取`dict`对象的某些序列化版本。标准库文档使用YAML标记语言编写的示例，因为它简单且灵活。
- en: 'We might do something like this to create a configuration object:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能像这样创建一个配置对象：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This object has the required `version` attribute to specify the structure of
    the configuration. A single handler is defined; it's named `console` and uses
    `logging.StreamHandler` is used to write to the standard error stream. The root
    logger is configured to use the `console` handler. The severity level is defined
    to include any message at or above the `DEBUG` level.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象具有所需的`version`属性，用于指定配置的结构。定义了一个单个处理器；它被命名为`console`，并使用`logging.StreamHandler`写入标准错误流。根日志记录器配置为使用`console`处理器。严重级别被定义为包括任何`DEBUG`级别或以上的消息。
- en: Only in configuration files is the root logger named `'root'`. In application
    code, the root logger is named with an empty string.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在配置文件中，根日志记录器才被命名为`'root'`。在应用程序代码中，根日志记录器使用空字符串命名。
- en: Larger and more sophisticated applications will rely on logging configurations
    in external configuration files. This permits flexible and sophisticated logging
    configurations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 较大且更复杂的应用程序将依赖于外部配置文件中的日志配置。这允许灵活且复杂的日志配置。
- en: Writing documentation with RST markup
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RST标记编写文档
- en: While Python code should be beautiful and informative, it doesn't easily provide
    background or context to show why a particular algorithm or data structure was
    chosen. We often need to provide these additional details to help people maintain,
    extend, and make effective use of our software. While we can include a lot of
    information in a module docstring, it seems best to keep docstrings focused on
    implementation details, and provide the additional material separately.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python代码应该是美观且富有信息的，但它并不容易提供背景或上下文来展示为什么选择特定的算法或数据结构。我们经常需要提供这些额外的细节来帮助人们维护、扩展并有效地使用我们的软件。虽然我们可以在模块文档字符串中包含大量信息，但似乎最好将文档字符串集中在实现细节上，并单独提供额外的材料。
- en: We can write additional documentation in a variety of formats. We can use a
    sophisticated editor with complex file formats, or we can use simple text editors
    and plain text format. We can even write our documentation entirely in HTML. Python
    also offers a hybrid approach—we can write using a text editor with simplified
    **ReStructuredText** (**RST**) markup, and use the `docutils` tools to create
    nice-looking HTML pages or LaTeX files suitable for publication from that markup.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用各种格式编写额外的文档。我们可以使用具有复杂文件格式的复杂编辑器，或者我们可以使用简单的文本编辑器和纯文本格式。我们甚至可以完全用HTML编写我们的文档。Python还提供了一种混合方法——我们可以使用带有简化**ReStructuredText**（**RST**）标记的文本编辑器来编写，并使用`docutils`工具从该标记创建漂亮的HTML页面或适合出版的LaTeX文件。
- en: The RST markup language is widely used for creating Python documentation. This
    markup allows us to write plain text, while adhering to a few formatting rules.
    In the next section, we'll look at using the `docutils` tools to parse the RST
    and create an output document.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: RST标记语言被广泛用于创建Python文档。这种标记允许我们编写纯文本，同时遵守一些格式规则。在下一节中，我们将探讨使用`docutils`工具解析RST并创建输出文档。
- en: The rules of RST markup are simple. There is paragraph-level markup that applies
    to big blocks of text. Paragraphs must be separated by blank lines. When a line
    is "underlined" with a sequence of characters, it is taken as a heading. When
    a paragraph starts with an isolated punctuation mark, it's a bullet. When a paragraph
    starts with a letter or digit, and a punctuation mark, this indicates numbers
    instead of bullets. The `docutils` `rst2html.py` tool transforms each paragraph
    of the input to the proper kind of HTML structure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: RST标记的规则很简单。存在段落级别的标记，适用于大块文本。段落必须由空白行分隔。当一行被字符序列“下划”时，它被视为标题。当一个段落以一个独立的标点符号开头时，它是一个项目符号。当一个段落以字母或数字开头，后面跟着一个标点符号时，这表示数字而不是项目符号。`docutils`的`rst2html.py`工具将输入的每个段落转换为适当的HTML结构。
- en: There are many paragraph-level "directives" that can be used to insert an image,
    a table, an equation, or a large block of code. These directives are prefixed
    with `..` and end with `::`. We might use the directive `.. contents::` to add
    the table of contents to our document.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多段落级别的“指令”可以用来插入图像、表格、方程式或大块代码。这些指令以前缀`..`开头，以`::`结尾。我们可能使用指令`.. contents::`来将目录添加到我们的文档中。
- en: 'We can write inline markup inside the body of a paragraph. Inline markup includes
    a few simple constructs. If we surround a word with the `*` character, like `*this*`,
    we''ll see the word in an *italic*-style font in the final document; we can use
    `**bold**` for **bold** characters. If we want to write a `*` character without
    confusing the tool, we can escape it with the `\` character. In many cases, however,
    we''ll need to use a more complex semantic markup that looks like this: `` :code:`code
    sample` ``. This includes the text role, `:code:`, as a prefix that shows how
    to classify the marked characters; the content is surrounded by the `` ` `` character.
    The text roles of `:code:` and `:math:` are widely used.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在段落的主体内编写内联标记。内联标记包括一些简单的结构。如果我们用`*`字符包围一个单词，如`*this*`，我们将在最终文档中看到以*斜体*风格的字体显示的单词；我们可以使用`**bold**`来表示**粗体**字符。如果我们想在不混淆工具的情况下写入`*`字符，我们可以用`\`字符来转义它。然而，在许多情况下，我们需要使用更复杂的语义标记，如下所示：``
    :code:`code sample` ``。这包括文本角色`:code:`作为前缀，显示如何分类标记的字符；内容被`` ` ``字符包围。`:code:``和`:math:`的文本角色被广泛使用。
- en: When we write a docstring, we'll often use additional RST markup. We'll use
    `:param name:` when defining the parameter to a function or class method. We use
    `:returns:` to annotate the return values from a function. When we provide this
    additional markup, we're assured that various formatting tools will produce elegant
    documentation from our docstrings.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写文档字符串时，我们通常会使用额外的RST标记。当我们定义函数或类方法的参数时，我们会使用`:param name:`。我们使用`:returns:`来注释函数的返回值。当我们提供这些额外的标记时，我们可以确保各种格式化工具能够从我们的文档字符串中生成优雅的文档。
- en: 'Here''s an example of what an RST file might contain:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个RST文件可能包含的示例：
- en: '[PRE14] for more complex semantic markup.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]以获取更复杂的语义标记。'
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: MacBookPro-SLott:Chapter_14 slott$ rst2html.py ch14_doc.rst ch14_doc.rst.html
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: MacBookPro-SLott:Chapter_14 slott$ rst2html.py ch14_doc.rst ch14_doc.rst.html
- en: '```'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We've provided the `rst2html.py` command. We've named the input file and the
    output file. This will use default values for the style sheet, and other optional
    features for the resulting document. We can configure the output through the command
    line or by providing a configuration file that assures a common look for all of
    our generated HTML files.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了`rst2html.py`命令。我们已命名了输入文件和输出文件。这将使用默认的样式表值，并为生成的文档提供其他可选功能。我们可以通过命令行或提供配置文件来配置输出，以确保所有生成的HTML文件具有统一的样式。
- en: To create LaTeX, we can use the `rst2latex.py` or `rst2xetex.py` tool, and then
    a LaTeX formatter. TeX Live distribution works nicely for creating a PDF file
    from LaTeX. See [https://www.tug.org/texlive/](https://www.tug.org/texlive/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建LaTeX，我们可以使用`rst2latex.py`或`rst2xetex.py`工具，然后使用LaTeX格式化器。TeX Live发行版非常适合从LaTeX创建PDF文件。请参阅[https://www.tug.org/texlive/](https://www.tug.org/texlive/)。
- en: For large and complex documents, creating a single RST file isn't ideal. While
    we can use the `.. include::` directive to insert material from separate files,
    the document must be built as a whole, which requires a large amount of memory;
    rebuilding a document after a small change might require a disproportionate amount
    of processing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型且复杂的文档，创建单个RST文件并不是最佳选择。虽然我们可以使用`.. include::`指令从单独的文件中插入内容，但文档必须作为一个整体来构建，这需要大量的内存；在文档进行小幅度修改后重新构建可能需要不成比例的处理量。
- en: For a multipage website, we have to use a tool like Make, Ant, or SCons to rebuild
    the relevant HTML pages when a source RST file has been updated. This is the kind
    of overhead that calls out for a tool to automate and simplify production of large
    or complex documents.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多页网站，我们必须使用像Make、Ant或SCons这样的工具来在源RST文件更新后重新构建相关的HTML页面。这种开销呼唤一个工具来自动化和简化大型或复杂文档的生产。
- en: Using the Sphinx tool
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sphinx工具
- en: The Sphinx tool allows us to easily build multipage websites or complex documents.
    For more information, see [http://sphinx-doc.org](http://sphinx-doc.org). When
    we install Sphinx using `pip` or `easy_install`, the installer will also include
    `docutils` for us.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx工具使我们能够轻松构建多页网站或复杂文档。有关更多信息，请参阅[http://sphinx-doc.org](http://sphinx-doc.org)。当我们使用`pip`或`easy_install`安装Sphinx时，安装程序也会为我们包括`docutils`。
- en: To create sophisticated documentation, we'll start with the `sphinx-quickstart`
    script. This application will build the template file structure, the configuration
    files, and a Makefile that we can use to rebuild our documents efficiently.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建复杂的文档，我们将从`sphinx-quickstart`脚本开始。此应用程序将构建模板文件结构、配置文件以及一个Makefile，我们可以使用它来高效地重新构建我们的文档。
- en: Sphinx adds a large number of directives and text roles to the basics of RST.
    These additional roles and directives make it easier to write about code with
    properly formatted references to modules, classes, and functions. Sphinx simplifies
    inter-document references—we can have multiple documents with consistent references
    to a target location; we can move the target and the references will all be updated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx在RST的基本指令和文本角色中添加了大量指令。这些额外的角色和指令使得编写关于代码的内容变得更加容易，可以正确地引用模块、类和函数。Sphinx简化了文档间的引用——我们可以拥有多个文档，它们对目标位置的引用保持一致；我们可以移动目标，所有引用都将自动更新。
- en: The `sphinx-build` command is used to construct the target files from the RST
    source. Sphinx can build over a dozen different kinds of target documents, making
    it a versatile tool.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sphinx-build`命令从RST源文件构建目标文件。Sphinx可以构建十几种不同类型的目标文档，使其成为一个多功能的工具。
- en: The Python documentation is built with Sphinx. This means that our projects
    can include documentation that looks as polished and elegant as Python's documentation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Python文档是用Sphinx构建的。这意味着我们的项目可以包含看起来像Python文档一样光鲜和优雅的文档。
- en: Organizing Python code
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织Python代码
- en: Python programs should be beautiful. To that end, the language has few syntactic
    overheads; we should be able to write short scripts without unpleasant boilerplate.
    The principle is sometimes articulated as *Simple things should be simple*. The
    "Hello World" script really is a single line of code that uses the `print()` function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序应该是美丽的。为此，语言有很少的语法开销；我们应该能够编写简短的脚本而不需要不愉快的模板代码。这个原则有时被阐述为“简单的事情应该简单”。“Hello
    World”脚本实际上是一行代码，它使用了`print()`函数。
- en: 'A more complex file will generally have a few major sections:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的文件通常有几个主要部分：
- en: A `!#` line, often `#!/usr/bin/env python3`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行`!#`，通常是`#!/usr/bin/env python3`。
- en: A docstring comment explaining what the module does.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个注释文档字符串，解释模块的功能。
- en: The function or class definitions. We often group multiple functions and classes
    into a single module. The module is the proper unit of reuse in Python.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数或类的定义。我们通常将多个函数和类组合成一个模块。在Python中，模块是重用的适当单元。
- en: If the module can be run as a main script, we'll include an `if __name__ ==
    "__main__":` section that defines the file's behavior when run as the main script.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模块可以作为主脚本运行，我们将包括一个`if __name__ == "__main__":`部分，该部分定义了文件作为主脚本运行时的行为。
- en: Many applications are too complex for a single file. When designing larger applications,
    the Pythonic ideal is to keep the resulting structure as flat as possible. While
    the language supports nested packages, deep nesting is not seen as desirable.
    In [Chapter 12](ch12.html "Chapter 12. Scripts, Modules, Packages, Libraries,
    and Applications"), *Scripts, Modules, Packages, Libraries, and Applications*,
    we looked at the details of defining modules and packages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序对于单个文件来说过于复杂。在设计较大的应用程序时，Python的理想是尽可能保持结果结构尽可能扁平。虽然语言支持嵌套包，但深度嵌套并不被视为理想。在[第12章](ch12.html
    "第12章。脚本、模块、包、库和应用")中，我们探讨了定义模块和包的细节。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've looked at several features of polished and complete Python
    projects. The most important feature of working code is a suite of unit tests
    that demonstrate that the code works. Code without test cases simply cannot be
    trusted. In order to make use of any software, we must have tests that show us
    that the software is trustworthy.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了几个光鲜和完整的Python项目的特性。工作代码最重要的特性是一套单元测试，它证明了代码是有效的。没有测试用例的代码根本无法信任。为了使用任何软件，我们必须有显示软件是可信的测试。
- en: We've looked at including tests in docstrings. The `doctest` tool can locate
    these tests and execute them. We've looked at creating `unittest.TestCase` classes.
    We can combine the two into a script that will locate all `doctest` and `unittest`
    test cases into a single master test suite.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了在文档字符串中包含测试。`doctest`工具可以定位这些测试并执行它们。我们已经探讨了创建`unittest.TestCase`类。我们可以将两者结合到一个脚本中，该脚本将定位所有`doctest`和`unittest`测试用例到一个单独的主测试套件中。
- en: One other feature of good software is some explanation of how to install and
    use the software. This may be as short as a `README` file that provides basic
    information. Often, however, we need a more sophisticated document that provides
    a variety of additional information. We might want to provide context, design
    background, or examples that are too big to be packaged into module or class docstrings.
    We'll often write documentation using tools above and beyond the basic components
    that come with Python.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的一个其他特点是关于如何安装和使用软件的解释。这可能只是一个提供基本信息的`README`文件。然而，通常我们需要一个更复杂的文档，它提供了各种附加信息。我们可能希望提供背景、设计背景或太大而无法打包到模块或类文档字符串中的示例。我们通常会使用超出Python基本组件的工具来编写文档。
- en: In [Chapter 15](ch15.html "Chapter 15. Next Steps"), *Next Steps*, we'll look
    at the next steps in our exploration of Python. Once we've mastered the essentials,
    we need to add depth to the areas that are relevant to the problems we need to
    solve. We might want to study big data applications, web applications, or game
    development. Each of these more specialized areas will involve additional Python
    concepts, tools, and frameworks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch15.html "第15章。下一步")，“下一步”，我们将探讨Python探索的下一步。一旦我们掌握了基础知识，我们需要加深与我们需要解决的问题相关的领域的深度。我们可能想要研究大数据应用、Web应用或游戏开发。这些更专业化的领域将涉及额外的Python概念、工具和框架。
