- en: Chapter 14. Fit and Finish – Unit Testing, Packaging, and Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond the Python language and its libraries, there are several other aspects
    to Python programming. We'll start by looking closely at the docstrings, which
    should be viewed as an essential ingredient in every package, module, class, and
    function definition. These have several purposes, one of which is to clarify what
    the object does.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll also look at the different approaches to unit testing.
    The `doctest` and `unittest` modules provide a comprehensive suite of tools. External
    tools like Nose are also widely used.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at how we can leverage the `logging` module as part of a complete
    application. The Python logger is quite sophisticated as well, so we'll focus
    on a few of the essential features.
  prefs: []
  type: TYPE_NORMAL
- en: We'll examine some tools that are used to build Python documentation from the
    embedded docstring comments. Using tools to extract documentation allows us to
    focus on writing proper code and deriving the reference documents from the code.
    In order to create complete documentation—more than just an API reference—many
    developers use the Sphinx tool.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also address the organization of files in a large Python project. Because
    Python is used in so many different contexts and has so many different frameworks,
    the layout for a web application built with Flask will look nothing like a web
    application built with Django. However, there are a few essential principles that
    we can follow for keeping Python programs neat and well organized.
  prefs: []
  type: TYPE_NORMAL
- en: Writing docstrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"), *Basic Function
    Definitions*, we noted that all functions should have a docstring that describes
    the function. In [Chapter 11](ch11.html "Chapter 11. Class Definitions"), *Class
    Definitions*, and [Chapter 12](ch12.html "Chapter 12. Scripts, Modules, Packages,
    Libraries, and Applications"), *Scripts, Modules, Packages, Libraries, and Applications*,
    we offered similar advice, without providing many details.
  prefs: []
  type: TYPE_NORMAL
- en: The `def` statement and the `class` statement should, universally, be followed
    by a triple-quoted string that describes the function, method, or class. It's
    not required by the language—it's required by all of the people who will try to
    read, understand, extend, improve, or repair our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll revisit an example from [Chapter 11](ch11.html "Chapter 11. Class Definitions"),
    *Class Definitions*, to show the kinds of docstrings that were omitted. Here''s
    how we might create a more complete class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this class definition, we've provided four separate docstrings. For the class
    as a whole, we provided an overview of what the class does, plus an example of
    how the class behaves. This is shown as a copy and paste from the Python REPL,
    showing the input prefixed with `>>>` prompts.
  prefs: []
  type: TYPE_NORMAL
- en: For each method function, we've provided a docstring that shows what the method
    function does. In the case of the `dist()` method, we've included another example
    interaction in the docstring to show an example of the expected behavior of the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation of parameters and return values uses the **ReStructuredText**
    (**RST**) markup language. This is widely used because of tools like `docutils`
    and Sphinx, which can format RST into nice-looking HTML or LaTeX. We'll look at
    RST in the section *Writing documentation with RST markup* later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we can focus on `:param name:` and `:returns:` as markup syntax that
    helps tools understand the semantics of these constructs. The tool can then give
    them special formatting to reflect their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests with doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a widely adopted practice to provide concrete examples of classes and
    functions in docstrings. As shown in the preceding example, we can provide the
    following kind of example text in a docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A concrete example has many benefits. The goal of Python code is to be beautiful
    and readable. If the code sample is obscure or confusing, this is a design problem
    that really should be resolved. Writing more words in comments to try to explain
    bad code is a symptom of a deeper problem. A concrete example should be as clear
    and expressive as the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: An additional benefit of concrete examples is that they are test cases. The
    `doctest` module can scan each docstring to locate these examples, build, and
    execute test cases. This will confirm that the output in the example matches the
    actual output.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common approach to using `doctest` is to include the following in a `library`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the module is executed as the main script instead of being imported, then
    it will import `doctest`, scan the module for docstrings, and execute all the
    tests in those docstrings. We've set the verbose level to one, which produces
    output that shows the tests in some detail. If we leave the verbose level to it's
    default value of zero, success is silent; not even an `Ok` is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also run `doctest` as a command-line application. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve run the `doctest` module as an application, providing it with the name
    of a file that should be examined to locate test examples inside docstrings. The
    output starts with the first example found. The example is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The verbose output shows the expression and the expected results. The output
    of `ok` indicates that the test was passed.
  prefs: []
  type: TYPE_NORMAL
- en: What about the one item that had no tests? That's the docstring for the module
    itself. This shows us that our test case coverage is incomplete. We should consider
    adding a test in the module docstring.
  prefs: []
  type: TYPE_NORMAL
- en: The summary showed that 9 items had 19 tests. The items are identified with
    strings such as `ch01_ex1.__test__.assignment`. The special name `__test__` is
    neither a function nor a class; it's a global variable. If there's a variable
    named `__test__`, it must be a dictionary. The keys in the `__test__` dictionary
    are documentation, and the values are strings that must include `doctest` examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__test__` variable might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each key identifies the test. Each value is a triple-quoted string that includes
    a snippet of REPL interaction showing the expected results.
  prefs: []
  type: TYPE_NORMAL
- en: As a practical matter, this particular test suffers from one of the potential
    limitations of `doctest` examples.
  prefs: []
  type: TYPE_NORMAL
- en: As we noted in [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"),
    *Logic, Comparisons, and Conditions*, we should not use exact equality tests between
    floating point values. The proper way to write a test like this is to use `round(355/113,
    6)` to truncate the trailing digits; the final digits might differ slightly depending
    on the hardware or underlying floating point libraries. It's better to write tests
    that are independent of implementation nuances.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of potential limitations with `doctest` examples. Dictionary
    keys have no defined order. Therefore, a `doctest` can fail when the keys are
    displayed in an order that differs from the expected output in the test. Similarly,
    set items have no defined order. Additionally, an error traceback message may
    not match precisely because it will have a line like `File "<stdin>", line 1,
    in <module>` that may vary depending on the context in which the test runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some of these potential limitations, `doctest` offers directives that can
    be used to annotate the tests. The directives appear as special comments like
    this: `# doctest: +ELLIPSIS`. This will enable flexible pattern matching to cope
    with the variations in displayed output. For other limitations, we need to construct
    our test cases properly. We can use `sorted(some_dict.values())` to transform
    a dictionary result into a sorted list of tuples where the order is guaranteed.'
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings are an essential feature of good Python programming. Examples are
    an essential feature of well-written documentation. Given a tool that can verify
    the correctness of the examples, this kind of testing should be considered mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Using the unittest library for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more complex testing, the `doctest` examples may not provide enough depth
    or flexibility. A docstring with a large number of cases would become too long
    to be effective as documentation. A docstring with complex test setup, teardown,
    or mock objects may not be useful as documentation either.
  prefs: []
  type: TYPE_NORMAL
- en: For these cases, we'll use the `unittest` module to define test cases and test
    suites. When using `unittest`, we'll generally create separate modules. These
    test modules will contain `TestCase` classes that contain test methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick overview of a typical test case class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've shown a `setUp()` method and two test methods. The default `runTest()`
    method will search for all methods with a name that begins with `test`; it will
    then run the `setUp()` method that is executed prior to each individual `test...`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Python `assert` statement to compare actual and expected results.
    Because there are so many common comparisons, the `TestCase` class offers handy
    methods for comparing different kinds of expected results with actual results.
    We've shown `assertEqual()` and `assertAlmostEqual()`. Each of these methods parallels
    the `assert` statement—they succeed silently. If there's a problem, they raise
    an `AssertionError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `unittest` module allows us to write voluminous test cases. A `doctest`
    string is most useful when it expresses a few helpful concrete examples. A unit
    test is a better way to include many edge and corner cases.
  prefs: []
  type: TYPE_NORMAL
- en: The `unittest` module is also handy for test examples that involve interaction
    with the filesystem. We might have a `.csv` format file that has a number of examples.
    We can write a `runTest()` method that reads this file and treats each row as
    a test case.
  prefs: []
  type: TYPE_NORMAL
- en: When pursuing **acceptance test-driven development** (**ATDD**), the test cases
    themselves can become quite complex. The test case setup may involve seeding a
    database with sample data prior to executing a big application feature, and then
    examining the resulting database contents. The essential structure of ATDD testing
    fits the unit testing design patterns offered by the `unittest` module. The "unit"
    under test is not an isolated class; instead, we're testing a complete web API
    or command-line application.
  prefs: []
  type: TYPE_NORMAL
- en: Combining doctest and unittest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can incorporate `doctest` test cases into the `unittest` suite of tests.
    This assures us that the `doctest` examples are not overlooked when using `unittest`
    cases. We'll do this by using the `TestSuite` class, which can contain other `TestCase`
    classes as well as `TestSuite` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `doctest.DocTestSuite` object will create a proper `unittest.TestSuite` method
    from the `doctest` strings embedded in a given module. We can use a function like
    the following to locate all test cases in a large collection of packages and modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will return a `TestSuite` object built from other `TestSuite`
    objects. This function has five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses `glob.glob()` to get a list of all matching module names in the packages.
    This particular pattern will locate all of the example code for this book. We
    might have to change this to pass or reject other kinds of names that might be
    available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It defines a lambda object that extracts the chapter number from the module,
    ignoring the package. The expression uses `name.partition(".")` to split the complete
    module name into the package, the dot character, and the module name. Item number
    2 from this sequence is the module name. This is partitioned on the `"_"` into
    chapter prefix, underscore, and example suffix. We use item number 0, the chapter
    prefix, as the sort order for the modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The input to the `sorted()` function is a sequence of filenames restructured
    into module names. This transformation involves replacing the `".py"` filename
    suffix and then splitting the filename on the OS path separator ("/" on most OSes,
    but on Windows it is "\") into separate substrings. When we join the substrings
    using "." we get a module name, which we can use for sorting and test case discovery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We build a list comprehension of the test suites that can be built from the
    `doctest` examples in each module. This includes over 100 individual tests culled
    from the examples throughout this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We assemble a single test suite from the list of test suites. This can then
    be executed to confirm that all of the examples produce the expected results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can merge this doctest `TestSuite` object with a `TestSuite` object built
    from tests based on the `unittest.TestCase` definitions. This complete suite can
    then be executed to show that the code works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We often use something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will create a test runner that produces a summary of tests and test failures.
    The `suite()` function—not shown—returns a `TestSuite()` method built from the
    `doctest_suite()` function and a function that scans files for `unittest.TestCase`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: The output summarizes the tests run and the failures. When we build a comprehensive
    test suite like this, we include both `unittest` and `doctest` cases. This allows
    us to freely mix complex suites with simple docstring examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using other add-on test libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `doctest` and `unittest` modules allow us to write a number unit tests conveniently.
    In many cases, we want even more sophistication. One of the more popular additional
    features is test discovery. The `nose` package gives us a way to painlessly examine
    modules and packages for tests. See [http://nose.readthedocs.org/en/latest/](http://nose.readthedocs.org/en/latest/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: There are several benefits of using `nose` as an extension to `unittest`. The
    `nose` module can collect tests from `unittest.TestCase` subclasses, as well as
    simple test functions, and also from test classes that are not subclasses of `unittest.TestCase`.
    We can use `nose` for writing timing tests too—something that can be a little
    awkward in `unittest`.
  prefs: []
  type: TYPE_NORMAL
- en: Because `nose` is particularly good at collecting tests automatically, there's
    no need to manually collect test cases into test suites; we don't need some of
    the examples shown earlier. Furthermore, `nose` supports test fixtures at the
    package, module, and class level, so expensive initialization can be done as infrequently
    as possible. This allows us to populate a test database for multiple modules of
    related testing—something that `unittest` can't do as easily.
  prefs: []
  type: TYPE_NORMAL
- en: Logging events and conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A well-behaved application can produce a variety of processing summaries. For
    command-line applications, the summary might be a simple "everything went okay"
    message. For GUI applications, this summary is inverted—silence means things are
    working well, and a dialog box with an error message indicates things didn't work
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: In some command-line processing contexts, the summary might include some additional
    details on the number of objects that were processed. In financial applications,
    some counts and the total values of various objects must balance properly to show
    that all objects that were received as input became proper outputs.
  prefs: []
  type: TYPE_NORMAL
- en: When we need additional details, beyond a simple "works or breaks" summary,
    we can leverage the `print()` function. The output can be redirected to the `sys.stderr`
    file to produce a handy log. While this is effective in small programs, it has
    a number of desirable features offered by the `logging` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in using the `logging` module is to create logger objects and
    use the loggers to produce useful output. Each logger has a name that fits into
    a tree using names delimited with the `.` character. The logger names parallel
    the standards for module names; we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will create a module-wide `logger` object with a name that matches the
    module name. The root logger has the name `""`; that is, an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create class-wide loggers as well as object-specific loggers. We
    can, for example, create a logger during the `__init__()` method part of object
    creation. We might use the `__qualname__` attribute of an object's class to provide
    a qualified class name for the logger. To create a logger for a specific instance
    of a class, we can suffix the class name with the `.` character and some unique
    identifier for the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the logger to create messages with a severity level from `DEBUGGING`
    (the least severe) to `FATAL` or `CRITICAL` (synonyms for the most severe level.)
    We do this with a method name that reflects the severity level. Messages are created
    with methods like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `logging` module has a default configuration that does nothing. This means
    that we can include logging requests in an application without any further consideration.
    As long as we properly create a `Logger` instance and use methods of the logger
    instance, we don't need to do anything else.
  prefs: []
  type: TYPE_NORMAL
- en: To see output, we'll need to create a handler that will write the messages to
    a particular stream or file. This is usually done as part of the overall configuration
    of the logging system.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the logging system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have several ways to configure the logging system. For small applications,
    we might provide the logging setup using the `logging.basicConfig()` function.
    We've shown this in [Chapter 13](ch13.html "Chapter 13. Metaprogramming and Decorators"),
    *Metaprogramming and Decorators*. A simple initialization will send the output
    to the standard error stream and explicitly set a level that filters the messages
    being displayed. This uses the `stream` and `level` keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly more complex configuration might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We've opened a named file, assigned a mode of `a` to append, and set the level
    to show messages with a severity that's equal to or greater than `INFO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since each individual logger is named, we can adjust the level of detail for
    a specific logger. We can include a line like the following to enable debugging
    on a specific logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to see details for a specific class or module. This is often
    a great help when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The `logging.handlers` module offers a large number of handlers for routing,
    printing, or saving the sequence of logging messages. The preceding example shows
    the file handler. The stream handler is used to write to the standard error stream.
    In some cases, we need to have multiple handlers. We can apply filters to each
    handler, so that the handlers will reflect different kinds of details.
  prefs: []
  type: TYPE_NORMAL
- en: Logging configurations often get too complex for the `basicConfig()` function.
    The `logging.config` module offers several functions that can be used to configure
    the logging for an application. One general approach is to use the `logging.config.dictConfig()`
    function. We can create a Python `dict` object directly in Python, or read some
    serialized version of the `dict` object. The standard library documentation uses
    examples written in the YAML markup language because it's simple and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might do something like this to create a configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This object has the required `version` attribute to specify the structure of
    the configuration. A single handler is defined; it's named `console` and uses
    `logging.StreamHandler` is used to write to the standard error stream. The root
    logger is configured to use the `console` handler. The severity level is defined
    to include any message at or above the `DEBUG` level.
  prefs: []
  type: TYPE_NORMAL
- en: Only in configuration files is the root logger named `'root'`. In application
    code, the root logger is named with an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Larger and more sophisticated applications will rely on logging configurations
    in external configuration files. This permits flexible and sophisticated logging
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Writing documentation with RST markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Python code should be beautiful and informative, it doesn't easily provide
    background or context to show why a particular algorithm or data structure was
    chosen. We often need to provide these additional details to help people maintain,
    extend, and make effective use of our software. While we can include a lot of
    information in a module docstring, it seems best to keep docstrings focused on
    implementation details, and provide the additional material separately.
  prefs: []
  type: TYPE_NORMAL
- en: We can write additional documentation in a variety of formats. We can use a
    sophisticated editor with complex file formats, or we can use simple text editors
    and plain text format. We can even write our documentation entirely in HTML. Python
    also offers a hybrid approach—we can write using a text editor with simplified
    **ReStructuredText** (**RST**) markup, and use the `docutils` tools to create
    nice-looking HTML pages or LaTeX files suitable for publication from that markup.
  prefs: []
  type: TYPE_NORMAL
- en: The RST markup language is widely used for creating Python documentation. This
    markup allows us to write plain text, while adhering to a few formatting rules.
    In the next section, we'll look at using the `docutils` tools to parse the RST
    and create an output document.
  prefs: []
  type: TYPE_NORMAL
- en: The rules of RST markup are simple. There is paragraph-level markup that applies
    to big blocks of text. Paragraphs must be separated by blank lines. When a line
    is "underlined" with a sequence of characters, it is taken as a heading. When
    a paragraph starts with an isolated punctuation mark, it's a bullet. When a paragraph
    starts with a letter or digit, and a punctuation mark, this indicates numbers
    instead of bullets. The `docutils` `rst2html.py` tool transforms each paragraph
    of the input to the proper kind of HTML structure.
  prefs: []
  type: TYPE_NORMAL
- en: There are many paragraph-level "directives" that can be used to insert an image,
    a table, an equation, or a large block of code. These directives are prefixed
    with `..` and end with `::`. We might use the directive `.. contents::` to add
    the table of contents to our document.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write inline markup inside the body of a paragraph. Inline markup includes
    a few simple constructs. If we surround a word with the `*` character, like `*this*`,
    we''ll see the word in an *italic*-style font in the final document; we can use
    `**bold**` for **bold** characters. If we want to write a `*` character without
    confusing the tool, we can escape it with the `\` character. In many cases, however,
    we''ll need to use a more complex semantic markup that looks like this: `` :code:`code
    sample` ``. This includes the text role, `:code:`, as a prefix that shows how
    to classify the marked characters; the content is surrounded by the `` ` `` character.
    The text roles of `:code:` and `:math:` are widely used.'
  prefs: []
  type: TYPE_NORMAL
- en: When we write a docstring, we'll often use additional RST markup. We'll use
    `:param name:` when defining the parameter to a function or class method. We use
    `:returns:` to annotate the return values from a function. When we provide this
    additional markup, we're assured that various formatting tools will produce elegant
    documentation from our docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of what an RST file might contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14] for more complex semantic markup.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: MacBookPro-SLott:Chapter_14 slott$ rst2html.py ch14_doc.rst ch14_doc.rst.html
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We've provided the `rst2html.py` command. We've named the input file and the
    output file. This will use default values for the style sheet, and other optional
    features for the resulting document. We can configure the output through the command
    line or by providing a configuration file that assures a common look for all of
    our generated HTML files.
  prefs: []
  type: TYPE_NORMAL
- en: To create LaTeX, we can use the `rst2latex.py` or `rst2xetex.py` tool, and then
    a LaTeX formatter. TeX Live distribution works nicely for creating a PDF file
    from LaTeX. See [https://www.tug.org/texlive/](https://www.tug.org/texlive/).
  prefs: []
  type: TYPE_NORMAL
- en: For large and complex documents, creating a single RST file isn't ideal. While
    we can use the `.. include::` directive to insert material from separate files,
    the document must be built as a whole, which requires a large amount of memory;
    rebuilding a document after a small change might require a disproportionate amount
    of processing.
  prefs: []
  type: TYPE_NORMAL
- en: For a multipage website, we have to use a tool like Make, Ant, or SCons to rebuild
    the relevant HTML pages when a source RST file has been updated. This is the kind
    of overhead that calls out for a tool to automate and simplify production of large
    or complex documents.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Sphinx tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Sphinx tool allows us to easily build multipage websites or complex documents.
    For more information, see [http://sphinx-doc.org](http://sphinx-doc.org). When
    we install Sphinx using `pip` or `easy_install`, the installer will also include
    `docutils` for us.
  prefs: []
  type: TYPE_NORMAL
- en: To create sophisticated documentation, we'll start with the `sphinx-quickstart`
    script. This application will build the template file structure, the configuration
    files, and a Makefile that we can use to rebuild our documents efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Sphinx adds a large number of directives and text roles to the basics of RST.
    These additional roles and directives make it easier to write about code with
    properly formatted references to modules, classes, and functions. Sphinx simplifies
    inter-document references—we can have multiple documents with consistent references
    to a target location; we can move the target and the references will all be updated.
  prefs: []
  type: TYPE_NORMAL
- en: The `sphinx-build` command is used to construct the target files from the RST
    source. Sphinx can build over a dozen different kinds of target documents, making
    it a versatile tool.
  prefs: []
  type: TYPE_NORMAL
- en: The Python documentation is built with Sphinx. This means that our projects
    can include documentation that looks as polished and elegant as Python's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python programs should be beautiful. To that end, the language has few syntactic
    overheads; we should be able to write short scripts without unpleasant boilerplate.
    The principle is sometimes articulated as *Simple things should be simple*. The
    "Hello World" script really is a single line of code that uses the `print()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more complex file will generally have a few major sections:'
  prefs: []
  type: TYPE_NORMAL
- en: A `!#` line, often `#!/usr/bin/env python3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A docstring comment explaining what the module does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function or class definitions. We often group multiple functions and classes
    into a single module. The module is the proper unit of reuse in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the module can be run as a main script, we'll include an `if __name__ ==
    "__main__":` section that defines the file's behavior when run as the main script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many applications are too complex for a single file. When designing larger applications,
    the Pythonic ideal is to keep the resulting structure as flat as possible. While
    the language supports nested packages, deep nesting is not seen as desirable.
    In [Chapter 12](ch12.html "Chapter 12. Scripts, Modules, Packages, Libraries,
    and Applications"), *Scripts, Modules, Packages, Libraries, and Applications*,
    we looked at the details of defining modules and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked at several features of polished and complete Python
    projects. The most important feature of working code is a suite of unit tests
    that demonstrate that the code works. Code without test cases simply cannot be
    trusted. In order to make use of any software, we must have tests that show us
    that the software is trustworthy.
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at including tests in docstrings. The `doctest` tool can locate
    these tests and execute them. We've looked at creating `unittest.TestCase` classes.
    We can combine the two into a script that will locate all `doctest` and `unittest`
    test cases into a single master test suite.
  prefs: []
  type: TYPE_NORMAL
- en: One other feature of good software is some explanation of how to install and
    use the software. This may be as short as a `README` file that provides basic
    information. Often, however, we need a more sophisticated document that provides
    a variety of additional information. We might want to provide context, design
    background, or examples that are too big to be packaged into module or class docstrings.
    We'll often write documentation using tools above and beyond the basic components
    that come with Python.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 15](ch15.html "Chapter 15. Next Steps"), *Next Steps*, we'll look
    at the next steps in our exploration of Python. Once we've mastered the essentials,
    we need to add depth to the areas that are relevant to the problems we need to
    solve. We might want to study big data applications, web applications, or game
    development. Each of these more specialized areas will involve additional Python
    concepts, tools, and frameworks.
  prefs: []
  type: TYPE_NORMAL
