["```py\nimport threading\n\nclass RaceConditionDemo:\n  def __init__(self):\n    self.shared_var = 0\n    self.total_count = 100000\n    self.demo_of_race_condition()\n\n  def increment(self):\n    for i in range(self.total_count):\n      self.shared_var += 1\n\n  def decrement(self):\n    for i in range(self.total_count):\n      self.shared_var -= 1\n\n  def demo_of_race_condition(self):\n    t1 = threading.Thread(target=self.increment)\n    t2 = threading.Thread(target=self.decrement)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n    print(\"value of shared_var after all increments & decrements :\", self.shared_var)\n\nif __name__ == \"__main__\":\n  for i in range(100):\n     RaceConditionDemo()\n```", "```py\nself.lock = threading.Lock()\n```", "```py\nself.lock.acquire()\nself.shared_var += 1\nself.lock.release()\n```", "```py\nmy_queue = Queue() #create empty queue\nmy_queue.put(data)# put items into queue\ntask = my_queue.get () #get the next item in the queue\nmy_queue.task_done() # called when a queued task has completed\nmy_queue.join() # awaits for all tasks in queue to get completed\n```", "```py\nimport queue\nimport threading\n\nclass Consumer(threading.Thread):\n\n  def __init__(self, queue):\n   threading.Thread.__init__(self)\n   self.queue = queue\n\n  def run(self):\n    while True:\n      task = self.queue.get()\n      self.do_task(task)\n\n  def do_task(self, task):\n    print ('doing task{}'.format(task))\n    self.queue.task_done()\n\ndef producer(tasks):\n    my_queque = queue.Queue()\n    # populate queue with tasks\n    for task in tasks:\n      my_queque.put(task)\n    # create 6 threads and pass the queue as its argument\n    for i in range(6):\n      my_thread = Consumer(my_queque)\n      my_thread.daemon = True\n      my_thread.start()\n    # wait for the queue to finish\n    my_queque.join()\n    print ('all tasks completed')\n\nif __name__ == \"__main__\":\n  tasks = 'A B C D E F'.split()\n  producer(tasks)\n```", "```py\nclass View(Tk):\n  def __init__(self, queue):\n    Tk.__init__(self)\n    self.queue = queue\n    self.create_gui()\n\n  def create_gui(self):\n    self.canvas = Canvas(self, width=495, height=305, bg='#FF75A0')\n    self.canvas.pack()\n    self.snake = self.canvas.create_line((0, 0), (0,0),fill='#FFCC4C', \n      width=10)\n    self.food = self.canvas.create_rectangle(0, 0, 0, 0,  \n      fill='#FFCC4C', outline='#FFCC4C')\n    self.points_earned = self.canvas.create_text(455, 15, fill='white', \n      text='Score:0')\n```", "```py\nclass Food:\n\ndef __init__(self, queue):\n self.queue = queue\n self.generate_food()\n\ndef generate_food(self):\n x = random.randrange(5, 480, 10)\n y = random.randrange(5, 295, 10)\n self.position = (x, y)\n rectangle_position = (x - 5, y - 5, x + 5, y + 5)\n self.queue.put({'food': rectangle_position})\n```", "```py\nclass Snake(threading.Thread):\n\n  is_game_over = False\n\n  def __init__(self, queue):\n    threading.Thread.__init__(self)\n    self.queue = queue\n    self.daemon = True\n    self.points_earned = 0\n    self.snake_points = [(495, 55), (485, 55), (475, 55), (465, 55), \n      (455, 55)]\n    self.food = Food(queue)\n    self.direction = 'Left'\n    self.start()\n\n  def run(self):\n    while not self.is_game_over:\n      self.queue.put({'move': self.snake_points})\n    time.sleep(0.1)\n    self.move()\n\n  def on_keypress(self, e):\n    self.direction = e.keysym\n\n  def move(self):\n   new_snake_point = self.calculate_new_coordinates()\n   if self.food.position == new_snake_point:\n     self.points_earned += 1\n     self.queue.put({'points_earned': self.points_earned})\n     self.food.generate_food()\n   else:\n     self.snake_points.pop(0)\n   self.check_game_over(new_snake_point)\n   self.snake_points.append(new_snake_point)\n\n  def calculate_new_coordinates(self):\n    last_x, last_y = self.snake_points[-1]\n    if self.direction == 'Up':\n      new_snake_point = (last_x, last_y - 10)\n    elif self.direction == 'Down':\n      new_snake_point = (last_x, last_y + 10)\n    elif self.direction == 'Left':\n      new_snake_point = (last_x - 10, last_y)\n    elif self.direction == 'Right':\n      new_snake_point = (last_x + 10, last_y)\n    return new_snake_point\n\n  def check_game_over(self, snake_point):\n    x, y = snake_point\n    if not -5 < x < 505 or not -5 < y < 315 or snake_point in self.snake_points:\n      self.is_game_over = True\n      self.queue.put({'game_over': True})\n```", "```py\ndef queue_handler(self):\n try:\n   while True:\n     task = self.queue.get_nowait()\n     if 'game_over' in task:\n       self.game_over()\n     elif 'move' in task:\n       points = [x for point in task['move'] for x in point]\n       self.canvas.coords(self.snake, *points)\n     elif 'food' in task:\n       self.canvas.coords(self.food, *task['food'])\n     elif 'points_earned' in task:\n       self.canvas.itemconfigure(self.points_earned, text='Score:  \n                               {}'.format (task['points_earned'])) \n     self.queue.task_done()\n except queue.Empty:\n   self.after(100, self.queue_handler)\n```", "```py\ndef main():\n  q = queue.Queue()\n  gui = View(q)\n  snake = Snake(q)\n  for key in (\"Left\", \"Right\", \"Up\", \"Down\"):\n    gui.bind(\"<Key-{}>\".format(key), snake.on_keypress)\n    gui.mainloop()\n\nif __name__ == '__main__':\n  main()\n```", "```py\nimport urllib.request\n\nwith urllib.request.urlopen('http://www.packtpub.com/') as f:\n  print(f.read())\n```", "```py\ndef main():\n  root=Tk()\n  WeatherReporter(root)\n  root.mainloop()\n\nif __name__ == '__main__':\n  main()\n```", "```py\napi.openweathermap.org/data/2.5/weather?q=London,uk&APPID={APIKEY} \n```", "```py\n{\"coord\":{\"lon\":-0.12574,\"lat\":51.50853},\"sys\":{\"country\":\"GB\",\"sunrise\":1377147503,\"sunset\":1377198481},\"weather\":[{\"id\":500,\"main\":\"Rain\", \"description\": \"light rain\",\"icon\":\"10d\"}],\"base\":\"gdps stations\",\"main\":{\"temp\":294.2, \"pressure\":1020,\"humidity\":88, \"temp_min\":292.04,\"temp_max\":296.48},\"wind\":{\"speed\":1,\"deg\":0},\"rain\":{\"1h\":0.25},\"clouds\":{\"\n all\":40},\"dt\":1377178327,\"id\":2643743,\"name\":\"London\",\"cod\":200}\n```", "```py\ndef get_data_from_url(self):\n try:\n   params = urllib.parse.urlencode( {'q': self.location.get(), 'APPID': self.APIKEY},\n    encoding=\"utf-8\")\n   api_url = ('http://api.openweathermap.org/data/2.5/weather?{}'.format(params))\n   with urllib.request.urlopen(api_url) as f:\n     json_data = f.read()\n     return json_data\n except IOError as e:\n   messagebox.showerror('Unable to connect', 'Unable to connect %s' % e)\n   sys.exit(1)\n```", "```py\ndef json_to_dict(self, json_data):\n decoder = json.JSONDecoder()\n decoded_json_data = decoder.decode(json_data.decode(\"utf-8\"))\n flattened_dict = {}\n for key, value in decoded_json_data.items():\n   if key == 'weather':\n     for ke, va in value[0].items():\n       flattened_dict[str(ke)] =  str(va).upper()\n     continue\n   try:\n     for k, v in value.items():\n     flattened_dict[str(k)] = str(v).upper()\n   except:\n     flattened_dict[str(key)] = str(value).upper()\n return flattened_dict \n```", "```py\n(protocol, local address, local port, remote address, remote port) \n```", "```py\nmessage = \"GET / HTTP/1.1 \\r\\nHost:\" + host + \"\\r\\n\\r\\nAccept: text/html\\r\\n\\r\\n\"\n```", "```py\ndef is_port_open(self,url, port):\n try:\n   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n   s.settimeout(1)\n   s.connect((socket.gethostbyname(url), port))\n   s.close()\n   return True\n except:\n   return False\n```", "```py\ndef start_scan(self, url, start_port, end_port):\n for port in range (start_port, end_port+1):\n   if not self.stop:\n     self.output_to_console(\"Scanning port{}\".format(port))\n     if self.is_port_open(url, port):\n       self.output_to_console(\" -- Port {} open \\n\".format(port))\n     else:\n       self.output_to_console(\"-- Port {} closed \\n\".format(port))\n```", "```py\ndef scan_in_a_new_thread(self):\n  url = self.host_entry.get()\n  start_port = int(self.start_port_entry.get())\n  end_port = int(self.end_port_entry.get())\n  thread = Thread(target=self.start_scan, args=(url, start_port, \n    end_port ))\n  thread.start()\n```", "```py\nclass ChatServer:\n  clients_list = []\n  last_received_message = \"\"\n\n  def __init__(self):\n    self.create_listening_server()\n\n  def create_listening_server(self):\n    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    local_ip = '127.0.0.1'\n    local_port = 10319\n    self.server_socket.setsockopt(socket.SOL_SOCKET, \n      socket.SO_REUSEADDR, 1)\n    self.server_socket.bind((local_ip, local_port))\n    print(\"Listening for incoming messages..\")\n    self.server_socket.listen(5)\n    self.receive_messages_in_a_new_thread()\n\n  def receive_messages_in_a_new_thread(self):\n    while 1:\n      client = so, (ip, port) = self.server_socket.accept()\n      self.add_to_clients_list(client)\n      print ('Connected to ', ip , ':' , str(port))   \n      t = threading.Thread(target=self.receive_messages, args=(so,))\n      t.start()\n\n  def receive_messages(self, so):\n    while True:\n      incoming_buffer = so.recv(256)\n      if not incoming_buffer: break\n      self.last_received_message = incoming_buffer.decode('utf-8')\n      self.broadcast_to_all_clients(so)\n      so.close()\n\n  def broadcast_to_all_clients(self, senders_socket):\n     for client in self.clients_list:\n        socket, (ip, port) = client\n        if socket is not senders_socket:\n           socket.sendall(self.last_received_message.encode('utf-8'))\n\n  def add_to_clients_list(self, client):\n      if client not in self.clients_list:\n         self.clients_list.append(client)\n\nif __name__ == \"__main__\":\nChatServer()\n```", "```py\nclass ChatClient:\n  client_socket = None\n  last_received_message = None\n\n  def __init__(self, root):\n    self.root = root\n    self.initialize_socket()\n    self.initialize_gui()\n    self.listen_for_incoming_messages_in_a_thread()\n\n  def initialize_socket(self):\n    self.client_socket = socket(AF_INET, SOCK_STREAM)\n    remote_ip = '127.0.0.1'\n    remote_port = 10319\n    self.client_socket.connect((remote_ip, remote_port))\n\n  def listen_for_incoming_messages_in_a_thread(self):\n    t = Thread(target=self.recieve_message_from_server,\n    args=(self.client_socket,))\n    t.start()\n\n  def recieve_message_from_server(self, so):\n    while True:\n      buf = so.recv(256)\n      if not buf:\n        break \n      self.chat_transcript_area.insert('end',buf.decode('utf-8') + '\\n')\n      self.chat_transcript_area.yview(END)\n    so.close()\n\n  def send_chat(self):\n    senders_name = self.name_widget.get().strip() + \":\"\n    data = self.enter_text_widget.get(1.0, 'end').strip()\n    message = (senders_name + data).encode('utf-8')\n    self.chat_transcript_area.insert('end', message.decode('utf-8') + '\\n')\n    self.chat_transcript_area.yview(END)\n    self.client_socket.send(message)\n    self.enter_text_widget.delete(1.0, 'end')\n    return 'break'\n```", "```py\nsqlite3 phonebook.db\n```", "```py\nSQLite version 3.7.17 2018-01-31 00:56:22\nEnter \".help\" for instructions\nEnter SQL statements terminated with a \";\"\nsqlite>\n```", "```py\nsqlite> .tables\n```", "```py\nsqlite> .exit\n```", "```py\nsqlite3 phonebook.db\n```", "```py\nsqlite> CREATE TABLE contacts\n(\ncontactid INTEGER PRIMARY KEY AUTOINCREMENT,\nname STRING NOT NULL,\ncontactnumber INTEGER NOT NULL\n);\n```", "```py\nsqlite>.table\n```", "```py\nsqlite>.table\ncontacts\n```", "```py\ndef create_tree_view(self):\n self.tree = ttk.Treeview(height=5, columns=2)\n self.tree.grid(row=4, column=0, columnspan=2)\n self.tree.heading('#0', text='Name', anchor=W)\n self.tree.heading(2, text='Phone Number', anchor=W)\n```", "```py\nself.tree.insert('', 0, text=row[1], values=row[2])\n```", "```py\nitems = self.tree.get_children()\n```", "```py\nself.tree.delete(item)\n```", "```py\ndb_filename = 'phonebook.db'\n\ndef execute_db_query(self, query, parameters=()):\n  with sqlite3.connect(self.db_filename) as conn:\n    cursor = conn.cursor()\n    query_result = cursor.execute(query, parameters)\n    conn.commit()\n  return query_result\n```", "```py\nquery = 'INSERT INTO contacts VALUES(NULL,?, ?)'\nparameters = (self.namefield.get(), self.numfield.get())\nself.execute_db_query(query, parameters)\n```", "```py\nquery = 'SELECT * FROM contacts ORDER BY name desc'\nphone_book_entries = self.execute_db_query(query)\n```", "```py\nquery = 'UPDATE contacts SET contactnumber=? WHERE contactnumber=? AND name=?'\nparameters = (newphone, old_phone_number, name)\nself.execute_db_query(query, parameters)\n```", "```py\nquery = 'DELETE FROM contacts WHERE name = ?'\nself.execute_db_query(query, (name,))\n```", "```py\nfrom tkinter import Tk, Button\nimport asyncio\nimport threading\nimport random\n\ndef asyncio_thread(event_loop):\n  print('The tasks of fetching multiple URLs begins')\n  event_loop.run_until_complete(simulate_fetch_all_urls())\n\ndef execute_tasks_in_a_new_thread(event_loop):\n  \"\"\" Button-Event-Handler starting the asyncio part. \"\"\"\n  threading.Thread(target=asyncio_thread, args=(event_loop, )).start()\n\nasync def simulate_fetch_one_url(url):\n  \"\"\" We simulate fetching of URL by sleeping for a random time \"\"\"\n  seconds = random.randint(1, 8)\n  await asyncio.sleep(seconds)\n  return 'url: {}\\t fetched in {} seconds'.format(url, seconds)\n\nasync def simulate_fetch_all_urls():\n  \"\"\" Creating and starting 10 i/o bound tasks. \"\"\"\n  all_tasks = [simulate_fetch_one_url(url) for url in range(10)]\n  completed, pending = await asyncio.wait(all_tasks)\n  results = [task.result() for task in completed]\n  print('\\n'.join(results))\n\ndef check_if_button_freezed():\n  print('This button is responsive even when a list of i/o tasks are in progress')\n\ndef main(event_loop):\n  root = Tk()\n  Button( master=root, text='Fetch All URLs',\n        command=lambda: execute_tasks_in_a_new_thread(event_loop)).pack()\n  Button(master=root, text='This will not Freeze',  \n                      command=check_if_button_freezed).pack()\n  root.mainloop()\n\nif __name__ == '__main__':\n  event_loop = asyncio.get_event_loop()\n  main(event_loop)\n```", "```py\nconst int triggerPin = 8;\nconst int echoBackPin = 7;\n\nvoid setup() {\n Serial.begin(9600);\n pinMode(triggerPin, OUTPUT);\n pinMode(echoBackPin, INPUT);\n}\n\nvoid loop() {\n  long duration, distanceIncm;\n  // trigger ultrasound ping\n  digitalWrite(triggerPin, LOW);\n  delayMicroseconds(2);\n  digitalWrite(triggerPin, HIGH);\n  delayMicroseconds(5);\n  digitalWrite(triggerPin, LOW);\n  // receive input from the sensor\n  duration = pulseIn(echoBackPin, HIGH);\n\n  //calculate distance\n  distanceIncm = duration / 29 / 2;\n\n  // send data over serial port\n  Serial.print(distanceIncm);\n  Serial.println();\n  delay(100);\n}\n```", "```py\npip install pyserial\n\n```", "```py\npython -m serial.tools.list_ports\n```", "```py\nfrom tkinter import Tk, Label\nimport serial\n\nser = serial.Serial()\nser.port = \"/dev/ttyUSB0\"\nser.baudrate = 9600\ntry:\n ser.open()\nexcept serial.SerialException:\n print(\"Could not open serial port: \" + ser.port)\n\nroot = Tk()\nroot.geometry('{}x{}'.format(200, 100))\nlabel = Label(root, font=(\"Helvetica\", 26))\nlabel.pack(fill='both')\n\ndef read_serial_data():\n if ser.isOpen():\n   try:\n     response = ser.readline()\n     label.config(text='Distance : \\n' + response.decode(\"utf-8\").rstrip() + ' cm')\n   except serial.SerialException:\n     print(\"no message received\")\n\nroot.after(100, read_serial_data)\nread_serial_data()\nroot.mainloop()\n```"]