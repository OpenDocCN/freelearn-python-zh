- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Parameters – Making Nodes More Dynamic
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数 – 使节点更加动态
- en: We are now done with the basics of ROS 2 communications. In this chapter, we
    will continue to work on nodes, but this time by making them more dynamic with
    **parameters**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了ROS 2通信的基础。在本章中，我们将继续在节点上工作，但这次是通过使用**参数**使它们更加动态。
- en: To understand parameters, I will start with why we need them in the first place.
    Then, you will learn how to add parameters to your nodes so that you can customize
    them at runtime. You will also see how to load multiple parameters at once with
    **YAML** files and how to allow parameters to be modified in your code with **parameter
    callbacks**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解参数，我将从为什么一开始就需要它们开始。然后，你将学习如何将参数添加到你的节点中，以便你可以在运行时自定义它们。你还将看到如何使用**YAML**文件一次性加载多个参数，以及如何使用**参数回调**允许在代码中修改参数。
- en: As a starting point, we will use the code inside the **ch7** folder of the book’s
    GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
    If you skipped *actions* ([*Chapter 7*](B22403_07.xhtml#_idTextAnchor338)), you
    can also start from the **ch6** folder, which will work the same. The final code
    for this chapter will be in the **ch8** folder.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，我们将使用书中GitHub仓库的**ch7**文件夹中的代码([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch))。如果你跳过了*动作*([*第7章*](B22403_07.xhtml#_idTextAnchor338))，你也可以从**ch6**文件夹开始，它将起到相同的作用。本章的最终代码将在**ch8**文件夹中。
- en: By the end of this chapter, you will be able to add parameters to any of your
    nodes and handle parameters for other nodes that you start.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够将参数添加到你的任何节点中，并处理你启动的其他节点的参数。
- en: The concept of parameters is not too difficult, and there won’t be too much
    to do in the code. However, it’s an important concept and the first step toward
    making your application more dynamic and scalable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的概念并不太难，代码中也不会有太多要做。然而，这是一个重要的概念，是使你的应用程序更加动态和可扩展的第一步。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: What is a ROS 2 parameter?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是ROS 2参数？
- en: Using parameters in your nodes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的节点中使用参数
- en: Storing parameters in YAML files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数存储在YAML文件中
- en: Additional tools to handle parameters
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理参数的附加工具
- en: Updating parameters with parameter callbacks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数回调更新参数
- en: Parameter challenge
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数挑战
- en: What is a ROS 2 parameter?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是ROS 2参数？
- en: You have already experimented a bit with parameters in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092),
    where you ran a node with different settings.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在[*第3章*](B22403_03.xhtml#_idTextAnchor092)中尝试过一些参数实验，其中你运行了一个具有不同设置的节点。
- en: I am now going to start from scratch again and explain parameters with a real-life
    example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将从头开始再次解释参数，并使用一个现实生活中的例子。
- en: Why parameters?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要参数？
- en: Let’s start with a problem to understand the need for parameters. I will use
    a camera driver as an example—we won’t write the node; it’s just for the explanation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个问题开始，以理解参数的需求。我将使用一个相机驱动程序作为例子——我们不会编写节点；这只是用于解释。
- en: This camera driver connects to a USB camera, reads images, and publishes them
    on a ROS 2 topic. This is classic behavior for any ROS 2 hardware driver.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相机驱动程序连接到USB相机，读取图像，并在ROS 2主题上发布。这是任何ROS 2硬件驱动程序的典型行为。
- en: 'Inside this node, you will have some variables for different kinds of settings.
    Here are some examples:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个节点内部，你将有一些用于不同设置的变量。以下是一些示例：
- en: USB device name
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB设备名称
- en: Frames per second (FPS)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒帧数（FPS）
- en: Simulation mode
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟模式
- en: Let’s say the camera you’re working on is connected to the **/dev/ttyUSB0**
    port (typical USB port name on Linux). You want to set **60** FPS and not use
    the simulation mode (**false**). Those are the values you will write for the variables
    inside your node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在工作的相机连接到**/dev/ttyUSB0**端口（Linux上典型的USB端口名称）。你想要设置**60** FPS并且不使用模拟模式（**false**）。这些就是你要在节点内部写入的变量值。
- en: Later on, if the USB device name is different (for example, **/dev/ttyUSB1**),
    you will have to change that setting in your code and maybe build again—you'll
    do the same thing if you want to start your camera with **30** FPS instead of
    **60** FPS, or if you want to run it in simulation mode.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，如果USB设备名称不同（例如，**/dev/ttyUSB1**），你将不得不在代码中更改该设置，也许需要重新构建——如果你想要以**30** FPS而不是**60**
    FPS启动相机，或者想要在模拟模式下运行它，你将做同样的事情。
- en: Also, what if you have two cameras, and you want to use them both at the same
    time? Will you duplicate your code for each camera? How can you handle the different
    settings for both cameras?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你有两个摄像头，并且你想同时使用它们呢？你会为每个摄像头复制代码吗？你如何处理两个摄像头的不同设置？
- en: As you can see, hardcoding those settings in your code is not a great option
    for reusability. This is why we have ROS 2 parameters.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在代码中硬编码这些设置并不是一个很好的重用选项。这就是为什么我们有ROS 2参数。
- en: Example of a node with parameters
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有参数的节点示例
- en: A ROS 2 parameter is basically a setting for a node that you can modify when
    you start the node.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 2参数基本上是一个节点设置，你可以在启动节点时修改它。
- en: 'So, if we keep the camera driver example, we could add three parameters—USB
    device name (string), FPS value (integer), and simulation mode (boolean):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们保持摄像头驱动程序的示例，我们可以添加三个参数——USB设备名称（字符串）、帧率值（整数）和模拟模式（布尔值）：
- en: '![Figure 8.1 – A node class with three parameters](img/B22403_08_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 具有三个参数的节点类](img/B22403_08_1.jpg)'
- en: Figure 8.1 – A node class with three parameters
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 具有三个参数的节点类
- en: When you start this camera driver with **ros2 run** (we will see how to do that
    later in this chapter), you will be able to provide the values you want for those
    three parameters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用**ros2 run**（我们将在本章后面看到如何操作）启动这个摄像头驱动程序时，你将能够为这三个参数提供你想要的值。
- en: 'Let’s say you want to start two nodes for two different cameras, given the
    following settings:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想为两个不同的摄像头启动两个节点，以下是一些设置：
- en: 'Port: `/dev/ttyUSB0`; FPS: `30`; simulation mode: off'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口：`/dev/ttyUSB0`；帧率：`30`；模拟模式：关闭
- en: 'Port: `/dev/ttyUSB1`; FPS: `60`; simulation mode: off'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口：`/dev/ttyUSB1`；帧率：`60`；模拟模式：关闭
- en: 'With the parameters we’ve added in the code, we can start the same node multiple
    times with different values:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中添加的参数使我们能够以不同的值多次启动相同的节点：
- en: '![Figure 8.2 – Starting two nodes with different settings](img/B22403_08_2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 使用不同设置启动两个节点](img/B22403_08_2.jpg)'
- en: Figure 8.2 – Starting two nodes with different settings
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 使用不同设置启动两个节点
- en: From the same code, we start two different nodes. At runtime, we rename the
    nodes (because we can’t have two nodes with the same name), and we provide the
    parameters’ values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从相同的代码中，我们启动了两个不同的节点。在运行时，我们重命名了节点（因为我们不能有两个同名节点），并提供了参数的值。
- en: Our two camera nodes are now running, each with a different configuration. You
    could stop one camera node and start it again with a different set of values.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个摄像头节点现在正在运行，每个节点都有不同的配置。你可以停止一个摄像头节点，然后使用不同的值重新启动它。
- en: ROS 2 parameters – wrapping things up
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ROS 2参数 – 总结
- en: With parameters, you can reuse the same code and start several nodes with different
    settings. There’s no need to compile or build anything again; you just have to
    provide the parameters’ values at runtime.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数，你可以重用相同的代码并使用不同的设置启动多个节点。无需再次编译或构建任何东西；你只需在运行时提供参数的值即可。
- en: Making your nodes customizable allows for greater flexibility and reusability.
    Your application will become much more dynamic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的节点可定制可以提供更大的灵活性和重用性。你的应用程序将变得更加动态。
- en: Parameters are also very convenient for collaborating with other ROS developers.
    If you develop a node that could be reused by others, then with parameters, you
    allow other developers to fully customize the node without even having to look
    at the code. This also applies when using existing nodes. Lots of them can be
    configured at runtime.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 参数也非常方便与其他ROS开发者协作。如果你开发了一个可以被其他人重用的节点，那么通过参数，你可以允许其他开发者完全定制节点，甚至无需查看代码。这也适用于使用现有节点。许多节点可以在运行时进行配置。
- en: 'Here are a few important points about parameters:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于参数的几个重要点：
- en: Just as with a variable, a parameter has a name and a data type. Among the most
    common types, you can use booleans, integer numbers, float numbers, strings, and
    lists of those types.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像变量一样，参数有一个名称和数据类型。在最常见的类型中，你可以使用布尔值、整数、浮点数、字符串以及这些类型的列表。
- en: A parameter’s value is specific to a node. If you kill the node, the value is
    gone with it.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的值是针对特定节点的。如果你杀死节点，该值也会随之消失。
- en: You can set the value for each parameter when you start a node with `ros2 run`
    (or from a launch file, which we will see in the next chapter).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用`ros2 run`（我们将在下一章中看到如何操作）启动一个节点时，你可以设置每个参数的值。
- en: Now, how to add parameters to your code? As for nodes, topics, and services,
    you will get everything you need from the **rclpy** and **rclcpp** libraries.
    You will be able to declare the parameters in your code and get the value for
    each parameter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如何将参数添加到您的代码中？对于节点、主题和服务，您将从**rclpy**和**rclcpp**库中获得您所需的一切。您将能够在您的代码中声明参数并获取每个参数的值。
- en: Using parameters in your nodes
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的节点中使用参数
- en: We will continue with the code we have written in the previous chapters. Here,
    we will improve the **number_publisher** node. As a quick recap, this node publishes
    a number on a topic, at a given rate. The number and publishing rate are directly
    written in the code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用前几章中编写的代码。在这里，我们将改进**number_publisher**节点。作为一个快速回顾，这个节点会在一个主题上以给定的速率发布一个数字。数字和发布速率直接在代码中写出。
- en: Now, instead of hardcoding the number and publishing rate values, we will use
    parameters. This way, we will be able to specify what number to publish, and the
    publishing frequency or period, when we start the node.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再将数字和发布速率值硬编码，而是将使用参数。这样，我们就可以在启动节点时指定要发布的数字和发布频率或周期。
- en: 'You need to follow two steps to be able to use a parameter in your code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要遵循两个步骤才能在您的代码中使用参数：
- en: Declare the parameter in the node. This will make the parameter exist within
    the node so that you can set a value to it when starting the node with `ros2 run`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在节点中声明参数。这将使参数存在于节点中，这样您就可以在启动节点时使用`ros2 run`来设置其值。
- en: Retrieve the parameter’s value so that you can use it in the code.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取参数的值，以便您可以在代码中使用它。
- en: Let’s start with Python, and later on, we will also see the C++ code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Python开始，稍后我们还将看到C++代码。
- en: Declaring, getting, and using parameters with Python
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python声明、获取和使用参数
- en: Before using a parameter, we need to declare it. Where should we declare parameters?
    We will do that in the node’s constructor, before everything else. To declare
    a parameter, use the **declare_parameter()** method from the **Node** class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用参数之前，我们需要声明它。我们应该在哪里声明参数？我们将在节点的构造函数中这样做，在所有其他操作之前。要声明参数，请使用**Node**类的**declare_parameter()**方法。
- en: 'You will provide two arguments:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您将提供两个参数：
- en: '**Parameter name**: This is the name that you will use to set the parameter’s
    value at runtime'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数名称**：这是您将在运行时设置参数值的名称'
- en: '**Default value**: If the parameter’s value is not provided at runtime, this
    value will be used'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认值**：如果运行时没有提供参数值，将使用此值'
- en: There are, in fact, different ways to declare a parameter. You don’t necessarily
    need to provide a default value if you provide the parameter type instead. However,
    we will keep things like that, as it will probably make your life easier. Adding
    a default value for each parameter is a best practice to follow.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，声明参数有不同的方式。如果您提供了参数类型，您不一定需要提供默认值。然而，我们将保持这种方式，因为它可能会使您的生活更加轻松。为每个参数添加默认值是一个最佳实践。
- en: 'Open the **number_publisher.py** file, and let’s declare two parameters in
    the constructor:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**number_publisher.py**文件，让我们在构造函数中声明两个参数：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A parameter is defined by a name and a data type. Here, you choose the name,
    and the data type will be automatically set depending on the default value you
    have provided. In this example, the default value for **number** is **2**, which
    means that the parameter’s data type is integer. For the **publish_period** parameter,
    the default value is **1.0**, which is a float number.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 参数由一个名称和一个数据类型定义。在这里，您选择名称，数据类型将根据您提供的默认值自动设置。在这个例子中，**number**的默认值是**2**，这意味着参数的数据类型是整数。对于**publish_period**参数，默认值是**1.0**，这是一个浮点数。
- en: 'Here are a few more examples of different data types:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些不同数据类型的示例：
- en: '`self.declare_parameter("simulation_mode", False)`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.declare_parameter("simulation_mode", False)`'
- en: '`self.declare_parameter("device_name", "/dev/ttyUSB0")`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.declare_parameter("device_name", "/dev/ttyUSB0")`'
- en: '`self.declare_parameter("numbers", [4,` `5, 6])`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.declare_parameter("numbers", [4, 5, 6])`'
- en: Now, declaring a parameter means that it exists within the node, and you can
    set a value from the outside. However, in your code, to be able to use the parameter,
    it’s not enough to declare it. After doing that, you need to get the value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，声明一个参数意味着它在节点内部存在，并且您可以从外部设置一个值。然而，在您的代码中，为了能够使用该参数，仅仅声明它是远远不够的。在这样做之后，您还需要获取该值。
- en: 'For this, you will use the **get_parameter()** method, and provide the parameter’s
    name as an argument. Then, you can access the value with the **value** attribute:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，你需要使用 **get_parameter()** 方法，并将参数的名称作为参数提供。然后，你可以使用 **value** 属性来访问其值：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point in the code, the **number_** variable (which is a class attribute)
    contains the value that was set for the **number** parameter at runtime with **ros2
    run**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的这个位置，**number_** 变量（它是一个类属性）包含在运行时使用 **ros2 run** 设置的 **number** 参数的值。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You always need to declare a parameter before getting its value. If you fail
    to do so, when starting the node, you will get an exception (`ParameterNotDeclaredException`)
    as soon as you try to get the value.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取参数值之前，你总是需要声明一个参数。如果你没有这样做，当启动节点时，一旦尝试获取值，你将立即收到一个异常（`ParameterNotDeclaredException`）。
- en: 'After you get the values for all parameters and store them inside variables
    or class attributes, you can use them in your code. Here, we modify the timer
    callback:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取所有参数的值并将它们存储在变量或类属性中之后，你可以在你的代码中使用它们。在这里，我们修改了计时器回调：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this, we set the publishing period from the parameter’s value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们根据参数的值设置了发布周期。
- en: 'That’s pretty much it for the code. As you can see, there is nothing too complicated.
    For one parameter, you will just add two instructions: one to declare the parameter
    (give it a name and a default value), and another to get its value.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 代码部分就到这里。如你所见，并没有什么太复杂的。对于一个参数，你只需要添加两条指令：一条用于声明参数（给它一个名字和一个默认值），另一条用于获取其值。
- en: Now, I’ve been talking about setting a parameter’s value at runtime with **ros2
    run**. How do we do that?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我一直在谈论如何使用 **ros2 run** 在运行时设置参数的值。我们该如何做呢？
- en: Providing parameters at runtime
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时提供参数
- en: Before going further, make sure to save the **number_publisher.py** file and
    build the **my_py_pkg** package (if you haven’t used **--****symlink-install**
    before).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保保存 **number_publisher.py** 文件并构建 **my_py_pkg** 包（如果你之前没有使用过 **--****symlink-install**）。
- en: 'To provide a parameter’s value with the **ros2 run** command, follow the next
    steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 **ros2 run** 命令提供参数的值，请按照以下步骤操作：
- en: You will first start your node with `ros2 run <``package_name> <exec_name>`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先使用 `ros2 run <``package_name> <exec_name>` 启动你的节点。
- en: Then, to add any argument after this command, you have to write `--ros-args`
    (only once).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，要在该命令之后添加任何参数，你必须写 `--ros-args`（只写一次）。
- en: To specify a parameter’s value, write `-p <param_name>:=<param_value>`. You
    can add as many parameters as you want.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要指定参数的值，请写 `-p <param_name>:=<param_value>`。你可以添加任意多的参数。
- en: 'Let’s say we want to start the node and publish the number **3** every **0.5**
    seconds. In that case, we’d run the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要每 **0.5** 秒发布数字 **3**，在这种情况下，我们将运行以下命令：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To verify it’s working, we can subscribe to the **/****number** topic:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证它是否工作，我们可以订阅 **/****number** 主题：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also verify the publish rate:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以验证发布速率：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, what happened? You provided some values for different parameters at runtime.
    The node will start and recognize those parameters because they match the names
    that have been declared in the code. Then, the node can get the value for each
    parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么？你在运行时为不同的参数提供了一些值。节点将启动并识别这些参数，因为它们的名称与代码中声明的名称相匹配。然后，节点可以获取每个参数的值。
- en: 'If you provide the wrong data type for a parameter, you will get an error.
    As seen previously, the data type is set in the code from the default value. In
    this example, the **number** parameter should be an integer number. Look at what
    happens if we try to set a double value:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为参数提供了错误的数据类型，你将收到一个错误。如前所述，数据类型是在代码中从默认值设置的。在这个例子中，**number** 参数应该是一个整数。看看如果我们尝试设置一个双精度值会发生什么：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, once a parameter type is set in the code, you have to use that
    exact same type whenever you provide a value at runtime.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦在代码中设置了参数类型，你必须在提供运行时值时始终使用完全相同的类型。
- en: 'As each parameter has a default value, you could also omit one or more parameters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个参数都有一个默认值，你也可以省略一个或多个参数：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, the **publish_period** parameter will be set to its default value
    (**1.0**), defined in the code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**publish_period** 参数将被设置为代码中定义的默认值（**1.0**）。
- en: To finish here, let’s just see an example where renaming the node and setting
    parameters’ values can allow you to run several different nodes from the same
    code without having to modify anything in the code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这里，让我们看看一个例子，其中重命名节点和设置参数值可以让你从相同的代码中运行多个不同的节点，而无需修改代码中的任何内容。
- en: 'In Terminal 1, run the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端1中运行以下命令：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In Terminal 2, run the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端2中运行以下命令：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this, you have two nodes (**num_pub1** and **num_pub2**), both publishing
    to the **/number** topic but with different data and publishing rates. With this
    example, you can see that parameters are a great way to make your nodes more dynamic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就有两个节点（**num_pub1** 和 **num_pub2**），它们都发布到 **/number** 主题，但数据不同且发布速率不同。通过这个示例，你可以看到参数是使你的节点更加动态的绝佳方式。
- en: Let’s now finish this section with the C++ code for parameters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在用参数的C++代码来完成这个部分。
- en: Parameters with C++
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的参数
- en: Parameters work the same for Python and C++; only the syntax differs. Here,
    we will modify the **number_publisher.cpp** file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 参数对于Python和C++的工作方式相同；只是语法不同。在这里，我们将修改 **number_publisher.cpp** 文件。
- en: 'In the constructor, you can declare some parameters:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，你可以声明一些参数：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use the **declare_parameter()** method from the **rclcpp::Node** class.
    The arguments are the same as for Python: name and default value. From this value,
    the parameter type will be set.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **rclcpp::Node** 类的 **declare_parameter()** 方法。参数与Python中的相同：名称和默认值。从这个值中，参数类型将被设置。
- en: 'Then, to get a parameter’s value in the code, write the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要在代码中获取一个参数的值，请编写以下内容：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We use the **get_parameter()** method and provide the name for the parameter.
    Then, we get the value with the method that corresponds to the data type: **as_int()**,
    **as_double()**, **as_string()**, **as_string_array()**, and so on. If you have
    an IDE with auto-completion, you should be able to see all possible types.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **get_parameter()** 方法并提供参数的名称。然后，我们使用对应于数据类型的方法获取值：**as_int()**、**as_double()**、**as_string()**、**as_string_array()**
    等。如果你有一个具有自动完成的IDE，你应该能够看到所有可能的数据类型。
- en: The rest is the same as for Python. Please refer to the GitHub files for any
    other minor changes and additions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分与Python相同。请参考GitHub文件以了解任何其他细微的更改和添加。
- en: 'To start a node with parameters, run the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要带参数启动节点，请运行以下命令：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Working with parameters is not that tough. For each parameter you want to create,
    you have to declare it in the code and get its value. When starting the node from
    the terminal, you can specify a value for each parameter you want.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与参数一起工作并不那么困难。对于你想要创建的每个参数，你必须在代码中声明它并获取其值。当从终端启动节点时，你可以为每个参数指定一个值。
- en: Now, that works well only if you have a small number of parameters. In a real
    application, it’s not uncommon to have a few dozen or even hundreds of parameters
    for a node. How can you manage so many parameters?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这只有在参数数量较少的情况下才有效。在实际应用程序中，一个节点有几十个甚至几百个参数并不罕见。你如何管理这么多参数？
- en: Storing parameters in YAML files
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将参数存储在YAML文件中
- en: As your ROS 2 application grows, so will the number of parameters. Adding 10
    or more parameters from the command line is not really an option anymore.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的ROS 2应用程序的增长，参数的数量也会增加。从命令行添加10个或更多的参数已经不再是可行的选项。
- en: Fortunately, you can use YAML files to store your parameters, and you can load
    these files at runtime. If you don’t know YAML, it’s basically a markup language,
    similar to XML and JSON, but supposedly more readable by humans.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用YAML文件来存储你的参数，并且你可以在运行时加载这些文件。如果你不了解YAML，它基本上是一种标记语言，类似于XML和JSON，但据说比人类更容易阅读。
- en: In this section, you will learn how to add your parameters to a YAML file and
    how to load this file at runtime.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何将你的参数添加到YAML文件中，以及如何在运行时加载此文件。
- en: Loading parameters from a YAML file
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从YAML文件加载参数
- en: Let’s start by saving parameters into a file so we can use them when we start
    a node.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先保存参数到一个文件中，这样我们就可以在启动节点时使用它们。
- en: First, create a YAML file with the **.yaml** extension. The filename doesn’t
    matter that much, but it’s better to give it a meaningful name. As our application
    deals with numbers, we can name it **number_params.yaml**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个具有 **.yaml** 扩展名的YAML文件。文件名并不那么重要，但最好给它一个有意义的名字。由于我们的应用程序处理数字，我们可以将其命名为
    **number_params.yaml**。
- en: 'For now, let’s just create a new file in our home directory (in the next chapter,
    we will see how to properly install a YAML file in a ROS 2 application):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的主目录中创建一个新文件（在下一章中，我们将看到如何在ROS 2应用程序中正确安装YAML文件）：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Edit this file and add parameters for the **/****number_publisher** node:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑此文件并添加 **/****number_publisher** 节点的参数：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, you write the name of the node. On the next line, and with an indentation
    (usually, it’s recommended to use two spaces), we add **ros__parameters** (make
    sure you use two underscores). This will be the same for every node you add in
    a YAML file. On the following lines, and with yet another indentation, you can
    add all the parameters’ values for the node.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你写下节点的名称。在下一行，并使用缩进（通常建议使用两个空格），我们添加 **ros__parameters**（确保你使用两个下划线）。这将是
    YAML 文件中每个节点的相同设置。在接下来的几行中，并使用更多的缩进，你可以添加节点的所有参数值。
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important that the node name matches; otherwise, the parameters won’t be
    loaded into the node. If you omit the leading slash, it would still work for loading
    parameters with `ros2 run`, but you could have issues with other commands.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 确保节点名称匹配；否则，参数不会被加载到节点中。如果你省略了前面的斜杠，使用 `ros2 run` 加载参数仍然可以工作，但可能会与其他命令出现问题。
- en: 'Once you’ve written this file, you can load the parameters with the **--****params-file**
    argument:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写了这个文件，你可以使用 **--params-file** 参数来加载参数：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will start the node and specify the values for the **number** and **publish_period**
    parameters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动节点并指定 **number** 和 **publish_period** 参数的值。
- en: If you have two or fifty parameters, the **ros2 run** command stays the same.
    All you have to do is add more parameters in the YAML file. If you want to modify
    a parameter, you can modify the corresponding line in the file or even create
    several files for different sets of configurations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有两个或五十个参数，**ros2 run** 命令保持不变。你所要做的就是向 YAML 文件中添加更多参数。如果你想修改一个参数，你可以修改文件中的对应行，甚至为不同的配置集创建几个文件。
- en: Parameters for multiple nodes
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个节点的参数
- en: What should you do if you want to save parameters for several nodes?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为多个节点保存参数，你应该怎么做？
- en: 'Good news: inside one param YAML file, you can add the configuration for as
    many nodes as you want. Here’s an example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息：在一个 param YAML 文件中，你可以为任意多个节点添加配置。以下是一个示例：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This corresponds to the example we ran before, with two nodes and different
    parameters.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于我们之前运行过的示例，有两个节点和不同的参数。
- en: Now, to start the same nodes and parameters, we only need to run the commands
    shown next.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了启动相同的节点和参数，我们只需要运行下面的命令。
- en: 'In Terminal 1, run the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端1中，运行以下命令：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Terminal 2, run the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端2中，运行以下命令：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We give the same YAML file to both nodes. Each node will only load the parameters’
    values that are defined under the node name.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将相同的 YAML 文件给两个节点。每个节点将只加载在节点名称下定义的参数值。
- en: Recapping all parameters’ data types
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾所有参数的数据类型
- en: 'Let’s say you have all those parameters declared in your code (Python example
    only, but you can easily translate to C++):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经在你的代码中声明了所有这些参数（仅以 Python 为例，但你可以轻松地将其转换为 C++）：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Those are basically all the available data types for parameters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本上是参数的所有可用数据类型。
- en: 'To specify the value for each parameter, you can create a YAML file or add
    some configuration to an existing YAML file. Here is what you would write for
    this node (named **your_node**):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定每个参数的值，你可以创建一个 YAML 文件或在现有的 YAML 文件中添加一些配置。以下是为你这个节点（命名为 **your_node**）编写的代码：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With YAML files, you will be able to customize your nodes in a quick and efficient
    way. I recommend using them as soon as you get more than a few parameters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 YAML 文件，你可以快速高效地自定义节点。我建议在参数超过几个时立即使用它们。
- en: Also, as you continue your journey with ROS 2, you will start to use nodes and
    complete stacks developed by other developers. Those nodes often come with a bunch
    of YAML files that allow you to configure the stack without having to change anything
    in the nodes directly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着你继续使用 ROS 2，你将开始使用其他开发者开发的节点和完整的堆栈。这些节点通常附带一些 YAML 文件，允许你配置堆栈而无需直接更改节点中的任何内容。
- en: Let’s now continue with the command-line tools. You have set the parameters’
    values with **ros2 run**, but there are actually more tools to handle parameters.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续介绍命令行工具。你已经使用 **ros2 run** 设置了参数的值，但实际上还有更多工具可以处理参数。
- en: Additional tools for handling parameters
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理参数的附加工具
- en: 'You start to get used to it: for each ROS 2 core concept, we get a dedicated
    **ros2** command-line tool. For parameters, we have **ros2 param**.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始习惯了：对于每个 ROS 2 核心概念，我们都有一个专门的 **ros2** 命令行工具。对于参数，我们有 **ros2 param**。
- en: You can see all the commands with **ros2 param -h**. Let’s focus on the most
    important ones so that we can get parameters’ values from the terminal and set
    some values after the node has been started. At the end of this section, we will
    also explore the different parameter services available for all nodes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 **ros2 param -h** 查看所有命令。让我们关注最重要的命令，以便我们可以从终端获取参数值，并在节点启动后设置一些值。在本节的最后，我们还将探索所有节点可用的不同参数服务。
- en: Getting parameters’ values from the terminal
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从终端获取参数值
- en: After you’ve started one or several nodes, you can list all available parameters
    with **ros2** **param list**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在您启动了一个或多个节点后，您可以使用 **ros2 param list** 列出所有可用的参数。
- en: Stop all nodes and start two nodes, **num_pub1** and **num_pub2**, either by
    using the YAML file or by providing the parameters’ values manually.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 停止所有节点并启动两个节点，**num_pub1** 和 **num_pub2**，可以通过使用 YAML 文件或手动提供参数值来实现。
- en: 'In Terminal 1, run the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端 1 中运行以下命令：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In Terminal 2, run the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端 2 中运行以下命令：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, list all available parameters:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，列出所有可用的参数：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, I started two nodes to show you that each node gets its own set of parameters.
    The **number** parameter inside **/num_pub1** is not the same as the **number**
    parameter inside **/num_pub2**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我启动了两个节点以向您展示每个节点都有自己的参数集。**/num_pub1** 中的 **number** 参数与 **/num_pub2**
    中的 **number** 参数不同。
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For each parameter, we also always get the `use_sim_time` parameter with a default
    value of `false`. This means that we use the system clock. We would set it to
    `true` if we were simulating the robot so that we could use the simulation engine
    clock instead. This is not important for now, and you can ignore this parameter.
    You can also ignore the `start_type_description_service` parameter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个参数，我们也会始终获取一个 `use_sim_time` 参数，默认值为 `false`。这意味着我们使用系统时钟。如果我们正在模拟机器人，我们会将其设置为
    `true`，以便我们可以使用模拟引擎时钟。这对现在来说并不重要，您可以忽略此参数。您也可以忽略 `start_type_description_service`
    参数。
- en: 'From this, you can get the value for one specific parameter, using **ros2 param
    get <****node_name> <param_name>**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从此，您可以使用 **ros2 param get <节点名> <参数名>** 获取一个特定参数的值：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This corresponds to the values we have set when starting the node. Using **ros2
    param get** allows you to introspect the parameters inside any running node.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于我们在启动节点时设置的值。使用 **ros2 param get** 允许您检查任何运行节点内部的参数。
- en: Exporting parameters into YAML
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将参数导出到 YAML
- en: If you’d like to get the complete set of parameters for a node, you can do so
    with **ros2 param** **dump <node_name>**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想获取一个节点的完整参数集，可以使用 **ros2 param dump <节点名>** 来实现。
- en: Let’s dump all parameters for the nodes we are running.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出我们正在运行的节点上的所有参数。
- en: 'For the first node, run the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个节点，运行以下命令：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For the second node, run the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个节点，运行以下命令：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the output is exactly what you need to write inside a YAML file.
    You can then just copy and paste what you get in the terminal and create your
    own YAML file to load later (there’s no need to set **use_sim_time** and **start_type_description_service**).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出结果正是您需要写入 YAML 文件中的内容。您可以将终端中获取的内容复制粘贴，创建自己的 YAML 文件以供稍后加载（无需设置 **use_sim_time**
    和 **start_type_description_service**）。
- en: This **ros2 param dump** command can be useful for getting all parameters’ values
    at once and for building a param YAML file quickly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 **ros2 param dump** 命令可以用于一次性获取所有参数值，并快速构建一个参数 YAML 文件。
- en: Setting a parameter’s value from the terminal
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从终端设置参数值
- en: Parameters are actually not set in stone for the entire life of a node. After
    you initialize a parameter’s value with **ros2 run**, you can modify it from the
    terminal.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 参数实际上并不是在节点的整个生命周期中固定不变的。在您使用 **ros2 run** 初始化参数值后，您可以从终端修改它。
- en: With our camera driver example, let’s say you disconnect and reconnect the camera.
    The device name might change on Linux. If it were **/dev/ttyUSB0**, now it could
    be **/dev/ttyUSB1**. You could stop and start the node again with a different
    value for the device name parameter, but with the **ros2 param set** command,
    you could also just change the value directly while the node is still running.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的相机驱动程序为例，假设您断开并重新连接相机。在 Linux 上，设备名称可能会改变。如果它是 **/dev/ttyUSB0**，现在它可能是 **/dev/ttyUSB1**。您可以通过为设备名称参数设置不同的值来停止并重新启动节点，但使用
    **ros2 param set** 命令，您也可以在节点仍在运行时直接更改值。
- en: To show you how it works, let’s come back to our number application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示它是如何工作的，让我们回到我们的数字应用。
- en: 'Stop all nodes and start one **number_publisher** node (here, I don’t provide
    any parameter; we will use the default values):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 停止所有节点并启动一个**number_publisher**节点（在这里，我不提供任何参数；我们将使用默认值）：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s just verify the value for the **number** parameter:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证**number**参数的值：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To modify a parameter from the terminal, you have to run **ros2 param set <node_name>
    <param_name> <new_value>**, as in the following example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要从终端修改参数，您必须运行**ros2 param set <node_name> <param_name> <new_value>**，如下面的示例所示：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Of course, make sure to provide the correct data type for the parameter; otherwise,
    you will get an error. You can also load a YAML file directly with **ros2 param
    load <node_name> <yaml_file>** so that you can set several parameters at the same
    time:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，请确保为参数提供正确的数据类型；否则，您将得到一个错误。您还可以使用**ros2 param load <node_name> <yaml_file>**直接加载YAML文件，这样您可以同时设置多个参数：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After modifying a parameter, we check the parameter’s value again:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 修改参数后，我们再次检查参数的值：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the value was successfully changed. However, did this really
    work? Is the new parameter’s value used in the code?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，值已成功更改。然而，这真的有效吗？代码中使用了新参数的值吗？
- en: 'Let’s verify that we are publishing the correct number:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证我们是否正在发布正确的数字：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Even if we changed the parameter’s value, the new value was not updated inside
    the code. To do that, we will need to add a parameter callback. That’s what we
    will see in a minute, but for now, let’s just finish this section with the extra
    existing services that allow you to manage parameters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经更改了参数的值，新的值也没有在代码内部更新。为了做到这一点，我们需要添加一个参数回调。这就是我们将在下一分钟看到的内容，但现在，让我们通过额外存在的允许您管理参数的服务来完成这个部分。
- en: Parameter services
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数服务
- en: If you remember, when we worked on services, you saw that for each node, we
    got an additional set of seven services, most of them related to parameters.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，当我们处理服务时，您看到对于每个节点，我们得到了一组额外的七个服务，其中大多数与参数相关。
- en: 'List all services for the **number_publisher** node:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列出**number_publisher**节点的所有服务：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With those services, you can list parameters, get their value, and even set
    new values. Those services basically give you the same functionalities as the
    **ros2 param** command-line tool.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些服务，您可以列出参数，获取它们的值，甚至设置新值。这些服务基本上提供了与**ros2 param**命令行工具相同的函数。
- en: This is good news because getting and setting parameters from the terminal is
    not really practical and scalable in a real application. By using those services,
    you can create a service client in node A, which will get or modify parameters
    in node B.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好消息，因为从终端获取和设置参数在真实应用中并不实用且可扩展。通过使用这些服务，您可以在节点A中创建一个服务客户端，该客户端将获取或修改节点B中的参数。
- en: 'I will not dive too far into this; you can experiment on your own with what
    you saw in [*Chapter 6*](B22403_06.xhtml#_idTextAnchor282). Let’s just do a quick
    example here by modifying the **number** parameter. Let’s first check which interface
    you need to use:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入探讨这个问题；您可以自己尝试使用您在[*第6章*](B22403_06.xhtml#_idTextAnchor282)中看到的内容。这里我们通过修改**number**参数来做一个小例子。首先，让我们检查您需要使用哪个接口：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, you can get more details with **ros2 interface show**. Finally, you can
    create a service client (inside a node) to modify a parameter. Let’s do so from
    the terminal:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用**ros2 interface show**获取更多详细信息。最后，您可以在节点内部创建一个服务客户端来修改一个参数。让我们从终端这样做：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is the same as running **ros2 param set /number_publisher number 3**. The
    benefit of the service is that you can use it inside any of your other nodes,
    with a service client from **rclpy** or **rclcpp**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这与运行**ros2 param set /number_publisher number 3**相同。服务的好处是您可以在任何其他节点中使用它，使用来自**rclpy**或**rclcpp**的服务客户端。
- en: 'If you’re wondering what **type: 2** means in the service request, here are
    all the types you can get or set with the parameter services:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您想知道服务请求中的**type: 2**是什么意思，这里列出了您可以使用参数服务获取或设置的 所有类型：'
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, the number **2** corresponds to the **PARAMETER_INTEGER** type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数字**2**对应于**PARAMETER_INTEGER**类型。
- en: Now that you’ve seen how to set a parameter’s value while the node is already
    running, let’s continue with parameter callbacks. The problem so far is that if
    we modify a parameter, the value doesn’t *reach* the code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何在节点运行时设置参数的值，让我们继续讨论参数回调。到目前为止的问题是我们修改参数时，值没有*到达*代码。
- en: Updating parameters with parameter callbacks
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用参数回调更新参数
- en: After a parameter’s value has been set when the node starts, you can modify
    it from the terminal or with a service client. To be able to receive the new value
    in your code, however, you will need to add what is called a parameter callback.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点启动时参数的值被设置后，你可以从终端或使用服务客户端进行修改。然而，为了在代码中接收新的值，你需要添加一个称为参数回调的东西。
- en: In this section, you will learn how to implement a parameter callback for Python
    and C++. This callback will be triggered whenever a parameter’s value has been
    changed, and we will be able to get the new value in the code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何为 Python 和 C++ 实现参数回调。这个回调将在参数的值被更改时触发，我们将在代码中获取新的值。
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You don’t necessarily need to add parameter callbacks in your nodes. For some
    parameters, you will want to have a fixed value when you start the node and not
    modify this value anymore. Use parameter callbacks only if it makes sense to modify
    some parameters during the execution of a node.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定需要在你的节点中添加参数回调。对于某些参数，你希望在启动节点时有一个固定值，并且不再修改这个值。只有当在节点执行期间修改某些参数有意义时，才使用参数回调。
- en: Parameter callbacks are a great way to change a setting in your node without
    having to create yet another service. Let me explain that with the camera driver
    example. If you want to be able to change the device name while the node is running,
    the default way would be services. You would create a service server in your node
    that accepts requests to change the device name. However, doing this for each
    small setting in your node can be a hassle. With parameters, not only can you
    provide a different device name at runtime, but you can also modify it later by
    using the parameter services that each ROS 2 node already has. There’s no need
    to make it more complicated than that.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 参数回调是改变节点设置的好方法，而不必再创建另一个服务。让我用一个相机驱动程序的例子来解释这一点。如果你想能够在节点运行时更改设备名称，默认的方法将是服务。你将在你的节点中创建一个服务服务器，接受更改设备名称的请求。然而，为节点中的每个小设置这样做可能会很麻烦。使用参数，你不仅可以在运行时提供不同的设备名称，还可以通过使用每个
    ROS 2 节点已经具有的参数服务来稍后修改它。没有必要让它比这更复杂。
- en: Now, let’s see how to solve the issue we had when setting a new value for the
    **number** parameter, and let’s start with Python.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何解决我们设置**number**参数新值时遇到的问题，让我们从 Python 开始。
- en: There are actually several parameter callbacks you could implement, but to keep
    things simple, I will just use one of them. Parameter callbacks are a nice and
    useful functionality, but it’s not necessarily the most important when you begin
    with ROS 2\. Thus, here you will get an overview of the functionality, and feel
    free to do more research on your own after finishing the book (you will find additional
    resources in [*Chapter 14*](B22403_14.xhtml#_idTextAnchor665)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上可以实施几种参数回调，但为了保持简单，我将只使用其中之一。参数回调是一个很好且有用的功能，但当你刚开始使用 ROS 2 时，它可能不是最重要的。因此，在这里你将获得功能概述，并在完成本书后自行进行更多研究（你将在[*第14章*](B22403_14.xhtml#_idTextAnchor665)中找到额外资源）。
- en: Python parameter callback
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 参数回调
- en: Let’s write our first Python parameter callback.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的第一个 Python 参数回调。
- en: 'Open the **number_publisher.py** file and register a parameter callback in
    the node’s constructor:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**number_publisher.py**文件，并在节点构造函数中注册一个参数回调：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We also add a new import line:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一条新的导入语句：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we implement the callback method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现回调方法：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this callback, you receive a list of **Parameter** objects. For each parameter,
    you can access its name, value, and type. With a **for** loop, we go through each
    parameter we get and set the corresponding values in the code. You could also
    decide to validate the values (for example, only accept positive numbers), but
    I will not do that here to keep the code minimal.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调中，你将收到一个**Parameter**对象的列表。对于每个参数，你可以访问其名称、值和类型。使用**for**循环，我们遍历我们得到的每个参数，并在代码中设置相应的值。你也可以决定验证值（例如，只接受正数），但在这里我将不会这样做，以保持代码最小化。
- en: 'To make a quick test, run the **number_publisher** node again (no specified
    params; default values will be used). In another terminal, subscribe to the **/****number**
    topic:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行快速测试，再次运行**number_publisher**节点（未指定参数；将使用默认值）。在另一个终端中，订阅**/****number**主题：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, change the parameter’s value:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更改参数的值：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s now go back to the other terminal to observe the change:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在回到另一个终端去观察变化：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The parameter’s value has been changed, and we have received this value in the
    code, thanks to the parameter callback.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的值已经更改，我们通过参数回调在代码中收到了这个值。
- en: C++ parameter callback
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++参数回调
- en: 'The behavior for parameter callbacks in C++ is exactly the same as for Python.
    Let’s have a look at the syntax. Open the **number_publisher.cpp** file and register
    the parameter callback in the constructor:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: C++中参数回调的行为与Python中完全相同。让我们看看语法。打开**number_publisher.cpp**文件，并在构造函数中注册参数回调：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is the implementation for the callback:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是回调的实现：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We get a list of **rclcpp::Parameter** objects. From this, we can check each
    parameter’s name with the **get_name()** method. If the parameter’s name matches,
    we get the value. Since we are receiving an integer here, we use the **as_int()**
    method. For a string, you would use the **as_string()** method, and so on. Please
    refer to the GitHub files for the complete code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个**rclcpp::Parameter**对象的列表。从这个列表中，我们可以使用**get_name()**方法检查每个参数的名称。如果参数的名称匹配，我们就获取值。由于我们在这里接收的是整数，我们使用**as_int()**方法。对于字符串，你会使用**as_string()**方法，等等。请参考GitHub文件以获取完整的代码。
- en: You have now seen the basics of parameter callbacks. You will not necessarily
    add them to all your nodes. They are great if you need to be able to modify a
    parameter’s value after the node has been started.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了参数回调的基础。你并不一定需要在所有节点中添加它们。如果你需要在节点启动后修改参数的值，它们是非常有用的。
- en: Let’s end this chapter with an additional challenge to make you practice more
    with parameters.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个额外的挑战结束这一章，以便让你更多地练习使用参数。
- en: Parameter challenge
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数挑战
- en: 'With this challenge, you will practice everything you’ve seen in this chapter:
    declaring and getting parameters in your code, providing parameters’ values at
    runtime, and saving the values inside a YAML file. We will just skip parameter
    callbacks, but feel free to add them if you want to practice those too.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个挑战，你将练习这一章中看到的所有内容：在代码中声明和获取参数，在运行时提供参数的值，并将值保存在YAML文件中。我们将跳过参数回调，但如果你也想练习这些，请随意添加。
- en: As usual for challenges, I will first explain what the challenge is and then
    provide the Python solution. You can find the complete code for both Python and
    C++ in the book’s GitHub repository.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于挑战，我首先会解释挑战的内容，然后提供Python解决方案。你可以在书的GitHub仓库中找到Python和C++的完整代码。
- en: Challenge
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战
- en: 'We will continue to improve the **turtle_controller** node. For this challenge,
    we want to be able to choose different settings at runtime:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续改进**turtle_controller**节点。对于这个挑战，我们希望在运行时能够选择不同的设置：
- en: Pen color on the right side
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的笔颜色
- en: Pen color on the left side
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧的笔颜色
- en: Velocity to publish on the `cmd_vel` topic
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在`cmd_vel`主题上发布的速度
- en: 'To do that, you will add these parameters:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要添加以下参数：
- en: '`color_1`: Instead of just arbitrarily choosing a color for when the turtle
    is on the right side, we rename the color as `color_1`, and we get the value from
    a parameter. This parameter will be an integer list containing three values (`red`,
    `green`, `blue`).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color_1`：当海龟位于右侧时，我们不再随意选择颜色，而是将颜色重命名为`color_1`，并从参数中获取值。这个参数将是一个包含三个值（`红色`、`绿色`、`蓝色`）的整数列表。'
- en: '`color_2`: Same as for `color_1`, this one is the color used when the turtle
    is on the left side of the screen.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color_2`：与`color_1`相同，这是海龟位于屏幕左侧时使用的颜色。'
- en: '`turtle_velocity`: By default, we used `1.0` and `2.0` for velocities sent
    on the `cmd_vel` topic. We make this a parameter so that we can provide the velocity
    at runtime. Instead of `1.0` and `2.0`, we will use `turtle_velocity` and `turtle_velocity
    *` `2.0`.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`turtle_velocity`：默认情况下，我们为发送到`cmd_vel`主题的速度使用了`1.0`和`2.0`。我们将其作为一个参数，以便在运行时提供速度。我们将使用`turtle_velocity`和`turtle_velocity
    * 2.0`代替`1.0`和`2.0`。'
- en: To test this node, you will start the **turtle_controller** node with **ros2
    run** and provide different values for the parameters. You should see if it works
    by watching how fast the turtle is moving and what the colors are for the pen.
    If needed, add some logs in the code to see what’s happening.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个节点，你需要使用**ros2 run**启动**turtle_controller**节点，并为参数提供不同的值。你应该通过观察海龟移动的速度和笔的颜色来检查它是否工作。如果需要，可以在代码中添加一些日志来查看发生了什么。
- en: As a last step for this challenge, you can put all the parameters inside a YAML
    file and load this YAML file at runtime.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个挑战的最后一步，你可以将所有参数放入一个YAML文件中，并在运行时加载这个YAML文件。
- en: Solution
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Let’s start by declaring the parameters that we will need for this challenge.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先声明我们将需要用于这个挑战的参数。
- en: 'Open the **turtle_controller.py** file. Let’s declare a few parameters at the
    beginning of the node’s constructor:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **turtle_controller.py** 文件。让我们在节点构造函数的开始处声明一些参数：
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We provide default values that correspond to the same values we previously hardcoded.
    Thus, if we start the node without providing any parameters, the behavior will
    be the same as before.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了与之前硬编码的相同值的默认值。因此，如果我们不提供任何参数就启动节点，行为将与之前相同。
- en: 'After declaring the parameters, we can get their values:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 声明参数后，我们可以获取它们的值：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We store the values inside class attributes so that we can reuse them later
    in the code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将值存储在类属性中，以便我们可以在代码的后续部分重用它们。
- en: Note
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a reminder, in Python, don’t forget to add `.value` (without any parentheses)
    after `get_parameter()`. This is a common error that will lead to an exception
    when you start the node.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，在 Python 中，别忘了在 `get_parameter()` 后面添加 `.value`（不带任何括号）。这是一个常见的错误，当启动节点时会导致异常。
- en: 'Then, we modify a few lines in the **callback_pose()** method:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 **callback_pose()** 方法中修改了几行：
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Instead of hardcoding the velocity value, we use the one we got from the parameter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用硬编码的速率值，而是使用我们从参数中获取的值。
- en: 'Then, we set the pen color:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置笔的颜色：
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we modify the logs so that they make more sense, as the color could be
    anything.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了日志，使其更有意义，因为颜色可以是任何东西。
- en: Finally, there are different ways you could pass the integer array to the **call_set_pen()**
    method. You could modify **call_set_pen()** so that it receives an array of three
    integers and extracts each number from it. Or, like I did here, you don’t modify
    the method and you just make sure to pass the correct arguments.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有几种不同的方法可以将整数数组传递给 **call_set_pen()** 方法。你可以修改 **call_set_pen()**，使其接收一个包含三个整数的数组并从中提取每个数字。或者，像我这里做的那样，你不需要修改该方法，只需确保传递正确的参数即可。
- en: 'The code is now finished. To test it, start the **turtlesim** node in one terminal
    and the **turtle_controller** node in another one. You can provide different values
    for the parameters. For example, if we want the velocity to be **1.5** and the
    colors to be black and white, we run the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在已完成。要测试它，在一个终端中启动 **turtlesim** 节点，在另一个终端中启动 **turtle_controller** 节点。你可以为参数提供不同的值。例如，如果我们想速度为
    **1.5**，颜色为黑白，我们运行以下命令：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can also save those parameters inside a YAML file. Create a new YAML file
    (for example, in your home directory) named **turtle_params.yaml**. In this file,
    write this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这些参数保存在一个 YAML 文件中。创建一个新的 YAML 文件（例如，在你的家目录中），命名为 **turtle_params.yaml**。在这个文件中，写入以下内容：
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, you can start the turtle controller node with the YAML file directly:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以直接使用 YAML 文件启动 turtle 控制器节点：
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That’s it for this challenge. In the end, for each parameter, we did three
    things: we declared it, got its value, and used it in the code. This is not too
    complicated, and if you just know how to do that, you will be able to successfully
    handle parameters in your future ROS 2 applications.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战就到这里。最后，对于每个参数，我们做了三件事：我们声明了它，获取了它的值，并在代码中使用了它。这并不复杂，如果你只是知道如何做，你将能够成功地处理你未来
    ROS 2 应用程序中的参数。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you worked on parameters. Parameters allow you to provide settings
    for your nodes at runtime. Thus, with the same code, you could start several different
    nodes with different configurations. This increases the code reusability a lot.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你处理了参数。参数允许你在运行时为你的节点提供设置。因此，使用相同的代码，你可以启动具有不同配置的几个不同的节点。这大大增加了代码的可重用性。
- en: 'To handle parameters in your nodes, follow these guidelines:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理节点中的参数，请遵循以下指南：
- en: Declare the parameter so that it exists within the node. The best practice is
    to set a default value. This value will also set the type for the parameter.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明参数，使其在节点内存在。最佳实践是设置一个默认值。这个值也将设置参数的类型。
- en: Get the parameter’s value and store it in your node—for example, in a private
    attribute.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取参数的值并将其存储在你的节点中——例如，在一个私有属性中。
- en: Use this value in your code.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码中使用这个值。
- en: Then, when you start a node with **ros2 run**, you can specify any parameter’s
    value you want.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你使用 **ros2 run** 启动一个节点时，你可以指定任何你想要的参数值。
- en: You can also organize your parameters inside a YAML file, which makes it much
    more convenient when you start to have more than a handful of parameters. You
    will load the YAML file when you start a node.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将参数组织在一个 YAML 文件中，当您开始拥有超过几个参数时，这将变得非常方便。您将在启动节点时加载该 YAML 文件。
- en: Finally, you can also decide to allow parameters to be modified even after you’ve
    started a node. To do that, you will need to implement parameter callbacks.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以决定在启动节点后允许修改参数。为此，您需要实现参数回调。
- en: Parameters make your nodes much more dynamic. In almost every node you run,
    you will have parameters. Using them makes it easier to scale your application
    by allowing different sets of configurations to be loaded.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 参数使您的节点变得更加动态。在您运行的几乎每一个节点中，您都会拥有参数。使用它们可以更容易地通过加载不同的配置集来扩展您的应用程序。
- en: Speaking of scaling, in the following chapter, we will dive into launch files.
    With launch files, you can start multiple nodes and parameters at once. This will
    be of great help when your application starts to grow.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 说到扩展，在下一章中，我们将深入探讨启动文件。使用启动文件，您可以同时启动多个节点和参数。当您的应用程序开始增长时，这将非常有帮助。
