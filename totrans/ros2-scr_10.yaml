- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameters – Making Nodes More Dynamic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now done with the basics of ROS 2 communications. In this chapter, we
    will continue to work on nodes, but this time by making them more dynamic with
    **parameters**.
  prefs: []
  type: TYPE_NORMAL
- en: To understand parameters, I will start with why we need them in the first place.
    Then, you will learn how to add parameters to your nodes so that you can customize
    them at runtime. You will also see how to load multiple parameters at once with
    **YAML** files and how to allow parameters to be modified in your code with **parameter
    callbacks**.
  prefs: []
  type: TYPE_NORMAL
- en: As a starting point, we will use the code inside the **ch7** folder of the book’s
    GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
    If you skipped *actions* ([*Chapter 7*](B22403_07.xhtml#_idTextAnchor338)), you
    can also start from the **ch6** folder, which will work the same. The final code
    for this chapter will be in the **ch8** folder.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to add parameters to any of your
    nodes and handle parameters for other nodes that you start.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of parameters is not too difficult, and there won’t be too much
    to do in the code. However, it’s an important concept and the first step toward
    making your application more dynamic and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a ROS 2 parameter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using parameters in your nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing parameters in YAML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional tools to handle parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating parameters with parameter callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter challenge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a ROS 2 parameter?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have already experimented a bit with parameters in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092),
    where you ran a node with different settings.
  prefs: []
  type: TYPE_NORMAL
- en: I am now going to start from scratch again and explain parameters with a real-life
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Why parameters?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with a problem to understand the need for parameters. I will use
    a camera driver as an example—we won’t write the node; it’s just for the explanation.
  prefs: []
  type: TYPE_NORMAL
- en: This camera driver connects to a USB camera, reads images, and publishes them
    on a ROS 2 topic. This is classic behavior for any ROS 2 hardware driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this node, you will have some variables for different kinds of settings.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: USB device name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frames per second (FPS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulation mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s say the camera you’re working on is connected to the **/dev/ttyUSB0**
    port (typical USB port name on Linux). You want to set **60** FPS and not use
    the simulation mode (**false**). Those are the values you will write for the variables
    inside your node.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, if the USB device name is different (for example, **/dev/ttyUSB1**),
    you will have to change that setting in your code and maybe build again—you'll
    do the same thing if you want to start your camera with **30** FPS instead of
    **60** FPS, or if you want to run it in simulation mode.
  prefs: []
  type: TYPE_NORMAL
- en: Also, what if you have two cameras, and you want to use them both at the same
    time? Will you duplicate your code for each camera? How can you handle the different
    settings for both cameras?
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, hardcoding those settings in your code is not a great option
    for reusability. This is why we have ROS 2 parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a node with parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A ROS 2 parameter is basically a setting for a node that you can modify when
    you start the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we keep the camera driver example, we could add three parameters—USB
    device name (string), FPS value (integer), and simulation mode (boolean):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – A node class with three parameters](img/B22403_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – A node class with three parameters
  prefs: []
  type: TYPE_NORMAL
- en: When you start this camera driver with **ros2 run** (we will see how to do that
    later in this chapter), you will be able to provide the values you want for those
    three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to start two nodes for two different cameras, given the
    following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Port: `/dev/ttyUSB0`; FPS: `30`; simulation mode: off'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Port: `/dev/ttyUSB1`; FPS: `60`; simulation mode: off'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the parameters we’ve added in the code, we can start the same node multiple
    times with different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Starting two nodes with different settings](img/B22403_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Starting two nodes with different settings
  prefs: []
  type: TYPE_NORMAL
- en: From the same code, we start two different nodes. At runtime, we rename the
    nodes (because we can’t have two nodes with the same name), and we provide the
    parameters’ values.
  prefs: []
  type: TYPE_NORMAL
- en: Our two camera nodes are now running, each with a different configuration. You
    could stop one camera node and start it again with a different set of values.
  prefs: []
  type: TYPE_NORMAL
- en: ROS 2 parameters – wrapping things up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With parameters, you can reuse the same code and start several nodes with different
    settings. There’s no need to compile or build anything again; you just have to
    provide the parameters’ values at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Making your nodes customizable allows for greater flexibility and reusability.
    Your application will become much more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters are also very convenient for collaborating with other ROS developers.
    If you develop a node that could be reused by others, then with parameters, you
    allow other developers to fully customize the node without even having to look
    at the code. This also applies when using existing nodes. Lots of them can be
    configured at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few important points about parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Just as with a variable, a parameter has a name and a data type. Among the most
    common types, you can use booleans, integer numbers, float numbers, strings, and
    lists of those types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A parameter’s value is specific to a node. If you kill the node, the value is
    gone with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set the value for each parameter when you start a node with `ros2 run`
    (or from a launch file, which we will see in the next chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, how to add parameters to your code? As for nodes, topics, and services,
    you will get everything you need from the **rclpy** and **rclcpp** libraries.
    You will be able to declare the parameters in your code and get the value for
    each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Using parameters in your nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue with the code we have written in the previous chapters. Here,
    we will improve the **number_publisher** node. As a quick recap, this node publishes
    a number on a topic, at a given rate. The number and publishing rate are directly
    written in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, instead of hardcoding the number and publishing rate values, we will use
    parameters. This way, we will be able to specify what number to publish, and the
    publishing frequency or period, when we start the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to follow two steps to be able to use a parameter in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the parameter in the node. This will make the parameter exist within
    the node so that you can set a value to it when starting the node with `ros2 run`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the parameter’s value so that you can use it in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start with Python, and later on, we will also see the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring, getting, and using parameters with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before using a parameter, we need to declare it. Where should we declare parameters?
    We will do that in the node’s constructor, before everything else. To declare
    a parameter, use the **declare_parameter()** method from the **Node** class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will provide two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameter name**: This is the name that you will use to set the parameter’s
    value at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default value**: If the parameter’s value is not provided at runtime, this
    value will be used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are, in fact, different ways to declare a parameter. You don’t necessarily
    need to provide a default value if you provide the parameter type instead. However,
    we will keep things like that, as it will probably make your life easier. Adding
    a default value for each parameter is a best practice to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **number_publisher.py** file, and let’s declare two parameters in
    the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A parameter is defined by a name and a data type. Here, you choose the name,
    and the data type will be automatically set depending on the default value you
    have provided. In this example, the default value for **number** is **2**, which
    means that the parameter’s data type is integer. For the **publish_period** parameter,
    the default value is **1.0**, which is a float number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more examples of different data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.declare_parameter("simulation_mode", False)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.declare_parameter("device_name", "/dev/ttyUSB0")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.declare_parameter("numbers", [4,` `5, 6])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, declaring a parameter means that it exists within the node, and you can
    set a value from the outside. However, in your code, to be able to use the parameter,
    it’s not enough to declare it. After doing that, you need to get the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you will use the **get_parameter()** method, and provide the parameter’s
    name as an argument. Then, you can access the value with the **value** attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At this point in the code, the **number_** variable (which is a class attribute)
    contains the value that was set for the **number** parameter at runtime with **ros2
    run**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You always need to declare a parameter before getting its value. If you fail
    to do so, when starting the node, you will get an exception (`ParameterNotDeclaredException`)
    as soon as you try to get the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you get the values for all parameters and store them inside variables
    or class attributes, you can use them in your code. Here, we modify the timer
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this, we set the publishing period from the parameter’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s pretty much it for the code. As you can see, there is nothing too complicated.
    For one parameter, you will just add two instructions: one to declare the parameter
    (give it a name and a default value), and another to get its value.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, I’ve been talking about setting a parameter’s value at runtime with **ros2
    run**. How do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: Providing parameters at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before going further, make sure to save the **number_publisher.py** file and
    build the **my_py_pkg** package (if you haven’t used **--****symlink-install**
    before).
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a parameter’s value with the **ros2 run** command, follow the next
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You will first start your node with `ros2 run <``package_name> <exec_name>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, to add any argument after this command, you have to write `--ros-args`
    (only once).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To specify a parameter’s value, write `-p <param_name>:=<param_value>`. You
    can add as many parameters as you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s say we want to start the node and publish the number **3** every **0.5**
    seconds. In that case, we’d run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify it’s working, we can subscribe to the **/****number** topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also verify the publish rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, what happened? You provided some values for different parameters at runtime.
    The node will start and recognize those parameters because they match the names
    that have been declared in the code. Then, the node can get the value for each
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you provide the wrong data type for a parameter, you will get an error.
    As seen previously, the data type is set in the code from the default value. In
    this example, the **number** parameter should be an integer number. Look at what
    happens if we try to set a double value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, once a parameter type is set in the code, you have to use that
    exact same type whenever you provide a value at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'As each parameter has a default value, you could also omit one or more parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the **publish_period** parameter will be set to its default value
    (**1.0**), defined in the code.
  prefs: []
  type: TYPE_NORMAL
- en: To finish here, let’s just see an example where renaming the node and setting
    parameters’ values can allow you to run several different nodes from the same
    code without having to modify anything in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In Terminal 2, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this, you have two nodes (**num_pub1** and **num_pub2**), both publishing
    to the **/number** topic but with different data and publishing rates. With this
    example, you can see that parameters are a great way to make your nodes more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now finish this section with the C++ code for parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters with C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameters work the same for Python and C++; only the syntax differs. Here,
    we will modify the **number_publisher.cpp** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constructor, you can declare some parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the **declare_parameter()** method from the **rclcpp::Node** class.
    The arguments are the same as for Python: name and default value. From this value,
    the parameter type will be set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to get a parameter’s value in the code, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the **get_parameter()** method and provide the name for the parameter.
    Then, we get the value with the method that corresponds to the data type: **as_int()**,
    **as_double()**, **as_string()**, **as_string_array()**, and so on. If you have
    an IDE with auto-completion, you should be able to see all possible types.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest is the same as for Python. Please refer to the GitHub files for any
    other minor changes and additions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a node with parameters, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Working with parameters is not that tough. For each parameter you want to create,
    you have to declare it in the code and get its value. When starting the node from
    the terminal, you can specify a value for each parameter you want.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that works well only if you have a small number of parameters. In a real
    application, it’s not uncommon to have a few dozen or even hundreds of parameters
    for a node. How can you manage so many parameters?
  prefs: []
  type: TYPE_NORMAL
- en: Storing parameters in YAML files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your ROS 2 application grows, so will the number of parameters. Adding 10
    or more parameters from the command line is not really an option anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you can use YAML files to store your parameters, and you can load
    these files at runtime. If you don’t know YAML, it’s basically a markup language,
    similar to XML and JSON, but supposedly more readable by humans.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to add your parameters to a YAML file and
    how to load this file at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Loading parameters from a YAML file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by saving parameters into a file so we can use them when we start
    a node.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a YAML file with the **.yaml** extension. The filename doesn’t
    matter that much, but it’s better to give it a meaningful name. As our application
    deals with numbers, we can name it **number_params.yaml**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s just create a new file in our home directory (in the next chapter,
    we will see how to properly install a YAML file in a ROS 2 application):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit this file and add parameters for the **/****number_publisher** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the name of the node. On the next line, and with an indentation
    (usually, it’s recommended to use two spaces), we add **ros__parameters** (make
    sure you use two underscores). This will be the same for every node you add in
    a YAML file. On the following lines, and with yet another indentation, you can
    add all the parameters’ values for the node.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important that the node name matches; otherwise, the parameters won’t be
    loaded into the node. If you omit the leading slash, it would still work for loading
    parameters with `ros2 run`, but you could have issues with other commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve written this file, you can load the parameters with the **--****params-file**
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will start the node and specify the values for the **number** and **publish_period**
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If you have two or fifty parameters, the **ros2 run** command stays the same.
    All you have to do is add more parameters in the YAML file. If you want to modify
    a parameter, you can modify the corresponding line in the file or even create
    several files for different sets of configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters for multiple nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What should you do if you want to save parameters for several nodes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Good news: inside one param YAML file, you can add the configuration for as
    many nodes as you want. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This corresponds to the example we ran before, with two nodes and different
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to start the same nodes and parameters, we only need to run the commands
    shown next.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In Terminal 2, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We give the same YAML file to both nodes. Each node will only load the parameters’
    values that are defined under the node name.
  prefs: []
  type: TYPE_NORMAL
- en: Recapping all parameters’ data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you have all those parameters declared in your code (Python example
    only, but you can easily translate to C++):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Those are basically all the available data types for parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the value for each parameter, you can create a YAML file or add
    some configuration to an existing YAML file. Here is what you would write for
    this node (named **your_node**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With YAML files, you will be able to customize your nodes in a quick and efficient
    way. I recommend using them as soon as you get more than a few parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as you continue your journey with ROS 2, you will start to use nodes and
    complete stacks developed by other developers. Those nodes often come with a bunch
    of YAML files that allow you to configure the stack without having to change anything
    in the nodes directly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now continue with the command-line tools. You have set the parameters’
    values with **ros2 run**, but there are actually more tools to handle parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Additional tools for handling parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You start to get used to it: for each ROS 2 core concept, we get a dedicated
    **ros2** command-line tool. For parameters, we have **ros2 param**.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see all the commands with **ros2 param -h**. Let’s focus on the most
    important ones so that we can get parameters’ values from the terminal and set
    some values after the node has been started. At the end of this section, we will
    also explore the different parameter services available for all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting parameters’ values from the terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After you’ve started one or several nodes, you can list all available parameters
    with **ros2** **param list**.
  prefs: []
  type: TYPE_NORMAL
- en: Stop all nodes and start two nodes, **num_pub1** and **num_pub2**, either by
    using the YAML file or by providing the parameters’ values manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In Terminal 2, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, list all available parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, I started two nodes to show you that each node gets its own set of parameters.
    The **number** parameter inside **/num_pub1** is not the same as the **number**
    parameter inside **/num_pub2**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For each parameter, we also always get the `use_sim_time` parameter with a default
    value of `false`. This means that we use the system clock. We would set it to
    `true` if we were simulating the robot so that we could use the simulation engine
    clock instead. This is not important for now, and you can ignore this parameter.
    You can also ignore the `start_type_description_service` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, you can get the value for one specific parameter, using **ros2 param
    get <****node_name> <param_name>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This corresponds to the values we have set when starting the node. Using **ros2
    param get** allows you to introspect the parameters inside any running node.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting parameters into YAML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’d like to get the complete set of parameters for a node, you can do so
    with **ros2 param** **dump <node_name>**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dump all parameters for the nodes we are running.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first node, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second node, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output is exactly what you need to write inside a YAML file.
    You can then just copy and paste what you get in the terminal and create your
    own YAML file to load later (there’s no need to set **use_sim_time** and **start_type_description_service**).
  prefs: []
  type: TYPE_NORMAL
- en: This **ros2 param dump** command can be useful for getting all parameters’ values
    at once and for building a param YAML file quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a parameter’s value from the terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameters are actually not set in stone for the entire life of a node. After
    you initialize a parameter’s value with **ros2 run**, you can modify it from the
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: With our camera driver example, let’s say you disconnect and reconnect the camera.
    The device name might change on Linux. If it were **/dev/ttyUSB0**, now it could
    be **/dev/ttyUSB1**. You could stop and start the node again with a different
    value for the device name parameter, but with the **ros2 param set** command,
    you could also just change the value directly while the node is still running.
  prefs: []
  type: TYPE_NORMAL
- en: To show you how it works, let’s come back to our number application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop all nodes and start one **number_publisher** node (here, I don’t provide
    any parameter; we will use the default values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s just verify the value for the **number** parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To modify a parameter from the terminal, you have to run **ros2 param set <node_name>
    <param_name> <new_value>**, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, make sure to provide the correct data type for the parameter; otherwise,
    you will get an error. You can also load a YAML file directly with **ros2 param
    load <node_name> <yaml_file>** so that you can set several parameters at the same
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After modifying a parameter, we check the parameter’s value again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the value was successfully changed. However, did this really
    work? Is the new parameter’s value used in the code?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s verify that we are publishing the correct number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Even if we changed the parameter’s value, the new value was not updated inside
    the code. To do that, we will need to add a parameter callback. That’s what we
    will see in a minute, but for now, let’s just finish this section with the extra
    existing services that allow you to manage parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you remember, when we worked on services, you saw that for each node, we
    got an additional set of seven services, most of them related to parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'List all services for the **number_publisher** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With those services, you can list parameters, get their value, and even set
    new values. Those services basically give you the same functionalities as the
    **ros2 param** command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: This is good news because getting and setting parameters from the terminal is
    not really practical and scalable in a real application. By using those services,
    you can create a service client in node A, which will get or modify parameters
    in node B.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will not dive too far into this; you can experiment on your own with what
    you saw in [*Chapter 6*](B22403_06.xhtml#_idTextAnchor282). Let’s just do a quick
    example here by modifying the **number** parameter. Let’s first check which interface
    you need to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can get more details with **ros2 interface show**. Finally, you can
    create a service client (inside a node) to modify a parameter. Let’s do so from
    the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as running **ros2 param set /number_publisher number 3**. The
    benefit of the service is that you can use it inside any of your other nodes,
    with a service client from **rclpy** or **rclcpp**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re wondering what **type: 2** means in the service request, here are
    all the types you can get or set with the parameter services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, the number **2** corresponds to the **PARAMETER_INTEGER** type.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to set a parameter’s value while the node is already
    running, let’s continue with parameter callbacks. The problem so far is that if
    we modify a parameter, the value doesn’t *reach* the code.
  prefs: []
  type: TYPE_NORMAL
- en: Updating parameters with parameter callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a parameter’s value has been set when the node starts, you can modify
    it from the terminal or with a service client. To be able to receive the new value
    in your code, however, you will need to add what is called a parameter callback.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to implement a parameter callback for Python
    and C++. This callback will be triggered whenever a parameter’s value has been
    changed, and we will be able to get the new value in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You don’t necessarily need to add parameter callbacks in your nodes. For some
    parameters, you will want to have a fixed value when you start the node and not
    modify this value anymore. Use parameter callbacks only if it makes sense to modify
    some parameters during the execution of a node.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter callbacks are a great way to change a setting in your node without
    having to create yet another service. Let me explain that with the camera driver
    example. If you want to be able to change the device name while the node is running,
    the default way would be services. You would create a service server in your node
    that accepts requests to change the device name. However, doing this for each
    small setting in your node can be a hassle. With parameters, not only can you
    provide a different device name at runtime, but you can also modify it later by
    using the parameter services that each ROS 2 node already has. There’s no need
    to make it more complicated than that.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how to solve the issue we had when setting a new value for the
    **number** parameter, and let’s start with Python.
  prefs: []
  type: TYPE_NORMAL
- en: There are actually several parameter callbacks you could implement, but to keep
    things simple, I will just use one of them. Parameter callbacks are a nice and
    useful functionality, but it’s not necessarily the most important when you begin
    with ROS 2\. Thus, here you will get an overview of the functionality, and feel
    free to do more research on your own after finishing the book (you will find additional
    resources in [*Chapter 14*](B22403_14.xhtml#_idTextAnchor665)).
  prefs: []
  type: TYPE_NORMAL
- en: Python parameter callback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s write our first Python parameter callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **number_publisher.py** file and register a parameter callback in
    the node’s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add a new import line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we implement the callback method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this callback, you receive a list of **Parameter** objects. For each parameter,
    you can access its name, value, and type. With a **for** loop, we go through each
    parameter we get and set the corresponding values in the code. You could also
    decide to validate the values (for example, only accept positive numbers), but
    I will not do that here to keep the code minimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a quick test, run the **number_publisher** node again (no specified
    params; default values will be used). In another terminal, subscribe to the **/****number**
    topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change the parameter’s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now go back to the other terminal to observe the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The parameter’s value has been changed, and we have received this value in the
    code, thanks to the parameter callback.
  prefs: []
  type: TYPE_NORMAL
- en: C++ parameter callback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The behavior for parameter callbacks in C++ is exactly the same as for Python.
    Let’s have a look at the syntax. Open the **number_publisher.cpp** file and register
    the parameter callback in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the implementation for the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We get a list of **rclcpp::Parameter** objects. From this, we can check each
    parameter’s name with the **get_name()** method. If the parameter’s name matches,
    we get the value. Since we are receiving an integer here, we use the **as_int()**
    method. For a string, you would use the **as_string()** method, and so on. Please
    refer to the GitHub files for the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: You have now seen the basics of parameter callbacks. You will not necessarily
    add them to all your nodes. They are great if you need to be able to modify a
    parameter’s value after the node has been started.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s end this chapter with an additional challenge to make you practice more
    with parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this challenge, you will practice everything you’ve seen in this chapter:
    declaring and getting parameters in your code, providing parameters’ values at
    runtime, and saving the values inside a YAML file. We will just skip parameter
    callbacks, but feel free to add them if you want to practice those too.'
  prefs: []
  type: TYPE_NORMAL
- en: As usual for challenges, I will first explain what the challenge is and then
    provide the Python solution. You can find the complete code for both Python and
    C++ in the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will continue to improve the **turtle_controller** node. For this challenge,
    we want to be able to choose different settings at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: Pen color on the right side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pen color on the left side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Velocity to publish on the `cmd_vel` topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do that, you will add these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color_1`: Instead of just arbitrarily choosing a color for when the turtle
    is on the right side, we rename the color as `color_1`, and we get the value from
    a parameter. This parameter will be an integer list containing three values (`red`,
    `green`, `blue`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color_2`: Same as for `color_1`, this one is the color used when the turtle
    is on the left side of the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`turtle_velocity`: By default, we used `1.0` and `2.0` for velocities sent
    on the `cmd_vel` topic. We make this a parameter so that we can provide the velocity
    at runtime. Instead of `1.0` and `2.0`, we will use `turtle_velocity` and `turtle_velocity
    *` `2.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test this node, you will start the **turtle_controller** node with **ros2
    run** and provide different values for the parameters. You should see if it works
    by watching how fast the turtle is moving and what the colors are for the pen.
    If needed, add some logs in the code to see what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: As a last step for this challenge, you can put all the parameters inside a YAML
    file and load this YAML file at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by declaring the parameters that we will need for this challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **turtle_controller.py** file. Let’s declare a few parameters at the
    beginning of the node’s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We provide default values that correspond to the same values we previously hardcoded.
    Thus, if we start the node without providing any parameters, the behavior will
    be the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'After declaring the parameters, we can get their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We store the values inside class attributes so that we can reuse them later
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, in Python, don’t forget to add `.value` (without any parentheses)
    after `get_parameter()`. This is a common error that will lead to an exception
    when you start the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we modify a few lines in the **callback_pose()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Instead of hardcoding the velocity value, we use the one we got from the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we set the pen color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we modify the logs so that they make more sense, as the color could be
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there are different ways you could pass the integer array to the **call_set_pen()**
    method. You could modify **call_set_pen()** so that it receives an array of three
    integers and extracts each number from it. Or, like I did here, you don’t modify
    the method and you just make sure to pass the correct arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is now finished. To test it, start the **turtlesim** node in one terminal
    and the **turtle_controller** node in another one. You can provide different values
    for the parameters. For example, if we want the velocity to be **1.5** and the
    colors to be black and white, we run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also save those parameters inside a YAML file. Create a new YAML file
    (for example, in your home directory) named **turtle_params.yaml**. In this file,
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can start the turtle controller node with the YAML file directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it for this challenge. In the end, for each parameter, we did three
    things: we declared it, got its value, and used it in the code. This is not too
    complicated, and if you just know how to do that, you will be able to successfully
    handle parameters in your future ROS 2 applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you worked on parameters. Parameters allow you to provide settings
    for your nodes at runtime. Thus, with the same code, you could start several different
    nodes with different configurations. This increases the code reusability a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle parameters in your nodes, follow these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the parameter so that it exists within the node. The best practice is
    to set a default value. This value will also set the type for the parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the parameter’s value and store it in your node—for example, in a private
    attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this value in your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, when you start a node with **ros2 run**, you can specify any parameter’s
    value you want.
  prefs: []
  type: TYPE_NORMAL
- en: You can also organize your parameters inside a YAML file, which makes it much
    more convenient when you start to have more than a handful of parameters. You
    will load the YAML file when you start a node.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can also decide to allow parameters to be modified even after you’ve
    started a node. To do that, you will need to implement parameter callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters make your nodes much more dynamic. In almost every node you run,
    you will have parameters. Using them makes it easier to scale your application
    by allowing different sets of configurations to be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of scaling, in the following chapter, we will dive into launch files.
    With launch files, you can start multiple nodes and parameters at once. This will
    be of great help when your application starts to grow.
  prefs: []
  type: TYPE_NORMAL
