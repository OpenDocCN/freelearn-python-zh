- en: Implementing Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All applications operate with data; this is the essence of any process in the
    world of technology. Reusable data storage provides great opportunities for operations,
    because if data stored from an application's previous operations is not used,
    an app will restart its processes each time it runs. In relation to the Qt app
    that we have been building in this book, on startup, the application will be empty
    and will not display any earlier information. In a sense, it is a pure real-time
    application, which can be used with web operations such as scraping, or for simple
    communication and monitoring. There is always a need to save something for use
    again later, however. The examples that were implemented in [Chapter 13](427e029e-38a6-4167-b146-402bd66ff25e.xhtml), *Creating
    Layouts*, are very primitive and don't allow us to reuse data in a more convenient
    way. This chapter will therefore introduce more convenient ways of reusing data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look at various instruments for working with various
    types of data storage, such as files, SQL, and NoSQL. These instruments will mostly be
    third-party packages, but whenever possible, Qt library based modules and classes
    will also be provided. This chapter does not cover the SQL language, as it is an
    implementation of the databases in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Storage with files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage with files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 13](427e029e-38a6-4167-b146-402bd66ff25e.xhtml), *Creating Layouts*,
    we demonstrated how to save data to a text file and later reuse it in an ordinary
    task, such as saving color settings for an application. The Python standard library
    has some other tools for saving various information. Saving text files and retrieving
    strings from these files is a simple, but limited way, of doing this. In some
    cases, it's preferable to save objects and retrieve them for specific tasks. The
    Python standard library includes modules such as `pickle` and `shelve` that can
    help with the serialization and de-serialization of objects, and how to write
    and read them. With Python and the bindings of the Qt library, these modules can
    easily be implemented in our application. We will talk about this in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The pickle module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pickle` module of the Python standard library has binary protocols for
    serializing and de-serializing Python objects. This tool can save objects in a
    file that can be retrieved for various tasks in an application. Python objects
    that can be saved include lists, tuples, dictionaries, and more. Any Python objects
    can be saved to a file, but saving dictionaries, for example, allows us to use
    a data structure that has keys and values. Note that only pickleable objects of
    dicts, lists, tuples, and so on can be pickled. So, let''s add the `pickle` module
    functionality to our application with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `data/` folder in the `App/App_PySide2/` and `App/App_PyQt5/` directories.
    We need to add the following lines to the `u_tools.py` file, which will represent
    various methods for working with  data in the application. To use the `pickle`
    module in our application, we need to add a line with an import statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `import` section of the `u_tools.py` file, add the following statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This module includes the `dump()` and `load()` functions to serialize or de-serialize
    Python objects. These functions write the object to a file object and then load
    the object from a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `pickle_dump()` function, which will serialize objects, to the `UTools`
    class of the `u_tools.py` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function will open the file in binary mode to write and dump the object,
    and will include parameters in relation to the relevant version of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add the `pickle_load()` function, which will de-serialize the
    object, to the `UTools` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function will open the file in binary mode for reading and will load the
    object from a file, with parameters related to the version of Python you are using.
    We now need to make some changes in the application files for easier opening and
    data-saving operations. Open the `u_window.py` file and add some lines to the
    top panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following new selection options in the data section of the top panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These additional selection options will be used later on in this chapter. We
    now need to change the `UApp` class of the `u_app.py` file to be able to use the
    dump and load operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, insert the `Save` button in the `__init__()` function of the `UApp` class
    with a connection to the slots that will be used to save the data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At the bottom of the `__init__()` function, we've added a variable with an empty
    string that will be used to save data if the tool has not been opened before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `data()` function, which will be used to load the pickled objects,
    to the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The instruction of this function will use the function to load data from a file,
    or it will set an error to the status bar of the application. The loaded data
    will be appended to the `text edit` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following `save_data()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function will provide saving operations to files, databases, and so on.
    It will also check whether the used line edit fields are empty, as well as calling
    the `user_data1()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `user_data1()` function at the end of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This function will use the `pickle_dump()` function of the `UTools` class to
    save data to a file. Also available in the `pickle` module are the `dumps()` and
    `loads()` functions, which return a byte object instead of writing it to a file
    and read the objects, respectively. Classes such as `pickle.Pickler()` and `pickle.Unpickler()`
    can be used to pickle and unpickle data. The Python standard library's `pickletools`
    module extends the `pickle` module's functionality with additional functions that
    analyze pickled data. The `pickle` module is very useful for tasks such as data
    persistence in machine learning models and implementing them in an application.
  prefs: []
  type: TYPE_NORMAL
- en: The shelve module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `shelve` module creates dictionary-like objects using the `pickle` and `dbm` modules that
    can be saved in a file and opened accordingly. So, let''s add the `shelve_open()`
    function to the `UTools` class of the `u_tools.py` files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following module to the import section of the `u_tools.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `shelve_open()` function to the `UTools` class of the `u_tools.py`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function will write and read the data to and from a database. The parameters
    can be specified by using this function in the application. In the `UApp` class
    of the `u_app.py` file, we now need to add the `shelve` tool to open and save
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `shelve` module functionality to the `data()` function of the `UApp`
    class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `shelve_open()` function of the `UTools` class will be used to connect to
    the database. The `get()` method will get the data from the specified field of
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following option to the `save_data()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This instruction will call the `user_data2()` function with the data specified
    in its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `user_data2()` function to the end of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function will write the data to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object of the `shelve_open()` function provides methods that are similar
    to the following dictionary methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`db.keys()`: This returns all the keys of an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.values()`: This returns all the values of an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.items()`: This returns an iterable object with tuples, including key/value
    pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.get(key)`: This returns the value related to the key in a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.update({key: value})`: This adds elements to a database object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following flags are also available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`: Reading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`w`**: Reading and writing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`c`**: Reading and writing; if the file does not exist, it will be created
    (this is the default flag).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n`: Reading and writing; if the file does not exist, it will be created; if
    the file exists, it will be rewritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the `pickle` and `shelve` modules provide some convenient ways
    of organizing data. They are also useful in applications that work with machine
    learning algorithms. In reality, however, there may be tasks that require a broader
    approach and the need to use common tools and databases. In the following sections,
    we will try to describe these common tools.
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Comma Separated Values** (**CSV**) file is a type of text file that uses
    a comma to separate values and stores data in a table as a plain text file. This
    is a very popular kind of file and is often used as a source of data in machine
    learning applications, and data science generally. CSV files allow us to create
    and operate with large datasets, which can often contain billions of values. The
    tables of data used with popular office applications such as Microsoft Excel and
    LibreOffice Calc appear in similar spreadsheets, and these applications can open
    CSV files, but the Python standard library has a module that creates and operates
    with CSV files. We'll also look at some special tools, such as pandas.
  prefs: []
  type: TYPE_NORMAL
- en: The csv module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python standard library includes the `csv` module for manipulating CSV
    files. To show you how to use this module effectively, we''ll provide an example
    of writing and reading CSV files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following lines to the `import` section of the `u_tools.py`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `import` section, add the following path to this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this line, we can get the directory path to the application file to the
    working directory of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UTools` class of the `u_tools.py` file, add the following functions,
    which will write and read CSV files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding functions will write data to the CSV file. If the specified file
    does not exist, the header will be added to the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following function to read CSV files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function will read a CSV file with the Python standard library's `csv` module
    and will return the `DictReader` object with data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UApp` class of the `u_app.py` file, we now need to add the tool for
    opening and saving CSV files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the **`csv`** module functionality to the `data()` function of the
    `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function will read the rows of the `DataReader` object that will be returned
    when the `csv_read()` function of the `UTools` class is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following instruction to the `save_data()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This function will call the `user_data3()` function with the data specified
    in its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `user_data3()` function to the end of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The function will try to write the data to the CSV file. If the specified data
    exists in the file, this data will not be written. The preceding example shows
    us what is possible using Python's `csv` module for reading and writing CSV files,
    although some of these lines are optional and can be rewritten.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, some lines we need to pay attention to. Lines with statements
    that pass exceptions are not recommended, because when errors occur, they will
    not provide us with any information about the error or tell us what happened.
    This can be solved by changing these lines in relation to Python 2.x/3.x. (As
    mentioned earlier, PyQt5 uses Python 3.x and PySide2 uses Python 2.x.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the following lines for PyQt5 exception handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines are for PySide2 exception handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that more concrete exceptions, such as `FileNotFoundError` or `PermissionError`
    (3.x), can be used. The full list of built-in exceptions is available in the official
    Python documentation, and they are different for each Python version.
  prefs: []
  type: TYPE_NORMAL
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with CSV files in a professional sense, you should use the most
    popular toolset for working with data: **pandas**. This toolset allows us to handle
    large datasets, manipulate data, and analyze and represent data in almost any
    field of data science. This package, along with SciPy, NumPy, and Matplotlib,
    forms the basis of scientific Python. As mentioned in its official source, pandas
    is a library that provides high-performance, easy-to-use data structures and data
    analysis tools for the Python programming language. For more information on the
    wide functionality of the pandas library, visit [http://pandas.pydata.org/](http://pandas.pydata.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now take a look at this great tool in action by using it with CSV files.
    pandas can be installed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the latest versions of Anaconda include pandas as the default installed
    package, as well as NumPy, SciPy, Matplotlib, scikit-learn, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will go through a short example of how to write and read
    files with pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After it has been installed, you need to import the pandas library. To do this,
    add the following `import` statement to the `u_tools.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `pandas_write()` function to the `UTools` class of the `u_tools.py`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function can write data to various files, such as CSV, Excel,
    HTML, and JSON, depending on the specified filename and the extension (the type),
    and the type specified in the `writer` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following `pandas_read()` function, which will read the file depending
    on the specified parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This function can read data from various files, such as CSV, Excel, HTML, and
    JSON, depending on the specified filename and the extension (the type), and the
    type specified in the `reader` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UApp` class of the `u_app.py` file, add the pandas tool for opening
    and saving files. Add the pandas functionality to the `data()` function of the
    `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This instruction will call the function for reading CSV file with pandas. It
    will either append read data to the text field or display an error message in
    the status bar of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following instruction to the `save_data()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This instruction will call the `user_data4()` function with the data specified
    in the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `user_data4()` function to the end of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This function does not use the data retrieved in the parameters; instead, it
    uses the data generated with the `range()` function, which is used for each column
    in the table. We're now in a position to run the `u_app.py` file and take a look
    at the results. When the `Save` button is clicked, a file will be created with
    data. You can change the extension of the filename to `data/tests.xlsx` and change
    the writer to Excel as an experiment, if you wish. As you can see, this small
    amount of code provides a lot of functionality in comparison to our CSV example.
    Note that other functions, such as `to_html()`, are optional and simply demonstrate
    the functionality of the pandas library.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas is the recommended tool for data manipulation in applications because
    it has the widest toolset. On the other hand, the application can, unsurprisingly,
    often become slow. Importing pandas and writing the total number of values costs
    memory resources; in [Chapter 16](0e64461d-9420-4c73-9607-25e90f854793.xhtml),
    *Threading and Multiprocessing*, we will try to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at databases based on **Structured Query Language**
    (**SQL**). SQL is a domain-specific language that's used to manipulate databases
    by managing data in **Relational Database Management Systems** (**RDBMS**) and
    stream processing in **Relational** **Data Stream Management Systems** (**RDSMS**).
    We will not dive into SQL theory, as you can learn more about that by reading
    the relevant documentation. In this section, we will just cover the most valuable
    parts of GUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Databases, whether SQL or NoSQL-based, provide other approaches to storing data
    than previously discussed. In earlier examples, we have saved data to files and
    retrieved it by creating a data structure. However, using CSV files in this way
    is not always the most efficient approach. In some applications, we may require
    a database that is convenient and also provides management functionality. In other
    words, we need to create a SQL (or NoSQL) database for storing and managing data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get the most out of this book, readers must have some basic knowledge
    of SQL and its main statements, such as `CREATE`, `INSERT`, `SELECT`, `UPDATE`,
    and `DELETE`. In the next section, we will start by looking at the main third-party
    SQL databases before moving on to discover what the Qt library makes possible.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is an SQL database library that implements a small and fast SQL database
    engine using the C language. It is a straightforward database to use; its strengths
    are its simplicity and portability. This database can be easily implemented with
    applications for almost any device, and is the most widely used database in the
    world. Importantly, this database is also included in the Python standard library
    modules, and consequently can be used with PyQt and PySide bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to download it, install it, or go through a complicated process
    to start using this database; we just need to import it in a file, whenever we
    need it, with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following line in the `u_defaults.py` file''s `import` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `u_defaults.py` file and add the following lines to create a database. After
    the `import` section, add the following path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after the function that writes colors to the file, add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Creating the connection to a database and its cursor, writing and executing
    an SQL query, and then closing the cursor with the database is a standard way
    of working with the SQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we run the `u_app.py` file, the SQLite database with the table should
    exist and be ready to use. Note that the file of the database will be created
    in the `data/` folder of the application's directories.
  prefs: []
  type: TYPE_NORMAL
- en: We now want to provide some operations to this database, such as inserting or
    selecting values.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the `u_tools.py` files'' `import` section, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function, which will insert values into the database, to
    the `UTools` class of the `u_tools.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function realizes a connection to the SQLite database for inserting
    specified values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the function that will select values for the database, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will select values from the database depending on the
    specific SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UApp` class of the `u_app.py` file, add the SQLite functionality for
    inserting or selecting database values to the `data()` function of the `UApp`
    class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will use the `sqlite_select()` function of the `UTools`
    class to select values from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following code to the `save_data()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction will call the `user_data5()` function with the data
    specified in the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `user_data5()` function to the end of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will write the specified data to the SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to use the SQLite3 database in our application by inserting
    and selecting values. Note that some users may find SQLite less secure than other
    databases, but it also has a number of benefits. SQLite's flexibility, simplicity,
    and reliability, among other benefits means it is still recommended for use in
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PostgreSQL is a high-management relational database system and can be defined
    as an **Object-Relational Database Management System (ORDBMS)**. At the moment,
    it is the most commonly used database in cases related to big data and industrial
    tasks. As a database, PostgreSQL provides wide functionality. To implement this
    database in our application, we first need to download and install it to our remote
    or local device. PostgreSQL can be easily downloaded from the official source, [https://www.postgresql.org](https://www.postgresql.org),
    for any platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install this database, we need to follow the installation instructions and
    provide a password before it can connect. After everything is downloaded and installed,
    we need to configure PostgreSQL before we can begin using it. The following steps
    demonstrate how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, initialize the database cluster. To do this, open a command line or
    Terminal and change the current directory to the `data/` folder of the application
    directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, initialize the database cluster, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The database cluster will be initialized as a folder called `postgresdb`, or
    a place (a storage area on disk) where the database will be created. When initialization
    is complete, the following message should appear in the command-line or Terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start the server with a copy of the preceding line in the command line
    or Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We have now started the server and database cluster in the required directory.
    Note that we must start the server each time we want to use the database. After
    rebooting or reinstalling the operating system, this server can be stopped, so
    we need to enable the server to start automatically when the environment is started.
    You can find out how to do this by reading the official documentation or other
    third-party sources applicable to your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create the PostgreSQL database with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a table in the database. To do this, open the following `psql` shell
    in the command line or Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Input the following SQL query for table creation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: So, we have now created a PostgreSQL database with a table for our application.
    PostgreSQL has various functionalities that give users the ability to configure
    and manage databases, such as `dropdb`, `dropuser`, and `psql` (command-line interface).
    These can all be found in the `bin/` folder of the PostgreSQL installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to use this database in our application. The Python standard
    library doesn''t include PostgreSQL, so it needs to be downloaded and installed
    through a third-party package adapter, for example, `psycopg`. To do this, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use PostgreSQL with any Python-based application. To implement this
    functionality, add  the following lines to the `u_tools.py` files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `u_tools.py` file, add the following import statement to the `import`
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `UTools` class of the `u_tools.py` file, add a function that inserts
    values into the PostgreSQL database, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding example, SQL databases are very similar, and
    the function quickly realizes it's using a PostgreSQL database in the application.
    This function will insert values into the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function, which selects values from the PostgreSQL database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will select values from the PostgreSQL database dependent
    on the specified SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UApp` class of the `u_app.py` file, add the PostgreSQL tool for inserting
    and selecting database values. Add the PostgreSQL functionality to the `data()`
    function of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction uses the `psql_select()` function of the `UTools`
    class to select the data from the database and append it to the text edit field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `user_data6()` function to the `save_data()` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction will call the `user_data6()` function with the specified
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `user_data6()` function to the end of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction calls the `psql_insert()` function to insert user
    data into the database. The PostgreSQL database is now integrated and ready to
    use!
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MySQL database requires special attention. MySQL is an open source RDBMS that
    combines the simplicity and reliability of SQLite with slightly less functionality
    than PostgreSQL. In addition, MySQL is a component of the **Linux-Apache-MySQL-Python|PHP|Perl
    (LAMP)** web application software stack, which is very important for development.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating this database in our application is very easy. We can either download
    and install a binary package of MySQL or a zipped archive. Using a binary package,
    we can easily install the database by following the instructions provided by the
    graphical installer. With a zipped archive, we need to use the documentation available
    at [https://www.mysql.com](https://www.mysql.com) and initialize the non-install
    MySQL package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything is downloaded and installed, we can create a database with
    a table using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a client console, enter the password for the root user, and type
    a SQL query similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, pass the following command to check all available databases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91b44329-db4e-46fe-b75f-b36a5bc8cbc5.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot displays the databases available for us to use.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a table for the `mysqldb` database, but we need to select
    the database first. Note that choosing to use the database is required before
    you can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Input the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the query for adding a table to the database with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, display the tables in the database with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Check which user is connecting to the database with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Like PostgreSQL, the Python standard library does not include MySQL—it needs
    to be downloaded and installed via a third-party package adapter such as PyMySQL.
    To do so, enter the following command on the command line or Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start using the MySQL database with a Python-based application.
    We use the MySQL database in the `u_tools.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `u_tools.py` file, add the following `import` statement to the `import`
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, add the function that will insert values into the MySQL database
    table to the `UTools` class of the `u_tools.py` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will connect to the MySQL database and insert user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function, which will be used to select values from the MySQL
    database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will connect to and select user data from the MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UApp` class of the `u_app.py` file, add the MySQL tool for inserting
    and selecting database values. Add the MySQL functionality to the `data()` function
    of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction will use the `mysql_select()` function for reading
    user data from the database and append it to the text field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following code to the `save_data()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction will call the `user_data7()`function with the specified
    user data in its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `user_data7()` function to the end of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction will use the `mysql_insert()` function of the `UTools`
    class to insert values into the MySQL database. The MySQL database operations are
    now available!
  prefs: []
  type: TYPE_NORMAL
- en: Qt SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Qt library, the Qt SQL module provides SQL database integration with
    GUI applications. This module includes classes that realize the driver, API, and
    user interface layers for SQL databases. The driver-related classes that are currently
    available are `QSqlDriver`, `QSqlDriverCreatorBase`, and `QSqlResult`. For the
    API, there are classes such as `QSqlDatabase`, `QSqlQuery`, `QSqlField`, `QSqlIndex`,
    `QSqlRecord`, and `QSqlError`. Classes that implement the user interface layer
    include `QSqlQueryModel`, `QSqlTableModel`, and `QSqlRelationalTableModel`. To
    use this module in our application, we need to add the following lines to the
    `u_tools.py` files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `import` section of the PyQt5 `u_tools.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `import` section of the PySide2 `u_tools.py`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Let's now look at some of the classes included in the `QtSql` module for working
    with SQL databases in our application.
  prefs: []
  type: TYPE_NORMAL
- en: QSqlDatabase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class realizes the SQL API layer and creates connections to the databases
    in the application. The declaration syntax of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `QSqlDatabase` class improves functionality with the following functions.
  prefs: []
  type: TYPE_NORMAL
- en: add
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sql_db.addDatabase(str, str)` function adds the database to a list of connections,
    along with its driver type (the first parameter) and the connection name (the
    second parameter).
  prefs: []
  type: TYPE_NORMAL
- en: 'The driver types that can be specified for the database connection are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"QSQLITE"`: SQLite3 or above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"QSQLITE2"`: SQLite2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"QPSQL"`: PostgreSQL driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"QMYSQL"`: MySQL driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"QODBC"`: ODBC driver (includes Microsoft SQL Server).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"QOCI"`: Oracle Call Interface driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"QDB2"`: IBM DB2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"QIBASE"`: Borland InterBase driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"QTDS"`: Sybase Adaptive Server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following functions set the parameters and properties of the database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.setConnectOptions(str)`: This sets the database-specific options specified
    in a parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.setDatabaseName(str)`: This sets the name of the database, specified
    in the parameter, of the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.setHostName(str)`: This sets the hostname, as specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.setNumericalPrecisionPolicy(QtSql.QSql.NumericalPrecisionPolicy)`:
    This sets the numerical precision policy, as specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.setPassword(str)`: This sets the password, as specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.setPort(int)`: This sets the port, as specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.setUserName(str)`: This sets the username, as specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following functions return a Boolean value (`bool`) related to the database''s
    connection state:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.isDriverAvailable(str)`: This returns `True` if the driver specified
    in the parameter is available.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.isOpen()`: This returns `True` if this database connection is open;
    otherwise, it returns `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.isOpenError()`: This returns `True` if an error occurs when the database
    connection opens.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.isValid()`: This returns `True` if the `QtSql.QSqlDatabase` object
    has a valid driver.'
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following functions relate to the current values of the database connection,
    changes in functionality, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.cloneDatabase(QtSql.QSqlDatabase, str)`: This clones the database connection
    (the first parameter) and stores it as a connection name (the second parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.close()`: This closes this database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.commit()`: This commits a transaction to the database, such as `INSERT`
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.connectionName()`: This returns the connection name of the database
    connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.connectionNames()`: This returns a list of the connection names of
    the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.connectOptions()`: This returns the connection options that are used
    with the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.contains(str)`: This returns `True` if the list of connections contains
    the connection name specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.database(str, bool)`: This returns the database connection of the `QtSql.QSqlDatabase`
    type, with the connection name (the first parameter); if `open` (the second parameter)
    is `True`, the unopened database connection will open.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.databaseName()`: This returns the name of the database for the database
    connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.driver()`: This returns the database driver of the `QtSql.QSqlDriver`
    type used for the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.driverName()`: This returns the name of the driver that is used for
    the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.drivers()`: This returns the list of all available drivers.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.exec_(str)`: This executes a SQL statement and returns an object of
    the `QtSql.QSqlQuery` type.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.hostName()`: This returns the hostname of the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.lastError()`: This returns the last error that occurred within the
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.numericalPrecisionPolicy()`: This returns the default precision policy
    of the `QtSql.QSql.NumericalPrecisionPolicy` type for the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.open()`: This opens the database connection with the current connection
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.open(str, str)`: This opens the database connection with the specified username
    (the first parameter) and password (the second parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.password()`: This returns the password of the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.port()`: This returns the port of the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.primaryIndex(str)`: This returns the primary index for the table specified
    in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.record(str)`: This returns the record of the `QtSql.QSqlRecord` type,
    populated with the names of the fields in the table specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.registerSqlDriver(str, QtSql.QSqlDriverCreatorBase)`: This registers
    the SQL driver (the second parameter) with a name (the first parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.removeDatabase(str)`**:** This removes the database connection with
    the name specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.rollback()`: This rolls back database transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.tables(QtSql.QSql.TableType)`: This returns a list of the tables in
    the database used with the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.transaction()`: This begins a transaction with the database, such as
    inserting values.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db.userName()`: This returns the username of the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: QSqlQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `QSqlQuery` class executes SQL statements and database-specific commands
    related to operations with databases in the application.  The declaration syntax
    of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `QSqlQuery` class improves functionality with the following functions.
  prefs: []
  type: TYPE_NORMAL
- en: add
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This `add` function adds SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: The  `sql_query.addBindValue(object, PySide2.QtSql.QSql.ParamType)` function
    adds the binding value (the first parameter) to the list of values, using the
    type (the second parameter).
  prefs: []
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following functions set the parameters and properties of the SQL queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.setForwardOnly(bool)`: If this parameter is `True`, it sets forward-only
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.setNumericalPrecisionPolicy(QtSql.QSql.NumericalPrecisionPolicy)`:
    This sets the numerical precision policy, specified in the parameter, that will
    be used for querying.'
  prefs: []
  type: TYPE_NORMAL
- en: is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following functions return a Boolean value (`bool`) related to the SQL
    query''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.isActive()`: This returns `True` if the query is active.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.isForwardOnly()`: This returns `True` if the result set can only be
    scrolled in a forward direction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.isNull(int)`: This returns `True` if the query is not active nor
    positioned on a valid record, if there is no field specified in the parameter,
    or if this field is `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.isNull(str)`: This returns `True` if this query is not active, not
    positioned on a valid record, if there is no field with the name specified in
    the parameter, or if this field is `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.isSelect()`: This returns `True` if the current query uses the SQL
    `SELECT` statement to retrieve values from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.isValid()`: This returns `True` if this query is positioned on a
    valid record.'
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following functions relate to the current values of SQL queries, changes
    in functionality, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.at()`: This returns the current internal position for the query.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.bindValue(str, object, QtSql.QSql.ParamType)`: This sets the placeholder
    (the first parameter) that will be bound to the value (the second parameter) in
    the statement, using the type (the third parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.bindValue(int, object, QtSql.QSql.ParamType)`: This sets the placeholder
    in the position (the first parameter) that will be bound to the value (the second
    parameter) in the statement, using the type (the third parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.boundValue(str)`: This returns the bound value for the placeholder
    specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.boundValue(int)`: This returns the bound value for the placeholder
    at the position specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.boundValues()`: This returns a dictionary with bound values.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.clear()`: This clears the results of the query.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.driver()`: This returns the database driver of the `QtSql.QSqlDriver`
    type that was used with the query.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.exec_()`: This executes the prepared query statement and returns
    `True` if it was successful.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.exec_(str)`: This executes the query statement specified in the
    parameter and returns `True` if it was successful.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.execBatch(QtSql.QSqlQuery.BatchExecutionMode)`: This executes the
    query statement in a batch, with the execution mode specified in the parameter. The
    available modes include **`QtSql.QSqlQuery.ValuesAsRows`**—`0`, which updates
    multiple rows, and `QtSql.QSqlQuery.ValuesAsColumns`—`1`, which updates a single
    row.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.executedQuery()`: This returns the last successfully executed query.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.finish()`: This function instructs that no more data will be fetched
    from a query until the query is  re-executed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.first()`: This retrieves the first record in a  result, and positions
    the query on the retrieved record.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.last()`: This retrieves the last record in a result, and positions
    the query on the retrieved record.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.lastError()`: This returns the last error of the `QtSql.QSqlError`
    type that occurred with the query.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.lastInsertId()`: This returns the ID of the object for the last
    inserted row.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.lastQuery()`: This returns the text of the last query.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.next()`: This retrieves the next record in the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.nextResult()`: This discards the result set of a query, and if it''s
    available, it navigates to the next result.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.numericalPrecisionPolicy()`: This returns the precision policy of
    the `QtSql.QSql.NumericalPrecisionPolicy` type that is currently used.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.numRowsAffected()`: This returns the number of rows in relation
    to the result of the SQL statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.prepare(str)`: This prepares the SQL query statement specified in
    the parameter for execution.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.previous()`: This retrieves the previous record in the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.record()`: This returns the record of the `QtSql.QSqlRecord` type
    that contains the field information for this query.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.result()`: This returns the result of the `QtSql.QSqlResult` type
    related to the query.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.seek(int, bool)`: This retrieves the record at a specific index
    (the first parameter) in accordance with the second parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.size()`: This returns the number of rows in the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.value(int)`: This returns the value of the field at the index specified
    in the parameter of the current record.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_query.value(str)`: This returns the value of field with the name specified
    in the parameter of the current record.'
  prefs: []
  type: TYPE_NORMAL
- en: Qt SQL example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now take a look at an example of the `QtSql` module in action in our
    application. First, we need to open the `u_tools.py` files and add the following
    lines to them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `QSqlDatabase`, which will open an existing database or create a new database
    if one doesn''t exist, to the `__init__()` function of the `UTools` class, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The name of the database driver is defined in the `addDatabase()` method. Another
    driver can be used if available. This method sets the name and opens the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the function that will insert values into the opened SQLite database,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function uses the **`QSqlQuery`** class to create the SQL query
    and bind user data by inserting values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function, which will select values from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will select the user data dependent on the query and
    return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UApp` class of the `u_app.py` files, add the `QtSQL` tool for inserting
    and selecting database values. Add the `QtSql` module functionality to the `data()`
    function of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction uses the `sql_qt_select()` function to select user
    data from the database and append the returned result to the text field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following to the `save_data()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction calls the `user_data8()`function with the specified
    user data parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `user_data8()` function to the end of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will call the `sql_qt_insert()` function of the `UTools`
    class to insert user data into the SQLite database. This example demonstrates
    the use of the `QtSql` module in practice. As you can see, it differs from standard
    third-party instruments, and this construction may be hard to understand. At the
    time of writing, by default, this module only has a `"QSQLITE"` driver, so others
    will need to be loaded and configured additionally. Whether you use this module
    instead of third-party database instruments is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NoSQL databases are other modern mechanisms for storing data. NoSQL is referred
    to as not-SQL, or not-relational, as data is modeled in a different way to the
    tabular relations in relational SQL databases. NoSQL databases are usually used
    in big data and real-time web applications. Another popular definition of NoSQL
    is *Not only SQL.* This means NoSQL databases can support SQL or sit alongside
    SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing NoSQL databases in our application may simplify document storage
    and make data handling easier, so let's a look at some short examples of how to
    use the most popular NoSQL databases in the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is an open source database for NoSQL document storage. This database
    records documents as a data structure with field/value pairs. These documents
    are similar to the JSON objects we created in the *pandas* section. MongoDB values
    include documents, arrays, and arrays of documents. To use MongoDB, you need to
    download and install it from the official source, [https://mongodb.com](https://mongodb.com),
    using the documentation provided. It is also recommended that you download and
    install the additional development tools available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to previous sections, create the `MongoDB_1/`  folder in both the `App/App_PySide2/data/`
    and `App/App_PyQt5/data/` directories, where the database will be located:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run a command similar to the following in your command line or Terminal,
    depending on your operating system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the executable files, such as `mongod` (for Linux) or `mongod.exe` (for
    Windows), and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect to MongoDB, use commands such as `mongo` or `mongo.exe` in the new
    command line or Terminal, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'An adapter is required for using MongoDB with Python; in this case, `pymongo`.
    Install the adapter with `pip`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use the MongoDB functionality with our application!
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to add some lines to the `u_tools.py` files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `u_tools.py` files and add the following line to the `import` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function to the `UTools` class of the `u_tools.py` files.
    This will insert values into the MongoDB database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function creates a connection to the MongoDB database with the
    host and port specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the function that will be used to select values from MongoDB, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The name of the database in this example is specified as `'umongodb'`. This
    function returns all user data from within the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UApp` class of the `u_app.py` files, add the MongoDB tool for inserting
    and selecting database values. Add the MongoDB functionality to the `data()` function
    of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction uses the `mongo_select()` function to read data from
    the database and append it to the text field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following to the `save_data()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The `elif` instruction will use the `user_data9()` function with the specified
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `user_data9()` function to the end of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will be used to insert data into the database. It is
    a simple, short, and basic example of the implementation of Mongo in our application.
    To learn about all the capabilities and advantages of MongoDB in more detail,
    it's recommended that you read Mongo's official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: CouchDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular type of NoSQL data storage is Apache CouchDB. This database
    uses mechanisms that are similar to the ones described in the previous section,
    but improves them with additional features. CouchDB is a modern tool for the web
    implementation of stored documents. If you're using the HTTP and JSON data formats,
    this database is the preferred choice.
  prefs: []
  type: TYPE_NORMAL
- en: To use this database in your application, you need to download and install it
    by following the instructions at [http://couchdb.apache.org/](http://couchdb.apache.org/) for
    the appropriate operating system. When everything that is required is installed
    and configured, it's time to start CouchDB. To configure and start this database,
    it is recommended that you use additional documentation from your operating system,
    because the steps required may be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'With CouchDB open, it''s time to enter `http://127.0.0.1:5984/_utils/` in the
    search line of the web browser. A page explaining Couch database management, with
    additional instructions, should appear. It''s now time to create a database called
    `u_couchdb` using the functionality of this web page. Once the database is created,
    you can create a document. To do this, click on the Create Document button on
    the web page and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `_id` will be different. When the document is created, the first
    record of the database should appear on the web page. To implement these operations
    with Python, additional instruments to connect to Couch Database are needed, for
    example, the `CouchDB` package. Install this using the following command with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open the `u_tools.py` files and add some lines to realize the functionality
    in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `import` section of the `u_tools.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following function to the `UTools` class of the `u_tools.py`
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will connect to the database with the specified URL (host
    and port) and insert values into CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the function that will be used to select values from the database,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will connect to the database, select the available values,
    and return data. In the `UApp` class of the `u_app.py` files, add the CouchDB
    tool for inserting and selecting database values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the CouchDB functionality to the `data()` function of the `UApp` class,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction uses the `couch_select()` function of the `UTools`
    class to select the user data from CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to the `save_data()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction uses the `user_data10()` function with the specified
    user data parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `user_data10()` function to the end of the `UApp` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will call the `couch_insert()` function of the `UTools`
    class to insert the specified user data into the database. When the `u_app.py`
    files are run, you can communicate with CouchDB to insert values and select them
    in the documents, which will be represented on the web page of the Fauxton utility
    provided by the CouchDB functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the most important part of constructing an application—data
    manipulation. In this chapter, we also explained the first steps of handling data
    in an application. As we have outlined in this chapter, the construction of implementations
    are somewhat similar, and their use is optional, so we will now move forward and
    concentrate on extending the GUI application's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explain the communication mechanism between an application
    and its user. In the Qt library, this is done with signals, slots, and events.
  prefs: []
  type: TYPE_NORMAL
