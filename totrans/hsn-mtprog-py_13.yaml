- en: '*Chapter 10*: Understanding Method Resolution Order of Inheritance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the concept of **method resolution order**
    (**MRO**) in Python 3 and how it works on inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, MRO is the order in which methods of a class get resolved
    while calling them in a program.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will look at understanding the MRO through a few
    examples, how method resolution can go wrong, and how the current Python 3 implementation
    handles methods defined in a class. We will be making use of MRO throughout this
    chapter to understand the behavior of code while inheritance is implemented in
    Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Why should we understand MRO? In scenarios where we are using multiple classes
    in Python code, we need to inherit methods from multiple parent classes or superclasses.
    Understanding the order in which the methods would get resolved from the existing
    class to its parent class helps in avoiding incorrect method calls. This in turn
    helps in avoiding incorrect results in the algorithm of Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be taking a look at the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the MRO of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the impact of modifying the order of inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Impact of unintended change of order in inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to get an understanding of how
    methods are resolved in Python class hierarchy, understand how methods are processed
    in multiple inheritances, and write the methods on your own with the knowledge
    of how they would get resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter10](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the MRO of a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let’s explore how methods are resolved in a class that has
    no inheritance specified within its code. A class by default in Python 3 is inherited
    by `object`. To understand how MRO works on a class that has no parent class,
    looking at it in its simplest form is the easiest approach. We will then see how
    MRO works on a class with single, multiple, and multilevel inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let’s create a class for a branch of *ABC Megamart* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Branch` class, let’s create attributes for branch ID, street, city,
    state and ZIP code, product, sales, and invoice. Let’s also create methods such
    as `get_product` (which returns the product), `get_sales` (which returns sales),
    and `get_invoice` (which returns the invoice). The following code represents the
    `Branch` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are five attributes and three methods in the preceding class. The MRO
    for the preceding class can be reviewed by calling a built-in method on the class,
    known as `mro`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s call the `mro` method of the `Branch` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `mro` of the `Branch` class is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we can see that the `Branch` class did not have any
    explicit definition of a superclass or parent class, and so it is, by default,
    inherited from the object.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we understood the concept of MRO along with an example of how
    to look at the MRO of a class. Now, let’s look further to see how MRO works on
    a class that has a single parent class or superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MRO in single inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a class inherits one parent class or superclass, it is single inheritance.
    Let’s look at how methods are resolved in the case of the `Branch` class example
    when it becomes a parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding with the creation of the child class, let’s redefine the
    `Branch` class with suitable methods that can be used for testing this concept:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this example, let’s create another class, named `NYC`, which inherits from
    the `Branch` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we have the `NYC` class inherited from the `Branch` class,
    and the `NYC` class has two methods defined. The `set_management` method returns
    the value stored in `intercitybranch`, and the `calc_tax_nyc` method calculates
    tax for `NYC`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MRO of the `NYC` class is represented in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The methods present in `NYC` will be resolved first, followed by the methods
    of `Branch` and then the methods of `object`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at what happens when a method required by `NYC` is not present in
    `NYC` but instead defined in its parent class. In the `NYC` class, `calc_tax_nyc`
    is the method that calculates tax for the `NYC` branch, and this method needs
    values for attributes such as `branch`, `intercitybranch`, `product`, and `sales`.
    The value for the `intercitybranch` attribute alone can be set within the `NYC`
    class using the `set_management` method, whereas the remaining attributes, such
    as `branch`, `product`, and `sales`, do not have a set method in `NYC`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start by creating a variable named `intercitybranch` and defining an
    instance for `NYC`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s set the value for `intercitybranch` first, and then look at how to deal
    with the set methods for the remaining attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The set methods required to set `branch`, `product`, and `sales` are available
    in the parent class of `Branch`. Since the MRO of the `NYC` class is to resolve
    from `NYC` followed by `Branch` followed by `object`, the set methods of `Branch`
    can now be called by `NYC` to set the values for `branch`, `product`, and `sales`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the required values are set, we are good to call the `calc_tax_nyc`
    method from the `NYC` class that inherited the `Branch` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The selling price calculated using the tax rate and the other supporting values
    of `branch`, `product`, and `sales` set using the parent class is represented
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we looked at how MRO works in classes that have a single inheritance.
    Now, let’s look at what happens when a class inherits from two classes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MRO in multiple inheritances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will look at inheriting from more than one superclass or
    parent class and its corresponding MRO.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, let’s create two parent classes, `Product` and `Branch`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Product` class will have a set of attributes followed by a method named
    `get_product`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Branch` class will have a set of attributes followed by a method named
    `get_branch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s next create a child class or subclass named `Sales` and inherit from
    the `Product` and `Branch` classes. `Sales` will have one attribute date and a
    `get_sales` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Sales` class inherits `Product` followed by `Branch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at the order of its method resolution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding output, the methods are resolved in the order of `Sales` followed
    by `Product` followed by `Branch` followed by `object`. If a method called by
    an object of the `Sales` class is not present in `Sales`, the MRO algorithm searches
    for it within the `Product` class followed by the `Branch` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create another class (named `Invoice`) and inherit both `Branch` and
    `Product` in an order that''s different from the inheritance of the `Sales` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine `mro` for the `Invoice` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `mro` for the `Invoice` class is represented in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding output, the methods are resolved in the order of `Invoice`
    followed by `Branch` followed by `Product` followed by `object`. If a method called
    by an object of the `Invoice` class is not present in `Invoice`, the MRO algorithm
    searches for it within the `Branch` class followed by the `Product` class.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of multiple inheritances, we reviewed how the order of method resolution
    changes when the order of inheriting superclasses or parent classes changes in
    Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at what happens to MRO in the case of multilevel inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing MRO in multilevel inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes in Python can also inherit from superclasses at multiple levels, and
    the MRO gets more complicated as the number of superclasses or parent classes
    increases. In this section, let’s look at the order of method resolution for such
    multiple inheritances with a few more examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first create a class named `StoreCoupon`, where we will be defining attributes
    for a store such as product name, product category, the brand of the product,
    store name where the product is sold, expiry date of the product, and quantity
    to be purchased to get a coupon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will then define a method named `generate_coupon`, where we will be generating
    two coupons for the product with random coupon ID values and all the details of
    the product and its store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now define a class, `SendStoreCoupon`, that inherits `StoreCoupon` and
    does not add any methods or attributes to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The MRO of this class is represented in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The methods in `SendStoreCoupon` are resolved first, followed by the methods
    in the `StoreCoupon` class, followed by `object`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s add one more level of inheritance by defining another class, named `SendCoupon`,
    and inheriting it from the `SendStoreCoupon` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The MRO of this class is represented in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding output, the methods are resolved from `SendCoupon` followed
    by `SendStoreCoupon` followed by `StoreCoupon` followed by `object`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s create an object for the `SendCoupon` class and call the `generate_coupon`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `SendCoupon` class does not have a definition for the `generate_coupon`
    method and so, as per the MRO, the parent class or superclass’ `SendStoreCoupon`
    method will be called, as in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we looked at how the methods are resolved from one level of
    inheritance to the other.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look further into the impact of modifying the order of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of modifying the order of inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at inheriting from more than one parent class.
    We will see what happens to the method resolution when the order of the parent
    class changes in addition to the `SendStoreCoupon` class that was created in the
    preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will be creating another class, named `ManufacturerCoupon`, where
    we will be defining attributes for a manufacturer such as the product name, product
    category, brand of the product, manufacturer name where the product is sold, expiry
    date of the product, and quantity to be purchased to get a coupon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will then define a method named `generate_coupon`, where we will be generating
    two coupons for the product with random coupon ID values and all the details of
    the product and its manufacturer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also define the `SendCoupon` class with two parent classes—`ManufacturerCoupon`
    and `SendStoreCoupon`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The MRO of the class is represented in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further create an object for the class and call the `generate_coupon`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `generate_coupon` method generated coupons for the manufacturer in this
    example since the first parent that has the `generate_coupon` method definition
    is `ManufacturerCoupon`. The following coupons are generated from the `generate_coupon`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further change the order of inheritance in the `SendCoupon` class and
    look at how the methods are resolved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The MRO of the class is represented in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further create an object for the class and call the `generate_coupon`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `generate_coupon` method generated coupons for the store in this example
    since the first parent that has the `generate_coupon` method definition is `SendStoreCoupon`,
    which in turn inherits the method from its `StoreCoupon` parent class, as represented
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we understood the impact of the order in which a child class
    resolved the parent classes or the superclasses.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s look at what happens when the inheritance becomes
    even more complex and where it can lead to errors.
  prefs: []
  type: TYPE_NORMAL
- en: Impact of unintended change of order in inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be looking at examples that demonstrate how important
    the order of inheritance is to resolve the methods in the case of multilevel inheritance,
    and what happens when the order changes in one of the parent or superclasses unintentionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a class named `CommonCounter` that initializes with
    two attributes, `items` and `name`. Let’s also add two methods to this class,
    `return_cart` (which returns the items in the cart) and `goto_counter` (which
    returns the name of the counter). This is how the code looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The MRO of the class is represented in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now create another class, named `CheckItems`, which is also going to
    be a parent class in multilevel inheritance applied in this section. This class
    will have one attribute named `item_type` and one method named `review_items`
    that returns the name of the counter based on the type of items in the cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The MRO of the class is represented in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the second level of inheritance, let’s create a class named `ElectronicsCounter`,
    which inherits from the `CommonCounter` and `CheckItems` classes, in that order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The MRO of the class is represented in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the second level of inheritance, let’s also create a class named `VegeCounter`,
    which inherits from the `CheckItems` and `CommonCounter` classes, in that order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The MRO of the class is represented in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now create another class, named `ScanCode`, which inherits the `ElectronicsCounter`
    and `VegCounter` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code results in the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – MRO error ](img/Figure_10.1_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – MRO error
  prefs: []
  type: TYPE_NORMAL
- en: Even though the MRO of the class is `ScanCode` followed by `ElectronicsCounter`
    followed by `VegeCounter` followed by `CommonCounter` followed by `CheckItems`
    followed by `object`, the MROs of the `CommonCounter` and `CheckItems` base classes
    are reversed. Therefore, the overall class definition throws an error in this
    scenario.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example demonstrates the impact of unintended change in the order of inheritance.
    It is important to ensure that the order of classes is correct while defining
    classes with multilevel inheritance in Python so that the MRO is consistent for
    base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the concept of method resolution by exploring
    the MRO method in Python 3\. We also inspected the MRO of Python code by implementing
    different types of inheritance. We understood the impact of MRO by modifying the
    order of inheritance at various levels for multiple classes from our core example.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other chapters covered in this book, this chapter explains that the
    MRO also focuses on metaprogramming and its impact on Python code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at the concept of dynamic objects, with
    some other interesting examples.
  prefs: []
  type: TYPE_NORMAL
