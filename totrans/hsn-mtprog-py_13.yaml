- en: '*Chapter 10*: Understanding Method Resolution Order of Inheritance'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：理解继承的方法解析顺序'
- en: In this chapter, we will look at the concept of **method resolution order**
    (**MRO**) in Python 3 and how it works on inheritance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Python 3中**方法解析顺序**（**MRO**）的概念以及它在继承中的工作方式。
- en: As the name suggests, MRO is the order in which methods of a class get resolved
    while calling them in a program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，MRO是类在程序中调用方法时解析方法的顺序。
- en: Throughout this chapter, we will look at understanding the MRO through a few
    examples, how method resolution can go wrong, and how the current Python 3 implementation
    handles methods defined in a class. We will be making use of MRO throughout this
    chapter to understand the behavior of code while inheritance is implemented in
    Python 3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过几个示例来了解MRO，了解方法解析可能出错的情况，以及当前Python 3实现如何处理在类中定义的方法。我们将在本章中使用MRO来理解在Python
    3中实现继承时的代码行为。
- en: Why should we understand MRO? In scenarios where we are using multiple classes
    in Python code, we need to inherit methods from multiple parent classes or superclasses.
    Understanding the order in which the methods would get resolved from the existing
    class to its parent class helps in avoiding incorrect method calls. This in turn
    helps in avoiding incorrect results in the algorithm of Python code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该理解MRO？在Python代码中使用多个类的情况下，我们需要从多个父类或超类继承方法。了解方法从现有类到其父类解析的顺序有助于避免错误的调用方法。这反过来又有助于避免Python代码算法中的错误结果。
- en: 'In this chapter, we will be taking a look at the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨以下主要主题：
- en: Understanding the MRO of a class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类的MRO
- en: Understanding the impact of modifying the order of inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解修改继承顺序的影响
- en: Impact of unintended change of order in inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不当改变继承顺序的影响
- en: By the end of this chapter, you should be able to get an understanding of how
    methods are resolved in Python class hierarchy, understand how methods are processed
    in multiple inheritances, and write the methods on your own with the knowledge
    of how they would get resolved.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够理解Python类层次结构中方法的解析方式，了解在多继承中方法是如何处理的，并根据自己的知识编写方法。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter10](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter10).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中分享的代码示例可在GitHub上找到，位于本章代码的以下位置：[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter10](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter10).
- en: Understanding the MRO of a class
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类的MRO
- en: In this section, let’s explore how methods are resolved in a class that has
    no inheritance specified within its code. A class by default in Python 3 is inherited
    by `object`. To understand how MRO works on a class that has no parent class,
    looking at it in its simplest form is the easiest approach. We will then see how
    MRO works on a class with single, multiple, and multilevel inheritance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们探索在代码中没有指定继承的类中方法是如何解析的。在Python 3中，类默认继承自`object`。为了理解MRO在没有父类的类上的工作方式，以最简单的方式查看它是最容易的方法。然后我们将看到MRO在单继承、多继承和多级继承中的工作方式。
- en: 'In this example, let’s create a class for a branch of *ABC Megamart* as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们创建一个代表*ABC Megamart*分支的类，如下所示：
- en: 'In the `Branch` class, let’s create attributes for branch ID, street, city,
    state and ZIP code, product, sales, and invoice. Let’s also create methods such
    as `get_product` (which returns the product), `get_sales` (which returns sales),
    and `get_invoice` (which returns the invoice). The following code represents the
    `Branch` class:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Branch`类中，让我们为分支ID、街道、城市、州和邮政编码、产品、销售额和发票创建属性。让我们还创建一些方法，如`get_product`（返回产品）、`get_sales`（返回销售额）和`get_invoice`（返回发票）。以下代码表示`Branch`类：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are five attributes and three methods in the preceding class. The MRO
    for the preceding class can be reviewed by calling a built-in method on the class,
    known as `mro`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中，有五个属性和三个方法。可以通过在类上调用一个内置方法来查看前面类的MRO，该方法称为`mro`。
- en: 'Next, let’s call the `mro` method of the `Branch` class:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们调用`Branch`类的`mro`方法：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `mro` of the `Branch` class is represented as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Branch`类的`mro`表示如下：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding output, we can see that the `Branch` class did not have any
    explicit definition of a superclass or parent class, and so it is, by default,
    inherited from the object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到`Branch`类没有对超类或父类进行任何显式定义，因此它默认继承自`object`。
- en: In this section, we understood the concept of MRO along with an example of how
    to look at the MRO of a class. Now, let’s look further to see how MRO works on
    a class that has a single parent class or superclass.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了MRO的概念，并通过一个例子展示了如何查看类的MRO。现在，让我们进一步看看MRO在只有一个父类或超类的类上是如何工作的。
- en: Understanding MRO in single inheritance
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解单一继承中的MRO
- en: 'When a class inherits one parent class or superclass, it is single inheritance.
    Let’s look at how methods are resolved in the case of the `Branch` class example
    when it becomes a parent class:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类继承一个父类或超类时，这是单一继承。让我们看看在`Branch`类成为父类时，方法是如何解决的。
- en: 'Before proceeding with the creation of the child class, let’s redefine the
    `Branch` class with suitable methods that can be used for testing this concept:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建子类之前，让我们重新定义`Branch`类，并添加适合测试这个概念的方法：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For this example, let’s create another class, named `NYC`, which inherits from
    the `Branch` class:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们创建另一个类，命名为`NYC`，它继承自`Branch`类：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we have the `NYC` class inherited from the `Branch` class,
    and the `NYC` class has two methods defined. The `set_management` method returns
    the value stored in `intercitybranch`, and the `calc_tax_nyc` method calculates
    tax for `NYC`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有从`Branch`类继承的`NYC`类，`NYC`类定义了两个方法。`set_management`方法返回存储在`intercitybranch`中的值，而`calc_tax_nyc`方法计算`NYC`的税费。
- en: 'The MRO of the `NYC` class is represented in the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`NYC`类的MRO在以下输出中表示：'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The methods present in `NYC` will be resolved first, followed by the methods
    of `Branch` and then the methods of `object`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`NYC`类中存在的方法将首先被解决，然后是`Branch`类的方法，最后是`object`类的方法。'
- en: Let’s look at what happens when a method required by `NYC` is not present in
    `NYC` but instead defined in its parent class. In the `NYC` class, `calc_tax_nyc`
    is the method that calculates tax for the `NYC` branch, and this method needs
    values for attributes such as `branch`, `intercitybranch`, `product`, and `sales`.
    The value for the `intercitybranch` attribute alone can be set within the `NYC`
    class using the `set_management` method, whereas the remaining attributes, such
    as `branch`, `product`, and `sales`, do not have a set method in `NYC`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看当`NYC`需要的方法不在`NYC`中定义，而是在其父类中定义时会发生什么。在`NYC`类中，`calc_tax_nyc`是计算`NYC`分支税费的函数，这个函数需要`branch`、`intercitybranch`、`product`和`sales`等属性的值。`intercitybranch`属性的值可以在`NYC`类中使用`set_management`方法单独设置，而其他属性，如`branch`、`product`和`sales`，在`NYC`中没有设置方法。
- en: 'Let’s start by creating a variable named `intercitybranch` and defining an
    instance for `NYC`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`intercitybranch`的变量并定义`NYC`的实例开始：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s set the value for `intercitybranch` first, and then look at how to deal
    with the set methods for the remaining attributes:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先设置`intercitybranch`的值，然后看看如何处理剩余属性的设置方法：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The set methods required to set `branch`, `product`, and `sales` are available
    in the parent class of `Branch`. Since the MRO of the `NYC` class is to resolve
    from `NYC` followed by `Branch` followed by `object`, the set methods of `Branch`
    can now be called by `NYC` to set the values for `branch`, `product`, and `sales`
    as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`branch`、`product`和`sales`所需的设置方法在`Branch`类的父类中可用。由于`NYC`类的MRO是先从`NYC`开始，然后是`Branch`，最后是`object`，因此`NYC`现在可以调用`Branch`的设置方法来设置`branch`、`product`和`sales`的值，如下所示：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that the required values are set, we are good to call the `calc_tax_nyc`
    method from the `NYC` class that inherited the `Branch` class:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所需的值都已设置，我们可以从继承自`Branch`类的`NYC`类中调用`calc_tax_nyc`方法：
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The selling price calculated using the tax rate and the other supporting values
    of `branch`, `product`, and `sales` set using the parent class is represented
    in the following output:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用税率和其他支持值（`branch`、`product`和`sales`）计算出的销售价格，这些值是通过父类设置的，在以下输出中表示：
- en: '[PRE10]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this section, we looked at how MRO works in classes that have a single inheritance.
    Now, let’s look at what happens when a class inherits from two classes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了具有单一继承的类中MRO的工作方式。现在，让我们看看当一个类从两个类继承时会发生什么。
- en: Understanding MRO in multiple inheritances
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解多重继承中的MRO
- en: In this section, we will look at inheriting from more than one superclass or
    parent class and its corresponding MRO.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨从多个超类或父类继承及其相应的MRO。
- en: 'For this example, let’s create two parent classes, `Product` and `Branch`,
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们创建两个父类，`Product`和`Branch`，如下所示：
- en: 'The `Product` class will have a set of attributes followed by a method named
    `get_product`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Product`类将有一组属性，后面跟着一个名为`get_product`的方法：'
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Branch` class will have a set of attributes followed by a method named
    `get_branch`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Branch`类将有一组属性，后面跟着一个名为`get_branch`的方法：'
- en: '[PRE12]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s next create a child class or subclass named `Sales` and inherit from
    the `Product` and `Branch` classes. `Sales` will have one attribute date and a
    `get_sales` method:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为`Sales`的子类或子类，并从`Product`和`Branch`类继承。`Sales`将有一个属性`date`和一个`get_sales`方法：
- en: '[PRE13]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Sales` class inherits `Product` followed by `Branch`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Sales`类继承自`Product`，然后是`Branch`：'
- en: '[PRE14]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s look at the order of its method resolution:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看其方法解析的顺序：
- en: '[PRE15]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding output, the methods are resolved in the order of `Sales` followed
    by `Product` followed by `Branch` followed by `object`. If a method called by
    an object of the `Sales` class is not present in `Sales`, the MRO algorithm searches
    for it within the `Product` class followed by the `Branch` class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，方法的解析顺序是按照`Sales`、`Product`、`Branch`、`object`的顺序进行的。如果一个由`Sales`类的对象调用的方法不在`Sales`中，MRO算法将在`Product`类中搜索它，然后是`Branch`类。
- en: 'Let’s create another class (named `Invoice`) and inherit both `Branch` and
    `Product` in an order that''s different from the inheritance of the `Sales` class:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个类（命名为`Invoice`），并以与`Sales`类继承不同的顺序继承`Branch`和`Product`：
- en: '[PRE16]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s examine `mro` for the `Invoice` class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查`Invoice`类的`mro`：
- en: '[PRE17]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `mro` for the `Invoice` class is represented in the following output:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoice`类的`mro`（方法解析顺序）在以下输出中表示：'
- en: '[PRE18]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding output, the methods are resolved in the order of `Invoice`
    followed by `Branch` followed by `Product` followed by `object`. If a method called
    by an object of the `Invoice` class is not present in `Invoice`, the MRO algorithm
    searches for it within the `Branch` class followed by the `Product` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，方法的解析顺序是按照`Invoice`、`Branch`、`Product`、`object`的顺序进行的。如果一个由`Invoice`类的对象调用的方法不在`Invoice`中，MRO算法将在`Branch`类中搜索它，然后是`Product`类。
- en: In the case of multiple inheritances, we reviewed how the order of method resolution
    changes when the order of inheriting superclasses or parent classes changes in
    Python 3.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重继承的情况下，我们回顾了在Python 3中，当继承超类或父类的顺序改变时，方法解析顺序如何变化。
- en: Now, let’s look at what happens to MRO in the case of multilevel inheritance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在多层继承的情况下MRO（Method Resolution Order，方法解析顺序）会发生什么。
- en: Reviewing MRO in multilevel inheritance
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习多层继承中的MRO
- en: Classes in Python can also inherit from superclasses at multiple levels, and
    the MRO gets more complicated as the number of superclasses or parent classes
    increases. In this section, let’s look at the order of method resolution for such
    multiple inheritances with a few more examples.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的类也可以在多个级别上从超类继承，随着超类或父类数量的增加，MRO变得更加复杂。在本节中，我们将通过一些额外的示例来查看这种多重继承的方法解析顺序。
- en: 'In this example, we will perform the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将执行以下步骤：
- en: Let’s first create a class named `StoreCoupon`, where we will be defining attributes
    for a store such as product name, product category, the brand of the product,
    store name where the product is sold, expiry date of the product, and quantity
    to be purchased to get a coupon.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为`StoreCoupon`的类，我们将在这个类中定义商店的属性，例如产品名称、产品类别、产品的品牌、销售产品的商店名称、产品的过期日期以及购买以获得优惠券的数量：
- en: 'We will then define a method named `generate_coupon`, where we will be generating
    two coupons for the product with random coupon ID values and all the details of
    the product and its store:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义一个名为`generate_coupon`的方法，我们将在这个方法中为产品生成两个具有随机优惠券ID值和产品及其商店的所有详细信息的优惠券：
- en: '[PRE19]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s now define a class, `SendStoreCoupon`, that inherits `StoreCoupon` and
    does not add any methods or attributes to it:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个类`SendStoreCoupon`，它继承自`StoreCoupon`，并且不对它添加任何方法或属性：
- en: '[PRE20]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The MRO of this class is represented in the following output:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类的MRO在以下输出中表示：
- en: '[PRE21]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The methods in `SendStoreCoupon` are resolved first, followed by the methods
    in the `StoreCoupon` class, followed by `object`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SendStoreCoupon`中的方法首先解析，然后是`StoreCoupon`类中的方法，最后是`object`。'
- en: 'Let’s add one more level of inheritance by defining another class, named `SendCoupon`,
    and inheriting it from the `SendStoreCoupon` classes:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过定义另一个名为`SendCoupon`的类并从`SendStoreCoupon`类继承它来添加一个继承级别：
- en: '[PRE22]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The MRO of this class is represented in the following output:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类的MRO（Method Resolution Order，方法解析顺序）在以下输出中展示：
- en: '[PRE23]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding output, the methods are resolved from `SendCoupon` followed
    by `SendStoreCoupon` followed by `StoreCoupon` followed by `object`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的输出中，方法是从`SendCoupon`解析到`SendStoreCoupon`，然后是`StoreCoupon`，最后是`object`。
- en: 'Let’s create an object for the `SendCoupon` class and call the `generate_coupon`
    method:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`SendCoupon`类创建一个对象并调用`generate_coupon`方法：
- en: '[PRE24]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `SendCoupon` class does not have a definition for the `generate_coupon`
    method and so, as per the MRO, the parent class or superclass’ `SendStoreCoupon`
    method will be called, as in the following output:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SendCoupon`类没有为`generate_coupon`方法定义，因此，根据MRO，将调用父类或超类的`SendStoreCoupon`方法，如下所示输出：'
- en: '[PRE25]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we looked at how the methods are resolved from one level of
    inheritance to the other.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们探讨了方法是如何从继承的一个级别解析到另一个级别的。
- en: Now, let’s look further into the impact of modifying the order of inheritance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步探讨修改继承顺序的影响。
- en: Understanding the importance of modifying the order of inheritance
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解修改继承顺序的重要性
- en: 'In this section, we will look at inheriting from more than one parent class.
    We will see what happens to the method resolution when the order of the parent
    class changes in addition to the `SendStoreCoupon` class that was created in the
    preceding section:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨从多个父类继承的情况。我们将看到当父类顺序改变时，除了上一节中创建的`SendStoreCoupon`类之外，方法解析会发生什么变化：
- en: First, we will be creating another class, named `ManufacturerCoupon`, where
    we will be defining attributes for a manufacturer such as the product name, product
    category, brand of the product, manufacturer name where the product is sold, expiry
    date of the product, and quantity to be purchased to get a coupon.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建另一个名为`ManufacturerCoupon`的类，在该类中我们将定义制造商的属性，例如产品名称、产品类别、产品品牌、产品销售制造商名称、产品有效期以及购买以获得优惠券的数量。
- en: 'We will then define a method named `generate_coupon`, where we will be generating
    two coupons for the product with random coupon ID values and all the details of
    the product and its manufacturer:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个名为`generate_coupon`的方法，在该方法中我们将为产品生成两个优惠券，具有随机的优惠券ID值以及产品及其制造商的所有详细信息：
- en: '[PRE26]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s also define the `SendCoupon` class with two parent classes—`ManufacturerCoupon`
    and `SendStoreCoupon`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也定义具有两个父类——`ManufacturerCoupon`和`SendStoreCoupon`的`SendCoupon`类：
- en: '[PRE27]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The MRO of the class is represented in the following output:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类的MRO在以下输出中展示：
- en: '[PRE28]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s further create an object for the class and call the `generate_coupon`
    method:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步为该类创建一个对象并调用`generate_coupon`方法：
- en: '[PRE29]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `generate_coupon` method generated coupons for the manufacturer in this
    example since the first parent that has the `generate_coupon` method definition
    is `ManufacturerCoupon`. The following coupons are generated from the `generate_coupon`
    method:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，`generate_coupon`方法为制造商生成了优惠券，因为第一个具有`generate_coupon`方法定义的父类是`ManufacturerCoupon`。以下是从`generate_coupon`方法生成的优惠券：
- en: '[PRE30]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s further change the order of inheritance in the `SendCoupon` class and
    look at how the methods are resolved:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`SendCoupon`类中进一步改变继承顺序，并查看方法是如何解析的：
- en: '[PRE31]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The MRO of the class is represented in the following output:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类的MRO在以下输出中展示：
- en: '[PRE32]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s further create an object for the class and call the `generate_coupon`
    method:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步为该类创建一个对象并调用`generate_coupon`方法：
- en: '[PRE33]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `generate_coupon` method generated coupons for the store in this example
    since the first parent that has the `generate_coupon` method definition is `SendStoreCoupon`,
    which in turn inherits the method from its `StoreCoupon` parent class, as represented
    in the following output:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，`generate_coupon`方法为商店生成了优惠券，因为第一个具有`generate_coupon`方法定义的父类是`SendStoreCoupon`，它反过来又从其`StoreCoupon`父类继承了这个方法，如下所示输出：
- en: '[PRE34]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this section, we understood the impact of the order in which a child class
    resolved the parent classes or the superclasses.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了子类解决父类或超类顺序的影响。
- en: With this understanding, let’s look at what happens when the inheritance becomes
    even more complex and where it can lead to errors.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，让我们看看当继承变得更加复杂时会发生什么，以及它可能导致错误的地方。
- en: Impact of unintended change of order in inheritance
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承顺序无意改变的 影响
- en: In this section, we will be looking at examples that demonstrate how important
    the order of inheritance is to resolve the methods in the case of multilevel inheritance,
    and what happens when the order changes in one of the parent or superclasses unintentionally.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过示例来展示在多层继承的情况下，方法的解析顺序是多么重要，以及当父类或超类中顺序无意中改变时会发生什么。
- en: 'This is how it works:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：
- en: 'Let’s start by creating a class named `CommonCounter` that initializes with
    two attributes, `items` and `name`. Let’s also add two methods to this class,
    `return_cart` (which returns the items in the cart) and `goto_counter` (which
    returns the name of the counter). This is how the code looks:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `CommonCounter` 的类，该类初始化时包含两个属性，`items` 和 `name`。同时，我们还要为这个类添加两个方法，`return_cart`（返回购物车中的商品）和
    `goto_counter`（返回计数器的名称）。代码如下所示：
- en: '[PRE35]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The MRO of the class is represented in the following output:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的 MRO 如下所示：
- en: '[PRE36]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s now create another class, named `CheckItems`, which is also going to
    be a parent class in multilevel inheritance applied in this section. This class
    will have one attribute named `item_type` and one method named `review_items`
    that returns the name of the counter based on the type of items in the cart:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个类，命名为 `CheckItems`，它也将成为本节多层继承中的一个父类。这个类将有一个名为 `item_type` 的属性和一个名为
    `review_items` 的方法，该方法根据购物车中物品的类型返回计数器的名称：
- en: '[PRE37]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The MRO of the class is represented in the following output:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的 MRO 如下所示：
- en: '[PRE38]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On the second level of inheritance, let’s create a class named `ElectronicsCounter`,
    which inherits from the `CommonCounter` and `CheckItems` classes, in that order:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继承的第二层，我们创建一个名为 `ElectronicsCounter` 的类，它按顺序继承自 `CommonCounter` 和 `CheckItems`
    类：
- en: '[PRE39]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The MRO of the class is represented in the following output:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的 MRO 如下所示：
- en: '[PRE40]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'On the second level of inheritance, let’s also create a class named `VegeCounter`,
    which inherits from the `CheckItems` and `CommonCounter` classes, in that order:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继承的第二层，我们还要创建一个名为 `VegeCounter` 的类，它按顺序继承自 `CheckItems` 和 `CommonCounter` 类：
- en: '[PRE41]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The MRO of the class is represented in the following output:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的 MRO 如下所示：
- en: '[PRE42]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s now create another class, named `ScanCode`, which inherits the `ElectronicsCounter`
    and `VegCounter` classes:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个类，命名为 `ScanCode`，它继承自 `ElectronicsCounter` 和 `VegCounter` 类：
- en: '[PRE43]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding code results in the following error message:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码导致以下错误信息：
- en: '![Figure 10.1 – MRO error ](img/Figure_10.1_B13426.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – MRO 错误](img/Figure_10.1_B13426.jpg)'
- en: Figure 10.1 – MRO error
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – MRO 错误
- en: Even though the MRO of the class is `ScanCode` followed by `ElectronicsCounter`
    followed by `VegeCounter` followed by `CommonCounter` followed by `CheckItems`
    followed by `object`, the MROs of the `CommonCounter` and `CheckItems` base classes
    are reversed. Therefore, the overall class definition throws an error in this
    scenario.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管类的 MRO 是 `ScanCode` 后跟 `ElectronicsCounter`，然后是 `VegeCounter`，接着是 `CommonCounter`，然后是
    `CheckItems`，最后是 `object`，但 `CommonCounter` 和 `CheckItems` 基类的 MRO 是相反的。因此，在这种情况下，整体类定义会抛出错误。
- en: This example demonstrates the impact of unintended change in the order of inheritance.
    It is important to ensure that the order of classes is correct while defining
    classes with multilevel inheritance in Python so that the MRO is consistent for
    base classes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了继承顺序无意中改变的影响。在 Python 中定义具有多层继承的类时，确保类顺序正确非常重要，以确保基类的 MRO 一致。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the concept of method resolution by exploring
    the MRO method in Python 3\. We also inspected the MRO of Python code by implementing
    different types of inheritance. We understood the impact of MRO by modifying the
    order of inheritance at various levels for multiple classes from our core example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过探索 Python 3 中的 MRO 方法来了解方法解析的概念。我们还通过实现不同类型的继承来检查 Python 代码的 MRO。我们通过修改多个类在各个继承层次上的顺序来理解
    MRO 的影响。
- en: Similar to other chapters covered in this book, this chapter explains that the
    MRO also focuses on metaprogramming and its impact on Python code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中涵盖的其他章节类似，本章解释了 MRO 也关注元编程及其对 Python 代码的影响。
- en: In the next chapter, we will be looking at the concept of dynamic objects, with
    some other interesting examples.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨动态对象的概念，并给出一些有趣的示例。
