- en: Chapter 5. Invaders Revenge – an Interactive Multi-touch Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。侵略者复仇 - 一个交互式多点触控游戏
- en: 'This chapter introduces a collection of components and strategies to make animated
    and dynamic applications. Most of them are particularly useful for game development.
    This chapter is full of examples of how to combine different Kivy elements and
    teaches strategies to control multiple events happening at the same time. The
    examples are all integrated in a completely new project, a version of the classic
    *Space Invaders* game (Copyright ©1978 Taito Corporation, [http://en.wikipedia.org/wiki/Space_Invaders](http://en.wikipedia.org/wiki/Space_Invaders)).
    The following is a list of the main components that we will work on in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一系列组件和策略，用于制作动画和动态应用程序。其中大部分特别适用于游戏开发。本章充满了如何结合不同的Kivy元素以及控制同时发生的多个事件的策略的示例。所有示例都集成在一个全新的项目中，这是一个经典游戏《太空侵略者》的版本（版权©1978年太田公司，[http://en.wikipedia.org/wiki/Space_Invaders](http://en.wikipedia.org/wiki/Space_Invaders)）。以下是我们将在本章中工作的主要组件列表：
- en: '**Atlas**: A Kivy package that allows us to load images efficiently'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图集**：一个Kivy包，允许我们高效地加载图像'
- en: '**Sound**: Classes that allow sound management'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声音**：允许声音管理的类'
- en: '**Animations**: Transitions, time control, events, and operations that can
    be applied to animate widgets'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**：可以应用于小部件的过渡、时间控制、事件和操作'
- en: '**Clock**: A class that allows us to schedule events'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时钟**：一个允许我们安排事件的类'
- en: '**Multi-touch**: A strategy that allows us to control different actions according
    to touches'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多点触控**：一种允许我们根据触摸控制不同动作的策略'
- en: '**Keyboard**: The Kivy strategy of capturing keyboard events'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键盘**：Kivy捕获键盘事件的策略'
- en: The first section presents an overview of the project, the GUI, and the rules
    of the game. After that, we will follow a bottom-up approach. The simple classes
    that refer to individual components of the game will be explained, and additional
    topics of the chapter will then be introduced one after another. We will finish
    with the classes that have the main control over the game. By the end of this
    chapter, you should be able to start any game application you have always wanted
    to implement for your mobile device.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分介绍了项目概述、GUI和游戏规则。之后，我们将采用自下而上的方法。解释与游戏各个组件相关的简单类，然后依次介绍本章的其他主题。我们将以对游戏有主要控制权的类结束。到本章结束时，你应该能够开始为你的移动设备实现任何你一直想要实现的游戏应用程序。
- en: Invaders Revenge – an animated multi-touch game
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侵略者复仇 - 一个动画多点触控游戏
- en: '*Invaders Revenge* is the name of our Kivy version of Space Invaders©. The
    following screenshot shows you the game we will build in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*侵略者复仇*是我们Kivy版本的《太空侵略者》©的名称。以下截图显示了本章我们将构建的游戏：'
- en: '![Invaders Revenge – an animated multi-touch game](img/B04244_05_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![侵略者复仇 - 一个动画多点触控游戏](img/B04244_05_01.jpg)'
- en: There are several tags in yellow and cyan in the screenshot (or gray dashed
    lines in the printed version). They help identify the structure of our game; the
    game will consist of one *shooter* (the player), who shoots (*shots*) at 32 (8x4)
    *invaders* who are trying to destroy the *shooter* with their *missiles*. The
    *invaders* are organized in a *fleet* (which moves horizontally) and sometimes
    an individual *invader* can break out of the grid formation and fly around the
    screen before going back to its corresponding position (*dock*) in the *fleet*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 截图中有几个黄色和青色的标签（或打印版本中的灰色虚线）。它们帮助我们识别游戏的结构；游戏将包括一个**射击者**（玩家），他向32（8x4）个**侵略者**射击（*射击*），这些侵略者试图用他们的**导弹**摧毁**射击者**。**侵略者**组织在一个**舰队**（水平移动）中，有时一个单独的**侵略者**可以突破网格结构，在屏幕上飞来飞去，然后再回到其在**舰队**中的对应位置（*码头*）。
- en: The cyan (gray in the printed version) line across the screen indicates an internal
    division of the screen into the *enemy area* and *shooter area*. This division
    is used to distinguish between actions that should occur according to touches
    that happen in different sections of the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上横跨的青色（打印版本中为灰色）线条表示屏幕内部将屏幕划分为**敌对区域**和**射击区域**。这种划分用于区分根据屏幕不同部分发生的触摸而应发生的动作。
- en: 'The skeleton of the game is presented in the `invasion.kv` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的骨架在`invasion.kv`文件中展示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are two `AnchorLayout` instances. The top one is the *enemy area* that
    contains the *fleet* and the bottom one is the *shooter area* that contains the
    *shooter*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个`AnchorLayout`实例。上面的一个是包含**舰队**的**敌对区域**，下面的一个是包含**射击者**的**射击区域**。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The *enemy area* and *shooter area* are very important for the logic of the
    game in order to distinguish between the types of touches on the screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*敌人区域*和*射击区域*对于游戏的逻辑非常重要，以便区分屏幕上触摸的类型。'
- en: 'We also created some IDs and references that will allow the interaction between
    different instances of the interface. The following diagram summarizes these relations:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一些ID和引用，这将允许不同界面实例之间的交互。以下图表总结了这些关系：
- en: '![Invaders Revenge – an animated multi-touch game](img/B04244_05_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![侵略者复仇 – 一个动画多点触控游戏](img/B04244_05_02.jpg)'
- en: Atlas – An efficient management of images
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Atlas – 高效的图像管理
- en: When it comes to applications that use many images, it is important to reduce
    their loading time, especially when they are requested from a remote server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用许多图像的应用程序时，减少它们的加载时间非常重要，尤其是在它们从远程服务器请求时。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One strategy to reduce the loading time is to use an **Atlas** (also known as
    sprite). An Atlas groups all the application images into one big image, so it
    reduces the number of necessary requests to the operating system, or online requests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 减少加载时间的一种策略是使用**Atlas**（也称为精灵）。Atlas将所有应用程序图像组合成一个大的图像，因此减少了必要的操作系统或在线请求的数量。
- en: 'Here is the image of the Atlas we use for invaders revenge:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们用于“侵略者复仇”游戏的Atlas图像：
- en: '![Atlas – An efficient management of images](img/B04244_05_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Atlas – 高效的图像管理](img/B04244_05_03.jpg)'
- en: 'Instead of requesting five images for the *invaders revenge*, we will just
    request the Atlas image. We will also need an associated `json` file that tells
    us the exact coordinates of each unit in the image. The good news is that we don''t
    need to do this manually. Kivy provides a simple command to create both the Atlas
    image and the `json` file. Assuming that all the images are in a directory called
    `img`, we just need to open a terminal, go to the `img` directory (that contains
    the individual images), and run the following command in the terminal:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再请求五个“侵略者复仇”图像，而是只请求Atlas图像。我们还需要一个相关的`json`文件，它告诉我们图像中每个单元的确切坐标。好消息是，我们不需要手动做这件事。Kivy提供了一个简单的命令来创建Atlas图像和`json`文件。假设所有图像都在名为`img`的目录中，我们只需要打开终端，转到`img`目录（包含单个图像），然后在终端中运行以下命令：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to execute the previous command, will you need to install the **Pillow
    library** ([http://python-pillow.github.io/](http://python-pillow.github.io/)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行前面的命令，您需要安装**Pillow库**([http://python-pillow.github.io/](http://python-pillow.github.io/))。
- en: The command contains three parameters, namely **`basename`**, **`size`**, and
    **`images list`**. The `basename` parameter is the prefix of the `json` file (`img/invasion.json`)
    and the Atlas image or images (`img/invasion-0.png`). It could happen that several
    Atlas images are generated, in which case we would have several images with `basename`
    as a prefix followed by a numerical identifier, for example, `invasion-0.png`
    and `invasion-1.png`. The `size` parameter indicates the size in pixels of the
    resulting Atlas image. Be sure to specify a size that is larger than the biggest
    of the images. The **`image list`** parameter is the list of all the images that
    will be added to the Atlas, and we can use the `*` wildcard. In our case, we will
    use it to indicate all files with the `.png` extension.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 命令包含三个参数，即**`basename`**、**`size`**和**`images list`**。`basename`参数是`json`文件（`img/invasion.json`）和Atlas图像或图像（`img/invasion-0.png`）的前缀。可能会生成多个Atlas图像，在这种情况下，我们会有一系列以`basename`为前缀并跟随数字标识符的图像，例如，`invasion-0.png`和`invasion-1.png`。`size`参数表示结果Atlas图像的像素大小。请确保指定一个比最大的图像更大的大小。**`image
    list`**参数是要添加到Atlas的所有图像的列表，我们可以使用`*`通配符。在我们的情况下，我们将使用它来指示所有具有`.png`扩展名的文件。
- en: 'In order to use the Atlas in the Kivy language, we have to use the following
    format: `atlas://path/to/atlas/atlas_name/id`. The `id` file refers to the image
    filename without the extension. For example, normally we would have referenced
    the *shooter* image as a source: `''img/shooter.png''`. After generating the Atlas,
    it becomes `source: ''atlas://images/invasion/shooter''`. The following `image.kv`
    file presents the code for all the images of *Invaders Revenge*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '为了在Kivy语言中使用Atlas，我们必须使用以下格式：`atlas://path/to/atlas/atlas_name/id`。`id`文件指的是不带扩展名的图像文件名。例如，我们通常会将*射击者*图像作为源引用：`''img/shooter.png''`。在生成Atlas后，它变为`source:
    ''atlas://images/invasion/shooter''`。下面的`image.kv`文件展示了“侵略者复仇”中所有图像的代码：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All the classes in this file inherit, directly or indirectly, from the `Image`
    class. The `Missile` and `Shot` inherit first from the class called `Ammo`, which
    also inherits from `Image`. There is also the `Boom` class that will create the
    effect of an explosion when any `Ammo` is triggered. Apart from the `Boom` image
    (a star in the Atlas), the `Boom` class will be associated with a sound that we
    will add in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本文件中的所有类都是直接或间接地从 `Image` 类继承而来的。`Missile` 和 `Shot` 首先从名为 `Ammo` 的类继承，该类也继承自
    `Image`。还有一个 `Boom` 类，当任何 `Ammo` 被触发时，它将创建爆炸效果。除了 `Boom` 图像（Atlas 中的星星）外，`Boom`
    类还将与我们在下一节中添加的声音相关联。
- en: Boom – simple sound effects
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爆炸声 – 简单的声音效果
- en: 'Adding sound effects in Kivy is very simple. A `Boom` instance will produce
    a sound when it is created, and this will happen every time a *shot* or *missile*
    is fired. Here is the code for `boom.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kivy 中添加声音效果非常简单。当创建 `Boom` 实例时，它会产生声音，并且每次发射 *射击* 或 *导弹* 时都会发生这种情况。以下是 `boom.py`
    的代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Reproducing a sound involves the use of two classes, **`Sound`** and **`SoundLoader`**
    (line 54). `SoundLoader` loads an audio file (`.wav`) and returns a `Sound` instance
    (line 57) that we keep in the `sound` reference (a static attribute of the `Boom`
    class). We play a sound every time a new `Boom` instance is created.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 生成声音涉及使用两个类，**`Sound`** 和 **`SoundLoader`**（第 54 行）。`SoundLoader` 加载音频文件（`.wav`）并返回一个
    `Sound` 实例（第 57 行），我们将其保存在 `sound` 引用中（`Boom` 类的静态属性）。每当创建一个新的 `Boom` 实例时，我们都会播放声音。
- en: Ammo – simple animation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Ammo` – 简单动画'
- en: 'This section explains how to animate *shots* and *missiles*, which show very
    similar behavior. They move from their original position to a destination, constantly
    checking whether a target has been hit. The following is the code for the `ammo.py`
    class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何对 *射击* 和 *导弹* 进行动画处理，它们表现出非常相似的行为。它们从原始位置移动到目的地，不断检查是否击中了目标。以下是对 `ammo.py`
    类的代码：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the `Ammo` animation, we require a simple **`Animation`** (line 69). We
    send `x` and `top` as parameters.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Ammo` 动画，我们需要一个简单的 **`Animation`**（第 69 行）。我们发送 `x` 和 `top` 作为参数。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The parameters of an `Animation` instance can be any properties of the widget
    to which we are applying the animation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animation` 实例的参数可以是应用动画的部件的任何属性。'
- en: In this case, the `x` and `top` properties belong to `Ammo` itself. This is
    enough to set `Animation` of `Ammo` from its original position to `tx`, `ty`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`x` 和 `top` 属性属于 `Ammo` 本身。这足以将 `Ammo` 的 `Animation` 从其原始位置设置为 `tx`，`ty`。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the execution period of **`Animation`** is one second.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**`Animation`** 的执行周期为 1 秒。
- en: We need `Ammo` to do a few more things in its trajectory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Ammo` 的轨迹中，我们需要 `Ammo` 做一些额外的事情。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Animation` class includes three events, which are triggered when the animations
    starts (**`on_start`**), during its progress (**`on_progress`**), and when it
    stops (**`on_stop`**).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animation` 类包括三个事件，当动画开始时触发（**`on_start`**），在其进行过程中触发（**`on_progress`**），以及当它停止时触发（**`on_stop`**）。'
- en: We bind these events (lines 70 to 72) to our own methods. The **`on_start`**
    method (line 75) displays a `Boom` instance (line 76) when the animation starts.
    The **`on_progress`** (lines 80 to 84) method removes `Boom` after 10 percent
    of **`progression`** (lines 81 and 82). Also, it is constantly checking `target`
    (line 83). When `target` is hit, the animation is stopped (line 84). Once the
    animation ends (or is stopped), `Ammo` is removed from the parent (line 82).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些事件（第 70 至 72 行）绑定到我们自己的方法上。**`on_start`** 方法（第 75 行）在动画开始时显示一个 `Boom` 实例（第
    76 行）。**`on_progress`**（第 80 至 84 行）方法在 10% 的 **`progression`**（第 81 和 82 行）后移除
    `Boom`。此外，它还会不断检查 `target`（第 83 行）。当 `target` 被击中时，动画停止（第 84 行）。一旦动画结束（或被停止），`Ammo`
    就会从父级中移除（第 82 行）。
- en: Lines 89 to 92 define two classes, `Shot` and `Missile`. The `Shot` and `Missile`
    classes inherit from `Ammo` and their only difference right now is the image that
    is used in `images.kv`. Eventually, we will use `Shot` instances for the *shooter*,
    and `Missile` instances for the *invaders*. Before this, let's give the *invaders*
    some freedom, so they can leave their *fleet* and perform an individual attack.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第 89 至 92 行定义了两个类，`Shot` 和 `Missile`。`Shot` 和 `Missile` 类从 `Ammo` 继承，它们目前唯一的区别是
    `images.kv` 中使用的图像。最终，我们将使用 `Shot` 实例进行 *射击*，使用 `Missile` 实例进行 *入侵者*。在此之前，让我们给
    *入侵者* 一些自由，这样它们就可以离开它们的 *舰队* 并执行单独的攻击。
- en: Invader – transitions for animations
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入侵者 – 动画的过渡
- en: 'The previous section uses the default `Animation` transition. This is a `Linear`
    transition, which means that the `Widget` instance moves from one point to another
    in a straight line. *Invaders* trajectories can be more interesting. For example,
    there could be accelerations, or changes of direction, as shown by the line in
    the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节使用默认的`Animation`过渡。这是一个`Linear`过渡，这意味着`Widget`实例从一个点移动到另一个点是一条直线。*入侵者*的轨迹可以更有趣。例如，可能会有加速度或方向变化，如下面的截图所示：
- en: '![Invader – transitions for animations](img/B04244_05_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![入侵者 – 动画过渡](img/B04244_05_04.jpg)'
- en: 'The following is the code of `invader.py`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`invader.py`的代码：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The idea behind this code is to let an *invader* break the formation from the
    *fleet* and proceed into a `solo_attack` (lines 106 to 111) method. The *invader's*
    `Animation` is created in the `trajectory` method (lines 113 and 119) by randomizing
    the final point of the *invader's* trajectory (lines 116 and 117). This randomization
    will pick up two coordinates on the left or right borders of the *enemy area*.
    Also, we randomize the type of **`transition`** (line 118), and **`duration`**
    (line 119) to create more diverse and unpredictable trajectories.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码背后的想法是让一个*入侵者*从*舰队*中打破队形并进入`solo_attack`（第106至111行）方法。*入侵者*的`Animation`在`trajectory`方法（第113和119行）中创建，通过随机化*入侵者*轨迹的终点（第116和117行）。这种随机化将在*敌方区域*的左右边界上选择两个坐标。此外，我们还随机化**`transition`**（第118行）和**`duration`**（第119行）以创建更多样化和不可预测的轨迹。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Kivy currently includes 31 **transitions**. They are represented by a string
    such as `'in_out_cubic'`, where `in_out` is a prefix that describes the way in
    which the function (`cubic`) is used. There are three possible prefixes (`in`,
    `out`, and `in_out`), and 10 functions (line 102), such as `cubic`, `exponential`,
    `sin`, `quadratic`. Please visit the Kivy API for a description of all of them
    ([http://kivy.org/docs/api-kivy.animation.html](http://kivy.org/docs/api-kivy.animation.html)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy目前包含31种**过渡**。它们由一个字符串表示，例如`'in_out_cubic'`，其中`in_out`是一个前缀，描述了函数（`cubic`）的使用方式。有三个可能的前缀（`in`、`out`和`in_out`），以及10个函数（第102行），例如`cubic`、`exponential`、`sin`、`quadratic`。请访问Kivy
    API以了解它们的描述（[http://kivy.org/docs/api-kivy.animation.html](http://kivy.org/docs/api-kivy.animation.html)）。
- en: Line 118 selects one of the transitions randomly. The transition is applied
    to the progress, and therefore to `x` and `y` at the same time, which produces
    an interesting acceleration effect on the trajectories.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第118行随机选择一个过渡。过渡应用于进度，因此同时应用于`x`和`y`，这在轨迹上产生了一个有趣的加速度效果。
- en: When the `Animation` class ends its trajectory (line 110), the `to_dock` method
    (lines 121 to 126) brings the *invader* back to its original position starting
    from the top-center part of `Window`. We use the **`Window`** class to get `height`
    and `width`. Sometimes this is easier than traversing the chain of parents, to
    find the root widget. When the *invader* reaches the *dock*, it is bound back
    to it (line 125).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Animation`类结束其轨迹（第110行）时，`to_dock`方法（第121至126行）将*入侵者*从`Window`的顶部中心部分返回到其原始位置。我们使用**`Window`**类来获取`height`和`width`。有时这比遍历父级链以找到根小部件要简单。当*入侵者*到达*停靠点*时，它会被绑定回那里（第125行）。
- en: The last method (`drop_missile` in lines 128 to 133) shoots one *missile* that
    follows a vertical line starting from the *invader's* bottom-center position (line
    130) to the bottom of the screen (line 133). Remember that the `Missile` class
    inherits from the `Ammo` class we created in the previous section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法（第128至133行的`drop_missile`）发射一枚从*入侵者*底部中心位置（第130行）开始垂直向下至屏幕底部的*导弹*（第133行）。记住，`Missile`类继承自我们在前一节中创建的`Ammo`类。
- en: Our invaders can now move freely around the enemy area. However, we would also
    like to have some sort of group movement. In the next section, we will create
    a *dock* for each corresponding invader. In this way, the *invader* has a corresponding
    placeholder in the *fleet* formation. After this, we will create the *fleet*,
    which constantly moves all the *docks*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以让入侵者自由地在敌方区域内移动。然而，我们还想有一种群体移动方式。在下一节中，我们将为每个相应的入侵者创建一个*停靠点*。这样，*入侵者*在*舰队*队形中就有了一个对应的占位符。之后，我们将创建*舰队*，它将不断移动所有的*停靠点*。
- en: Dock – automatic binding in the Kivy language
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停靠点 – Kivy语言中的自动绑定
- en: You might realize from previous chapters that the Kivy language does more than
    simply transform its rules to Python instructions. For instance, you might see
    that when it creates properties, it also binds them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会从之前的章节中意识到，Kivy 语言不仅仅是将其规则转换为 Python 指令。例如，你可能会看到，当它创建属性时，它也会绑定它们。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When we do something common such as `pos: self.parent.pos` inside a layout,
    then the property of the parent is bound to its child. The child always moves
    to the parent position when the parent moves.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们在布局内部执行一些常见操作，例如 `pos: self.parent.pos` 时，父级的属性就会绑定到其子级。当父级移动时，子级总是移动到父级的位置。'
- en: This is usually desirable but not all the time. Think about `solo_attack` of
    the *invader*. We need it to break formation and follow a free trajectory on the
    screen. While this happens, the whole formation of *invaders* continues moving
    from right to left and vice versa. This means that the *invader* will receive
    two orders at the same time; one from the moving parent and another from the trajectory's
    `Animation`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是期望的，但并非总是如此。考虑一下入侵者的 `solo_attack`。我们需要它打破队形，并在屏幕上遵循自由轨迹。当这种情况发生时，整个入侵者队形将继续从右向左和从左向右移动。这意味着入侵者将同时接收到两个命令；一个来自移动的父级，另一个来自轨迹的
    `Animation`。
- en: 'This means that we need a placeholder (the *dock*) for each *invader*. This
    will secure the space for the *invader* when it comes back from executing a solo
    attack. If we don''t have a placeholder, the layout (`GridLayout`, as we will
    see in the next section) of the *fleet* will automatically reconfigure the formation,
    reallocating the rest of the *invaders* to fill the empty space. Also, the *invader*
    needs to free itself from the parent (the *dock*) so it can float to any location
    on the screen. The following code (`dock.py`) binds (lines 145 to 147) and unbinds
    (lines 149 to 151) the *invader* using Python, and not the Kivy language:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要为每个入侵者（*invader*）提供一个占位符（*dock*）。这样，当入侵者从单独攻击执行返回时，可以确保其空间。如果没有占位符，舰队（`GridLayout`，我们将在下一节中看到）的布局将自动重新配置队形，重新分配剩余的入侵者以填充空位。此外，入侵者还需要从父级（*dock*）中释放自己，以便可以在屏幕上的任何位置漂浮。以下代码（`dock.py`）使用
    Python 而不是 Kivy 语言绑定（第 145 至 147 行）和解除绑定（第 149 至 151 行）入侵者：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We use the knowledge from [Chapter 3](ch03.html "Chapter 3. Widget Events –
    Binding Actions"), *Widget Events – Binding Actions*, for this code, but the important
    part is the strategy that we apply.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 [第 3 章](ch03.html "第 3 章。部件事件 – 绑定动作") 的知识，*部件事件 – 绑定动作*，来编写此代码，但重要的是我们应用的策略。
- en: There will be situations in which we will want to avoid using the Kivy language
    because it is preferable to have complete control.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会希望避免使用 Kivy 语言，因为这更有利于完全控制。
- en: This doesn't mean that it is impossible to solve this using the Kivy language.
    For example, one common approach is to switch the *invader's* parent (*dock*)
    to, let's say, the root `Widget` instance of the application; this unbinds the
    position of the *invader* from its current parent. It doesn't really matter which
    approach we follow. As long as we understand the mechanisms, we will be able to
    find elegant solutions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着使用 Kivy 语言解决这个问题是不可能的。例如，一种常见的方法是将入侵者的父级（*dock*）切换到，比如说，应用程序的根 `Widget`
    实例；这将解除入侵者位置与其当前父级的绑定。我们遵循哪种方法并不重要。只要我们理解了机制，我们就能找到优雅的解决方案。
- en: Now that each invader has a *dock* securing its place in the *invaders* formation,
    we are ready to introduce some movement to the *fleet*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然每个入侵者都有一个确保其在入侵者队形中位置的 *dock*，我们就准备好向舰队引入一些运动。
- en: Fleet – infinite concatenation of animations
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 舰队 – 无限连接的动画
- en: 'In this section, we will animate the fleet so that it has perpetual movement
    from right to left and vice versa, as shown by the arrows in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使舰队从右向左和从左向右进行动画处理，以保持持续运动，如以下截图中的箭头所示：
- en: '![Fleet – infinite concatenation of animations](img/B04244_05_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![舰队 – 无限连接的动画](img/B04244_05_05.jpg)'
- en: In order to do this, we will learn how to concatenate one animation just after
    another one is completed. Indeed, we will create an infinite loop of animations
    so that the *fleet* is in perpetual movement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将学习如何在动画完成之后立即连接另一个动画。实际上，我们将创建一个无限循环的动画，使得舰队处于持续运动状态。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can concatenate two animations with the `on_complete` event.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `on_complete` 事件连接两个动画。
- en: 'The following code, fragment 1 (of 2), of `fleet.py` shows how to concatenate
    these events:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `fleet.py` 的代码片段 1（共 2 个），展示了如何连接这些事件：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `go_left` method (lines 180 to 183) binds the `on_complete` (line 182) event
    of an `Animation` instance to the `go_right` method (lines 185 to 188). Similarly,
    the `go_right` method binds the `on_complete` (line 187) event of another `Animation`
    instance to the `go_left` method. With this strategy, we create an infinite loop
    of two animations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`go_left` 方法（第 180 至 183 行）将 `Animation` 实例的 `on_complete`（第 182 行）事件绑定到 `go_right`
    方法（第 185 至 188 行）。同样，`go_right` 方法将另一个 `Animation` 实例的 `on_complete`（第 187 行）事件绑定到
    `go_left` 方法。通过这种策略，我们创建了一个两个动画的无穷循环。'
- en: The `fleet.py` class also overloads the constructor to add 32 *invaders* (lines
    169 to 173) to the children of `Fleet`. These *invaders* are added to the survivors
    **`ListProperty`** that we use to keep track of the *invaders* that haven't been
    shot down. The `start_attack` method (lines 175 to 178) starts the `Fleet` animation
    calling the `go_left` method (line 177) and the `schedule_events` method (line
    178). The latter makes use of `Clock`, which will be explained in the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`fleet.py` 类还重载了构造函数，向 `Fleet` 的子类添加了 32 个 *入侵者*（第 169 至 173 行）。这些 *入侵者* 被添加到我们用来跟踪尚未被击落的
    *入侵者* 的 **`ListProperty`** 中。`start_attack` 方法（第 175 至 178 行）通过调用 `go_left` 方法（第
    177 行）和 `schedule_events` 方法（第 178 行）启动 `Fleet` 动画。后者使用了 `Clock`，这将在下一节中解释。'
- en: Scheduling events with the clock
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时钟安排事件
- en: 'We saw that `Animation` has a duration parameter that establishes the time
    in which an animation should take place. A different time-related topic is the
    scheduling of a particular task at a certain time or during intervals of n seconds.
    In these cases, we use the **`Clock`** class. Let''s analyze the following code,
    fragment 2 (of 2), of `fleet.py`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 `Animation` 有一个持续时间参数，它确定了动画应该持续的时间。另一个与时间相关的话题是在特定时间或 n 秒的间隔内安排特定任务。在这些情况下，我们使用
    **`Clock`** 类。让我们分析以下 `fleet.py` 的代码片段 2（共 2 个），如下所示：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `schedule_events` method (lines 190 to 192) schedules actions for a particular
    time. Line 191 schedules the `solo_attack` method every two seconds. Line 192
    schedules `shoot` just once at random (between 0 and 1) seconds.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`schedule_events` 方法（第 190 至 192 行）为特定时间安排动作。第 191 行每两秒安排一次 `solo_attack` 方法。第
    192 行随机安排一次 `shoot`（在 0 和 1 秒之间）。'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **`schedule_interval`** method schedules actions periodically, whereas the
    **`schedule_once`** method schedules an action just once.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**`schedule_interval`** 方法定期安排动作，而 **`schedule_once`** 方法只安排一次动作。'
- en: The `solo_attack` method (lines 194 to 198) randomly selects one of the survivors
    to perform the solo attack that we studied for the *invaders* (lines 106 to 111
    of `invader.py`). The `shoot` method (lines 200 to 205) randomly selects one survivor
    to fire a *missile* at the *shooter* (lines 201 to 204). After this, the method
    schedules another `shoot` (line 205).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`solo_attack` 方法（第 194 至 198 行）随机选择一个幸存者执行我们为 *入侵者* 研究的单独攻击（`invader.py` 中的第
    106 至 111 行）。`shoot` 方法（第 200 至 205 行）随机选择一个幸存者向 *射击者* 发射 *导弹*（第 201 至 204 行）。之后，该方法安排另一个
    `shoot`（第 205 行）。'
- en: In the `Ammo` class, we used the `collide_ammo` method to verify that an `Ammo`
    instance hits any of the *invaders* (line 83 of `ammo.py`). Now, in `fleet.py`,
    we implemented such a method (lines 207 or 213) that hides and removes the *invader*
    from the survivors list. The `on_survivors` event is triggered every time we modify
    the survivors `ListProperty`. When there are no survivors left, we unschedule
    the events with the **`unscheduled`** method (lines 217 and 218) and end the game
    by displaying the **You Win!** message.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Ammo` 类中，我们使用了 `collide_ammo` 方法来验证 `Ammo` 实例是否击中了任何 *入侵者*（`ammo.py` 中的第
    83 行）。现在，在 `fleet.py` 中，我们实现了这样一个方法（第 207 或 213 行），它将 *入侵者* 隐藏并从幸存者列表中删除。每当修改幸存者
    `ListProperty` 时，都会触发 `on_survivors` 事件。当没有幸存者剩下时，我们使用 **`unscheduled`** 方法（第
    217 和 218 行）取消安排事件，并通过显示 **You Win!** 消息来结束游戏。
- en: We finished creating the shooter enemies. Now it is time to provide the *shooter*
    with movement to dodge the *missiles* and *shots* to hit the *invaders*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了射击者敌人的创建。现在，是时候为 *射击者* 提供躲避 *导弹* 和 *射击* 以击中 *入侵者* 的移动了。
- en: Shooter – multi-touch control
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射击者 – 多点触控控制
- en: Kivy supports multi-touch interactions. This feature is always present but we
    haven't paid too much attention to it except when we used the `Scatter` widget
    in [Chapter 4](ch04.html "Chapter 4. Improving the User Experience"), *Improving
    the User Experience*. Additionally, we didn't clarify that the entire screen and
    GUI components are already capable of multi-touch, and that Kivy handles the events
    accordingly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 支持多点触控交互。这个特性始终存在，但我们除了在 [第 4 章](ch04.html "第 4 章。改进用户体验") *改进用户体验* 中使用
    `Scatter` 小部件时之外，并没有过多关注它。我们没有明确指出整个屏幕和 GUI 组件已经能够进行多点触控，以及 Kivy 会相应地处理这些事件。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Kivy handles multi-touch actions internally. This means that all the Kivy widgets
    and components support multi-touch interaction; we don't have to worry about it.
    Kivy solves all the possible conflicts of ambiguous situations that are common
    in multi-touch control, for example, touching two buttons at the same time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 在内部处理多点触控动作。这意味着所有 Kivy 小部件和组件都支持多点触控交互；我们不必担心这一点。Kivy 解决了多点触控控制中常见的模糊情况的所有可能冲突，例如，同时触摸两个按钮。
- en: That said, it is up to us to control particular implementations. Multi-touch
    programming introduces logic problems that we need to solve as developers. Nevertheless,
    Kivy provides the data related to each particular touch so we can work on the
    logic. The main problem is that we need to constantly distinguish one touch from
    another, and then take the respective actions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，控制特定实现的责任在我们身上。多点触控编程引入了我们需要作为开发者解决的逻辑问题。尽管如此，Kivy 提供了与每个特定触摸相关的数据，因此我们可以处理逻辑。主要问题是我们需要不断区分一个触摸与另一个触摸，然后采取相应的行动。
- en: 'With Invaders Revenge, we need to distinguish between two actions that are
    triggered by the same type of touch. The first action is the *shooter''s* horizontal
    movement in order to avoid the invaders'' *missiles*. The second is touching the
    screen to fire at the *invaders*. The following screenshot illustrates these two
    actions with the wide thick arrows (sliding touch) and the dotted thin arrow (shot
    action):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在《入侵者复仇》中，我们需要区分由相同类型的触摸触发的两种动作。第一种动作是 *射手* 的水平移动，以避免入侵者的 *导弹*。第二种是触摸屏幕以射击 *入侵者*。以下截图通过宽粗箭头（滑动触摸）和虚线细箭头（射击动作）说明了这两种动作：
- en: '![Shooter – multi-touch control](img/B04244_05_06.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![射手 – 多点触控](img/B04244_05_06.jpg)'
- en: 'The following code, fragment 1 (of 2), of `shooter.py` controls these two actions
    by using the *enemy area* and *shooter area*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `shooter.py` 的代码片段 1（共 2 个），通过使用 *敌人区域* 和 *射手区域* 来控制这两种动作：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `on_touch_down` (lines 229 to 235) and `on_touch_move` (lines 237 to 241)
    methods distinguish between the two actions, *movement* or *shoot*, by using the
    *shooter area* (lines 230 and 238) and the *enemy area* (lines 233 and 240) widgets,
    respectively, in order to collide the coordinates of the event.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_touch_down`（第 229 至 235 行）和 `on_touch_move`（第 237 至 241 行）方法通过分别使用 *射手区域*（第
    230 和 238 行）和 *敌人区域*（第 233 和 240 行）小部件来区分两种动作，*移动* 或 *射击*，以便碰撞事件的坐标。'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The touch coordinates are the most common strategy to identify specific touches.
    However, touches have many other attributes that could help to distinguish between
    them, for example, timing, a double (or triple) tap, or the input device. You
    can check the `MotionEvent` class to review all the attributes of a touch ([http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent](http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent)).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸坐标是最常见的识别特定触摸的策略。然而，触摸有许多其他属性可以帮助区分它们，例如，时间、双击（或三击）或输入设备。您可以通过检查 `MotionEvent`
    类来查看触摸的所有属性（[http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent](http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent)）。
- en: In contrast, the `on_touch_up` method (line 243) follows a different approach.
    It uses the **`ud`** attribute (user data dictionary to store personalized data
    on the touch) of a `MotionEvent` instance (touch) to determine whether the touchdown
    that started the event was a *movement* (in the *shooter area*) or a *shoot* (in
    the *enemy area*). We set `touch.ud` (lines 232 and 235) previously on `on_touch_down`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，`on_touch_up` 方法（第 243 行）采用了一种不同的方法。它使用 `MotionEvent` 实例（触摸）的 **`ud`**
    属性（用户数据字典，用于在触摸中存储个性化数据）来确定事件开始时的触摸是否是 *移动*（在 *射手区域*）还是 *射击*（在 *敌人区域*）。我们之前在 `on_touch_down`
    中设置了 `touch.ud`（第 232 和 235 行）。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Kivy keeps the touch event associated with the three basic touch events (down,
    move, and up), so the touch references we get for `on_touch_down`, `on_touch_move`,
    and `on_touch_up` are the same, and we can distinguish between touches.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy将触摸事件与三个基本触摸事件（按下、移动和抬起）关联起来，因此我们获取的`on_touch_down`、`on_touch_move`和`on_touch_up`的触摸引用是相同的，我们可以区分触摸。
- en: 'Let''s now analyze the details of the methods that are called on by these events.
    The following is the code, fragment 2 (of 2), of `shooter.py`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来分析这些事件调用的方法细节。以下是从`shooter.py`中提取的代码片段2（共2个）：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We first created a method to start the shooter by bringing it to life (line
    247 and 248), which we will use when we start the game. Then, we implement an
    interesting behavior for the `on_touch_move` method with the `shoot` method (lines
    250 to 258). Instead of shooting as fast as possible, we delay the next `shoot`
    by `0.5` seconds. This delay simulates a time lapse in which the gun needs to
    be reloaded (line 253). Otherwise, it would be unfair to the *invaders* to shoot
    as fast as the computer allows. Conversely, when we use the `on_touch_up` method,
    the gun is reloaded immediately so, in this case, it would be the skill of the
    player who could fire faster with a touchdown and touch-up sequence.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个方法来启动射手（第247和248行），我们将在游戏开始时使用它。然后，我们为`on_touch_move`方法与`shoot`方法（第250至258行）实现了一个有趣的行为。我们不是尽可能快地射击，而是将下一次`shoot`延迟`0.5`秒。这个延迟模拟了枪需要重新装填的时间间隔（第253行）。否则，如果允许计算机以尽可能快的速度射击，这对**入侵者**来说是不公平的。相反，当我们使用`on_touch_up`方法时，枪立即重新装填，因此在这种情况下，这将取决于玩家的技巧，看谁能够通过射门和触摸序列更快地射击。
- en: The `collide_ammo` method (lines 263 to 269) is almost equivalent to the `collide_ammo`
    method of the `Fleet` (lines 207 to 213). The only difference is that there is
    just one *shooter* instead of a set of *invaders*. If the *shooter* is hit, then
    the game is over and the message **Game Over** is displayed. Notice that we don't
    remove the *shooter*, we simply set its `alife` flag to `False` (line 265), and
    hide it by setting the color to black (line 266). With this, we avoid inconsistencies
    in references that point to an instance that no longer exists in the interface
    context.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`collide_ammo`方法（第263至269行）几乎等同于`Fleet`（第207至213行）中的`collide_ammo`方法。唯一的区别是只有一个**射手**而不是一组**入侵者**。如果**射手**被击中，则游戏结束，并显示**游戏结束**的消息。请注意，我们没有移除**射手**，我们只是将其`alife`标志设置为`False`（第265行），并通过将颜色设置为黑色（第266行）来隐藏它。这样，我们避免了指向不再存在于界面上下文中的实例的引用不一致。'
- en: The `project` method (lines 271 to 278) extends (project) the touch coordinates
    to the border of the screen, so the *shot* will continue its trajectory until
    it reaches the end of the screen and not stop exactly at the touch coordinate.
    The mathematical details are beyond the scope of this book but it is a simple
    linear projection.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`project`方法（第271至278行）将触摸坐标扩展到屏幕边界，因此**射击**将继续其轨迹直到屏幕的尽头，而不是正好停止在触摸坐标处。数学细节超出了本书的范围，但它是一种简单的线性投影。'
- en: The application is almost ready. There is just one minor problem. If you don't
    have a multi-touch screen, you would actually not be able to play this game. The
    next section introduces how to handle keyboard events in order to have a more
    classic gaming approach, which combines the keyboard and mouse.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序几乎准备好了。只有一个小问题。如果你没有多点触控屏幕，实际上你将无法玩这个游戏。下一节将介绍如何处理键盘事件，以便采用更经典的游戏方式，这种方式结合了键盘和鼠标。
- en: Invasion – moving the shooter with the keyboard
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入侵 - 使用键盘移动射手
- en: 'This section offers a second possibility of how to move the *shooter*. If you
    don''t have a multi-touch device, you will need to use something else to control
    the position of the *shooter* easily while you use the mouse to shoot. The following
    is the code, fragment 1, (of 2) of `main.py`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了第二种移动**射手**的方法。如果你没有多点触控设备，你将需要使用其他东西来轻松控制**射手**的位置，同时你使用鼠标进行射击。以下是从`main.py`中提取的代码片段1（共2个）：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code illustrates the keyboard event control. The `__init__` constructor
    (lines 295 to 299) will request **`keyboard`** (line 297) to the `Window` and
    `bind` (line 298) the **`on_keyboard_down`** event to the **`press`** method.
    One important parameter of the `Window._request_keyboard` method is the method
    that is called when `keyboard` is closed (lines 301 to 303). There are many reasons
    why the keyboard can become closed, including when another widget requests it.
    The `press` method (lines 305 to 310) is the one in charge of handling the keyboard
    input, the pressed key. The pressed key is kept in the `keycode` parameter and
    it is used in lines 306 and 308 to decide whether the *shooter* should move left
    or right.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码展示了键盘事件控制。`__init__`构造函数（第295至299行）将请求**`keyboard`**（第297行）到`Window`，并将**`on_keyboard_down`**事件绑定到**`press`**方法。`Window._request_keyboard`方法的一个重要参数是当`keyboard`关闭时调用的方法（第301至303行）。键盘可以关闭的原因有很多，包括当另一个小部件请求它时。`press`方法（第305至310行）负责处理键盘输入，即按下的键。按下的键保存在`keycode`参数中，并在第306和308行使用，以决定**射手**应该向左还是向右移动。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The keyboard binding in the game is for testing purposes on devices that have
    no multi-touch functionality. If you want to try it on your mobile device, you
    should comment out lines 297 and 298 to deactivate the keyboard binding.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的键盘绑定是为了在没有多触控功能的设备上进行测试。如果您想在您的移动设备上尝试它，您应该注释掉第297和298行以禁用键盘绑定。
- en: Line 299 calls the `start_game` method (lines 312 to 318). The method displays
    `Label` with the text **Ready!** Notice that we applied an `Animation` instance
    to `font_size` in line 314\. So far, we have been using the animations to move
    widgets around with the `x`, `y`, or `pos` properties. However, animations work
    with any property (that supports arithmetic operators; as a counter example, `String`
    doesn't support such operations). For example, we could use them to animate the
    rotation or scaling of `Scatter`. When the animation is complete, it will start
    both the *fleet* and the *shooter* (lines 315 and 316). Notice how we just bound
    two methods to the same event.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第299行调用了`start_game`方法（第312至318行）。该方法显示带有文本**Ready!**的`Label`。请注意，我们在第314行将一个`Animation`实例应用于`font_size`。到目前为止，我们一直在使用动画通过`x`、`y`或`pos`属性移动小部件。然而，动画可以与任何支持算术运算的属性一起工作（例如，`String`不支持此类运算；作为一个反例）。例如，我们可以使用它们来动画化`Scatter`的旋转或缩放。当动画完成后，它将同时启动**舰队**和**射手**（第315和316行）。注意我们如何将两个方法绑定到同一个事件。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is no limit to the number of methods that we can bind to an event.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任意数量的方法绑定到事件上。
- en: In the next section, we will discuss how to animate multiple properties in a
    sequence or simultaneously.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何按顺序或同时动画化多个属性。
- en: Combining animations with '+' and '&'
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`+`和`&`结合动画
- en: You already learned that you can add several properties to the same animation
    so that they are modified together (line 69 of `ammo.py`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到，您可以将多个属性添加到同一个动画中，以便它们一起修改（在`ammo.py`的第69行）。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can combine animations by using the `+` and `&` **operators**. The `+` operator
    is used to create sequenced animations (one after another). The `&` operator lets
    us execute two animations at the same time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`+`和`&`**运算符**来组合动画。`+`运算符用于创建顺序动画（一个接一个）。`&`运算符允许我们同时执行两个动画。
- en: 'The following code is fragment 2 of `main.py`, and illustrates the use of these
    two operators:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`main.py`的片段2，并展示了这两个运算符的使用：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `end_game` method (lines 320 to 324) displays a final message to indicate
    how the game ended (**You Win** on line 219 of `fleet.py` or **Game Over** on
    line 267 of `shooter.py`). This method uses the `composed_animation` method (lines
    326 to 330) to create a composed `Animation`, in which we use all the possibilities
    to combine animations. Line 327 is a simple `Animation` that is joined (with the
    '`&`' operator) to execute at the same time with another simple `Animation` of
    a different duration (line 328). In line 329, an `Animation` containing two properties
    (`font_size` and `y`) is attached to the previous one with the '`+`' operator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`end_game`方法（第320至324行）显示一条最终消息，以指示游戏如何结束（在`fleet.py`的第219行显示**You Win**或在`shooter.py`的第267行显示**Game
    Over**）。该方法使用`composed_animation`方法（第326至330行）创建一个组合的`Animation`，在其中我们使用所有可能的组合动画方式。第327行是一个简单的`Animation`，它通过`&`运算符与另一个不同持续时间的简单`Animation`同时执行。在第329行，一个包含两个属性（`font_size`和`y`）的`Animation`通过`+`运算符附加到之前的一个上。'
- en: 'The resulting animation does the following: it takes one second to move the
    message from the left to the middle, while the font size increases in size. When
    it gets to the middle, the increase in the font size continues for two more seconds.
    Once the font reaches its full size (72 points), the message moves to the bottom
    and keeps decreasing in size at the same time. The following diagram illustrates
    the whole animation sequence:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的动画执行以下操作：将消息从左侧移动到中间需要一秒钟，同时字体大小在增加。当它到达中间时，字体大小的增加持续两秒钟。一旦字体达到完全大小（72点），消息移动到底部，同时字体大小以相同的速度减小。以下图表说明了整个动画序列：
- en: '![Combining animations with ''+'' and ''&''](img/B04244_05_08.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ''+'' 和 ''&'' 符号组合动画](img/B04244_05_08.jpg)'
- en: 'The ''`+`'' operator is similar to what we did when we bound the `Animation
    on_complete` event to a method that creates another `Animation` in the *invader*:
    `animation.bind(on_complete = self.to_dock)` (line 110 of `invader.py`). The difference
    is that when we use the ''`+`'' operator, there is no chance to create an infinite
    loop as we did with the *fleet*, or change the `Widget` properties before starting
    another animation. For example, in the *invader* case, we relocated the *invader*
    to the top-center (lines 122 and 123) of the screen before the animation that
    carries it back to the *dock* (lines 124 to 126):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`''+''`运算符类似于我们在将`Animation on_complete`事件绑定到创建另一个`Animation`的方法时所做的操作：`animation.bind(on_complete
    = self.to_dock)`（`invader.py`的第110行）。区别在于，当我们使用`''+''`运算符时，没有机会创建无限循环，就像我们在`*fleet*`中做的那样，或者在进行另一个动画之前更改`Widget`属性。例如，在`*invader*`的情况下，我们在将其带回到`*dock*`的动画之前（第124到126行），将`*invader*`移动到屏幕的顶部中心（第122和123行）：'
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `&` operator is similar to sending two properties as parameters of the
    `Animation`, as we did in line 69: `self.animation = Animation(x=tx, top=ty)`.
    The difference in sending two properties as parameters is that they share the
    same duration and transition, whereas in line 328, we change the duration of the
    second property.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`运算符类似于将两个属性作为`Animation`的参数发送，就像我们在第69行所做的那样：`self.animation = Animation(x=tx,
    top=ty)`。将两个属性作为参数发送的区别在于，它们共享相同的持续时间和过渡效果，而在第328行，我们改变了第二个属性的持续时间。'
- en: 'Here is one last screenshot that shows how the invaders have finally taken
    their revenge:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一张最后的截图，展示了入侵者最终复仇的场景：
- en: '![Combining animations with ''+'' and ''&''](img/B04244_05_07.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ''+'' 和 ''&'' 符号组合动画](img/B04244_05_07.jpg)'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter covered the whole construction process of an interactive and animated
    application. You learned how to integrate various Kivy components and you should
    now be able to comfortably build a 2D animated game.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了整个交互式和动画应用程序的构建过程。你学习了如何集成各种Kivy组件，现在你应该能够轻松地构建一个2D动画游戏。
- en: 'Let''s review all the new classes and components we used in this chapter:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章中使用的所有新类和组件：
- en: '`Atlas`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Atlas`'
- en: '`Image`: The `source` property'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`: `source`属性'
- en: '`SoundLoader` and `Sound`: The `load` and `play` methods, respectively'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoundLoader`和`Sound`: 分别是`load`和`play`方法'
- en: '`Window`: The `height` and `width` properties, and the `request_keyboard`,
    `remove_widget`, and `add_widget` methods'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Window`: `高度`和`宽度`属性，以及`request_keyboard`、`remove_widget`和`add_widget`方法'
- en: '`Animation`: The properties as parameters; `d` and `t` parameters; `start`,
    `stop`, and `bind` methods; `on_start`, `on_progress`, and `on_complete` events;
    and `''+''` and `''&''` operators'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animation`: 作为参数的属性；`d`和`t`参数；`start`、`stop`和`bind`方法；`on_start`、`on_progress`和`on_complete`事件；以及`''+''`和`''&''`运算符'
- en: '`Touch`: `ud` attribute'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Touch`: `ud`属性'
- en: '`Clock`: `schedule_interval` and `schedule_once` methods'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clock`: `schedule_interval`和`schedule_once`方法'
- en: '`Keyboard`: `bind` and `unbind` methods, `on_key_down` event'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Keyboard`: `bind`和`unbind`方法，`on_key_down`事件'
- en: The information contained in this chapter presents tools and strategies you
    can use to develop highly interactive applications. By combining the previous
    chapters information with this chapter's insights into the use of properties,
    binding events, and further understanding of the Kivy language, you should be
    able to quickly start using all the other components of the Kivy API ([http://kivy.org/docs/api-kivy.html](http://kivy.org/docs/api-kivy.html)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含的信息提供了你可以用来开发高度交互式应用程序的工具和策略。通过将前几章的信息与本章对属性、绑定事件和Kivy语言进一步理解的洞察相结合，你应该能够快速开始使用Kivy
    API的所有其他组件（[http://kivy.org/docs/api-kivy.html](http://kivy.org/docs/api-kivy.html)）。
- en: The last chapter, [Chapter 6](ch06.html "Chapter 6. Kivy Player – a TED Video
    Streamer"), *Kivy Player – a TED Video Streamer,* of this book will teach you
    how to control multimedia components, in particular video and audio. It will present
    another example in order to present a few more Kivy components, but more importantly,
    it will teach you how to build a more professional looking interface. It will
    also introduce some Kivy tools to debug our applications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一章，[第6章](ch06.html "第6章。Kivy Player – TED视频流媒体"), *Kivy Player – TED视频流媒体*，本书将教你如何控制多媒体组件，特别是视频和音频。它将提供一个额外的示例，以便展示更多Kivy组件，但更重要的是，它将教你如何构建一个看起来更专业的界面。它还将介绍一些Kivy工具来调试我们的应用程序。
