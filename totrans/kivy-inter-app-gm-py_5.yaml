- en: Chapter 5. Invaders Revenge – an Interactive Multi-touch Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduces a collection of components and strategies to make animated
    and dynamic applications. Most of them are particularly useful for game development.
    This chapter is full of examples of how to combine different Kivy elements and
    teaches strategies to control multiple events happening at the same time. The
    examples are all integrated in a completely new project, a version of the classic
    *Space Invaders* game (Copyright ©1978 Taito Corporation, [http://en.wikipedia.org/wiki/Space_Invaders](http://en.wikipedia.org/wiki/Space_Invaders)).
    The following is a list of the main components that we will work on in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atlas**: A Kivy package that allows us to load images efficiently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sound**: Classes that allow sound management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animations**: Transitions, time control, events, and operations that can
    be applied to animate widgets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clock**: A class that allows us to schedule events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-touch**: A strategy that allows us to control different actions according
    to touches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyboard**: The Kivy strategy of capturing keyboard events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first section presents an overview of the project, the GUI, and the rules
    of the game. After that, we will follow a bottom-up approach. The simple classes
    that refer to individual components of the game will be explained, and additional
    topics of the chapter will then be introduced one after another. We will finish
    with the classes that have the main control over the game. By the end of this
    chapter, you should be able to start any game application you have always wanted
    to implement for your mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: Invaders Revenge – an animated multi-touch game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Invaders Revenge* is the name of our Kivy version of Space Invaders©. The
    following screenshot shows you the game we will build in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invaders Revenge – an animated multi-touch game](img/B04244_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are several tags in yellow and cyan in the screenshot (or gray dashed
    lines in the printed version). They help identify the structure of our game; the
    game will consist of one *shooter* (the player), who shoots (*shots*) at 32 (8x4)
    *invaders* who are trying to destroy the *shooter* with their *missiles*. The
    *invaders* are organized in a *fleet* (which moves horizontally) and sometimes
    an individual *invader* can break out of the grid formation and fly around the
    screen before going back to its corresponding position (*dock*) in the *fleet*.
  prefs: []
  type: TYPE_NORMAL
- en: The cyan (gray in the printed version) line across the screen indicates an internal
    division of the screen into the *enemy area* and *shooter area*. This division
    is used to distinguish between actions that should occur according to touches
    that happen in different sections of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The skeleton of the game is presented in the `invasion.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are two `AnchorLayout` instances. The top one is the *enemy area* that
    contains the *fleet* and the bottom one is the *shooter area* that contains the
    *shooter*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *enemy area* and *shooter area* are very important for the logic of the
    game in order to distinguish between the types of touches on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also created some IDs and references that will allow the interaction between
    different instances of the interface. The following diagram summarizes these relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invaders Revenge – an animated multi-touch game](img/B04244_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Atlas – An efficient management of images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to applications that use many images, it is important to reduce
    their loading time, especially when they are requested from a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One strategy to reduce the loading time is to use an **Atlas** (also known as
    sprite). An Atlas groups all the application images into one big image, so it
    reduces the number of necessary requests to the operating system, or online requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the image of the Atlas we use for invaders revenge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Atlas – An efficient management of images](img/B04244_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of requesting five images for the *invaders revenge*, we will just
    request the Atlas image. We will also need an associated `json` file that tells
    us the exact coordinates of each unit in the image. The good news is that we don''t
    need to do this manually. Kivy provides a simple command to create both the Atlas
    image and the `json` file. Assuming that all the images are in a directory called
    `img`, we just need to open a terminal, go to the `img` directory (that contains
    the individual images), and run the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to execute the previous command, will you need to install the **Pillow
    library** ([http://python-pillow.github.io/](http://python-pillow.github.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: The command contains three parameters, namely **`basename`**, **`size`**, and
    **`images list`**. The `basename` parameter is the prefix of the `json` file (`img/invasion.json`)
    and the Atlas image or images (`img/invasion-0.png`). It could happen that several
    Atlas images are generated, in which case we would have several images with `basename`
    as a prefix followed by a numerical identifier, for example, `invasion-0.png`
    and `invasion-1.png`. The `size` parameter indicates the size in pixels of the
    resulting Atlas image. Be sure to specify a size that is larger than the biggest
    of the images. The **`image list`** parameter is the list of all the images that
    will be added to the Atlas, and we can use the `*` wildcard. In our case, we will
    use it to indicate all files with the `.png` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the Atlas in the Kivy language, we have to use the following
    format: `atlas://path/to/atlas/atlas_name/id`. The `id` file refers to the image
    filename without the extension. For example, normally we would have referenced
    the *shooter* image as a source: `''img/shooter.png''`. After generating the Atlas,
    it becomes `source: ''atlas://images/invasion/shooter''`. The following `image.kv`
    file presents the code for all the images of *Invaders Revenge*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All the classes in this file inherit, directly or indirectly, from the `Image`
    class. The `Missile` and `Shot` inherit first from the class called `Ammo`, which
    also inherits from `Image`. There is also the `Boom` class that will create the
    effect of an explosion when any `Ammo` is triggered. Apart from the `Boom` image
    (a star in the Atlas), the `Boom` class will be associated with a sound that we
    will add in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Boom – simple sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding sound effects in Kivy is very simple. A `Boom` instance will produce
    a sound when it is created, and this will happen every time a *shot* or *missile*
    is fired. Here is the code for `boom.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Reproducing a sound involves the use of two classes, **`Sound`** and **`SoundLoader`**
    (line 54). `SoundLoader` loads an audio file (`.wav`) and returns a `Sound` instance
    (line 57) that we keep in the `sound` reference (a static attribute of the `Boom`
    class). We play a sound every time a new `Boom` instance is created.
  prefs: []
  type: TYPE_NORMAL
- en: Ammo – simple animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section explains how to animate *shots* and *missiles*, which show very
    similar behavior. They move from their original position to a destination, constantly
    checking whether a target has been hit. The following is the code for the `ammo.py`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For the `Ammo` animation, we require a simple **`Animation`** (line 69). We
    send `x` and `top` as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The parameters of an `Animation` instance can be any properties of the widget
    to which we are applying the animation.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `x` and `top` properties belong to `Ammo` itself. This is
    enough to set `Animation` of `Ammo` from its original position to `tx`, `ty`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the execution period of **`Animation`** is one second.
  prefs: []
  type: TYPE_NORMAL
- en: We need `Ammo` to do a few more things in its trajectory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Animation` class includes three events, which are triggered when the animations
    starts (**`on_start`**), during its progress (**`on_progress`**), and when it
    stops (**`on_stop`**).
  prefs: []
  type: TYPE_NORMAL
- en: We bind these events (lines 70 to 72) to our own methods. The **`on_start`**
    method (line 75) displays a `Boom` instance (line 76) when the animation starts.
    The **`on_progress`** (lines 80 to 84) method removes `Boom` after 10 percent
    of **`progression`** (lines 81 and 82). Also, it is constantly checking `target`
    (line 83). When `target` is hit, the animation is stopped (line 84). Once the
    animation ends (or is stopped), `Ammo` is removed from the parent (line 82).
  prefs: []
  type: TYPE_NORMAL
- en: Lines 89 to 92 define two classes, `Shot` and `Missile`. The `Shot` and `Missile`
    classes inherit from `Ammo` and their only difference right now is the image that
    is used in `images.kv`. Eventually, we will use `Shot` instances for the *shooter*,
    and `Missile` instances for the *invaders*. Before this, let's give the *invaders*
    some freedom, so they can leave their *fleet* and perform an individual attack.
  prefs: []
  type: TYPE_NORMAL
- en: Invader – transitions for animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous section uses the default `Animation` transition. This is a `Linear`
    transition, which means that the `Widget` instance moves from one point to another
    in a straight line. *Invaders* trajectories can be more interesting. For example,
    there could be accelerations, or changes of direction, as shown by the line in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invader – transitions for animations](img/B04244_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the code of `invader.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The idea behind this code is to let an *invader* break the formation from the
    *fleet* and proceed into a `solo_attack` (lines 106 to 111) method. The *invader's*
    `Animation` is created in the `trajectory` method (lines 113 and 119) by randomizing
    the final point of the *invader's* trajectory (lines 116 and 117). This randomization
    will pick up two coordinates on the left or right borders of the *enemy area*.
    Also, we randomize the type of **`transition`** (line 118), and **`duration`**
    (line 119) to create more diverse and unpredictable trajectories.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kivy currently includes 31 **transitions**. They are represented by a string
    such as `'in_out_cubic'`, where `in_out` is a prefix that describes the way in
    which the function (`cubic`) is used. There are three possible prefixes (`in`,
    `out`, and `in_out`), and 10 functions (line 102), such as `cubic`, `exponential`,
    `sin`, `quadratic`. Please visit the Kivy API for a description of all of them
    ([http://kivy.org/docs/api-kivy.animation.html](http://kivy.org/docs/api-kivy.animation.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Line 118 selects one of the transitions randomly. The transition is applied
    to the progress, and therefore to `x` and `y` at the same time, which produces
    an interesting acceleration effect on the trajectories.
  prefs: []
  type: TYPE_NORMAL
- en: When the `Animation` class ends its trajectory (line 110), the `to_dock` method
    (lines 121 to 126) brings the *invader* back to its original position starting
    from the top-center part of `Window`. We use the **`Window`** class to get `height`
    and `width`. Sometimes this is easier than traversing the chain of parents, to
    find the root widget. When the *invader* reaches the *dock*, it is bound back
    to it (line 125).
  prefs: []
  type: TYPE_NORMAL
- en: The last method (`drop_missile` in lines 128 to 133) shoots one *missile* that
    follows a vertical line starting from the *invader's* bottom-center position (line
    130) to the bottom of the screen (line 133). Remember that the `Missile` class
    inherits from the `Ammo` class we created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Our invaders can now move freely around the enemy area. However, we would also
    like to have some sort of group movement. In the next section, we will create
    a *dock* for each corresponding invader. In this way, the *invader* has a corresponding
    placeholder in the *fleet* formation. After this, we will create the *fleet*,
    which constantly moves all the *docks*.
  prefs: []
  type: TYPE_NORMAL
- en: Dock – automatic binding in the Kivy language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might realize from previous chapters that the Kivy language does more than
    simply transform its rules to Python instructions. For instance, you might see
    that when it creates properties, it also binds them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we do something common such as `pos: self.parent.pos` inside a layout,
    then the property of the parent is bound to its child. The child always moves
    to the parent position when the parent moves.'
  prefs: []
  type: TYPE_NORMAL
- en: This is usually desirable but not all the time. Think about `solo_attack` of
    the *invader*. We need it to break formation and follow a free trajectory on the
    screen. While this happens, the whole formation of *invaders* continues moving
    from right to left and vice versa. This means that the *invader* will receive
    two orders at the same time; one from the moving parent and another from the trajectory's
    `Animation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we need a placeholder (the *dock*) for each *invader*. This
    will secure the space for the *invader* when it comes back from executing a solo
    attack. If we don''t have a placeholder, the layout (`GridLayout`, as we will
    see in the next section) of the *fleet* will automatically reconfigure the formation,
    reallocating the rest of the *invaders* to fill the empty space. Also, the *invader*
    needs to free itself from the parent (the *dock*) so it can float to any location
    on the screen. The following code (`dock.py`) binds (lines 145 to 147) and unbinds
    (lines 149 to 151) the *invader* using Python, and not the Kivy language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the knowledge from [Chapter 3](ch03.html "Chapter 3. Widget Events –
    Binding Actions"), *Widget Events – Binding Actions*, for this code, but the important
    part is the strategy that we apply.
  prefs: []
  type: TYPE_NORMAL
- en: There will be situations in which we will want to avoid using the Kivy language
    because it is preferable to have complete control.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't mean that it is impossible to solve this using the Kivy language.
    For example, one common approach is to switch the *invader's* parent (*dock*)
    to, let's say, the root `Widget` instance of the application; this unbinds the
    position of the *invader* from its current parent. It doesn't really matter which
    approach we follow. As long as we understand the mechanisms, we will be able to
    find elegant solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that each invader has a *dock* securing its place in the *invaders* formation,
    we are ready to introduce some movement to the *fleet*.
  prefs: []
  type: TYPE_NORMAL
- en: Fleet – infinite concatenation of animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will animate the fleet so that it has perpetual movement
    from right to left and vice versa, as shown by the arrows in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fleet – infinite concatenation of animations](img/B04244_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to do this, we will learn how to concatenate one animation just after
    another one is completed. Indeed, we will create an infinite loop of animations
    so that the *fleet* is in perpetual movement.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can concatenate two animations with the `on_complete` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code, fragment 1 (of 2), of `fleet.py` shows how to concatenate
    these events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `go_left` method (lines 180 to 183) binds the `on_complete` (line 182) event
    of an `Animation` instance to the `go_right` method (lines 185 to 188). Similarly,
    the `go_right` method binds the `on_complete` (line 187) event of another `Animation`
    instance to the `go_left` method. With this strategy, we create an infinite loop
    of two animations.
  prefs: []
  type: TYPE_NORMAL
- en: The `fleet.py` class also overloads the constructor to add 32 *invaders* (lines
    169 to 173) to the children of `Fleet`. These *invaders* are added to the survivors
    **`ListProperty`** that we use to keep track of the *invaders* that haven't been
    shot down. The `start_attack` method (lines 175 to 178) starts the `Fleet` animation
    calling the `go_left` method (line 177) and the `schedule_events` method (line
    178). The latter makes use of `Clock`, which will be explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling events with the clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw that `Animation` has a duration parameter that establishes the time
    in which an animation should take place. A different time-related topic is the
    scheduling of a particular task at a certain time or during intervals of n seconds.
    In these cases, we use the **`Clock`** class. Let''s analyze the following code,
    fragment 2 (of 2), of `fleet.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `schedule_events` method (lines 190 to 192) schedules actions for a particular
    time. Line 191 schedules the `solo_attack` method every two seconds. Line 192
    schedules `shoot` just once at random (between 0 and 1) seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **`schedule_interval`** method schedules actions periodically, whereas the
    **`schedule_once`** method schedules an action just once.
  prefs: []
  type: TYPE_NORMAL
- en: The `solo_attack` method (lines 194 to 198) randomly selects one of the survivors
    to perform the solo attack that we studied for the *invaders* (lines 106 to 111
    of `invader.py`). The `shoot` method (lines 200 to 205) randomly selects one survivor
    to fire a *missile* at the *shooter* (lines 201 to 204). After this, the method
    schedules another `shoot` (line 205).
  prefs: []
  type: TYPE_NORMAL
- en: In the `Ammo` class, we used the `collide_ammo` method to verify that an `Ammo`
    instance hits any of the *invaders* (line 83 of `ammo.py`). Now, in `fleet.py`,
    we implemented such a method (lines 207 or 213) that hides and removes the *invader*
    from the survivors list. The `on_survivors` event is triggered every time we modify
    the survivors `ListProperty`. When there are no survivors left, we unschedule
    the events with the **`unscheduled`** method (lines 217 and 218) and end the game
    by displaying the **You Win!** message.
  prefs: []
  type: TYPE_NORMAL
- en: We finished creating the shooter enemies. Now it is time to provide the *shooter*
    with movement to dodge the *missiles* and *shots* to hit the *invaders*.
  prefs: []
  type: TYPE_NORMAL
- en: Shooter – multi-touch control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kivy supports multi-touch interactions. This feature is always present but we
    haven't paid too much attention to it except when we used the `Scatter` widget
    in [Chapter 4](ch04.html "Chapter 4. Improving the User Experience"), *Improving
    the User Experience*. Additionally, we didn't clarify that the entire screen and
    GUI components are already capable of multi-touch, and that Kivy handles the events
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kivy handles multi-touch actions internally. This means that all the Kivy widgets
    and components support multi-touch interaction; we don't have to worry about it.
    Kivy solves all the possible conflicts of ambiguous situations that are common
    in multi-touch control, for example, touching two buttons at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: That said, it is up to us to control particular implementations. Multi-touch
    programming introduces logic problems that we need to solve as developers. Nevertheless,
    Kivy provides the data related to each particular touch so we can work on the
    logic. The main problem is that we need to constantly distinguish one touch from
    another, and then take the respective actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Invaders Revenge, we need to distinguish between two actions that are
    triggered by the same type of touch. The first action is the *shooter''s* horizontal
    movement in order to avoid the invaders'' *missiles*. The second is touching the
    screen to fire at the *invaders*. The following screenshot illustrates these two
    actions with the wide thick arrows (sliding touch) and the dotted thin arrow (shot
    action):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shooter – multi-touch control](img/B04244_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code, fragment 1 (of 2), of `shooter.py` controls these two actions
    by using the *enemy area* and *shooter area*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `on_touch_down` (lines 229 to 235) and `on_touch_move` (lines 237 to 241)
    methods distinguish between the two actions, *movement* or *shoot*, by using the
    *shooter area* (lines 230 and 238) and the *enemy area* (lines 233 and 240) widgets,
    respectively, in order to collide the coordinates of the event.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The touch coordinates are the most common strategy to identify specific touches.
    However, touches have many other attributes that could help to distinguish between
    them, for example, timing, a double (or triple) tap, or the input device. You
    can check the `MotionEvent` class to review all the attributes of a touch ([http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent](http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent)).
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the `on_touch_up` method (line 243) follows a different approach.
    It uses the **`ud`** attribute (user data dictionary to store personalized data
    on the touch) of a `MotionEvent` instance (touch) to determine whether the touchdown
    that started the event was a *movement* (in the *shooter area*) or a *shoot* (in
    the *enemy area*). We set `touch.ud` (lines 232 and 235) previously on `on_touch_down`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kivy keeps the touch event associated with the three basic touch events (down,
    move, and up), so the touch references we get for `on_touch_down`, `on_touch_move`,
    and `on_touch_up` are the same, and we can distinguish between touches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now analyze the details of the methods that are called on by these events.
    The following is the code, fragment 2 (of 2), of `shooter.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We first created a method to start the shooter by bringing it to life (line
    247 and 248), which we will use when we start the game. Then, we implement an
    interesting behavior for the `on_touch_move` method with the `shoot` method (lines
    250 to 258). Instead of shooting as fast as possible, we delay the next `shoot`
    by `0.5` seconds. This delay simulates a time lapse in which the gun needs to
    be reloaded (line 253). Otherwise, it would be unfair to the *invaders* to shoot
    as fast as the computer allows. Conversely, when we use the `on_touch_up` method,
    the gun is reloaded immediately so, in this case, it would be the skill of the
    player who could fire faster with a touchdown and touch-up sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The `collide_ammo` method (lines 263 to 269) is almost equivalent to the `collide_ammo`
    method of the `Fleet` (lines 207 to 213). The only difference is that there is
    just one *shooter* instead of a set of *invaders*. If the *shooter* is hit, then
    the game is over and the message **Game Over** is displayed. Notice that we don't
    remove the *shooter*, we simply set its `alife` flag to `False` (line 265), and
    hide it by setting the color to black (line 266). With this, we avoid inconsistencies
    in references that point to an instance that no longer exists in the interface
    context.
  prefs: []
  type: TYPE_NORMAL
- en: The `project` method (lines 271 to 278) extends (project) the touch coordinates
    to the border of the screen, so the *shot* will continue its trajectory until
    it reaches the end of the screen and not stop exactly at the touch coordinate.
    The mathematical details are beyond the scope of this book but it is a simple
    linear projection.
  prefs: []
  type: TYPE_NORMAL
- en: The application is almost ready. There is just one minor problem. If you don't
    have a multi-touch screen, you would actually not be able to play this game. The
    next section introduces how to handle keyboard events in order to have a more
    classic gaming approach, which combines the keyboard and mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Invasion – moving the shooter with the keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section offers a second possibility of how to move the *shooter*. If you
    don''t have a multi-touch device, you will need to use something else to control
    the position of the *shooter* easily while you use the mouse to shoot. The following
    is the code, fragment 1, (of 2) of `main.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code illustrates the keyboard event control. The `__init__` constructor
    (lines 295 to 299) will request **`keyboard`** (line 297) to the `Window` and
    `bind` (line 298) the **`on_keyboard_down`** event to the **`press`** method.
    One important parameter of the `Window._request_keyboard` method is the method
    that is called when `keyboard` is closed (lines 301 to 303). There are many reasons
    why the keyboard can become closed, including when another widget requests it.
    The `press` method (lines 305 to 310) is the one in charge of handling the keyboard
    input, the pressed key. The pressed key is kept in the `keycode` parameter and
    it is used in lines 306 and 308 to decide whether the *shooter* should move left
    or right.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyboard binding in the game is for testing purposes on devices that have
    no multi-touch functionality. If you want to try it on your mobile device, you
    should comment out lines 297 and 298 to deactivate the keyboard binding.
  prefs: []
  type: TYPE_NORMAL
- en: Line 299 calls the `start_game` method (lines 312 to 318). The method displays
    `Label` with the text **Ready!** Notice that we applied an `Animation` instance
    to `font_size` in line 314\. So far, we have been using the animations to move
    widgets around with the `x`, `y`, or `pos` properties. However, animations work
    with any property (that supports arithmetic operators; as a counter example, `String`
    doesn't support such operations). For example, we could use them to animate the
    rotation or scaling of `Scatter`. When the animation is complete, it will start
    both the *fleet* and the *shooter* (lines 315 and 316). Notice how we just bound
    two methods to the same event.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no limit to the number of methods that we can bind to an event.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how to animate multiple properties in a
    sequence or simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Combining animations with '+' and '&'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You already learned that you can add several properties to the same animation
    so that they are modified together (line 69 of `ammo.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can combine animations by using the `+` and `&` **operators**. The `+` operator
    is used to create sequenced animations (one after another). The `&` operator lets
    us execute two animations at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is fragment 2 of `main.py`, and illustrates the use of these
    two operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `end_game` method (lines 320 to 324) displays a final message to indicate
    how the game ended (**You Win** on line 219 of `fleet.py` or **Game Over** on
    line 267 of `shooter.py`). This method uses the `composed_animation` method (lines
    326 to 330) to create a composed `Animation`, in which we use all the possibilities
    to combine animations. Line 327 is a simple `Animation` that is joined (with the
    '`&`' operator) to execute at the same time with another simple `Animation` of
    a different duration (line 328). In line 329, an `Animation` containing two properties
    (`font_size` and `y`) is attached to the previous one with the '`+`' operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting animation does the following: it takes one second to move the
    message from the left to the middle, while the font size increases in size. When
    it gets to the middle, the increase in the font size continues for two more seconds.
    Once the font reaches its full size (72 points), the message moves to the bottom
    and keeps decreasing in size at the same time. The following diagram illustrates
    the whole animation sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining animations with ''+'' and ''&''](img/B04244_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The ''`+`'' operator is similar to what we did when we bound the `Animation
    on_complete` event to a method that creates another `Animation` in the *invader*:
    `animation.bind(on_complete = self.to_dock)` (line 110 of `invader.py`). The difference
    is that when we use the ''`+`'' operator, there is no chance to create an infinite
    loop as we did with the *fleet*, or change the `Widget` properties before starting
    another animation. For example, in the *invader* case, we relocated the *invader*
    to the top-center (lines 122 and 123) of the screen before the animation that
    carries it back to the *dock* (lines 124 to 126):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&` operator is similar to sending two properties as parameters of the
    `Animation`, as we did in line 69: `self.animation = Animation(x=tx, top=ty)`.
    The difference in sending two properties as parameters is that they share the
    same duration and transition, whereas in line 328, we change the duration of the
    second property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one last screenshot that shows how the invaders have finally taken
    their revenge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining animations with ''+'' and ''&''](img/B04244_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the whole construction process of an interactive and animated
    application. You learned how to integrate various Kivy components and you should
    now be able to comfortably build a 2D animated game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review all the new classes and components we used in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Atlas`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Image`: The `source` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SoundLoader` and `Sound`: The `load` and `play` methods, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Window`: The `height` and `width` properties, and the `request_keyboard`,
    `remove_widget`, and `add_widget` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Animation`: The properties as parameters; `d` and `t` parameters; `start`,
    `stop`, and `bind` methods; `on_start`, `on_progress`, and `on_complete` events;
    and `''+''` and `''&''` operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Touch`: `ud` attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clock`: `schedule_interval` and `schedule_once` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Keyboard`: `bind` and `unbind` methods, `on_key_down` event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The information contained in this chapter presents tools and strategies you
    can use to develop highly interactive applications. By combining the previous
    chapters information with this chapter's insights into the use of properties,
    binding events, and further understanding of the Kivy language, you should be
    able to quickly start using all the other components of the Kivy API ([http://kivy.org/docs/api-kivy.html](http://kivy.org/docs/api-kivy.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The last chapter, [Chapter 6](ch06.html "Chapter 6. Kivy Player – a TED Video
    Streamer"), *Kivy Player – a TED Video Streamer,* of this book will teach you
    how to control multimedia components, in particular video and audio. It will present
    another example in order to present a few more Kivy components, but more importantly,
    it will teach you how to build a more professional looking interface. It will
    also introduce some Kivy tools to debug our applications.
  prefs: []
  type: TYPE_NORMAL
