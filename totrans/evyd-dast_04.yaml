- en: 'Chapter 4. Stacks: LIFO Collections'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stack** is an abstract data structure that serves as a collection of objects
    that are inserted and removed based on a **last-in first-out** (**LIFO**) principle.
    Accordingly, the two operations that most clearly define a stack structure are
    **push**, which adds objects to the collection, and **pop**, which removes objects
    from the collection. Other common operations include peek, clear, count, empty
    and full, all of which will be examined in the Advanced topics section later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks can be either array-based or linked list-based. And, similar to linked
    lists, stacks can be either sorted or unsorted. Considering the structure of a
    linked list, a linked list-based stack will be more efficient for sorting operations
    than an array-based stack.
  prefs: []
  type: TYPE_NORMAL
- en: A stack data structure is well suited for any application that requires the
    ability to add and remove objects only from the tail of a list. A good example
    of this is backtracking along a specified path or series of operations. If the
    application allows for adding or removing data from any point within the collection,
    then a linked list would be a better choice than the data structures we have already
    examined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of a Stack data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case study: motion planning algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common stack operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array-based stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List-based stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each language provides varying levels of support for the stack data structure.
    The following are some examples of initializing the collection, adding an object
    to the collection, and then removing the top object from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: C# provides a concrete implementation of the stack data structure through the
    `Stack<T>` generic class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: Java provides a concrete implementation of the stack data structure through
    the `Stack<T>` generic class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C does not provide a concrete implementation of the stack data structure,
    but one can be easily creating using the class cluster `NSMutableArray`. Be aware
    that this will create an array-based implementation of the stack, which is generally
    less efficient than a linked list-based implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: UINavigationController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not entirely accurate to state that Objective-C does not provide a stack
    data structure. Any amount of iOS programming in Objective-C will immediately
    expose a developer to an implementation of the stack data structure through use
    of the `UINavigationController` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `UINavigationController` class manages the navigation stack, which is an
    array-based stack of view controllers. The class exposes several methods corresponding
    to the basic stack operations. These include `pushViewController:animated:` (*push*),
    `popViewControllerAnimated:` (*pop*), `popToRootViewControllerAnimated:` (*clear*...sort
    of), and `topViewController:` (*peek*). The navigation stack is never *empty*
    unless it is a *nil* object, and it can only be considered *full* when your app
    adds so many view controllers that the device runs out of system resources.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is an array-based implementation, you can get the *count* of the
    stack by simply examining `count` on the collection itself. However, this is not
    a collection class you can use for just any purpose in your application. If you
    need a stack for more general circumstances, you are going to need to build one
    of your own.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Objective-C, Swift does not provide a concrete implementation of the stack
    data structure, but the Array class does expose some stack-like operations. The
    following example demonstrates the `popLast()` method, which removes and returns
    the last object in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Stack operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all implementations of stack data structures expose the same operational
    methods. However, the more common operations should be available or made available
    as needed by the developer. Each of these operations, whether they are part of
    an array-based implementation or a linked list-based one, have an operational
    cost of **O**(*1*).
  prefs: []
  type: TYPE_NORMAL
- en: '**push**: The push operation adds a new object onto the stack by either appending
    to the collection, if it is array-based, or adding a new node to the collection
    if it is linked list-based.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pop**: The pop operation is the opposite of push. In most implementations,
    the pop operation both removes and returns the top object off the stack to the
    caller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**peek**: The peek operation returns the top object off the stack to the caller,
    but does not remove the object from the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**clear**: The clear operation removes all objects from the stack, effectively
    resetting the collection to the empty state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**count**: The count operation, sometimes referred to as size or length, returns
    the total number of objects in the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**empty**: The empty operation typically returns a Boolean value denoting whether
    the collection has any objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**full**: The full operation typically returns a Boolean value denoting whether
    the collection is at capacity or if there is still room to add more objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case study: motion planning algorithm'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Business problem**: An industrial engineer programs a robotic manufacturing
    device to insert bolts in sequential receptacles on a widget, then attach and
    tighten nuts onto each bolt. The robot carriers a different tool for each operation,
    and can switch between them automatically on command. However, the process of
    switching between tools adds considerable time to the overall workflow, especially
    when the tool is switched back and forth over each bolt. This has been identified
    as a source of inefficiency, and the engineer wants to improve the speed of the
    process, reducing the overall time required to complete each unit.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to eliminate the latency introduced by switching between tools repeatedly,
    the engineer decides to program the robot to install all of the bolts first, and
    then switch tools before returning and installing all of the nuts. To further
    improve performance, he does not want the robot to reset to it's original starting
    position, but instead he wants it to retrace it's own steps while installing the
    nuts. By removing the reset before installing the nuts, his workflow eliminates
    two additional traversals across the widget. To accomplish his goals, the engineer
    needs to store the commands used to move the robot across the widget while inserting
    the bolts, and then play them back in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the nature of the data and the application, the class that represents
    the commands will need several basic pieces of functionality. First, it requires
    some mechanism for adding and removing commands as part of normal operation, as
    well as the ability to reset the system when the workflow encounters an error.
    In the case of a reset, the class must be able to report the count of commands
    currently waiting to be executed in order to account for inventory loss. Finally,
    the class should be able to easily report when the command list is at capacity
    or when the commands have all been completed.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen in the prior implementation examples, C# conveniently exposes
    a stack data structure through the `Stack<T>` class. There follows an example
    of what a simple implementation in C# might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our class declares two fields. The first is `_commandStack`, which represents
    our stack data structure and the core of this class. The field is publicly visible
    but can only be modified by the methods within our class. The second field is
    `_capacity`. This field maintains our caller-defined maximum number of commands
    in the collection. Finally, the constructor initializes `_commandStack` and assigns
    `commandCapacity` to `_capacity`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our first order of business is to establish some validation for our collection.
    The first validation method, `IsFull()`, checks if our stack has reached it's
    capacity. Since our business rules state that the robot must backtrack through
    all of its commands before it can proceed to a new widget, we will always track
    the number of commands that are being added into our collection. If for whatever
    reason we find that we have exceeded the pre-defined capacity for `_commandStack`,
    something has gone wrong during the previous backtracking operation and must be
    addressed. Therefore, we check that `_commandStack.Count` is greater than or equal
    to `_capacity` and return the value. `IsEmpty()` is the next validation method.
    This method must be called prior to any operations that could attempt to read
    from our stack by *peeking* at the collection. Both of these operations have an
    **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `PerformCommand(Command)` method provides the *push* functionality of our
    class. It accepts a single parameter of type `Command`, then checks if `_commandStack`
    is full. If it is full, the `PerformCmmand()` method returns `false`. Otherwise,
    we add `command` to our collection by calling the `Stack<T>.Push()` method. Then
    the method returns `true` to the caller. This operation has an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In case the caller has a script of commands that can be executed successively,
    our class includes the `PerformCommands(List<Command>)` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `PerformCommands()` method accepts a list of commands, and inserts them
    sequentially into our collection by calling `PerformCommand()`. This operation
    has an **O**(*n*) cost, where *n* is the number of elements in `commands`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `UndoCommand()` method provides the *pop* functionality of our class. It
    takes no parameters, but pops the last `Command` from our stack by calling `Stack<T>.Pop()`.
    The `Pop()` method removes the last `Command` from our `_commandStack` collection
    and returns it. If `_commandStack` is empty, `Pop()` returns a `null` object.
    This behavior actually works to our advantage, at least within the scope of this
    block of code. Since the `UndoCommand()` method is designed to return an instance
    of `Command`, we would be forced to return `null` anyway if `_commandStack` were
    empty. Therefore, it would be a waste of time to first check `IsEmpty()` before
    calling `Pop()`. This operation has an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The final pair of methods of our `CommandStack` class, `Reset()` and `TotalCommands()`,
    provide the *clear* functionality and the *count* functionality, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the prior implementation examples, Java also exposes a stack data
    structure through the `Stack<E>` class, which is an extension of `Vector<E>` including
    five methods that allow it to operate as a class. However, the Java documentation
    for `Stack<E>` recommends that you should use `Deque<E>` in favor of `Stack<E>`.
    However, since we will be evaluating `Queue<E>` and `Deque<E>` in [Chapter 5](part0033_split_000.html#VF2I1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 5. Queues: FIFO Collections"), *Queues: FIFO Collections*, we will use
    the `Stack<E>` class here. Here''s an example of what a simple implementation
    in Java might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our class declares three fields. The first is `_commandStack`, which represents
    our stack data structure and the core of this class. The field is private, but
    we also declare a publicly visible getter called `GetCommandStack()`. This is
    necessary because only methods within our class should be able to modify the collection.
    The second field is `_capacity`. This field maintains our caller-defined maximum
    number of commands in the collection. Finally, the constructor initializes `_commandStack`
    and assigns `commandCapacity` to `_capacity`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, we need to establish some validation for our collection at the outset.
    The first validation method, `isFull()`, checks if our stack has reached it's
    capacity. Since our business rules state that the robot must backtrack through
    all of it's commands before it can proceed to a new widget, we will track the
    number of commands that are being added into our collection. If for whatever reason
    we find that we have exceeded the pre-defined capacity for `_commandStack`, something
    has gone wrong during the previous backtracking operation and must be addressed.
    Therefore, we check that `_commandStack.size()` is greater than or equal to `_capacity`
    and return the value. `isEmpty()` is the next validation method. This method must
    be called prior to any operations that could attempt to read from our stack by
    *peeking* at the collection. Both of these operations have an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `performCommand(Command)` method provides the *push* functionality of our
    class. It accepts a single parameter of type `Command`, then checks if `_commandStack`
    is full. If it is full, `performCmmand()` returns `false`. Otherwise, we add `command`
    to our collection by calling the `Stack<t>.push()` method. Then the method returns
    `true` to the caller. This operation has an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In case the caller has a script of commands that can be executed successively
    then our class includes the `performCommands(List<Command>)` method as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `performCommands()` method accepts a list of commands, and inserts them
    sequentially into our collection by calling `performCommand()`. This operation
    has an **O**(*n*) cost, where *n* is the number of elements in `commands`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `undoCommand()` method provides the *pop* functionality of our class. It
    takes no parameters, but pops the last `Command` from our stack by calling `Stack<E>.pop()`.
    The `pop()` method removes the last `Command` from our `_commandStack` collection
    and returns it. If `_commandStack` is empty, `pop()` returns a `null` object.
    As with the C# example, this behavior works to our advantage within the scope
    of this block of code. Since the `undoCommand()` method is designed to return
    an instance of `Command`, we would be forced to return `null` anyway if `_commandStack`
    were empty. Therefore, it would be a waste of time to first check `isEmpty()`
    before calling `pop()`. This operation has an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The final two methods of our `CommandStack` class, `Reset()` and `TotalCommands()`,
    provide the *clear* and *count* functionalities respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen before (and probably will again before this text is through),
    Objective-C does not expose an explicit concrete implementation of the stack data
    structure, but instead provides the `NSMutableArray` class cluster for this purpose.
    Some could argue that this is a weakness in Objective-C, citing that by not providing
    methods for every conceivable operation that a developer could need is inconvenient.
    On the other hand, one could argue that Objective-C is much more powerful in its
    simplicity, providing the developer with a streamlined API and the basic components
    necessary to build whichever data structure he may require. I will leave you to
    come to your own conclusion on the matter. Meanwhile, here''s an example of what
    a simple implementation in Objective-C might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our class declares two **ivar** properties. The first is `_commandStack`, which
    represents our stack data structure and the core of this class. The property is
    private, but we also declare a publicly visible accessor called `commandStack`.
    This is necessary because only methods within our class should be able to modify
    the collection. The second property is `_capacity`. This property maintains our
    caller defined maximum number of commands in the collection. Finally, the constructor
    initializes `_commandStack` and assigns `commandCapacity` to `_capacity`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Again, we need to establish some validation for our collection at the outset.
    The first validation method, `isFull:`, checks if our stack has reached it's capacity.
    Since our business rules state that the robot must backtrack through all of it's
    commands before it can proceed to a new widget, we will track the number of commands
    that are being added into our collection. If for whatever reason we find that
    we have exceeded the pre-defined capacity for `_commandStack`, something has gone
    wrong during the previous backtracking operation and must be addressed. Therefore,
    we check that `[_commandStack count]` is greater than or equal to `_capacity`
    and return the value. `isEmpty:` is the next validation method. Both of these
    operations have an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Objective-C is quite forgiving about passing around `nil` objects, you
    may not even consider `isEmpty:` to be a validation method but more of a property
    in its own right. However, consider that, if this method were declared as a property,
    we would need to declare it as `readonly`, in addition to including the method
    in our implementation file. Otherwise, Objective-C would dynamically generate
    the ivar `_isEmpty` on our behalf, and callers could modify the value directly.
    For the sake of simplicity and clarity, in this case it's better to just declare
    the value as a method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `performCommand:` method provides the *push* functionality of our class.
    It accepts a single parameter of type `Command`, then checks if `_commandStack`
    is full. If it is full, `performCmmand:` returns `NO`. Otherwise, we add `command`
    to our collection by calling the `addObject:` method. Then the method returns
    `YES` to the caller. This operation has an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In case the caller has a script of commands that can be executed successively,
    our class includes the `performCommands:` class. `performCommands:` accepts an
    array of `EDSCommand` objects, and inserts them sequentially into our collection
    by calling `performCommand:`. This operation has an **O**(n) cost, where *n* is
    the number of elements in `commands`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `undoCommand:` method provides the *pop* functionality of our class. Since
    Objective-C does not provide a concrete implementation of the stack structure,
    our class needs to be somewhat creative here. This method grabs the top object
    from the stack by calling `lastObject`, then it removes the command from the collection
    by calling `removeLastObject`. Finally, it returns the `Command` object `c` to
    the caller. This series of calls effectively mimics the *pop* functionality found
    in the concrete stack implementations of C# and Java. Although the method has
    to jump through a hoop or two to get the job done, we are always working with
    the last object in the array so this operation still has an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the final pair of methods of our `CommandStack` class, `reset()`
    and `totalCommands()`, provide the *clear* functionality and the *count* functionality,
    respectively. Objective-C rules!
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Objective-C, Swift does not expose a concrete implementation of the stack
    data structure, but we can use the mutable, generic `Array` class for this purpose.
    Here''s an example of what a simple implementation in Swift might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our class declares two properties. The first is `_commandStack`, which represents
    our stack data structure and is again the core of this class. The property is
    publicly visible but can only be modified by the methods within our class. The
    second property is `_capacity`. This field maintains our caller defined maximum
    number of commands in the collection. Finally, the constructor initializes `_commandStack`
    and assigns `commandCapacity` to `_capacity`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As with the examples in other languages, we include two validation methods called
    `IsFull()` and `IsEmpty()`. The `IsFull()` method checks if our stack has reached
    it's capacity. Since our business rules state that the robot must backtrack through
    all of it's commands before it can proceed to a new widget, we will track the
    number of commands that are being added into our collection. If for whatever reason
    we find that we have exceeded the pre-defined capacity for `_commandStack`, something
    has gone wrong with the previous backtracking operation and must be addressed.
    Therefore, we check that `_commandStack.count` is greater than or equal to `_capacity`
    and return the value. `IsEmpty()` must be called prior to any operations that
    could attempt to read from our stack by *peeking* at the collection. Both of these
    operations have an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `PerformCommand(Command)` method provides the *push* functionality of our
    class. It accepts a single parameter of type `Command`, then checks if `_commandStack`
    is full. If it is full, the `PerformCmmand()` method returns `false`. Otherwise,
    we add `command` to our collection by calling the `Array.append()` method. Then
    the method returns `true` to the caller. This operation has an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In case the caller has a script of commands that can be executed successively
    our class includes the `PerformCommands(List<Command>)` class. `PerformCommands()`
    accepts a list of commands, and inserts them sequentially into our collection
    by calling the `PerformCommand()` method. This operation has an **O**(*n*) cost,
    where *n* is the number of elements in `commands`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `UndoCommand()` method provides the *pop* functionality of our class. It
    takes no parameters, but pops the last `Command` from our stack by calling `Array.popLast()!`
    with the forced unwrapping operator to access the value *wrapped* inside the `return`,
    assuming the object is not `nil`. The `popLast()` method removes the top `Command`
    from our `_commandStack` collection and returns it. If `_commandStack` is empty,
    `popLast()` returns `nil`. As seen in Java and Objective-C, this behavior works
    to our advantage within the scope of this block of code. Since the `UndoCommand()` method
    is designed to return an instance of `Command`, we would be forced to return `nil`
    anyway if `_commandStack` were empty. Therefore, it would be a waste of time to
    first check `IsEmpty()` before calling `popLast()`. This operation has an **O**(*1*)
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The final pair of methods of our `CommandStack` class, `Reset()` and `TotalCommands()`,
    provide the *clear* and *count* functionalities, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **nil coalescing operator**, or **null coalescing operator** as it is termed
    in other languages, is shorthand for the more verbose ternary operator and the
    explicit `if...else` statement. Languages such as C# and Swift designate `??`
    for this operator. Swift goes a step further by including the `!`, or unwrapping
    operator, for cases where a return value is optional, or potentially nil. The
    `??` operator in Swift is necessary for defining a default value when unwrapping
    an **optional** type.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics - stack implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how stacks are used in common practice, lets examine the
    different types of stack implementation you may encounter. The two most common
    implementations are the array-based stack and the linked list-based stack. We
    will examine each of these here.
  prefs: []
  type: TYPE_NORMAL
- en: Array-based stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array-based stack utilizes a mutable array to represent the collection.
    In this implementation, the 0 position in the array represents the *bottom* of
    the stack. Therefore, `array[0]` is the first object pushed onto the stack and
    the last one popped off. Array-based structures are not practical for a sorted
    stack as any reorganizing of the structure would require significantly more operational
    cost than that of a list-based stack. The Tower of Hanoi puzzle is the quintessential
    example of sorting am array-based stack, with an operational cost of **O**(*2^n*),
    where *n* is the number of plates on the starting tower. The Tower of Hanoi puzzle
    will be examined in more detail in [Chapter 12](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 12. Sorting: Bringing Order Out Of Chaos"), *Sorting: Bringing Order
    Out Of Chaos*.'
  prefs: []
  type: TYPE_NORMAL
- en: Linked list-based stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The linked list-based stack utilizes a pointer to the *bottom* object on the
    stack, and subsequent pointers as each new object is linked from the last object
    in the list. Popping an object from the top of the stack simply involves removing
    the last object from the collection. For applications requiring sorted data, a
    linked list stack is far more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned the basic definition of the Stack data structure,
    including how to initialize concrete implementations of the structure in each
    of the four languages we are discussing. Next, we discussed the most common operations
    associated with the stack data structure and their operational cost. We examined
    a case study using stacks to track commands passed to a robotic manufacturing
    device. These examples demonstrated how C# and Java provide concrete implementations
    of a stack whereas Objective-C and Swift do not. Finally, we examined the two
    most common types of stacks, the array-based and the linked-list-based, and showed
    how the array-based stack is not well suited for a sorted stack.
  prefs: []
  type: TYPE_NORMAL
