<html><head></head><body>
		<div>
			<div id="_idContainer375" class="Content">
			</div>
		</div>
		<div id="_idContainer376" class="Content">
			<h1 id="_idParaDest-338"><a id="_idTextAnchor353"/>12. Building a REST API</h1>
		</div>
		<div id="_idContainer386" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces <strong class="bold">REST APIs</strong> and <strong class="bold">Django REST Framework</strong> (<strong class="bold">DRF</strong>). You will start by implementing a simple API for the Bookr project. Next, you will learn about the serialization of model instances, which is a key step in delivering data to the frontend side of Django applications. You will explore different types of API views, including both functional and class-based types. By the end of this chapter, you will be able to implement custom API endpoints, including simple authentication.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor354"/>Introduction</h1>
			<p>In the previous chapter, we learned about templates and class-based views. These concepts greatly help expand the range of functionalities we can provide to the user on the frontend (that is, in their web browser). However, that is not sufficient to build a modern web application. Web apps typically have the frontend built with an entirely separate library, such as <strong class="bold">ReactJS</strong> or <strong class="bold">AngularJS</strong>. These libraries provide powerful tools for building dynamic user interfaces; however, they do not communicate directly with our backend Django code or database. The frontend code simply runs in the web browser and does not have direct access to any data on our backend server. Therefore, we need to create a way for these applications to "talk" to our backend code. One of the best ways to do this in Django is by using REST APIs.</p>
			<p><strong class="bold">API</strong> stands for <strong class="bold">Application Programming Interface</strong>. APIs are used to facilitate interaction between different pieces of software, and they communicate using <strong class="bold">HTTP</strong> (<strong class="bold">Hypertext Transfer Protocol</strong>). This is the standard protocol for communication between servers and clients and is fundamental to information transfer on the web. APIs receive requests and send responses in HTTP format.</p>
			<p>In our use case in this chapter, an API will help facilitate interaction between our Django backend, and our frontend JS code. For example, imagine that we want to create a frontend application that allows users to add new books to the Bookr database. The user's web browser would send a message (an HTTP request) to our API to say that they want to create an entry for a new book, and perhaps include some details about the book in that message. Our server would send back a response to report on whether the book was successfully added or not. The web browser would then be able to display to the user the outcome of their action.</p>
			<h1 id="_idParaDest-340"><a id="_idTextAnchor355"/>REST APIs</h1>
			<p><strong class="bold">REST</strong> stands for <strong class="bold">Representational State Transfer</strong>. Most modern web APIs can be classified as REST APIs. REST APIs are simply a type of API that focuses on communicating and synchronizing the <em class="italic">state</em> of objects between the database server and frontend client. </p>
			<p>For example, imagine that you are updating your details on a website for which you are signed into your account. When you go to the account details page, the web server tells your browser about the various details attached to your account. When you change the values on that page, the browser sends back the updated details to the web server and tells it to update these details on the database. If the action is successful, the website will show you a confirmation message.</p>
			<p>This is a very simple example of what is known as <strong class="bold">decoupled</strong> architecture between frontend and backend systems. Decoupling allows greater flexibility and makes it easier to update or change components in your architecture. So, let's say you want to create a new frontend website. In such a case, you don't have to change the backend code at all, as long as your new frontend is built to make the same API requests as the old one.</p>
			<p>REST APIs are <em class="italic">stateless</em>, which means that neither the client nor the server stores any states in-between to do the communication. Every time a request is made, the data is processed, and a response is sent back without having to store any intermediate data by the protocol itself. What this means is that the API is processing each request in isolation. It doesn't need to store information regarding the session itself. This is in contrast to a stateful protocol (such as <strong class="bold">TCP</strong>), which maintains information regarding the session during its life.</p>
			<p>So, a <strong class="bold">RESTful web service</strong>, as the name suggests, is a collection of REST APIs used to carry out a set of tasks. For example, if we develop a set of REST APIs for the Bookr application to carry out a certain set of tasks, then we can call it a RESTful web service.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor356"/>Django REST Framework</h2>
			<p><strong class="bold">Django REST Framework</strong>, also called <strong class="bold">DRF</strong> for short, is an open-source Python library that can be used to develop REST APIs for a Django project. DRF has most of the necessary functionality built in to help develop APIs for any Django project. Throughout this chapter, we will be using it to develop APIs for our Bookr project.</p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor357"/>Installation and Configuration</h2>
			<p>Install <strong class="source-inline">djangorestframework</strong> in the <strong class="source-inline">virtual env</strong> setup along with PyCharm. Enter the following code in your Terminal app or Command Prompt to do this:</p>
			<p class="source-code">pip install djangorestframework</p>
			<p>Next, open the <strong class="source-inline">settings.py</strong> file and add <strong class="source-inline">rest_framework</strong> to <strong class="source-inline">INSTALLED_APPS</strong> as shown in the following snippet:</p>
			<p class="source-code">INSTALLED_APPS = ['django.contrib.admin',\</p>
			<p class="source-code">                  'django.contrib.auth',\</p>
			<p class="source-code">                  ‹django.contrib.contenttypes›,\</p>
			<p class="source-code">                  'django.contrib.sessions',\</p>
			<p class="source-code">                  'django.contrib.messages',\</p>
			<p class="source-code">                  'django.contrib.staticfiles',\</p>
			<p class="source-code">                  <strong class="bold">‹rest_framework›</strong>,\</p>
			<p class="source-code">                  ‹reviews›]</p>
			<p>You are now ready to start using DRF to create your first simple API.</p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor358"/>Functional API Views</h2>
			<p>In <em class="italic">Chapter 3</em>, <em class="italic">URL Mapping, Views, and Templates</em>, we learned about simple functional views that take a request and return a response. We can write similar functional views using DRF. However, note that class-based views are more commonly used, and will be covered next. A functional view is created by simply adding the following decorator onto a normal view, as follows:</p>
			<p class="source-code">from rest_framework.decorators import api_view</p>
			<p class="source-code">@api_view</p>
			<p class="source-code">def my_view(request):</p>
			<p class="source-code">     ...</p>
			<p>This decorator takes the functional view and turns it into a subclass of the DRF <strong class="source-inline">APIView</strong>. It's a quick way to include an existing view as part of your API.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor359"/>Exercise 12.01: Creating a Simple REST API</h2>
			<p>In this exercise, you will create your first REST API using DRF and implement an endpoint using a functional view. You will create this endpoint to view the total number of books in the database:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You'll need to have DRF installed on your system to proceed with this exercise. If you haven't already installed it, make sure you refer to the section titled <em class="italic">Installation and Configuration</em> earlier in this chapter.</p>
			<ol>
				<li>Create <strong class="source-inline">api_views.py</strong> in the <strong class="source-inline">bookr/reviews</strong> folder.<p>REST API views work like Django's conventional views. We could have added the API views, along with the other views, in the <strong class="source-inline">views.py</strong> folder. However, having our REST API views in a separate file will help us maintain a cleaner code base. </p></li>
				<li>Add the following code in <strong class="source-inline">api_views.py</strong>:<p class="source-code">from rest_framework.decorators import api_view</p><p class="source-code">from rest_framework.response import Response</p><p class="source-code">from .models import Book</p><p class="source-code">@api_view()</p><p class="source-code">def first_api_view(request):</p><p class="source-code">    num_books = Book.objects.count()</p><p class="source-code">    <strong class="bold">return Response({"num_books": num_books})</strong></p><p>The first line imports the <strong class="source-inline">api_view</strong> decorator, which will be used to convert our functional view into one that can be used with DRF, and the second line imports <strong class="source-inline">Response</strong>, which will be used to return a response.</p><p>The <strong class="source-inline">view</strong> function returns a <strong class="source-inline">Response</strong> object containing a dictionary with the number of books in our database (see the highlighted part).</p><p>Open <strong class="source-inline">bookr/reviews/urls.py</strong> and import the <strong class="source-inline">api_views</strong> module. Then, add a new path to the <strong class="source-inline">api_views</strong> module in the URL patterns that we have developed throughout this course, as follows:</p><p class="source-code">from . import views, api_views</p><p class="source-code">urlpatterns = [path('api/first_api_view/)',\</p><p class="source-code">               path(api_views.first_api_view)</p><p class="source-code">    …</p><p class="source-code">]</p><p>Start the Django service with the <strong class="source-inline">python manage.py runserver</strong> command and go to <strong class="source-inline">http://0.0.0.0:8000/api/first_api_view/</strong> to make your first API request. Your screen should appear as in <em class="italic">Figure 12.1</em>:</p><div id="_idContainer377" class="IMG---Figure"><img src="image/B15509_12_01.jpg" alt="Figure 12.1: API view with the number of books&#13;&#10;"/></div><p class="figure-caption">Figure 12.1: API view with the number of books</p><p>Calling this URL endpoint made a default <strong class="source-inline">GET</strong> request to the API endpoint, which returned a JSON key-value pair <strong class="source-inline">("num_books": 0</strong>). Also, notice how DRF provides a nice interface to view and interact with the APIs.</p></li>
				<li>We could also use the Linux <strong class="source-inline">curl</strong> (client URL) command to send an HTTP request as follows:<p class="source-code">curl http://0.0.0.0:8000/api/first_api_view/</p><p class="source-code">{"num_books":0}</p><p>Alternatively, if you are using Windows 10, you can make an equivalent HTTP request with <strong class="source-inline">curl.exe</strong> from Command Prompt as follows:</p><p class="source-code">curl.exe http://0.0.0.0:8000/api/first_api_view/</p></li>
			</ol>
			<p>In this exercise, we learned how to create an API view using DRF and a simple functional view. We will now look at a more elegant way to convert between information stored in the database and what gets returned by our API using serializers.</p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor360"/>Serializers</h1>
			<p>By now, we are well versed in the way Django works with data in our application. Broadly, the columns of a database table are defined in a class in <strong class="source-inline">models.py</strong>, and when we access a row of the table, we are working with an instance of that class. Ideally, we often just want to pass this object to our frontend application. For example, if we wanted to build a website that displayed a list of books in our Bookr app, we would want to call the <strong class="source-inline">title</strong> property of each book instance to know what string to display to the user. However, our frontend application knows nothing about Python and needs to retrieve this data through an HTTP request, which just returns a string in a specific format.</p>
			<p>This means that any information translated between Django and the frontend (via our API) must be done by representing the information in <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) format. JSON objects look similar to a Python dictionary, except there are some extra rules that constrict the exact syntax. In our previous example in <em class="italic">Exercise 12.01</em>, <em class="italic">Creating a Simple REST API</em>, the API returned the following JSON object containing the number of books in our database:</p>
			<p class="source-code">{"num_books": 0}</p>
			<p>But what if we wanted to return the full details about an actual book in our database with our API? DRF's <strong class="source-inline">serializer</strong> class helps to convert complex Python objects into formats such as JSON or XML so that they can be transmitted across the web using the HTTP protocol. The part of DRF that does this conversion is named <strong class="source-inline">serializer</strong>. Serializers also perform deserialization, which refers to converting serialized data back into Python objects, so that the data can be processed in the application. </p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor361"/>Exercise 12.02: Creating an API View to Display a List of Books</h2>
			<p>In this exercise, you will use serializers to create an API that returns a list of all books present in the <strong class="source-inline">bookr</strong> application:</p>
			<ol>
				<li value="1">Create a file named <strong class="source-inline">serializers.py</strong> in the <strong class="source-inline">bookr/reviews</strong> folder. This is the file where we will place all the serializer code for the APIs.</li>
				<li>Add the following code to <strong class="source-inline">serializers.py</strong>:<p class="source-code">from rest_framework import serializers</p><p class="source-code">class PublisherSerializer(serializers.Serializer):</p><p class="source-code">    name = serializers.CharField()</p><p class="source-code">    website = serializers.URLField()</p><p class="source-code">    email = serializers.EmailField()</p><p class="source-code">class BookSerializer(serializers.Serializer):</p><p class="source-code">    title = serializers.CharField()</p><p class="source-code">    publication_date = serializers.DateField()</p><p class="source-code">    isbn = serializers.CharField()</p><p class="source-code">    publisher = PublisherSerializer()</p><p>Here, the first line imports the serializers from the <strong class="source-inline">rest_framework</strong> module. </p><p>Following the imports, we have defined two classes, <strong class="source-inline">PublisherSerializer</strong> and <strong class="source-inline">BookSerializer</strong>. As the names suggest, they are serializers for the <strong class="source-inline">Publisher</strong> and <strong class="source-inline">Book</strong> models respectively. Both these serializers are subclasses of <strong class="source-inline">serializers.Serializer</strong> and we have defined field types for each serializer such as <strong class="source-inline">CharField</strong>, <strong class="source-inline">URLField</strong>, and <strong class="source-inline">EmailField</strong>, and so on.</p><p>Look at the <strong class="source-inline">Publisher</strong> model in the <strong class="source-inline">bookr/reviews/models.py</strong> file. The <strong class="source-inline">Publisher</strong> model has <strong class="source-inline">name</strong>, <strong class="source-inline">website</strong>, and <strong class="source-inline">email</strong> attributes. So, to serialize a <strong class="source-inline">Publisher</strong> object, we need <strong class="source-inline">name</strong>, <strong class="source-inline">website</strong>, and <strong class="source-inline">email</strong> attributes in the <strong class="source-inline">serializer</strong> class, which we have defined accordingly in <strong class="source-inline">PublisherSerializer</strong>.  Similarly, for the <strong class="source-inline">Book</strong> model, we have defined <strong class="source-inline">title</strong>, <strong class="source-inline">publication_date</strong>, <strong class="source-inline">isbn</strong>, and <strong class="source-inline">publisher</strong> as the desired attributes in <strong class="source-inline">BookSerializer</strong>. Since <strong class="source-inline">publisher</strong> is a foreign key for the <strong class="source-inline">Book</strong> model, we have used <strong class="source-inline">PublisherSerializer</strong> as the serializer for the <strong class="source-inline">publisher</strong> attribute.</p></li>
				<li>Open <strong class="source-inline">bookr/reviews/api_views.py</strong>, remove any pre-existing code, and add the following code:<p class="source-code">from rest_framework.decorators import api_view</p><p class="source-code">from rest_framework.response import Response</p><p class="source-code">from .models import Book</p><p class="source-code">from .serializers import BookSerializer</p><p class="source-code">@api_view()</p><p class="source-code">def all_books(request):</p><p class="source-code">    books = Book.objects.all()</p><p class="source-code">    book_serializer = BookSerializer(books, many=True)</p><p class="source-code">    return Response(book_serializer.data)</p><p>In the second line, we have imported the newly created <strong class="source-inline">BookSerializer</strong> from the <strong class="source-inline">serializers</strong> module. </p><p>We then add a functional view, <strong class="source-inline">all_books</strong> (as in the previous exercise). This view takes a query set containing all books and then serializes them using <strong class="source-inline">BookSerializer</strong>. T<a id="_idTextAnchor362"/>he <strong class="source-inline">serializer</strong> class is also taking an argument, <strong class="source-inline">many=True</strong>, which indicates that the <strong class="source-inline">books</strong> object is a <strong class="source-inline">queryset</strong> or a list of many objects. Remember that serialization takes Python objects and returns them in a JSON serializable format, as follows:</p><p class="source-code">[OrderedDict([('title', 'Advanced Deep Learning with Keras'), ('publication_date', '2018-10-31'), ('isbn', '9781788629416'), ('publisher', OrderedDict([('name', 'Packt Publishing'), ('website', 'https://www.packtpub.com/'), ('email', 'info@packtpub.com')]))]), OrderedDict([('title', 'Hands-On Machine Learning for Algorithmic Trading'), ('publication_date', '2018-12-31'), ('isbn', '9781789346411'), ('publisher', OrderedDict([('name', 'Packt Publishing'), ('website', 'https://www.packtpub.com/'), ('email', 'info@packtpub.com')]))]) …</p></li>
				<li>Open <strong class="source-inline">bookr/reviews/urls.py</strong>, remove the previous example path for <strong class="source-inline">first_api_view</strong>, and add the <strong class="source-inline">all_books</strong> path as shown in the following code:<p class="source-code">from django.urls import path</p><p class="source-code">from . import views, api_views</p><p class="source-code">urlpatterns = [path('api/all_books/'),\</p><p class="source-code">               path(api_views.all_books),\</p><p class="source-code">               path(name='all_books')</p><p class="source-code">    …</p><p class="source-code">]</p><p>This newly added path calls the view function <strong class="source-inline">all_books</strong> when it comes across the <strong class="source-inline">api/all_books/</strong> path in the URL.</p></li>
				<li>Once all the code is added, run the Django server with the <strong class="source-inline">python manage.py runserver</strong> command and navigate to <strong class="source-inline">http://0.0.0.0:8000/api/all_books/</strong>. You should see something similar to <em class="italic">Figure 12.2</em>:<div id="_idContainer378" class="IMG---Figure"><img src="image/B15509_12_02.jpg" alt="Figure 12.2: List of books shown in the all_books endpoint&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.2: List of books shown in the all_books endpoint</p>
			<p>The preceding screenshot shows that the list of all books is returned upon calling the <strong class="source-inline">/api/all_books</strong> endpoint. And with that, you have successfully used a serializer to return data efficiently in your database, with the help of a REST API. </p>
			<p>Till now, we have been focusing on functional views. However, you will now learn that class-based views are more commonly used in DRF and will make your life much easier.</p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor363"/>Class-Based API Views and Generic Views</h2>
			<p>Similar to what we learned in <em class="italic">Chapter 11</em>, <em class="italic">Advanced Templating and Class-Based Views</em>, we can write class-based views for REST APIs as well. Class-based views are the most preferred way for writing views among developers as a lot can be achieved by writing very little code. </p>
			<p>Just as with conventional views, DRF offers a set of generic views that makes writing class-based views even simpler. Generic views are designed keeping in mind some of the most common operations needed while creating APIs. Some of the generic views offered by DRF are <strong class="source-inline">ListAPIView</strong>, <strong class="source-inline">RetrieveAPIView</strong>, and so on. In <em class="italic">Exercise 12.02</em>, <em class="italic">Creating an API View to Display a List of Books</em>, our functional view was responsible for creating a <strong class="source-inline">queryset</strong> of the objects and then calling the serializer. Equivalently, we could use <strong class="source-inline">ListAPIView</strong> to do the same thing:</p>
			<p class="source-code">class AllBooks(ListAPIView):</p>
			<p class="source-code">    queryset = Book.objects.all()</p>
			<p class="source-code">    serializer_class = BookSerializer</p>
			<p>Here, the <strong class="source-inline">queryset</strong> of objects is defined as a class attribute. Passing the <strong class="source-inline">queryset</strong> through to the <strong class="source-inline">serializer</strong> is handled by methods on <strong class="source-inline">ListAPIView</strong>. </p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor364"/>Model Serializers</h2>
			<p>In <em class="italic">Exercise 12.02</em>, <em class="italic">Creating an API View to Display a List of Books</em>, our serializer was defined as follows:</p>
			<p class="source-code">class BookSerializer(serializers.Serializer):</p>
			<p class="source-code">    title = serializers.CharField()</p>
			<p class="source-code">    publication_date = serializers.DateField()</p>
			<p class="source-code">    isbn = serializers.CharField()</p>
			<p class="source-code">    publisher = PublisherSerializer()</p>
			<p>However, our model for <strong class="source-inline">Book</strong> looks like this (note how similar the definitions of the model and serializer appear to be):</p>
			<p class="source-code">class Book(models.Model):</p>
			<p class="source-code">    """A published book."""</p>
			<p class="source-code">    title = models.CharField(max_length=70),\</p>
			<p class="source-code">                            (help_text="The title of the book.")</p>
			<p class="source-code">    publication_date = models.DateField\</p>
			<p class="source-code">                      (verbose_name="Date the book was published.")</p>
			<p class="source-code">    isbn = models.CharField(max_length=20),\</p>
			<p class="source-code">                           (verbose_name="ISBN number of the book.")</p>
			<p class="source-code">    publisher = models.ForeignKey(Publisher),\</p>
			<p class="source-code">                                 (on_delete=models.CASCADE)</p>
			<p class="source-code">    contributors = models.ManyToManyField('Contributor'),\</p>
			<p class="source-code">                                         (through="BookContributor")</p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return self.title</p>
			<p>We would prefer not to specify that the title must be <strong class="source-inline">serializers.CharField()</strong>. It would be easier if the serializer just looked at how <strong class="source-inline">title</strong> was defined in the model and could figure out what serializer field to use.</p>
			<p>This is where model serializers come in. They provide shortcuts to create serializers by utilizing the definition of the fields on the model. Instead of specifying that <strong class="source-inline">title</strong> should be serialized using a <strong class="source-inline">CharField</strong>, we just tell the model serializer we want to include the <strong class="source-inline">title</strong>, and it uses the <strong class="source-inline">CharField</strong> serializer because the <strong class="source-inline">title</strong> field on the model is also a <strong class="source-inline">CharField</strong>.  </p>
			<p>For example, suppose we wanted to create a serializer for the <strong class="source-inline">Contributor</strong> model in <strong class="source-inline">models.py</strong>. Instead of specifying the types of serializers that should be used for each field, we can give it a list of the field names, and let it figure out the rest:</p>
			<p class="source-code">from rest_framework import serializers</p>
			<p class="source-code">from .models import Contributor</p>
			<p class="source-code">class ContributorSerializer(serializers.ModelSerializer):</p>
			<p class="source-code">    class Meta:</p>
			<p class="source-code">        model = Contributor</p>
			<p class="source-code">        fields = ['first_names', 'last_names', 'email']</p>
			<p>In the following exercise, we will see how we can use a model serializer to avoid the duplication of code in the preceding classes.</p>
			<h2 id="_idParaDest-349">E<a id="_idTextAnchor365"/>xercise 12.03: Creating Class-Based API Views and Model Serializers</h2>
			<p>In this exercise, you will create class-based views to display a list of all books while using model serializers:</p>
			<ol>
				<li value="1">Open the file <strong class="source-inline">bookr/reviews/serializers.py</strong>, remove any pre-existing code, and replace it with the following code:<p class="source-code">from rest_framework import serializers</p><p class="source-code">from .models import Book, Publisher</p><p class="source-code">class PublisherSerializer(serializers.ModelSerializer):</p><p class="source-code">    class Meta:</p><p class="source-code">        model = Publisher</p><p class="source-code">        fields = ['name', 'website', 'email']</p><p class="source-code">class BookSerializer(serializers.ModelSerializer):</p><p class="source-code">    publisher = PublisherSerializer()</p><p class="source-code">    class Meta:</p><p class="source-code">        model = Book</p><p class="source-code">        fields = ['title', 'publication_date', 'isbn', 'publisher']</p><p>Here, we have included two model serializer classes, <strong class="source-inline">PublisherSerializer</strong> and <strong class="source-inline">BookSerializer</strong>. Both these classes inherit the parent class <strong class="source-inline">serializers.ModelSerializer</strong>. We do not need to specify how each field gets serialized, instead, we can simply pass a list of field names, and the field types are inferred from the definition in <strong class="source-inline">models.py</strong>.</p><p>Although mentioning the field inside <strong class="source-inline">fields</strong> is sufficient for the model serializer, under certain special cases, such as this one, we may have to customize the field since the <strong class="source-inline">publisher</strong> field is a foreign key. Hence, we must use <strong class="source-inline">PublisherSerializer</strong> to serialize the <strong class="source-inline">publisher</strong> field.</p></li>
				<li>Next, open <strong class="source-inline">bookr/reviews/api_views.py</strong>, remove any pre-existing code, and add the following code:<p class="source-code">from rest_framework import generics</p><p class="source-code">from .models import Book</p><p class="source-code">from .serializers import BookSerializer</p><p class="source-code">class AllBooks(generics.ListAPIView):</p><p class="source-code">    queryset = Book.objects.all()</p><p class="source-code">    serializer_class = BookSerializer</p><p>Here, we use the DRF class-based <strong class="source-inline">ListAPIView</strong> instead of a functional view. This means that the list of books is defined as a class attribute, and we do not have to write a function that directly handles the request and calls the serializer. The book serializer from the previous step is also imported and assigned as an attribute of this class.</p><p>Open the <strong class="source-inline">bookr/reviews/urls.py</strong> file and modify the <strong class="source-inline">/api/all_books</strong> API path to include the new class-based view as follows:</p><p class="source-code">urlpatterns = [path('api/all_books/'),\</p><p class="source-code">               path(api_views.AllBooks.as_view()),\</p><p class="source-code">               path(name='all_books')]</p><p>Since we are using a class-based view, we have to use the class name along with the <strong class="source-inline">as_view()</strong> method.</p></li>
				<li>Once all the preceding modifications are completed, wait till the Django service restarts or start the server with the <strong class="source-inline">python manage.py runserver</strong> command, and then open the API at <strong class="source-inline">http://0.0.0.0:8000/api/all_books/</strong> in the web browser. You should see something like <em class="italic">Figure 12.3</em>:<p> </p><div id="_idContainer379" class="IMG---Figure"><img src="image/B15509_12_03.jpg" alt="Figure 12.3: List of books shown in the all_books endpoint&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.3: List of books shown in the all_books endpoint</p>
			<p>Like what we saw in <em class="italic">Exercise 12.02</em>, <em class="italic">Creating an API View to Display a List of Books</em>, this is a list of all books present in the book review application. In this exercise, we used model serializers to simplify our code, and the generic class-based <strong class="source-inline">ListAPIView</strong> to return a list of the books in our database.</p>
			<h2 id="_idParaDest-350">Act<a id="_idTextAnchor366"/>ivity 12.01: Creating an API Endpoint for a Top Contributors Page</h2>
			<p>Imagine that your team decides to create a web page that displays the top contributors (that is, authors, coauthors, and editors) in your database. They decide to enlist the services of an external developer to create an app in React JavaScript. To integrate with the Django backend, the developer will need an endpoint that provides the following:</p>
			<ul>
				<li>A list of all contributors in the database</li>
				<li>For each contributor, a list of all books they contributed to</li>
				<li>For each contributor, the number of books they contributed to</li>
				<li>For each book they contributed to, their role in the book</li>
			</ul>
			<p>The final API view should look like this:</p>
			<p> </p>
			<div>
				<div id="_idContainer380" class="IMG---Figure">
					<img src="image/B15509_12_04.jpg" alt="Figure 12.4: Top contributors endpoint &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.4: Top contributors endpoint </p>
			<p>To perform this task, execute the following steps:</p>
			<ol>
				<li value="1">Add a method to the <strong class="source-inline">Contributor</strong> class that returns the number of contributions made.</li>
				<li>Add <strong class="source-inline">ContributionSerializer</strong>, which serializes the <strong class="source-inline">BookContribution</strong> model.</li>
				<li>Add <strong class="source-inline">ContributorSerializer</strong>, which serializes the <strong class="source-inline">Contributor</strong> model.</li>
				<li>Add <strong class="source-inline">ContributorView</strong>, which uses <strong class="source-inline">ContributorSerializer</strong>.</li>
				<li>Add a pattern to <strong class="source-inline">urls.py</strong> to enable access to <strong class="source-inline">ContributorView</strong>.<p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-351"><a id="_idTextAnchor367"/>ViewSets</h1>
			<p>We have seen how we can optimize our code and make it more concise using class-based generic views. <strong class="bold">Viewsets</strong> and <strong class="bold">Routers</strong> help us further simplify our code. As the name indicates, viewsets are a set of views represented in a single class. For example, we used the <strong class="source-inline">AllBooks</strong> view to return a list of all books in the application and the <strong class="source-inline">BookDetail</strong> view to return the details of a single book. Using viewsets, we could combine both these classes into a single class. </p>
			<p>DRF also provides a class named <strong class="source-inline">ModelViewSet</strong>. This class not only combines the two views mentioned in the preceding discussion (that is, list and detail) but also allows you to create, update, and delete model instances. The code needed to implement all this functionality could be as simple as specifying the serializer and <strong class="source-inline">queryset</strong>. For example, a view that allows you to manage all these actions for your user model could be defined as tersely as the following:</p>
			<p class="source-code">class UserViewSet(viewsets.ModelViewSet):</p>
			<p class="source-code">    serializer_class = UserSerializer</p>
			<p class="source-code">    queryset = User</p>
			<p>Lastly, DRF provides a <strong class="source-inline">ReadOnlyModelViewSet</strong> class. This is a simpler version of the preceding <strong class="source-inline">ModelViewSet</strong>. It is identical, except that it only allows you to list and retrieve specific users. You cannot create, update, or delete records.</p>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor368"/>Routers</h1>
			<p>Routers, when used along with a viewset, take care of automatically creating the required URL endpoints for the viewset. This is because a single viewset is accessed at different URLs. For example, in the preceding <strong class="source-inline">UserViewSet</strong>, you would access a list of users at the URL <strong class="source-inline">/api/users/</strong>, and a specific user record at the URL <strong class="source-inline">/api/users/123</strong>, where <strong class="source-inline">123</strong> is the primary key of that user record. Here is a simple example of how you might use a router in the context of the previously defined <strong class="source-inline">UserViewSet</strong>:</p>
			<p class="source-code">from rest_framework import routers</p>
			<p class="source-code">router = routers.SimpleRouter()</p>
			<p class="source-code">router.register(r'users', UserViewSet)</p>
			<p class="source-code">urlpatterns = router.urls</p>
			<p>Now, let's try to combine the concepts of routers and viewsets in a simple exercise.</p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor369"/>Exercise 12.04: Using ViewSets and Routers</h2>
			<p>In this exercise, we will combine the existing views to create a viewset and create the required routing for the viewset:</p>
			<ol>
				<li value="1">Open the file <strong class="source-inline">bookr/reviews/serializers.py</strong>, remove the pre-existing code, and add the following code snippet:<p class="source-code-heading">reviews/serializers.py</p><p class="source-code">01  from django.contrib.auth.models import User</p><p class="source-code">02  from django.utils import timezone</p><p class="source-code">03  from rest_framework import serializers</p><p class="source-code">04  from rest_framework.exceptions import NotAuthenticated, PermissionDenied</p><p class="source-code">05</p><p class="source-code">06  from .models import Book, Publisher, Review</p><p class="source-code">07  from .utils import average_rating</p><p class="source-code">08</p><p class="source-code">09  class PublisherSerializer(serializers.ModelSerializer):</p><p class="source-code-link">You can find the complete code snippet at <a href="http://packt.live/3osYJli">http://packt.live/3osYJli</a>.</p><p>Here, we added two new fields to <strong class="source-inline">BookSerializer</strong>, namely <strong class="source-inline">reviews</strong> and <strong class="source-inline">rating</strong>. The interesting thing about these fields is that the logic behind them is defined as a method on the serializer itself. This is why we use the <strong class="source-inline">serializers.SerializerMethodField</strong> type to set the <strong class="source-inline">serializer</strong> class attributes.</p></li>
				<li>Open the file <strong class="source-inline">bookr/reviews/api_views.py</strong>, remove the pre-existing code, and add the following:<p class="source-code">from rest_framework import viewsets</p><p class="source-code">from rest_framework.pagination import LimitOffsetPagination</p><p class="source-code">from .models import Book, Review</p><p class="source-code">from .serializers import BookSerializer, ReviewSerializer</p><p class="source-code">class BookViewSet(viewsets.ReadOnlyModelViewSet):</p><p class="source-code">    queryset = Book.objects.all()</p><p class="source-code">    serializer_class = BookSerializer</p><p class="source-code">class ReviewViewSet(viewsets.ModelViewSet):</p><p class="source-code">    queryset = Review.objects.order_by('-date_created')</p><p class="source-code">    serializer_class = ReviewSerializer</p><p class="source-code">    pagination_class = LimitOffsetPagination</p><p class="source-code">    authentication_classes = []</p><p>Here, we have removed the <strong class="source-inline">AllBook</strong> and the <strong class="source-inline">BookDetail</strong> views and replaced them with <strong class="source-inline">BookViewSet</strong> and <strong class="source-inline">ReviewViewSet</strong>. In the first line, we import the <strong class="source-inline">ViewSets</strong> module from <strong class="source-inline">rest_framework</strong>. The <strong class="source-inline">BookViewSet</strong> class is a subclass of <strong class="source-inline">ReadOnlyModelViewSet</strong>, which ensures that the views are used for the <strong class="source-inline">GET</strong> operation only.</p><p>Next, open the <strong class="source-inline">bookr/reviews/urls.py</strong> file, remove the first two URL patterns starting with <strong class="source-inline">api/</strong>, and then add the following (highlighted) code:</p><p class="source-code"><strong class="bold">from django.urls import path, include</strong></p><p class="source-code"><strong class="bold">from rest_framework.routers import DefaultRouter</strong></p><p class="source-code"><strong class="bold">from . import views, api_views</strong></p><p class="source-code"><strong class="bold">router = DefaultRouter()</strong></p><p class="source-code"><strong class="bold">router.register(r'books', api_views.BookViewSet)</strong></p><p class="source-code"><strong class="bold">router.register(r'reviews', api_views.ReviewViewSet)</strong></p><p class="source-code"><strong class="bold">urlpatterns = [path('api/', include((router.urls, 'api'))),\</strong></p><p class="source-code">               path('books/', views.book_list, \</p><p class="source-code">                    name='book_list'),</p><p class="source-code">               path('books/&lt;int:pk&gt;/', views.book_detail, \</p><p class="source-code">                    name='book_detail'),</p><p class="source-code">               path('books/&lt;int:book_pk&gt;/reviews/new/', \</p><p class="source-code">                    views.review_edit, name='review_create'),</p><p class="source-code">               path('books/&lt;int:book_pk&gt;/reviews/&lt;int:review_pk&gt;/', \</p><p class="source-code">                    views.review_edit, name='review_edit'),</p><p class="source-code">               path('books/&lt;int:pk&gt;/media/', views.book_media, \</p><p class="source-code">                    name='book_media'),</p><p class="source-code">               path('publishers/&lt;int:pk&gt;/', views.publisher_edit, \</p><p class="source-code">                    name='publisher_detail'),</p><p class="source-code">               path('publishers/new/', views.publisher_edit, \</p><p class="source-code">                    name='publisher_create')]</p><p>Here, we have combined the <strong class="source-inline">all_books</strong> and <strong class="source-inline">book_detail</strong> paths into a single path called <strong class="source-inline">books</strong>.  We have also added a new endpoint under the path <strong class="source-inline">reviews</strong> which we will need in a later chapter.</p><p>We start by importing the <strong class="source-inline">DefaultRouter</strong> class from <strong class="source-inline">rest_framework.routers</strong>. Then, we create a <strong class="source-inline">router</strong> object using the <strong class="source-inline">DefaultRouter</strong> class and then register the newly created <strong class="source-inline">BookViewSet</strong> and <strong class="source-inline">ReviewViewSet</strong>, as can be seen from the highlighted code. This ensures that the <strong class="source-inline">BookViewSet</strong> is invoked whenever the API has the <strong class="source-inline">/api/books</strong> path.</p></li>
				<li>Save all the files, and once the Django service restarts (or you start it manually with the <strong class="source-inline">python manage.py runserver</strong> command), go to the URL <strong class="source-inline">http://0.0.0.0:8000/api/books/</strong> to get a list of all the books. You should see the following view in the API explorer:<div id="_idContainer381" class="IMG---Figure"><img src="image/B15509_12_05.jpg" alt="Figure 12.5: Book list at the path /api/books&#13;&#10;"/></div><p class="figure-caption">Figure 12.5: Book list at the path /api/books</p></li>
				<li>You can also access the details for a specific book using the URL <strong class="source-inline">http://0.0.0.0:8000/api/books/1/</strong>. In this case, it will return details for the book with a primary key of <strong class="source-inline">1</strong> (if it exists in your database):<p> </p><div id="_idContainer382" class="IMG---Figure"><img src="image/B15509_12_06.jpg" alt="Figure 12.6: Book details for &quot;Advanced Deep Learning with Keras&quot;&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.6: Book details for "Advanced Deep Learning with Keras"</p>
			<p>In this exercise, we saw how we can use viewsets and routers to combine the list and detail views into a single viewset. Using viewsets will make our code more consistent and idiomatic, making it easier to collaborate with other developers. This becomes particularly important when integrating with a separate frontend application.</p>
			<h1 id="_idParaDest-354"><a id="_idTextAnchor370"/>Authentication</h1>
			<p>As we learned in <em class="italic">Chapter 9</em>, <em class="italic">Sessions and Authentication</em>, it is important to authenticate the users of our application. It is good practice to only allow those users who have registered in the application to log in and access information from the application. Similarly, for REST APIs too, we need to design a way to authenticate and authorize users before any information is passed on. For example, suppose Facebook's website makes an API request to get a list of all comments for a post. If they did not have authentication on this endpoint, you could use it to programmatically get comments for any post you want. They obviously don't want to allow this, so some sort of authentication needs to be implemented.</p>
			<p>There are different authentication schemes, such as <strong class="bold">Basic Authentication</strong>, <strong class="bold">Session Authentication</strong>, <strong class="bold">Token Authentication</strong>, <strong class="bold">Remote User Authentication</strong>, and various third-party authentication solutions. For the scope of this chapter, and for our Bookr application, we will use <strong class="bold">Token Authentication</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For further reading on all the authentication schemes, please refer to the official documentation at <a href="https://www.django-rest-framework.org/api-guide/authentication">https://www.django-rest-framework.org/api-guide/authentication</a>.</p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor371"/>Token-Based Authentication</h2>
			<p>Token-based authentication works by generating a unique token for a user in exchange for the user's username and password. Once the token is generated, it will be stored in the database for further reference and will be returned to the user upon every login. </p>
			<p>This token is unique for a user and the user can then use this token to authorize every API request they make. Token-based authentication eliminates the need to pass the username and password on every request. It is much safer and is best suited to client-server communication, such as a JavaScript-based web client interacting with the backend application via REST APIs.</p>
			<p>An example of this would be a ReactJS or AngularJS application interacting with a Django backend via REST APIs. </p>
			<p>The same architecture can be used if you are developing a mobile application to interact with the backend server via REST APIs, for instance, an Android or iOS application interacting with a Django backend via REST APIs.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor372"/>Exercise 12.05: Implementing Token-Based Authentication for Bookr APIs</h2>
			<p>In this exercise, you will implement token-based authentication for the <strong class="source-inline">bookr</strong> application's APIs:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">bookr/settings.py</strong> file and add <strong class="source-inline">rest_framework.authtoken</strong> to <strong class="source-inline">INSTALLED_APPS</strong>:<p class="source-code">INSTALLED_APPS = ['django.contrib.admin',\</p><p class="source-code">                  'django.contrib.auth',\</p><p class="source-code">                  ‹django.contrib.contenttypes›,\</p><p class="source-code">                  'django.contrib.sessions',\</p><p class="source-code">                  'django.contrib.messages',\</p><p class="source-code">                  'django.contrib.staticfiles',\</p><p class="source-code">                  ‹rest_framework›,\</p><p class="source-code">                  <strong class="bold">‹rest_framework.authtoken›</strong>,\</p><p class="source-code">                  ‹reviews›]</p></li>
				<li>Since the <strong class="source-inline">authtoken</strong> app has associated database changes, run the <strong class="source-inline">migrate</strong> command in the command line/terminal as follows:<p class="source-code">python manage.py migrate</p></li>
				<li>Open the <strong class="source-inline">bookr/reviews/api_views.py</strong> file, remove any pre-existing code, and replace it with the following:<p class="source-code-heading">/reviews/api_views.py</p><p class="source-code">from django.contrib.auth import authenticate</p><p class="source-code">from rest_framework import viewsets</p><p class="source-code">from rest_framework.authentication import TokenAuthentication</p><p class="source-code">from rest_framework.authtoken.models import Token</p><p class="source-code">from rest_framework.pagination import LimitOffsetPagination</p><p class="source-code">from rest_framework.permissions import IsAuthenticated</p><p class="source-code">from rest_framework.response import Response</p><p class="source-code">from rest_framework.status import HTTP_404_NOT_FOUND, HTTP_200_OK</p><p class="source-code">from rest_framework.views import APIView</p><p class="source-code-link">You can find the complete code for this file at <a href="http://packt.live/2JQebbS">http://packt.live/2JQebbS</a>.</p><p>Here, we have defined a view called <strong class="source-inline">Login</strong>. The purpose of this view is to allow a user to get (or create if it does not already exist) a token that they can use to authenticate with the API. </p><p>We override the <strong class="source-inline">post</strong> method of this view because we want to customize the behavior when a user sends us data (that is, their login details). First, we use the <strong class="source-inline">authenticate</strong> method from Django's <strong class="source-inline">auth</strong> library to check whether the username and password are correct. If they are correct, then we will have a <strong class="source-inline">user</strong> object. If not, we return an <strong class="source-inline">HTTP 404</strong> error. If we do have a valid <strong class="source-inline">user</strong> object, then we simply get or create a token, and return it to the user.</p></li>
				<li>Next, let's add the authentication class to our <strong class="source-inline">BookViewSet</strong>. This means that when a user tries to access this viewset, it will require them to authenticate using token-based authentication. Note that it's possible to include a list of different accepted authentication methods, not just one. We also add the <strong class="source-inline">permissions_classes</strong> attribute, which just uses DRF's built-in class that checks to see if the given user has permission to view the data in this model:<p class="source-code">class <a id="_idTextAnchor373"/>BookViewSet(viewsets.ReadOnlyModelViewSet):</p><p class="source-code">    queryset = Book.objects.all()</p><p class="source-code">    serializer_class = BookSerializer</p><p class="source-code">    <strong class="bold">authentication_classes = [TokenAuthentication]</strong></p><p class="source-code"><strong class="bold">    permission_classes = [IsAuthenticated]</strong></p><p class="callout-heading">Note</p><p class="callout">The preceding code (highlighted) won't match the code you see on GitHub as we'll be modifying it later in <em class="italic">step 9</em></p></li>
				<li>Open <strong class="source-inline">bookr/reviews/urls.py</strong> file and add the following path into url patterns.<p class="source-code">path('api/login', api_views.Login.as_view(), name='login')</p></li>
				<li>Save the file and wait for the application to restart, or start the server manually with the <strong class="source-inline">python manage.py runserver</strong> command. Then access the application using the URL <strong class="source-inline">http://0.0.0.0:8000/api/login</strong>. Your screen should appear as follows:<div id="_idContainer383" class="IMG---Figure"><img src="image/B15509_12_07.jpg" alt="Figure 12.7: Login page&#13;&#10;"/></div><p class="figure-caption">Figure 12.7: Login page</p><p>The API at <strong class="source-inline">/api/login</strong> is a <strong class="source-inline">POST</strong> only message, hence <strong class="source-inline">Method GET not allowed</strong> is displayed.</p></li>
				<li>Next, enter the following snippet in the content and click on <strong class="source-inline">POST</strong>:<p class="source-code">{</p><p class="source-code">"username": "Peter",</p><p class="source-code">"password": "testuserpassword"</p><p class="source-code">}</p><p>You will need to replace this with an actual username and password for your account in the database. Now you can see the token generated for the user. This is the token we need to use to access <strong class="source-inline">BookSerializer</strong>:</p><div id="_idContainer384" class="IMG---Figure"><img src="image/B15509_12_08.jpg" alt="Figure 12.8: Token generated for the user&#13;&#10;"/></div><p class="figure-caption">Figure 12.8: Token generated for the user</p></li>
				<li>Try to access the list of books using the API that we previously created at <strong class="source-inline">http://0.0.0.0:8000/api/books/</strong>. Note that you are now not allowed to access it. This is because this viewset now requires you to use your token to authenticate.<p>The same API can be accessed using <strong class="source-inline">curl</strong> on the command line: </p><p class="source-code">curl -X GET http://0.0.0.0:8000/api/books/</p><p class="source-code">{"detail":"Authentication credentials were not provided."}</p><p>Since the token was not provided, the message <strong class="source-inline">Authentication credentials were not provided</strong> is displayed:</p><div id="_idContainer385" class="IMG---Figure"><img src="image/B15509_12_09.jpg" alt="Figure 12.9: Message saying that the authentication details weren't provided&#13;&#10;"/></div><p class="figure-caption">Figure 12.9: Message saying that the authentication details weren't provided</p><p>Note that if you're using Windows 10, replace <strong class="source-inline">curl</strong> in the preceding command with <strong class="source-inline">curl.exe</strong> and execute it from Command Prompt.</p><p>To pass the <strong class="source-inline">Authorization</strong> token (obtained in <em class="italic">step 7</em>) as a header, you can use the following command (Windows users can replace <strong class="source-inline">curl</strong> with <strong class="source-inline">curl.exe</strong>):</p><p class="source-code">curl -X GET http://0.0.0.0:8000/api/books/ -H "Authorization: Token 724865fcaff6d0aace359620a12ec0b5cc6524fl"</p><p class="callout-heading">Note</p><p class="callout">Before pasting this command, make sure you've replaced the token (highlighted) with the one you got when you ran <em class="italic">step 7 </em>of this exercise. It will be different from the one we have shown here.</p><p>The preceding command should now return the list of books: </p><p class="source-code"> [{"title":"Advanced Deep Learning with Keras","publication_date":"2018-10-31","isbn":"9781788629416","publisher":{"name":"Packt Publishing","website":"https://www.packtpub.com/","email":"info@packtpub.com"},"rating":4,"reviews":[{"content":"A must read for all","date_created":… (truncated)</p><p>This operation ensured that only an existing user of the application can access and fetch the collection of all books.</p></li>
				<li>Before moving on, set the authentication and permission classes on <strong class="source-inline">BookViewSet</strong> to an empty string. Future chapters will not utilize these authentication methods, and we will assume for sake of simplicity that our API can be accessed by an unauthenticated user.<p class="source-code">class BookViewSet(viewsets.ReadOnlyModelViewSet):</p><p class="source-code">    queryset = Book.objects.all()</p><p class="source-code">    serializer_class = BookSerializer</p><p class="source-code">    authentication_classes = []</p><p class="source-code">    permission_classes = []</p></li>
			</ol>
			<p>In this exercise, we implemented token-based authentication in our Bookr app. We created a login view that allows us to retrieve the token for a given authenticated user. This then enabled us to make API requests from the command line by passing through the token as a header in the request.</p>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor374"/>Summary</h1>
			<p>This chapter introduced REST APIs, a fundamental building block in most real-world web applications. These APIs facilitate communication between the backend server and the web browser, so they are central to your growth as a Django web developer. We learned how to serialize data in our database so that it can be transmitted via an HTTP request. We also learned the various options DRF gives us to simplify the code we write, taking advantage of the existing definitions of the models themselves. We also covered viewsets and routers, and saw how they can be used to condense code even further by combining the functionality of multiple views. We also learned about authentication and authorization and implemented token-based authentication for the book review app. In the next chapter, we will extend Bookr's functionality for its users by learning how to generate CSVs, PDFs, and other binary filetypes.</p>
		</div>
	</body></html>