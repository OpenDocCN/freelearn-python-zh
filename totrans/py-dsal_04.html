<html><head></head><body>
        

            
                <h1 class="header-title">Lists and Pointer Structures</h1>
            

            
                
<p>You will have already seen lists in Python. They are convenient and powerful. Normally, any time you need to store something in a list, you use python's built-in list implementation. In this chapter, however, we are more interested in understanding how lists work. So we are going to study list internals. As you will notice, there are different types of lists.</p>
<p>Python's list implementation is designed to be powerful and to encompass several different use cases. We are going to be a bit more strict in our definition of what a list is.</p>
<p>The concept of a node is very important to lists. We shall discuss them in this chapter, but this concept will, in different forms, come back throughout the rest of the book.</p>
<p>The focus of this chapter will be the following:</p>
<ul>
<li>Understand pointers in Python</li>
<li>Treating the concept of nodes</li>
<li>Implementing singly, doubly, and circularly linked lists</li>
</ul>
<p>In this chapter, we are going to deal quite a bit with pointers. So it may be useful to remind ourselves what these are. To begin with, imagine that you have a house that you want to sell. Lacking time, you contact an agent to find interested buyers. So you pick up your house and take it over to the agent, who will in turn carry the house to anybody who may want to buy it. Ludicrous, you say? Now imagine that you have a few Python functions that work with images. So you pass high-resolution image data between your functions.</p>
<p>Of course, you don't carry your house around. What you would do is write the address of the house down on a piece of scrap paper and hand it over to the agent. The house remains where it is, but the note containing the directions to the house is passed around. You might even write it down on several pieces of paper. Each one is small enough to fit in your wallet, but they all point to the same house.</p>
<p>As it turns out, things are not very different in Python land. Those large image files remain in one single place in memory. What you do is create variables that hold the locations of those images in memory. These variables are small and can easily be passed around between different functions.</p>
<p>That is the big benefit of pointers: they allow you to point to a potentially large segment of memory with just a simple memory address.</p>
<p>Support for pointers exists in your computer's hardware, where it is known as indirect addressing.</p>
<p>In Python, you don't manipulate pointers directly, unlike in some other languages, such as C or Pascal. This has led some people to think that pointers aren't used in Python. Nothing could be further from the truth. Consider this assignment in the Python interactive shell:</p>
<pre>
    <strong>&gt;&gt;&gt; s = set()</strong>
</pre>
<p>We would normally say that <kbd>s</kbd> is a variable of the type set. That is, <kbd>s</kbd> is a set. This is not strictly true, however. The variable <kbd>s</kbd> is rather a reference (a "safe" pointer) to a set. The set constructor creates a set somewhere in memory and returns the memory location where that set starts. This is what gets stored in <kbd>s</kbd>.</p>
<p>Python hides this complexity from us. We can safely assume that <kbd>s</kbd> is a set and that everything works fine.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Arrays</h1>
            

            
                
<p>An array is a sequential list of data. Being sequential means that each element is stored right after the previous one in memory. If your array is really big and you are low on memory, it could be impossible to find large enough storage to fit your entire array. This will lead to problems.</p>
<p>Of course, the flip side of the coin is that arrays are very fast. Since each element follows from the previous one in memory, there is no need to jump around between different memory locations. This can be a very important point to take into consideration when choosing between a list and an array in your own real-world applications.</p>
<p>In the latter parts of <a href="ee04d80f-97b1-4a1b-b61f-8a830c0b78c5.xhtml">Chapter 2</a>, <em>Python Data Types and Structures</em>, we looked at the array data type and discovered the various operations that could be performed on it.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Pointer structures</h1>
            

            
                
<p>Contrary to arrays, pointer structures are lists of items that can be spread out in memory. This is because each item contains one or more links to other items in the structure. What type of links these are dependent on the type of structure we have. If we are dealing with linked lists, then we will have links to the next (and possibly previous) items in the structure. In the case of a tree, we have parent-child links as well as sibling links. In a tile-based game where the game map is built up of hexes, each node will have links to up to six adjacent map cells.</p>
<p>There are several benefits with pointer structures. First of all, they don't require sequential storage space. Second, they can start small and grow arbitrarily as you add more nodes to the structure.</p>
<p>As noted in <a href="ee04d80f-97b1-4a1b-b61f-8a830c0b78c5.xhtml">Chapter 2</a>, <em>Python Data Types and Structures</em>, however, this comes at a cost. If you have a list of integers, each node is going to take up the space of an integer, as well as an additional integer for storing the pointer to the next node.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Nodes</h1>
            

            
                
<p>At the heart of lists (and several other data structures) is the concept of a node. Before we go any further, let us consider this idea for a while.</p>
<p>To begin with, we shall create a few strings:</p>
<pre>
<strong>&gt;&gt;&gt; a = "eggs"</strong><br/><strong>&gt;&gt;&gt; b = "ham"</strong><br/><strong>&gt;&gt;&gt; c = "spam"</strong>
</pre>
<p>Now you have three variables, each with a unique name, a type, and a value. What we do not have is a way of saying in which way the variables relate to each other. Nodes allow us to do this. A node is a container of data, together with one or more links to other nodes. A link is a pointer.</p>
<p>A simple type of node is one that only has a link to the next node.</p>
<p>Of course, knowing what we do about pointers, we realize that this is not entirely true. The string is not really stored in the node, but is rather a pointer to the actual string:</p>
<div><img class="image-border" height="172" src="img/image_04_001.jpg" width="241"/></div>
<p>Thus the storage requirement for this simple node is two memory addresses. The data attribute of the nodes are pointers to the strings <kbd>eggs</kbd> and <kbd>ham</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Finding endpoints</h1>
            

            
                
<p>We have created three nodes: one containing <strong>eggs</strong>, one <strong>ham</strong>, and another <strong>spam</strong>. The <strong>eggs</strong> node points to the <strong>ham</strong> node, which in turn points to the <strong>spam</strong> node. But what does the <strong>spam</strong> node point to? Since this is the last element in the list, we need to make sure its next member has a value that makes this clear.</p>
<p>If we make the last element point to nothing then we make this fact clear. In python, we will use the special value <kbd>None</kbd> to denote nothing:</p>
<div><img class="image-border" height="124" src="img/image_04_007.jpg" width="365"/></div>
<p>The last node has its next point pointing to None. As such it is the last node in the chain of nodes.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Node</h1>
            

            
                
<p>Here is a simple node implementation of what we have discussed so far:</p>
<pre>
    class Node: <br/>        def __init__(self, data=None): <br/>            self.data = data <br/>            self.next = None 
</pre>
<p>Do not confuse the concept of a node with Node.js, a server-side technology implemented in JavaScript.</p>
<p>The <kbd>next</kbd> pointer is initialized to <kbd>None</kbd>, meaning that unless you change the value of <kbd>next</kbd>, the node is going to be an end-point. This is a good idea, so that we do not forget to terminate the list properly.</p>
<p>You can add other things to the <kbd>node</kbd> class as you see fit. Just make sure that you keep in mind the distinction between node and data. If your node is going to contain customer data, then create a <kbd>Customer</kbd> class and put all the data there.</p>
<p>One thing you may want to do is implement the <kbd>__str__</kbd> method so that it calls the <kbd>__str__</kbd> method of the contained object is called when the node object is passed to print:</p>
<pre>
    def __str__(self): <br/>        return str(data) 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Other node types</h1>
            

            
                
<p>We have assumed nodes that have a pointer to the next node. This is probably the simplest type of node. However, depending on our requirements, we can create a number of other types of nodes.</p>
<p>Sometimes we want to go from A to B, but at the same time from B to A. In that case, we add a previous pointer in addition to the next pointer:</p>
<div><img class="image-border" height="125" src="img/image_04_003.jpg" width="368"/></div>
<p>As you can see from the figure, we let both the last and the first nodes point to <kbd>None</kbd>, to indicate that we have reached they form the boundary of our list end-point. The first node’s previous pointer points to None since it has no predecessor, just as the last item’s next pointer points to <kbd>None</kbd> because it no successor node.</p>
<p>You might also be creating tiles for a tile-based game. In such a case, instead of previous and next, you might use north, south, east, and west. There are more types of pointers, but the principle is the same. Tiles at the end of the map will point to <kbd>None</kbd>:</p>
<div><img class="image-border" height="322" src="img/image_04_004.jpg" width="481"/></div>
<p>You can take this as far as you need to. If you need to be able to move north-west, north-east, south-east, and south-west as well, all you have to do is add these pointers to your <kbd>node</kbd> class.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Singly linked lists</h1>
            

            
                
<p>A singly linked list is a list with only one pointer between two successive nodes. It can only be traversed in a single direction, that is, you can go from the first node in the list to the last node, but you cannot move from the last node to the first node.</p>
<p>We can actually use the <kbd>node</kbd> class that we created earlier to implement a very simple singly linked list:</p>
<pre>
    <strong>&gt;&gt;&gt; n1 = Node('eggs')<br/>    &gt;&gt;&gt; n2 = Node('ham')<br/>    &gt;&gt;&gt; n3 = Node('spam')</strong>
</pre>
<p>Next we link the nodes together so that they form a <em>chain</em>:</p>
<pre>
    <strong>&gt;&gt;&gt; n1.next = n2<br/>    &gt;&gt;&gt; n2.next = n3</strong>
</pre>
<p>To traverse the list, you could do something like the following. We start by setting the variable <kbd>current</kbd> to the first item in the list:</p>
<pre>
    current = n1<br/>    while current:<br/>        print(current.data)<br/>        current = current.next 
</pre>
<p>In the loop we print out the current element after which we set current to point to the next element in the list. We keep doing this until we have reached the end of the list.</p>
<p>There are, however, several problems with this simplistic list implementation:</p>
<ul>
<li>It requires too much manual work by the programmer</li>
<li>It is too error-prone (this is a consequence of the first point)</li>
<li>Too much of the inner workings of the list is exposed to the programmer</li>
</ul>
<p>We are going to address all these issues in the following sections.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Singly linked list class</h1>
            

            
                
<p>A list is clearly a separate concept from a node. So we start by creating a very simple class to hold our list. We will start with a constructor that holds a reference to the very first node in the list. Since this list is initially empty, we will start by setting this reference to <kbd>None</kbd>:</p>
<pre>
    class SinglyLinkedList:<br/>         def __init__(self):<br/>             self.tail = None 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Append operation</h1>
            

            
                
<p>The first operation that we need to perform is to append items to the list. This operation is sometimes called an insert operation. Here we get a chance to hide away the <kbd>Node</kbd> class. The user of our <kbd>list</kbd> class should really never have to interact with Node objects. These are purely for internal use.</p>
<p>A first shot at an <kbd>append()</kbd> method may look like this:</p>
<pre>
    class SinglyLinkedList:<br/>         # ...<br/><br/>         def append(self, data):<br/>             # Encapsulate the data in a Node<br/>             node = Node(data)<br/><br/>             if self.tail == None:<br/>                 self.tail = node<br/>             else:<br/>                 current = self.tail<br/>                 while current.next:<br/>                     current = current.next<br/>                 current.next = node 
</pre>
<p>We encapsulate data in a node, so that it now has the next pointer attribute. From here we check if there are any existing nodes in the list (that is, does <kbd>self.tail</kbd> point to a Node). If there is none, we make the new node the first node of the list; otherwise, find the insertion point by traversing the list to the last node, updating the next pointer of the last node to the new node.</p>
<p>We can append a few items:</p>
<pre>
<strong>&gt;&gt;&gt; words = SinglyLinkedList()<br/> &gt;&gt;&gt; words.append('egg')<br/> &gt;&gt;&gt; words.append('ham')<br/> &gt;&gt;&gt; words.append('spam')</strong>
</pre>
<p>List traversal will work more or less like before. You will get the first element of the list from the list itself:</p>
<pre>
<strong>&gt;&gt;&gt; current = words.tail<br/>&gt;&gt;&gt; while current:<br/>        print(current.data) <br/>        current = current.next</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">A faster append operation</h1>
            

            
                
<p>There is a big problem with the append method in the previous section: it has to traverse the entire list to find the insertion point. This may not be a problem when there are just a few items in the list, but wait until you need to add thousands of items. Each append will be slightly slower than the previous one. A <strong>O</strong>(n) goes to prove how slow our current implementation of the <kbd>append</kbd> method will actually be.</p>
<p>To fix this, we will store, not only a reference to the first node in the list, but also a reference to the last node. That way, we can quickly append a new node at the end of the list. The worst case running time of the append operation is now reduced from <strong>O</strong>(n) to <strong>O</strong>(1). All we have to do is make sure the previous last node points to the new node, that is about to be appended to the list. Here is our updated code:</p>
<pre>
    class SinglyLinkedList:<br/>         def __init__(self): <br/>             # ...<br/>             self.tail = None<br/><br/>         def append(self, data):<br/>            node = Node(data)<br/>            if self.head:<br/>                self.head.next = node<br/>                self.head = node<br/>            else:<br/>                self.tail = node<br/>                self.head = node 
</pre>
<div><p>Take note of the convention being used. The point at which we append new nodes is through <kbd>self.head</kbd>. The <kbd>self.tail</kbd> variable points to the first node in the list.</p>
</div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting the size of the list</h1>
            

            
                
<p>We would like to be able to get the size of the list by counting the number of nodes. One way we could do this is by traversing the entire list and increasing a counter as we go along:</p>
<pre>
    def size(self):<br/>         count = 0<br/>         current = self.tail<br/>         while current:<br/>             count += 1<br/>             current = current.next<br/>         return count 
</pre>
<p>This works, but list traversal is potentially an expensive operation that we should avoid when we can. So instead, we shall opt for another rewrite of the method. We add a size member to the <kbd>SinglyLinkedList</kbd> class, initializing it to 0 in the constructor. Then we increment size by one in the <kbd>append</kbd> method:</p>
<pre>
class SinglyLinkedList:<br/>     def __init__(self):<br/>         # ...<br/>         self.size = 0<br/><br/>     def append(self, data):<br/>         # ...<br/>         self.size += 1 
</pre>
<p class="NormalPACKT">Because we are now only reading the size attribute of the node object, and not using a loop to count the number of nodes in the list, we get to reduce the worst case running time from <strong>O</strong>(n) to <strong>O</strong>(1).</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Improving list traversal</h1>
            

            
                
<p>If you notice how we traverse our list. That one place where we are still exposed to the <kbd>node</kbd> class. We need to use <kbd>node.data</kbd> to get the contents of the node and <kbd>node.next</kbd> to get the next node. But we mentioned earlier that client code should never need to interact with Node objects. We can achieve this by creating a method that returns a generator. It looks as follows:</p>
<pre>
    def iter(self):<br/>        current = self.tail<br/>        while current:<br/>            val = current.data<br/>            current = current.next<br/>            yield val  
</pre>
<p>Now list traversal is much simpler and looks a lot better as well. We can completely ignore the fact that there is anything called a Node outside of the list:</p>
<pre>
    for word in words.iter():<br/>        print(word) 
</pre>
<p>Notice that since the <kbd>iter()</kbd> method yields the data member of the node, our client code doesn't need to worry about that at all.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Deleting nodes</h1>
            

            
                
<p>Another common operation that you would need to be able to do on a list is to delete nodes. This may seem simple, but we'd first have to decide how to select a node for deletion. Is it going to be by an index number or by the data the node contains? Here we will choose to delete a node by the data it contains.</p>
<p>The following is a figure of a special case considered when deleting a node from the list:</p>
<div><img class="image-border" height="535" src="img/image_04_005.jpg" width="483"/></div>
<p>When we want to delete a node that is between two other nodes, all we have to do is make the previous node directly to the successor of its next node. That is, we simply cut the node to be deleted out of the chain as in the preceding image.</p>
<p>Here is the implementation of the <kbd>delete()</kbd> method may look like:</p>
<pre>
    def delete(self, data):<br/>        current = self.tail<br/>        prev = self.tail<br/>        while current:<br/>            if current.data == data:<br/>                if current == self.tail:<br/>                    self.tail = current.next<br/>                else:<br/>                    prev.next = current.next<br/>                self.size -= 1<br/>                return<br/>            prev = current<br/>            current = current.next 
</pre>
<p> It should take a <strong>O</strong>(n) to delete a node.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">List search</h1>
            

            
                
<p>We may also need a way to check whether a list contains an item. This method is fairly easy to implement thanks to the <kbd>iter()</kbd> method we previously wrote. Each pass of the loop compares the current data to the data being searched for. If a match is found, <kbd>True</kbd> is returned, or else <kbd>False</kbd> is returned:</p>
<pre>
def search(self, data):<br/>     for node in self.iter():<br/>         if data == node:<br/>             return True<br/>     return False  
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Clearing a list</h1>
            

            
                
<p>We may want a quick way to clear a list. Fortunately for us, this is very simple. All we do is clear the pointers <kbd>head</kbd> and <kbd>tail</kbd> by setting them to <kbd>None</kbd>:</p>
<pre>
def clear(self): <br/>       """ Clear the entire list. """ <br/>       self.tail = None <br/>       self.head = None 
</pre>
<p>In one fell swoop, we orphan all the nodes at the <kbd>tail</kbd> and <kbd>head</kbd> pointers of the list. This has a ripple effect of orphaning all the nodes in between.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Doubly linked lists</h1>
            

            
                
<p>Now that we have a solid grounding on what a singly linked list is and the kind of operations that can be performed on it, we shall now turn our focus one notch higher to the topic of doubly linked lists.</p>
<p>A doubly linked list is somehow similar to a singly linked list in that we make use of the same fundamental idea of stringing nodes together. In a Singly linked list, there exists one link between each successive node. A node in a doubly linked list has two pointers: a pointer to the next node and a pointer to the previous node:</p>
<div><img class="image-border" height="126" src="img/image_04_006.jpg" width="261"/></div>
<p>A node in a singly linked list can only determine the next node associated with it. But the referenced node or next node has no way of telling who is doing the referencing. The flow of direction is <strong>only one way</strong>.</p>
<p>In a doubly linked list, we add to each node the ability to not only reference the next node but also the previous node.</p>
<p>Let's examine the nature of the linkages that exist between two successive nodes for better understanding:</p>
<div><img class="image-border" height="128" src="img/image_04_007.jpg" width="377"/></div>
<p>With the existence of two pointers that point to the next and previous nodes, doubly linked lists become equipped with certain capabilities.</p>
<p>Doubly linked lists can be traversed in any direction. Depending on the operation being performed, a node within a doubly linked list can easily refer to its previous node where necessary without having to designate a variable to keep track of that node. Because a Singly linked list can only be traversed in one direction it may sometimes mean moving to the start or beginning of the list in order to effect certain changes buried within the list.</p>
<p>Since there is immediate access to both next and previous nodes, deletion operations are much easier to perform, as you will see later on in this chapter.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">A doubly linked list node</h1>
            

            
                
<p>The Python code that creates a class to capture what a doubly linked list node is includes in its initializing method, the <kbd>prev</kbd>, <kbd>next</kbd>, and <kbd>data</kbd> instance variables. When a node is newly created, all these variables default to <kbd>None</kbd>:</p>
<pre>
    class Node(object): <br/>        def __init__(self, data=None, next=None, prev=None): <br/>           self.data = data <br/>           self.next = next <br/>           self.prev = prev 
</pre>
<p>The <kbd>prev</kbd> variable holds a reference to the previous node, while the <kbd>next</kbd> variable continues to hold a reference to the next node.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Doubly linked list</h1>
            

            
                
<p>It is still important to create a class that captures the data that our functions will be operating on:</p>
<pre>
    class DoublyLinkedList(object):<br/>       def __init__(self):<br/>           self.head = None<br/>           self.tail = None<br/>           self.count = 0
</pre>
<p>For the purposes of enhancing the <kbd>size</kbd> method, we also set the <kbd>count</kbd> instance variable to 0. <kbd>head</kbd> and <kbd>tail</kbd> will point to the head and tail of the list when we begin to insert nodes into the list.</p>
<div><p>We adopt a new convention where <kbd>self.head</kbd> points to the beginner node of the list and <kbd>self.tail</kbd> points to the latest node added to the list. This is contrary to the convention we used in the singly linked list. There are no fixed rules as to the naming of the head and tail node pointers.</p>
</div>
<p>Doubly linked lists also need to provide functions that return the size of the list, inserts into the list, and also deletes nodes from the list. We will be examining some of the code to do this. Let's commence with the <kbd>append</kbd> operation.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Append operation</h1>
            

            
                
<p>During an <kbd>append</kbd> operation, it is important to check whether the <kbd>head</kbd> is <kbd>None</kbd>. If it is <kbd>None</kbd>, it means that the list is empty and should have the <kbd>head</kbd> set pointing to the just-created node. The <kbd>tail</kbd> of the list is also pointed at the new node through the head. By the end of these series of steps, <kbd>head</kbd> and <kbd>tail</kbd> will now be pointing to the same node:</p>
<pre>
    def append(self, data): <br/>        """ Append an item to the list. """ <br/><br/>           new_node = Node(data, None, None) <br/>           if self.head is None: <br/>               self.head = new_node <br/>               self.tail = self.head <br/>           else: <br/>               new_node.prev = self.tail <br/>               self.tail.next = new_node <br/>               self.tail = new_node <br/><br/>               self.count += 1 
</pre>
<p>The following diagram illustrates the head and tail pointers of the doubly linked list when a new node is added to an empty list.</p>
<div><img class="aligncenter size-full wp-image-1088 image-border" height="291" src="img/04_01.jpg" width="339"/></div>
<p>The <kbd>else</kbd> part of the algorithm is only executed if the list is not empty. The new node's previous variable is set to the tail of the list:</p>
<pre>
    new_node.prev = self.tail 
</pre>
<p>The tail's next pointer (or variable) is set to the new node:</p>
<pre>
    self.tail.next = new_node 
</pre>
<p>Lastly, we update the tail pointer to point to the new node:</p>
<pre>
    self.tail = new_node 
</pre>
<p>Since an <kbd>append</kbd> operation increases the number of nodes by one, we increase the counter by one:</p>
<pre>
    self.count += 1 
</pre>
<p>A visual representation of the <kbd>append</kbd> operation is as follows:</p>
<div><img class="image-border" height="221" src="img/image_04_009.jpg" width="410"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Delete operation</h1>
            

            
                
<p>Unlike the singly linked list, where we needed to keep track of the previously encountered node anytime we traversed the whole length of the list, the doubly linked list avoids that whole step. This is made possible by the use of the previous pointer. </p>
<p>The algorithm for removing nodes from a doubly linked list caters for basically four scenarios before deletion of a node is completed. These are:</p>
<ul>
<li>When the search item is not found at all</li>
<li>When the search item is found at the very beginning of the list</li>
<li>When the search item is found at the tail end of the list</li>
<li>When the search item is found somewhere in the middle of the list</li>
</ul>
<p>The node to be removed is identified when its <kbd>data</kbd> instance variable matches the data that is passed to the method to be used in the search for the node. If a matching node is found and subsequently removed, the variable <kbd>node_deleted</kbd> is set to <kbd>True</kbd>. Any other outcome results in <kbd>node_deleted</kbd> being set to <kbd>False</kbd>:</p>
<pre>
    def delete(self, data): <br/>        current = self.head <br/>        node_deleted = False <br/>        ...    
</pre>
<p>In the <kbd>delete</kbd> method, the <kbd>current</kbd> variable is set to the head of the list (that is, it points to the <kbd>self.head</kbd> of the list). A set of <kbd>if... else</kbd> statements are then used to search the various parts of the list to find the node with the specified data.</p>
<p>The <kbd>head</kbd> node is searched first. Since <kbd>current</kbd> is pointing at <kbd>head</kbd>, if <kbd>current</kbd> is None, it is presumed that the list has no nodes for a search to even begin to find the node to be removed:</p>
<pre>
    if current is None: <br/>        node_deleted = False     
</pre>
<p>However, if <kbd>current</kbd> (which now points to head) contains the very data being searched for, then <kbd>self.head</kbd> is set to point to the <kbd>current</kbd> next node. Since there is no node behind head now, <kbd>self.head.prev</kbd> is set to <kbd>None</kbd>:</p>
<pre>
    elif current.data == data: <br/>        self.head = current.next <br/>        self.head.prev = None <br/>        node_deleted = True 
</pre>
<p>A similar strategy is adopted if the node to be removed is located at the tail end of the list. This is the third statement that searches for the possibility that the node to be removed might be located at the end of the list:</p>
<pre>
    elif self.tail.data == data: <br/>        self.tail = self.tail.prev <br/>        self.tail.next = None <br/>        node_deleted = True 
</pre>
<p>Lastly, the algorithm to find and remove a node loops through the list of nodes. If a matching node is found, <kbd>current</kbd>'s previous node is connected to current's next node. After that step, <kbd>current</kbd>'s next node is connected to previous node of <kbd>current</kbd>:</p>
<pre>
else<br/>    while current: <br/>        if current.data == data: <br/>            current.prev.next = current.next <br/>            current.next.prev = current.prev <br/>            node_deleted = True <br/>        current = current.next 
</pre>
<p>The <kbd>node_delete</kbd> variable is then checked after all the <kbd>if-else</kbd> statements has been evaluated. If any of the <kbd>if-else</kbd> statements changed this variable, then it means a node has been deleted from the list. The count variable is therefore decremented by 1:</p>
<pre>
    if node_deleted: <br/>        self.count -= 1 
</pre>
<p>As an example of deleting a node that is buried within a list, assume the existence of three nodes, A, B, and C. To delete node B in the middle of the list, we will essentially make A point to C as its next node, while making C point to A as its previous node:</p>
<div><img class="image-border" height="250" src="img/image_04_010.jpg" width="433"/></div>
<p>After such an operation, we end up with the following list:</p>
<div><img class="image-border" height="153" src="img/image_04_011.jpg" width="450"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">List search</h1>
            

            
                
<p>The search algorithm is similar to that of the <kbd>search</kbd> method in a singly linked list. We call the internal method <kbd>iter()</kbd> to return the data in all the nodes. As we loop through the data, each is matched against the data passed into the <kbd>contain</kbd> method. If there is a match, we return <kbd>True</kbd>, or else we return <kbd>False</kbd> to symbolize that no match was found:</p>
<pre>
    def contain(self, data): <br/>        for node_data in self.iter(): <br/>            if data == node_data: <br/>                return True <br/>            return False 
</pre>
<p class="NormalPACKT">Our doubly linked list has a <strong>O</strong>(1) for the <kbd>append</kbd> operation and <strong>O</strong>(n) for the <kbd>delete</kbd> operation.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Circular lists</h1>
            

            
                
<p>A circular list is a special case of a linked list. It is a list where the endpoints are connected. That is, the last node in the list points back to the first node. Circular lists can be based on both singly and doubly linked lists. In the case of a doubly linked circular list, the first node also needs to point to the last node.</p>
<p>Here we are going to look at an implementation of a singly linked circular list. It should be straightforward to implement a doubly linked circular list, once you have grasped the basic concepts.</p>
<p>We can reuse the <kbd>node</kbd> class that we created in the section on singly linked lists. As a matter of fact, we can reuse most parts of the <kbd>SinglyLinkedList</kbd> class as well. So we are going to focus on the methods where the circular list implementation differs from the normal singly linked list.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Appending elements</h1>
            

            
                
<p>When we append an element to the circular list, we need to make sure that the new node points back to the tail node. This is demonstrated in the following code. There is one extra line as compared to the singly linked list implementation:</p>
<pre>
     def append(self, data): <br/>           node = Node(data) <br/>           if self.head: <br/>               self.head.next = node <br/>               self.head = node <br/>           else: <br/>               self.head = node <br/>               self.tail = node <br/>           self.head.next = self.tail <br/>           self.size += 1 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Deleting an element</h1>
            

            
                
<p>We may think that we can follow the same principle as for append and simply make sure the head points to the tail. This would give us the following implementation:</p>
<pre>
   def delete(self, data): <br/>       current = self.tail <br/>       prev = self.tail <br/>       while current: <br/>           if current.data == data: <br/>               if current == self.tail: <br/>                   self.tail = current.next <br/>                   self.head.next = self.tail <br/>               else: <br/>                   prev.next = current.next <br/>               self.size -= 1 <br/>               return <br/>           prev = current <br/>           current = current.next 
</pre>
<p>As previously, there is just a single line that needs to change. It is only when we remove the tail node that we need to make sure that the head node is updated to point to the new tail node.</p>
<p>However, there is a serious problem with this code. In the case of a circular list, we cannot loop until current becomes <kbd>None</kbd>, since that will never happen. If you delete an existing node, you wouldn't see this, but try deleting a nonexistent node and you will get stuck in an indefinite loop.</p>
<p>We thus need to find a different way to control the <kbd>while</kbd> loop. We cannot check whether current has reached head, because then it will never check the last node. But we could use <kbd>prev</kbd>, since it lags behind current by one node. There is a special case, however. The very first loop iteration, <kbd>current</kbd> and <kbd>prev</kbd>, will point to the same node, namely the tail node. We want to ensure that the loop does run here, since we need to take the one node list into consideration. The updated <kbd>delete</kbd> method now looks as follows:</p>
<pre>
def delete(self, data): <br/>        current = self.tail <br/>        prev = self.tail <br/>        while prev == current or prev != self.head: <br/>            if current.data == data: <br/>                if current == self.tail: <br/>                    self.tail = current.next <br/>                    self.head.next = self.tail <br/>                else: <br/>                    prev.next = current.next <br/>                self.size -= 1 <br/>                return <br/>            prev = current <br/>            current = current.next 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Iterating through a circular list</h1>
            

            
                
<p>You do not need to modify the <kbd>iter()</kbd> method. It will work perfectly well for our circular list. But you do need to put in an exit condition when you are iterating through the circular list, otherwise your program will get stuck in a loop. Here is a way you could do this, by using a counter variable:</p>
<pre>
    words = CircularList() <br/>    words.append('eggs') <br/>    words.append('ham') <br/>    words.append('spam') <br/><br/>    counter = 0 <br/>    for word in words.iter(): <br/>       print(word) <br/>       counter += 1 <br/>       if counter &gt; 1000: <br/>           break 
</pre>
<p>Once we have printed out 1,000 elements, we break out of the loop.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, we have looked at linked lists. We have studied the concepts that underlie lists, such as nodes and pointers to other nodes. We implemented the major operations that occur on these types of list and saw how their worst case running times compare.</p>
<p>In the next chapter, we are going to look at two other data structures that are usually implemented using lists: stacks and queues.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>