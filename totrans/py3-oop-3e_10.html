<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Python Design Patterns I</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we were briefly introduced to design patterns, and covered the iterator pattern, a pattern so useful and common that it has been abstracted into the core of the programming language itself. In this chapter, we'll be reviewing other common patterns, and how they are implemented in Python. As with iteration, Python often provides an alternative syntax to make working with such problems simpler. We will cover both the <em>traditional</em> design, and the Python version for these patterns.</p>
<p>In summary, we'll see:</p>
<ul>
<li>Numerous specific patterns</li>
<li>A canonical implementation of each pattern in Python</li>
<li>Python syntax to replace certain patterns</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The decorator pattern</h1>
                </header>
            
            <article>
                
<p>The decorator pattern allows us to <em>wrap</em> an object that provides core functionality with other objects that alter this functionality. Any object that uses the decorated object will interact with it in exactly the same way as if it were undecorated (that is, the interface of the decorated object is identical to that of the core object).</p>
<p>There are two primary uses of the decorator pattern:</p>
<ul>
<li>Enhancing the response of a component as it sends data to a second component</li>
<li>Supporting multiple optional behaviors</li>
</ul>
<p>The second option is often a suitable alternative to multiple inheritance. We can construct a core object, and then create a decorator wrapping that core. Since the decorator object has the same interface as the core object, we can even wrap the new object in other decorators. Here's how it looks in a UML diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/03350c12-8e05-436c-b1a4-523d3c95399e.png" style="width:33.50em;height:11.92em;"/></div>
<p>Here, <strong>Core</strong> and all the decorators implement a specific <strong>Interface</strong>. The decorators maintain a reference to another instance of that <strong>Interface</strong> via composition. When called, the decorator does some added processing before or after calling its wrapped interface. The wrapped object may be another decorator, or the core functionality. While multiple decorators may wrap each other, the object in the <em>center</em> of all those decorators provides the core functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A decorator example</h1>
                </header>
            
            <article>
                
<p>Let's look at an example from network programming. We'll be using a TCP socket. The <kbd>socket.send()</kbd> method takes a string of input bytes and outputs them to the receiving socket at the other end. There are plenty of libraries that accept sockets and access this function to send data on the stream. Let's create such an object; it will be an interactive shell that waits for a connection from a client and then prompts the user for a string response:</p>
<pre>import socket<br/><br/><br/>def respond(client):<br/>    response = input("Enter a value: ")<br/>    client.send(bytes(response, "utf8"))<br/>    client.close()<br/><br/><br/>server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>server.bind(("localhost", 2401))<br/>server.listen(1)<br/>try:<br/>    while True:<br/>        client, addr = server.accept()<br/>        respond(client)<br/>finally:<br/>    server.close()</pre>
<p>The <kbd>respond</kbd> function accepts a <kbd>socket</kbd> parameter and prompts for data to be sent as a reply, then sends it. To use it, we construct a server socket and tell it to listen on port <kbd>2401</kbd> (I picked the port randomly) on the local computer. When a client connects, it calls the <kbd>respond</kbd> function, which requests data interactively and responds appropriately. The important thing to notice is that the <kbd>respond</kbd> function only cares about two methods of the socket interface: <kbd>send</kbd> and <kbd>close</kbd>.</p>
<p>To test this, we can write a very simple client that connects to the same port and outputs the response before exiting:</p>
<pre>import socket<br/><br/>client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>client.connect(("localhost", 2401))<br/>print("Received: {0}".format(client.recv(1024)))<br/>client.close()</pre>
<p>To use these programs, follow these steps:</p>
<ol>
<li>Start the server in one Terminal.</li>
<li>Open a second Terminal window and run the client.</li>
<li>At the <span class="packt_screen">Enter a value:</span> prompt in the server window, type a value and press <em>Enter</em>.</li>
<li>The client will receive what you typed, print it to the console, and exit. Run the client a second time; the server will prompt for a second value.</li>
</ol>
<p>The result will look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4a7dbf2a-12ac-488a-87f4-f8b7fc895c4e.png" style="width:50.08em;height:24.58em;"/></p>
<p>Now, looking back at our server code, we see two sections. The <kbd>respond</kbd> function sends data into a <kbd>socket</kbd> object. The remaining script is responsible for creating that <kbd>socket</kbd> object. We'll create a pair of decorators that customize the socket behavior without having to extend or modify the socket itself.</p>
<p>Let's start with a <em>logging</em> decorator. This object outputs any data being sent to the server's console before it sends it to the client:</p>
<pre>class LogSocket:<br/>    def __init__(self, socket):<br/>        self.socket = socket<br/><br/>    def send(self, data):<br/>        print(<br/>            "Sending {0} to {1}".format(<br/>                data, self.socket.getpeername()[0]<br/>            )<br/>        )<br/>        self.socket.send(data)<br/><br/>    def close(self):<br/>        self.socket.close()</pre>
<p>This class decorates a <kbd>socket</kbd> object and presents the <kbd>send</kbd> and <kbd>close</kbd> interface to client sockets. A better decorator would also implement (and possibly customize) all of the remaining <kbd>socket</kbd> methods. It should properly implement all of the arguments to <kbd>send</kbd>, (which actually accepts an optional flags argument) as well, but let's keep our example simple. Whenever <kbd>send</kbd> is called on this object, it logs the output to the screen before sending data to the client using the original socket.</p>
<p>We only have to change one line in our original code to use this decorator. Instead of calling <kbd>respond</kbd> with the socket, we call it with a decorated socket:</p>
<pre>respond(LogSocket(client)) </pre>
<p>While that's quite simple, we have to ask ourselves why we didn't just extend the <kbd>socket</kbd> class and override the <kbd>send</kbd> method. We could call <kbd>super().send</kbd> to do the actual sending, after we logged it. There is nothing wrong with this design either.</p>
<p>When faced with a choice between decorators and inheritance, we should only use decorators if we need to modify the object dynamically, according to some condition. For example, we may only want to enable the logging decorator if the server is currently in debugging mode. Decorators also beat multiple inheritance when we have more than one optional behavior. As an example, we can write a second decorator that compresses data using <kbd>gzip</kbd> compression whenever <kbd>send</kbd> is called:</p>
<pre>import gzip<br/>from io import BytesIO<br/><br/><br/>class GzipSocket:<br/>    def __init__(self, socket):<br/>        self.socket = socket<br/><br/>    def send(self, data):<br/>        buf = BytesIO()<br/>        zipfile = gzip.GzipFile(fileobj=buf, mode="w")<br/>        zipfile.write(data)<br/>        zipfile.close()<br/>        self.socket.send(buf.getvalue())<br/><br/>    def close(self):<br/>        self.socket.close()</pre>
<p>The <kbd>send</kbd> method in this version compresses the incoming data before sending it on to the client.</p>
<p>Now that we have these two decorators, we can write code that dynamically switches between them when responding. This example is not complete, but it illustrates the logic we might follow to mix and match decorators:</p>
<pre>        client, addr = server.accept() 
        if log_send: 
            client = LogSocket(client) 
        if client.getpeername()[0] in compress_hosts: 
            client = GzipSocket(client) 
        respond(client) </pre>
<p>This code checks a hypothetical configuration variable named <kbd>log_send</kbd>. If it's enabled, it wraps the socket in a <kbd>LogSocket</kbd> decorator. Similarly, it checks whether the client that has connected is in a list of addresses known to accept compressed content. If so, it wraps the client in a <kbd>GzipSocket</kbd> decorator. Notice that none, either, or both of the decorators may be enabled, depending on the configuration and connecting client. Try writing this using multiple inheritance and see how confused you get!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorators in Python</h1>
                </header>
            
            <article>
                
<p>The decorator pattern is useful in Python, but there are other options. For example, we may be able to use monkey-patching (for example, <kbd>socket.socket.send = log_send</kbd>) to get a similar effect. Single inheritance, where the <em>optional</em> calculations are done in one large method, could be an option, and multiple inheritance should not be written off just because it's not suitable for the specific example seen previously.</p>
<p>In Python, it is very common to use this pattern on functions. As we saw in a previous chapter, functions are objects too. In fact, function decoration is so common that Python provides a special syntax to make it easy to apply such decorators to functions.</p>
<p>For example, we can look at the logging example in a more general way. Instead of logging, only send calls on sockets; we may find it helpful to log all calls to certain functions or methods. The following example implements a decorator that does just this:</p>
<pre>import time<br/><br/><br/>def log_calls(func):<br/>    def wrapper(*args, **kwargs):<br/>        now = time.time()<br/>        print(<br/>            "Calling {0} with {1} and {2}".format(<br/>                func.__name__, args, kwargs<br/>            )<br/>        )<br/>        return_value = func(*args, **kwargs)<br/>        print(<br/>            "Executed {0} in {1}ms".format(<br/>                func.__name__, time.time() - now<br/>            )<br/>        )<br/>        return return_value<br/><br/>    return wrapper<br/><br/><br/>def test1(a, b, c):<br/>    print("\ttest1 called")<br/><br/><br/>def test2(a, b):<br/>    print("\ttest2 called")<br/><br/><br/>def test3(a, b):<br/>    print("\ttest3 called")<br/>    time.sleep(1)<br/><br/><br/>test1 = log_calls(test1)<br/>test2 = log_calls(test2)<br/>test3 = log_calls(test3)<br/><br/>test1(1, 2, 3)<br/>test2(4, b=5)<br/>test3(6, 7)<br/><br/></pre>
<p>This decorator function is very similar to the example we explored earlier; in those cases, the decorator took a socket-like object and created a socket-like object. This time, our decorator takes a function object and returns a new function object. This code comprises three separate tasks:</p>
<ul>
<li>A function, <kbd>log_calls</kbd>, that accepts another function</li>
<li>This function defines (internally) a new function, named <kbd>wrapper</kbd>, that does some extra work before calling the original function</li>
<li>The inner function is returned from the outer function</li>
</ul>
<p>Three sample functions demonstrate the decorator in use. The third one includes a <kbd>sleep</kbd> call to demonstrate the timing test. We pass each function into the decorator, which returns a new function. We assign this new function to the original variable name, effectively replacing the original function with a decorated one.</p>
<p>This syntax allows us to build up decorated function objects dynamically, just as we did with the socket example. If we don't replace the name, we can even keep decorated and non-decorated versions for different situations.</p>
<p>Typically, these decorators are general modifications that are applied permanently to different functions. In this situation, Python supports a special syntax to apply the decorator at the time the function is defined. We've already seen this syntax in a few places; now, let's understand how it works.</p>
<p>Instead of applying the decorator function after the method definition, we can use the <kbd>@decorator</kbd> syntax to do it all at once:</p>
<pre><strong>@log_calls</strong> 
def test1(a,b,c): 
    print("\ttest1 called") </pre>
<p>The primary benefit of this syntax is that we can easily see that the function has been decorated whenever we read the function definition. If the decorator is applied later, someone reading the code may miss that the function has been altered at all. Answering a question like, <em>Why is my program logging function calls to the console?</em> can become much more difficult! However, the syntax can only be applied to functions we define, since we don't have access to the source code of other modules. If we need to decorate functions that are part of somebody else's third-party library, we have to use the earlier syntax.</p>
<p>There is more to the decorator syntax than we've seen here. We don't have room to cover the advanced topics here, so check the Python reference manual or other tutorials for more information. Decorators can be created as callable objects, not just functions that return functions. Classes can also be decorated; in that case, the decorator returns a new class instead of a new function. Finally, decorators can take arguments to customize them on a per-function basis.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The observer pattern</h1>
                </header>
            
            <article>
                
<p>The observer pattern is useful for state monitoring and event handling situations. This pattern allows a given object to be monitored by an unknown and dynamic group of <em>observer</em> objects.</p>
<p>Whenever a value on the core object changes, it lets all the observer objects know that a change has occurred, by calling an <kbd>update()</kbd> method. Each observer may be responsible for different tasks whenever the core object changes; the core object doesn't know or care what those tasks are, and the observers don't typically know or care what other observers are doing.</p>
<p>Here it is in UML:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/ba0eb0db-e28f-48b0-900a-a501cb8938e0.png" style="width:22.17em;height:13.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An observer example</h1>
                </header>
            
            <article>
                
<p>The observer pattern might be useful in a redundant backup system. We can write a core object that maintains certain values, and then have one or more observers create serialized copies of that object. These copies might be stored in a database, on a remote host, or in a local file, for example. Let's implement the core object using properties:</p>
<pre>class Inventory:<br/>    def __init__(self):<br/>        self.observers = []<br/>        self._product = None<br/>        self._quantity = 0<br/><br/>    def attach(self, observer):<br/>        self.observers.append(observer)<br/><br/>    @property<br/>    def product(self):<br/>        return self._product<br/><br/>    @product.setter<br/>    def product(self, value):<br/>        self._product = value<br/>        self._update_observers()<br/><br/>    @property<br/>    def quantity(self):<br/>        return self._quantity<br/><br/>    @quantity.setter<br/>    def quantity(self, value):<br/>        self._quantity = value<br/><strong>        self._update_observers()</strong><br/><br/><strong>    def _update_observers(self):</strong><br/><strong>        for observer in self.observers:</strong><br/><strong>            observer()</strong></pre>
<p>This object has two properties that, when set, call the <kbd>_update_observers</kbd> method on itself. All this method does is loop over any registered observers and let each know that something has changed. In this case, we call the observer object directly; the object will have to implement <kbd>__call__</kbd> to process the update. This would not be possible in many object-oriented programming languages, but it's a useful shortcut in Python that can help make our code more readable.</p>
<p>Now let's implement a simple observer object; this one will just print out some state to the console:</p>
<pre>class ConsoleObserver: 
    def __init__(self, inventory): 
        self.inventory = inventory 
 
    def __call__(self): 
        print(self.inventory.product) 
        print(self.inventory.quantity) </pre>
<p>There's nothing terribly exciting here; the observed object is set up in the initializer, and when the observer is called, we do <em>something</em>. We can test the observer in an interactive console:</p>
<pre>    <strong>&gt;&gt;&gt; i = Inventory()</strong>
    <strong>&gt;&gt;&gt; c = ConsoleObserver(i)</strong>
    <strong>&gt;&gt;&gt; i.attach(c)</strong>
    <strong>&gt;&gt;&gt; i.product = "Widget"</strong>
    <strong>Widget</strong>
    <strong>0</strong>
    <strong>&gt;&gt;&gt; i.quantity = 5</strong>
    <strong>Widget</strong>
    <strong>5</strong>  </pre>
<p class="mce-root"/>
<p>After attaching the observer to the <kbd>Inventory</kbd> object, whenever we change one of the two observed properties, the observer is called and its action is invoked. We can even add two different observer instances:</p>
<pre>    <strong>&gt;&gt;&gt; i = Inventory()</strong>
    <strong>&gt;&gt;&gt; c1 = ConsoleObserver(i)</strong>
    <strong>&gt;&gt;&gt; c2 = ConsoleObserver(i)</strong>
    <strong>&gt;&gt;&gt; i.attach(c1)</strong>
    <strong>&gt;&gt;&gt; i.attach(c2)</strong>
    <strong>&gt;&gt;&gt; i.product = "Gadget"</strong>
    <strong>Gadget</strong>
    <strong>0</strong>
    <strong>Gadget</strong>
    <strong>0</strong>  </pre>
<p>This time when we change the product, there are two sets of output, one for each observer. The key idea here is that we can easily add totally different types of observers that back up the data in a file, database, or internet application at the same time.</p>
<p>The observer pattern detaches the code being observed from the code doing the observing. If we were not using this pattern, we would have had to put code in each of the properties to handle the different cases that might come up; logging to the console, updating a database or file, and so on. The code for each of these tasks would all be mixed in with the observed object. Maintaining it would be a nightmare, and adding new monitoring functionality at a later date would be painful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The strategy pattern</h1>
                </header>
            
            <article>
                
<p>The strategy pattern is a common demonstration of abstraction in object-oriented programming. The pattern implements different solutions to a single problem, each in a different object. The client code can then choose the most appropriate implementation dynamically at runtime.</p>
<p>Typically, different algorithms have different trade-offs; one might be faster than another, but uses a lot more memory, while a third algorithm may be most suitable when multiple CPUs are present or a distributed system is provided. Here is the strategy pattern in UML:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/280d5e74-70d4-49a2-91f2-d083a054a7d2.png" style="width:23.42em;height:10.25em;"/></div>
<p>The <strong>User</strong> code connecting to the strategy pattern simply needs to know that it is dealing with the <strong>Abstraction</strong> interface. The actual implementation chosen performs the same task, but in different ways; either way, the interface is identical.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A strategy example</h1>
                </header>
            
            <article>
                
<p>The canonical example of the strategy pattern is sort routines; over the years, numerous algorithms have been invented for sorting a collection of objects; quick sort, merge sort, and heap sort are all fast sort algorithms with different features, each useful in its own right, depending on the size and type of inputs, how out of order they are, and the requirements of the system.</p>
<p>If we have client code that needs to sort a collection, we could pass it to an object with a <kbd>sort()</kbd> method. This object may be a <kbd>QuickSorter</kbd> or <kbd>MergeSorter</kbd> object, but the result will be the same in either case: a sorted list. The strategy used to do the sorting is abstracted from the calling code, making it modular and replaceable.</p>
<p>Of course, in Python, we typically just call the <kbd>sorted</kbd> function or <kbd>list.sort</kbd> method and trust that it will do the sorting in a near-optimal fashion. So, we really need to look at a better example.</p>
<p>Let's consider a desktop wallpaper manager. When an image is displayed on a desktop background, it can be adjusted to the screen size in different ways. For example, assuming the image is smaller than the screen, it can be tiled across the screen, centered on it, or scaled to fit. There are other, more complicated, strategies that can be used as well, such as scaling to the maximum height or width, combining it with a solid, semi-transparent, or gradient background color, or other manipulations. While we may want to add these strategies later, let's start with the basic ones.</p>
<p>Our strategy objects take two inputs; the image to be displayed, and a tuple of the width and height of the screen. They each return a new image the size of the screen, with the image manipulated to fit according to the given strategy. You'll need to install the <kbd>pillow</kbd> module with <kbd>pip3 install pillow</kbd> for this example to work:</p>
<pre>from PIL import Image<br/><br/><br/>class TiledStrategy:<br/>    def make_background(self, img_file, desktop_size):<br/>        in_img = Image.open(img_file)<br/>        out_img = Image.new("RGB", desktop_size)<br/>        num_tiles = [<br/>            o // i + 1 for o, i in zip(out_img.size, in_img.size)<br/>        ]<br/>        for x in range(num_tiles[0]):<br/>            for y in range(num_tiles[1]):<br/>                out_img.paste(<br/>                    in_img,<br/>                    (<br/>                        in_img.size[0] * x,<br/>                        in_img.size[1] * y,<br/>                        in_img.size[0] * (x + 1),<br/>                        in_img.size[1] * (y + 1),<br/>                    ),<br/>                )<br/>        return out_img<br/><br/><br/>class CenteredStrategy:<br/>    def make_background(self, img_file, desktop_size):<br/>        in_img = Image.open(img_file)<br/>        out_img = Image.new("RGB", desktop_size)<br/>        left = (out_img.size[0] - in_img.size[0]) // 2<br/>        top = (out_img.size[1] - in_img.size[1]) // 2<br/>        out_img.paste(<br/>            in_img,<br/>            (left, top, left + in_img.size[0], top + in_img.size[1]),<br/>        )<br/>        return out_img<br/><br/><br/>class ScaledStrategy:<br/>    def make_background(self, img_file, desktop_size):<br/>        in_img = Image.open(img_file)<br/>        out_img = in_img.resize(desktop_size)<br/>        return out_img</pre>
<p>Here we have three strategies, each using <kbd>PIL</kbd> to perform their task. Individual strategies have a <kbd>make_background</kbd> method that accepts the same set of parameters. Once selected, the appropriate strategy can be called to create a correctly sized version of the desktop image. <kbd>TiledStrategy</kbd> loops over the number of input images that would fit in the width and height of the image and copies it into each location, repeatedly. <kbd>CenteredStrategy</kbd> figures out how much space needs to be left on the four edges of the image to center it. <kbd>ScaledStrategy</kbd> forces the image to the output size (ignoring aspect ratio).</p>
<p>Consider how switching between these options would be implemented without the strategy pattern. We'd need to put all the code inside one great big method and use an awkward <kbd>if</kbd> statement to select the expected one. Every time we wanted to add a new strategy, we'd have to make the method even more ungainly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strategy in Python</h1>
                </header>
            
            <article>
                
<p>The preceding canonical implementation of the strategy pattern, while very common in most object-oriented libraries, is rarely seen in Python programming.</p>
<p>These classes each represent objects that do nothing but provide a single function. We could just as easily call that function <kbd>__call__</kbd> and make the object callable directly. Since there is no other data associated with the object, we need do no more than create a set of top-level functions and pass them around as our strategies instead.</p>
<p>Opponents of design pattern philosophy will therefore say, <em>because Python has first-class functions, the strategy pattern is unnecessary</em>. In truth, Python's first-class functions allow us to implement the strategy pattern in a more straightforward way. Knowing the pattern exists can still help us choose a correct design for our program, but implement it using a more readable syntax. The strategy pattern, or a top-level function implementation of it, should be used when we need to allow client code or the end user to select from multiple implementations of the same interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The state pattern</h1>
                </header>
            
            <article>
                
<p>The state pattern is structurally similar to the strategy pattern, but its intent and purpose are very different. The goal of the state pattern is to represent state-transition systems: systems where it is obvious that an object can be in a specific state, and that certain activities may drive it to a different state.</p>
<p>To make this work, we need a manager, or context class that provides an interface for switching states. Internally, this class contains a pointer to the current state. Each state knows what other states it is allowed to be in and will transition to those states depending on actions invoked upon it.</p>
<p>So, we have two types of classes: the context class and multiple state classes. The context class maintains the current state, and forwards actions to the state classes. The state classes are typically hidden from any other objects that are calling the context; it acts like a black box that happens to perform state management internally. Here's how it looks in UML:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/381f487e-aad8-4b2b-95a1-4c13ddf6f461.png" style="width:36.25em;height:14.00em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A state example</h1>
                </header>
            
            <article>
                
<p>To illustrate the state pattern, let's build an XML parsing tool. The context class will be the parser itself. It will take a string as input and place the tool in an initial parsing state. The various parsing states will eat characters, looking for a specific value, and when that value is found, change to a different state. The goal is to create a tree of node objects for each tag and its contents. To keep things manageable, we'll parse only a subset of XML – tags and tag names. We won't be able to handle attributes on tags. It will parse text content of tags, but won't attempt to parse <em>mixed</em> content, which has tags inside of text. Here is an example <em>simplified XML</em> file that we'll be able to parse:</p>
<pre>&lt;book&gt; 
    &lt;author&gt;Dusty Phillips&lt;/author&gt; 
    &lt;publisher&gt;Packt Publishing&lt;/publisher&gt; 
    &lt;title&gt;Python 3 Object Oriented Programming&lt;/title&gt; 
    &lt;content&gt; 
        &lt;chapter&gt; 
            &lt;number&gt;1&lt;/number&gt; 
            &lt;title&gt;Object Oriented Design&lt;/title&gt; 
        &lt;/chapter&gt; 
        &lt;chapter&gt; 
            &lt;number&gt;2&lt;/number&gt; 
            &lt;title&gt;Objects In Python&lt;/title&gt; 
        &lt;/chapter&gt; 
    &lt;/content&gt; 
&lt;/book&gt; </pre>
<p>Before we look at the states and the parser, let's consider the output of this program. We know we want a tree of <kbd>Node</kbd> objects, but what does a <kbd>Node</kbd> look like? It will clearly need to know the name of the tag it is parsing, and since it's a tree, it should probably maintain a pointer to the parent node and a list of the node's children in order. Some nodes have a text value, but not all of them. Let's look at this <kbd>Node</kbd> class first:</p>
<pre>class Node:<br/>    def __init__(self, tag_name, parent=None):<br/>        self.parent = parent<br/>        self.tag_name = tag_name<br/>        self.children = []<br/>        self.text = ""<br/><br/>    def __str__(self):<br/>        if self.text:<br/>            return self.tag_name + ": " + self.text<br/>        else:<br/>            return self.tag_name</pre>
<p>This class sets default attribute values upon initialization. The <kbd>__str__</kbd> method is supplied to help visualize the tree structure when we're finished.</p>
<p>Now, looking at the example document, we need to consider what states our parser can be in. Clearly, it's going to start in a state where no nodes have yet been processed. We'll need a state for processing opening tags and closing tags. And when we're inside a tag with text contents, we'll have to process that as a separate state, too.</p>
<p>Switching states can be tricky; how do we know if the next node is an opening tag, a closing tag, or a text node? We could put a little logic in each state to work this out, but it actually makes more sense to create a new state whose sole purpose is figuring out which state we'll be switching to next. If we call this transition state <strong>ChildNode</strong>, we end up with the following states:</p>
<ul>
<li><kbd>FirstTag</kbd></li>
<li><kbd>ChildNode</kbd></li>
<li><kbd>OpenTag</kbd></li>
<li><kbd>CloseTag</kbd></li>
<li><kbd>Text</kbd></li>
</ul>
<p>The <strong>FirstTag</strong> state will switch to <strong>ChildNode</strong>, which is responsible for deciding which of the other three states to switch to; when those states are finished, they'll switch back to <strong>ChildNode</strong>. The following state-transition diagram shows the available state changes:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/98701341-1821-4aaa-b23a-457371c26270.png" style="width:16.33em;height:14.42em;"/></div>
<p>The states are responsible for taking <em>what's left of the string</em>, processing as much of it as they know what to do with, and then telling the parser to take care of the rest of it. Let's construct the <kbd>Parser</kbd> class first:</p>
<pre>class Parser: 
    def __init__(self, parse_string): 
        self.parse_string = parse_string 
        self.root = None 
        self.current_node = None 
 
        self.state = FirstTag() 
 
    def process(self, remaining_string): 
        remaining = self.state.process(remaining_string, self) 
        if remaining: 
            self.process(remaining) 
 
    def start(self): 
        self.process(self.parse_string) </pre>
<p>The initializer sets up a few variables on the class that the individual states will access. The <kbd>parse_string</kbd> instance variable is the text that we are trying to parse. The <kbd>root</kbd> node is the <em>top</em> node in the XML structure. The <kbd>current_node</kbd> instance variable is the one that we are currently adding children to.</p>
<p>The important feature of this parser is the <kbd>process</kbd> method, which accepts the remaining string, and passes it off to the current state. The parser (the <kbd>self</kbd> argument) is also passed into the state's process method so that the state can manipulate it. The state is expected to return the remainder of the unparsed string when it is finished processing. The parser then recursively calls the <kbd>process</kbd> method on this remaining string to construct the rest of the tree.</p>
<p>Now let's have a look at the <kbd>FirstTag</kbd> state:</p>
<pre>class FirstTag:<br/>    def process(self, remaining_string, parser):<br/>        i_start_tag = remaining_string.find("&lt;")<br/>        i_end_tag = remaining_string.find("&gt;")<br/>        tag_name = remaining_string[i_start_tag + 1 : i_end_tag]<br/>        root = Node(tag_name)<br/><strong>        parser.root = parser.current_node = root</strong><br/><strong>        parser.state = ChildNode()</strong><br/>        return remaining_string[i_end_tag + 1 :]</pre>
<p>This state finds the index (the <kbd>i_</kbd> stands for index) of the opening and closing angle brackets on the first tag. You may think this state is unnecessary, since XML requires that there be no text before an opening tag. However, there may be whitespace that needs to be consumed; this is why we search for the opening angle bracket instead of assuming it is the first character in the document.</p>
<div class="packt_infobox">Note that this code is assuming a valid input file. A proper implementation would be rigorously testing for invalid input, and would attempt to recover or display an extremely descriptive error message.</div>
<p>The method extracts the name of the tag and assigns it to the root node of the parser. It also assigns it to <kbd>current_node</kbd>, since that's the one we'll be adding children to next.</p>
<p>Then comes the important part: the method changes the current state on the parser object to a <kbd>ChildNode</kbd> state. It then returns the remainder of the string (after the opening tag) to allow it to be processed.</p>
<p>The <kbd>ChildNode</kbd> state, which seems quite complicated, turns out to require nothing but a simple conditional:</p>
<pre>class ChildNode: 
    def process(self, remaining_string, parser): 
        stripped = remaining_string.strip() 
        if stripped.startswith("&lt;/"): 
<strong>            parser.state = CloseTag()</strong> 
        elif stripped.startswith("&lt;"): 
<strong>            parser.state = OpenTag()</strong> 
        else: 
<strong>            parser.state = TextNode()</strong> 
        return stripped </pre>
<p>The <kbd>strip()</kbd> call removes whitespace from the string. Then the parser determines if the next item is an opening or closing tag, or a string of text. Depending on which possibility occurs, it sets the parser to a particular state, and then tells it to parse the remainder of the string.</p>
<p>The <kbd>OpenTag</kbd> state is similar to the <kbd>FirstTag</kbd> state, except that it adds the newly created node to the previous <kbd>current_node</kbd> object's <kbd>children</kbd> and sets it as the new <kbd>current_node</kbd>. It places the processor back in the <kbd>ChildNode</kbd> state before continuing:</p>
<pre>class OpenTag:<br/>    def process(self, remaining_string, parser):<br/>        i_start_tag = remaining_string.find("&lt;")<br/>        i_end_tag = remaining_string.find("&gt;")<br/>        tag_name = remaining_string[i_start_tag + 1 : i_end_tag]<br/>        node = Node(tag_name, parser.current_node)<br/><strong>        parser.current_node.children.append(node)</strong><br/><strong>        parser.current_node = node</strong><br/><strong>        parser.state = ChildNode()</strong><br/>        return remaining_string[i_end_tag + 1 :]</pre>
<p>The <kbd>CloseTag</kbd> state basically does the opposite; it sets the parser's <kbd>current_node</kbd> back to the parent node so any further children in the outside tag can be added to it:</p>
<pre>class CloseTag:<br/>    def process(self, remaining_string, parser):<br/>        i_start_tag = remaining_string.find("&lt;")<br/>        i_end_tag = remaining_string.find("&gt;")<br/>        assert remaining_string[i_start_tag + 1] == "/"<br/>        tag_name = remaining_string[i_start_tag + 2 : i_end_tag]<br/>        assert tag_name == parser.current_node.tag_name<br/><strong>        parser.current_node = parser.current_node.parent</strong><br/><strong>        parser.state = ChildNode()</strong><br/>        return remaining_string[i_end_tag + 1 :].strip()</pre>
<p>The two <kbd>assert</kbd> statements help ensure that the parse strings are consistent.</p>
<p>Finally, the <kbd>TextNode</kbd> state very simply extracts the text before the next close tag and sets it as a value on the current node:</p>
<pre>class TextNode: 
    def process(self, remaining_string, parser): 
        i_start_tag = remaining_string.find('&lt;') 
        text = remaining_string[:i_start_tag] 
<strong>        parser.current_node.text = text 
        parser.state = ChildNode()</strong> 
        return remaining_string[i_start_tag:] </pre>
<p>Now we just have to set up the initial state on the parser object we created. The initial state is a <kbd>FirstTag</kbd> object, so just add the following to the <kbd>__init__</kbd> method:</p>
<pre>        self.state = FirstTag() </pre>
<p>To test the class, let's add a main script that opens an file from the command line, parses it, and prints the nodes:</p>
<pre>if __name__ == "__main__": 
    import sys 
    with open(sys.argv[1]) as file: 
        contents = file.read() 
        p = Parser(contents) 
        p.start() 
 
        nodes = [p.root] 
        while nodes: 
            node = nodes.pop(0) 
            print(node) 
            nodes = node.children + nodes </pre>
<p>This code opens the file, loads the contents, and parses the result. Then it prints each node and its children in order. The <kbd>__str__</kbd> method we originally added on the <kbd>node</kbd> class takes care of formatting the nodes for printing. If we run the script on the earlier example, it outputs the tree as follows:</p>
<pre>    <strong>book</strong>
    <strong>author: Dusty Phillips</strong>
    <strong>publisher: Packt Publishing</strong>
    <strong>title: Python 3 Object Oriented Programming</strong>
    <strong>content</strong>
    <strong>chapter</strong>
    <strong>number: 1</strong>
    <strong>title: Object Oriented Design</strong>
    <strong>chapter</strong>
    <strong>number: 2</strong>
    <strong>title: Objects In Python</strong>  </pre>
<p>Comparing this to the original simplified XML document tells us the parser is working.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State versus strategy</h1>
                </header>
            
            <article>
                
<p>The state pattern looks very similar to the strategy pattern; indeed, the UML diagrams for the two are identical. The implementation, too, is identical. We could even have written our states as first-class functions instead of wrapping them in objects, as was suggested for strategy.</p>
<p>While the two patterns have identical structures, they solve completely different problems. The strategy pattern is used to choose an algorithm at runtime; generally, only one of those algorithms is going to be chosen for a particular use case. The state pattern, on the other hand, is designed to allow switching between different states dynamically, as some process evolves. In code, the primary difference is that the strategy pattern is not typically aware of other strategy objects. In the state pattern, either the state or the context needs to know which other states that it can switch to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State transition as coroutines</h1>
                </header>
            
            <article>
                
<p>The state pattern is the canonical object-oriented solution to state-transition problems. However, you can get a similar effect by constructing your objects as coroutines. Remember the regular expression log file parser we built in <a href="0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>The Iterator Pattern</em>? That was a state-transition problem in disguise. The main difference between that implementation and one that defines all the objects (or functions) used in the state pattern is that the coroutine solution allows us to encode more of the boilerplate in language constructs. There are two implementations, but neither one is inherently better than the other. The state pattern is actually the only place I would consider using coroutines outside of <kbd>asyncio</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The singleton pattern</h1>
                </header>
            
            <article>
                
<p>The singleton pattern is one of the most controversial patterns; many have accused it of being an <em>anti-pattern</em>, a pattern that should be avoided, not promoted. In Python, if someone is using the singleton pattern, they're almost certainly doing something wrong, probably because they're coming from a more restrictive programming language.</p>
<p>So, why discuss it at all? Singleton is one of the most famous of all design patterns. It is useful in overly object-oriented languages, and is a vital part of traditional object-oriented programming. More relevantly, the idea behind singleton is useful, even if we implement the concept in a totally different way in Python.</p>
<p>The basic idea behind the singleton pattern is to allow exactly one instance of a certain object to exist. Typically, this object is a sort of manager class like those we discussed in <a href="42cd7e16-073b-485c-8073-554ac64d992f.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>When to Use Object-Oriented Programming</em>. Such objects often need to be referenced by a wide variety of other objects, and passing references to the manager object around to the methods and constructors that need them can make code hard to read.</p>
<p>Instead, when a singleton is used, the separate objects request the single instance of the manager object from the class, so a reference to it need not to be passed around. The UML diagram doesn't fully describe it, but here it is for completeness:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/ce1b7c4a-1f9e-4c9f-8290-86b645a94096.png" style="width:18.83em;height:7.92em;"/></div>
<p>In most programming environments, singletons are enforced by making the constructor private (so no one can create additional instances of it), and then providing a static method to retrieve the single instance. This method creates a new instance the first time it is called, and then returns that same instance for all subsequent calls.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Singleton implementation</h1>
                </header>
            
            <article>
                
<p>Python doesn't have private constructors, but for this purpose, we can use the <kbd>__new__</kbd> class method to ensure that only one instance is ever created:</p>
<pre>class OneOnly: 
<strong>    _singleton = None</strong> 
    def __new__(cls, *args, **kwargs): 
        if not cls._singleton: 
<strong>            cls._singleton = super(OneOnly, cls 
                ).__new__(cls, *args, **kwargs)</strong> 
        return cls._singleton </pre>
<p>When <kbd>__new__</kbd> is called, it normally constructs a new instance of that class. When we override it, we first check whether our singleton instance has been created; if not, we create it using a <kbd>super</kbd> call. Thus, whenever we call the constructor on <kbd>OneOnly</kbd>, we always get the exact same instance:</p>
<pre>    <strong>&gt;&gt;&gt; o1 = OneOnly()</strong>
    <strong>&gt;&gt;&gt; o2 = OneOnly()</strong>
    <strong>&gt;&gt;&gt; o1 == o2</strong>
    <strong>True</strong>
    <strong>&gt;&gt;&gt; o1</strong>
    <strong>&lt;__main__.OneOnly object at 0xb71c008c&gt;</strong>
    <strong>&gt;&gt;&gt; o2</strong>
    <strong>&lt;__main__.OneOnly object at 0xb71c008c&gt;</strong>  </pre>
<p>The two objects are equal and located at the same address; thus, they are the same object. This particular implementation isn't very transparent, since it's not obvious that a singleton object has been created. Whenever we call a constructor, we expect a new instance of that object; in this case, that contract is violated. Perhaps, good docstrings on the class could alleviate this problem if we really think we need a singleton.</p>
<p>But we don't need it. Python coders frown on forcing the users of their code into a specific mindset. We may think only one instance of a class will ever be required, but other programmers may have different ideas. Singletons can interfere with distributed computing, parallel programming, and automated testing, for example. In all those cases, it can be very useful to have multiple or alternative instances of a specific object, even though a <em>normal</em> operation may never require one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module variables can mimic singletons</h1>
                </header>
            
            <article>
                
<p>Normally, in Python, the singleton pattern can be sufficiently mimicked using module-level variables. It's not as <em>safe</em> as a singleton in that people could reassign those variables at any time, but as with the private variables we discussed in <a href="0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Objects in Python</em>, this is acceptable in Python. If someone has a valid reason to change those variables, why should we stop them? It also doesn't stop people from instantiating multiple instances of the object, but again, if they have a valid reason to do so, why interfere?</p>
<p>Ideally, we should give them a mechanism to get access to the <em>default singleton</em> value, while also allowing them to create other instances if they need them. While technically not a singleton at all, it provides the most Pythonic mechanism for singleton-like behavior.</p>
<p>To use module-level variables instead of a singleton, we instantiate an instance of the class after we've defined it. We can improve our state pattern to use singletons. Instead of creating a new object every time we change states, we can create a module-level variable that is always accessible:</p>
<pre>class Node:<br/>    def __init__(self, tag_name, parent=None):<br/>        self.parent = parent<br/>        self.tag_name = tag_name<br/>        self.children = []<br/>        self.text = ""<br/><br/>    def __str__(self):<br/>        if self.text:<br/>            return self.tag_name + ": " + self.text<br/>        else:<br/>            return self.tag_name<br/><br/><br/>class FirstTag:<br/>    def process(self, remaining_string, parser):<br/>        i_start_tag = remaining_string.find("&lt;")<br/>        i_end_tag = remaining_string.find("&gt;")<br/>        tag_name = remaining_string[i_start_tag + 1 : i_end_tag]<br/>        root = Node(tag_name)<br/>        parser.root = parser.current_node = root<br/>        parser.state = child_node<br/>        return remaining_string[i_end_tag + 1 :]<br/><br/><br/>class ChildNode:<br/>    def process(self, remaining_string, parser):<br/>        stripped = remaining_string.strip()<br/>        if stripped.startswith("&lt;/"):<br/>            parser.state = close_tag<br/>        elif stripped.startswith("&lt;"):<br/>            parser.state = open_tag<br/>        else:<br/>            parser.state = text_node<br/>        return stripped<br/><br/><br/>class OpenTag:<br/>    def process(self, remaining_string, parser):<br/>        i_start_tag = remaining_string.find("&lt;")<br/>        i_end_tag = remaining_string.find("&gt;")<br/>        tag_name = remaining_string[i_start_tag + 1 : i_end_tag]<br/>        node = Node(tag_name, parser.current_node)<br/>        parser.current_node.children.append(node)<br/>        parser.current_node = node<br/>        parser.state = child_node<br/>        return remaining_string[i_end_tag + 1 :]<br/><br/><br/>class TextNode:<br/>    def process(self, remaining_string, parser):<br/>        i_start_tag = remaining_string.find("&lt;")<br/>        text = remaining_string[:i_start_tag]<br/>        parser.current_node.text = text<br/>        parser.state = child_node<br/>        return remaining_string[i_start_tag:]<br/><br/><br/>class CloseTag:<br/>    def process(self, remaining_string, parser):<br/>        i_start_tag = remaining_string.find("&lt;")<br/>        i_end_tag = remaining_string.find("&gt;")<br/>        assert remaining_string[i_start_tag + 1] == "/"<br/>        tag_name = remaining_string[i_start_tag + 2 : i_end_tag]<br/>        assert tag_name == parser.current_node.tag_name<br/>        parser.current_node = parser.current_node.parent<br/>        parser.state = child_node<br/>        return remaining_string[i_end_tag + 1 :].strip()<br/><br/><br/><strong>first_tag = FirstTag()</strong><br/><strong>child_node = ChildNode()</strong><br/><strong>text_node = TextNode()</strong><br/><strong>open_tag = OpenTag()</strong><br/><strong>close_tag = CloseTag()</strong></pre>
<p>All we've done is create instances of the various state classes that can be reused. Notice how we can access these module variables inside the classes, even before the variables have been defined? This is because the code inside the classes is not executed until the method is called, and by this point, the entire module will have been defined.</p>
<p>The difference in this example is that instead of wasting memory creating a bunch of new instances that must be garbage collected, we are reusing a single state object for each state. Even if multiple parsers are running at once, only these state classes need to be used.</p>
<p>When we originally created the state-based parser, you may have wondered why we didn't pass the parser object to <kbd>__init__</kbd> on each individual state, instead of passing it into the <kbd>process</kbd> method as we did. The state could then have been referenced as <kbd>self.parser</kbd>. This is a perfectly valid implementation of the state pattern, but it would not have allowed leveraging the singleton pattern. If the state objects maintain a reference to the parser, then they cannot be used simultaneously to reference other parsers.</p>
<div class="packt_tip">Remember, these are two different patterns with different purposes; the fact that singleton's purpose may be useful for implementing the state pattern does not mean the two patterns are related.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The template pattern</h1>
                </header>
            
            <article>
                
<p>The template pattern is useful for removing duplicate code; it's intended to support the <strong>Don't Repeat Yourself</strong> principle we discussed in <a href="42cd7e16-073b-485c-8073-554ac64d992f.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>When to Use Object-Oriented Programming</em>. It is designed for situations where we have several different tasks to accomplish that have some, but not all, steps in common. The common steps are implemented in a base class, and the distinct steps are overridden in subclasses to provide custom behavior. In some ways, it's like a generalized strategy pattern, except similar sections of the algorithms are shared using a base class. Here it is in the UML format:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/ec4347a5-997f-43a6-a91a-ca31741a38c6.png" style="width:17.92em;height:16.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A template example</h1>
                </header>
            
            <article>
                
<p>Let's create a car sales reporter as an example. We can store records of sales in an SQLite database table. SQLite is a simple file-based database engine that allows us to store records using SQL syntax. Python includes SQLite in its standard library, so there are no extra modules required.</p>
<p>We have two common tasks we need to perform:</p>
<ul>
<li>Select all sales of new vehicles and output them to the screen in a comma-delimited format</li>
<li>Output a comma-delimited list of all salespeople with their gross sales and save it to a file that can be imported to a spreadsheet</li>
</ul>
<p>These seem like quite different tasks, but they have some common features. In both cases, we need to perform the following steps:</p>
<ol>
<li>Connect to the database.</li>
<li>Construct a query for new vehicles or gross sales.</li>
<li>Issue the query.</li>
<li>Format the results into a comma-delimited string.</li>
<li>Output the data to a file or email.</li>
</ol>
<p>The query construction and output steps are different for the two tasks, but the remaining steps are identical. We can use the template pattern to put the common steps in a base class, and the varying steps in two subclasses.</p>
<p>Before we start, let's create a database and put some sample data in it, using a few lines of SQL:</p>
<pre>import sqlite3<br/><br/>conn = sqlite3.connect("sales.db")<br/><br/>conn.execute(<br/>    "CREATE TABLE Sales (salesperson text, "<br/>    "amt currency, year integer, model text, new boolean)"<br/>)<br/>conn.execute(<br/>    "INSERT INTO Sales values"<br/>    " ('Tim', 16000, 2010, 'Honda Fit', 'true')"<br/>)<br/>conn.execute(<br/>    "INSERT INTO Sales values"<br/>    " ('Tim', 9000, 2006, 'Ford Focus', 'false')"<br/>)<br/>conn.execute(<br/>    "INSERT INTO Sales values"<br/>    " ('Gayle', 8000, 2004, 'Dodge Neon', 'false')"<br/>)<br/>conn.execute(<br/>    "INSERT INTO Sales values"<br/>    " ('Gayle', 28000, 2009, 'Ford Mustang', 'true')"<br/>)<br/>conn.execute(<br/>    "INSERT INTO Sales values"<br/>    " ('Gayle', 50000, 2010, 'Lincoln Navigator', 'true')"<br/>)<br/>conn.execute(<br/>    "INSERT INTO Sales values"<br/>    " ('Don', 20000, 2008, 'Toyota Prius', 'false')"<br/>)<br/>conn.commit()<br/>conn.close()</pre>
<p>Hopefully, you can see what's going on here even if you don't know SQL; we've created a table to hold the data, and used six <kbd>insert</kbd> statements to add sales records. The data is stored in a file named <kbd>sales.db</kbd>. Now we have a sample we can work with in developing our template pattern.</p>
<p>Since we've already outlined the steps that the template has to perform, we can start by defining the base class that contains the steps. Each step gets its own method (to make it easy to selectively override any one step), and we have one more managerial method that calls the steps in turn. Without any method content, here's how it might look:</p>
<pre>class QueryTemplate:<br/>    def connect(self):<br/>        pass<br/><br/>    def construct_query(self):<br/>        pass<br/><br/>    def do_query(self):<br/>        pass<br/><br/>    def format_results(self):<br/>        pass<br/><br/>    def output_results(self):<br/>        pass<br/><br/>    def process_format(self):<br/>        self.connect()<br/>        self.construct_query()<br/>        self.do_query()<br/>        self.format_results()<br/>        self.output_results()</pre>
<p>The <kbd>process_format</kbd> method is the primary method to be called by an outside client. It ensures each step is executed in order, but it does not care whether that step is implemented in this class or in a subclass. For our examples, we know that three methods are going to be identical between our two classes:</p>
<pre>import sqlite3 
 
class QueryTemplate:<br/>    def connect(self):<br/>        self.conn = sqlite3.connect("sales.db")<br/><br/>    def construct_query(self):<br/>        raise NotImplementedError()<br/><br/>    def do_query(self):<br/>        results = self.conn.execute(self.query)<br/>        self.results = results.fetchall()<br/><br/>    def format_results(self):<br/>        output = []<br/>        for row in self.results:<br/>            row = [str(i) for i in row]<br/>            output.append(", ".join(row))<br/>        self.formatted_results = "\n".join(output)<br/><br/>    def output_results(self):<br/>        raise NotImplementedError()</pre>
<p>To help with implementing subclasses, the two methods that are not specified raise <kbd>NotImplementedError</kbd>. This is a common way to specify abstract interfaces in Python when abstract base classes seem too heavyweight. The methods could have empty implementations (with <kbd>pass</kbd>), or could be fully unspecified. Raising <kbd>NotImplementedError</kbd>, however, helps the programmer understand that the class is meant to be subclassed and these methods overridden. Empty methods or methods that do not exist are harder to identify as needing to be implemented and to debug if we forget to implement them.</p>
<p>Now we have a template class that takes care of the boring details, but is flexible enough to allow the execution and formatting of a wide variety of queries. The best part is, if we ever want to change our database engine from SQLite to another database engine (such as <kbd>py-postgresql</kbd>), we only have to do it here, in this template class, and we don't have to touch the two (or two hundred) subclasses we might have written.</p>
<p>Let's have a look at the concrete classes now:</p>
<pre>import datetime <br/><br/>class NewVehiclesQuery(QueryTemplate):<br/>    def construct_query(self):<br/>        self.query = "select * from Sales where new='true'"<br/><br/>    def output_results(self):<br/>        print(self.formatted_results)<br/><br/><br/>class UserGrossQuery(QueryTemplate):<br/>    def construct_query(self):<br/>        self.query = (<br/>            "select salesperson, sum(amt) "<br/>            + " from Sales group by salesperson"<br/>        )<br/><br/>    def output_results(self):<br/>        filename = "gross_sales_{0}".format(<br/>            datetime.date.today().strftime("%Y%m%d")<br/>        )<br/>        with open(filename, "w") as outfile:<br/>            outfile.write(self.formatted_results)</pre>
<p>These two classes are actually pretty short, considering what they're doing: connecting to a database, executing a query, formatting the results, and outputting them. The superclass takes care of the repetitive work, but lets us easily specify those steps that vary between tasks. Further, we can also easily change steps that are provided in the base class. For example, if we wanted to output something other than a comma-delimited string (for example: an HTML report to be uploaded to a website), we can still override <kbd>format_results</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>While writing the examples for this chapter, I discovered that it can be very difficult, and extremely educational, to come up with good examples where specific design patterns should be used. Instead of going over current or old projects to see where you can apply these patterns, as I've suggested in previous chapters, think about the patterns and different situations where they might come up. Try to think outside your own experiences. If your current projects are in the banking business, consider how you'd apply these design patterns in a retail or point-of-sale application. If you normally write web applications, think about using design patterns while writing a compiler.</p>
<p>Look at the decorator pattern and come up with some good examples of when to apply it. Focus on the pattern itself, not the Python syntax we discussed. It's a bit more general than the actual pattern. The special syntax for decorators is, however, something you may want to look for places to apply in existing projects too.</p>
<p>What are some good areas to use the observer pattern? Why? Think about not only how you'd apply the pattern, but how you would implement the same task without using observer? What do you gain, or lose, by choosing to use it?</p>
<p>Consider the difference between the strategy and state patterns. Implementation-wise, they look very similar, yet they have different purposes. Can you think of cases where the patterns could be interchanged? Would it be reasonable to redesign a state-based system to use strategy instead, or vice versa? How different would the design actually be?</p>
<p>The template pattern is such an obvious application of inheritance to reduce duplicate code that you may have used it before, without knowing its name. Try to think of at least half a dozen different scenarios where it would be useful. If you can do this, you'll be finding places for it in your daily coding all the time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter discussed several common design patterns in detail, with examples, UML diagrams, and a discussion of the differences between Python and statically typed object-oriented languages. The decorator pattern is often implemented using Python's more generic decorator syntax. The observer pattern is a useful way to decouple events from actions taken on those events. The strategy pattern allows different algorithms to be chosen to accomplish the same task. The state pattern looks similar, but is used instead to represent systems can move between different states using well-defined actions. The singleton pattern, popular in some statically typed languages, is almost always an anti-pattern in Python.</p>
<p>In the next chapter, we'll wrap up our discussion of design patterns.</p>


            </article>

            
        </section>
    </body></html>