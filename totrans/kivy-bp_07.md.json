["```py\nFloatLayout:\n    Background:\n        id: background\n        canvas:\n            Rectangle:\n                pos: self.pos\n                size: (self.width, 96)\n                texture: self.tx_floor\n\n            Rectangle:\n                pos: (self.x, self.y + 96)\n                size: (self.width, 64)\n                texture: self.tx_grass\n\n            Rectangle:\n                pos: (self.x, self.height - 144)\n                size: (self.width, 128)\n                texture: self.tx_cloud\n\n```", "```py\nfrom kivy.core.image import Image\nfrom kivy.uix.widget import Widget\n\nclass BaseWidget(Widget):\n    def load_tileable(self, name):\n        t = Image('%s.png' % name).texture\n        t.wrap = 'repeat'\n        setattr(self, 'tx_%s' % name, t)\n```", "```py\nfrom kivy.properties import ObjectProperty\n\nclass Background(BaseWidget):\n    tx_floor = ObjectProperty(None)\n    tx_grass = ObjectProperty(None)\n    tx_cloud = ObjectProperty(None)\n\n    def __init__(self, **kwargs):\n        super(Background, self).__init__(**kwargs)\n\n        for name in ('floor', 'grass', 'cloud'):\n            self.load_tileable(name)\n```", "```py\ndef set_background_size(self, tx):\n    tx.uvsize = (self.width / tx.width, -1)\n```", "```py\ndef on_size(self, *args):\n    for tx in (self.tx_floor, self.tx_grass, self.tx_cloud):\n        self.set_background_size(tx)\n```", "```py\nfrom kivy.app import App\nfrom kivy.clock import Clock\n\nclass KivyBirdApp(App):\n    def on_start(self):\n        self.background = self.root.ids.background\n        Clock.schedule_interval(self.update, 0.016)\n\n    def update(self, nap):\n        self.background.update(nap)\n```", "```py\ndef update(self, nap):\n    self.set_background_uv('tx_floor', 2 * nap)\n    self.set_background_uv('tx_grass', 0.5 * nap)\n    self.set_background_uv('tx_cloud', 0.1 * nap)\n\ndef set_background_uv(self, name, val):\n    t = getattr(self, name)\n    t.uvpos = ((t.uvpos[0] + val) % self.width, t.uvpos[1])\n    self.property(name).dispatch(self)\n```", "```py\n<Pipe>:\n    canvas:\n        Rectangle:\n            pos: (self.x + 4, self.FLOOR)\n            size: (56, self.lower_len)\n            texture: self.tx_pipe\n            tex_coords: self.lower_coords\n\n        Rectangle:\n            pos: (self.x, self.FLOOR + self.lower_len)\n            size: (64, self.PCAP_HEIGHT)\n            texture: self.tx_pcap\n\n        Rectangle:\n            pos: (self.x + 4, self.upper_y)\n            size: (56, self.upper_len)\n            texture: self.tx_pipe\n            tex_coords: self.upper_coords\n\n        Rectangle:\n            pos: (self.x, self.upper_y - self.PCAP_HEIGHT)\n            size: (64, self.PCAP_HEIGHT)\n            texture: self.tx_pcap\n\n    size_hint: (None, 1)\n    width: 64\n```", "```py\nfrom kivy.properties import (AliasProperty,\n                             ListProperty,\n                             NumericProperty,\n                             ObjectProperty)\n\nclass Pipe(BaseWidget):\n    FLOOR = 96\n    PCAP_HEIGHT = 26\n    PIPE_GAP = 120\n\n    tx_pipe = ObjectProperty(None)\n    tx_pcap = ObjectProperty(None)\n\n    ratio = NumericProperty(0.5)\n    lower_len = NumericProperty(0)\n    lower_coords = ListProperty((0, 0, 1, 0, 1, 1, 0, 1))\n    upper_len = NumericProperty(0)\n    upper_coords = ListProperty((0, 0, 1, 0, 1, 1, 0, 1))\n\n    upper_y = AliasProperty(\n        lambda self: self.height - self.upper_len,\n        None, bind=['height', 'upper_len'])\n```", "```py\nclass Pipe(BaseWidget):\n    def __init__(self, **kwargs):\n        super(Pipe, self).__init__(**kwargs)\n\n        for name in ('pipe', 'pcap'):\n            self.load_tileable(name)\n```", "```py\ndef set_coords(self, coords, len):\n    len /= 16  # height of the texture\n    coords[5:] = (len, 0, len)  # set the last 3 items\n```", "```py\ndef on_size(self, *args):\n    pipes_length = self.height - (\n        Pipe.FLOOR + Pipe.PIPE_GAP + 2 * Pipe.PCAP_HEIGHT)\n    self.lower_len = self.ratio * pipes_length\n    self.upper_len = pipes_length - self.lower_len\n    self.set_coords(self.lower_coords, self.lower_len)\n    self.set_coords(self.upper_coords, self.upper_len)\n```", "```py\nself.bind(ratio=self.on_size)\n```", "```py\nclass KivyBirdApp(App):\n    pipes = []\n\n    def on_start(self):\n        self.spacing = 0.5 * self.root.width\n        # ...\n\n    def spawn_pipes(self):\n        for p in self.pipes:\n            self.root.remove_widget(p)\n\n        self.pipes = []\n\n        for i in range(4):\n            p = Pipe(x=self.root.width + (self.spacing * i))\n            p.ratio = random.uniform(0.25, 0.75)\n            self.root.add_widget(p)\n            self.pipes.append(p)\n```", "```py\ndef update(self, nap):\n    self.background.update(nap)\n\n    for p in self.pipes:\n        p.x -= 96 * nap\n        if p.x <= -64:  # pipe gone off screen\n            p.x += 4 * self.spacing\n            p.ratio = random.uniform(0.25, 0.75)\n```", "```py\nBird:\n    id: bird\n    pos_hint: {'center_x': 0.3333, 'center_y': 0.6}\n    size: (54, 54)\n    size_hint: (None, None)\n    source: 'bird.png'\n```", "```py\nfrom kivy.uix.image import Image as ImageWidget\n\nclass Bird(ImageWidget):\n    pass\n```", "```py\nfrom kivy.core.window import Window, Keyboard\n\nclass KivyBirdApp(App):\n    playing = False\n\n    def on_start(self):\n        # ...\n        Window.bind(on_key_down=self.on_key_down)\n        self.background.on_touch_down = self.user_action\n\n    def on_key_down(self, window, key, *args):\n        if key == Keyboard.keycodes['spacebar']:\n            self.user_action()\n\n    def user_action(self, *args):\n        if not self.playing:\n            self.spawn_pipes()\n            self.playing = True\n```", "```py\nclass Bird(ImageWidget):\n    ACCEL_FALL = 0.25\n\n    speed = NumericProperty(0)\n\n    def gravity_on(self, height):\n        # Replace pos_hint with a value\n        self.pos_hint.pop('center_y', None)\n        self.center_y = 0.6 * height\n\n    def update(self, nap):\n        self.speed -= Bird.ACCEL_FALL\n        self.y += self.speed\n```", "```py\nif not self.playing:\n    self.bird.gravity_on(self.root.height)\n    self.spawn_pipes()\n    self.playing = True\n```", "```py\nself.background = self.root.ids.background\nself.bird = self.root.ids.bird\n```", "```py\n    def update(self, nap):\n        self.background.update(nap)\n        if not self.playing:\n return  # don't move bird or pipes\n\n self.bird.update(nap)\n        # rest of the code omitted\n```", "```py\nACCEL_JUMP = 5\n\ndef bump(self):\n    self.speed = Bird.ACCEL_JUMP\n```", "```py\nclass Bird(ImageWidget):\n    speed = NumericProperty(0)\n    angle = AliasProperty(\n        lambda self: 5 * self.speed,\n        None, bind=['speed'])\n```", "```py\n<Bird>:\n    canvas.before:\n        PushMatrix\n        Rotate:\n            angle: root.angle\n            axis: (0, 0, 1)\n            origin: root.center\n\n    canvas.after:\n        PopMatrix\n```", "```py\ndef test_game_over(self):\n    if self.bird.y < 90 or \\\n            self.bird.y > self.root.height - 50:\n        return True\n\n    return False\n```", "```py\n    def test_game_over(self):\n        screen_height = self.root.height\n\n        if self.bird.y < 90 or \\\n                self.bird.y > screen_height - 50:\n            return True\n\n        for p in self.pipes:\n            if not p.collide_widget(self.bird):\n                continue\n\n            # The gap between pipes\n            if (self.bird.y < p.lower_len + 116 or\n                self.bird.y > screen_height - (\n                    p.upper_len + 75)):\n                return True\n\n        return False\n```", "```py\ndef update(self, nap):\n    # ...\n    if self.test_game_over():\n        self.playing = False\n```", "```py\nfrom kivy.core.audio import SoundLoader\n\nsnd = SoundLoader.load('sound.wav')\nsnd.play()\n```", "```py\nclass MultiAudio:\n    _next = 0\n\n    def __init__(self, filename, count):\n        self.buf = [SoundLoader.load(filename)\n                    for i in range(count)]\n\n    def play(self):\n        self.buf[self._next].play()\n        self._next = (self._next + 1) % len(self.buf)\n```", "```py\nsnd = MultiAudio('sound.wav', 5)\nsnd.play()\n```", "```py\nsnd_bump = MultiAudio('bump.wav', 4)\nsnd_game_over = SoundLoader.load('game_over.wav')\n```", "```py\nif self.test_game_over():\n    snd_game_over.play()\n    self.playing = False\n\ndef user_action(self, *args):\n    snd_bump.play()\n\n```"]