["```py\nimport wx\nimport threading\n\nclass FibThread(threading.Thread):\n    def __init__(self, window, n):\n        super(FibThread, self).__init__()\n\n        # Attributes\n        self.window = window\n        self.n = n\n\n    def run(self):\n        val = SlowFib(self.n)\n        wx.CallAfter(self.window.output.SetValue, str(val))\n        wx.CallAfter(self.window.StopBusy)\n\ndef SlowFib(n):\n    \"\"\"Calculate Fibonacci numbers\n    using slow recursive method to demonstrate\n    blocking the UI.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return SlowFib(n-1) + SlowFib(n-2)\n\n```", "```py\nclass BlockingApp(wx.App):\n    def OnInit(self):\n        self.frame = BlockingFrame(None,\n                                   title=\"Non-Blocking Gui\")\n        self.frame.Show()\n        return True\n\nclass BlockingFrame(wx.Frame):\n    \"\"\"Main application window\"\"\"\n    def __init__(self, *args, **kwargs):\n        super(BlockingFrame, self).__init__(*args, **kwargs)\n\n        # Attributes\n        self.panel = BlockingPanel(self)\n\n        # Layout\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.panel, 1, wx.EXPAND)\n        self.SetSizer(sizer)\n        self.SetInitialSize()\n\n```", "```py\nclass BlockingPanel(wx.Panel):\n    def __init__(self, parent):\n        super(BlockingPanel, self).__init__(parent)\n\n        # Attributes\n        self.timer = wx.Timer(self)\n        self.input = wx.SpinCtrl(self, value=\"35\", min=1)\n        self.output = wx.TextCtrl(self)\n        self.block = wx.Button(self, label=\"Blocking\")\n        self.noblock = wx.Button(self, label=\"Non-Blocking\")\n        self.prog = wx.Gauge(self)\n\n        # Layout\n        self.__DoLayout()\n\n        # Event Handlers\n        self.Bind(wx.EVT_BUTTON, self.OnButton)\n        self.Bind(wx.EVT_TIMER, self.OnPulse, self.timer)\n\n    def __DoLayout(self):\n        vsizer = wx.BoxSizer(wx.VERTICAL)\n        hsizer = wx.BoxSizer(wx.HORIZONTAL)\n        gridsz = wx.GridSizer(2, 2, 5, 5)\n\n        # Layout controls\n        vsizer.Add(self.prog, 0, wx.EXPAND)\n        gridsz.Add(wx.StaticText(self, label=\"fib(n):\"))\n        gridsz.Add(self.input, 0, wx.EXPAND)\n        gridsz.Add(wx.StaticText(self, label=\"result:\"))\n        gridsz.Add(self.output, 0, wx.EXPAND)\n        vsizer.Add(gridsz, 0, wx.EXPAND|wx.ALL, 10)\n        hsizer.Add(self.block, 0, wx.ALL, 5)\n        hsizer.Add(self.noblock, 0, wx.ALL, 5)\n        vsizer.Add(hsizer, 0, wx.ALIGN_CENTER_HORIZONTAL)\n\n        self.SetSizer(vsizer)\n\n```", "```py\n    def OnButton(self, event):\n        input = self.input.GetValue()\n        self.output.SetValue(\"\") # clear output\n        self.StartBusy() # give busy feedback\n        if event.GetEventObject() == self.block:\n            # Calculate value in blocking mode\n            val = SlowFib(input)\n            self.output.SetValue(str(val))\n            self.StopBusy()\n        else:\n            # Non-Blocking mode\n            task = FibThread(self, input)\n            task.start()\n\n```", "```py\n    def OnPulse(self, event):\n        self.prog.Pulse() # Pulse busy feedback\n\n    def StartBusy(self):\n        self.timer.Start(100)\n        self.block.Disable()\n        self.noblock.Disable()\n\n    def StopBusy(self):\n        self.timer.Stop()\n        self.prog.SetValue(0)\n        self.block.Enable()\n        self.noblock.Enable()\n\nif __name__ == '__main__':\n    app = BlockingApp(False)\n    app.MainLoop()\n\n```", "```py\nimport wx\nimport time\nimport threading\n\n# Define a new custom event type\nwxEVT_THREAD_UPDATE = wx.NewEventType()\nEVT_THREAD_UPDATE = wx.PyEventBinder(wxEVT_THREAD_UPDATE, 1)\n\nclass ThreadUpdateEvent(wx.PyCommandEvent):\n    def __init__(self, eventType, id):\n        super(ThreadUpdateEvent, self).__init__(eventType, id)\n\n        # Attributes\n        self.value = None\n\n    def SetValue(self, value):\n        self.value = value\n\n    def GetValue(self):\n        return self.value\n\n```", "```py\nclass CountingThread(threading.Thread):\n    \"\"\"Simple thread that sends an update to its \n    target window once a second with the new count value.\n    \"\"\"\n    def __init__(self, targetwin, id):\n        super(CountingThread, self).__init__()\n\n        # Attributes\n        self.window = targetwin\n        self.id = id\n        self.count = 0\n        self.stop = False\n\n    def run(self):\n        while not self.stop:\n            time.sleep(1) # wait a second\n            # Notify the main thread itsitâ€™s time \n            # to update the ui\n            if self.window:\n                event = ThreadUpdateEvent(wxEVT_THREAD_UPDATE,\n                                          self.id)\n                event.SetValue(self.count)\n                wx.PostEvent(self.window, event)\n            self.count += 1\n\n    def Stop(self):\n        # Stop the thread\n        self.stop = True\n\nclass ThreadSafetyApp(wx.App):\n    def OnInit(self):\n        self.frame = ThreadSafeFrame(None,\n                                     title=\"Thread Safety\")\n        self.frame.Show()\n        return True\n\n```", "```py\nclass ThreadSafeFrame(wx.Frame):\n    \"\"\"Main application window\"\"\"\n    def __init__(self, *args, **kwargs):\n        super(ThreadSafeFrame, self).__init__(*args, **kwargs)\n\n        # Attributes\n        self.panel = ThreadSafePanel(self)\n        self.threadId = wx.NewId()\n        self.worker = CountingThread(self, self.threadId)\n\n        # Layout\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.panel, 1, wx.EXPAND)\n        self.SetSizer(sizer)\n        self.SetInitialSize((300, 300))\n\n        # Start the worker thread\n        self.worker.start()\n\n        # Event Handlers\n        self.Bind(wx.EVT_CLOSE, self.OnClose)\n        self.Bind(EVT_THREAD_UPDATE, self.OnThreadEvent)\n\n    def OnClose(self, event):\n        # Stop the worker thread\n        self.worker.Stop()\n        event.Skip()\n\n```", "```py\n    def OnThreadEvent(self, event):\n        if event.GetId() == self.threadId():\n            # Handle event to update Displayed Count\n            value = event.GetValue()\n            self.panel.DisplayCount(value)\n        else:\n            event.Skip()\n\nclass ThreadSafePanel(wx.Panel):\n    def __init__(self, parent):\n        super(ThreadSafePanel, self).__init__(parent)\n\n        # Attributes\n        self.count = wx.StaticText(self, label=\"Count: \")\n\n        # Setup\n        self.__DoLayout()\n\n    def __DoLayout(self):\n        vsizer = wx.BoxSizer(wx.VERTICAL)\n        hsizer = wx.BoxSizer(wx.HORIZONTAL)\n        vsizer.AddStretchSpacer()\n        hsizer.AddStretchSpacer()\n        hsizer.Add(self.count)\n        hsizer.AddStretchSpacer()\n        vsizer.Add(hsizer, 0, wx.EXPAND)\n        vsizer.AddStretchSpacer()\n        self.SetSizer(vsizer)\n\n    def DisplayCount(self, value):\n        self.count.SetLabel(\"Count: %d\" % value)\n\nif __name__ == '__main__':\n    app = ThreadSafetyApp(False)\n    app.MainLoop()\n\n```", "```py\nwx.CallAfter(callable, *args, **kw)\n\n```", "```py\nwx.CallAfter(self.window.panel.DisplayCount,\n             self.count)\n\n```", "```py\nvalue = wx.CallAfter(window.GetValue)\n\n```", "```py\nimport wx\nimport threading\nfrom types import FunctionType, MethodType\n\n__all__ = ['callafter', 'synchfunct', 'ClassSynchronizer']\n\n```", "```py\ndef callafter(funct):callafter(funct):\n    \"\"\"Decorator to automatically use CallAfter if\n    a method is called from a different thread.\n    \"\"\"\n    def callafterwrap(*args, **kwargs):\n        if wx.Thread_IsMain():\n            return funct(*args, **kwargs)\n        else:\n            wx.CallAfter(funct, *args, **kwargs)\n    callafterwrap.__name__ = funct.__name__\n    callafterwrap.__doc__ = funct.__doc__\n    return callafterwrap\n\n```", "```py\nclass Synchronizer(object):\n    \"\"\"Synchronize CallAfter calls\"\"\"\n    def __init__(self, funct, args, kwargs):\n        super(Synchronizer, self).__init__()\n\n        # Attributes\n        self.funct = funct\n        self.args = args\n        self.kwargs = kwargs\n        self._synch = threading.Semaphore(0)\n\n```", "```py\n    def _AsynchWrapper(self):\n        \"\"\"This part runs in main gui thread\"\"\"\n        try:\n            self.result = self.funct(*self.args,\n                                     **self.kwargs)\n        except Exception, msg:\n            # Store exception to report back to\n            # the calling thread.\n            self.exception = msg\n        # Release Semaphore to allow processing back \n        # on other thread to resume.\n        self._synch.release()\n\n```", "```py\n    def Run(self):\n        \"\"\"Call from background thread\"\"\"\n        # Make sure this is not called from main thread\n        # as it will result in deadlock waiting on the\n        # Semaphore.\n        assert not wx.Thread_IsMain(), \"Deadlock!\"\n        # Make the asynchronous call to the main thread\n        # to run the function.\n        wx.CallAfter(self._AsynchWrapper)\n        # Block on Semaphore release until the function\n        # has been processed in the main thread by the\n        # UI's event loop.\n        self._synch.acquire()\n        # Return result to caller or raise error\n        try:\n            return self.result\n        except AttributeError:\n            raise self.exception\n\n```", "```py\ndef synchfunct(funct):\n    \"\"\"Decorator to synchronize a method call from a worker\n    thread to the GUI thread.\n    \"\"\"\n    def synchwrap(*args, **kwargs):\n        if wx.Thread_IsMain():\n            # called in context of main thread so\n            # no need for special synchronization\n            return self.funct(*args, **kwargs)\n        else:\n            synchobj = Synchronizer(funct, args, kwargs)\n            return synchobj.Run()\n\n    synchwrap.__name__ = funct.__name__\n    synchwrap.__doc__ = funct.__doc__\n    return synchwrap\n\n```", "```py\nclass ClassSynchronizer(type):\n    \"\"\"Metaclass to make all methods in a class threadsafe\"\"\"\n    def __call__(mcs, *args, **kwargs):\n        obj = type.__call__(mcs, *args, **kwargs)\n\n        # Wrap all methods/functions in the class with\n        # the synchfunct decorator.\n        for attrname in dir(obj):\n            attr = getattr(obj, attrname)\n            if type(attr) in (MethodType, FunctionType):\n                nfunct = synchfunct(attr)\n                setattr(obj, attrname, nfunct)\n\n        return obj\n\n```", "```py\nclass MyPanel(wx.Panel):\n    @callafter\n    def SetSomeGuiValues(self, values):\n        self.ctrl1.SetValue(values[0])\n        ...\n        self.ctrlN.SetValue(values[N])\n\n```", "```py\nclass MyPanel(wx.Panel):\n    __metaclass__ = ClassSynchronizer\n    def __init__(self, parent, *args, **kwargs)\n\n```", "```py\nclass TimerTaskBase(object):\n    \"\"\"Defines interface for long running task\n    state machine.\n    \"\"\"\n    TASK_STATE_PENDING, \\\n    TASK_STATE_RUNNING, \\\n    TASK_STATE_COMPLETE = range(3)\n    def __init__(self):\n        super(TimerTaskBase, self).__init__()\n\n        # Attributes\n        self._state = TimerTaskBase.TASK_STATE_PENDING\n\n    #---- Interface ----#\n\n    def ProcessNext(self):\n        \"\"\"Do next iteration of task\n        @note: must be implemented by subclass\n        \"\"\"\n        raise NotImplementedError\n\n    def InitTask(self):\n        \"\"\"Optional override called before task \n        processing begins\n        \"\"\"\n        self.SetState(TimerTaskBase.TASK_STATE_RUNNING)\n\n    #---- Implementation ----#\n\n    def GetState(self):\n        return self._state\n\n    def SetState(self, state):\n        self._state = state\n\n```", "```py\nclass TimerTaskMixin(object):\n    \"\"\"Mixin class for a wxWindow object to use timers\n    for running long task. Must be used as a mixin with\n    a wxWindow derived class!\n    \"\"\"\n    def __init__(self):\n        super(TimerTaskMixin, self).__init__()\n\n        # Attributes\n        self._task = None\n        self._timer = wx.Timer(self)\n\n        # Event Handlers\n        self.Bind(wx.EVT_TIMER, self.OnTimer, self._timer)\n\n    def __del__(self):\n        # Make sure timer is stopped\n        self.StopProcessing()\n\n```", "```py\n    def OnTimer(self, event):\n        if self._task is not None:\n            self._task.ProcessNext()\n            state = self._task.GetState()\n            if state == self._task.TASK_STATE_COMPLETE:\n                self._timer.Stop()\n\n    def StartTask(self, taskobj):\n        assert not self._timer.IsRunning(), \\\n               \"Task already busy!\"\n        assert isinstance(taskobj, TimerTaskBase)\n        self._task = taskobj\n        self._task.InitTask()\n        self._timer.Start(100)\n\n    def StopProcessing(self):\n        if self._timer.IsRunning():\n            self._timer.Stop()\n\n```", "```py\nimport wx\nimport wx.stc as stc\nimport threading\nimport subprocess\n\n```", "```py\nclass ProcessThread(threading.Thread):\n    \"\"\"Helper Class for OutputWindow to run a subprocess in\n    a separate thread and report its output back \n    to the window.\n    \"\"\"\n    def __init__(self, parent, command, readblock=4096):\n        \"\"\"\n        @param parent: OutputWindow instance\n        @param command: Command line command\n        @param readblock: amount to read from stdout each read\n        \"\"\"\n        assert hasattr(parent, 'AppendUpdate')\n        assert readblock > 0\n        super(ProcessThread, self).__init__()\n\n        # Attributes\n        self._proc = None\n        self._parent = parent\n        self._command = command\n        self._readblock = readblock\n\n        # Setup\n        self.setDaemon(True)\n\n```", "```py\n    def run(self):\n        # Suppress popping up a console window\n        # when running on windows\n        if subprocess.mswindows:            \n            suinfo = subprocess.STARTUPINFO()\n            try:\n                from win32process import STARTF_USESHOWWINDOW\n                suinfo.dwFlags |= STARTF_USESHOWWINDOW\n            except ImportError:\n                # Give up and use hard coded value \n                # from Windows.h\n                suinfo.dwFlags |= 0x00000001\n        else:\n            suinfo = None\n\n        try:\n            # Start the subprocess\n            outmode = subprocess.PIPE\n            errmode = subprocess.STDOUT\n            self._proc = subprocess.Popen(self._command,\n                                          stdout=outmode,\n                                          stderr=errmode,\n                                          shell=True,\n                                          startupinfo=suinfo)\n        except OSError, msg:\n            self._parent.AppendUpdate(unicode(msg))\n            return\n\n```", "```py\n        # Read from stdout while there is output from process\n        while True:\n            self._proc.poll()\n            if self._proc.returncode is None:\n                # Still running so check stdout\n                txt = self._proc.stdout.read(self._readblock)\n                if txt:\n                    # Add to UI's update queue\n                    self._parent.AppendUpdate(txt)\n            else:\n                break\n\n```", "```py\nclass OutputWindow(stc.StyledTextCtrl):\n    def __init__(self, parent):\n        super(OutputWindow, self).__init__(parent)\n\n        # Attributes\n        self._mutex = threading.Lock()\n        self._updating = threading.Condition(self._mutex)\n        self._updates = list()\n        self._timer = wx.Timer(self)\n        self._threads = list()\n\n        # Setup\n        self.SetReadOnly(True)\n\n        # Event Handlers\n        self.Bind(wx.EVT_TIMER, self.OnTimer)\n\n    def __del__(self):\n        if self._timer.IsRunning():\n            self._timer.Stop()\n\n```", "```py\n    def AppendUpdate(self, value):\n        \"\"\"Thread safe method to add updates to UI\"\"\"\n        self._updating.acquire()\n        self._updates.append(value)\n        self._updating.release()\n\n```", "```py\ndef OnTimer(self, event):\n\"\"\"Check updates queue and apply to UI\"\"\"\n# Check Thread(s)\ntlist = list(self._threads)\nfor idx, thread in enumerate(tlist):\nif not thread.isAlive():\ndel self._threads[idx]\n# Apply pending updates to control\nind = len(self._updates)\nif ind:\n# Flush update buffer\nself._updating.acquire()\nself.SetReadOnly(False)\ntxt = ''.join(self._updates[:])\nself.AppendText(txt)\nself.GotoPos(self.GetLength())\nself._updates = list()\nself.SetReadOnly(True)\nself._updating.release()\nif not len(self._threads):\nself._timer.Stop()\n\n```", "```py\n    def StartProcess(self, command, blocksize=4096):\n        \"\"\"Start command. Blocksize can be used to control\n        how much text must be read from stdout before window\n        will update.\n        \"\"\"\n        procthread = ProcessThread(self, command, blocksize)\n        procthread.start()\n        self._threads.append(procthread)\n        if not self._timer.IsRunning():\n            self._timer.Start(250)\n\n```"]