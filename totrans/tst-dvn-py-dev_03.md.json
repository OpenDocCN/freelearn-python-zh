["```py\n    def get_crossover_signal(self, on_date):\n        cpl = []\n        for i in range(11):\n            chk = on_date.date() - timedelta(i)\n            for price_event in reversed(self.price_history):\n                if price_event.timestamp.date() > chk:\n                    pass\n                if price_event.timestamp.date() == chk:\n                    cpl.insert(0, price_event)\n                    break\n                if price_event.timestamp.date() < chk:\n                    cpl.insert(0, price_event)\n                    break\n\n        # Return NEUTRAL signal\n        if len(cpl) < 11:\n            return 0\n\n        # BUY signal\n        if sum([update.price for update in cpl[-11:-1]])/10 \\\n                > sum([update.price for update in cpl[-6:-1]])/5 \\\n            and sum([update.price for update in cpl[-10:]])/10 \\\n                < sum([update.price for update in cpl[-5:]])/5:\n                    return 1\n\n        # BUY signal\n        if sum([update.price for update in cpl[-11:-1]])/10 \\\n                < sum([update.price for update in cpl[-6:-1]])/5 \\\n            and sum([update.price for update in cpl[-10:]])/10 \\\n                > sum([update.price for update in cpl[-5:]])/5:\n                    return -1\n\n        # NEUTRAL signal\n        return 0\n```", "```py\ndef get_crossover_signal(self, on_date):\n    closing_price_list = []\n    for i in range(11):\n        chk = on_date.date() - timedelta(i)\n        for price_event in reversed(self.price_history):\n            if price_event.timestamp.date() > chk:\n                pass\n            if price_event.timestamp.date() == chk:\n                closing_price_list.insert(0, price_event)\n                break\n            if price_event.timestamp.date() < chk:\n                closing_price_list.insert(0, price_event)\n                break\n\n    # Return NEUTRAL signal\n    if len(closing_price_list) < 11:\n        return 0\n\n    # BUY signal\n    if (sum([update.price\n                 for update in closing_price_list[-11:-1]])/10\n            > sum([update.price\n                       for update in closing_price_list[-6:-1]])/5\n        and sum([update.price\n                     for update in closing_price_list[-10:]])/10\n            < sum([update.price\n                       for update in closing_price_list[-5:]])/5):\n                return 1\n\n    # BUY signal\n    if (sum([update.price\n                 for update in closing_price_list[-11:-1]])/10\n            < sum([update.price\n                 for update in closing_price_list[-6:-1]])/5\n        and sum([update.price\n                     for update in closing_price_list[-10:]])/10\n            > sum([update.price\n                       for update in closing_price_list[-5:]])/5):\n                return -1\n\n    # NEUTRAL signal\n    return 0\n```", "```py\n# Halve the price if age is 60 or above\nif age >= 60:\n    price = price * 0.5\n\n# People aged 60 or above are eligible for senior citizen discount\nif age >= 60:\n    price = price * 0.5\n\nif age >= SENIOR_CITIZEN_AGE:\n    price = price * SENIOR_CITIZEN_DISCOUNT\n```", "```py\nclass Stock:\n    LONG_TERM_TIMESPAN = 10\n    SHORT_TERM_TIMESPAN = 5\n\n```", "```py\n    def get_crossover_signal(self, on_date):\n        closing_price_list = []\n        NUM_DAYS = self.LONG_TERM_TIMESPAN + 1\n        for i in range(NUM_DAYS):\n            chk = on_date.date() - timedelta(i)\n            for price_event in reversed(self.price_history):\n                if price_event.timestamp.date() > chk:\n                    pass\n                if price_event.timestamp.date() == chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n                if price_event.timestamp.date() < chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n```", "```py\nfrom enum import Enum\n```", "```py\nclass StockSignal(Enum):\n    buy = 1\n    neutral = 0\n    sell = -1\n```", "```py\n        # NEUTRAL signal\n        return StockSignal.neutral\n\n```", "```py\n    def _get_closing_price_list(self, on_date, num_days):\n        closing_price_list = []\n        for i in range(num_days):\n            chk = on_date.date() - timedelta(i)\n            for price_event in reversed(self.price_history):\n                if price_event.timestamp.date() > chk:\n                    pass\n                if price_event.timestamp.date() == chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n                if price_event.timestamp.date() < chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n        return closing_price_list\n```", "```py\n    def _get_closing_price_list(self, on_date, num_days):\n        pass\n    ```", "```py\n    def _get_closing_price_list(self, on_date, num_days):\n        closing_price_list = []\n        for i in range(NUM_DAYS):\n            chk = on_date.date() - timedelta(i)\n            for price_event in reversed(self.price_history):\n                if price_event.timestamp.date() > chk:\n                    pass\n                if price_event.timestamp.date() == chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n                if price_event.timestamp.date() < chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n    ```", "```py\n    def _get_closing_price_list(self, on_date, num_days):\n        closing_price_list = []\n        for i in range(num_days):\n            chk = on_date.date() - timedelta(i)\n            for price_event in reversed(self.price_history):\n                if price_event.timestamp.date() > chk:\n                    pass\n                if price_event.timestamp.date() == chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n                if price_event.timestamp.date() < chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n        return closing_price_list\n    ```", "```py\n    def get_crossover_signal(self, on_date):\n        NUM_DAYS = self.LONG_TERM_TIMESPAN + 1\n        closing_price_list = \\\n            self._get_closing_price_list(on_date, NUM_DAYS)\n    ```", "```py\ndef _get_closing_price_list(self, on_date, num_days):\n    closing_price_list = []\n    for i in range(num_days):\n        chk = on_date.date() - timedelta(i)\n        for price_event in reversed(self.price_history):\n            if price_event.timestamp.date() > chk:\n                pass\n            if price_event.timestamp.date() == chk:\n                closing_price_list.insert(0, price_event)\n                break\n            if price_event.timestamp.date() < chk:\n                closing_price_list.insert(0, price_event)\n                break\n    return closing_price_list\n\ndef get_crossover_signal(self, on_date):\n    NUM_DAYS = self.LONG_TERM_TIMESPAN + 1\n    closing_price_list = \\\n        self._get_closing_price_list(on_date, NUM_DAYS)\n    â€¦\n```", "```py\nlong_term_series = closing_price_list[-self.LONG_TERM_TIMESPAN:]\nprev_long_term_series = \\\n    closing_price_list[-self.LONG_TERM_TIMESPAN-1:-1]\nshort_term_series = closing_price_list[-self.SHORT_TERM_TIMESPAN:]\nprev_short_term_series = \\\n    closing_price_list[-self.SHORT_TERM_TIMESPAN-1:-1]\n```", "```py\nif sum([update.price for update in prev_long_term_series])/10 \\\n    > sum([update.price for update in prev_short_term_series])/5 \\\n    and sum([update.price for update in long_term_series])/10 \\\n        < sum([update.price for update in short_term_series])/5:\n            return StockSignal.buy\n```", "```py\nif sum([update.price for update in prev_long_term_series])/10 \\> sum([update.price for update in prev_short_term_series])/5 \\and sum([update.price for update in long_term_series])/10 \\< sum([update.price for update in short_term_series])/5:\n            return StockSignal.buy\n```", "```py\nlong_term_ma = sum([update.price\n                    for update in long_term_series])\\\n                /self.LONG_TERM_TIMESPAN\nprev_long_term_ma = sum([update.price\n                         for update in prev_long_term_series])\\\n                     /self.LONG_TERM_TIMESPAN\nshort_term_ma = sum([update.price\n                     for update in short_term_series])\\\n                /self.SHORT_TERM_TIMESPAN\nprev_short_term_ma = sum([update.price\n                          for update in prev_short_term_series])\\\n                     /self.SHORT_TERM_TIMESPAN\n```", "```py\ndef _is_short_term_crossover_below_to_above(self, prev_short_term_ma,\n                                            prev_long_term_ma,\n                                            short_term_ma,\n                                            long_term_ma):\n    return prev_long_term_ma > prev_short_term_ma \\\n        and long_term_ma < short_term_ma\n\ndef _is_short_term_crossover_above_to_below(self, prev_short_term_ma,\n                                            prev_long_term_ma,\n                                            short_term_ma,\n                                            long_term_ma):\n    return prev_long_term_ma < prev_short_term_ma \\\n        and long_term_ma > short_term_ma\n```", "```py\nif self._is_short_term_crossover_below_to_above(prev_short_term_ma,\n                                                prev_long_term_ma,\n                                                short_term_ma,\n                                                long_term_ma):\n            return StockSignal.buy\n\nif self._is_short_term_crossover_above_to_below(prev_short_term_ma,\n                                                prev_long_term_ma,\n                                                short_term_ma,\n                                                long_term_ma):\n            return StockSignal.sell\n\nreturn StockSignal.neutral\n```", "```py\nNUM_DAYS = self.LONG_TERM_TIMESPAN + 1\nclosing_price_list = self._get_closing_price_list(on_date, NUM_DAYS)\n\nif len(closing_price_list) < NUM_DAYS:\n    return StockSignal.neutral\n\nlong_term_series = closing_price_list[-self.LONG_TERM_TIMESPAN:]\nprev_long_term_series = \\\n    closing_price_list[-self.LONG_TERM_TIMESPAN-1:-1]\nshort_term_series = closing_price_list[-self.SHORT_TERM_TIMESPAN:]\nprev_short_term_series = \\\n    closing_price_list[-self.SHORT_TERM_TIMESPAN-1:-1]\n\nlong_term_ma = sum([update.price\n                    for update in long_term_series])\\\n                /self.LONG_TERM_TIMESPAN\nprev_long_term_ma = sum([update.price\n                         for update in prev_long_term_series])\\\n                     /self.LONG_TERM_TIMESPAN\nshort_term_ma = sum([update.price\n                     for update in short_term_series])\\\n                /self.SHORT_TERM_TIMESPAN\nprev_short_term_ma = sum([update.price\n                          for update in prev_short_term_series])\\\n                     /self.SHORT_TERM_TIMESPAN\n\nif self._is_short_term_crossover_below_to_above(prev_short_term_ma,\n                                                prev_long_term_ma,\n                                                short_term_ma,\n                                                long_term_ma):\n            return StockSignal.buy\n\nif self._is_short_term_crossover_above_to_below(prev_short_term_ma,\n                                                prev_long_term_ma,\n                                                short_term_ma,\n                                                long_term_ma):\n            return StockSignal.sell\n\nreturn StockSignal.neutral\n```", "```py\ndef _is_short_term_crossover_below_to_above(self, prev_short_term_ma,\n                                            prev_long_term_ma,\n                                            short_term_ma,\n                                            long_term_ma):\n    return prev_long_term_ma > prev_short_term_ma \\\n        and long_term_ma < short_term_ma\n\ndef _is_short_term_crossover_above_to_below(self, prev_short_term_ma,\n                                            prev_long_term_ma,\n                                            short_term_ma,\n                                            long_term_ma):\n    return prev_long_term_ma < prev_short_term_ma \\\n        and long_term_ma > short_term_ma\n```", "```py\ndef _is_short_term_crossover_below_to_above(self, prev_short_term_ma,prev_long_term_ma,short_term_ma,long_term_ma):return prev_short_term_ma < prev_long_term_ma \\\n        and short_term_ma > long_term_ma\n```", "```py\ndef _is_short_term_crossover_above_to_below(self, prev_short_term_ma,\n                                            prev_long_term_ma,\n                                            short_term_ma,\n                                            long_term_ma):\n    return prev_long_term_ma < prev_short_term_ma \\\n        and long_term_ma > short_term_ma\n```", "```py\ndef _is_crossover_below_to_above(self, prev_ma, prev_reference_ma,\n                                 current_ma, current_reference_ma):\n    return prev_ma < prev_reference_ma \\\n        and current_ma > current_reference_ma\n```", "```py\nif self._is_crossover_below_to_above(prev_short_term_ma,\n                                     prev_long_term_ma,\n                                     short_term_ma,\n                                     long_term_ma):\n            return StockSignal.buy\n\nif self._is_crossover_below_to_above(prev_long_term_ma,\n                                     prev_short_term_ma,\n                                     long_term_ma,\n                                     short_term_ma):\n            return StockSignal.sell\n```", "```py\nclass TimeSeries:\n    pass\n```", "```py\n    def __init__(self, symbol):\n        self.symbol = symbol\n        self.price_history = []\n        self.history = TimeSeries()\n```", "```py\nimport bisect\nimport collections\n\nUpdate = collections.namedtuple(\"Update\", [\"timestamp\", \"value\"])\n\nclass TimeSeries:\n    def __init__(self):\n        self.series = []\n\n    def update(self, timestamp, value):\n        bisect.insort_left(self.series, Update(timestamp, value))\n```", "```py\n    def update(self, timestamp, price):\n        if price < 0:\n            raise ValueError(\"price should not be negative\")\n        bisect.insort_left(self.price_history, PriceEvent(timestamp, price))\n        self.history.update(timestamp, price)\n```", "```py\ndef price(self):\n    return self.price_history[-1].price \\\n        if self.price_history else None\n\ndef is_increasing_trend(self):\n    return self.price_history[-3].price < \\\n        self.price_history[-2].price < self.price_history[-1].price\n```", "```py\nclass TimeSeries:\n    def __getitem__(self, index):\n        return self.series[index]\n```", "```py\n    def price(self):\n        try:\n           return self.history[-1].value\n        except IndexError:\n            return None\n\n    def is_increasing_trend(self):\n        return self.history[-3].value < \\\n            self.history[-2].value < self.history[-1].value\n```", "```py\nclass TimeSeries:\n    def get_closing_price_list(self, on_date, num_days, price_history):\n        closing_price_list = []\n        for i in range(num_days):\n            chk = on_date.date() - timedelta(i)\n            for price_event in reversed(price_history):\n                if price_event.timestamp.date() > chk:\n                    pass\n                if price_event.timestamp.date() == chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n                if price_event.timestamp.date() < chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n        return closing_price_list\n```", "```py\n    def get_crossover_signal(self, on_date):\n        NUM_DAYS = self.LONG_TERM_TIMESPAN + 1\n        closing_price_list = self.history.get_closing_price_list(on_date, NUM_DAYS, self.price_history)\n```", "```py\n    def get_closing_price_list(self, on_date, num_days):\n        closing_price_list = []\n        for i in range(num_days):\n            chk = on_date.date() - timedelta(i)\n            for price_event in reversed(self.series):\n                if price_event.timestamp.date() > chk:\n                    pass\n                if price_event.timestamp.date() == chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n                if price_event.timestamp.date() < chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n        return closing_price_list\n```", "```py\n    def get_crossover_signal(self, on_date):\n        NUM_DAYS = self.LONG_TERM_TIMESPAN + 1\n        closing_price_list = self.history.get_closing_price_list(on_date, NUM_DAYS)\n```", "```py\n==================================================================\nERROR: test_with_upward_crossover_returns_buy (stock_alerter.stock.StockCrossOverSignalTest)\n------------------------------------------------------------------\nTraceback (most recent call last):\n File \"c:\\Projects\\tdd_with_python\\src\\stock_alerter\\stock.py\", line 239, in test_with_upward_crossover_returns_buy\n self.goog.get_crossover_signal(date_to_check))\n File \"c:\\Projects\\tdd_with_python\\src\\stock_alerter\\stock.py\", line 63, in get_crossover_signal\n for update in long_term_series])\\\n File \"c:\\Projects\\tdd_with_python\\src\\stock_alerter\\stock.py\", line 63, in <listcomp>\n for update in long_term_series])\\\nAttributeError: 'Update' object has no attribute 'price'\n\nRan 21 tests in 0.018s\n\nFAILED (errors=7)\n\n```", "```py\n        long_term_ma = sum([update.value\n                            for update in long_term_series])\\\n                        /self.LONG_TERM_TIMESPAN\n        prev_long_term_ma = sum([update.value\n                                 for update in prev_long_term_series])\\\n                             /self.LONG_TERM_TIMESPAN\n        short_term_ma = sum([update.value\n                             for update in short_term_series])\\\n                        /self.SHORT_TERM_TIMESPAN\n        prev_short_term_ma = sum([update.value\n                                  for update in prev_short_term_series])\\\n                             /self.SHORT_TERM_TIMESPAN\n```", "```py\nclass Stock:\n    LONG_TERM_TIMESPAN = 10\n    SHORT_TERM_TIMESPAN = 5\n\n    def __init__(self, symbol):\n        self.symbol = symbol\n        self.history = TimeSeries()\n\n    def update(self, timestamp, price):\n        if price < 0:\n            raise ValueError(\"price should not be negative\")\n        self.history.update(timestamp, price)\n```", "```py\ndef get_crossover_signal(self, on_date):\n    cpl = []\n    for i in range(11):\n        chk = on_date.date() - timedelta(i)\n        for price_event in reversed(self.price_history):\n            if price_event.timestamp.date() > chk:\n                pass\n            if price_event.timestamp.date() == chk:\n                cpl.insert(0, price_event)\n                break\n            if price_event.timestamp.date() < chk:\n                cpl.insert(0, price_event)\n                break\n\n    # Return NEUTRAL signal\n    if len(cpl) < 11:\n        return 0\n\n    # BUY signal\n    if sum([update.price for update in cpl[-11:-1]])/10 \\\n            > sum([update.price for update in cpl[-6:-1]])/5 \\\n        and sum([update.price for update in cpl[-10:]])/10 \\\n            < sum([update.price for update in cpl[-5:]])/5:\n                return 1\n\n    # BUY signal\n    if sum([update.price for update in cpl[-11:-1]])/10 \\\n            < sum([update.price for update in cpl[-6:-1]])/5 \\\n        and sum([update.price for update in cpl[-10:]])/10 \\\n            > sum([update.price for update in cpl[-5:]])/5:\n                return -1\n\n    # NEUTRAL signal\n    return 0\n```", "```py\ndef get_crossover_signal(self, on_date):\n    long_term_ma = MovingAverage(self.history, self.LONG_TERM_TIMESPAN)\n    short_term_ma = MovingAverage(self.history, self.SHORT_TERM_TIMESPAN)\n\n    try:\n        if self._is_crossover_below_to_above(\n                on_date,\n                short_term_ma,\n                long_term_ma):\n            return StockSignal.buy\n\n        if self._is_crossover_below_to_above(\n                on_date,\n                long_term_ma,\n                short_term_ma):\n            return StockSignal.sell\n    except NotEnoughDataException:\n        return StockSignal.neutral\n\n    return StockSignal.neutral\n```"]