- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance, Optimization, and Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters of the book, we have created a full stack application
    from scratch, starting with building and creating a REST API using Django and
    Django REST Framework and then creating a web interface with React to communicate
    with the API we created. We have also deployed applications on services such as
    AWS EC2 and AWS S3\. However, we need to further investigate some important aspects
    of having an application deployed on the internet, such as performance checks,
    query optimization, frontend optimization, and finally, security aspects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to create a performant API with fewer SQL
    queries and faster API responses, how to serve the API and the React frontend
    over HTTPS using AWS CloudFront, and how to log out users using the API. In this
    chapter, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Revoking JWT tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the deployment of a React application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing deployed applications with HTTPS with AWS CloudFront
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you need to have an active AWS account with access to services
    such as S3, EC2, and CloudFront. You can also find the code for this chapter at:
    [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap16](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap16).'
  prefs: []
  type: TYPE_NORMAL
- en: Revoking JWT tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have implemented an authentication system using **JSON Web
    Tokens** (**JWTs**), and because it is a stateless authentication system, most
    of the authentication flow is handled by the frontend. If we want to log the user
    out of the Postagram React application, we must clear the tokens from the local
    storage of the browser, and the user is automatically redirected to the login
    page. But even if the tokens are deleted from the browser, they are still active.
  prefs: []
  type: TYPE_NORMAL
- en: The refresh tokens have a longer life period, so if a hacker gets their hands
    on a refresh token, they can still request access tokens and make HTTP requests
    using someone else’s identity. To avoid that, we will add a logout feature to
    invalidate access and refresh tokens from the server side.
  prefs: []
  type: TYPE_NORMAL
- en: The package used to add JWT authentication on the Django REST API (`djangorestframework-simplejwt`)
    supports blacklisting tokens, and that is the perfect feature we need here. Let’s
    set up the required configurations for the logout feature, and let’s add the feature
    to the Django REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a logout endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will write some code on the Django application to add an
    endpoint for logout:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `settings.py` file of the project, add the following entry to the `INSTALLED_APPS`
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After that, create a file called `logout.py` in the `core/auth/viewsets` directory.
    This file will contain the code for the `viewsets` and the logic to blacklist
    a token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, add the required imports and define the `LogoutViewSet` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/auth/viewsets/logout.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The logout endpoint will only accept `POST` requests, as the client will be
    required to pass a refresh token within the body of the `POST` request. We also
    specify that only authenticated users have permission to access this endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the `create` method of the `LogoutViewSet` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/auth/viewsets/logout.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we ensure that the refresh token is present in the body
    of the request. Otherwise, we raise an error. Once the verification is done, we
    encapsulate the blacklisting logic in a `try/except` block:'
  prefs: []
  type: TYPE_NORMAL
- en: If the token is valid, then the token is blacklisted, and we return a response
    with a `204 HTTP` status code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is an error related to the token, then the token is invalid, and we
    return a validation error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s not forget to add the newly created `ViewSet` in the `routers.py` file
    and register a new route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/routers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! To follow best practices for building software, we must add a test for
    the newly added route in the `core/auth/tests.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/auth/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we log in to retrieve a refresh token and force the authentication
    for the user so we can access the logout endpoint. After that, we ensure that
    we have returned the right status code when the logout is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests using the `pytest` command. If you are using Docker, then you
    can run the tests using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the logout endpoint ready, we can now make some modifications to the authentication
    logic (mostly the logout logic) in the React application.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the logout with React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already handled the logout on the React application to a certain extent
    by just deleting the tokens from the local storage. There is nothing big to modify
    here, we will just add a function to make a request to the API, and if this request
    is successful, we will delete the tokens and the user from the local storage of
    the browser. The current logout logic on the React application is handled in the
    `NavigationBar` component:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/NavBar.jsx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `useActions` Hook function, let’s tweak the `logout` method to make
    an API call before deleting the user:'
  prefs: []
  type: TYPE_NORMAL
- en: src/hooks/user.actions.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is done, let’s create a function in the `NavigationBar` component to
    handle the cases when there is an error from the API. We will display a toast
    HTML bloc on the page with the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/NavBar.jsx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Great! Our full stack application now supports logout. In the next section,
    we will discuss a recurrent topic when deploying a project online, caching.
  prefs: []
  type: TYPE_NORMAL
- en: Adding caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software computing, caching is the process of storing copies of files in
    a cache so they can be accessed more quickly. A **cache** is a temporary storage
    location that stores data, files, and information concerning software that is
    regularly requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great example and explanation of caching comes from Peter Chester, who asked
    the audience at one of his speeches: *“What’s 3,485,250 divided by 23,235?” Everyone
    fell silent for a moment, but someone pulled a calculator and yelled out the answer
    “150!”*. Then, Peter Chester asked the same question again, and this time, everyone
    was able to answer the question immediately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a great demo of the concept of caching: *The computation is only done
    once by the machine and then saved in quick memory for* *faster access*.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a concept used widely by companies and primarly social media websites
    where millions of users access the same posts, videos, and files. It would be
    very primitive to hit the database whenever millions of people want to access
    the same information. For example, if a tweet is gaining traction on Twitter,
    it is automatically moved to cache storage for quick access. And, if you have
    an influencer such as Kim Kardashian posting a picture on Instagram, you should
    expect a lot of requests for this picture. Thus caching can be useful here to
    avoid thousands of queries on the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recapitulate, caching brings the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduced load time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduced bandwidth usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduced SQL queries on databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduced downtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an idea about caching and its benefits, we can implement the
    concept using Django and even Docker. But before that, let’s quickly discuss the
    complexity caching brings to your application.
  prefs: []
  type: TYPE_NORMAL
- en: The cons of caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You already know the advantages of using caching, mostly if your application
    is scaling or you want to improve load time and reduce costs. However, caching
    introduces some complexity to your system (it can also depend on the type of application
    you are developing). If your application is based on news or feeds, you might
    be in trouble, as you will need to define a good architecture for caching.
  prefs: []
  type: TYPE_NORMAL
- en: On the one hand, you have the chance to reduce load times by showing your users
    the same content for a period, but at the same time, your users might miss updates
    and maybe some important updates. Here, cache invalidation comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache invalidation is the process of declaring cached content as invalid or
    stale. The content is invalidated, as it is no longer marked as being the most
    up-to-date version of a file. There are some methods available to invalidate a
    cache, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Purge (flush)**: Cache purging instantly removes the content from the cache.
    When the content is requested again, it is stored in the memory cache before returning
    it to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refresh**: A cache refresh consists of refreshing the same content from the
    server and replacing the content stored in the cache with the new version fetched
    from the server. This is done in the React application using **state-while-revalidate**
    (**SWR**). Each time a post is created, we call a refresh function to fetch data
    again from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ban**: A cache ban does not remove content from the cache immediately. Rather,
    the content is marked as blacklisted. Then, when the client makes a request, it
    is matched with the blacklist content, and if a match is found, new content is
    fetched again and updated in the memory cache before returning to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the cons of caching and how to invalidate the cache understood, you are
    well equipped to add caching to the Django application. In the next section, let’s
    add caching to the Django API of Postagram.
  prefs: []
  type: TYPE_NORMAL
- en: Adding caching to the Django API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous paragraphs, we have explored caching, its advantages, and the
    cons of the concept. Now, it’s time to implement caching within our Django application.
    Django provides useful support for caching, which makes the configuration of caching
    within Django straightforward. Let’s start by making the required configurations
    depending on your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Django for caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using caching within Django requires configuring a memory cache. For the quickest
    read and write access, it is better to use a different data storage solution from
    SQL databases as SQL databases are known to be slower than memory databases (again,
    it depends on your needs). In this book, we will use Redis. Redis is an open source,
    in-memory data store used as a database, cache, streaming engine, and message
    broker.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll review the configurations you need to make to start using Redis in your
    Django project, whether you are using Docker or not. However, for the deployment,
    we’ll use Docker for configuring Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you are not going to use Docker, you can install Redis using the following
    link: [https://redis.io/download/](https://redis.io/download/).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are working in a Linux environment, you can check whether the service
    is running using the `sudo service redis-server status` command. If the service
    is not active, use the `sudo service redis-server start` command to start the
    Redis server. If you are using Windows, you will need to install or enable WSL2\.
    You can read more at: [https://redis.io/docs/getting-started/installation/install-redis-on-windows/](https://redis.io/docs/getting-started/installation/install-redis-on-windows/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation on your machine, you can configure caching in Django
    using the `CACHES` setting in the `settings.py` file of the Django project:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration will require the installation of a Python package called
    `django-redis`. Install it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are working with Docker, you just need to add the following configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `django-redis` package to the `requirements.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: requirements.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `docker-compose.yaml` configuration. We will add a new image in the
    Docker configuration to make sure that the Django application requires `redis-server`
    to be ready before the API service starts running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: docker-compose.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Add the following custom backend in the `settings.py` file of the Django
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You will notice here that we are using `redis` as the host instead of `127.0.0.1`.
    This is because, with Docker, you can use the name of the service as a host. This
    is a better solution; otherwise, you will have to configure a static IP address
    for the services.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about assigning a static IP address to your containers
    with Docker, you can read the following resource: [https://www.howtogeek.com/devops/how-to-assign-a-static-ip-to-a-docker-container/](https://www.howtogeek.com/devops/how-to-assign-a-static-ip-to-a-docker-container/).'
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now that we have configured Django for caching, let’s build the caching
    system for the Postagram application.
  prefs: []
  type: TYPE_NORMAL
- en: Using caching on the endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Caching depends a lot on the business requirements for how much time you want
    to cache the data. Well, Django provides many levels for caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Per-site cache**: This enables you to cache your entire website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template fragment cache**: This enables you to cache some components of the
    website. For example, you can decide to only cache the footer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Per-view cache**: This enables you to cache the output of individual views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-level cache**: Django provides an API you can use for interacting directly
    with the cache. It is useful if you want to produce a certain behavior based on
    a set of actions. For example, in this book, if a post is updated or deleted,
    we will update the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a better idea about the levels of caching Django provides,
    let’s define the caching requirements for the Postagram API.
  prefs: []
  type: TYPE_NORMAL
- en: Our requirement is if there is a delete or an update on a comment or a post,
    the cache is updated. Otherwise, we return the same information in the cache to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved in many ways. We can use Django signals or directly add
    custom methods to the manager of the model’s `Post` and `Comment` classes. Let’s
    go with the latter. We will surcharge the `save` and `delete` methods of the `AbstractModel`
    class, so if there is an update on a `Post` or `Comment` object, we update the
    cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `core/abstract/models.py` file, add the following method on top
    of the file after the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: core/abstract/models.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The function in the preceding code takes an application label, and according
    to the value of this `app_label`, we invalidate the corresponding cache. For the
    moment, we only support caching for posts and comments. Notice how the name of
    the function is prefixed with a `_`. It is a coding convention to specify that
    this method is private and should not be used outside the file where it is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `AbstractModel` class, we can surcharge the `save` method. Before
    the `save` method is executed, we invalidate the cache. It means that on operations
    such as `create` and `update`, the cache will be reset:'
  prefs: []
  type: TYPE_NORMAL
- en: core/abstract/models.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we retrieve `app_label` from the `_meta` attribute on
    the model. If it corresponds to either `core_post` or `core_comment`, we invalidate
    the cache, and the rest of the instructions can proceed. Let’s do the same for
    the `delete` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Core/abstract/models.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Great. The cache invalidation logic has been implemented on the models. Let’s
    add the logic for cache data retrieving on the viewsets of the `core_post` application
    and the `core_comment` application.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from the cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cache invalidation is ready, so we can freely retrieve data from the cache
    on the endpoints for the posts and the comments. Let’s start with `PostViewSet`
    as the portion of code that will be written on `PostViewSet` and `CommentViewSet`
    will be the same. As a small exercise, you can write the logic for retrieving
    the cache for the comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `PostViewSet` class, we will rewrite the `list()` method. On the
    **Django REST framework** (**DRF**) open source repository, the code looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, a `queryset` call is made to retrieve the data, and
    then this `queryset` call is paginated, serialized, and returned inside a `Response`
    object. Let’s tweak the method a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, instead of doing a lookup on the database directly, we
    check the cache. If `post_objects` is `None` when making a query to the database,
    save `queryset` in the cache and finally proceed to return the cache objects to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the process is very simple. You just need to have a robust
    caching strategy. You can do the same for `CommentViewSet` as an exercise. You
    can check the code at this link to compare your results: [https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/chap16/core/comment/viewsets.py](https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/chap16/core/comment/viewsets.py).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have explored the benefits of caching, and we have implemented
    caching in the Django application. In the next section, we will see how to optimize
    the React build using tools such as `webpack`.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the React application build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we successfully built the React application and made
    the deployment on AWS S3\. However, we could have done better in terms of optimization
    and performance. In this section, we will use the famous webpack module builder
    to optimize the React build of Postagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of advantages of using webpack in React:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It speeds up development and build times**: Using webpack in development
    enhances the speed of fast reload of React.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It provides minification**: Webpack automatically minimizes the code without
    changing the functionalities. This results in a faster load on the browser side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code splitting**: Webpack converts JavaScript files into modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It eliminates dead assets**: Webpack only builds the images and CSS that
    your code uses and needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by integrating webpack into the project.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to integrate webpack into your project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the React project, run the following command to add the `webpack` and
    `webpack-cli` packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the installation is done, modify the `package.json` scripts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: package.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Also, we need to install Babel, which is a JavaScript compiler that converts
    next-generation JavaScript code into browser-compatible JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the React project, Babel will convert the React components, the ES6 variables,
    and JSX code to regular JavaScript so old browsers can render the components correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`babel-loader` is the webpack loader for Babel, `babel/preset-env` compiles
    with JavaScript to ES5, and `babel/preset-react` is for compiling JSX to JS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then create a new file called `.babelrc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then create a new file called `webpack.config.js`. This file will contain the
    configurations for webpack. Before writing the configuration, add some plugins
    for optimizing HTML, CSS, and copy files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then add the following configuration on `webpack.config.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: webpack.config.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code above tells webpack to send all files in `.js` and `.jsx`
    through `babel-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add another configuration called `resolve` to generate all the possible
    paths to the module. For example, webpack would then proceed to look up each of
    those paths until it finds a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: webpack.config.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add the configuration for the plugins we will use in this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: webpack.config.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added plugin configurations for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`html-loader`: This will send the HTML files through `html-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy`: This will copy the content of the public file to the `dist` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`define`: This plugin declares the `process` object so we can access environment
    variables in the production environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once it is done, run the `build` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Webpack will take control and build the React application in the `dist` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – The content of the dist directory](img/Figure_16.01_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – The content of the dist directory
  prefs: []
  type: TYPE_NORMAL
- en: Great! You can push the changes made to GitHub, and the code will be deployed
    on AWS S3\. To make the testing and build faster, we will change the package manager
    from `yarn` to `pnpm`. The next section is optional, but it will help you with
    a faster build for your React application.
  prefs: []
  type: TYPE_NORMAL
- en: Using pnpm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pnpm` is a replacement for the `npm` JavaScript package manager, which is
    built on top of `npm`, and is much faster and more efficient. It provides advantages
    such as disk space efficiency, improved speed, and better security. The `pnpm`
    package manager is the one to use if you want to spend less time building and
    making cuts to the minutes spent on the GitHub Actions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install `pnpm` on our machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can generate a `pnpm-lock.yaml` file. We can generate this file
    from another manager’s lock file, in our case, from the `yarn.lock` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 16.2 – Result of pnpm import](img/Figure_16.02_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – Result of pnpm import
  prefs: []
  type: TYPE_NORMAL
- en: 'A new file will be generated in the directory of the React project. Then, modify
    the `deploy-frontend.yml` file to configure for `pnpm` usage:'
  prefs: []
  type: TYPE_NORMAL
- en: .github/workflows/deploy-frontend.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After that, just replace `yarn` with `pnpm` in the `deploy-frontend.yml` file.
    You will notice a faster build for the React application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have covered pnpm and webpack and how they can boost the
    performance of the React application. In the next section, we will learn how to
    secure HTTP requests using AWS CloudFront.
  prefs: []
  type: TYPE_NORMAL
- en: Securing deployed applications with HTTPS with AWS CloudFront
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we have deployed the backend and the frontend on AWS S3, the applications
    are served through HTTP. Basically, our full stack application is not secured
    on the internet, and we are vulnerable. According to the **Open Web Application
    Security Project** (**OSWAP**) description of Insecure Transport ([https://owasp.org/www-community/vulnerabilities/Insecure_Transport](https://owasp.org/www-community/vulnerabilities/Insecure_Transport)),
    our application is vulnerable to the following attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Attacks targeting login credentials, session IDs, and other sensitive information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing **Secure Sockets Layer** (**SSL**) protocol by entering HTTP instead
    of HTTPS at the beginning of the URL in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending non-protected URLs of authentication pages to users to trick them into
    authenticating via HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS EC2 and AWS S3 don’t serve content through HTTPS by default. But AWS also
    has a service called CloudFront that can help you serve your applications via
    HTTPS, plus it also makes the content available globally.
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS CloudFront** is a content delivery network service, and in the next section,
    we will configure the AWS S3 bucket hosting the React application with AWS Cloudfront.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the React project with CloudFront
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to configure our React project with CloudFront:'
  prefs: []
  type: TYPE_NORMAL
- en: On the AWS dashboard, select the **CloudFront** service in the AWS console and
    click on **Create Distribution**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the origin of your website hosted on AWS and paste it into the **Origin
    domain** name field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.3 – Origin configuration of the CloudFront distribution](img/Figure_16.03_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – Origin configuration of the CloudFront distribution
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, configure the default cache behaviors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.4 – Viewer configuration of the CloudFront distribution](img/Figure_16.04_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – Viewer configuration of the CloudFront distribution
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the cache configuration is done, create the distribution. AWS will take
    some time to create the distribution and once it is done, click on the distribution
    **ID** field to copy the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.5 – List of the CloudFront distribution](img/Figure_16.05_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – List of the CloudFront distribution
  prefs: []
  type: TYPE_NORMAL
- en: 'Once **Status** changes to **Enabled**, click on the distribution **ID** field
    to access more details about the distribution and copy the distribution domain
    name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 16.6\uFEFF – Details about the created CloudFront distribution](img/Figure_16.06_B18221.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 – Details about the created CloudFront distribution
  prefs: []
  type: TYPE_NORMAL
- en: The CloudFront distribution URL will return the React application over HTTPS.
    Great, the React application is secured on the internet and well distributed worldwide.
    Great! We have successfully secured our application over HTTPS using AWS CloudFront.
    From now, you can build a full stack application with Django and React, assure
    code quality with tests and linting, automate **continuous integration** and **continuous
    delivery** (**CI/CD**) pipelines using GitHub Actions and use AWS services such
    as S3, EC2, and CloudFront to deploy and serve your web application around the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered some important points about optimizations and
    security. We have implemented a logout endpoint to blacklist tokens, added caching
    to the Django application using Redis, optimized the backend build using webpack,
    and secured the full stack application over HTTPS using AWS CloudFront. And that’s
    the final touch of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered how to build a powerful and robust full stack application using
    Django and React. We have covered how to create a project from scratch, build
    an API secured with JWT tokens, build a frontend application with React and Bootstrap,
    and deploy the applications on AWS. We have explored Docker and tools such as
    GitHub Actions to make the development and deployment process secure, faster,
    and automated. You can now build and deploy a full stack application using Django
    and React!
  prefs: []
  type: TYPE_NORMAL
- en: We are now at the end of this book, and if you are looking for best practices
    and what to learn next, feel free to go through the *Appendix* directly after
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is AWS CloudFront?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the cache invalidation strategies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is logging important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every successful application will eventually need to scale, and this process
    can cause resource issues and more optimization problems. In this appendix, I
    will list what you can read to deepen your studies after this book so you can
    become a better full stack developer.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logging is the action of collecting information about an application as it performs
    different tasks or events. In the development process of an application, if you
    have a bug, you can use `print()` or `console.log()` to identify the issues. Even
    better, with `DEBUG` as `true` in Django, you have access to the whole traceback
    of a `500` error. Once your project deployed in production, this is no longer
    the case. You can implement logging in files using the default logging package
    provided by Python; Django has full support that you can explore in the official
    documentation at [https://docs.djangoproject.com/en/4.1/topics/logging/](https://docs.djangoproject.com/en/4.1/topics/logging/).
    If you are looking to get real-time notifications when you have a `500` error,
    you can connect your backend to services such as Sentry, Datadog, or Bugsnag.
  prefs: []
  type: TYPE_NORMAL
- en: Database queries optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Django ORM is a very flexible and powerful tool, and it can be used well
    or badly. Databases are important in your full stack applications and the fewer
    queries you make, the better it is for the high availability of the SQL database.
    Django provides many methods you can study and explore if you need to optimize
    database queries. You can read more at [https://docs.djangoproject.com/en/4.1/topics/db/optimization/](https://docs.djangoproject.com/en/4.1/topics/db/optimization/).
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are deploying a web application on the internet, it’s important to ensure
    that you have a secure application. In the beginning, you don’t really need a
    lot, but you do need to ensure that your system is secured against the top 10
    threats listed by OWASP. You can learn more about this at the following link:
    [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/).'
  prefs: []
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Representational State Transfer** (**REST**) API is a web architecture and
    a set of constraints that provide simple interfaces to interact with resources,
    allowing clients to retrieve or manipulate them using standard HTTP requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Django is a Python web framework that enables the fast development of secure
    and maintainable websites. It follows the **Model-View-Controller** (**MVC**)
    architectural pattern and emphasizes reusability and pluggability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a Django project, you need to have Django installed on your OS. Once
    you have it installed, you can use the following command to create a new Django
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**django-admin startproject DjangoProject**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding command will create a Django project with the name `DjangoProject`
  prefs: []
  type: TYPE_NORMAL
- en: Migrations are Django’s way of synchronizing changes you make to your models
    (adding a field, deleting a model, etc.) into your database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A virtual environment in Python is a tool to keep the dependencies required
    by different projects in separate places by creating isolated python virtual environments
    for them. This is useful in case of different projects and when you want to avoid
    conflicting dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON Web Token** (**JWT**) is a JSON object meant of representing claims
    to be transferred between two parties. JWT is often used to authenticate users
    in REST APIs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Django Rest Framework** (**DRF**) is a third-party package for Django that
    makes it easy to build, test, debug, and maintain RESTful APIs written using the
    Django framework.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Django model is a Python class that represents a database table, and it defines
    the fields and behaviors of the data you’re storing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serializers in DRF are used to convert complex data types, such as Django model
    instances or QuerySets, into JSON, XML, or other content types. Serializers also
    provide deserialization, which allows parsed data to be converted back into complex
    types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Viewsets in DRF are classes that provide actions on model-backed resources.
    Viewsets are built on top of Django’s class-based views and provide actions like
    `list`, `create`, `update`, and `delete`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DRF routers provide a simple, quick, and consistent way of wiring viewsets to
    URLs. It allows you to automatically generate the URL conf for your API views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A refresh token is a token that is issued by an authentication server and is
    used to obtain a new access token. Refresh tokens are used to keep the user authenticated
    indefinitely, by periodically obtaining a new access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some common database relationships in relational databases are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**One-to-one**: This relationship is used when one record in a table is related
    to only one record in another table.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-to-many**: This relationship is used when one record in a table is related
    to multiple records in another table.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many-to-many**: This relationship is used when multiple records in one table
    are related to multiple records in another table.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Django REST permissions are used to control access to specific actions on specific
    viewsets. They can be used to restrict who can view, add, change, or delete data
    in your REST API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In DRF, you can use the `LimitOffsetPagination` class to paginate the results
    of an API response. To use this class, you can include it in `REST_FRAMEWORK`
    in the `settings.py` file of your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use the Django shell, you need to open the command line in the root directory
    of your Django project, and then run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**python manage.py shell**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A nested route is a URL endpoint that represents a relationship between two
    or more resources. For example, in a social media application, you might have
    a route for all posts and another route for a specific post’s comments. The comments
    route would be nested within the post route, allowing you to access the comments
    for a specific post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`drf-nested-routers` is a package for DRF that allows you to easily create
    nested routes for your API. It automatically creates the appropriate URLs for
    related resources and allows you to nest your views within other views.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `partial` attribute on the `ModelSerializer` can help you determine whether
    the user is submitting all the fields of the resource on an HTTP request for mutating
    like `PUT`, `PATCH`, or `DELETE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a process of verifying that a system or software behaves in the way
    that it is expected to. Testing can be done manually or automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A unit test is a test that verifies the functionality of a small and isolated
    piece of code, usually a single function or a method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The testing pyramid is a concept that describes the balance between different
    types of tests in a software project. It suggests that most of the tests should
    be unit tests, which are fast and isolated, followed by a smaller number of integration
    tests, which test the interactions between different units of code, and a small
    number of end-to-end tests, which test the entire system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pytest is a popular testing framework for Python that makes it easy to write
    small, focused unit tests and provides many useful features such as test discovery,
    test parametrization, fixtures, and powerful and expressive assertion syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Pytest fixture is a way to provide data or set up resources that are needed
    for your tests. Fixtures are defined using the `@pytest.fixture` decorator and
    can be passed as arguments to test functions, allowing you to write more expressive
    and maintainable tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. It allows
    developers to run JavaScript on the server side to build fast and scalable network
    applications. Yarn is a package manager for Node.js, like npm but it is faster
    and more secure and provides a more consistent experience across different environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Frontend development is the process of building the user interface of a software
    application. In web development, it involves using languages such as **HTML**,
    **CSS**, and **JavaScript** to create the visual elements, layout, and functionality
    of a website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To install Node.js, you can download the installer package from the official
    Node.js website ([https://nodejs.org/](https://nodejs.org/)) and then run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS Code**) is a free, open-source code editor developed
    and maintained by Microsoft. It is a popular choice among developers for its support
    for multiple languages, debugging, and integrated Git control.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In VS Code, you can install extensions by clicking on the **Extensions** icon
    in the **Activity Bar** on the side of the editor, or by typing *Ctrl* + *Shift*
    + *X* (*Cmd* + *Shift* + *X* on macOS) to open the **Extensions** pane. You can
    then search for and install any installation you need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hot reloading is a feature that allows you to see the changes you make to your
    code immediately in the browser, without having to manually refresh the page.
    This makes development faster and more efficient, as you can see the effects of
    your changes in real-time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a React application with `create-react-app`, you first need to have
    Node.js and yarn installed on your OS. Then, you can use `yarn` to create a new
    React application by running the following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**yarn create react-app my-app**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`localStorage` is an API provided by web browsers that allow developers to
    store `localStorage` persists even when the browser is closed, or the computer
    is restarted.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`React-Router` is a popular library for client-side routing in React. It allows
    you to declaratively map your application’s component structure to specific URLs,
    making it easy to navigate between pages and manage the browser history'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To configure a protected route in React, you can use React-Router’s `<Route>`
    component along with a **higher-order component** (**HOC**) or a custom Hook that
    checks if the user is authenticated before rendering the protected component.
    For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A React Hook is a special function that allows you to use state and other React
    features in a functional component. Hooks were introduced in React 16.8 to make
    it easier to write and manage stateful logic in functional components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some examples of React Hooks are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`useState`: allows you to add a state to a functional component.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useEffect`: allows you to run side effects such as fetching data or subscribing
    to an event in a functional component.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useContext`: allows you to access the context values from a functional component.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two rules of React Hooks are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only call Hooks at the top level. Don’t call Hooks inside loops, conditions,
    or nested functions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only call Hooks from React function components. Don’t call Hooks from regular
    JavaScript functions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A modal is a dialog box/pop-up window that is displayed on top of the current
    page. Modals are used to display content that requires the user’s attention or
    input, such as forms, images, videos, or alerts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In React, a `props` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `children` element in React is a special prop that is used to pass content
    between elements. It is used to nest UI elements inside of other elements, and
    it can be accessed using the `props.children` property inside of the parent component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A wireframe is a simplified visual representation of a web page or application,
    used to communicate the layout, structure, and functionality of a user interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `map` method is an array method in JavaScript that is used to iterate over
    an array and create a new array with the results of a function applied to each
    element of the original array. It can also be used in JSX to map over an array
    and create a new set of elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `mutate` method on SWR objects allows you to programmatically update the
    data in the cache, without waiting for the revalidation to happen. The `mutate`
    method triggers a re-render on the components that are using the data in the cache,
    updating the UI to reflect the new data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useParams` Hook is a built-in Hook in React Router that allows you to access
    the dynamic parameters passed in the URL of a route. It returns an object containing
    the **key-value** pairs of the parameters in the parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In React, you can write a route that can support parameter passing by using
    the `:` syntax in the path of the route. For example, you can have `post/:postId`
    where `postId` is an URL parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `useContext` Hook is a built-in hook in React that allows you to access
    a context value within a functional component. This can be useful for sharing
    data across multiple components without having to pass props down through multiple
    levels of the component tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FormData` object is a built-in JavaScript object that allows you to construct
    and send `multipart/form-data` requests. It can be used to upload files or other
    forms of binary data, as well as to send `FormData` object can be passed as the
    body of an `XMLHttpRequest` or `fetch` request, and it will automatically set
    the appropriate `Content-Type` header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Django, the `MEDIA_URL` setting is used to specify the URL at which user-uploaded
    media files will be served.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `MEDIA_ROOT` setting in Django is used to specify the filesystem path where
    user-uploaded media files will be stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `render` method of the `render` method can be used to test the behavior
    and output of a component in a real-world-like environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jest is a JavaScript testing framework that allows you to write and run unit
    tests for JavaScript code, including React components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `data-testid` attribute is a special attribute that allows you to add an
    identifier to an element for the purpose of testing. This attribute can be used
    to query the element in a test and make assertions about its state or behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some drawbacks of snapshot testing are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Snapshots can become stale over time as the component changes, and they need
    to be updated manually.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapshot tests can be difficult to understand, as they often show the entire
    component tree, which can be large and complex.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To trigger user events in a React test suite, you can use React Testing Library
    `fireEvent` and `userEvent` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Git, a branch is a separate line of development that allows one or multiple
    developers to work on different features or bug fixes simultaneously without interfering
    with each other’s work. Branches are also used to isolate changes and make it
    easy to merge them back into the main codebase or branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git is a **version control system** (**VCS**) that allows developers to track
    changes in their code over time, collaborate with others, and revert to previous
    versions if needed. GitHub is a web-based hosting service for Git repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An HTTP Host header attack is a type of web application attack that exploits
    a vulnerability in the way some web servers handle the HTTP Host header. The HTTP
    Host header is used to specify the domain name of the website that the user is
    trying to access. By manipulating the Host header, an attacker can trick a vulnerable
    web server into serving content from a different domain, potentially exposing
    sensitive information, or allowing the attacker to perform actions on the user’s
    behalf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Django, the `SECRET_KEY` setting is used to provide a secret key that is
    used to secure certain aspects of the Django framework, such as session management,
    password hashing, and the generation of cryptographic signatures. As it is a sensible
    piece of information, the value should be stored using environment variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a platform for developing, shipping, and running applications that
    uses containerization technology to package an application and its dependencies
    into a single, portable container that can run on any platform that supports Docker.
    Containers provide a lightweight, isolated environment for running applications,
    which makes it easy to move them between development, staging, and production
    environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Compose is a tool for defining and running multi-container Docker applications.
    It allows you to use a single `docker-compose.yml` file to configure and start
    multiple services (containers) that make up your application. This makes it easy
    to manage the dependencies and configuration of a complex application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main difference between Docker and Docker Compose is that Docker is a platform
    for creating, shipping, and running containers, while Docker Compose is a tool
    for defining and running multi-container applications. Additionally, Docker Compose
    relies on Docker to create and run the containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Virtualization is a technology that allows you to run multiple operating systems
    on a single physical machine, by creating virtual machines that emulate the hardware
    of a physical computer. Each virtual machine runs its operating system, and applications
    running inside the virtual machines are isolated from each other. Containerization
    is a technology that allows you to package an application and its dependencies
    into a single, portable container that can run on any platform. Containers are
    lightweight, isolated environments that share the host operating system kernel,
    which makes them faster and more efficient than virtual machines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An environment variable is a value that can be passed to an operating system
    or application at runtime. It allows you to configure system-wide settings or
    to pass information to an application without hard-coding it in the source code.
    Environment variables can be used to set configuration options, such as the location
    of a file or the value of a secret key, and they can be easily changed without
    modifying the application’s code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The differences between **Continuous Integration** (**CI**) and **Continuous
    Deployment** (**CD**) are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CI is a software development practice in which developers integrate code into
    a shared repository multiple times a day. Each integration is verified by an automated
    build and test process to catch errors early.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CD is an extension of CI that goes a step further and automatically deploys
    the code changes to production after they pass the automated build and test process.
    The goal of CD is to make sure that the code is always in a releasable state and
    to shorten the time between code being written and it being available to end-users.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions is a feature provided by GitHub that allows developers to automate
    their software development workflows, such as building, testing, and deploying
    code. These workflows are defined in YAML files and can be triggered by various
    events such as a push to a branch, a pull request, or a scheduled time. Developers
    can use GitHub Actions to automate their CI/CD workflows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CD is the practice of automatically building, testing, and deploying code changes
    to different environments after they pass the automated build and test process.
    It is an extension of CI, and the goal is to ensure that the code changes are
    always in a releasable state, so that they can be deployed to production at any
    time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Amazon Simple Storage Service** (**S3**) is an object storage service provided
    by **Amazon Web Services** (**AWS**) that allows you to store and retrieve large
    amounts of data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create an **Identity and Access Management** (**IAM**) user on AWS, you
    can use the AWS Management Console. Here’s an example of how to create an IAM
    user using the AWS Management Console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to the AWS Management Console
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the IAM console.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Navigation** pane, choose **Users** and then choose **Add user**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the username and select the **AWS** **access type**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Permissions**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Add user to a group**, create group, or **Add existing groups** as
    appropriate.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Tags**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Review**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Create user**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The command used to build a React application is `react-scripts build`. This
    command will take all the code and assets in your application and create a production-ready
    build that can be deployed on a web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a Node.js or more specifically a React project, environment variables are
    typically retrieved using the `process.env` object. For example, you can access
    the value of an environment variable named `VARIABLE` using `process.env.VARIABLE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon CloudFront is a **content delivery network** (**CDN**) provided by AWS.
    It allows you to distribute content, such as web pages, images, videos, and more,
    to users across the world by caching the content on servers located in various
    geographic locations. CloudFront can be used to deliver content from a variety
    of origins, such as an S3 bucket or a custom origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are several strategies for cache invalidation in Django:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Per-site cache**: This enables you to cache your entire website.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template fragment cache**: This enables you to cache some components of the
    website. For example, you can decide to only cache the footer.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Per-view cache**: This enables you to cache the output of individual views.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-level cache**: Django provides an API you can use for interacting directly
    with the cache. It is useful if you want to produce a certain behavior based on
    a set of actions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging is important because it allows you to track the activity of your system,
    troubleshoot issues, and gather data for analysis. Logs provide a detailed history
    of what has happened in your system, including events such as user actions, system
    failures, and performance metrics. This information can be used to identify trends,
    detect patterns, and troubleshoot problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
