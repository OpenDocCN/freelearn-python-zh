<html><head></head><body>
<section id="chapter-10-the-functools-module" class="level2 chapterHead" data-number="0.14">&#13;
<h2 class="chapterHead" data-number="0.14"><span class="titlemark"> 10</span><br/>&#13;
<span id="x1-21700010"/>The Functools Module</h2>&#13;
<p>Functional programming<span id="dx1-217001"/> considers functions to be first-class objects. We’ve seen several higher-order functions that accept functions as arguments or return functions as results. In this chapter, we’ll look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> library, which contains some tools to help us implement some common functional design patterns.</p>&#13;
<p>We’ll look at some higher-order functions. This extends the material from <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>. We’ll continue looking at higher-order function techniques in <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator Design Techniques</span></a>, as well.</p>&#13;
<p>We’ll look at the following functions in this module:</p>&#13;
<ul>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">@lru_cache</code></span></span>: These decorators<span id="dx1-217002"/> can be a huge performance<span id="dx1-217003"/> boost for certain types of applications.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">@total_ordering</code></span></span>: This decorator<span id="dx1-217004"/> can help create rich comparison operators. Additionally, it lets us look at the more general question of object-oriented design mixed with functional programming.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span>: This function<span id="dx1-217005"/> creates a new function from a function and some parameter value bindings.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span>: This is a higher-order function<span id="dx1-217006"/> that generalizes reductions such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span>.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">singledispatch()</code></span></span>: This function<span id="dx1-217007"/> allows us to assemble alternative implementations based on the argument type. It saves us from writing the <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement to choose the implementation, keeping the implementations cleanly separated.</p></li>&#13;
</ul>&#13;
<p>We’ll defer two additional members of this library to <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator</span> <span class="cmti-10x-x-109">Design Techniques</span></a>: the <span class="obeylines-h"><span class="verb"><code class="inlineCode">update_wrapper()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">wraps()</code></span></span> functions. We’ll also look more closely at writing our own decorators in the next chapter.</p>&#13;
<div id="tcolobox-219" class="infobox note">&#13;
&#13;
&#13;
<p>We’ll ignore the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cmp_to_key()</code></span></span> function entirely. Its purpose is to help with converting Python 2 code to run under Python 3. Since Python 2 is no longer being actively maintained, we can safely ignore this function.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-217008r219"/></p>&#13;
<section id="function-tools" class="level3 sectionHead" data-number="0.14.1">&#13;
<h3 class="sectionHead" data-number="0.14.1"><span class="titlemark">10.1 </span> <span id="x1-2180001"/>Function tools</h3>&#13;
<p>We looked at a number of higher-order functions in <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order</span> <span class="cmti-10x-x-109">Functions</span></a>. Those functions either accept a function as an argument or return a function (or generator expression) as a result. All those higher-order functions have an essential algorithm that is customized by injecting another function. Functions such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> accept a <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> function to customize their behavior. Functions such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> accept a function and an iterable and apply the given function to the argument iterable. In the case of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function, the results of the function are simply yielded. In the case of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function, the Boolean result of the function is used to yield or reject values from an iterable source.</p>&#13;
<p>All the functions in <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>, are part of the Python <span class="obeylines-h"><span class="verb"><code class="inlineCode">__builtins__</code></span></span> package, meaning these functions are available without the need to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">import</code></span></span> statement. They were made ubiquitous because they seem universally useful. The functions in this chapter must be introduced with an <span class="obeylines-h"><span class="verb"><code class="inlineCode">import</code></span></span> statement because they’re not quite so universally helpful.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function straddles this fence. It was originally built in. After some discussion, it was moved from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__builtins__</code></span></span> package to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> module because of the possibility of really poor performance. Later in this chapter, we’ll see how seemingly simple operations can perform remarkably poorly. <span id="x1-218001r226"/></p>&#13;
</section>&#13;
<section id="memoizing-previous-results-with-cache" class="level3 sectionHead" data-number="0.14.2">&#13;
<h3 class="sectionHead" data-number="0.14.2"><span class="titlemark">10.2 </span> <span id="x1-2190002"/>Memoizing previous results with cache</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">@lru_cache</code></span></span> decorators<span id="dx1-219001"/> transform a given function into a function that might perform<span id="dx1-219002"/> more quickly. <span class="keyWord">LRU </span>means <span class="keyWord">Least Recently</span> <span class="keyWord">Used</span>—a finite pool of recently used items is retained. Items not recently<span id="dx1-219003"/> used are discarded to keep the pool to a bounded size. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> has no storage management<span id="dx1-219004"/> and requires a little bit of consideration to be sure it won’t consume all available memory.</p>&#13;
<p>Since these are decorators, we can apply one of them to any function that might benefit from caching previous results. We can use it as follows:</p>&#13;
<pre id="listing-220" class="lstlisting"><code>from functools import lru_cache &#13;
 &#13;
@lru_cache(128) &#13;
def fibc(n: int) -&gt; int: &#13;
    if n == 0: return 0 &#13;
    if n == 1: return 1 &#13;
    return fibc(n-1) + fibc(n-2)</code></pre>&#13;
<p>This is an example based on <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and Reductions</span></a>. We’ve applied the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@lru_cache</code></span></span> decorator to the naive Fibonacci number calculation. Because of this decoration, each evaluation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fibc(n)</code></span></span> function will now be checked against a cache maintained by the decorator. If the argument value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>, is in the cache, the previously computed result is used instead of doing a potentially expensive re-calculation. Each new collection of argument values and return value updates the cache.</p>&#13;
<p>We highlight this example because the naive recursion is quite expensive in this case. The complexity of computing any given Fibonacci number, <span class="italic">F</span><sub><span class="cmmi-8">n</span></sub> = <span class="italic">F</span><sub><span class="cmmi-8">n</span><span class="cmsy-8">−</span><span class="cmr-8">1</span></sub> + <span class="italic">F</span><sub><span class="cmmi-8">n</span><span class="cmsy-8">−</span><span class="cmr-8">2</span></sub>, involves not merely computing <span class="italic">F</span><sub><span class="cmmi-8">n</span><span class="cmsy-8">−</span><span class="cmr-8">1</span></sub> but also <span class="italic">F</span><sub><span class="cmmi-8">n</span><span class="cmsy-8">−</span><span class="cmr-8">2</span></sub>. This tree of values leads to a complexity in the order of <span class="keyWord">O</span>(2<sup><span class="cmmi-8">n</span></sup>).</p>&#13;
<p>The argument value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">128</code></span></span> is the size of the cache. This is used to limit the amount of memory used for the cache. When the cache is full, the LRU item is replaced.</p>&#13;
<p>We can try to confirm<span id="dx1-219012"/> the benefits empirically<span id="dx1-219013"/> using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">timeit</code></span></span> module. We can execute the two implementations 1,000 times each to see how the timing compares. Using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fib(20)</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">fibc(20)</code></span></span> methods shows just how costly this calculation is without the benefit of caching. Because the naive version is so slow, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">timeit</code></span></span> number of repetitions was reduced to only 1,000. Here are the results (in seconds):</p>&#13;
<ul>&#13;
<li><p>Naive: 3.23</p></li>&#13;
<li><p>Cached: 0.0779</p></li>&#13;
</ul>&#13;
<p>Note that we can’t trivially use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">timeit</code></span></span> module on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fibc()</code></span></span> function. The cached values will remain in place; we’ll only evaluate the complete <span class="obeylines-h"><span class="verb"><code class="inlineCode">fibc(20)</code></span></span> calculation once, which populates values in the cache. Each of the remaining 999 iterations will simply fetch the value from the cache. We need to actually clear the cache between uses of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fibc()</code></span></span> function or the time drops to almost zero. This is done with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">fibc.cache_clear()</code></span></span> method built by the decorator.</p>&#13;
<p>The concept of memoization<span id="dx1-219014"/> is powerful. There are many algorithms that can benefit from memoization of results. Because the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> decorator applies to a function, it means using a functional programming approach can also lead to high-performance software. Functions with side effects are rarely good candidates for memoization; pure functions will work out best.</p>&#13;
<p>We’ll look at one more example of the benefits of caching. This will involve a small computation that also has repeated values. The number of combinations of <span class="italic">p </span>things taken in groups of <span class="italic">r </span>is often stated as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file97.jpg" class="math-display" alt="( ) p = ----p!--- r r!(p− r!) "/>&#13;
</div>&#13;
<p>This binomial function involves computing three factorial values. It might make sense to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> decorator on a factorial function. A program that calculates a number of binomial values will not need to re-compute all of those factorials. For cases where similar values are computed repeatedly, the speedup can be impressive. For situations where the cached values are rarely reused, the overheads of maintaining the cached values may outweigh any speedups.</p>&#13;
<p>We’ve omitted<span id="dx1-219015"/> the details of the actual binomial<span id="dx1-219016"/> function. It’s only one line of code. Caching a built-in function is done like this:</p>&#13;
<pre id="listing-221" class="lstlisting"><code>from functools import cache &#13;
from math import factorial &#13;
 &#13;
factorial = cache(factorial)</code></pre>&#13;
<p>This applies the decorator<span id="dx1-219021"/> to an existing function. For more information on this approach to decoration, see <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator Design Techniques</span></a>.</p>&#13;
<p>When evaluating a binomial function repeatedly, we see the following:</p>&#13;
<ul>&#13;
<li><p>Naive factorial: 0.174</p></li>&#13;
<li><p>Cached factorial: 0.046</p></li>&#13;
</ul>&#13;
<p>It’s important to recognize that the cache is a stateful object. This design pushes the edge of the envelope on purely functional programming. One functional ideal is to avoid changes of state. This concept of avoiding stateful variables is exemplified by a recursive function; the current state is contained in the argument values, and not in the changing values of variables. We’ve seen how tail-call optimization is an essential performance improvement to ensure that this idealized recursion actually works nicely with the available processor hardware and limited memory budgets. In Python, we can do this tail-call optimization manually by replacing the tail recursions with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> loop. Caching is a similar kind of optimization; we must implement it manually as needed, knowing that it isn’t purely functional programming.</p>&#13;
<p>Further, if our design is centered on pure functions—free of side effects—then there are no problems with introducing caching. Applying an <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> decorator to a function that has side effects, for example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">print()</code></span></span> function, will create confusion: we’ll note that evaluations of <span class="obeylines-h"><span class="verb"><code class="inlineCode">print()</code></span></span> with the same argument values won’t produce any output because the result value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>, will be fetched from cache.</p>&#13;
<p>In principle, each call to a function<span id="dx1-219022"/> with a cache has two results: the expected result and a new <span class="obeylines-h"><span class="verb"><code class="inlineCode">cache</code></span></span> object available<span id="dx1-219023"/> for future evaluations<span id="dx1-219024"/> of the function. Pragmatically, in our example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cache</code></span></span> object is encapsulated inside the decorated version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fibc()</code></span></span> function, and it isn’t available for inspection or manipulation.</p>&#13;
<p>Caching is not a panacea. Applications that work with float values might not benefit much from memoization because float values are often approximations. The least-significant bits of a float value should be seen as random noise that can prevent the exact equality test in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@lru_cache</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> decorator from working. <span id="x1-219025r227"/></p>&#13;
</section>&#13;
<section id="defining-classes-with-total-ordering" class="level3 sectionHead" data-number="0.14.3">&#13;
<h3 class="sectionHead" data-number="0.14.3"><span class="titlemark">10.3 </span> <span id="x1-2200003"/>Defining classes with total ordering</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@total_ordering</code></span></span> decorator<span id="dx1-220001"/> is helpful for creating new class definitions that implement a rich set of comparison operators. This might apply to numeric classes that subclass <span class="obeylines-h"><span class="verb"><code class="inlineCode">numbers.Number</code></span></span>. It may also apply to semi-numeric classes.</p>&#13;
<p>As an example of a semi-numeric class, consider a playing card. It has a numeric rank and a symbolic suit. The suit, for example, may not matter for some games. Like ordinary integers, cards have an ordering. We often sum the point values of each card, making them number-like. However, multiplication of cards, <span class="cmti-10x-x-109">card </span><span class="tcrm-1095">× </span><span class="cmti-10x-x-109">card</span>, doesn’t really make any sense; a card isn’t quite like a number.</p>&#13;
<p>We can almost emulate a playing card with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> base class as follows:</p>&#13;
<pre id="listing-222" class="lstlisting"><code>from typing import NamedTuple &#13;
 &#13;
class Card1(NamedTuple): &#13;
    rank: int &#13;
    suit: str</code></pre>&#13;
<p>This model suffers from a profound limitation: all comparisons between cards will include both the rank and the suit. This leads to the following awkward behavior when we compare the two of spades against the two of clubs:</p>&#13;
<pre id="listing-223" class="lstlisting"><code>&gt;&gt;&gt; c2s = Card1(2, ’\u2660’) &#13;
&gt;&gt;&gt; c2h = Card1(2, ’\u2665’) &#13;
&gt;&gt;&gt; c2s &#13;
Card1(rank=2, suit=’♠’) &#13;
&gt;&gt;&gt; c2h &#13;
Card1(rank=2, suit=’♡’) &#13;
 &#13;
# The following is undesirable for some games: &#13;
 &#13;
&gt;&gt;&gt; c2h == c2s &#13;
False</code></pre>&#13;
<p>The default comparison<span id="dx1-220018"/> rule is fine for some games. It does not work well for those games in which comparisons focus on rank and ignore suit.</p>&#13;
<p>For some games, it can be better for the default comparisons between cards to be based on only their rank.</p>&#13;
<p>The following class definition is appropriate for games where the suit isn’t a primary concern:</p>&#13;
<pre id="listing-224" class="lstlisting"><code>from functools import total_ordering &#13;
from typing import NamedTuple &#13;
 &#13;
@total_ordering &#13;
class Card2(NamedTuple): &#13;
    rank: int &#13;
    suit: str &#13;
 &#13;
    def __str__(self) -&gt; str: &#13;
        return f"{self.rank:2d}{self.suit}" &#13;
    def __eq__(self, other: Any) -&gt; bool: &#13;
        match other: &#13;
            case Card2(): &#13;
                return self.rank == other.rank &#13;
            case int(); &#13;
                return self.rank == other &#13;
            case _: &#13;
                return NotImplemented &#13;
    def __lt__(self, other: Any) -&gt; bool: &#13;
        match other: &#13;
            case Card2(): &#13;
                return self.rank &lt; other.rank &#13;
            case int(); &#13;
                return self.rank &lt; other &#13;
            case _: &#13;
                return NotImplemented</code></pre>&#13;
<p>This class extends the <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> class. We’ve provided a <span class="obeylines-h"><span class="verb"><code class="inlineCode">__str__()</code></span></span> method to print a string representation of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Card2</code></span></span> object.</p>&#13;
<p>There are two comparisons defined—one for equality<span id="dx1-220045"/> and one for ordering. A wide variety of comparisons can be defined, and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@total_ordering</code></span></span> decorator handles the construction of the remaining comparisons. In this case, the decorator creates <span class="obeylines-h"><span class="verb"><code class="inlineCode">__le__()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">__gt__()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">__ge__()</code></span></span> from these two definitions. The default implementation of <span class="obeylines-h"><span class="verb"><code class="inlineCode">__ne__()</code></span></span> uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">__eq__()</code></span></span>; this works without using a decorator.</p>&#13;
<p>Both the methods provided in this class allow two kinds of comparisons—between <span class="obeylines-h"><span class="verb"><code class="inlineCode">Card2</code></span></span> objects, and also between a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Card2</code></span></span> object and an integer. The type hint must be <span class="obeylines-h"><span class="verb"><code class="inlineCode">Any</code></span></span> to remain compatible with the superclass definition of <span class="obeylines-h"><span class="verb"><code class="inlineCode">__eq__()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">__lt__()</code></span></span>. It’s clear that it could be narrowed to <span class="obeylines-h"><span class="verb"><code class="inlineCode">Union[Card2,</code><code class="inlineCode"> int]</code></span></span>, but this conflicts with the definition inherited from the superclass.</p>&#13;
<p>First, this class offers proper comparison of only the ranks, as follows:</p>&#13;
<div id="tcolobox-220" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; c2s = Card2(2, ’\u2660’) &#13;
&gt;&gt;&gt; c2h = Card2(2, ’\u2665’) &#13;
&gt;&gt;&gt; c2h == c2s &#13;
True &#13;
 &#13;
&gt;&gt;&gt; c2h == 2 &#13;
True &#13;
&gt;&gt;&gt; 2 == c2h &#13;
True</code></pre>&#13;
&#13;
</div>&#13;
<p>We can use this class for a number of simulations<span id="dx1-220056"/> with simplified syntax to compare ranks of cards. Furthermore, the decorator builds a rich set of comparison operators as follows:</p>&#13;
<div id="tcolobox-221" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; c2s = Card2(2, ’\u2660’) &#13;
&gt;&gt;&gt; c3h = Card2(3, ’\u2665’) &#13;
&gt;&gt;&gt; c4c = Card2(4, ’\u2663’) &#13;
&gt;&gt;&gt; c2s &lt;= c3h &lt; c4c &#13;
True</code></pre>&#13;
&#13;
</div>&#13;
<p>We didn’t need to write all of the comparison method functions; they were generated by the decorator. The decorator’s creation of operators isn’t perfect. In our case, we’ve asked for comparisons with integers as well as between <span class="obeylines-h"><span class="verb"><code class="inlineCode">Card</code></span></span> instances. This reveals some problems.</p>&#13;
<p>Operations such as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">c4c</code><code class="inlineCode"> &gt;</code><code class="inlineCode"> 3</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">3</code><code class="inlineCode"> &lt;</code><code class="inlineCode"> c4c</code></span></span> comparisons would raise <span class="obeylines-h"><span class="verb"><code class="inlineCode">TypeError</code></span></span> exceptions because of the way the operators are resolved to find a class that implements the comparison. This exposes a limitation of the methods created by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@total_ordering</code></span></span> decorator. Specifically, the generated methods won’t have clever type matching rules. If we need type matching in all of the comparisons, we’ll need to write all of the methods. <span id="x1-220063r228"/></p>&#13;
</section>&#13;
<section id="applying-partial-arguments-with-partial" class="level3 sectionHead" data-number="0.14.4">&#13;
<h3 class="sectionHead" data-number="0.14.4"><span class="titlemark">10.4 </span> <span id="x1-2210004"/>Applying partial arguments with partial()</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span> function leads to something<span id="dx1-221001"/> called a <span class="keyWord">partial application</span>.<span id="dx1-221002"/> A partially applied function is a new function built from an old function and a subset of the required argument values. It is closely related to the concept<span id="dx1-221003"/> of <span class="keyWord">currying</span>. Much of the theoretical background is not relevant here, since currying doesn’t apply directly to the way Python functions are implemented. The concept, however, can lead us to some handy simplifications.</p>&#13;
<p>We can look at trivial examples as follows:</p>&#13;
<pre>&gt;&gt;&gt; exp2 = partial(pow, 2)&#13;
&gt;&gt;&gt; exp2(12)&#13;
4096&#13;
&gt;&gt;&gt; exp2(17)-1&#13;
131071&#13;
</pre>&#13;
<p>We’ve created the function <span class="obeylines-h"><span class="verb"><code class="inlineCode">exp2(y)</code></span></span>, which is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pow(2,</code><code class="inlineCode"> y)</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span> function binds the first positional parameter to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pow()</code></span></span> function. When we evaluate the newly created <span class="obeylines-h"><span class="verb"><code class="inlineCode">exp2()</code></span></span> function, we get values computed from the argument bound by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span> function, plus the additional<span id="dx1-221010"/> argument provided to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">exp2()</code></span></span> function.</p>&#13;
<p>The bindings of positional parameters are handled in a strict left-to-right order. Functions that accept keyword parameters can also be provided when building the partially applied function.</p>&#13;
<p>We can also create this kind of partially applied function with a lambda form as follows:</p>&#13;
<div id="tcolobox-222" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; exp2 = lambda y: pow(2, y)</code></pre>&#13;
&#13;
</div>&#13;
<p>Neither is clearly superior. The use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span> can help a reader understand the design intent. The use of a lambda may not have the same explanatory power.</p>&#13;
<p>Partial functions can be very handy in a context where we want to avoid repeating argument values to a function. We may, for example, be normalizing data after computing the mean and standard deviation. These normalized values are sometimes called Z-scores. While we can define a function <span class="obeylines-h"><span class="verb"><code class="inlineCode">z(mean:</code><code class="inlineCode"> float,</code><code class="inlineCode"> stdev:</code><code class="inlineCode"> float,</code><code class="inlineCode"> score:</code><code class="inlineCode"> float)</code><code class="inlineCode"> -&gt;</code><code class="inlineCode"> float:</code></span></span>, this has the clutter of many argument values that don’t change once the mean and standard deviation are known.</p>&#13;
<p>We prefer something like the following example:</p>&#13;
<div id="tcolobox-223" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; m = mean(some_data) &#13;
&gt;&gt;&gt; std = stdev(some_data) &#13;
&gt;&gt;&gt; z_value = partial(z, m, std) &#13;
&gt;&gt;&gt; normalized_some_data = [z_value(x) for x in some_data]</code></pre>&#13;
&#13;
</div>&#13;
<p>The creation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">z_value()</code></span></span> partial function is not – strictly speaking – needed. Having this function can clarify the expression<span id="dx1-221018"/> that creates the <span class="obeylines-h"><span class="verb"><code class="inlineCode">normalized_some_data</code></span></span> object. Using <span class="obeylines-h"><span class="verb"><code class="inlineCode">z_value(x)</code></span></span> seems slightly more readable than <span class="obeylines-h"><span class="verb"><code class="inlineCode">z_value(m,</code><code class="inlineCode"> std,</code><code class="inlineCode"> x)</code></span></span>.</p>&#13;
<p>We’ll return to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span> function in <a href="Chapter_13.xhtml#x1-26600013"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 13</span></a>, <a href="Chapter_13.xhtml#x1-26600013"><span class="cmti-10x-x-109">The PyMonad Library</span></a>, and look at how we can accomplish this same kind of function definition using <span class="cmti-10x-x-109">currying</span>. <span id="x1-221019r229"/></p>&#13;
</section>&#13;
<section id="reducing-sets-of-data-with-the-reduce-function" class="level3 sectionHead" data-number="0.14.5">&#13;
<h3 class="sectionHead" data-number="0.14.5"><span class="titlemark">10.5 </span> <span id="x1-2220005"/>Reducing sets of data with the reduce() function</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> functions are, in a way, all specializations of a more general algorithm expressed<span id="dx1-222001"/> by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function. See <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a> for more on these functions. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function is a higher-order function that folds a binary operation<span id="dx1-222002"/> into each pair of items in an iterable.</p>&#13;
<p>A sequence object is given as follows:</p>&#13;
<div id="tcolobox-224" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; d = [2, 4, 4, 4, 5, 5, 7, 9]</code></pre>&#13;
&#13;
</div>&#13;
<p>The expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce(lambda</code><code class="inlineCode"> x,</code><code class="inlineCode"> y:</code><code class="inlineCode"> x+y,</code><code class="inlineCode"> d)</code></span></span> will fold in <span class="obeylines-h"><span class="verb"><code class="inlineCode">+</code></span></span> operators to the list as if we were evaluating the following:</p>&#13;
<div id="tcolobox-225" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from functools import reduce &#13;
 &#13;
&gt;&gt;&gt; reduce(lambda x, y: x+y, d) &#13;
40 &#13;
&gt;&gt;&gt; 2+4+4+4+5+5+7+9 &#13;
40</code></pre>&#13;
&#13;
</div>&#13;
<p>It can help to include <span class="obeylines-h"><span class="verb"><code class="inlineCode">()</code></span></span> to show the effective left-to-right grouping as follows:</p>&#13;
<div id="tcolobox-226" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; ((((((2+4)+4)+4)+5)+5)+7)+9 &#13;
40</code></pre>&#13;
&#13;
</div>&#13;
<p>Python’s standard interpretation<span id="dx1-222015"/> of expressions involves a left-to-right evaluation of operators. Consequently, a fold left doesn’t involve a change in meaning. Many functional programming languages including<span id="dx1-222016"/> <span class="keyWord">Haskell</span> and <span class="keyWord">OCaml </span>(among many others) offer a fold-right alternative. When used in conjunction with recursion, a compiler can do a number of clever optimizations. This isn’t available in Python; a reduction is always left to right.</p>&#13;
<p>We can also provide an initial value as follows:</p>&#13;
<div id="tcolobox-227" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; reduce(lambda x, y: x+y**2, d, 0) &#13;
232</code></pre>&#13;
&#13;
</div>&#13;
<p>If we don’t supply an initial value, the initial value from the sequence is used as the initialization. Providing an initial value is essential when there’s a <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function as well as a <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function. The following is how the right answer is computed with an explicit <span class="obeylines-h"><span class="verb"><code class="inlineCode">0</code></span></span> initializer:</p>&#13;
<div id="tcolobox-228" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; 0 + 2**2 + 4**2 + 4**2 + 4**2 + 5**2 + 5**2 + 7**2 + 9**2 &#13;
232</code></pre>&#13;
&#13;
</div>&#13;
<p>If we omit the initialization of <span class="obeylines-h"><span class="verb"><code class="inlineCode">0</code></span></span>, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function uses the first item as an initial value. This value does not have the transformation function applied, which leads to the wrong answer. In effect, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> without a proper initial value is computing this:</p>&#13;
<div id="tcolobox-229" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; 2 + 4**2 + 4**2 + 4**2 + 5**2 + 5**2 + 7**2 + 9**2 &#13;
230</code></pre>&#13;
&#13;
</div>&#13;
<p>This kind of mistake is part of the reason why <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> must be used carefully.</p>&#13;
<p>We can define a number of common and built-in reductions using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> higher-order function as follows:</p>&#13;
<pre id="listing-225" class="lstlisting"><code>from collections.abc import Callable &#13;
from functools import reduce &#13;
from typing import cast, TypeAlias &#13;
 &#13;
FloatFT: TypeAlias = Callable[[float, float], float] &#13;
 &#13;
sum2 = lambda data: reduce(cast(FloatFT, lambda x, y: x+y**2), data, 0.0) &#13;
sum = lambda data: reduce(cast(FloatFT, lambda x, y: x+y), data, 0.0) &#13;
count = lambda data: reduce(cast(FloatFT, lambda x, y: x+1), data, 0.0) &#13;
min = lambda data: reduce(cast(FloatFT, lambda x, y: x if x &lt; y else y), data) &#13;
max = lambda data: reduce(cast(FloatFT, lambda x, y: x if x &gt; y else y), data)</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum2()</code></span></span> reduction<span id="dx1-222037"/> function is the sum of squares, useful for computing the standard deviation of a set of samples. This <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> reduction function mimics the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span> reduction function<span id="dx1-222038"/> is similar to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> function, but it can work on an iterable, whereas the <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> function can only work on a materialized collection object.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">cast()</code></span></span> functions notify <span class="keyWord">mypy </span>of the intended types for the lambda objects. Without this, the default type hint for a lambda object is <span class="obeylines-h"><span class="verb"><code class="inlineCode">Any</code></span></span>, which isn’t the intent for these functions. The type hint <span class="obeylines-h"><span class="verb"><code class="inlineCode">FloatFT</code></span></span> describes a float function that accepts two float argument values and returns a float object as a result.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> functions mimic the built-in reductions. Because the first item of the iterable is used for initialization, these two functions will work properly. If we provided an initial value to these <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> functions, we might incorrectly use a value that never occurred in the original iterable.</p>&#13;
<p>The complexity of the type hints is a suggestion that lambda objects don’t convey enough information to tools like <span class="keyWord">mypy</span>. While a lambda is valid Python, it can be difficult to examine<span id="dx1-222039"/> in detail. This leads to the following<span id="dx1-222040"/> tip:</p>&#13;
<div id="tcolobox-230" class="packt_tip">&#13;
&#13;
&#13;
<p>A good design uses small function definitions.</p>&#13;
<p>A complete function definition lets us provide default values, documentation, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">doctest</code></span></span> test cases.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-222041r223"/></p>&#13;
<section id="combining-map-and-reduce" class="level4 subsectionHead" data-number="0.14.5.1">&#13;
<h4 class="subsectionHead" data-number="0.14.5.1"><span class="titlemark">10.5.1 </span> <span id="x1-2230001"/>Combining map() and reduce()</h4>&#13;
<p>We can see how to build higher-order functions around these foundational definitions. We can define a map-reduce function<span id="dx1-223001"/> that combines the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> functions as follows:</p>&#13;
<pre id="listing-226" class="lstlisting"><code>from collections.abc import Callable, Iterable &#13;
from functools import reduce &#13;
from typing import TypeVar, cast &#13;
 &#13;
ST = TypeVar("ST") &#13;
 &#13;
def map_reduce( &#13;
    map_fun: Callable[[ST], float], &#13;
    reduce_fun: Callable[[float, float], float], &#13;
    source: Iterable[ST], &#13;
    initial: float = 0 &#13;
) -&gt; float: &#13;
    return reduce(reduce_fun, map(map_fun, source), initial)</code></pre>&#13;
<p>This definition has a few formal type constraints. First, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">source</code></span></span> iterator produces some consistently typed data. We’ll bind the source type to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ST</code></span></span> type variable to show where consistent types are required. Second, the provided <span class="obeylines-h"><span class="verb"><code class="inlineCode">map_fun()</code></span></span> function accepts one argument of whatever type could be bound to <span class="obeylines-h"><span class="verb"><code class="inlineCode">ST</code></span></span> and produces a float object. Third, the provided <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce_fun()</code></span></span> function will reduce float objects to return a result of the same type. Because <span class="keyWord">mypy </span>is aware of the way Python operators work with integers as well as float values, this works in an integer context as well as a float context.</p>&#13;
<p>We can build a sum-of-squares reduction using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map_fun()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce_fun()</code></span></span> functions separately as follows:</p>&#13;
<pre id="listing-227" class="lstlisting"><code>from collections.abc import Iterable &#13;
 &#13;
def sum2_mr(source_iter: Iterable[float]) -&gt; float: &#13;
    return map_reduce( &#13;
        map_fun=lambda y: y**2, &#13;
        reduce_fun=lambda x, y: x+y, &#13;
        source=source_iter, &#13;
        initial=0)</code></pre>&#13;
<p>In this case, we’ve used a <span class="obeylines-h"><span class="verb"><code class="inlineCode">lambda</code><code class="inlineCode"> y:</code><code class="inlineCode"> y**2</code></span></span> argument value as a mapping to square each value. The reduction<span id="dx1-223023"/> is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">lambda</code><code class="inlineCode"> x,</code><code class="inlineCode"> y:</code><code class="inlineCode"> x+y</code></span></span> argument value. We don’t need to explicitly provide an initial value because the initial value will be the first item in the iterable after the provided <span class="obeylines-h"><span class="verb"><code class="inlineCode">map_fun()</code></span></span> lambda has squared it.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">lambda</code><code class="inlineCode"> x,</code><code class="inlineCode"> y:</code><code class="inlineCode"> x+y</code></span></span> argument value is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">+</code></span></span> operator. Python offers all of the arithmetic operators as short functions in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module. (We’ll look at this in <a href="Chapter_11.xhtml#x1-23500011"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 11</span></a>, <a href="Chapter_11.xhtml#x1-23500011"><span class="cmti-10x-x-109">The Toolz Package</span></a>.) The following is how we can slightly simplify our map-reduce operation:</p>&#13;
<pre id="listing-228" class="lstlisting"><code>from collections.abc import Iterable &#13;
import operator &#13;
 &#13;
def sum2_mr2(source: Iterable[float]) -&gt; float: &#13;
    return map_reduce( &#13;
        lambda y: y**2, &#13;
        operator.add, &#13;
        source, &#13;
        0)</code></pre>&#13;
<p>We’ve used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.add</code></span></span> function to sum our values instead of the longer lambda form.</p>&#13;
<p>The following is how we can count values in an iterable:</p>&#13;
<pre id="listing-229" class="lstlisting"><code>def count_mr(source: Iterable[float]) -&gt; float: &#13;
    return map_reduce( &#13;
        lambda y: 1, &#13;
        lambda x, y: x+y, &#13;
        source, &#13;
        0)</code></pre>&#13;
<p>We’ve used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">lambda</code><code class="inlineCode"> y:</code><code class="inlineCode"> 1</code></span></span> parameter to map each value to the value <span class="obeylines-h"><span class="verb"><code class="inlineCode">1</code></span></span>. The count is then reduced using a lambda or the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.add</code></span></span> function.</p>&#13;
<p>The general-purpose <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function allows us to create<span id="dx1-223039"/> any species of reduction from a large dataset to a single value. There are some limitations, however, on what we should do with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function. <span id="x1-223040r231"/></p>&#13;
</section>&#13;
<section id="using-the-reduce-and-partial-functions" class="level4 subsectionHead" data-number="0.14.5.2">&#13;
<h4 class="subsectionHead" data-number="0.14.5.2"><span class="titlemark">10.5.2 </span> <span id="x1-2240002"/>Using the reduce() and partial() functions</h4>&#13;
<p>As we saw earlier, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function has a provision for an initial value. The default initial<span id="dx1-224001"/> value is zero. This initial value seeds the reduction and will be the default value if the source iterable is empty.</p>&#13;
<p>In the following example, we’ve provided an absurd initial value:</p>&#13;
<div id="tcolobox-231" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import operator &#13;
&gt;&gt;&gt; from functools import reduce &#13;
&gt;&gt;&gt; d = [] &#13;
&gt;&gt;&gt; reduce(operator.add, d, "hello world") &#13;
’hello world’</code></pre>&#13;
&#13;
</div>&#13;
<p>The initial value provided to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function is a string. Because the iterable source of data, <span class="obeylines-h"><span class="verb"><code class="inlineCode">d</code></span></span> is empty, no operations were performed and the initial value is the final result, even though it’s absurdly invalid.</p>&#13;
<p>We note a complication here when we try to create a partial function using <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span>: there’s no sensible way to provide an initial value. This stems from the following root cause: the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function has no keyword parameters. For some reductions, we need to provide values for the first and third positional parameters to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function.</p>&#13;
<p>Here’s the result of attempting to combine <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span>. The following example definitions of partial<span id="dx1-224008"/> functions do <span class="cmti-10x-x-109">not </span>work correctly:</p>&#13;
<pre id="listing-230" class="lstlisting"><code>from functools import partial, reduce &#13;
 &#13;
psum2 = partial(reduce, lambda x, y: x+y**2) &#13;
pcount = partial(reduce, lambda x, y: x+1)</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">psum2()</code></span></span> function should compute a sum of squares of a source of values. As we’ll see, this does not work as hoped. Here’s an example of trying to use these functions based on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span> function:</p>&#13;
<div id="tcolobox-232" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; d = [2, 4, 4, 4, 5, 5, 7, 9] &#13;
&gt;&gt;&gt; sum2(d) &#13;
232.0 &#13;
&gt;&gt;&gt; psum2(d) &#13;
230 &#13;
 &#13;
&gt;&gt;&gt; count(d) &#13;
8.0 &#13;
&gt;&gt;&gt; pcount(d) &#13;
9</code></pre>&#13;
&#13;
</div>&#13;
<p>The sum-of-squares defined as a partial does not use a proper initialization for the sequence of values.</p>&#13;
<p>The reduction should start with 0. It will apply the lambda to each value, and sum <span class="obeylines-h"><span class="verb"><code class="inlineCode">0</code><code class="inlineCode"> +</code><code class="inlineCode"> 2**2</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">0</code><code class="inlineCode"> +</code><code class="inlineCode"> 2**2</code><code class="inlineCode"> +</code><code class="inlineCode"> 4**2</code></span></span>, etc. In actual fact, it starts with the first of the values, <span class="obeylines-h"><span class="verb"><code class="inlineCode">2</code></span></span>. Then it applies the lambda to the remaining values, computing <span class="obeylines-h"><span class="verb"><code class="inlineCode">2</code><code class="inlineCode"> +</code><code class="inlineCode"> 4**2</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">2</code><code class="inlineCode"> +</code><code class="inlineCode"> 4**2</code><code class="inlineCode"> +</code><code class="inlineCode"> 4**2</code></span></span>, etc.</p>&#13;
<p>There’s no work-around using <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span>. A lambda must be used in these cases where we’d like to apply a transformation while using <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span>.</p>&#13;
<p>A partial function is an important technique for simplifying a particularly complicated calculation. When there are numerous parameters, few of which change, then a partial function can be helpful. A partial function can make it easier to refactor a complex computation to use alternative implementations of discrete parts. Since each discrete part is a separately defined function, unit testing can confirm that the results are as expected.</p>&#13;
<p>The limitation around<span id="dx1-224024"/> the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function is a result of a function with two properties:</p>&#13;
<ul>&#13;
<li><p>Only positional parameters</p></li>&#13;
<li><p>The parameters being provided in an awkward order</p></li>&#13;
</ul>&#13;
<p>In the case of <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span>, the initial value comes <span class="cmti-10x-x-109">after </span>the source of values, making it difficult to provide via <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span>. <span id="x1-224025r232"/></p>&#13;
</section>&#13;
<section id="using-the-map-and-reduce-functions-to-sanitize-raw-data" class="level4 subsectionHead" data-number="0.14.5.3">&#13;
<h4 class="subsectionHead" data-number="0.14.5.3"><span class="titlemark">10.5.3 </span> <span id="x1-2250003"/>Using the map() and reduce() functions to sanitize raw data</h4>&#13;
<p>When doing data cleansing, we’ll often introduce<span id="dx1-225001"/> filters of various degrees of complexity to exclude invalid values. We may also include a mapping to sanitize values in the cases where a valid but improperly formatted value can be replaced with a valid and proper value.</p>&#13;
<p>We might produce the following output:</p>&#13;
<pre id="listing-231" class="lstlisting"><code>from collections.abc import Callable, Iterable &#13;
from functools import reduce &#13;
 &#13;
def comma_fix(data: str) -&gt; float: &#13;
    try: &#13;
        return float(data) &#13;
    except ValueError: &#13;
        return float(data.replace(",", "")) &#13;
 &#13;
def clean_sum( &#13;
    cleaner: Callable[[str], float], &#13;
    data: Iterable[str] &#13;
) -&gt; float: &#13;
    return reduce(operator.add, map(cleaner, data))</code></pre>&#13;
<p>We’ve defined a mapping, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">comma_fix()</code></span></span> function, that will convert data from a nearly correct string format into a usable floating-point value. This will remove the comma character. Another common variation could remove dollar signs and convert to <span class="obeylines-h"><span class="verb"><code class="inlineCode">decimal.Decimal</code></span></span>. We’ve left this as an exercise for the reader.</p>&#13;
<p>We’ve also defined a map-reduce operation<span id="dx1-225016"/> that applies a given cleaner function, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">comma_fix()</code></span></span> function in this case, to the data before doing a <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function, using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.add</code></span></span> method.</p>&#13;
<p>We can apply the previously described function as follows:</p>&#13;
<div id="tcolobox-233" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; d = (’1,196’, ’1,176’, ’1,269’, ’1,240’, ’1,307’, &#13;
... ’1,435’, ’1,601’, ’1,654’, ’1,803’, ’1,734’) &#13;
 &#13;
&gt;&gt;&gt; clean_sum(comma_fix, d) &#13;
14415.0</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve cleaned the data by fixing the commas, as well as computing a sum. The syntax is very convenient for combining these two operations.</p>&#13;
<p>We have to be careful, however, of using the cleaning function more than once. If we’re also going to compute a sum of squares, we really should not execute the following kinds of processing steps:</p>&#13;
<pre>&gt;&gt;&gt; sum = clean_sum(comma_fix, d)&#13;
&gt;&gt;&gt; comma_fix_squared = lambda x: comma_fix(x)**2&#13;
&gt;&gt;&gt; sum_2 = clean_sum(comma_fix_squared, d)&#13;
</pre>&#13;
<p>Using <span class="obeylines-h"><span class="verb"><code class="inlineCode">clean_sum()</code></span></span> expressions more than once means we’ll do the comma-fixing operation more than once on the source data. This is a poor design. It would be better to cache the intermediate numeric results of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">comma_fix()</code></span></span> function. Using a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> decorator can help. Materializing the sanitized intermediate values as a temporary sequence object is better. Comparing the performance of different caching options is left as an exercise. <span id="x1-225027r233"/></p>&#13;
</section>&#13;
<section id="using-the-groupby-and-reduce-functions" class="level4 subsectionHead" data-number="0.14.5.4">&#13;
<h4 class="subsectionHead" data-number="0.14.5.4"><span class="titlemark">10.5.4 </span> <span id="x1-2260004"/>Using the groupby() and reduce() functions</h4>&#13;
<p>A common requirement is to summarize<span id="dx1-226001"/> data after partitioning it into groups. We can use a <span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict(list)</code></span></span> method to partition data. We can then analyze each partition separately. In <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, we looked at some ways to group and partition. In <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The Itertools Module</span></a>, we looked at others.</p>&#13;
<p>The following is some sample data that we need to analyze:</p>&#13;
<div id="tcolobox-234" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; data = [(’4’, 6.1), (’1’, 4.0), (’2’, 8.3), (’2’, 6.5), &#13;
... (’1’, 4.6), (’2’, 6.8), (’3’, 9.3), (’2’, 7.8), &#13;
... (’2’, 9.2), (’4’, 5.6), (’3’, 10.5), (’1’, 5.8), &#13;
... (’4’, 3.8), (’3’, 8.1), (’3’, 8.0), (’1’, 6.9), &#13;
... (’3’, 6.9), (’4’, 6.2), (’1’, 5.4), (’4’, 5.8)]</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve got a sequence of raw data values with a key (a short string) and a measurement for each key (a float value).</p>&#13;
<p>One way to produce usable groups from this data is to build a dictionary that maps a key to a list of members in this groups, as follows:</p>&#13;
<pre id="listing-232" class="lstlisting"><code>from collections import defaultdict &#13;
from collections.abc import Iterable, Callable, Iterator &#13;
from typing import Any, TypeVar, Protocol, cast &#13;
DT = TypeVar("DT") &#13;
 &#13;
class Comparable(Protocol): &#13;
    def __lt__(self, __other: Any) -&gt; bool: ... &#13;
    def __gt__(self, __other: Any) -&gt; bool: ... &#13;
    def __hash__(self) -&gt; int: ... &#13;
KT = TypeVar("KT", bound=Comparable) &#13;
 &#13;
def partition( &#13;
    source: Iterable[DT], &#13;
    key: Callable[[DT], KT] = cast(Callable[[DT], KT], lambda x: x) &#13;
) -&gt; Iterator[tuple[KT, Iterator[DT]]]: &#13;
    """Sorting deferred.""" &#13;
    pd: dict[KT, list[DT]] = defaultdict(list) &#13;
    for item in source: &#13;
        pd[key(item)].append(item) &#13;
    for k in sorted(pd): &#13;
        yield k, iter(pd[k])</code></pre>&#13;
<p>This will separate<span id="dx1-226029"/> each item in the iterable into a group based on the key. The iterable source of data is described using a type variable of <span class="obeylines-h"><span class="verb"><code class="inlineCode">DT</code></span></span>, representing the type of each data item. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">key()</code></span></span> function is used to extract a key value from each item. This function produces an object of some key type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">KT</code></span></span>, that is generally distinct from the original data item type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">DT</code></span></span>. When looking at the sample data, the type of each data item is a tuple. The keys are of type <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code></span></span>. The callable function for extracting a key transforms a tuple into a string.</p>&#13;
<p>This key value extracted from each data item is used to append each item to a list in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pd</code></span></span> dictionary. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict</code></span></span> object is defined as mapping each key, <span class="obeylines-h"><span class="verb"><code class="inlineCode">KT</code></span></span>, to a list of the data items, <span class="obeylines-h"><span class="verb"><code class="inlineCode">list[DT]</code></span></span>.</p>&#13;
<p>The resulting value of this function matches the results of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.groupby()</code></span></span> function. It’s an iterable sequence of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">(group</code><code class="inlineCode"> key,</code><code class="inlineCode"> iterator)</code></span></span> tuples. The group key value will be of the type produced by the key function. The iterator will provide a sequence of the original data items.</p>&#13;
<p>The following is the same feature defined with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.groupby()</code></span></span> function:</p>&#13;
<pre id="listing-233" class="lstlisting"><code>from itertools import groupby &#13;
from collections.abc import Iterable, Callable, Iterator &#13;
 &#13;
def partition_s( &#13;
    source: Iterable[DT], &#13;
    key: Callable[[DT], KT] = cast(Callable[[DT], KT], lambda x: x) &#13;
) -&gt; Iterable[tuple[KT, Iterator[DT]]]: &#13;
    """Sort source data""" &#13;
    return groupby(sorted(source, key=key), key)</code></pre>&#13;
<div id="tcolobox-235" class="packt_tip">&#13;
&#13;
&#13;
<p>The important difference in the inputs to each function is that the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function version requires data to be sorted by the key, whereas the</p>&#13;
<p><span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict</code></span></span> version doesn’t require sorting. For very large sets of data, the sort can be expensive, measured in both time and storage.</p>&#13;
&#13;
</div>&#13;
<p>Here’s the core partitioning<span id="dx1-226039"/> operation. This might be used prior to filtering out a group, or it might be used prior to computing statistics for each group:</p>&#13;
<div id="tcolobox-236" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; for key, group_iter in partition(data, key=lambda x: x[0]): &#13;
...     print(key, tuple(group_iter)) &#13;
1 ((’1’, 4.0), (’1’, 4.6), (’1’, 5.8), (’1’, 6.9), (’1’, 5.4)) &#13;
2 ((’2’, 8.3), (’2’, 6.5), (’2’, 6.8), (’2’, 7.8), (’2’, 9.2)) &#13;
3 ((’3’, 9.3), (’3’, 10.5), (’3’, 8.1), (’3’, 8.0), (’3’, 6.9)) &#13;
4 ((’4’, 6.1), (’4’, 5.6), (’4’, 3.8), (’4’, 6.2), (’4’, 5.8))</code></pre>&#13;
&#13;
</div>&#13;
<p>We can summarize this grouped data as follows:</p>&#13;
<pre id="listing-234" class="lstlisting"><code>from collections.abc import Iterable, Sequence &#13;
 &#13;
def summarize( &#13;
    key: KT, &#13;
    item_iter: Iterable[tuple[KT, float]] &#13;
) -&gt; tuple[KT, float, float]: &#13;
    # mean = lambda seq: sum(seq) / len(seq) &#13;
    def mean(seq: Sequence[float]) -&gt; float: &#13;
        return sum(seq) / len(seq) &#13;
    # var = lambda mean, seq: sum(...) &#13;
    def var(mean: float, seq: Sequence[float]) -&gt; float: &#13;
        return sum((x - mean) ** 2 / (len(seq)-1) for x in seq) &#13;
 &#13;
    values = tuple(v for k, v in item_iter) &#13;
    m = mean(values) &#13;
    return key, m, var(m, values)</code></pre>&#13;
<p>The results of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">partition()</code></span></span> functions will be a sequence of <span class="cmti-10x-x-109">(key, iterator)</span> two-tuples. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">summarize()</code></span></span> function accepts the two-tuple and decomposes it into the key and the iterator over the original<span id="dx1-226063"/> data items. In this function, the data items are defined as <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple[KT,</code><code class="inlineCode"> float]</code></span></span>, a key of some type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">KT</code></span></span>, and a numeric value. From each two-tuple in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">item_iter</code></span></span> iterator we want the value portion, and we use a generator expression to create a tuple of only the values.</p>&#13;
<p>We can also use the expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(snd,</code><code class="inlineCode"> item_iter)</code></span></span> to pick the second item from each of the two-tuples. This requires a definition of <span class="obeylines-h"><span class="verb"><code class="inlineCode">snd</code><code class="inlineCode"> =</code><code class="inlineCode"> lambda</code><code class="inlineCode"> x:</code><code class="inlineCode"> x[1]</code></span></span> or perhaps <span class="obeylines-h"><span class="verb"><code class="inlineCode">snd</code><code class="inlineCode"> =</code><code class="inlineCode"> operator.itemgetter(1)</code></span></span>. The name <span class="obeylines-h"><span class="verb"><code class="inlineCode">snd</code></span></span> is a short form of <span class="cmti-10x-x-109">second</span>.</p>&#13;
<p>We can use the following command to apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">summarize()</code></span></span> function to each partition:</p>&#13;
<div id="tcolobox-237" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from itertools import starmap &#13;
&gt;&gt;&gt; partition1 = partition(data, key=lambda x: x[0]) &#13;
&gt;&gt;&gt; groups1 = starmap(summarize, partition1)</code></pre>&#13;
&#13;
</div>&#13;
<p>This uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span> function from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module. See <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The Itertools Module</span></a>. An alternative definition using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">partition_s()</code></span></span> function is as follows:</p>&#13;
<div id="tcolobox-238" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; partition2 = partition_s(data, key=lambda x: x[0]) &#13;
&gt;&gt;&gt; groups2 = starmap(summarize, partition2)</code></pre>&#13;
&#13;
</div>&#13;
<p>Both will provide us with summary values for each group. The resulting group statistics look as follows:</p>&#13;
<div id="tcolobox-239" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>1 5.34 1.25 &#13;
2 7.72 1.22 &#13;
3 8.56 1.9 &#13;
4 5.5 0.96</code></pre>&#13;
&#13;
</div>&#13;
<p>The variance can be used as part of a <span class="italic">χ</span><sup><span class="cmr-8">2</span></sup> (chi-squared) test to determine if the null hypothesis holds for this data. The null hypothesis asserts that there’s nothing to see: the variance in the data is essentially random. We can also compare the data between the four groups to see if the various means are consistent with the null hypothesis or if there is some statistically significant variation. <span id="x1-226076r234"/></p>&#13;
</section>&#13;
<section id="avoiding-problems-with-reduce" class="level4 subsectionHead" data-number="0.14.5.5">&#13;
<h4 class="subsectionHead" data-number="0.14.5.5"><span class="titlemark">10.5.5 </span> <span id="x1-2270005"/>Avoiding problems with reduce()</h4>&#13;
<p>There is a dark side to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function. We must avoid expressions<span id="dx1-227001"/> like the following:</p>&#13;
<pre id="listing-235" class="lstlisting"><code>reduce(operator.add, list_of_strings, "")</code></pre>&#13;
<p>This does work, because Python will apply the generic <span class="obeylines-h"><span class="verb"><code class="inlineCode">add</code></span></span> operator between two operands, which are strings. However, it will compute a large number of intermediate string objects, a relatively costly operation. An alternative is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">"".join(list_of_strings)</code></span></span> expression. A little study with <span class="obeylines-h"><span class="verb"><code class="inlineCode">timeit</code></span></span> reveals that the <span class="obeylines-h"><span class="verb"><code class="inlineCode">string.join()</code></span></span> approach is more efficient than the generic <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> version. We’ll leave the data collection and analysis as an exercise for the reader.</p>&#13;
<p>In general, it’s best to scrutinize <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> operations where the function provided creates or modifies a collection of some kind. It’s possible to have a superficially simple-looking expression that creates very large intermediate results. For example, we might write <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce(accumulate_details,</code><code class="inlineCode"> some_source,</code><code class="inlineCode"> {})</code></span></span> without thinking of the way the <span class="obeylines-h"><span class="verb"><code class="inlineCode">accumulate_details()</code></span></span> function updates a dictionary. We might be better off looking at ways to rewrite the underlying <span class="obeylines-h"><span class="verb"><code class="inlineCode">accumulate_details()</code></span></span> function to accept a sequence instead of a single item. <span id="x1-227003r230"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="handling-multiple-types-with-singledispatch" class="level3 sectionHead" data-number="0.14.6">&#13;
<h3 class="sectionHead" data-number="0.14.6"><span class="titlemark">10.6 </span> <span id="x1-2280006"/>Handling multiple types with singledispatch</h3>&#13;
<p>We’ll often have functions<span id="dx1-228001"/> which have similar semantics but distinct implementations based on the type of data presented. We might have a function that works for either a subclass of <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span>, or <span class="obeylines-h"><span class="verb"><code class="inlineCode">TypedDict</code></span></span>. The syntax for working with these objects is distinct, and we can’t use a single, generic Python function.</p>&#13;
<p>We have the following choices for working with data of distinct types:</p>&#13;
<ul>&#13;
<li><p>Use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">case</code></span></span> clause for each distinct type.</p></li>&#13;
<li><p>Use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@singledispatch</code></span></span> decorator to define a number of closely-related functions. This will create the necessary type-matching <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement for us.</p></li>&#13;
</ul>&#13;
<p>A small example arises when working<span id="dx1-228002"/> with US postal data and spreadsheets. It’s common for a US postal ZIP code to be misinterpreted as an integer (or float) value. The town of Andover, MA, for example, has a postal code of 01810. A spreadsheet might misinterpret this as an integer, 1810, dropping the leading zero.</p>&#13;
<p>When working with US postal data, we often need a function to normalize ZIP codes as string values, restoring any dropped leading zero values. This function will have at least the following three cases:</p>&#13;
<ul>&#13;
<li><p>An integer value needs to be converted to a string and have leading zeroes restored.</p></li>&#13;
<li><p>A float value, similarly, needs to be converted to a string and have the leading zeroes restored.</p></li>&#13;
<li><p>A string value may be a five-digit ZIP code or a nine-digit ZIP code. Depending on the application, we might want to truncate the ZIP codes to ensure they are uniform.</p></li>&#13;
</ul>&#13;
<p>While we can use a <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement to handle these three cases, we can also define several closely-related functions. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@singledispatch</code></span></span> decorator lets us define a ”default” function, used when no type matching is possible. We can then overload this function with additional definitions for each of the data types we want to process.</p>&#13;
<p>Here is the suite of definitions for a single <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_format()</code></span></span> function. We’ll start with the base definition, used when no other definition will work:</p>&#13;
<pre id="listing-236" class="lstlisting"><code>from functools import singledispatch &#13;
from typing import Any &#13;
 &#13;
@singledispatch &#13;
def zip_format(zip: Any) -&gt; str: &#13;
    raise NotImplementedError(f"unsupported {type(zip)} for zip_format()")</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@singledispatch</code></span></span> decorator will create a new decorator, using the name of the function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_format</code></span></span>. This new <span class="obeylines-h"><span class="verb"><code class="inlineCode">@zip_format</code></span></span> decorator can then use be used to create alternative, overloaded definitions. These definitions<span id="dx1-228009"/> imply a <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement to distinguish among the alternatives based on type matching rules.</p>&#13;
<p>Here are the alternative definitions:</p>&#13;
<pre id="listing-237" class="lstlisting"><code>@zip_format.register &#13;
def _(zip: int) -&gt; str: &#13;
    return f"{zip:05d}" &#13;
 &#13;
@zip_format.register &#13;
def _(zip: float) -&gt; str: &#13;
    return f"{zip:05.0f}" &#13;
 &#13;
@zip_format.register &#13;
def _(zip: str) -&gt; str: &#13;
    if "-" in zip: &#13;
        zip, box = zip.split("-") &#13;
    return f"{zip:0&gt;5s}"</code></pre>&#13;
<p>Note that each alternative function uses a name, <span class="obeylines-h"><span class="verb"><code class="inlineCode">_</code></span></span>, that will be ignored. The functions will all be combined into a single <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_format()</code></span></span> function that will dispatch an appropriate implementation based on the type of the argument value.</p>&#13;
<p>It’s also important to note that these functions do not all need to be defined in the same module. We can provide a module with foundational definitions. Additional modules can then import the base definitions and register their unique implementation functions. This permits expansion by adding alternative implementations at the module level. <span id="x1-228023r236"/></p>&#13;
</section>&#13;
<section id="summary-9" class="level3 sectionHead" data-number="0.14.7">&#13;
<h3 class="sectionHead" data-number="0.14.7"><span class="titlemark">10.7 </span> <span id="x1-2290007"/>Summary</h3>&#13;
<p>In this chapter, we’ve looked at a number of functions in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> module. This library module provides a number of functions that help us create sophisticated functions and classes.</p>&#13;
<p>We’ve looked at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">@lru_cache</code></span></span> decorators as ways to boost certain types of applications with frequent re-calculations of the same values. These two decorators are of tremendous value for certain kinds of functions that take integer or string argument values. They can reduce processing by simply implementing memoization. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@lru_cache</code></span></span> has an upper bound on the memory it will use; this is good for a domain with an unknown size.</p>&#13;
<p>We looked at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@total_ordering</code></span></span> function as a decorator to help us build objects that support rich ordering comparisons. This is at the fringe of functional programming, but is very helpful when creating new kinds of numbers.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span> function creates a new function with the partial application of argument values. As an alternative, we can build a lambda with similar features. The use case for this is ambiguous.</p>&#13;
<p>We also looked at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function as a higher-order function. This generalizes reductions like the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> function. We’ll use this function in several examples in later chapters. This fits logically with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> functions as an important higher-order function.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@singledispatch</code></span></span> decorator can help us to create a number of functions with similar semantics, but distinct data types for the argument values. This prevents the overhead of an explicit <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement. As the software evolves, we can add definitions to the collection of alternatives.</p>&#13;
<p>In the next chapter, we’ll look at a collection of small topics. We’ll examine the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package, which provides some alternatives to the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> modules. This alternative has a number of new features. It also has some overlapping features that are considered from a different perspective, making them more useful for some applications.</p>&#13;
<p>We’ll also see some additional use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module. This module makes some Python operators available as functions, letting us simplify our own function definitions.</p>&#13;
<p>We’ll also look at some techniques to design flexible decision-making and to allow expressions to be evaluated in a non-strict order. <span id="x1-229001r237"/></p>&#13;
</section>&#13;
<section id="exercises-9" class="level3 sectionHead" data-number="0.14.8">&#13;
<h3 class="sectionHead" data-number="0.14.8"><span class="titlemark">10.8 </span> <span id="x1-2300008"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-230001r235"/></p>&#13;
<section id="compare-string.join-and-reduce" class="level4 subsectionHead" data-number="0.14.8.1">&#13;
<h4 class="subsectionHead" data-number="0.14.8.1"><span class="titlemark">10.8.1 </span> <span id="x1-2310001"/>Compare string.join() and reduce()</h4>&#13;
<p>In the <a href="#x1-2270005"><span class="cmti-10x-x-109">Avoiding problems with reduce()</span></a> section of this chapter, we noted that we can combine a list of string values into a single string in the following two ways:</p>&#13;
<ul>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce(operator.add,</code><code class="inlineCode"> list_of_strings,</code><code class="inlineCode"> "")</code></span></span></p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">"".join(list_of_strings)</code></span></span></p></li>&#13;
</ul>&#13;
<p>One of these is considerably more efficient than the other. Use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">timeit</code></span></span> module to find out which is more efficient. The efficiency gain is dramatic, and it can be helpful to know what the ratio of time between these two approaches is.</p>&#13;
<p>It’s also important to know how the two approaches scale with larger and larger collections of strings. To this end, build a small module that exercises the above two expressions with collections of strings. Use collections with sizes 100, 200, 300, ..., 900 as a way to see how the work scales with the number of strings being concatenated. <span id="x1-231001r239"/></p>&#13;
</section>&#13;
<section id="extend-the-comma_fix-function" class="level4 subsectionHead" data-number="0.14.8.2">&#13;
<h4 class="subsectionHead" data-number="0.14.8.2"><span class="titlemark">10.8.2 </span> <span id="x1-2320002"/>Extend the comma_fix() function</h4>&#13;
<p>In the <a href="#x1-2250003"><span class="cmti-10x-x-109">Using the map() and reduce() functions to sanitize raw data</span></a> section, we defined a mapping, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">comma_fix()</code></span></span> function, that will convert data from a nearly correct string format into a usable floating-point value. This will remove the comma character.</p>&#13;
<p>This function has a misleading name. It’s really a string-to-float conversion that tolerates some punctuation. A better name might be <span class="obeylines-h"><span class="verb"><code class="inlineCode">tolerant_str_to_float()</code></span></span>.</p>&#13;
<p>Define and test a tolerant string-to-decimal conversion function. This should remove dollar signs, as well as commas, and convert the remaining string to <span class="obeylines-h"><span class="verb"><code class="inlineCode">decimal.Decimal</code></span></span>.</p>&#13;
<p>Define and test a tolerant string-to-int conversion function. This should parallel the <span class="obeylines-h"><span class="verb"><code class="inlineCode">tolerant_str_to_float()</code></span></span> by removing only comma characters. <span id="x1-232001r240"/></p>&#13;
</section>&#13;
<section id="revise-the-clean_sum-function" class="level4 subsectionHead" data-number="0.14.8.3">&#13;
<h4 class="subsectionHead" data-number="0.14.8.3"><span class="titlemark">10.8.3 </span> <span id="x1-2330003"/>Revise the clean_sum() function</h4>&#13;
<p>In the <a href="#x1-2250003"><span class="cmti-10x-x-109">Using the map() and reduce() functions to sanitize raw data</span></a> section, we defined a <span class="obeylines-h"><span class="verb"><code class="inlineCode">clean_sum()</code></span></span> function to cleanse and sum a collection of raw string values. For a simple case like computing a mean, this involves a single pass over the data doing conversion and computation.</p>&#13;
<p>For a more complex operation, like variance or standard deviation, multiple passes can be burdensome because the string conversion is done repeatedly. This suggests the <span class="obeylines-h"><span class="verb"><code class="inlineCode">clean_sum()</code></span></span> function is a poor design.</p>&#13;
<p>The first requirement is a function to compute the mean, variance, and standard deviation of string data:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file102.jpg" class="math-display" alt=" ∑ --x∈D-x- mean (D ) = len(D ) "/>&#13;
</div>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file103.jpg" class="math-display" alt=" ∑ (x-−-mean-(D-))2 var(D ) = len(D )− 1 x∈D "/>&#13;
</div>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file104.jpg" class="math-display" alt="stdev(D ) = ∘var-(D-) "/>&#13;
</div>&#13;
<p>One design alternative is to cache the intermediate numeric results of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">comma_fix()</code></span></span> function. Use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> decorator to define a <span class="obeylines-h"><span class="verb"><code class="inlineCode">comma_fix()</code></span></span> function. (This function should be renamed to something a little more explicit, like <span class="obeylines-h"><span class="verb"><code class="inlineCode">str_to_float()</code></span></span>.)</p>&#13;
<p>Create a very large collection of randomized numeric strings and see which alternative is faster.</p>&#13;
<p>Another design alternative is to materialize the sanitized intermediate values. Create a temporary sequence object with the purely numeric values, and then compute the various statistical measures on these purely numeric lists.</p>&#13;
<p>In <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex Stateless Objects</span></a>, we presented a way to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">sys.getallocatedblocks()</code></span></span> to understand how much memory was being used by Python. This procedure can be applied here to see which caching alternative uses the least memory.</p>&#13;
<p>Present the results to show which design alternative is best for performance and memory use.</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-10" class="level3 likesectionHead" data-number="0.14.9">&#13;
<h3 class="likesectionHead" data-number="0.14.9"><span id="x1-2340003"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/></p>&#13;
<p><span id="x1-234001r225"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>