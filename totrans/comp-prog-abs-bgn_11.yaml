- en: '*Chapter 9:* When Things Go Wrong – Bugs and Exceptions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing software can be hard, and when we write it, we will make errors. We
    will, unintentionally, introduce bugs to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Some of them will be rather trivial to find and fix, but some can set us off
    on a wild goose chase through the code where we try to understand the reasons
    as to why things are not working the way we expect them to.
  prefs: []
  type: TYPE_NORMAL
- en: It is not unheard of that people spend days, and sometimes weeks, attempting
    to track down a bug. To be able to find bugs in our applications, we will need
    to understand what kinds exist and how they affect the way our applications run.
    This chapter will help us recognize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding software bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding bugs using a debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will also talk a bit about variables and data types. Look
    back at [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*, Working
    with Data – Variables*, if you need to refresh your memory about these.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding software bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing software, things will not always go according to plan. The programs
    we create will contain bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *bug* to describe an error, flaw, or fault in a program dates way
    long before we had any computers. It has been recorded as a part of engineering
    jargon since the 1870s. In a letter, dated 1878, to an associate, Thomas Edison
    wrote the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"It has been just so in all of my inventions. The first step is an intuition,
    and comes with a burst, then difficulties arise—this thing gives out and [it is]
    then that "Bugs"—as such, little faults and difficulties are called—show themselves
    and months of intense watching, study, and labor are requisite before commercial
    success or failure is certainly reached."'
  prefs: []
  type: TYPE_NORMAL
- en: The first mechanical pinball game, Baffle Ball, was advertised as being *free
    from bugs* in 1931, and in 1944, Isaac Asimov used the term *bug* to describe
    issues with a robot in the short story **Catch That Rabbit**.
  prefs: []
  type: TYPE_NORMAL
- en: One story that has often been given tribute for being the origin of the term
    bug in software comes from Grace Hopper. In 1946, she joined the Harvard Faculty
    at the Computation Laboratory, where she continued her work on the Mark I and
    Mark II computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Mark II computer produced errors and, after some searching, the operators
    found that the cause was a moth trapped in a relay. The moth was carefully removed
    and taped to the logbook. Under the moth, the following was written:'
  prefs: []
  type: TYPE_NORMAL
- en: '"First actual case of a bug being found."'
  prefs: []
  type: TYPE_NORMAL
- en: 'The date in the logbook was September 9 1947, and that was the first time we
    had the term *bug* used in computer science:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The moth found in the Mark II computer in 1947 – US Naval Historical
    Center Online Library Photograph (Public Domain [PD])](img/Figure_9.1_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The moth found in the Mark II computer in 1947 – US Naval Historical
    Center Online Library Photograph (Public Domain [PD])
  prefs: []
  type: TYPE_NORMAL
- en: The likelihood that an actual bug will make our programs produce the wrong output
    is almost nonexistent. It is much more likely that the source of the error is
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different types of bugs. To understand some of them, and to see
    what damage a bug can cause, we'll look at two incredibly expensive software bugs.
  prefs: []
  type: TYPE_NORMAL
- en: NASA's Mars Climate Orbiter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is one of the most famous bugs in the history of computing. The Mars Climate
    Orbiter was a space probe that was launched by NASA on December 11, 1998\. Its
    mission was to study the Martian climate, atmosphere, and surface changes. On
    September 23, 1999, all communication with the spacecraft was lost. It is not
    known if it was destroyed in the Martian atmosphere or if it continued existing
    in space.
  prefs: []
  type: TYPE_NORMAL
- en: On November 10, 1999, the Mars Climate Orbiter Mishap Investigation Board released
    a Phase I report. In it, it was made clear that the reason for the disaster was
    a bug in a piece of ground-based software provided by one of NASA's contractors.
    This software produced a result in the United States customary units (units used
    in the US, such as inch, foot, and mile) while the NASA software expected the
    input to be in SI units (the metric system).
  prefs: []
  type: TYPE_NORMAL
- en: The cost of this mistake was estimated at 125 million US dollars.
  prefs: []
  type: TYPE_NORMAL
- en: The Morris worm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 1988, a Cornell University student named Robert Morris released a computer
    worm that was designed as a harmless experiment. It exploited some flaws in the
    Unix operating system's sendmail program that were spread from computer to computer.
    When a new computer was found, the program checked to see if this computer was
    already infected. Morris understood that this would be an easy way for system
    administrators to stop the spread and help the system identify if it was infected
    already. To compensate for this, Morris designed his worm so that it infected
    any computer that responded with a yes 1 out of 7 times.
  prefs: []
  type: TYPE_NORMAL
- en: This was the big mistake that made the worm not only spread rapidly across the
    internet but also infect the same computers multiple times, disrupting the target
    machines. The Morris worm was the first known internet worm, and the cost of cleaning
    up the mess it created was an estimated 100 million US dollars. Morris was fined
    10,000 US dollars but made a good career later; he is now a professor at the Massachusetts
    Institute of Technology. A disk with the source code of the worm is on display
    at the Computer History Museum in California.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these examples show us that even a small error can have enormous consequences.
    In the first example, one single programmer made an error that went unnoticed
    in the final product. The biggest problem here is not the error that was introduced
    but that no one saw it and stopped it before it was too late.
  prefs: []
  type: TYPE_NORMAL
- en: As for the second example, here, we had a person who created something on his
    own. The nature of this program was that no one should know about the program.
    The problem here is that he had no organization behind him with other developers
    who could help him make a plan for how the program should work. It is extremely
    hard to think about all the consequences one decision will have if you are alone
    and don't have anyone else to discuss your ideas with. In the latter case, having
    other people around him would hopefully result in them telling him that the idea
    as a whole was bad and should never have been done in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have seen two examples of what a bug is, but there are so many other
    kinds around. Due to this, the first thing we should do is attempt to define what
    a bug is.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a software bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand what a software bug is, we can first look at Techopedia''s definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A software bug is a problem causing a program to crash or produce invalid
    output. The problem is caused by insufficient or erroneous logic. A bug can be
    an error, mistake, defect, or fault, which may cause failure or deviation from
    expected results."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from this definition, a bug is caused by software that is not
    functioning correctly. This can result in incorrect or unexpected results. We
    can understand this if, say, we provide a program with some well-defined data.
    Here, we expect a certain result back. If the result is not what we expect, the
    reason can either be that there is something wrong with the data we provided or
    there is something wrong with the program. Let''s say we, for example, provide
    a calculator app with the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will expect the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we get anything else, we can say that there is a bug in our application.
  prefs: []
  type: TYPE_NORMAL
- en: The definition also says that a program can behave in unintended ways. This
    is when we expect a program to do one thing, but it turns out that it does something
    completely different. If we have a program that should turn down the thermostat
    in our home when it's reached a certain temperature, but it turns it up, then
    that would be a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we have bugs in our software? There isn't a single answer to this. To
    understand this, we will need to define some different types of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding types of software bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways we can classify bugs. Here, we will look at some
    common types, see what they are, and see what they can look like.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arithmetic bugs, as the name suggests, have to do with arithmetic operations.
    There are a few things we should look out for, as outlined in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Division by zero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One such thing is division by zero. This is not only related to computers as
    we can also never perform a division where the divisor is zero. In mathematics,
    dividing by zero has no meaning, because if we do ![](img/Formula_09_001.png),
    we will get 3\. If we multiply 3 and 2, we will get 6 back. But if we take ![](img/Formula_09_002.png),
    there is no number we can multiply by zero to get back to 6.
  prefs: []
  type: TYPE_NORMAL
- en: This might seem simple enough, but sometimes, it happens anyway, especially
    when we are working with variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have two variables that get their value somewhere in
    our application, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Later on in the program, we perform some calculations, maybe with some other
    variables, it might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the `current_temperature` variable now has the same value as `y`, which is
    `14` in our case, we will store the result, `0`, back in `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we then did something like this, our application will crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that we are dividing by zero. It might not be obvious
    that `y` is zero, so the problem is not easy to spot.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic overflow/underflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091), *Working with
    Data – Variables*, in the *Primitive data types* section, we talked about integer
    types and that they could have a fixed size. What that means is that some integer
    types have a predefined size that describes how much memory they will use. This
    also gives a variable of this type a maximum and minimum value. As long as we
    are storing values between the maximum and minimum value, there will be no problem,
    but what happens if we try to store a value that is larger or smaller than these
    values? Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: We will now assume that we are using a programming language that has a data
    type called byte. This data type can store values between -128 and 127.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a variable of this type and assign it a value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, what would happen if we increased this variable by one?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, we expect 127 + 1 will result in 128\. To our surprise, it is -128.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that when we are at the maximum value a data type can
    handle and increase it by one, we will end up at the smallest number it can handle;
    in this case, -128\. If we had increased it by 2 instead of 1, we would have ended
    up with -127.
  prefs: []
  type: TYPE_NORMAL
- en: This is an overflow error. If we were at the lowest value the data type can
    handle and decrease the value by one, we would go to the largest value of this
    data type. This is called an underflow error.
  prefs: []
  type: TYPE_NORMAL
- en: Loss of precision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091),
    *Working with Data – Variables,* floating-point numbers are something that is
    tricky for computers to work with, and we are always faced with the risk of losing
    precision when it comes to rounding off a value.
  prefs: []
  type: TYPE_NORMAL
- en: In some languages, this can become obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output of this program would, of course, be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To our surprise, some languages will instead give us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the computer showing the problems it has with floating-point numbers.
    If you need a refresher on how this works, go back to [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091),
    *Working with Data – Variables*, and read the section about floating-point numbers
    under the *Numeric type* heading.
  prefs: []
  type: TYPE_NORMAL
- en: We could argue that an error of 0.0000000000000004 is not much, but what if
    we were working with several of these results and added them together? This error
    would now accumulate and soon, we will have a value that is way off.
  prefs: []
  type: TYPE_NORMAL
- en: These three are the most common arithmetic errors we will find in software.
    The next group of errors are not as fun for us programmers as they are introduced
    when our logic is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Logical errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A logical error will usually not make a program crash but produce an unintended
    result. Unfortunately for us, there are a lot of opportunities to make logical
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could, for example, accidentally use the wrong operator. An example would
    be if we wanted to check if somebody''s age was above 18, but we did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common thing is to forget to use less than or equal to or greater than
    or equal to. Here, we could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is incorrect as we actually wanted to check if the age was greater or
    equal to 18, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common error is to use one equals sign instead of two. Some languages
    will let us do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we intended to use the equal to operator, ==, but instead, we used the
    assignment operator, =. Some languages will interpret this as assigning value
    to age. This will give us two problems. First, we might enter the `if` statement,
    even if, in reality, we shouldn't. The other problem is that the value that was
    in the `age` variable now will be overwritten by the value `20`.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that has always amazed me is how hard it can be to get the logical
    operators right. Even though they are only two, it is very common that we use
    one instead of the other. Yes, even I do that at times.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we intend to check if the age is above `12` and below `20`, we might write
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, what we wanted to do was this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first example will always be true, as age will always be either greater
    than `12` or less than `20`.
  prefs: []
  type: TYPE_NORMAL
- en: These are just some examples of logical errors. They can be hard to find as
    the code is valid, meaning that the program will run, but its behavior will be
    unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: An easier group of errors to amend is when the code is written so it can't run
    because we are breaking the language syntax rules. Let's take a look at these
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rules that tell us how code should be written in a particular language are
    called its syntax. When we write code that does not follow the syntax rules, we
    get what is called a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: These are rather easy to spot compared to many other errors as the compiler
    or interpreter will tell us where the problem is and also give us a hint about
    what the error is.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some syntax errors and investigate what message we get back that
    can assist us in fixing the error.
  prefs: []
  type: TYPE_NORMAL
- en: Here is one syntax error. Can you spot it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are trying to print a string, but we forgot the closing quote. Languages
    will report this error differently. As we will see, the message we get back does
    not always direct us to the real error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are four examples from four different programming languages – Python,
    Go, C#, and JavaScript, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The second and third are talking about newline, while the first and last ones
    are talking about strings. We will need to learn the messages we get back from
    the language we are using. All of them will also direct us to where the error
    was discovered. In different formats, we are directed to line 1, column 12\.
  prefs: []
  type: TYPE_NORMAL
- en: The location that's given is not always where the actual error is, it is where
    the compiler/interpreter discovered the error. If you don't find anything at the
    location given, look at the line above or sometimes some lines above this location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know from earlier chapters that we cannot name variables with a number as
    its first character. Let''s do that anyway and do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us messages like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, some languages call these errors syntax errors, while others
    will name them things such as compilation errors. Again, we will need to learn
    what the language we are using is calling these errors as it will help us identify
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Often, our editor will assist us in finding syntax errors by marking them even
    before we run the application. It uses the same technique as a spellchecker in
    a MS Word processor – a wiggly red line below the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following screenshot. Here, we can see that the editor had marked
    a syntax error before we tried to run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 –  An editor showing a syntax error in the programming language
    Python](img/Figure_9.2_B15554_Swiggly_line.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 –  An editor showing a syntax error in the programming language Python
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors are, as mentioned previously, rather easy to find as the program
    will not run and we will be directed to a location close to where the error is.
    But how do we find bugs when we have logical errors? We have tools for this called
    debuggers.
  prefs: []
  type: TYPE_NORMAL
- en: Finding bugs using a debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A debugger is a tool that can help us see what happens when a program is running.
    As we have already mentioned, some bugs can be hard to find and understand just
    by running the program. Often, we will discover a strange behavior in the program,
    but it might not be obvious what the reason behind this behavior is.
  prefs: []
  type: TYPE_NORMAL
- en: A debugger is an application that is tailored for a particular programming language
    and can be used to pause the application at a specified code line. At this point,
    we can inspect what values all the variables have.
  prefs: []
  type: TYPE_NORMAL
- en: We can also resume the execution of the program or execute it one line at a
    time to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try using a debugger. To do this, we first need to pick a language and
    then write a small program that contains a logical error. We can take one of the
    errors that we previously looked at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Remember that in this example, we accidentally used `or` instead of `and`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write this program in Python. In the following screenshot, we can see
    what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – A small program written in Python that contains a logical error](img/Figure_9.3_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – A small program written in Python that contains a logical error
  prefs: []
  type: TYPE_NORMAL
- en: On the first line, we declare (remember that declaring a variable means that
    we are creating it) a variable called `age` and assign the value `17` to it.
  prefs: []
  type: TYPE_NORMAL
- en: Then comes our `if` statement, where we're checking if the age is greater than
    `12` or less than `20`. The error here is that we used `or`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running this program, we get the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now change the program, that is, we assign another value to age, say
    `24`, and run it, it will not give us the predicted result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the changed program in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The same program with another value for age](img/Figure_9.4_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The same program with another value for age
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's use a debugger and explore this error. The first thing we need to
    do is set a breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A breakpoint is a way for us to say, run the program to this point, then pause
    it and show me the status of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see that we have a breakpoint on the line
    containing an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 –  A program with a breakpoint on line 3](img/Figure_9.5_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 –  A program with a breakpoint on line 3
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now run the program, it will stop when it reaches this line. At this
    point, the line that contains the breakpoint has still not executed. It will look
    like what''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The debugger has stopped at the breakpoint](img/Figure_9.6_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – The debugger has stopped at the breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: The line we are about to execute is marked with a blue line. Also, note that
    this debugger is showing the `age` value in gray on line 1\. This helps us understand
    what value it currently has.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we zoom out a bit, we will see that we have some other tools that have popped
    up as the program paused at this line. We can see what it looks like in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The debugger tools](img/Figure_9.7_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – The debugger tools
  prefs: []
  type: TYPE_NORMAL
- en: 'What we see here there are several tools that are provided to us by the debugger
    application. Let''s understand what they consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: To the right, we see a section marked **Variables**. Here, we can see all the
    variables that are currently defined and what values they have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Above this window, we can see some arrows pointing in different directions.
    They are used to advance the program one step. We have some options here. The
    first one is the arrow that first goes up and then goes down (marked as **1**
    in the preceding screenshot). This is called step over. If we have a function
    call on this line, step over will not jump to that function. Instead, it will
    call that function, run all the code within it, and then stop again when it returns
    to where we currently are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next arrow, the one pointing straight down, is step into (marked as **2**).
    This will, if we have a function on this line, jump to that function and let us
    step through it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can ignore the two arrows that follow and instead look at the one pointing
    straight up (marked as **3**). This one is called step out. We can use this one
    if we have stepped into a function and changed our minds.  It will run all the
    code in the function and stop again when we go back to the location we came from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the far left, we have some other tools that will restart the program (marked
    as **4**), resume the execution of the program (marked as **5**), pause a running
    program (marked as **6**), stop the program (marked as **7**), allow us to view
    all the breakpoints we currently have in the program (marked as **8**), and ignore
    all the breakpoints and continue to run (marked as **9**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our problem, none of these tools will be able to help us. We know that
    the program will enter the `if` statement as the output was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, there is another tool that might help us. In the following screenshot,
    we can see it marked with a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The evaluate expression button](img/Figure_9.8_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – The evaluate expression button
  prefs: []
  type: TYPE_NORMAL
- en: 'This tool, which looks like a small calculator, is the evaluate expression
    tool. If we click it, we will see a window like the one shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The evaluate expression window](img/Figure_9.9_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – The evaluate expression window
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top field, we can enter an expression. This can help us understand what
    is happening. We are currently on this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we enter a part of this expression into the evaluation expression tool,
    it will show us the result. Let''s take the first part of this `if` statement.
    Entering it into the tool will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Evaluating an expression](img/Figure_9.10_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Evaluating an expression
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that this part of the `if` statement is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now do the same with the second part, we will see that the result is
    false, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Evaluating another expression](img/Figure_9.11_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Evaluating another expression
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now take both of these statements, since we have written them in the
    code, and check the result, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Evaluating the full expression](img/Figure_9.12_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Evaluating the full expression
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the result of the full expression is true, even though
    the value is greater than the last part of the condition, `20`.
  prefs: []
  type: TYPE_NORMAL
- en: We can now suspect that the culprit is `or`. Let's change it to an `and` and
    see the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see that the result is now evaluated to
    `false`, which is the value we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Evaluating the expression with and instead of or](img/Figure_9.13_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Evaluating the expression with and instead of or
  prefs: []
  type: TYPE_NORMAL
- en: We can now stop the debugger and change our code.
  prefs: []
  type: TYPE_NORMAL
- en: This was one example of when the debugger can help us understand a problem.
    We will frequently run into errors like this one, and what the problem is might
    not be obvious to us right away. As a programmer, we should learn to use the debugger,
    what features it has to offer, and how we can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we have other types of errors where the syntax is correct, but still,
    the program will crash. These are called exceptions. We will move on to those
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Working with exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **exception** (short for **exceptional event** or **exceptional condition**)
    is an error or an unexpected event that occurs while a program is running. It
    is caused by a condition in the software where the program has reached a state
    where it can no longer run.
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons we can get an exception. One example could be if our
    program needs to read data from a file, but the file is not where it is supposed
    to be. Since the program has a reason to read the data from this file, a failure
    to do so will put the application in a state where it can no longer guarantee
    that its output will be correct. The best option, in this case, is just to halt
    the program and give back an error that hopefully instructs us about what the
    problem is so we can fix it.
  prefs: []
  type: TYPE_NORMAL
- en: No software developer wants to write an application that crashes. It can make
    the users of the application lose unsaved work, though the consequences might
    be even worse, depending on the nature of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Soon, we will talk about how we can handle exceptions so that they don't crash
    our program. But before we do that, let's explore exceptions a bit so that we
    have an understanding of how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some common reasons we get exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Common reasons for exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw, a missing file can be one reason we get an exception. Another common
    reason is that when we are trying to index into a sequence, we use an index that
    is larger than the sequence. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have an array (you can read more about array''s in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*,
    Working with Data – Variables*, in the *Composite type* section). It contains
    four values; in this case, four names. We can index into this array to retrieve
    a single value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the index value for the first item is 0, not 1, so the third item,
    `Cara`, has index 2.
  prefs: []
  type: TYPE_NORMAL
- en: What will happen if we use an index value that is greater than the number of
    items we have, like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There is no value at this location, so the program cannot fetch it for us. The
    syntax is correct, and if we had enough values, it would work perfectly fine.
    But this time, it won't, as we have used an index for something that does not
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program cannot continue at this point as it cannot guess what it should
    do. We have given an instruction that says that we want a value from this location.
    The programming language cannot just come up with a value for us. The most sensible
    thing to do at this point is to just end the program and wait for it to give us
    an error. This error might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is an exception. We can see it in the output as it clearly says `IndexOutOfBoundException`.
  prefs: []
  type: TYPE_NORMAL
- en: How much we use exceptions, and how many different exceptions we will need to
    deal with the different issues available, will differ greatly between languages.
    Some, such as Java, make heavy use of exceptions. C++, on the other hand, has
    just a handful of built-in exceptions. Then, we have languages such as Go that
    don't have exceptions at all, but instead will let a function return an error
    type alongside the real return value from the function.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the errors that we already have seen in this chapter will also generate
    exceptions. One such exception will happen if we divide something by zero.
  prefs: []
  type: TYPE_NORMAL
- en: Most languages support exceptions. Even if the number of exceptions a programming
    language has differs, the way they work will be pretty much the same, no matter
    what language we are using. The names will differ, as well as what kinds of exceptions
    we have, but the way we work with them will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: At times, it can be hard to understand the output we get from an exception.
    The reason for this is that when we get an exception, something called the call
    stack is also printed.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions and the call stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that we have a program and that in it, we have a `main` function. This
    function is calling another function that calls another function, and so on. We
    will have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – A function that calls a function that calls a function, and
    so on](img/Figure_9.14_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – A function that calls a function that calls a function, and so
    on
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of where we are in this chain of function calls is called the
    call stack, and that is handled by the programming language when we run the program.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that we get an exception in the last function called **function
    c**. This function will now exit immediately and return to where it was called.
    That is **function b**. This function will also exit as soon as the control gets
    handed back to it, and we will be returned to where we came from. This time, it
    is **function a**. Again, this function will be terminated immediately, and we
    are returned to the **main** function. The last thing that will happen is that
    this function will also end. Since this was the first function that was called
    in this application, the application as a whole will end.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why all the functions will exit is that none of them handle the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will get not only the exception information printed to the screen but
    also the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s use a very simple program like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is a rather silly program, but it will illustrate what will happen. At
    the bottom, we have a function called `main`. The `main` function will be called
    automatically when we run this program.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `main` function, we call the function named function `a`. This function
    will call `function b`, which calls `function c`.
  prefs: []
  type: TYPE_NORMAL
- en: When we enter `function c`, `function b` is still running and is waiting for
    `function c` to finish. The same thing is true for `function a`, which waits for
    `function b`. The `main` function is waiting for `function a` to finish, so at
    this point, we have four active functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, inside `function c`, we perform a division by zero, causing an exception
    to go off.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, `function c` will exit immediately. Control will be handed back
    to `function b`, which will exit, giving the control back to `function a`, which
    exits back to `main`, and finally, the program will exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output we''ll get will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, all the function calls are there. How this is displayed will
    differ from language to language. Some will print all the functions in the opposite
    order. Again, this is something we will need to learn when we pick up a new language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we get all this information is that it can help us figure out where
    things went wrong. Even if the error occurred in `function c`, the reason it happened
    might originate somewhere else. Let''s assume that the program looked as follows
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, `function c` takes two arguments, and it uses these to perform the calculation.
    This happens when `function c` is called from `function b`. The problem arises
    when we pass in `10` and `0` as arguments to the call.
  prefs: []
  type: TYPE_NORMAL
- en: Since the data has its origins in `function b`, this is where the problem came
    from. `function c` does not know the origins of these two values. They might come
    from some user input, they might have been read from a file, or they may have
    come from any other source.
  prefs: []
  type: TYPE_NORMAL
- en: To fully understand the origins of this problem, we will need the information
    that we get from the call stack as it tells us how we ended up in `function c`
    when the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we don't want the program to crash? No problem. We can write code
    that will handle exceptions. Let's look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how we can handle exceptions, we must first understand what the
    origins of a problem might be. It is only when we have understood this that we
    can insert measures to handle them correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to our function that divides two values. Let''s say this function
    takes two arguments, as it did in our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We should assume that this function does something more than just print this
    single line. We can mark it out with some comments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We know that as this function divides two values, we might get an exception
    if `y` is given a value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we should ask ourselves is if this is the best place to handle
    the problem. It could be, but most likely, it is not. This function is getting
    two values sent to it as arguments. Several parts of the application might use
    the function, so it has no way of knowing the source of the data that is being
    sent to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can do, though, is check if `y` is equal to zero before we perform
    the division. Let''s do that now. At the same time, we can change the function''s
    name to `calculate` as it better reflects what the function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: But what should we do if `y` is zero? We cannot continue running the function
    as we would then perform the division anyway. We cannot change `y` to something
    else either, because what would we even change it to?
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to signal to the caller of the function that we cannot accept
    a value of zero for `y`.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this would be to let the exception happen and remove the `if`
    statement again. If we did that, the caller could handle the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can handle an exception when we call a function. The call
    to the function would then need to be within a special block of code called a
    `try` statement. It could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the call to the `calculate` function is located within
    a `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: If everything is fine and we return from the function without any exception,
    the program will jump to the line after `end_catch` and resume its execution.
  prefs: []
  type: TYPE_NORMAL
- en: But if we get an exception and that exception is of the `ZeroDivisionError`
    type, we will end up in the block below, which begins with a `catch`.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions can be caught, but we need to specify what exception it is we want
    to handle. If we get another exception, one that does not have a matching `catch`,
    the program will crash as before.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the function like this could be a solution for us, but is it a good
    solution? Not really. Imagine that the `calculate` function is located in a different
    module that is in a different file. It might even be written by somebody else.
    In this situation, how do we know that it will perform a division and that it
    will use the second value we pass to it as the divisor in that division? We will
    most likely not know anything about that, or we should at least assume that the
    users do not know anything about how the function is written.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we could not assume that they will use a `ZeroDivisionError` exception
    in their `catch` statement. Instead, we could give them another exception that
    might make more sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our `calculate` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`throw` will create another exception; this time, one called `ValueError`.
    We are also passing a string to this exception. If someone now calls our function
    and gives us a value of zero for `y`, they will get this exception with the message
    we provided.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When they call our function, they could now check for this exception instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Since this is the location where the bad value for `y` originated, it is much
    more likely that this is where we can change it. If this, for example, was a value
    that was given to us by the user of the program, we could give a nice error message
    back, saying that they cannot enter a value of zero.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that this is the location that *owns* the data and therefore has
    the opportunity to change it.
  prefs: []
  type: TYPE_NORMAL
- en: If we use `try…catch` blocks around calls to functions that can throw exceptions,
    the program will no longer crash. In this case, the `calculate` function will
    still exit as soon as we throw the `ValueError` exception, but since we are catching
    it right after the call to the function, we might be able to correct the problem
    and call the function again with a correct value.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are a great way to handle conditions when we can't decide what to
    do due to a condition that we could not predict when we wrote the program. Without
    them, it would be very difficult to signal to other parts of the program that
    something is wrong. We should use them when we need to, but also ensure proper
    care. Exceptions always send a clear message regarding what is wrong and assist
    the author of the code that receives the exception with understanding what the
    problem is.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we realized that we, as humans, make mistakes, but we can go
    back and fix them as well.
  prefs: []
  type: TYPE_NORMAL
- en: A software bug is an error in an application that can have several causes. Depending
    on what is behind the bug, we must approach it differently when trying to fix
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, as with syntax errors, we will be told what the cause of the
    bug is right away, and even be directed to the correct location in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Other bugs will be harder to find. When the programming language syntax is correct,
    but the logic is not, the program will behave in unexpected ways. To be able to
    find these bugs, we can use a tool called a debugger. It helps us track down the
    bugs by letting us pause the execution of the program and see all the values the
    variables have; it will even let us step through the execution one line at a time.
  prefs: []
  type: TYPE_NORMAL
- en: An exceptional event is when things that should not happen still happen. In
    programming, they are referred to as exceptions. When they happen, they will immediately
    halt the execution of the program if they are not handled. Fortunately, we can
    handle them by inserting code that will only run if the exceptional event occurs
    so that we can try to fix the problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at different ways to approach a problem and
    create a solution with code. This is called a paradigm. A programming language
    will use one of these. As we will see, some languages will use concepts from more
    than one paradigm.
  prefs: []
  type: TYPE_NORMAL
