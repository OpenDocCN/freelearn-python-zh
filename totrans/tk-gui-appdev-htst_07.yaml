- en: Chapter 7. Some Fun Project Ideas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous projects, we have explored most of the important features of
    Tkinter. Developing new projects is now about extending what we have learned so
    far. In this project, we will build several partly-functional applications that
    you can take forward.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Briefing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, we will develop "bare bone structures" for several applications
    from different domains. The applications we will build here include:'
  prefs: []
  type: TYPE_NORMAL
- en: Screen saver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snake game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weather Reporter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phonebook application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphing with Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Is It Awesome?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find this project useful as we will delve further in to learning about
    the power of Tkinter **Canvas** widget, and develop some basic animations for
    our screen saver program.
  prefs: []
  type: TYPE_NORMAL
- en: When developing the Snake game, we will learn to develop a multithreaded Python
    application efficiently using the **Queue implementation** . As you will see,
    this is a handy tool to have when working on multithreaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Weather Reporter application will introduce you to the basics of network
    programming. You will learn how to mine into the seemingly infinite resource that
    is available to us over the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The phonebook application will show you how to work with databases. This is
    vital for developing any large-scale application where persistence is required.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we look at basic graphing abilities of Tkinter. We also look at ways
    of embedding matplotlib graphs in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Your Hotshot Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key objectives outlined for this project include developing and understanding
    the followings:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic animations with Tkinter canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue implementation for a multithreaded Tkinter application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network programming and tapping into resources over the Internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with data interchange formats like JSON and XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database programming and basic CRUD operations on a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphing with Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a screen saver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by building a screen saver for our desktop. The screen saver
    will consist of several random-colored and random-sized balls bouncing all over
    the screen at random velocity, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a screen saver](img/7941OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Carry out the following steps to create the screen saver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a class to generate balls with random attributes. Accordingly,
    we define a new class named `RandomBall` to achieve this (refer to the `7.01 screensaver.py`
    Python file, available in the code bundle):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `__init__` method takes three arguments, an instance of the Canvas widget,
    the screen width and the screen height. It then initializes the initial *x* and
    *y* positions for a ball as random numbers, starting from `0` up to the maximum
    screen coordinates.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It also initializes the velocity of the ball in *x* and *y* directions, the
    radius and color of the ball changes in a random fashion.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the hexadecimal color coding system uses two hexadecimal digits for
    each of red, green and blue colors, there are 16^2 (256) possibilities for each
    color. We therefore create a lambda function that generates a random number from
    0-255, and use this function to generate three random numbers. We convert this
    decimal number to its two-digit equivalent hexadecimal notation using the format
    %02x to generate a random color for the balls.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second method creates the actual ball using the canvas `create_oval` method
    (refer to the `7.01 screensaver.py` Python file available in the code bundle):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's now code the method to handle ball movement on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method also checks if the ball has reached the end of the screen on any
    of the sides. If the ball has actually reached the end of the screen, it simply
    changes the direction by appending a negative sign to the velocity of the ball.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The method finally moves the ball using the `canvas.move` method (refer to
    `7.01 screensaver.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is all to our `RandomBall` class. We can use this class to create as many
    ball objects as we want to display in our screen saver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, that we have coded methods to generate balls and to move them, let''s
    create our screen saver. We now create a class named `ScreenSaver` that will show
    the actual screen saver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `__init__` method of the `ScreenSaver` class takes the number of balls (`num_balls`)
    as its argument.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create a root window and calculate the height and width of the screen
    using the `winfo` method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `root.overrideredirect(1)` to remove the enclosing frame from the parent
    window.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then specify the geometry of the parent window to fill the entire screen.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We make the parent window transparent using `root.attributes('-alpha', 0.3)`.
    We add a transparency of `0.3` to make the window translucent.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then bind the root to call our `quit` command on the event of clicking the
    mouse button, pressing any keyboard button, or mouse motion. This is to ensure
    that our program behaves like a screen saver, exiting on any interactions from
    the user's end.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create a canvas to cover the entire screen with `Canvas(self.root, width=w,
    height=h)`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We create several random ball objects outs of the `RandomBall` class, passing
    along the Canvas widget instance, the width, and the height of the screen as its
    arguments.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We finally make a call to run the screen saver with the `run_screen_saver()`
    method within the `ScreenSaver` class, which is discussed in the following.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this step, we will run the `ScreenSaver` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `run_screensaver()` method simply moves each ball by calling itself at a
    regular interval of 20 milliseconds
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also define the `quit` method in our `ScreenSaver` class to quit from the
    main loop and exit the program:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the screen saver, we instantiate an object from our `ScreenSaver` class,
    passing the number of balls as its argument:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have used two Toplevel window methods `root.overrideredirect` and `root.attributes`,
    in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of methods that can be applied to the Toplevel window, refer
    to the *The Toplevel window methods* section in [Appendix B](apb.html "Appendix B. Quick
    Reference Sheets"), *Quick Reference Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our screen saver is ready!
  prefs: []
  type: TYPE_NORMAL
- en: In fact, if you are working on a Windows platform, and when you learn to create
    an executable program from Python programs (discussed in [Appendix A](apa.html
    "Appendix A. Miscellaneous Tips"), *Miscellaneous Tips*), you can create an executable
    file with `.exe` extension for this screen saver. So then, you can change its
    extension from `.exe` to `.scr` and right-click, and select **Install** to add
    it to your list of screensavers!
  prefs: []
  type: TYPE_NORMAL
- en: Building a Snake game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now build a simple Snake game. As usual, we will be making use of the
    Canvas widget to provide the platform for our Snake program.
  prefs: []
  type: TYPE_NORMAL
- en: We will use `canvas.create_line` to draw our snake, and `canvas.create_rectangle`
    to draw the snake-food.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the primary objectives for this project is to introduce the Queue implementation
    in Python as we used it in conjunction with the **threading** module.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have built single-threaded applications. However, threading can be
    difficult to handle when there is more than one thread in an application, and
    these threads need to share attributes or resources among them. In this case,
    you cannot predict the thread execution order at all. OS does it very randomly
    and swiftly each time.
  prefs: []
  type: TYPE_NORMAL
- en: To handle this complexity, threading module provides some synchronization tools,
    such as locks, join, semaphores, events, and condition variables. However, it
    is—in most cases—safer and simpler to use queues. Simply put, a **queue** is a
    compound memory structure that is thread-safe; queues effectively channel access
    to a resource to multiple threads in a sequential order, and are a recommended
    design pattern that uses threads for most of the scenarios that require concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: The **Queue** module provides a way to implement different kinds of queuing,
    such as **FIFO** (default implementation), **LIFO** queue, and **Priority** queue,
    and this module comes with a built-in implementation of all locking semantics
    required for running multithreaded programs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More information about the Queue module can be found in the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.Python.org/2/library/queue.html](http://docs.Python.org/2/library/queue.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick roundup of the basic usage of the Queue module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see a simple demonstration of using queue to implement a multithreaded
    application (refer to `7.02 threading with queue.py` available in the code bundle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a `Worker` class, which inherits from the `threading` module
    of Python. The `__init__` method takes in a queue as its argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then override the `run` method of the `threading` module to get each item
    from the queue using `queue.get()`, which is then passed on to the `taskHandler`
    method, which actually executes the task specified in the current queue item.
    In our example, it does nothing useful but printing the name of the task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the work is done on a particular thread by our `taskHandler` method, it
    sends a signal to the queue telling that the task has been completed using the
    `queue.task_done()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside our `Worker` class, we create an empty queue in our `main()` method.
    This queue is populated with a list of tasks using `queue.put(task)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create six different threads and pass this populated queue as its argument.
    Now that the tasks are handled by the queue, all threads automatically ensure
    that the tasks are completed in a sequence in which they are encountered by the
    threads, without causing any deadlocks or two different threads trying to work
    on the same queued task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of creating each thread, we also create a pool of daemon threads
    using the `mythread.setDaemon(True)` method. Doing this passes control to our
    main program once all threads have completed execution. If you comment out the
    line, the program would still run, but would fail to exit after all threads have
    completed executing the tasks in the queue. Without the daemon threads, you'd
    have to keep track of all the threads and tell them to exit before your program
    could completely quit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `queue.join()` method ensures that the program flow waits there
    until the queue is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know how to use queues to handle multithreaded applications effectively,
    let''s build our Snake game. In its final form, the game would be like the one
    shown in the following screenshot (refer to the `7.03 game of snake.py` Python
    file available in the code bundle):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start coding our game, by first creating a basic `GUI` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This code should be mostly familiar to you by now, because we have created similar
    `GUI` classes several times in the past.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: However, rather than passing the root instance as an argument to its `__init__`
    method, our GUI class now inherits from the Tk class. The line `Tk.__init__(self)`ensures
    that the root window is available to all methods of this class. This way we can
    avoid writing `root` attribute on every line by referencing `self.root` simply
    as `self`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then initialize the canvas, line (snake), rectangle (food) and text (to display
    score).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then call the function `queueHandler().` This yet to be defined method would
    be similar to `main` method defined in the previous queue example. This would
    be the central method which will process all tasks in the queue. We will come
    back to define this method once we have added some tasks to the queue.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will create the `Food` class, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because we want to process all data centrally from within a queue, we pass the
    queue as an argument to the `__init__` method of the `Food` class. We choose to
    run this from the main program thread to demonstrate how a code which is being
    executed in the main thread can communicate with attributes and methods from other
    threads.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__init__` method calls another method called `generate_food()`, which is
    responsible for generating the snake-food at random positions on the canvas.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `generate_food` method generates a random *(x, y)* position on the canvas.
    However, because the place where the coordinates coincide is just a small point
    on the canvas, it would be barely visible. We therefore generate an expanded coordinate
    (`self.exppos`) ranging from five values less than the *(x,y)* coordinate up to
    five values higher than the same coordinate. Using this range, we can create a
    small rectangle on the canvas which would be easily visible and would represent
    our food.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: However, we do not create the rectangle here. Instead, we pass the coordinates
    for the food (rectangle) into our queue using `queue.put`. Because this queue
    is to be made available to all our classes, we will have a centralized worker
    named `queue_handler()`, which will process this queue to generate the rectangle
    from our GUI class later. This is the central idea behind a Queue implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now create the `Snake` class. We have already passed a task to generate
    our food to the central queue. However, no thread was involved in the task. We
    could also generate our Snake class without using threads. However, because we
    are talking about ways to implement multithreaded applications, let''s implement
    our Snake class to work from a separate thread (refer to `7.03 game of snake.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we create a class named `Snake` to run from a separate thread. This class
    takes the GUI and queue as its input arguments.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We initialize the points earned by the player from zero and set the initial
    location of the snake using the attribute `self.snake_points`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we start the thread and create an infinite loop to call the `move()`
    method at small intervals. During every run of the loop, the method populates
    the queue with a dictionary having the key as `'move'` and the value equal to
    the updated position of the snake through the `self.snake_points` attribute.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this step, we will be making the snake move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The thread initialized above calls the `Snake` class `move()` method to move
    the snake around on the canvas. However, before we can move the snake, we need
    to know the direction in which the snake should move. This obviously depends on
    the particular key pressed by the user (Left/Right/Top/Down key).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accordingly, we need to bind these four events to the Canvas widget. We will
    do the actual binding later. However, we can now create a method named called
    `key_pressed`, which takes the `key_press` event itself as its argument and sets
    the direction value according to the key that is pressed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the directions, let''s code the `move` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description for the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, the `move` method obtains the latest coordinates for the snake depending
    on the keyboard event. It uses a separate method called `calculate_new_coordinates`
    to get the latest coordinates.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It then checks if the location of the new coordinates coincide with the location
    of the food. If they match, it increases the score of the player by one and calls
    the `Food` class `generate_food` method to generate a new food at a new location.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the current point does not coincide with the food coordinates, it deletes
    the last item from the snake coordinates using `self.snake_points.pop(0)`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, it calls another method named `check_game_over` to check if the snake
    collides against the wall or against itself. If the snake does collide, it appends
    a new dictionary item in the queue with the value `'game_over':True`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the game is not over, it appends the new position of the snake to
    the list `self.snake_points`. This is automatically added to the queue, because
    we have defined `self.queue.put({'move':self.snake_points})` in the `Snake` class's
    `run()` method to update every 0.1 seconds as long as the game is not over.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's create the Queue handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a `Food` class feeding the centralized queue from the main program
    thread. We also have the `Snake` class adding data to the queue from one thread
    and a `GUI` class running the `queue_handler` method from another thread. So,
    the queue is the central point of interaction between these three threads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, it is time to handle these data to update the content on the canvas. We
    accordingly define the `queue_handler()` method in our `GUI` class to work on
    items in the queue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description for the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `queue_handler` method gets into an infinite loop looking for tasks in the
    queue using `task = self.queue.get(block=False)`. If the queue becomes empty,
    the loop is restarted using `canvas.after`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a task is fetched from the queue, the method checks its key.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key is `'game_over'`, it calls another method named `game_over()` that
    we defined next.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key of task is `'move'`, it uses `canvas.coords` to move the line to
    its new position.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key is `'points_earned'`, it updates the score on the canvas.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When execution of a task completes, it signals the thread with the `task_done()`
    method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`queue.get` can take both `block=True` (default) and `block=False` as its argument.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the block is set to `False`, it removes and returns an item from the queue,
    if available. If the queue is empty, it raises `Queue.Empty`. When the block is
    set to `True`, `queue.get` fetches an item from the queue by suspending the calling
    thread, if required, until an item is available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this step, we will code the method to handle the `game_over` feature for
    the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `queue_handler` method calls the `game_over` method in case of a matching
    queue key:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description for the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We first set the `game_over` attribute to `True`. This helps us exit out of
    the infinite loop of `queue_handler`. Then, we add a text on the canvas displaying
    the content **Game Over**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also add a **Quit** button inside the canvas, which has a command callback
    attached to quit the root window.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Take a note of how to attach other widgets inside the canvas widget.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s Run the game. The game is now ready. To run the game, we create a function
    outside all other classes named `main()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create an empty queue, and pass it as an argument to all three of our classes
    so that they can feed tasks into the queue. We also bind the four directional
    keys to the `key_pressed` method, which is defined earlier within our `Snake`
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our game is now functional. Go try your hands at controlling the snake, while
    keeping its stomach filled.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we created three classes such as `Food`, `Snake`, and `GUI`. These
    three classes feed information about the task related to their class to a centralized
    queue which is passed as an argument to all the classes.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a centralized method named `queue_handler`, which handle tasks
    from the queue by polling tasks one at a time and completing it in a non-blocking
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: The game could have been implemented without threads and queues, but it would
    have been slower, longer, and more complex. By using queues to manage data from
    multiple threads effectively, we have been able to contain the program to less
    than 150 lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you should now be able to implement queues for managing other programs
    that you design at your work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Weather Reporter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now build a simple Weather Reporter application. The goal of this project
    is to introduce you to the basics of network programming, as used in conjunction
    with Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has great support for network programming. At the lowest level, Python
    provides a socket module that lets you connect and interact with the network using
    a simple-to-use object-oriented interface.
  prefs: []
  type: TYPE_NORMAL
- en: For those unaware of network programming, sockets are the fundamental concept
    behind any kind of network communications done by your computer. This is the lowest
    level at which a programmer can access the network. Underneath the socket layer
    lie raw UDP and TCP connections, which are handled by your computer's operating
    system with no direct access points for the programmers. For instance, when you
    type [www.packtpub.com](http://www.packtpub.com) in your browser, the operating
    system on your computer opens a socket and connects to [packtpub.com](http://packtpub.com)
    to fetch the web page and show it to you. Same happens with any application that
    needs to connect to the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a brief look at some of the APIs available in the socket module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the `7.04 socket demo.py` Python file in the code bundle of
    this project, you''ll find that it sends a very obscure looking GET request to
    fetch the contents from the URL in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`message = "GET / HTTP/1.1\r\n\r\n"`'
  prefs: []
  type: TYPE_NORMAL
- en: The data received from the server is also sent in packets, and it is our task
    to collect all the data and assemble them at our end. All these make direct socket
    programming a tedious approach. We do not want to be writing code for all that
    to fetch data from the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will therefore use a higher-level module named `urllib`, which is built
    on top of sockets module but is easier to use. The `urllib` module forms a part
    of Python standard library. With this protocol, fetching contents of a web page
    turns into a four-line code (see the code in `7.05 urllib demo.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This prints the entire HTML source code or whatever is the response from the
    web page [http://www.packtpub.com](http://www.packtpub.com). This is, in essence,
    the core of mining the Web for data and information.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to get data from a URL, let's apply it to build a small
    Weather Reporter application.
  prefs: []
  type: TYPE_NORMAL
- en: This application should take the location as an input from the user, and fetch
    relevant weather-related data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941OT_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create the GUI of the application. This should now be easy for
    you. We create a class `WeatherReporter`, and call it from outside the class within
    the main loop. See the code of `7.06 weather reporter.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The GUI component of the `WeatherReporter` class consists of two methods: `top_frame()`
    and `display_frame()`. The `top_frame()` method creates an entry widget and a
    button that says **Show Weather Info**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `display_frame()` method creates a canvas where the actual weather data
    would be displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the second step, we are going to fetch the weather data from a website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two ways to fetch data from a website. The first method involves getting
    an HTML response from a website, and then parsing the received HTML response for
    data that is relevant to us. This type of data extraction is called **site scraping**
    .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Site scraping is a rather crude method which is employed only when a given website
    does not provide a structured way to retrieve data. On the other hand, some websites
    are willing to share data through a set of APIs, provided you query it for data
    using the specified URL structure. This is clearly more elegant than site scraping,
    because data is interchanged in a reliable and "mutually agreed" format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For our Weather Reporter application, we want to query some weather channel
    for a given location, and in turn retrieve and display the data in our canvas.
    Fortunately, there are several weather APIs which lets us do that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our example, we will use the weather data provided by a the following website:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://openweathermap.org/](http://openweathermap.org/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The OpenWeatherMap service provides free weather data and forecast APIs. This
    site collates weather data from more than 40,000 weather stations across the globe,
    and the data can be assessed by city name and geographic coordinates or their
    internal city ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The website provides weather data in two data formats:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: JSON (JavaScript Object Notation)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: XML and JSON are two popular interchangeable data serialization formats widely
    used for data-interchanging among different applications, which may be running
    on different platforms and using different programming languages, thus providing
    the benefit of interoperability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: JSON is simpler than XML, because its grammar is simpler and it maps more directly
    onto the data structures used in modern programming languages. JSON is better
    suited for data exchanging, but XML is good for document exchanging.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The API documentation for the website tells us that a query, such as `api.openweathermap.org/data/2.5/weather?q=London,uk`
    returns us weather data for London in a JSON format as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The syntax of JSON is simple. Any JSON data is a name/value pair where each
    data is separated from the others by commas. JSON uses curly braces `{}` to hold
    objects and square brackets `[ ]` to hold arrays. We accordingly define a method
    to get the weather data in JSON format in our application (refer to `7.06 weather
    reporter.py` available in the code bundle of this project):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method uses `urllib` to retrieve responses from the website. It returns
    the response in JSON format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we'll start processing the JSON data. The weather data returned using API
    is encoded in JSON format. We need to convert this data into Python data type.
    Python provides a built-in `json` module that eases the process of "encoding-decoding"
    JSON data. We therefore import the `json` module into our current namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we''ll use this module to convert the retrieved JSON data into Python
    dictionary format (refer to `7.06 weather reporter.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll display the retrieved weather data. Now that we have a dictionary
    of all weather-related information provided by the API, let''s add a command callback
    to the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `display_final` method simply takes each item from the dictionary and displays
    it on the canvas using `create_text`. We do not include the code for `display_final`
    because it merely displays the data on the canvas, and this idea should be self-explanatory
    by now. The API also provides an icon-related data. The icons are stored in a
    folder named `weatherimages` (refer to the folder with the same name provided
    in the code bundle) and an appropriate icon is displayed using `canvas.create_image`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our Weather Reporter application is now functional. In essence, the application
    uses the `urllib` module to query the weather API provided by our data provider.
    The data is fetched in JSON format. The JSON data is then decoded into a Python-readable
    format (dictionary).
  prefs: []
  type: TYPE_NORMAL
- en: The converted data is then displayed on the canvas using `create_text` and `create_image`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you access a server from your Python program, it is very important to send
    requests after small time gaps.
  prefs: []
  type: TYPE_NORMAL
- en: A typical Python program is capable of running several million instructions
    per second. However, the server that sends you the data at the other end is never
    equipped to work at that speed.
  prefs: []
  type: TYPE_NORMAL
- en: If you knowingly or unknowingly send large number of requests to a server within
    a short time-span, you may hamper it from servicing its routine requests from
    normal web users. This constitutes what is called the **denial of service** (**DOS**)
    attack on the server. You may be banned or, in worse case, sued for disrupting
    a server, if your program does not make a limited number of well-behaved requests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a phonebook application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now build a simple phonebook application that allows the user to store
    names and phone numbers. The user should be able to create new records, read existing
    records, update existing records, and delete records from the database using this
    application. Together, these activities constitute what is known as **CRUD** (Create,
    Read, Update and Delete) operations on a database.
  prefs: []
  type: TYPE_NORMAL
- en: The main learning objective for this project relates to being able to use a
    relational database with Tkinter to store and manipulate records.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen some basic examples of object persistence with serialization.
    Relational databases extend this persistence using rules of relational algebra
    to store data into tables.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides database interfaces for a wide range of database engines. In
    addition, Python provides a generic interface standard that can be used to access
    database engines, but it is not natively available as a Python module.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the commonly-used database engines include MySQL, SQLite, PostgreSQL,
    Oracle, Ingres, SAP DB, Informix, Sybase, Firebird, IBM DB2, Microsoft SQL Server,
    Microsoft Access, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We will use SQLite to store data for our phonebook application.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite is a server-less, zero-configuration, self-contained SQL database engine
    suitable for developing embedded applications. The source code for SQLite is in
    the public domain, which makes it freely available for use in all sorts of commercial
    and non-commercial projects.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike many other SQL databases, SQLite does not require running a separate
    server process. Instead, SQLite stores all the data directly onto flat files which
    get stored on a computer disk. These files are easily portable across different
    platforms, making it a very popular choice for smaller and simpler database implementation
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.7 comes with a built-in standard library for sqlite3 support. However,
    we need to download the sqlite3 command-line tool that lets us create, modify,
    and access the database using a command-line tool. The command-line shell for
    Windows, Linux, and Mac OS X can be downloaded from [http://sqlite.org/download.html](http://sqlite.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: Following the instruction on the website, install the SQLite command shell into
    any location of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now implement our phonebook application. The application will look like
    the screenshot shown in the following. The application will demonstrate some of
    the common operations involved in database programming, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941OT_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create the database, we open the command-line tool of our operating
    system. On Windows, we generally invoke the command line by typing `cmd` in the
    run console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the command line, we first navigate to the directory where we need to
    create the new database file. In order to create the database, we simply use this
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This creates a database file named `phonebook.db` in the folder from which
    we execute the command. It also displays a message similar to the one shown below:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have now created a database named `phonebook.db`. However, the database
    file is currently empty. It does not contain any tables or any data. So, we get
    no results if we run the command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s for now exit the command-line tool by typing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to store contacts in our database, and that is why we need to create
    the c`ontacts` table. Intuitively, our database table should store a person's
    name and phone number. In addition, it is a good practice to keep a unique identification
    number for each person or each entry in the table. This is because multiple people
    might have the same name or same contact number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a table within our `phonebook.db` database, we again open the command-line
    tool and navigate to the directory where we had created the database. We again
    get into the sqlite3 terminal by typing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time a new database is not created. Rather, the command now opens the existing
    `phonebook.db` database, because it is already present on the disk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we create a table named `contacts`, and add three columns to the table
    from the command line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can verify if the `contacts` table was created by typing the following
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints the name of all the tables present in the currently open database.
    You will get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s first begin by creating a basic GUI that would let us add, view, delete,
    and modify the records. We create a class named `PhoneBook` and create all GUI
    widgets from within its `__init__` method (refer to `7.07 phonebook.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We do not rewrite the code here, because we have created similar widgets in
    all our previous projects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's start creating the records in the database file we created. A new record
    is to be created every time a user enters a new name and a phone number in the
    entry widgets provided, and clicks on the **Add Record** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `create_record` method, as defined above, is attached as a command callback
    to the **Add Record** button.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `create_record` method is called, it retrieves the name and number
    values entered in the **Name** and **Contact Number** entry field.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the name or number field is empty, it prints an error message and exits.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If name and number fields are valid, the method establishes connection to the
    `phonebook.db` database we had created earlier.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line, `c = conn.cursor()`, creates a cursor object. The cursor is a
    control structure that is required as per SQL standards, and it enables us to
    traverse over the records in a database.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next line, `c.execute(query)` is the line that actually inserts the name
    and phone number into database. Note that it includes three insertion values:
    the first is the NULL value corresponding to autoincrement contact ID which is
    added through that we had created in our `contacts` table.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `conn.commit()` actually commits these changes to the database and
    line `c.close()` closes the connection to the database.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After the above steps are carried out, we will view the records stored in the
    database. This method is responsible for fetching all the records from the database
    and displaying them in the tree widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `view_records` method first deletes all existing items being displayed in
    the tree widget
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It then establishes a database connection and queries the database to fetch
    all the data sorted by name in descending order
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it iterates over the fetched record to update the tree widget with
    the content
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, on the phonebook application we''ll delete some records. The `delete_record`
    method is simply responsible for deleting a row from the database based on a given
    name criterion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we have created this deletion query based on name, this method runs
    the risk of deleting multiple entries if two or more person have the same name.
    A better approach would be to delete the entries based on the primary key or contact
    id, which is unique for every entry in the table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final operation in the phonebook application is modifying the records. When
    a user selects a particular record and clicks on the **Modify Selected** button,
    it opens a new Toplevel window like the one shown here:![Engage Thrusters](img/7941OT_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This window is created using the `open_modify_window` method, as defined in
    the `7.07 phonebook.py` Python file. We will not reproduce the code for this method,
    because you should be comfortable making such windows by now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a user specifies a new number and clicks the **Update Record** button,
    it calls the `update_record` method, which is defined in the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have completed coding a basic phonebook application.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, we have seen how to work with databases. Our phonebook application
    has demonstrated how to execute basic create, read, update, and delete (CRUD)
    operations on a database.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to create database, add tables to the database, and query the
    database to add, modify, delete, and view items in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, due to similarity of basic database operations, you can now consider
    working with other database systems, such as MySQL, PostgreSQL, Oracle, Ingres,
    SAP DB, Informix, Sybase, Firebird, IBM DB2, Microsoft SQL Server, and Microsoft
    Access.
  prefs: []
  type: TYPE_NORMAL
- en: Graphing with Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us wrap up this project by looking at the graphing abilities of the Tkinter
    canvas widget.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe we will see how we can plot:'
  prefs: []
  type: TYPE_NORMAL
- en: Pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scatter chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bar graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding matplotlib graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the pie chart first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Engage Thrusters](img/7941OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can easily create pie charts in Tkinter using the Canvas widget''s `create_arc`
    method. A sample Pie Chart code is provided in `7.08 pie chart.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Each portion of the pie chart is drawn by changing the two following `create_arc`
    options:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: This option specifies the start angle. Default is `0.0`.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`extent`: This option specifies the size of `arc` relative to the start angle.
    Default is `90.0`.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we'll plot a sample scatter chart:![Engage Thrusters](img/7941OT_07_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, we can use `create_line` to draw the *x* and *y* axes and `create_oval`
    to draw the scatter plots, as shown in the preceding screenshot here. A sample
    scatter plot code is provided in the `7.09 scatter plot.py` Python file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's plot a sample bar graph:![Engage Thrusters](img/7941OT_07_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A bar graph can be easily generated using the Canvas widget''s `create_rectangle`
    method. A sample bar graph code is provided in `7.10 bar graph.py`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we're going to look at how to embed matplotlib graphs in Tkinter Toplevel
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Tkinter Canvas to draw graphs may work fine for trivial cases. However,
    Tkinter may not be the best library when it comes to drawing more sophisticated
    and interactive graphs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In fact, matplotlib is used in conjunction with the **NumPy** module is the
    preferred choice when it comes to producing professional-quality graphs with Python.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Engage Thrusters](img/7941OT_07_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Although a detailed discussion on matplotlib is beyond the scope of this book,
    we will take a brief look at embedding matplotlib-generated graphs on a Tkinter
    canvas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are interested in exploring advanced graphing with Python, you can install
    matplotlib and NumPy (a dependency for matplotlib) with the help of the installation
    instructions available at [http://matplotlib.org/users/installing.html](http://matplotlib.org/users/installing.html)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes our brief discussion on the graphing abilities of Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: In this iteration, we saw how to use Tkinter Canvas to draw basic graphs such
    as pie chart, scatter plots, and bar graphs.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to embed more sophisticated matplotlib graphs, on the Tkinter
    drawing area.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Accomplished
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the end of this project. In this project, we took a deeper
    look into some of the many things that can be done with Tkinter Canvas widget.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to use the Queue implementation to program a multithreaded
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The Weather Reporter application introduced us to the basics of network programming
    and how to tap into the Internet for our data needs.
  prefs: []
  type: TYPE_NORMAL
- en: The phonebook application showed us how to work with databases.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at basic graphing abilities of Tkinter, and we also looked
    at ways of embedding matplotlib graphs in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: A Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Screen saver challenge**: We have used the `create_oval` method of the Canvas
    widget to create multiple balls in our screen saver program. Try to experiment
    by replacing the oval with other canvas-supported shapes, such as lines, rectangles,
    and arcs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, because you can use the `create_image` method on Canvas, how about
    creating an aquarium brimming with different varieties of fishes, snails, aquatic
    animals, and plants? You can even add sky divers bubbling their way through the
    marine life!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Snake game challenge**: Implement different levels of the Snake game by introducing
    mazes on the canvas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network programming challenge**: Implement any other program that leverages
    the data available on the Internet to provide some value to the end user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database challenge**: Revisit your media player program and implement a database
    to store playlists and automatically populate the media player when it is run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphing challenge**: Explore advanced graphing capabilities of matplotlib.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
