<html><head></head><body>
  <div><h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-77" class="chapterTitle">Expecting the Unexpected</h1>
    <p class="normal">Systems built with software can be fragile. While the software is highly predictable, the runtime context can provide unexpected inputs and situations. Devices fail, networks are unreliable, mere anarchy is loosed on our application. We need to have a way to work around the spectrum of failures that plague computer systems. </p>
    <p class="normal">There are two broad approaches to dealing with the unforeseen. One approach is to return a recognizable error-signaling value from a function. A value, like <code class="Code-In-Text--PACKT-">None</code>, could be used. Other library functions can then be used by an application to retrieve details of the erroneous condition. A variation on this theme is to pair a return from an OS request with a success or failure indicator. The other approach is to interrupt the normal, sequential execution of statements and divert to statements that handle exceptions. This second approach is what Python does: it eliminates the need to check return values for errors.</p>
    <p class="normal">In this chapter, we will study <strong class="keyword">exceptions</strong>, special error objects raised when a normal response is impossible. In particular, we will cover the following:</p>
    <ul>
      <li class="bullet">How to cause an exception to occur</li>
      <li class="bullet">How to recover when an exception has occurred</li>
      <li class="bullet">How to handle different exception types in different ways</li>
      <li class="bullet">Cleaning up when an exception has occurred</li>
      <li class="bullet">Creating new types of exception</li>
      <li class="bullet">Using the exception syntax for flow control</li>
    </ul>
    <p class="normal">The case study for this chapter will look at data validation. We'll examine a number of ways exceptions can be used to ensure that inputs to our classifier are valid.</p>
    <p class="normal">We'll start by looking at Python's concept of an <code class="Code-In-Text--PACKT-">Exception</code>, and how exceptions are raised and handled.</p>
    <h1 id="_idParaDest-78" class="title">Raising exceptions</h1>
    <p class="normal">Python's <a id="_idIndexMarker254"/>normal behavior is to execute statements in the order they are found, either in a file or at the <code class="Code-In-Text--PACKT-">&gt;&gt;&gt;</code> prompt interactively. A few statements, specifically <code class="Code-In-Text--PACKT-">if</code>, <code class="Code-In-Text--PACKT-">while</code>, and <code class="Code-In-Text--PACKT-">for</code>, alter the simple top-to-bottom sequence of statement execution. Additionally, an exception can break the sequential flow of execution. Exceptions are raised, and this interrupts the sequential execution of statements. </p>
    <p class="normal">In Python, the exception that's raised is also an object. There are many different exception classes available, and we can easily define more of our own. The one thing they all have in common is that they inherit from a built-in class called <code class="Code-In-Text--PACKT-">BaseException</code>. </p>
    <p class="normal">When an exception is raised, everything that was supposed to happen is pre-empted. Instead, exception handling replaces normal processing. Make sense? Don't worry, it will!</p>
    <p class="normal">The easiest way to cause an exception to occur is to do something silly. Chances are you've done this already and seen the exception output. For example, any time Python encounters a line in your program that it can't understand, it bails with <code class="Code-In-Text--PACKT-">SyntaxError</code>, which is a type of exception. Here's a common one:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; print "hello world"
  File "&lt;input&gt;", line 1
    print "hello world"
          ^
SyntaxError: Missing parentheses in call to 'print'. Did you mean print("hello world")?
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">print()</code> function requires the arguments to be enclosed in parentheses. So, if we type the preceding command into a Python 3 interpreter, we raise a <code class="Code-In-Text--PACKT-">SyntaxError</code> exception.</p>
    <p class="normal">In addition to <code class="Code-In-Text--PACKT-">SyntaxError</code>, some other common exceptions are shown in the following example:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; x = 5 / 0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: division by zero
&gt;&gt;&gt; lst = [1,2,3]
&gt;&gt;&gt; print(lst[3])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range
&gt;&gt;&gt; lst + 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate list (not "int") to list
&gt;&gt;&gt; lst.add
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'list' object has no attribute 'add'
&gt;&gt;&gt; d = {'a': 'hello'}
&gt;&gt;&gt; d['b']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'b'
&gt;&gt;&gt; print(this_is_not_a_var)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'this_is_not_a_var' is not defined  
</code></pre>
    <p class="normal">We can<a id="_idIndexMarker255"/> partition these exceptions into roughly four categories. Some cases are blurry, but some edges have a bright line separating them: </p>
    <ul>
      <li class="bullet">Sometimes, these exceptions are indicators of something clearly wrong in our program. Exceptions like <code class="Code-In-Text--PACKT-">SyntaxError</code> and <code class="Code-In-Text--PACKT-">NameError</code> mean we need to find the indicated line number and fix the problem. </li>
      <li class="bullet">Sometimes, these exceptions are indicators of something wrong in the Python runtime. There's a <code class="Code-In-Text--PACKT-">RuntimeError</code> exception that can get raised. In many cases, this is resolved by downloading and installing a newer Python. (Or, if you're wrestling with a "Release Candidate" version, reporting the bug to the maintainers.)</li>
      <li class="bullet">Some exceptions are design problems. We may fail to account for an edge case properly and sometimes try to compute an average of an empty list. This will result in a <code class="Code-In-Text--PACKT-">ZeroDivisionError</code>. When we find these, again, we'll have to go to the indicated line number. But once we've found the resulting exception, we'll need to work backwards from there to find out what caused the problem that raised the exception. Somewhere there will be an object in an unexpected or not-designed-for state. </li>
      <li class="bullet">The bulk of the<a id="_idIndexMarker256"/> exceptions arise near our program's interfaces. Any user input, or operating system request, including file operations, can encounter problems with the resources outside our program, leading to exceptions. We can subdivide these interface problems further into two sub-groups:<ul>
          <li class="bullet-l2">External objects in an unusual or unanticipated state. This is common with files that aren't found because the path was spelled incorrectly, or directories that already exist because our application crashed earlier and we restarted it. These will often be some kind of <code class="Code-In-Text--PACKT-">OSError</code> with a reasonably clear root cause. It's also common with users entering things incorrectly, or even users maliciously trying to subvert the application. These should be application-specific exceptions to prevent dumb mistakes or intentional abuse.</li>
          <li class="bullet-l2">And there's also the (relatively small) category of simple chaos. In the final analysis, a computer system is a lot of interconnected devices and any one of the components could behave badly. These are hard to anticipate and it's harder still to plan a recovery strategy. When working with a small IoT computer, there are few parts, but it may be installed in a challenging physical environment. When working with an enterprise server farm with thousands of components, a 0.1% failure rate means something is always broken.</li>
        </ul>
      </li>
    </ul>
    <p class="normal">You may have noticed all of Python's built-in exceptions end with the name <code class="Code-In-Text--PACKT-">Error</code>. In Python, the words <strong class="keyword">error</strong> and <strong class="keyword">exception</strong> are used<a id="_idIndexMarker257"/> almost interchangeably. Errors are sometimes considered<a id="_idIndexMarker258"/> more dire than exceptions, but they are dealt with in exactly the same way. Indeed, all the error classes in the preceding example have <code class="Code-In-Text--PACKT-">Exception</code> (which extends <code class="Code-In-Text--PACKT-">BaseException</code>) as their superclass.</p>
    <h2 id="_idParaDest-79" class="title">Raising an exception</h2>
    <p class="normal">We'll get to <a id="_idIndexMarker259"/>responding to such exceptions in a minute, but first, let's discover what we should do if we're writing a program that needs to inform the user or a calling function that the inputs are invalid. We can use the exact same mechanism that Python uses. Here's a simple class that adds items to a list only if they are even-numbered integers:</p>
    <pre class="programlisting code"><code class="hljs-code">from typing import List
class EvenOnly(List[int]):
    def append(self, value: int) -&gt; None:
        if not isinstance(value, int):
            raise TypeError("Only integers can be added")
        if value % 2 != 0:
            raise ValueError("Only even numbers can be added")
        super().append(value)
</code></pre>
    <p class="normal">This class <a id="_idIndexMarker260"/>extends the built-in list, as we discussed in <em class="chapterRef">Chapter 2</em>, <em class="italic">Objects in Python</em>. We've provided a type hint suggesting we're creating a list of integer objects only. To do this, we've overridden the <code class="Code-In-Text--PACKT-">append</code> method to check two conditions that ensure the item is an even integer. We first check whether the input is an instance of the <code class="Code-In-Text--PACKT-">int</code> type, and then use the modulo operator to ensure it is divisible by two. If either of the two conditions is not met, the <code class="Code-In-Text--PACKT-">raise</code> keyword causes an exception to occur. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">raise</code> keyword is followed by the object being raised as an exception. In the preceding example, two objects are constructed from the built-in <code class="Code-In-Text--PACKT-">TypeError</code> and <code class="Code-In-Text--PACKT-">ValueError</code> classes. The raised object could just as easily be an instance of a new <code class="Code-In-Text--PACKT-">Exception</code> class we create ourselves (we'll see how shortly), an exception that was defined elsewhere, or even an <code class="Code-In-Text--PACKT-">Exception</code> object that has been previously raised and handled.</p>
    <p class="normal">If we test this class in the Python interpreter, we can see that it is outputting useful error information when exceptions occur, just as before:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; e = EvenOnly()
&gt;&gt;&gt; e.append("a string")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "even_integers.py", line 7, in add
    raise TypeError("Only integers can be added")
TypeError: Only integers can be added
&gt;&gt;&gt; e.append(3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "even_integers.py", line 9, in add
    raise ValueError("Only even numbers can be added")
ValueError: Only even numbers can be added
&gt;&gt;&gt; e.append(2)
</code></pre>
    <p class="normal">While this class is effective for demonstrating exceptions in action, it isn't very good at its job. It is still possible to get other values into the list using index notation or slice notation. These additional behaviors can be avoided by overriding other appropriate methods, some of which are <a id="_idIndexMarker261"/>magic double-underscore methods. To be really complete, we'd need to override methods like <code class="Code-In-Text--PACKT-">extend()</code>, <code class="Code-In-Text--PACKT-">insert()</code>, <code class="Code-In-Text--PACKT-">__setitem__()</code>, and even <code class="Code-In-Text--PACKT-">__init__()</code> to be sure things start off correctly.</p>
    <h2 id="_idParaDest-80" class="title">The effects of an exception</h2>
    <p class="normal">When an<a id="_idIndexMarker262"/> exception is raised, it appears to stop program execution immediately. Any lines that were supposed to run after the exception is raised are not executed, and unless the exception is handled by an <code class="Code-In-Text--PACKT-">except</code> clause, the program will exit with an error message. We'll examine unhandled exceptions first, and then take a close look at handling exceptions.</p>
    <p class="normal">Take a look at this basic function:</p>
    <pre class="programlisting code"><code class="hljs-code">from typing import NoReturn
def never_returns() -&gt; NoReturn:
    print("I am about to raise an exception")
    raise Exception("This is always raised")
    print("This line will never execute")
    return "I won't be returned"
</code></pre>
    <p class="normal">We've included the <code class="Code-In-Text--PACKT-">NoReturn</code> type hint for this function. This helps ease <strong class="" style="font-style: italic;">mypy</strong>'s worry that there's no way for this function to reach the end and return a string value. The type hint states, formally, the function isn't expected to return a value.</p>
    <p class="normal">(Note that <strong class="" style="font-style: italic;">mypy</strong> is aware the final <code class="Code-In-Text--PACKT-">return</code> cannot be executed. It does not object to the return type being <code class="Code-In-Text--PACKT-">NoReturn</code>, even though there's a <code class="Code-In-Text--PACKT-">return</code> statement with a string literal. It's clear this cannot be executed.)</p>
    <p class="normal">If we execute this function, we see that the first <code class="Code-In-Text--PACKT-">print()</code> call is executed and then the exception is raised. The second <code class="Code-In-Text--PACKT-">print()</code> function call is never executed, nor is the <code class="Code-In-Text--PACKT-">return</code> statement. Here's what it looks like:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; never_returns()
I am about to raise an exception
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
  File "&lt;input&gt;", line 6, in never_returns
Exception: This is always raised
</code></pre>
    <p class="normal">Furthermore, if <a id="_idIndexMarker263"/>we have a function that calls another function that raises an exception, nothing is executed in the first function after the point where the second function's exception was raised. Raising an exception stops all execution right up through the function call stack until it is either handled or forces the interpreter to exit. To demonstrate, let's add a second function that calls the <code class="Code-In-Text--PACKT-">never_returns()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">def call_exceptor() -&gt; None:
    print("call_exceptor starts here...")
    never_returns()
    print("an exception was raised...")
    print("...so these lines don't run")
</code></pre>
    <p class="normal">When we call this function, we see that the first <code class="Code-In-Text--PACKT-">print</code> statement executes, as well as the first line in the <code class="Code-In-Text--PACKT-">never_returns()</code> function. But once the exception is raised, nothing else executes:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; call_exceptor()
call_exceptor starts here...
I am about to raise an exception
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
  File "&lt;input&gt;", line 3, in call_exceptor
  File "&lt;input&gt;", line 6, in never_returns
Exception: This is always raised
</code></pre>
    <p class="normal">Note that <strong class="" style="font-style: italic;">mypy</strong> didn't recognize what <code class="Code-In-Text--PACKT-">never_returns()</code> does to the processing in <code class="Code-In-Text--PACKT-">call_exceptor()</code>. Based on previous examples, it seems like <code class="Code-In-Text--PACKT-">call_exceptor()</code> is better described as a <code class="Code-In-Text--PACKT-">NoReturn</code> function. When we try this, we get a warning from <strong class="" style="font-style: italic;">mypy</strong>. It turns out the <strong class="" style="font-style: italic;">mypy</strong> focus is rather narrow; it examines function and method definitions in relative isolation; it isn't aware that <code class="Code-In-Text--PACKT-">never_returns()</code> raises an exception.</p>
    <p class="normal">We can control how exceptions propagate from the initial <code class="Code-In-Text--PACKT-">raise</code> statement. We can react to and deal with the exception inside either of these methods in the call stack.</p>
    <p class="normal">Look at the output from the unhandled exception above, called a <strong class="keyword">traceback</strong>. This shows the call stack. The command line ("<code class="Code-In-Text--PACKT-">&lt;module&gt;</code>" is the name used when there's no input file) called <code class="Code-In-Text--PACKT-">call_exceptor()</code>, and <code class="Code-In-Text--PACKT-">call_exceptor()</code> called <code class="Code-In-Text--PACKT-">never_returns()</code>. Inside <code class="Code-In-Text--PACKT-">never_returns()</code>, the exception is initially raised. </p>
    <p class="normal">The exception <a id="_idIndexMarker264"/>propagates up through the call stack. From inside <code class="Code-In-Text--PACKT-">call_exceptor()</code>, the pesky <code class="Code-In-Text--PACKT-">never_returns()</code> function was called and the exception <em class="italic">bubbled up</em> to the calling method. From there, it went up one more level to the main interpreter, which, not knowing what else to do with it, gave up and printed the traceback object.</p>
    <h2 id="_idParaDest-81" class="title">Handling exceptions </h2>
    <p class="normal">Now let's look at<a id="_idIndexMarker265"/> the tail side of the exception coin. If we encounter an exception situation, how should our code react to or recover from it? We handle exceptions by wrapping any code that might throw one (whether it is exception code itself, or a call to any function or method that may have an exception raised inside it) inside a <code class="Code-In-Text--PACKT-">try...except</code> clause. The most basic syntax looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">def handler() -&gt; None:
    try:
        never_returns()
        print("Never executed")
    except Exception as ex:
        print(f"I caught an exception: {ex!r}")
    print("Executed after the exception")
</code></pre>
    <p class="normal">If we run this simple script using our existing <code class="Code-In-Text--PACKT-">never_returns()</code> function—which, as we know very well, always throws an exception—we get this output:</p>
    <pre class="programlisting con"><code class="hljs-con">I am about to raise an exception
I caught an exception: Exception('This is always raised')
Executed after the exception
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">never_returns()</code> function happily informs us that it is about to raise an exception and raises it. The <code class="Code-In-Text--PACKT-">handler()</code> function's <code class="Code-In-Text--PACKT-">except</code> clause catches the exception. Once caught, we are able to clean up after ourselves (in this case, by outputting that we are handling the situation), and continue on our way. The remainder of the code in the <code class="Code-In-Text--PACKT-">never_returns()</code> function remains unexecuted, but the code in the <code class="Code-In-Text--PACKT-">handler()</code> function after the <code class="Code-In-Text--PACKT-">try:</code> statement is able to recover and continue.</p>
    <div><p class="Tip--PACKT-">Note the indentation around <code class="Code-In-Text--PACKT-">try</code> and <code class="Code-In-Text--PACKT-">except</code>. The <code class="Code-In-Text--PACKT-">try</code> clause wraps any code that might throw an exception. The <code class="Code-In-Text--PACKT-">except</code> clause is then back on the same indentation level as the <code class="Code-In-Text--PACKT-">try</code> line. Any code to handle the exception is indented inside the <code class="Code-In-Text--PACKT-">except</code> clause. Then normal code resumes at the original indentation level.</p>
    </div>
    <p class="normal">The problem with the <a id="_idIndexMarker266"/>preceding code is that it uses the <code class="Code-In-Text--PACKT-">Exception</code> class to match any type of exception. What if we were writing some code that could raise either <code class="Code-In-Text--PACKT-">TypeError</code> or <code class="Code-In-Text--PACKT-">ZeroDivisionError</code>? We might need to catch <code class="Code-In-Text--PACKT-">ZeroDivisionError</code> because it reflects a known object state, but let any other exceptions propagate to the console because they reflect bugs we need to catch and kill. Can you guess the syntax?</p>
    <p class="normal">Here's a rather silly function that does just that:</p>
    <pre class="programlisting code"><code class="hljs-code">from typing import Union
def funny_division(divisor: float) -&gt; Union[str, float]:
    try:
        return 100 / divisor
    except ZeroDivisionError:
        return "Zero is not a good idea!"
</code></pre>
    <p class="normal">This function does a simple computation. We've provided the type hint of <code class="Code-In-Text--PACKT-">float</code> for the <code class="Code-In-Text--PACKT-">divisor</code> parameter. We can provide an integer, and ordinary Python type coercion will work. The <strong class="" style="font-style: italic;">mypy</strong> tool is aware of the ways integers can be coerced to floats, saving it from having to obsess over the parameter types.</p>
    <p class="normal">We do, however, have to be very clear about the return types. If we don't raise an exception, we'll compute and return a floating result. If we do raise a <code class="Code-In-Text--PACKT-">ZeroDivisionError</code> exception, it will be handled, and we'll return a string result. Any other exceptions? Let's try it and see:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; print(funny_division(0))
Zero is not a good idea!
&gt;&gt;&gt; print(funny_division(50.0))
2.0
&gt;&gt;&gt; print(funny_division("hello"))
Traceback (most recent call last):
...
TypeError: unsupported operand type(s) for /: 'int' and 'str'
</code></pre>
    <p class="normal">The first line of output shows that if we enter <code class="Code-In-Text--PACKT-">0</code>, we get properly mocked. If we call with a valid number, it operates correctly. Yet if we enter a string (you were wondering how to get a <code class="Code-In-Text--PACKT-">TypeError</code>, weren't you?), it fails with an unhandled exception. If we don't specify matching the <code class="Code-In-Text--PACKT-">ZeroDivisionError</code> exception class, our handler would also see the <code class="Code-In-Text--PACKT-">TypeError</code>, and accuse us of dividing by zero when we sent it a string, which is not a proper behavior at all.</p>
    <div><p class="Tip--PACKT-">Python also has a bare except syntax. Using <code class="Code-In-Text--PACKT-">except:</code> with no exception class to match is widely frowned upon because it will prevent an application from simply crashing when it should. We generally use <code class="Code-In-Text--PACKT-">except Exception:</code> to explicitly catch a sensible set of exceptions. </p>
      <p class="Tip--PACKT-">The bare except syntax is actually the same as using <code class="Code-In-Text--PACKT-">except BaseException</code><code class="Code-In-Text--PACKT-">:</code>, which attempts to handle system-level exceptions that are often impossible to recover from. Indeed, this can make it impossible to crash your application when it's misbehaving.</p>
    </div>
    <p class="normal">We can even catch <a id="_idIndexMarker267"/>two or more different exceptions and handle them with the same code. Here's an example that raises three different types of exceptions. It handles <code class="Code-In-Text--PACKT-">TypeError</code> and <code class="Code-In-Text--PACKT-">ZeroDivisionError</code> with the same exception handler, but it may also raise a <code class="Code-In-Text--PACKT-">ValueError</code> error if you supply the number <code class="Code-In-Text--PACKT-">13</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">def funnier_division(divisor: int) -&gt; Union[str, float]:
    try:
        if divisor == 13:
            raise ValueError("13 is an unlucky number")
        return 100 / divisor
    except (ZeroDivisionError, TypeError):
        return "Enter a number other than zero"
</code></pre>
    <p class="normal">We've included multiple exception classes in the <code class="Code-In-Text--PACKT-">except</code> clause. This lets us handle a variety of conditions with a common handler. Here's how we can test this with a bunch of different values:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; for val in (0, "hello", 50.0, 13):
...     print(f"Testing {val!r}:", end=" ")
...     print(funnier_division(val))
...     
Testing 0: Enter a number other than zero
Testing 'hello': Enter a number other than zero
Testing 50.0: 2.0
Testing 13: Traceback (most recent call last):
  File "&lt;input&gt;", line 3, in &lt;module&gt;
  File "&lt;input&gt;", line 4, in funnier_division
ValueError: 13 is an unlucky number
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">for</code> statement iterates over several test inputs and prints the results. If you're wondering about that <code class="Code-In-Text--PACKT-">end</code> parameter in the <code class="Code-In-Text--PACKT-">print</code> function, it just turns the default trailing newline into a space so that it's joined with the output from the next line. </p>
    <p class="normal">The number 0 and the <a id="_idIndexMarker268"/>string are both caught by the <code class="Code-In-Text--PACKT-">except</code> clause, and a suitable error message is printed. The exception from the number <code class="Code-In-Text--PACKT-">13</code> is not caught because it is a <code class="Code-In-Text--PACKT-">ValueError</code>, which was not included in the types of exceptions being handled. This is all well and good, but what if we want to catch different exceptions and do different things with them? Or maybe we want to do something with an exception and then allow it to continue to bubble up to the parent function, as if it had never been caught?</p>
    <p class="normal">We don't need any new syntax to deal with these cases. It's possible to stack the <code class="Code-In-Text--PACKT-">except</code> clauses, and only the first match will be executed. For the second question, the <code class="Code-In-Text--PACKT-">raise</code> keyword, with no arguments, will re-raise the last exception if we're already inside an exception handler. Observe the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">def funniest_division(divisor: int) -&gt; Union[str, float]:
    try:
        if divider == 13:
            raise ValueError("13 is an unlucky number")
        return 100 / divider
    except ZeroDivisionError:
        return "Enter a number other than zero"
    except TypeError:
        return "Enter a numerical value"
    except ValueError:
        print("No, No, not 13!")
        raise
</code></pre>
    <p class="normal">The last line re-raises the <code class="Code-In-Text--PACKT-">ValueError</code> error, so after outputting <code class="Code-In-Text--PACKT-">No, No, not 13!</code>, it will raise the exception again; we'll still get the original stack trace on the console.</p>
    <p class="normal">If we stack exception clauses like we did in the preceding example, only the first matching clause will be run, even if more than one of them fits. How can more than one clause match? Remember that exceptions are objects, and can therefore be subclassed. As we'll see in the next section, most exceptions extend the <code class="Code-In-Text--PACKT-">Exception</code> class (which is itself derived from <code class="Code-In-Text--PACKT-">BaseException</code>). If we have an <code class="Code-In-Text--PACKT-">except</code> clause to match <code class="Code-In-Text--PACKT-">Exception</code> before we match <code class="Code-In-Text--PACKT-">TypeError</code>, then only the <code class="Code-In-Text--PACKT-">Exception</code> handler will be executed, because <code class="Code-In-Text--PACKT-">TypeError</code> is an <code class="Code-In-Text--PACKT-">Exception</code> by inheritance.</p>
    <p class="normal">This can come in handy in cases where we want to handle some exceptions specifically, and then handle all remaining exceptions as a more general case. We can list <code class="Code-In-Text--PACKT-">Exception</code> in its own clause after catching all the specific exceptions and handle the general case there.</p>
    <p class="normal">Often, when we catch an<a id="_idIndexMarker269"/> exception, we need a reference to the <code class="Code-In-Text--PACKT-">Exception</code> object itself. This most often happens when we define our own exceptions with custom arguments, but can also be relevant with standard exceptions. Most exception classes accept a set of arguments in their constructor, and we might want to access those attributes in the exception handler. If we define our own <code class="Code-In-Text--PACKT-">Exception</code> class, we can even call custom methods on it when we catch it. The syntax for capturing an exception as a variable uses the <code class="Code-In-Text--PACKT-">as</code> keyword:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; try: 
...     raise ValueError("This is an argument") 
... except ValueError as e: 
...     print(f"The exception arguments were {e.args}") 
...
The exception arguments were ('This is an argument',)
</code>
ValueError</code> upon initialization.</pre>
    <p class="normal">We've seen several variations on the syntax for handling exceptions, but we still don't know how to execute code regardless of whether or not an exception has occurred. We also can't specify code that should be executed <strong class="keyword">only</strong> if an exception does <strong class="keyword">not</strong> occur. Two more keywords, <code class="Code-In-Text--PACKT-">finally</code> and <code class="Code-In-Text--PACKT-">else</code>, provide some additional execution paths. Neither one takes any extra arguments. </p>
    <p class="normal">We'll show an example with the <code class="Code-In-Text--PACKT-">finally</code> clause. For the most part, we often use context managers instead of exception blocks as a cleaner way to implement a finalization that occurs whether or not an exception interrupted processing. The idea is to encapsulate responsibility for finalization in the context manager.</p>
    <p class="normal">The following example iterates through a number of exception classes, raising an instance of each. Then some not-so-complicated exception handling code runs that illustrates the newly introduced syntax:</p>
    <pre class="programlisting code"><code class="hljs-code">some_exceptions = [ValueError, TypeError, IndexError, None]
for choice in some_exceptions:
    try:
        print(f"\nRaising {choice}")
        if choice:
            raise choice("An error")
        else:
            print("no exception raised")
    except ValueError:
        print("Caught a ValueError")
    except TypeError:
        print("Caught a TypeError")
    except Exception as e:
        print(f"Caught some other error: {e.__class__.__name__}")
    else:
        print("This code called if there is no exception")
    finally:
        print("This cleanup code is always called")
</code></pre>
    <p class="normal">If we run this example – which<a id="_idIndexMarker270"/> illustrates almost every conceivable exception handling scenario – we'll see the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">(CaseStudy39) % python ch_04/src/all_exceptions.py
Raising &lt;class 'ValueError'&gt;
Caught a ValueError
This cleanup code is always called
Raising &lt;class 'TypeError'&gt;
Caught a TypeError
This cleanup code is always called
Raising &lt;class 'IndexError'&gt;
Caught some other error: IndexError
This cleanup code is always called
Raising None
no exception raised
This code called if there is no exception
This cleanup code is always called
</code></pre>
    <p class="normal">Note how the <code class="Code-In-Text--PACKT-">print</code> statement in the <code class="Code-In-Text--PACKT-">finally</code> clause is executed no matter what happens. This is one way to perform certain tasks after our code has finished running (even if an exception has occurred). Some common examples include the following:</p>
    <ul>
      <li class="bullet">Cleaning up an open database connection</li>
      <li class="bullet">Closing an open file</li>
      <li class="bullet">Sending a closing handshake over the network</li>
    </ul>
    <p class="normal">All of these are more<a id="_idIndexMarker271"/> commonly handled with context managers, one of the topics of <em class="chapterRef">Chapter 8</em>, <em class="italic">The Intersection of Object-Oriented and Functional Programming</em>.</p>
    <div><p class="Tip--PACKT-">While obscure, the <code class="Code-In-Text--PACKT-">finally</code> clause is executed after the <code class="Code-In-Text--PACKT-">return</code> statement inside a <code class="Code-In-Text--PACKT-">try</code> clause. While this can be exploited for post-<code class="Code-In-Text--PACKT-">return</code> processing, it can also be confusing to folks reading the code.</p>
    </div>
    <p class="normal">Also, pay attention to the output when no exception is raised: both the <code class="Code-In-Text--PACKT-">else</code> and the <code class="Code-In-Text--PACKT-">finally</code> clauses are executed. The <code class="Code-In-Text--PACKT-">else</code> clause may seem redundant, as the code that should be executed when no exception is raised could just be placed after the entire <code class="Code-In-Text--PACKT-">try...except</code> block. The difference is that the <code class="Code-In-Text--PACKT-">else</code> block will not be executed if an exception is caught and handled. We'll see more on this when we discuss using exceptions as flow control later.</p>
    <p class="normal">Any of the <code class="Code-In-Text--PACKT-">except</code>, <code class="Code-In-Text--PACKT-">else</code>, and <code class="Code-In-Text--PACKT-">finally</code> clauses can be omitted after a <code class="Code-In-Text--PACKT-">try</code> block (although <code class="Code-In-Text--PACKT-">else</code> by itself is invalid). If you include more than one, the <code class="Code-In-Text--PACKT-">except</code> clauses must come first, then the <code class="Code-In-Text--PACKT-">else</code> clause, with the <code class="Code-In-Text--PACKT-">finally</code> clause at the end. You must be sure the order of the <code class="Code-In-Text--PACKT-">except</code> clauses has classes that move from the most specific subclasses to most generic superclasses.</p>
    <h2 id="_idParaDest-82" class="title">The exception hierarchy</h2>
    <p class="normal">We've already seen <a id="_idIndexMarker272"/>several of the most common built-in exceptions, and you'll probably encounter the rest over the course of your regular Python development. As we noticed earlier, most exceptions are subclasses of the <code class="Code-In-Text--PACKT-">Exception</code> class. But this is not true of all exceptions. The <code class="Code-In-Text--PACKT-">Exception</code> class actually extends a class called <code class="Code-In-Text--PACKT-">BaseException</code>. In fact, all exceptions must extend the <code class="Code-In-Text--PACKT-">BaseException</code> class or one of its subclasses.</p>
    <p class="normal">There are two key built-in exception classes, <code class="Code-In-Text--PACKT-">SystemExit</code> and <code class="Code-In-Text--PACKT-">KeyboardInterrupt</code>, that derive directly from the <code class="Code-In-Text--PACKT-">BaseException</code> class instead of the <code class="Code-In-Text--PACKT-">Exception</code> class. The <code class="Code-In-Text--PACKT-">SystemExit</code> exception is raised whenever the program exits naturally, typically because we called the <code class="Code-In-Text--PACKT-">sys.exit()</code> function somewhere in our code (for example, when the user selected an exit menu item, clicked the Close button on a window, entered a command to shut down a server, or the OS sent a signal to the application to terminate). This exception is designed to allow us to clean up code before the program ultimately exits. </p>
    <p class="normal">If we do handle the <code class="Code-In-Text--PACKT-">SystemExit</code> exception, we would normally re-raise the exception, since catching it could stop the program from exiting. Imagine a web service with a bug that is holding database locks and can't be stopped without rebooting the server. </p>
    <p class="normal">We don't want a <code class="Code-In-Text--PACKT-">SystemExit</code> exception to be accidentally caught in generic <code class="Code-In-Text--PACKT-">except Exception:</code> clauses. This is why it derives directly from <code class="Code-In-Text--PACKT-">BaseException</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">KeyboardInterrupt</code> exception <a id="_idIndexMarker273"/>is common in command-line programs. It is thrown when the user explicitly interrupts program execution with an OS-dependent key combination (normally, Ctrl + C). For Linux and macOS users, the <code class="Code-In-Text--PACKT-">kill -2 &lt;pid&gt;</code> command will also work. This is a standard way for the user to deliberately interrupt a running program and, like the <code class="Code-In-Text--PACKT-">SystemExit</code> exception, it should almost always respond by terminating the program. Also, like <code class="Code-In-Text--PACKT-">SystemExit</code>, it can handle any cleanup tasks inside the <code class="Code-In-Text--PACKT-">finally</code> blocks.</p>
    <p class="normal">Here is a class diagram that fully illustrates the hierarchy:</p>
    <figure class="mediaobject"><img src="img/B17070_04_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.1: Exception hierarchy</p>
    <p class="normal">When we use the <code class="Code-In-Text--PACKT-">except:</code> clause without<a id="_idIndexMarker274"/> specifying any type of exception, it will catch all subclasses of <code class="Code-In-Text--PACKT-">BaseException</code>; which is to say, it will catch all exceptions, including the two special ones. Since we almost always want these to get special treatment, it is unwise to use the <code class="Code-In-Text--PACKT-">except:</code> statement without arguments. If you want to catch all exceptions (other than <code class="Code-In-Text--PACKT-">SystemExit</code> and <code class="Code-In-Text--PACKT-">KeyboardInterrupt</code>), always explicitly catch <code class="Code-In-Text--PACKT-">Exception</code>. Most Python developers assume that <code class="Code-In-Text--PACKT-">except:</code> without a type is an error and will flag it in code review.</p>
    <h2 id="_idParaDest-83" class="title">Defining our own exceptions</h2>
    <p class="normal">Occasionally, when <a id="_idIndexMarker275"/>we want to raise an exception, we find that none of the built-in exceptions are suitable. The distinction is often focused on how applications must handle the exception; when we introduce a new exception it must be because there will be distinct processing in a handler. </p>
    <p class="normal">There's no good reason to define an exception that's handled exactly like <code class="Code-In-Text--PACKT-">ValueError</code>; we can use <code class="Code-In-Text--PACKT-">ValueError</code>. Luckily, it's trivial to define new exceptions of our own. The name of the class is usually designed to communicate what went wrong, and we can provide arbitrary arguments in the initializer to include additional information.</p>
    <p class="normal">All we have to do is inherit from the <code class="Code-In-Text--PACKT-">Exception</code> class or one of the existing exceptions that's semantically similar. We don't even have to add any content to the class! We can, of course, extend <code class="Code-In-Text--PACKT-">BaseException</code> directly, but this means we're inventing new ways of stopping a running program, a very unusual thing to be creating.</p>
    <p class="normal">Here's a simple exception we might use in a banking application:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; class InvalidWithdrawal(ValueError): 
...     pass 
 
&gt;&gt;&gt; raise InvalidWithdrawal("You don't have $50 in your account")
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
InvalidWithdrawal: You don't have $50 in your account
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">raise</code> statement illustrates how to raise the newly defined exception. We are able to pass an arbitrary number of arguments into the exception. Often a string message is used, but any object that might be useful in a later exception handler can be stored. The <code class="Code-In-Text--PACKT-">Exception.__init__()</code> method is designed to accept any arguments and store them as a tuple in an attribute named <code class="Code-In-Text--PACKT-">args</code>. This makes exceptions easier to define without needing to override <code class="Code-In-Text--PACKT-">__init__()</code>.</p>
    <p class="normal">Of course, if we do want to customize the initializer, we are free to do so. Here's a revision to the above exception whose initializer accepts the current balance and the amount the user wants to withdraw. In addition, it adds a method to calculate how overdrawn the request is:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; class InvalidWithdrawal(ValueError): 
...     def __init__(self, balance: Decimal, amount: Decimal) -&gt; None: 
...         super().__init__(f"account doesn't have ${amount}") 
...         self.amount = amount 
...         self.balance = balance 
...     def overage(self) -&gt; Decimal: 
...         return self.amount - self.balance 
</code></pre>
    <p class="normal">Since we're working with <a id="_idIndexMarker276"/>currency, we've imported the <code class="Code-In-Text--PACKT-">Decimal</code> class of numbers. We can't use Python's default <code class="Code-In-Text--PACKT-">int</code> or <code class="Code-In-Text--PACKT-">float</code> types for money where there are a fixed number of decimal places and exquisitely complex rounding rules that assume exact decimal arithmetic. </p>
    <p class="normal">(Also note that the account number is not part of the exception. Bankers frown on using account numbers in a way that could expose them in a log or a traceback message.)</p>
    <p class="normal">Here's an example of creating an instance of this exception:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; raise InvalidWithdrawal(Decimal('25.00'), Decimal('50.00'))
Traceback (most recent call last):
...
InvalidWithdrawal: account doesn't have $50.00
</code></pre>
    <p class="normal">Here's how we would handle an <code class="Code-In-Text--PACKT-">InvalidWithdrawal</code> exception if one was raised:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; try: 
...     balance = Decimal('25.00')
...     raise InvalidWithdrawal(balance, Decimal('50.00')) 
... except InvalidWithdrawal as ex: 
...     print("I'm sorry, but your withdrawal is " 
...             "more than your balance by " 
...             f"${ex.overage()}") 
</code></pre>
    <p class="normal">Here we see a valid use of the <code class="Code-In-Text--PACKT-">as</code> keyword to save the exception in a local variable, <code class="Code-In-Text--PACKT-">ex</code>. By convention, most Python coders assign the exception a variable like <code class="Code-In-Text--PACKT-">ex</code>, <code class="Code-In-Text--PACKT-">exc</code>, or <code class="Code-In-Text--PACKT-">exception</code>; although, as usual, you are free to call it <code class="Code-In-Text--PACKT-">the_exception_raised_above</code>, or <code class="Code-In-Text--PACKT-">aunt_sally</code> if you prefer.</p>
    <p class="normal">There are many reasons for <a id="_idIndexMarker277"/>defining our own exceptions. It is often useful to add information to the exception or log it in some way. But the utility of custom exceptions truly comes to light when creating a framework, library, or API that is intended for access by other programmers. In that case, be careful to ensure your code is raising exceptions that make sense to the client programmer. Here are some criteria:</p>
    <ul>
      <li class="bullet">They should clearly describe what went on. The <code class="Code-In-Text--PACKT-">KeyError</code> exception, for example, provides the key that could not be found.</li>
      <li class="bullet">The client programmer should easily see how to fix the error (if it reflects a bug in their code) or handle the exception (if it's a situation they need to be made aware of).</li>
      <li class="bullet">The handling should be distinct from other exceptions. If the handling is the same as an existing exception, reusing the existing exception is best.</li>
    </ul>
    <p class="normal">Now that we've looked at raising exceptions and defining new exceptions, we can look at some of the design considerations that surround exceptional data and responding to problems. There are a number of alternative design choices, and we'll start with the idea that exceptions, in Python, can be used for a number of things that aren't – strictly speaking – erroneous. </p>
    <h2 id="_idParaDest-84" class="title">Exceptions aren't exceptional</h2>
    <p class="normal">Novice programmers tend to think of exceptions<a id="_idIndexMarker278"/> as only useful for exceptional circumstances. However, the definition of exceptional circumstances can be vague and subject to interpretation. Consider the following two functions:</p>
    <pre class="programlisting code"><code class="hljs-code">def divide_with_exception(dividend: int, divisor: int) -&gt; None:
    try:
        print(f"{dividend / divisor=}")
    except ZeroDivisionError:
        print("You can't divide by zero")
def divide_with_if(dividend: int, divisor: int) -&gt; None:
    if divisor == 0:
        print("You can't divide by zero")
    else:
        print(f"{dividend / divisor=}")
</code></pre>
    <p class="normal">These two functions behave identically. If <code class="Code-In-Text--PACKT-">divisor</code> is zero, an error message is printed; otherwise, a message printing the result of the division is displayed. We could avoid <code class="Code-In-Text--PACKT-">ZeroDivisionError</code> ever being thrown by testing for it with an <code class="Code-In-Text--PACKT-">if</code> statement. In this example, the test for a valid division is relatively simple-looking (<code class="Code-In-Text--PACKT-">divisor == 0</code>). In some cases, it can be rather complex. In some cases, it may involve computing intermediate results. In the worst cases, the test for "will this work?" involves using a number of other <a id="_idIndexMarker279"/>methods of a class to – in effect – dry-run the operation to see if there would be an error along the way.</p>
    <p class="normal">Python programmers tend to follow a model summarized by "<strong class="keyword">It's Easier to Ask Forgiveness Than Permission</strong>," sometimes abbreviated EAFP. The point is to execute code and then deal with anything that goes wrong. The alternative is described as "<strong class="keyword">Look Before You Leap</strong>," often abbreviated LBYL. This is generally less popular. There are a few reasons for this, but the main one is that it shouldn't be necessary to burn CPU cycles looking for an unusual situation that is not going to arise in the normal path through the code. </p>
    <p class="normal">Therefore, it is wise to use exceptions for exceptional circumstances, even if those circumstances are only a little bit exceptional. Taking this argument further, exception syntax can be effective for flow control. Like an <code class="Code-In-Text--PACKT-">if</code> statement, exceptions can be used for decision making, branching, and message passing.</p>
    <p class="normal">Imagine an inventory application for a company that sells widgets and gadgets. When a customer makes a purchase, the item can either be available, in which case the item is removed from inventory and the number of items left is returned, or it might be out of stock. Now, being out of stock is a perfectly normal thing to happen in an inventory application. It is certainly not an exceptional circumstance. But what do we return if it's out of stock? A string saying "out of stock"? A negative number? In both cases, the calling method would have to check whether the return value is a positive integer or something else, to determine if it is out of stock. That seems a bit messy, especially if we forget to do it somewhere in our code.</p>
    <p class="normal">Instead, we can <a id="_idIndexMarker280"/>raise an <code class="Code-In-Text--PACKT-">OutOfStock</code> exception and use the <code class="Code-In-Text--PACKT-">try</code> statement to direct program flow control. Make sense? In addition, we want to make sure we don't sell the same item to two different customers, or sell an item that isn't in stock yet. One way to facilitate this is to lock each type of item to ensure only one person can update it at a time. The user must lock the item, manipulate the item (purchase, add stock, count items left...), and then unlock the item. (This is, in effect, a context manager, one subject of <em class="chapterRef">Chapter 8</em>.)</p>
    <p class="normal">Here's an<a id="_idIndexMarker281"/> incomplete <code class="Code-In-Text--PACKT-">Inventory</code> example with docstrings that describes what some of the methods should do:</p>
    <pre class="programlisting code"><code class="hljs-code">class OutOfStock(Exception):
    pass
class InvalidItemType(Exception):
    pass
class Inventory:
    def __init__(self, stock: list[ItemType]) -&gt; None:
        pass
    def lock(self, item_type: ItemType) -&gt; None:
        """Context Entry.
        Lock the item type so nobody else can manipulate the
        inventory while we're working."""
        pass
    def unlock(self, item_type: ItemType) -&gt; None:
        """Context Exit.
        Unlock the item type."""
        pass
    def purchase(self, item_type: ItemType) -&gt; int:
        """If the item is not locked, raise a
        ValueError because something went wrong.
        If the item_type does not exist,
          raise InvalidItemType.
        If the item is currently out of stock,
          raise OutOfStock.
        If the item is available,
          subtract one item; return the number of items left.
        """
        # Mocked results.
        if item_type.name == "Widget":
            raise OutOfStock(item_type)
        elif item_type.name == "Gadget":
            return 42
        else:
            raise InvalidItemType(item_type)
</code></pre>
    <p class="normal">We could hand this <a id="_idIndexMarker282"/>object prototype to a developer and have them implement the methods to do exactly as they say while we work on the code needed to make a purchase. We'll use Python's robust exception handling to consider different branches, depending on how the purchase was made. We can even write a test case to be sure there's no question about how this class should work.</p>
    <p class="normal">Here's a definition of <code class="Code-In-Text--PACKT-">ItemType</code>, just to round out the example:</p>
    <pre class="programlisting code"><code class="hljs-code">class ItemType:
    def __init__(self, name: str) -&gt; None:
        self.name = name
        self.on_hand = 0
</code></pre>
    <p class="normal">Here's an interactive session using this <code class="Code-In-Text--PACKT-">Inventory</code> class:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; widget = ItemType("Widget")
&gt;&gt;&gt; gadget = ItemType("Gadget")
&gt;&gt;&gt; inv = Inventory([widget, gadget])
&gt;&gt;&gt; item_to_buy = widget
&gt;&gt;&gt; inv.lock(item_to_buy)
&gt;&gt;&gt; try:
...     num_left = inv.purchase(item_to_buy)
... except InvalidItemType:
...     print(f"Sorry, we don't sell {item_to_buy.name}")
... except OutOfStock:
...     print("Sorry, that item is out of stock.")
... else:
...     print(f"Purchase complete. There are {num_left} {item_to_buy.name}s left")
... finally:
...     inv.unlock(item_to_buy)
...
Sorry, that item is out of stock.
</code></pre>
    <p class="normal">All the possible exception handling clauses are used to ensure the correct actions happen at the correct time. Even though <code class="Code-In-Text--PACKT-">OutOfStock</code> is not a terribly exceptional circumstance, we are able to use an exception to handle it suitably. This same code could be written with an <code class="Code-In-Text--PACKT-">if...elif...else</code> structure, but it wouldn't be as easy to read or maintain.</p>
    <p class="normal">As an aside, one of the exception messages, <code class="Code-In-Text--PACKT-">There are {num_left} {item_to_buy.name}s left</code>, suffers from a goofy English grammar problem. When there's only one item left, it needs a major revision to <code class="Code-In-Text--PACKT-">There is {num_left} {item_to_buy.name} left</code>. In<a id="_idIndexMarker283"/> order to support a sensible approach to translation, it's best to avoid fiddling around with grammar details inside the f-string. It's best to deal with it in the <code class="Code-In-Text--PACKT-">else:</code> clause, using something like this to select the message with appropriate grammar:</p>
    <pre class="programlisting code"><code class="hljs-code">msg = (
    f"there is {num_left} {item_to_buy.name} left" 
    if num_left == 1 
    else f"there are {num_left} {item_to_buy.name}s left")
print(msg)
</code></pre>
    <p class="normal">We can also use exceptions to pass messages between different methods. For example, if we wanted to inform the customer as to what date the item is expected to be in stock again, we could ensure our <code class="Code-In-Text--PACKT-">OutOfStock</code> object requires a <code class="Code-In-Text--PACKT-">back_in_stock</code> parameter when it is constructed. Then, when we handle the exception, we can check that value and provide additional information to the customer. The information attached to the object can be easily passed between two different parts of the program. The exception could even provide a method that instructs the inventory object to reorder or backorder an item.</p>
    <p class="normal">Using exceptions for flow control can make for some handy program designs. The important thing to take from this discussion is that exceptions are not a bad thing that we should try to avoid. Having an exception occur does not mean that you should have prevented this exceptional circumstance from happening. Rather, it is just a powerful way to communicate information between two sections of code that may not be directly calling each other.</p>
    <h1 id="_idParaDest-85" class="title">Case study</h1>
    <p class="normal">This chapter's case study<a id="_idIndexMarker284"/> will look at some ways that we can find – and help the users fix – potential problems with the data or the application's computations. Both the data and the processing are possible sources of exceptional behavior. They aren't, however, equivalent; we can compare the two as follows:</p>
    <ul>
      <li class="bullet">Exceptional data is the most common source of problems. The data may not follow the syntax rules and have an invalid physical format. Other, more minor errors may stem from data not having a recognized logical organization, for example wrong spelling of column names. Exceptions can also reflect users attempting to perform an unauthorized operation. We need to alert users and administrators of invalid data or invalid operations.</li>
      <li class="bullet">Exceptional processing is what is commonly<a id="_idIndexMarker285"/> called a <strong class="keyword">bug</strong>. An application shouldn't try to recover from these problems. While we prefer to find them as part of unit or integration testing (see <em class="chapterRef">Chapter 13</em>, <em class="italic">Testing Object-Oriented Programs</em>), it's possible that a problem escaped our scrutiny and wound up in production, and is exposed to the users of our software. We need to tell the users that something's broken and – as gracefully as possible – stop processing, or "crash." To continue in the presence of a bug is a serious breach of trust.</li>
    </ul>
    <p class="normal">In our case study, we have<a id="_idIndexMarker286"/> three kinds of inputs that need to be examined for potential problems:</p>
    <ol>
      <li class="numbered">The known <code class="Code-In-Text--PACKT-">Sample</code> instances, provided by a Botanist, and reflecting expert judgement. While this data should be exemplary in its quality, there's no guarantee that someone didn't accidentally rename a file and replace good data with something invalid or otherwise unprocessable.</li>
      <li class="numbered">The unknown <code class="Code-In-Text--PACKT-">Sample</code> instances, provided by Researchers. These may have all kinds of data quality problems. We'll look at few of them.</li>
      <li class="numbered">Actions taken by a Researcher or a Botanist. We'll review the use cases to see what actions should be allowed by each class of user. In some cases, these problems are prevented by offering each class of user a focused menu of actions they can take.</li>
    </ol>
    <p class="normal">We'll start with a review of the use cases, so we can identify the kinds of exceptions that are required by this application.</p>
    <h2 id="_idParaDest-86" class="title">Context view</h2>
    <p class="normal">The role of "User" in the<a id="_idIndexMarker287"/> Context Diagram from <em class="chapterRef">Chapter 1</em> is – at this point – less than ideal. It was tolerable as an initial description of the interfaces to the application. As we work through the design, we can see that a more specific term like "Researcher" might be a better description for someone researching a sample and looking for a classification.</p>
    <p class="normal">Here's an expanded context diagram with a new consideration of users and their authorized actions:</p>
    <figure class="mediaobject"><img src="img/B17070_04_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.2: Application context diagram</p>
    <p class="normal">The Botanist is responsible for one kind of data, and has two valid operations. The Researcher is responsible for a different kind of data, and has only one valid operation.</p>
    <p class="normal">The data and the processing use cases are intimately tied together. When a Botanist provides new training data or sets the parameters and tests the classifier, the application software must be sure their inputs are valid.</p>
    <p class="normal">Similarly, when a<a id="_idIndexMarker288"/> Researcher tries to classify a sample, the software must confirm that the data is valid and can be used. Invalid data must be reported to the Researcher so they can fix their inputs and try again.</p>
    <p class="normal">We can decompose handling bad data into two parts, each of which is tackled separately:</p>
    <ul>
      <li class="bullet">Discovering exceptional data. As we've seen in this chapter, this is implemented as raising an exception when invalid data is encountered. </li>
      <li class="bullet">Responding to exceptional data. This is implemented as a <code class="Code-In-Text--PACKT-">try:</code>/<code class="Code-In-Text--PACKT-">except:</code> block that provides useful information on the nature of the problem and likely courses of action to resolve it.</li>
    </ul>
    <p class="normal">We'll start with discovering the exceptional data, first. Raising the right exception is the foundation for handling bad data.</p>
    <h2 id="_idParaDest-87" class="title">Processing view</h2>
    <p class="normal">While there are a lot of data<a id="_idIndexMarker289"/> objects in this application, we're going to narrow our focus to the <code class="Code-In-Text--PACKT-">KnownSample</code> and <code class="Code-In-Text--PACKT-">UnknownSample</code> classes. These two are related to a common superclass, the <code class="Code-In-Text--PACKT-">Sample</code> class. These are created by two other classes. The following diagram shows where the <code class="Code-In-Text--PACKT-">Sample</code> objects are created:</p>
    <figure class="mediaobject"><img src="img/B17070_04_03.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.3: Object creation</p>
    <p class="normal">We've included two classes that will create these two kinds of samples. The <code class="Code-In-Text--PACKT-">TrainingData</code> class will load known samples. An overall <code class="Code-In-Text--PACKT-">ClassifierApp</code> class will validate an unknown sample, and attempt to classify it. </p>
    <p class="normal">A <code class="Code-In-Text--PACKT-">KnownSample</code> object has five attributes, each of which has a narrowly-defined set of valid values: </p>
    <ul>
      <li class="bullet">The measurements, <code class="Code-In-Text--PACKT-">sepal_length</code>, <code class="Code-In-Text--PACKT-">sepal_width</code>, <code class="Code-In-Text--PACKT-">petal_length</code>, <code class="Code-In-Text--PACKT-">petal_width</code>, are all floating-point numbers. There's a lower-bound of zero for these values.</li>
      <li class="bullet">The expert-supplied <code class="Code-In-Text--PACKT-">species</code> value is a string, with three valid values.</li>
    </ul>
    <p class="normal">An <code class="Code-In-Text--PACKT-">UnknownSample</code> object <a id="_idIndexMarker290"/>has only the four measurements. The idea of using a common superclass definition can help us ensure this validation processing is reused.</p>
    <p class="normal">The rules for valid values listed above only define the valid values for each attribute considered in isolation. In some applications, there may be complex relationships among the attributes, or rules that define relationships among the samples. For our case study, we'll focus on the five attribute validation rules.</p>
    <h2 id="_idParaDest-88" class="title">What can go wrong?</h2>
    <p class="normal">It helps to consider what can go wrong when loading a <code class="Code-In-Text--PACKT-">Sample</code> object, and what – if anything – the user can do about it. Our sample validation rules suggest we may want to raise specialized kinds of <code class="Code-In-Text--PACKT-">ValueError</code> exceptions to describe data where the measurements aren't valid float values or the species name isn't one of the known strings.</p>
    <p class="normal">We can use a class like the following to define the condition of bad data that can't be processed:</p>
    <pre class="programlisting code"><code class="hljs-code">class InvalidSampleError(ValueError):
    """Source data file has invalid data representation"""
</code></pre>
    <p class="normal">This lets us raise an <code class="Code-In-Text--PACKT-">InvalidSampleError</code> exception for input data that this application can't process. The intent is to provide a message with the details of what needs to be repaired.</p>
    <p class="normal">This can help us distinguish between bugs in our code, which may raise a <code class="Code-In-Text--PACKT-">ValueError</code> exception, and correct behavior in the presence of bad data, where the <code class="Code-In-Text--PACKT-">InvalidSampleError</code> exception will be raised. This means we need to be specific in our <code class="Code-In-Text--PACKT-">except:</code> blocks, using the <code class="Code-In-Text--PACKT-">InvalidSampleError</code> exception. </p>
    <p class="normal">If we ever use <code class="Code-In-Text--PACKT-">except ValueError:</code>, it will handle both generic exceptions as well as our unique exception. This means we might treat a more serious bug as invalid data. The trick is to be cautious handling generic exceptions; we may be working around a bug.</p>
    <h2 id="_idParaDest-89" class="title">Bad behavior</h2>
    <p class="normal">Earlier we suggested that a user might <a id="_idIndexMarker291"/>attempt an action which is invalid. For example, a Researcher might try to provide classified <code class="Code-In-Text--PACKT-">KnownSample</code> objects. The action of loading new training data is reserved for the Botanist; this means an attempt by a Researcher should raise some kind of exception.</p>
    <p class="normal">Our application works in the context of the overall operating system. For command-line applications, we can partition users into two groups, and use the operating system file ownership and access permissions to limit which group can run which applications. This is an effective and comprehensive solution, and doesn't require any Python code.</p>
    <p class="normal">For web-based applications, however, we need to authenticate each user to a web application. All of the web application frameworks for Python provide user authentication<a id="_idIndexMarker292"/> mechanisms. Many frameworks have handy plug-ins for systems like Open Authentication, OAuth. See <a href="https://oauth.net/2/">https://oauth.net/2/</a> for more information.</p>
    <p class="normal">For web applications, we<a id="_idIndexMarker293"/> generally have two tiers of processing:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Authentication</strong> of the user. This is<a id="_idIndexMarker294"/> where a user identifies themselves. This might involve a single factor like a password, or multiple factors like a physical key or an interaction with a cell phone.</li>
      <li class="bullet"><strong class="keyword">Authorization </strong>to <a id="_idIndexMarker295"/>perform some action. We'll often define roles for the users, and limit access to various resources based on the user's role. This means raising an exception when the user doesn't have the appropriate role to access a resource.</li>
    </ul>
    <p class="normal">Many web frameworks will use exceptions as an internal signal that something should not be allowed. This internal exception must then be mapped to external HTTP status codes, like a <code class="Code-In-Text--PACKT-">401 Authorization Required</code> response.</p>
    <p class="normal">This is a deep topic, outside the scope of this book. See, for example, <em class="italic">Building Web Applications with Flask</em> (<a href="https://www.packtpub.com/product/building-web-applications-with-flask/9781784396152">https://www.packtpub.com/product/building-web-applications-with-flask/9781784396152</a>) for an introduction to web applications.</p>
    <h2 id="_idParaDest-90" class="title">Creating samples from CSV files</h2>
    <p class="normal">Details of various options for reading samples in different file formats is something we need to defer to <em class="chapterRef">Chapter 9</em>, <em class="italic">Strings, Serialization, and File Paths</em>, where we talk in detail about serialization techniques. For now, we'll skip a number of details and focus on an approach that works very nicely for CSV-formatted data.</p>
    <p class="normal"><strong class="keyword">CSV</strong> – <strong class="keyword">Comma-Separated Values</strong> – can <a id="_idIndexMarker296"/>be used to define the rows of a spreadsheet. Within each row, the cell values are represented as text, separated by commas. When this data is parsed by Python's <code class="Code-In-Text--PACKT-">csv</code> module, each row can be represented by a dictionary where the keys are the column names and the values are the cell values from a particular row.</p>
    <p class="normal">For example, a row might look like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; row = {"sepal_length": "5.1", "sepal_width": "3.5", 
... "petal_length": "1.4", "petal_width": "0.2", 
... "species": "Iris-setosa"}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">csv</code> module's <code class="Code-In-Text--PACKT-">DictReader</code> class provides an iterable sequence of <code class="Code-In-Text--PACKT-">dict[str, str]</code> row instances. We need to transform these raw rows into instances of one of the subclasses of <code class="Code-In-Text--PACKT-">Sample</code>, if all of the features have valid string values. If the raw data isn't valid, then we need to raise an exception.</p>
    <p class="normal">Given rows like the example <a id="_idIndexMarker297"/>above, here's a method that will translate from the dictionary to a more useful object. This is part of the <code class="Code-In-Text--PACKT-">KnownSample</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">@classmethod
def from_dict(cls, row: dict[str, str]) -&gt; "KnownSample":
    if row["species"] not in {
            "Iris-setosa", "Iris-versicolour", "Iris-virginica"}:
        raise InvalidSampleError(f"invalid species in {row!r}")
    try:
        return cls(
            species=row["species"],
            sepal_length=float(row["sepal_length"]),
            sepal_width=float(row["sepal_width"]),
            petal_length=float(row["petal_length"]),
            petal_width=float(row["petal_width"]),
        )
    except ValueError as ex:
        raise InvalidSampleError(f"invalid {row!r}")
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">from_dict()</code> method makes a check of the species value, raising an exception if it's not valid. It attempts to create a row, applying the <code class="Code-In-Text--PACKT-">float()</code> function to convert various measurements from string values to float values. If the conversions all work, then the <code class="Code-In-Text--PACKT-">cls</code> parameter – the class to create – will build the expected object.</p>
    <p class="normal">If any of the <code class="Code-In-Text--PACKT-">float()</code> function evaluations encounters a problem, and raises a <code class="Code-In-Text--PACKT-">ValueError</code> exception; this is used to create our application's unique <code class="Code-In-Text--PACKT-">InvalidSampleError</code> exception.</p>
    <p class="normal">This style of validation is a<a id="_idIndexMarker298"/> mixture of some <strong class="keyword">Look Before You Leap</strong> (<strong class="keyword">LBYL</strong>) and <strong class="keyword">Easier to Ask Forgiveness than Permission</strong> (<strong class="keyword">EAFP</strong>) styles. The most <a id="_idIndexMarker299"/>widely-used approach in Python is EAFP. In the case of the species value, however, there's no conversion function similar to <code class="Code-In-Text--PACKT-">float()</code> to raise an exception or bad data. In this example, we've chosen to use LBYL for this attribute value. We'll look at an alternative below.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">from_dict()</code> method is defined with the <code class="Code-In-Text--PACKT-">@classmethod</code> decoration. This means the actual class object becomes the first parameter, <code class="Code-In-Text--PACKT-">cls</code>. When we do this, it means any subclass that inherits this will have the method tailored for that subclass. We can create a new subclass, for example, <code class="Code-In-Text--PACKT-">TrainingKnownSample</code>, using code like this:</p>
    <pre class="programlisting code"><code class="hljs-code">class TrainingKnownSample(KnownSample): 
    pass
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">TrainingKnownSample.from_dict()</code> method will be given the <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> class <a id="_idIndexMarker300"/>as the <code class="Code-In-Text--PACKT-">cls</code> parameter value; without any other code, the <code class="Code-In-Text--PACKT-">from_dict()</code> method of this class will build instances of the <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> class.</p>
    <p class="normal">While this works nicely, it's not clear to <strong class="" style="font-style: italic;">mypy</strong> that it works. We can use the following definition to provide an explicit type mapping:</p>
    <pre class="programlisting code"><code class="hljs-code">class TrainingKnownSample(KnownSample):
    @classmethod
    def from_dict(cls, row: dict[str, str]) -&gt; "TrainingKnownSample":
        return cast(TrainingKnownSample, super().from_dict(row))
</code></pre>
    <p class="normal">An alternative is to use the simpler class definition and put the <code class="Code-In-Text--PACKT-">cast()</code> operation in the places where <code class="Code-In-Text--PACKT-">from_dict()</code> is actually used, for example, <code class="Code-In-Text--PACKT-">cast(TrainingKnownSample, TrainingKnownSample.from_dict(data))</code>. Since this method is not used in very many places, it's difficult to assert which variation is simpler.</p>
    <p class="normal">Here's the rest of the <code class="Code-In-Text--PACKT-">KnownSample</code> class, repeated from the previous chapter:</p>
    <pre class="programlisting code"><code class="hljs-code">class KnownSample(Sample):
    def __init__(
        self,
        species: str,
        sepal_length: float,
        sepal_width: float,
        petal_length: float,
        petal_width: float,
    ) -&gt; None:
        super().__init__(
            sepal_length=sepal_length,
            sepal_width=sepal_width,
            petal_length=petal_length,
            petal_width=petal_width,
        )
        self.species = species
    def __repr__(self) -&gt; str:
        return (
            f"{self.__class__.__name__}("
            f"sepal_length={self.sepal_length}, "
            f"sepal_width={self.sepal_width}, "
            f"petal_length={self.petal_length}, "
            f"petal_width={self.petal_width}, "
            f"species={self.species!r}, "
            f")"
        )
</code></pre>
    <p class="normal">Let's see how this works in practice. Here's an example of loading some valid data:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from model import TrainingKnownSample
&gt;&gt;&gt; valid = {"sepal_length": "5.1", "sepal_width": "3.5",
...  "petal_length": "1.4", "petal_width": "0.2",
...  "species": "Iris-setosa"}
&gt;&gt;&gt; rks = TrainingKnownSample.from_dict(valid)
&gt;&gt;&gt; rks
TrainingKnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species='Iris-setosa', )
</code></pre>
    <p class="normal">We created the<a id="_idIndexMarker301"/> dictionary, <code class="Code-In-Text--PACKT-">valid</code>, that a <code class="Code-In-Text--PACKT-">csv.DictReader</code> would create from a line of input. Then, we built a <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> instance, <code class="Code-In-Text--PACKT-">rks</code>, from this dictionary. The resulting object has proper floating-point values, showing that conversions from strings have been performed as needed.</p>
    <p class="normal">Here's how the validation behaves. This is an example of the kind of exception raised for bad data:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from model import TestingKnownSample, InvalidSampleError
&gt;&gt;&gt; invalid_species = {"sepal_length": "5.1", "sepal_width": "3.5",
...  "petal_length": "1.4", "petal_width": "0.2",
...  "species": "nothing known by this app"}
&gt;&gt;&gt; eks = TestingKnownSample.from_dict(invalid_species)
Traceback (most recent call last):
...
model.InvalidSampleError: invalid species in {'sepal_length': '5.1', 'sepal_width': '3.5', 'petal_length': '1.4', 'petal_width': '0.2', 'species': 'nothing known by this app'}
</code></pre>
    <p class="normal">When we tried to create a <code class="Code-In-Text--PACKT-">TestingKnownSample</code> instance, the invalid species value raised an exception. </p>
    <p class="normal">Have we spotted all potential problems? The <code class="Code-In-Text--PACKT-">csv</code> module handles the physical format issues, so providing a PDF file, for example, will lead to exceptions being raised by the <code class="Code-In-Text--PACKT-">csv</code> module. Invalid species names and float values are checked in the <code class="Code-In-Text--PACKT-">from_dict()</code> method.</p>
    <p class="normal">There are some things we did not check. Here are some additional validations:</p>
    <ul>
      <li class="bullet">Missing keys. If a <a id="_idIndexMarker302"/>key is spelled incorrectly, this code will raise a <code class="Code-In-Text--PACKT-">KeyError</code> exception, which would not be restated as an <code class="Code-In-Text--PACKT-">InvalidSampleError</code> exception. This change is left as an exercise for the reader.</li>
      <li class="bullet">Extra keys. If there are unexpected columns, is the data invalid, or do we ignore this? It may be that we're given data from a spreadsheet with extra columns that should be ignored. While it's helpful to be flexible, it's also important to expose potential problems with the input.</li>
      <li class="bullet">Out-of-range float values. There are likely some sensible upper and lower bounds on the range of measurements. The lower bound of zero, seems clear; negative measurements don't make much sense. The upper bound, however, isn't as clear. There are some statistical techniques for locating <a id="_idIndexMarker303"/>outliers, including the <strong class="keyword">Median Absolute Deviation</strong> (<strong class="keyword">MAD</strong>) technique. <p class="bullet">See <a href="https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm">https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm</a> for more information on how to spot data that doesn't seem to fit a normal distribution.</p>
      </li>
    </ul>
    <p class="normal">The first of these additional checks can be added to the <code class="Code-In-Text--PACKT-">from_dict()</code> method. The second is a decision that must be reached with the users, and then potentially added to the <code class="Code-In-Text--PACKT-">from_dict()</code> method.</p>
    <p class="normal">The outlier detection is more sophisticated. We need to perform this check after all the testing and training samples have been loaded. Because the outlier check doesn't apply to a single row, it needs a different exception. We might define another exception like this:</p>
    <pre class="programlisting code"><code class="hljs-code">class OutlierError(ValueError):
    """Value lies outside the expected range."""
</code></pre>
    <p class="normal">This exception can be used with a simple range check, or the more sophisticated MAD method for outlier detection.</p>
    <h2 id="_idParaDest-91" class="title">Validating enumerated values</h2>
    <p class="normal">The list of valid <a id="_idIndexMarker304"/>species isn't very visible. We've essentially buried it inside the <code class="Code-In-Text--PACKT-">from_dict()</code> method, which may become a maintenance problem. When the source data changes, we need to also update this method, something that can be hard to remember and almost as hard to find. If the list of species becomes long, the lines of code could become hard to read.</p>
    <p class="normal">Using an explicit <code class="Code-In-Text--PACKT-">enum</code> class with the list of valid values is a way to convert this to purely EAFP processing. Consider using the following to validate species. Doing this means redefining a number of classes:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class Species(Enum):
...    Setosa = "Iris-setosa"
...    Versicolour = "Iris-versicolour"
...    Viginica = "Iris-virginica"
&gt;&gt;&gt; Species("Iris-setosa")
&lt;Species.Setosa: 'Iris-setosa'&gt;
&gt;&gt;&gt; Species("Iris-pinniped")
Traceback (most recent call last):
...
ValueError: 'Iris-pinniped' is not a valid Species
</code></pre>
    <p class="normal">When we apply the <code class="Code-In-Text--PACKT-">enum</code> class name, <code class="Code-In-Text--PACKT-">Species</code>, to one of the enumerated literal values, it will raise a <code class="Code-In-Text--PACKT-">ValueError</code> exception to show the string representation of the species is invalid. This parallels the way <code class="Code-In-Text--PACKT-">float()</code> and <code class="Code-In-Text--PACKT-">int()</code> raise <code class="Code-In-Text--PACKT-">ValueError</code> exceptions for a string that's not a valid number.</p>
    <p class="normal">Switching to enumerated values would also require changes to the class definition for a known sample. The class needs to be modified to use the enumeration, <code class="Code-In-Text--PACKT-">Species</code>, instead of <code class="Code-In-Text--PACKT-">str</code>. For this case study, the list of values is small, and an <code class="Code-In-Text--PACKT-">Enum</code> seems practical. For other problem domains, however, the enumerated list of values could be quite large and an <code class="Code-In-Text--PACKT-">Enum</code> class might be long and uninformative.</p>
    <p class="normal">Instead of an <code class="Code-In-Text--PACKT-">Enum</code> class, we might continue to use string objects. We can define each unique domain of string values as an extension to a <code class="Code-In-Text--PACKT-">Set[str]</code> class:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from typing import Set
&gt;&gt;&gt; class Domain(Set[str]):
...     def validate(self, value: str) -&gt; str:
...         if value in self:
...             return value
...         raise ValueError(f"invalid {value!r}")
&gt;&gt;&gt; species = Domain({"Iris-setosa", "Iris-versicolour", "Iris-virginica"})
&gt;&gt;&gt; species.validate("Iris-versicolour")
'Iris-versicolour'
&gt;&gt;&gt; species.validate("odobenidae")
Traceback (most recent call last):
...
ValueError: invalid 'odobenidae'
</code></pre>
    <p class="normal">We can <a id="_idIndexMarker305"/>use the <code class="Code-In-Text--PACKT-">species.validate()</code> function similar to the way we used the <code class="Code-In-Text--PACKT-">float()</code> function. This will validate the string, without coercing it to a different value. Instead, it returns the string. For invalid values, it raises a <code class="Code-In-Text--PACKT-">ValueError</code> exception.</p>
    <p class="normal">This lets us rewrite the body of the <code class="Code-In-Text--PACKT-">from_dict()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">@classmethod
def from_dict(cls, row: dict[str, str]) -&gt; "KnownSample":
    try:
        return cls(
            species=species.validate(row["species"]),
            sepal_length=float(row["sepal_length"]),
            sepal_width=float(row["sepal_width"]),
            petal_length=float(row["petal_length"]),
            petal_width=float(row["petal_width"]),
        )
    except ValueError as ex:
        raise InvalidSampleError(f"invalid {row!r}")
</code></pre>
    <p class="normal">This variation relies on the global <code class="Code-In-Text--PACKT-">species</code> to be a set of valid species. It also uses a pleasantly consistent EAFP approach to building the required object or raising an exception.</p>
    <p class="normal">As we mentioned earlier, there are two parts to this design. We've looked at the foundational element, raising an appropriate exception. Now we can look at the context in which we use this <code class="Code-In-Text--PACKT-">from_dict()</code> function, and how errors get reported to users.</p>
    <h2 id="_idParaDest-92" class="title">Reading CSV files</h2>
    <p class="normal">We'll provide a <a id="_idIndexMarker306"/>common template for creating objects from CSV source data. The idea is to leverage the <code class="Code-In-Text--PACKT-">from_dict()</code> methods of the various classes to create the objects our application uses:</p>
    <pre class="programlisting code"><code class="hljs-code">class TrainingData:
    def __init__(self, name: str) -&gt; None:
        self.name = name
        self.uploaded: datetime.datetime
        self.tested: datetime.datetime
        self.training: list[TrainingKnownSample] = []
        self.testing: list[TestingKnownSample] = []
        self.tuning: list[Hyperparameter] = []
    def load(self, raw_data_iter: Iterable[dict[str, str]]) -&gt; None:
        for n, row in enumerate(raw_data_iter):
            try:
                if n % 5 == 0:
                    test = TestingKnownSample.from_dict(row)
                    self.testing.append(test)
                else:
                    train = TrainingKnownSample.from_dict(row)
                    self.training.append(train)
            except InvalidSampleError as ex:
                print(f"Row {n+1}: {ex}")
                return
        self.uploaded = datetime.datetime.now(tz=datetime.timezone.utc)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">load()</code> method is partitioning the samples into testing and training subsets. It expects an iterable source of <code class="Code-In-Text--PACKT-">dict[str, str]</code> objects, which are produced by a <code class="Code-In-Text--PACKT-">csv.DictReader</code> object.</p>
    <p class="normal">The user experience implemented here is to report the first failure and return. This might lead to an error message like the following:</p>
    <pre class="programlisting con"><code class="hljs-con">text Row 2: invalid species in {'sepal_length': 7.9, 'sepal_width': 3.2, 'petal_length': 4.7, 'petal_width': 1.4, 'species': 'Buttercup'}
</code></pre>
    <p class="normal">This message has all the required information, but may not be as helpful as desired. We might, for example, want to report <em class="italic">all</em> failures, instead of the first failure. Here's how we might restructure the <code class="Code-In-Text--PACKT-">load()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">def load(self, raw_data_iter: Iterable[dict[str, str]]) -&gt; None:
    bad_count = 0
    for n, row in enumerate(raw_data_iter):
        try:
            if n % 5 == 0:
                test = TestingKnownSample.from_dict(row)
                self.testing.append(test)
            else:
                train = TrainingKnownSample.from_dict(row)
                self.training.append(train)
        except InvalidSampleError as ex:
            print(f"Row {n+1}: {ex}")
            bad_count += 1
    if bad_count != 0:
        print(f"{bad_count} invalid rows")
        return
    self.uploaded = datetime.datetime.now(tz=datetime.timezone.utc)
</code></pre>
    <p class="normal">This variation <a id="_idIndexMarker307"/>would catch each <code class="Code-In-Text--PACKT-">InvalidSampleError</code> error, displaying a message and counting the number of problems. This information might be more helpful because the user could then correct all of the rows which are invalid.</p>
    <p class="normal">In the case of a very, very large set of data, this may lead to a useless level of detail. If we accidentally used a CSV file with several hundred thousand rows of images of hand-written numbers, for example, instead of Iris data, we'd get several hundred thousand messages telling us each individual row was bad.</p>
    <p class="normal">Some additional user experience design is required around this loading operation, to make it useful in a wide variety of situations. The foundation, however, is the Python exception that's raised when something's not right. In this case study, we leveraged the <code class="Code-In-Text--PACKT-">float()</code> function's <code class="Code-In-Text--PACKT-">ValueError</code> and rewrote it to be our application's unique <code class="Code-In-Text--PACKT-">InvalidSampleError</code> exception. We also created our own <code class="Code-In-Text--PACKT-">ValueError</code> exceptions for unexpected strings.</p>
    <h2 id="_idParaDest-93" class="title">Don't repeat yourself</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">load()</code> method of <code class="Code-In-Text--PACKT-">TrainingData</code> will create two different subclasses of <code class="Code-In-Text--PACKT-">KnownSample</code>. We've put <a id="_idIndexMarker308"/>most of the processing into the <code class="Code-In-Text--PACKT-">KnownSample</code> superclass; this avoids repeating the validation processing in each subclass.</p>
    <p class="normal">For an <code class="Code-In-Text--PACKT-">UnknownSample</code>, however, we have a tiny problem: there's no species data in an <code class="Code-In-Text--PACKT-">UnknownSample</code>. It would be ideal to extract the validation of the four measurements, and keep them separate from validating the species. If we do this, we can't trivially combine building a <code class="Code-In-Text--PACKT-">Sample</code> with doing the validation in one simple EAFP kind of method that either creates the desired object or raises an exception that it can't be built. </p>
    <p class="normal">When a subclass introduces new fields, we have two choices:</p>
    <ul>
      <li class="bullet">Abandon simple-looking EAFP validation. In this case, we would need to separate validation from object construction. This will lead to the cost of doing <code class="Code-In-Text--PACKT-">float()</code> conversions twice: once to validate the data and again to create the target object. Multiple <code class="Code-In-Text--PACKT-">float()</code> conversions means we <a id="_idIndexMarker309"/>haven't really followed the <strong class="keyword">Don't Repeat Yourself</strong> (<strong class="keyword">DRY</strong>) principle.</li>
      <li class="bullet">Build an intermediate representation that can be used by subclasses. This means the two <code class="Code-In-Text--PACKT-">KnownSample</code> subclass of <code class="Code-In-Text--PACKT-">Sample</code> would involve three steps. First, build a <code class="Code-In-Text--PACKT-">Sample</code> object, validating the four measurements. Then, validate the species. Finally, build the <code class="Code-In-Text--PACKT-">KnownSample</code> using the valid fields from the <code class="Code-In-Text--PACKT-">Sample</code> object and the valid species value. This creates a temporary object, but avoids repeating any code.</li>
    </ul>
    <p class="normal">We'll leave the implementation details as an exercise for the reader.</p>
    <p class="normal">Once the exception is defined, we also need to display the results to the user in a form that guides them to a the right remedial action. This is a separate user experience design consideration that is built on the foundation of the underlying exception.</p>
    <h1 id="_idParaDest-94" class="title">Recall</h1>
    <p class="normal">Some key points in this chapter:</p>
    <ul>
      <li class="bullet">Raising an exception happens when something goes wrong. We looked at division by zero as an example. Exceptions can also be raised with the <code class="Code-In-Text--PACKT-">raise</code> statement.</li>
      <li class="bullet">The effects of an exception are to interrupt the normal sequential execution of statements. It saves us from having to write a lot of <code class="Code-In-Text--PACKT-">if</code> statements to check to see if things can possibly work or check to see if something actually failed.</li>
      <li class="bullet">Handling exceptions is done with the <code class="Code-In-Text--PACKT-">try:</code> statement, which has an <code class="Code-In-Text--PACKT-">except:</code> clause for each kind of exception we want to handle.</li>
      <li class="bullet">The exception hierarchy follows object-oriented design patterns to define a number of subclasses of the <code class="Code-In-Text--PACKT-">Exception</code> class we can work with. Some additional exceptions, <code class="Code-In-Text--PACKT-">SystemExit</code> and <code class="Code-In-Text--PACKT-">KeyboardInterrupt</code>, are not subclasses of the <code class="Code-In-Text--PACKT-">Exception</code> class; handling these introduces risks and doesn't solve very many problems, so we generally ignore them.</li>
      <li class="bullet">Defining our own exceptions is a matter of extending the <code class="Code-In-Text--PACKT-">Exception</code> class. This makes it possible to define exceptions with very specific semantics.</li>
    </ul>
    <h1 id="_idParaDest-95" class="title">Exercises</h1>
    <p class="normal">If you've never dealt with exceptions before, the first thing you need to do is look at any old Python code you've written and notice if there are places you should have been handling exceptions. How would you handle them? Do you need to handle them at all? Sometimes, letting the exception propagate to the console is the best way to communicate to the user, especially if the user is also the script's coder. Sometimes, you can recover from the error and allow the program to continue. Sometimes, you can only reformat the error into something the user can understand and display it to them.</p>
    <p class="normal">Some common places to look are file I/O (is it possible your code will try to read a file that doesn't exist?), mathematical expressions (is it possible that a value you are dividing by is zero?), list indices (is the list empty?), and dictionaries (does the key exist?). </p>
    <p class="normal">Ask yourself whether you should ignore the problem, handle it by checking values first, or handle it with an exception. Pay special attention to areas where you might have used <code class="Code-In-Text--PACKT-">finally</code> and <code class="Code-In-Text--PACKT-">else</code> to ensure the correct code is executed under all conditions.</p>
    <p class="normal">Now write some new code, extending the case study to cover any additional validation checks for the input data. For example, we need to check the measurements to be sure they're in a sensible range. This can be an additional subclass of <code class="Code-In-Text--PACKT-">ValueError</code>. We can apply the concept to other parts of the case study. For example, we might want to validate <code class="Code-In-Text--PACKT-">Sample</code> objects to be sure the values are all positive numbers.</p>
    <p class="normal">The case study doesn't do any range checking in the <code class="Code-In-Text--PACKT-">from_dict()</code> method. Checking the lower bound of zero is easy, and it would be good to add this as the first exercise. </p>
    <p class="normal">For setting an upper bound on the various measurements, it's important to know the data. First, it's helpful to survey the data and find the actual minimum, maximum, median, and the absolute deviations from the median. Given this summary information, a sensible set of limits can be defined and range checks added.</p>
    <p class="normal">We haven't addressed creating <code class="Code-In-Text--PACKT-">UnknownSample</code> instances, leaving the <code class="Code-In-Text--PACKT-">from_dict()</code> method as an exercise for the reader. In the <em class="italic">Don't repeat yourself</em> section, above, we described an implementation where validating the four measurements in the <code class="Code-In-Text--PACKT-">from_dict()</code> processing is refactored into the Sample class. This leads to two design changes:</p>
    <ul>
      <li class="bullet">In <code class="Code-In-Text--PACKT-">KnownSample</code>, use the <code class="Code-In-Text--PACKT-">Sample.from_dict()</code> to validate the measurements, validate species, and build the final <code class="Code-In-Text--PACKT-">KnownSample</code> object.</li>
      <li class="bullet">In <code class="Code-In-Text--PACKT-">UnknownSample</code>, use the <code class="Code-In-Text--PACKT-">Sample.from_dict()</code> to validate the measurements, then build the final <code class="Code-In-Text--PACKT-">UnknownSample</code> object.</li>
    </ul>
    <p class="normal">These changes should lead to a reasonably flexible data validation that doesn't involve copying and pasting the validation rules for measurements or species.</p>
    <p class="normal">Finally, try to think of places in your code where you can raise exceptions. It can be in code you've written or are working on, or you can write a new project as an exercise. You'll probably have the best luck designing a small framework or API that is meant to be used by other people; exceptions are a terrific communication tool between your code and someone else's. Remember to design and document any self-raised exceptions as part of the API, or they won't know whether or how to handle them!</p>
    <h1 id="_idParaDest-96" class="title">Summary</h1>
    <p class="normal">In this chapter, we went into the gritty details of raising, handling, defining, and manipulating exceptions. Exceptions are a powerful way to communicate unusual circumstances or error conditions without requiring a calling function to explicitly check return values. There are many built-in exceptions and raising them is trivially easy. There are several different syntaxes for handling different exception events.</p>
    <p class="normal">In the next chapter, everything we've studied so far will come together as we discuss how object-oriented programming principles and structures should best be applied in Python applications.</p>
  </div>
</body></html>