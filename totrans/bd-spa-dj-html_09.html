<html><head></head><body>
		<div><h1 id="_idParaDest-74"><a id="_idTextAnchor139"/>Chapter 6: Creating SPAs on the Backends</h1>
			<p>We cannot create a complete site by simply managing groups and sending HTML to the client. We must first master a variety of small solutions in order to be able to build a dynamic page that interacts with the user, with essential features such as page switching!</p>
			<p>When the first <strong class="bold">single-page applications</strong> (<strong class="bold">SPAs</strong>) were created, the developers at the time were forced to spend many hours on functionalities that had been free when using the HTTP protocol: routing, sessions, authentication, or origin verification, among others. Poor them! They had to re-invent the wheel with a rebellious adolescent JavaScript that was not very cross-browser compatible. However, they survived, or so I would like to think, by defining techniques in the frontend that have managed to mimic the same behavior as HTTP; these techniques have lasted until today. For example, in a routing system, when a SPA redraws a screen, the browser URL is modified to put the user in context. On the other hand, if a visitor manually types the address, the application reacts by loading the components that make up the screen. All tasks are exhausting to implement with JavaScript. It is not cheap to change content without making a new request. If we just used plain HTML, we wouldn’t need to do anything, but of course, the user would experience a page refresh with every change. And what does all this have to do with us? If we create pages using the WebSockets protocol, we find ourselves in a similar situation; we have to invent formulations to simulate the behavior that a polite user expects from us.</p>
			<p>Channels is simple in functionality compared to other libraries, but at the same time very mature and consistent with the real world. It is a framework born out of necessity. It relies on Django to give us the essentials to solve typical problems while providing flexibility. </p>
			<p>In this chapter, we are going to review different approaches to the following:</p>
			<ul>
				<li>Switching between pages</li>
				<li>Server-side rendering for each route</li>
				<li>Including a browser to achieve dynamic navigation</li>
				<li>Changing URLs</li>
				<li>Hydrating sections or components</li>
				<li>Creating temporary sessions for sessions</li>
				<li>Avoiding <strong class="bold">cross-site request forgery</strong> (<strong class="bold">CSRF</strong>) with WebSockets</li>
			</ul>
			<p>Therefore, we are going to focus on how to solve each point in order to prepare ourselves for <a href="B18321_07_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 7</em></a>,<em class="italic"> Creating a Real-Time Blog Using Only Django.</em></p>
			<p>Let’s organize our projects a bit better. From now on, we are going to divide Channels into two files: <code>consumers.py</code>, which will be the equivalent of <code>views.py</code> or a communication gateway between the frontend and the backend, and <code>actions.py</code>, where the logic or functions will be located.</p>
			<p>We’ll start by adding a complete system for switching pages. You will not need to follow each point in order, as you will find examples of how we can solve each task, not a tutorial.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor140"/>Technical requirements</h1>
			<p>All the code from the different sections can be found at the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-6">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-6</a></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor141"/>Switching between pages</h1>
			<p>At some point, the user <a id="_idIndexMarker294"/>will need to go to another page or change context. We are going to make them think this is happening, but in reality, it is going to be a magic trick since really, they will never move from the first HTML we gave them at the beginning. However, and here’s the key, they will perceive that the page is being changed. To achieve this deception (sorry, achievement), we will carry out the following tasks:</p>
			<ol>
				<li>Change the HTML of the main content or everything that belongs to <code>&lt;main&gt;</code>. Meanwhile, we will always keep the static sections of the pages, such as <code>&lt;header&gt;</code>, <code>&lt;aside&gt;</code>, or <code>&lt;footer&gt;</code>.</li>
				<li>Implement server-side rendering to render the HTML belonging to each URL.</li>
				<li>Visually mark in the <code>&lt;nav&gt;</code> where we are with a CSS style.</li>
				<li>Modify the browser URL via the JavaScript API. It is an aesthetic change but the URL acts as breadcrumbs to guide the visitor.</li>
			</ol>
			<p>The objective is to <a id="_idIndexMarker295"/>build a site with three pages: <code>base.html</code>:</p>
			<pre class="source-code">{% load static %}</pre>
			<pre class="source-code">&lt;!doctype html&gt;</pre>
			<pre class="source-code">&lt;html lang="en"&gt;</pre>
			<pre class="source-code">&lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="UTF-8"&gt;</pre>
			<pre class="source-code">    &lt;meta name="viewport" content="width=device-width, </pre>
			<pre class="source-code">        user-scalable=no, initial-scale=1.0, maximum-</pre>
			<pre class="source-code">            scale=1.0, minimum-scale=1.0"&gt;</pre>
			<pre class="source-code">    &lt;title&gt;Example website&lt;/title&gt;</pre>
			<pre class="source-code">    &lt;link rel="stylesheet" href="{% static 'css/main.css' </pre>
			<pre class="source-code">        %}"&gt;</pre>
			<pre class="source-code">    &lt;script defer src="img/index.js' %}"&gt;</pre>
			<pre class="source-code">    &lt;/script&gt;</pre>
			<pre class="source-code">&lt;/head&gt;</pre>
			<pre class="source-code">&lt;body</pre>
			<pre class="source-code">        data-host="{{ request.get_host }}"</pre>
			<pre class="source-code">        data-scheme="{{ request.scheme }}"&gt;</pre>
			<pre class="source-code">    &lt;div class="container"&gt;</pre>
			<pre class="source-code">        &lt;header&gt;</pre>
			<pre class="source-code">            &lt;nav id="nav" class="nav"&gt;{% include </pre>
			<pre class="source-code">                'components/_nav.html' %}&lt;/nav&gt;</pre>
			<pre class="source-code">        &lt;/header&gt;</pre>
			<pre class="source-code">        &lt;main id="main"&gt;{% include page %}&lt;/main&gt;</pre>
			<pre class="source-code">        &lt;footer class="footer"&gt;My footer&lt;/footer&gt;</pre>
			<pre class="source-code">    &lt;/div&gt;</pre>
			<pre class="source-code">&lt;/body&gt;</pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>The <code>components/_nav.html</code> component <a id="_idIndexMarker296"/>will be discussed later when we talk about navigation. The important thing is that we are going to incorporate an <code>include</code> inside <code>&lt;main&gt;</code> that we will use to create a future server-side rendering system.</p>
			<p>Next, in the <code>Consumer</code> class, we will create the <code>"Change page"</code> action, which will invoke the <code>send_page (self, "page name")</code> function inside <code>actions.py</code>:</p>
			<pre class="source-code"># app/app_template/consumers.py</pre>
			<pre class="source-code">from channels.generic.websocket import JsonWebsocketConsumer</pre>
			<pre class="source-code">import app.app_template.actions as actions</pre>
			<pre class="source-code"> <a id="_idTextAnchor142"/></pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class ExampleConsumer(JsonWebsocketConsumer):</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def connect(self):</pre>
			<pre class="source-code">        """Event when client connects"""</pre>
			<pre class="source-code">        # Accept the connection</pre>
			<pre class="source-code">        self.accept() </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def disconnect(self, close_code):</pre>
			<pre class="source-code">        """Event when client disconnects"""</pre>
			<pre class="source-code">        pass</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def receive_json(self, data_received):</pre>
			<pre class="source-code">        """</pre>
			<pre class="source-code">            Event when data is received</pre>
			<pre class="source-code">            All information will arrive in 2 variables:</pre>
			<pre class="source-code">            "action", with the action to be taken</pre>
			<pre class="source-code">            "data" with the information</pre>
			<pre class="source-code">        """</pre>
			<pre class="source-code">        # Get the data</pre>
			<pre class="source-code">        data = data_received["data"]</pre>
			<pre class="source-code">        # Depending on the action we will do one task or another.</pre>
			<pre class="source-code">        match data_received["action"]:</pre>
			<pre class="source-code">            case "Change page":</pre>
			<pre class="source-code">                actions.send_page(self, data["page"]) </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def send_html(self, event):</pre>
			<pre class="source-code">        """Event: Send html to client"""</pre>
			<pre class="source-code">        data = {</pre>
			<pre class="source-code">            "selector": event["selector"],</pre>
			<pre class="source-code">            "html": event["html"],</pre>
			<pre class="source-code">            "append": "append" in event and event["append"],</pre>
			<pre class="source-code">            "url": event["url"] if "url" in event else "",</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        self.send_json(data)</pre>
			<p>As you may<a id="_idIndexMarker297"/> have noticed, <code>send_html</code> has also already been modified to incorporate <code>append</code>, which we will use to indicate whether we want to add a block of HTML to the selector or replace all the content (for the moment, we will not implement it), while <code>url</code> will be used to indicate the URL that will be displayed in the browser.</p>
			<p>In <code>app/app_template/actions.py</code>, we would define the function that renders HTML and sends it to the fronte<a id="_idTextAnchor143"/>nd:</p>
			<pre class="source-code">from .forms import LoginForm, SignupForm</pre>
			<pre class="source-code">from asgiref.sync import async_to_sync</pre>
			<pre class="source-code">from django.template.loader import render_to_string</pre>
			<pre class="source-code">from django.urls import reverse</pre>
			<pre class="source-code">from datetime import datetime</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">def send_page(self, page):</pre>
			<pre class="source-code">    """Render HTML and send page to client""""</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    # Prepare context data for page</pre>
			<pre class="source-code">    context = {}</pre>
			<pre class="source-code">    match page:</pre>
			<pre class="source-code">        case "login":</pre>
			<pre class="source-code">            context = {"form": LoginForm()}</pre>
			<pre class="source-code">        case "signup":</pre>
			<pre class="source-code">            context = {"form": SignupForm()}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">     context.update({"active_nav": page})</pre>
			<p>We prepare the variables that will be used to render the HTML templates, the <code>Form</code> object corresponding to each page, and the name of the page where we are:</p>
			<pre class="source-code">    # Render HTML nav and send to client</pre>
			<pre class="source-code">    self.send_html({</pre>
			<pre class="source-code">        "selector": "#nav",</pre>
			<pre class="source-code">        "html": render_to_string("components/_nav.html", </pre>
			<pre class="source-code">            context),</pre>
			<pre class="source-code">    })</pre>
			<p>At each page <a id="_idIndexMarker298"/>change, we must redraw the <code>main</code> browser to mark where we are:</p>
			<pre class="source-code">    # Render HTML page and send to client</pre>
			<pre class="source-code">    self.send_html({</pre>
			<pre class="source-code">        "selector": "#main",</pre>
			<pre class="source-code">        "html": render_to_string(f"pages/{page}.html", </pre>
			<pre class="source-code">            context),</pre>
			<pre class="source-code">        "url": reverse(page),</pre>
			<pre class="source-code">    })</pre>
			<p>Finally, we send the HTML of the page to the frontend at <code>&lt;main&gt;</code> with a variable called <code>url</code>. This will be used by JavaScript later on to modify the address of the browser.</p>
			<p>Before we continue to incorporate page switching, let’s make a pitstop to incorporate the rendering of each view using Django. It will simplify the task of creating a browser that we’ll need to move between pages. </p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor144"/>Server-side rendering for each route</h1>
			<p>After<a id="_idIndexMarker299"/> preparing the <code>Consumer</code> class to change pages dynamically, we are going to incorporate a trivial system with Django for the management of routes and the rendering of each page without depending on Channels, so that crawlers can index the content. We’ll define three templates (<code>home.html</code>, <code>login.html</code>, and <code>signup.html</code>).</p>
			<p>The content of <code>app/app_template/templates/pages/home.html</code> will be a few lines of HTML:</p>
			<pre class="source-code">&lt;section&gt;</pre>
			<pre class="source-code">    &lt;h1&gt;Welcome to an example of browsing with WebSockets over the Wire.&lt;/h1&gt;</pre>
			<pre class="source-code">    &lt;p&gt;You will be able to experience a simple structure. &lt;/p&gt;</pre>
			<pre class="source-code">&lt;/section&gt;</pre>
			<p>Then, on the second page, representing a login form, we will use a <code>form</code> object to list all the fields and then validate. This will be an argument that we will pass when rendering the template.</p>
			<p>We write the following code in <code>app/app_template/templates/pages/login.html</code>:</p>
			<pre class="source-code">&lt;h1&gt;Login&lt;/h1&gt;</pre>
			<pre class="source-code">&lt;form id="login-form"&gt;</pre>
			<pre class="source-code">    {{ form.as_p }}</pre>
			<pre class="source-code">    &lt;input type="submit" class="button" value="Login"&gt;</pre>
			<pre class="source-code">&lt;/form&gt;</pre>
			<p>Finally, we repeat the same structure in <code>app/app_template/templates/pages/signup.html</code> using a <code>form</code> object:</p>
			<pre class="source-code">&lt;h1&gt;Signup&lt;/h1&gt;</pre>
			<pre class="source-code">&lt;form id="signup-form"&gt;</pre>
			<pre class="source-code">    {{ form.as_p }}</pre>
			<pre class="source-code">    &lt;input type="submit" class="button" value="Signup"&gt;</pre>
			<pre class="source-code">&lt;/form&gt;</pre>
			<p>Before <a id="_idIndexMarker300"/>defining the views, we need to structure the forms. In <code>app/app_template/forms.py</code>, we add the following content:</p>
			<pre class="source-code">from django import forms</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class LoginForm(forms.Form):</pre>
			<pre class="source-code">    email = forms.CharField(</pre>
			<pre class="source-code">        label="Email",</pre>
			<pre class="source-code">        max_length=255,</pre>
			<pre class="source-code">        widget=forms.EmailInput(attrs={"id": "login-email", </pre>
			<pre class="source-code">            "class": "input"}),</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">    password = forms.CharField(</pre>
			<pre class="source-code">        label="Password",</pre>
			<pre class="source-code">        max_length=255,</pre>
			<pre class="source-code">        widget=forms.PasswordInput(attrs={"id": "login-</pre>
			<pre class="source-code">            password", "class": "input"}),</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class SignupForm(forms.Form):</pre>
			<pre class="source-code">    username = forms.CharField(</pre>
			<pre class="source-code">        label="Username",</pre>
			<pre class="source-code">        max_length=255,</pre>
			<pre class="source-code">        widget=forms.TextInput(attrs={"id": "signup-</pre>
			<pre class="source-code">            username", "class": "input"}),</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">    email = forms.EmailField(</pre>
			<pre class="source-code">        label="Email",</pre>
			<pre class="source-code">        max_length=255,</pre>
			<pre class="source-code">        widget=forms.EmailInput(attrs={"id": "signup-</pre>
			<pre class="source-code">            email", "class": "input"}),</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">    password = forms.CharField(</pre>
			<pre class="source-code">        label="Password",</pre>
			<pre class="source-code">        max_length=255,</pre>
			<pre class="source-code">        widget=forms.PasswordInput(attrs={"id": "signup-</pre>
			<pre class="source-code">            password", "class": "input"}),</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">    password_confirm = forms.CharField(</pre>
			<pre class="source-code">        label="Confirm Password",</pre>
			<pre class="source-code">        max_length=255,</pre>
			<pre class="source-code">        widget=forms.PasswordInput(</pre>
			<pre class="source-code">            attrs={"id": "signup-password-confirm", </pre>
			<pre class="source-code">                "class": "input"}</pre>
			<pre class="source-code">        ),</pre>
			<pre class="source-code">    )</pre>
			<p>With the<a id="_idIndexMarker301"/> templates and forms ready to be rendered, we edit <code>app/app_template/views.py</code>:</p>
			<pre class="source-code">from django.shortcuts import render</pre>
			<pre class="source-code">from .forms import LoginForm, SignupForm </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">def home(request):</pre>
			<pre class="source-code">    return render(</pre>
			<pre class="source-code">        request,</pre>
			<pre class="source-code">        "base.html",</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "page": "pages/home.html",</pre>
			<pre class="source-code">            "active_nav": "home",</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">def login(request):</pre>
			<pre class="source-code">    return render(</pre>
			<pre class="source-code">        request,</pre>
			<pre class="source-code">        "base.html",</pre>
			<pre class="source-code">        { "page": "pages/login.html", "active_nav":</pre>
			<pre class="source-code">            "login", "form": LoginForm()},</pre>
			<pre class="source-code">                 )<a id="_idTextAnchor145"/></pre>
			<pre class="source-code">    </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">def signup(request):</pre>
			<pre class="source-code">    return render(</pre>
			<pre class="source-code">        request,</pre>
			<pre class="source-code">        "base.html",</pre>
			<pre class="source-code">        { "page": "pages/signup.html", "active_nav": "signup", "form": SignupForm()},</pre>
			<pre class="source-code">    )</pre>
			<p>In all cases, we<a id="_idIndexMarker302"/> use <code>base.html</code> as the main layout, where we will alter the content of <code>&lt;main&gt;</code> with the <code>page</code> variable:</p>
			<pre class="source-code">&lt;main id="main"&gt;{% include page %}&lt;/main&gt;</pre>
			<p>The <code>active_nav</code> variable is a visual resource to inform the visitor via CSS where they are by changing the color of the appropriate hyperlink. We can ignore it for the moment.</p>
			<p>Now, we edit <code>project_template/urls.py</code> to define all the paths:</p>
			<pre class="source-code">from django.contrib import admin</pre>
			<pre class="source-code">from django.urls import path</pre>
			<pre class="source-code">from app.app_template import views</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    path("", views.home, name="home"),</pre>
			<pre class="source-code">    path("login/", views.login, name="login"),</pre>
			<pre class="source-code">    path("signup/", views.signup, name="signup"),</pre>
			<pre class="source-code">    path("admin/", admin.site.urls),</pre>
			<p>Nothing out of the ordinary; it’s Django’s own routing system. Except for one detail: we haven’t extended it at any point. The usual way would be to render <code>home.html</code> and not <code>base.html</code>. In other words, <code>home.html</code> is the content of the page, which uses <code>base.html</code> as its structure:</p>
			<pre class="source-code">{% extends 'base.html' %}</pre>
			<pre class="source-code">&lt;section&gt;</pre>
			<pre class="source-code">    &lt;h1&gt;Welcome to an example of browsing with WebSockets over the Wire&lt;/h1&gt;.</pre>
			<pre class="source-code">    &lt;p&gt;You will be able to experience a simple structure.&lt;/p&gt;</pre>
			<pre class="source-code">&lt;/section&gt;</pre>
			<p>We’ve done it this way because Django must adapt to the way we’re going to draw HTML via WebSockets. We are only interested in modifying <code>&lt;main&gt;</code> and the templates must be isolated in components to work this way. </p>
			<p>You can now open the three paths to see how they render without using a <code>Consumer</code> class.</p>
			<p>We can see<a id="_idIndexMarker303"/> how the root of the site is rendered:</p>
			<div><div><img src="img/Figure_6.01_B18321.jpg" alt="Figure 6.1 – Rendering the Home page using Django&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Rendering the Home page using Django</p>
			<p>The login form is rendered without any problem:</p>
			<div><div><img src="img/Figure_6.02_B18321.jpg" alt="Figure 6.2 – Rendering the Login page using Django&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Rendering the Login page using Django</p>
			<p>The same <a id="_idIndexMarker304"/>happens when we render the registration page:</p>
			<div><div><img src="img/Figure_6.03_B18321.jpg" alt="Figure 6.3 – Rendering the Signup page using Django&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Rendering the Signup page using Django</p>
			<p>With the server-side rendering system in place, we are going to incorporate a browser that executes actions to dynamically modify the body of the page or small sections of it.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor146"/>Including a browser to achieve dynamic navigation</h1>
			<p>After<a id="_idIndexMarker305"/> incorporating the templates, views, and routes for traditional navigation, we will create a dynamic navigation system.</p>
			<p>We declare a file in the <code>app/app_template/components/_nav.html</code> path with the following content:</p>
			<pre class="source-code">&lt;ul class="nav__ul"&gt;</pre>
			<pre class="source-code">    &lt;li&gt;</pre>
			<pre class="source-code">        &lt;a</pre>
			<pre class="source-code">                href="#"</pre>
			<pre class="source-code">                class="nav__link nav__link nav__link--</pre>
			<pre class="source-code">                    page{% if active_nav == "home" %} </pre>
			<pre class="source-code">                        active{% endif %}"</pre>
			<pre class="source-code">                data-target="home"</pre>
			<pre class="source-code">        &gt;</pre>
			<pre class="source-code">            Home</pre>
			<pre class="source-code">        &lt;/a&gt;</pre>
			<pre class="source-code">    &lt;/li&gt;</pre>
			<pre class="source-code">    &lt;li&gt;</pre>
			<pre class="source-code">        &lt;a</pre>
			<pre class="source-code">                href="#"</pre>
			<pre class="source-code">                class="nav__link nav__link--page{% if </pre>
			<pre class="source-code">                active_nav == "login" %} active{% endif %}"</pre>
			<pre class="source-code">                data-target="login"</pre>
			<pre class="source-code">        &gt;</pre>
			<pre class="source-code">            Login</pre>
			<pre class="source-code">        &lt;/a&gt;</pre>
			<pre class="source-code">    &lt;/li&gt;</pre>
			<pre class="source-code">    &lt;li&gt;</pre>
			<pre class="source-code">        &lt;a</pre>
			<pre class="source-code">                href="#"</pre>
			<pre class="source-code">                class="nav__link nav__link nav__link--   </pre>
			<pre class="source-code">                    page{% if active_nav == "signup" %} </pre>
			<pre class="source-code">                        active{% endif %}"</pre>
			<pre class="source-code">                data-target="signup"</pre>
			<pre class="source-code">        &gt;</pre>
			<pre class="source-code">            Signup</pre>
			<pre class="source-code">        &lt;/a&gt;</pre>
			<pre class="source-code">    &lt;/li&gt;</pre>
			<pre class="source-code">&lt;/ul&gt;</pre>
			<p>We will <a id="_idIndexMarker306"/>pass <code>active_nav</code> to the template with the name of the page we want to mark with CSS, adding the <code>active</code> class. On the other hand, <code>data-target</code> is a dataset that will collect JavaScript to send to the <code>Consumer</code> class and tell it which page to render.</p>
			<p>In JavaScript, we will assign a <code>click</code> event to each <code>&lt;a&gt;</code> to send the action to change the desired page to the <code>Consumer</code> class. Which page? The one we have saved in the <code>data-target</code>. We must be careful before adding a new event listener; it is highly recommended that we delete the previous one to avoid duplicating the events to the same functions. Remember that the HTML is swapped but JavaScript remains static.</p>
			<p>Edit <code>static/js/index.js</code>, adding the browser events:</p>
			<pre class="source-code">/**</pre>
			<pre class="source-code">* Send message to update page</pre>
			<pre class="source-code">* @param {Event} event</pre>
			<pre class="source-code">* @return {void}</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">function handleClickNavigation(event) {</pre>
			<pre class="source-code">    event.preventDefault();</pre>
			<pre class="source-code">    sendData({</pre>
			<pre class="source-code">        action: 'Change page',</pre>
			<pre class="source-code">        data: {</pre>
			<pre class="source-code">            page: event.target.dataset.target</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }, myWebSocket);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">/**</pre>
			<pre class="source-code">* Send message to WebSockets server to change the page</pre>
			<pre class="source-code">* @param {WebSocket} webSocket</pre>
			<pre class="source-code">* @return {void}</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">function setEventsNavigation(webSocket) {</pre>
			<pre class="source-code">    // Navigation</pre>
			<pre class="source-code">    document.querySelectorAll('.nav__link--</pre>
			<pre class="source-code">        page').forEach(link =&gt; {</pre>
			<pre class="source-code">        link.removeEventListener('click', </pre>
			<pre class="source-code">            handleClickNavigation, false);</pre>
			<pre class="source-code">        link.addEventListener('click', </pre>
			<pre class="source-code">            handleClickNavigation, false);</pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">// Event when a new message is received by WebSockets</pre>
			<pre class="source-code">myWebSocket.addEventListener("message", (event) =&gt; {</pre>
			<pre class="source-code">    // Parse the data received</pre>
			<pre class="source-code">    const data = JSON.parse(event.data);</pre>
			<pre class="source-code">    // Renders the HTML received from the Consumer</pre>
			<pre class="source-code">    const selector = document.querySelector(data.selector);</pre>
			<pre class="source-code">    selector.innerHTML = data.html;</pre>
			<pre class="source-code">    /**</pre>
			<pre class="source-code">     * Reassigns the events of the newly rendered HTML</pre>
			<pre class="source-code">     */</pre>
			<pre class="source-code">    updateEvents();</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">/**</pre>
			<pre class="source-code">* Update events in every page</pre>
			<pre class="source-code">* return {void}</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">function updateEvents() {</pre>
			<pre class="source-code">    // Nav</pre>
			<pre class="source-code">    setEventsNavigation(myWebSocket);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    INITIALIZATION</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">updateEvents();</pre>
			<p>Now, we just need to add some CSS in <code>static/css/main.css</code> to change the color of the link for where we are:</p>
			<pre class="source-code">.nav__link.active {</pre>
			<pre class="source-code">    color: var(--color__active);</pre>
			<pre class="source-code">    text-decoration: none;</pre>
			<pre class="source-code">}</pre>
			<p>We can now <a id="_idIndexMarker307"/>switch between pages, although this is not reflected in the browser’s address bar.</p>
			<div><div><img src="img/Figure_6.04_B18321.jpg" alt="Figure 6.4 – Login page loaded with ability to navigate between Home and Signup dynamically&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Login page loaded with ability to navigate between Home and Signup dynamically</p>
			<p>We have built a<a id="_idIndexMarker308"/> website with the ability to navigate between pages, as well as integrating traditional rendering to feed content<a id="_idIndexMarker309"/> to <strong class="bold">search engine spiders</strong>. However, we do not give feedback to visitors. The next objective will be to display the hierarchy and/or name of the page in the URL.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor147"/>Changing URLs</h1>
			<p>We have <a id="_idIndexMarker310"/>managed to change pages and visually mark in the browser where we are, but the browser URL is still passive. We are going to add a mechanism to update the path every time we change pages.</p>
			<p>In JavaScript, we can use the History API to manipulate the address that the visitor sees in the browser. For example, if you wanted to show that you are at <code>/login/</code>, you would implement the following:</p>
			<pre class="source-code">history.pushState({}, '', '/login/')</pre>
			<p>What we will do is modify the event listener message by adding the line we just mentioned, together with a new parameter that will always send a <code>Consumer</code> class called <code>url</code>:</p>
			<pre class="source-code">// Event when a new message is received by WebSockets</pre>
			<pre class="source-code">myWebSocket.addEventListener("message", (event) =&gt; {</pre>
			<pre class="source-code">    // Parse the data received</pre>
			<pre class="source-code">    const data = JSON.parse(event.data);</pre>
			<pre class="source-code">    // Renders the HTML received from the Consumer</pre>
			<pre class="source-code">    const selector = document.querySelector(data.selector);</pre>
			<pre class="source-code">    selector.innerHTML = data.html;</pre>
			<pre class="source-code">    // Update URL</pre>
			<pre class="source-code">    history.pushState({}, '', data.url) // New line</pre>
			<pre class="source-code">    /**</pre>
			<pre class="source-code">     * Reassigns the events of the newly rendered HTML</pre>
			<pre class="source-code">     */</pre>
			<pre class="source-code">    updateEvents();</pre>
			<pre class="source-code">});</pre>
			<p>In <code>Consumer</code>, we will modify the <code>send_html</code> function to support the <code>url</code> parameter:</p>
			<pre class="source-code">def send_html(self, event):</pre>
			<pre class="source-code">        """Event: Send html to client"""</pre>
			<pre class="source-code">        data = {</pre>
			<pre class="source-code">            "selector": event["selector"],</pre>
			<pre class="source-code">            "html": event["html"],</pre>
			<pre class="source-code">            "url": event["url"] if "url" in event else "", # New line</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        self.send_json(data)</pre>
			<p>While in <code>actions.py</code>, we’ll modify <code>send_page</code> to send the route, but what is the route? Thanks<a id="_idIndexMarker311"/> to Django and <code>urls.py</code>, we can use <code>reverse</code>, which will return the full path:</p>
			<pre class="source-code">from django.urls import reverse</pre>
			<pre class="source-code">def send_page(self, page):</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">        self.send_html({</pre>
			<pre class="source-code">        "selector": "#main",</pre>
			<pre class="source-code">        "html": render_to_string(f "pages/{page}. html", </pre>
			<pre class="source-code">            context),</pre>
			<pre class="source-code">        "url": reverse(page),</pre>
			<pre class="source-code">    })</pre>
			<pre class="source-code">...</pre>
			<p>We can now visualize the routes when navigating.</p>
			<div><div><img src="img/Figure_6.05_B18321.jpg" alt="Figure 6.5 – Displaying the URL when browsing dynamically&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Displaying the URL when browsing dynamically</p>
			<p>We have a serious<a id="_idIndexMarker312"/> limitation though: we cannot add HTML blocks. We can only replace them. It is inefficient to render a whole page if we are only looking to add a new element to an existing list, for example. So, we are going to include a system that enables us to decide whether we are going to replace or add a piece of HTML to any available selector.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor148"/>Hydrating sections or components</h1>
			<p>Although we have a function that can dynamically include HTML rendered from a template and apply it to a tag present in the document, we cannot decide whether we want to replace or insert HTML, in other words, hydrate or replace the DOM.</p>
			<p><strong class="bold">Hydration</strong> is <a id="_idIndexMarker313"/>a technique in web development where client-side JavaScript converts a static HTML web page into a dynamic web page by attaching event handlers to the HTML elements. This allows for a<a id="_idIndexMarker314"/> fast <strong class="bold">First Contentful Paint</strong> (<strong class="bold">FCP</strong>) but there is a period of time afterward where the page appears to be fully loaded and interactive. However, it is not until the client-side JavaScript is executed and event handlers have been attached.</p>
			<p>To solve this <a id="_idIndexMarker315"/>problem, we will start by remembering that the <code>Consumer</code> class is<a id="_idIndexMarker316"/> prepared to receive the <code>append</code> instruction:</p>
			<pre class="source-code">    def send_html(self, event):</pre>
			<pre class="source-code">        """Event: Send html to client"""</pre>
			<pre class="source-code">        data = {</pre>
			<pre class="source-code">            "selector": event["selector"],</pre>
			<pre class="source-code">            "html": event["html"],</pre>
			<pre class="source-code">            "append": "append" in event and </pre>
			<pre class="source-code">                event["append"],</pre>
			<pre class="source-code">            "url": event["url"] if "url" in event else "",</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        self.send_json(data)</pre>
			<p>By default, <code>append</code> will be a <code>False</code> variable. But if the client sends us the <code>append</code> data and it is <code>True</code>, we will send what we want to add to the frontend and JavaScript will take care of the rest.</p>
			<p>We include the following in <code>static/js/index.js</code>, a conditional to control <code>append</code>:</p>
			<pre class="source-code">myWebSocket.addEventListener("message", (event) =&gt; {</pre>
			<pre class="source-code">    // Parse the data received</pre>
			<pre class="source-code">    const data = JSON.parse(event.data);</pre>
			<pre class="source-code">    // Renders the HTML received from the Consumer</pre>
			<pre class="source-code">    const selector = document.querySelector(data.selector);</pre>
			<pre class="source-code">    // If append is received, it will be appended. </pre>
			<pre class="source-code">     Otherwise the entire DOM will be replaced.</pre>
			<pre class="source-code">    if (data.append) {</pre>
			<pre class="source-code">        selector.innerHTML += data.html;</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">        selector.innerHTML = data.html;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    // Update URL</pre>
			<pre class="source-code">    history.pushState({}, '', data.url)</pre>
			<pre class="source-code">    /**</pre>
			<pre class="source-code">     * Reassigns the events of the newly rendered HTML</pre>
			<pre class="source-code">     */</pre>
			<pre class="source-code">    updateEvents();</pre>
			<pre class="source-code">});</pre>
			<p>To check that it works, we are going to add a list of <strong class="bold">Laps</strong> to the <strong class="bold">Home</strong> page. A Lap<a id="_idIndexMarker317"/> is a unit of time that is stored inside a stopwatch as a history of recorded periods of time. For example, if it were a Formula 1 race, you could visualize how long each car took to complete a lap just by looking at the recorded lap time.</p>
			<p>Each time a button <a id="_idIndexMarker318"/>is pressed, a new item with the current time will be <a id="_idIndexMarker319"/>added:</p>
			<ol>
				<li value="1">We edit the <code>Home</code> template hosted in <code>app/app_template/templates/pages/home.html</code>. We include a button and an unordered list:<pre>&lt;section&gt;
    &lt;h2&gt;Laps&lt;/h2&gt;
    &lt;p&gt;
        &lt;button id="add-lap"&gt;Add lap&lt;/button&gt;
    &lt;/p&gt;
    &lt;ul id="laps"&gt;&lt;/ul&gt;
&lt;/section&gt;</pre></li>
				<li>In JavaScript, hosted<a id="_idIndexMarker320"/> in the example in <code>static/js/index.js</code>, we <a id="_idIndexMarker321"/>incorporate the event into the button. It will just send an action without any data:<pre>/**
* Send new Lap
* @param {Event} event
* @return {void}
*/
function addLap(event) {
    sendData({
        action: 'Add lap',
        data: {}
    }, myWebSocket);
}
/**
* Update events in every page
* return {void}
*/
function updateEvents() {
    // Nav
    setEventsNavigation(myWebSocket);
    // Add lap
    const addLapButton = document.querySelector('#add-
        lap');
    if (addLapButton !== null) {
        addLapButton.removeEventListener('click', 
            addLap, false);
        addLapButton.addEventListener('click', addLap, false);
    }
}</pre></li>
				<li>In the <code>Consumer</code> class, in the <code>app/app_template/consumers.py</code> path, we capture<a id="_idIndexMarker322"/> the action and<a id="_idIndexMarker323"/> call a future <code>add_lap</code> function:<pre>    def receive_json(self, data_received):
        """
            Event when data is received
            All information will arrive in 2 variables:
            "action", with the action to be taken
            "data" with the information
        """
        # Get the data
        data = data_received["data"]
        # Depending on the action we will do one task or another.
        match data_received["action"]:
            case "Change page":
                actions.send_page(self, data["page"])
            case "Add lap":
                actions.add_lap(self)</pre></li>
				<li>In <code>actions</code>, located in <code>app/app_template/actions.py</code>, we include the function we called <code>add_lap</code> in the previous point. We include in the <code>#laps</code> selector the HTML fragment rendered in the <code>_laps.html</code> template, which is created from a <a id="_idIndexMarker324"/>variable <a id="_idIndexMarker325"/>called <code>time</code>, with the current time:<pre>def add_lap(self):
    """Add lap to Home page"""
    # Send current time to client
    self.send_html({
        "selector": "#laps",
        "html": render_to_string
            ("components/_lap.html", 
                {"time": datetime.now()}),
        "append: True,
    })</pre></li>
				<li>Finally, we build the <code>app/app_template/templates/components/_lap.html</code> component:<pre>&lt;li&gt;{{ time|date: "h:i:s" }}&lt;/li&gt;</pre></li>
			</ol>
			<p>And that’s it. We test how we can update the list over time by pressing the <strong class="bold">Add lap</strong> button in <strong class="bold">Home</strong>.</p>
			<div><div><img src="img/Figure_6.06_B18321.jpg" alt="Figure 6.6 – Adding HTML snippets to preserve the previous content in an unordered list that records the time when the button was clicked&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Adding HTML snippets to preserve the previous content in an unordered list that records the time when the button was clicked</p>
			<p>We have <a id="_idIndexMarker326"/>improved the <a id="_idIndexMarker327"/>HTML rendering system to be more selective and efficient. We can now decide when we want to add or replace a DOM.</p>
			<p>If you change the page and go back to <strong class="bold">Home</strong>, you will find that all the times have been deleted. To avoid this problem, we could save times in the database, or we can find an optimal solution by creating a temporary session for the user.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor149"/>Creating temporary sessions for clients</h1>
			<p>To have <a id="_idIndexMarker328"/>unique sessions for each client, we will need to<a id="_idIndexMarker329"/> activate middleware that enables this feature. Channels provides us with <code>SessionMiddlewareStack</code> or <code>AuthMiddlewareStack</code>, which also include tools to build login or logout functionality. We will use <code>AuthMiddlewareStack</code> whenever we can.</p>
			<p>We edit <code>project_template/asgi.py</code> as follows:</p>
			<pre class="source-code">import django</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">os.environ.setdefault("DJANGO_SETTINGS_MODULE", "project_template.settings")</pre>
			<pre class="source-code">from django.conf import settings</pre>
			<pre class="source-code">django.setup()</pre>
			<pre class="source-code">from django.core.asgi import get_asgi_application</pre>
			<pre class="source-code">from channels.auth import AuthMiddlewareStack</pre>
			<pre class="source-code">from channels.routing import ProtocolTypeRouter, URLRouter</pre>
			<pre class="source-code">from django.urls import re_path</pre>
			<pre class="source-code">from app.app_template.consumers import ExampleConsumer</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">application = ProtocolTypeRouter(</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        # Django's ASGI application to handle traditional HTTP requests</pre>
			<pre class="source-code">        "http": get_asgi_application(),</pre>
			<pre class="source-code">        # WebSocket handler</pre>
			<pre class="source-code">        "websocket": AuthMiddlewareStack(</pre>
			<pre class="source-code">            URLRouter(</pre>
			<pre class="source-code">                [</pre>
			<pre class="source-code">                    re_path(r"^ws/example/$", ExampleConsumer.as_asgi()),   </pre>
			<pre class="source-code">    }</pre>
			<p>We can now <a id="_idIndexMarker330"/>create sessions within the <code>Consumer</code> class with<a id="_idIndexMarker331"/> the following:</p>
			<pre class="source-code">self.scope["session"]["my name"] = "value".</pre>
			<pre class="source-code">self.scope["session"]. save()</pre>
			<p>Getting it will be the same as reading from any Python dictionary:</p>
			<pre class="source-code">print(self.scope["session"]["my name"])</pre>
			<pre class="source-code"># value</pre>
			<p>To exemplify<a id="_idIndexMarker332"/> its potential, we will create a classic to-do app on the home page. Even if we change pages, all the tasks that we left pending are always present when we come back, just like in real life. See the following:</p>
			<ol>
				<li value="1">At the end of the <code>home</code> template, we include an <code>&lt;input&gt;</code> to add the text of the task, a button to trigger the action, and the list where it will be displayed:<pre>&lt;section&gt;
    &lt;h2&gt;TODO&lt;/h2&gt;
    &lt;input type="text" id="task"&gt;
    &lt;button id="add-task"&gt; Add task&lt;/button&gt;
    &lt;ul id="todo"&gt;{% include "components/_tasks.html" with tasks=tasks %}&lt;/ul&gt;
&lt;/section&gt;</pre></li>
				<li>We will need a component that lists all the tasks. Therefore, in <code>app/app_template/templates/components/_tasks.html</code>, we include the following code:<pre>{% for task in tasks %}
    {% include "components/_task-item.html" with task=task %}
{% endfor %}</pre></li>
				<li>Inside the previous component, we use another component to render the item. We declare <code>app/app_template/templates/components/_task-item.html</code> with a <code>&lt;li&gt;</code> and the name of the task:<pre>&lt;li&gt;{{ task }}&lt;/li&gt;</pre></li>
				<li>In the <code>Consumer</code> class, when a user connects, we create a session called <code>tasks</code> with<a id="_idIndexMarker333"/> an empty list that we can fill in. On <a id="_idIndexMarker334"/>the other hand, we capture the action received from the frontend called "<code>Add task</code>" and call the <code>add_task</code> function in <code>actions.py</code>:<pre>import app.app_template.actions as actions
class ExampleConsumer(JsonWebsocketConsumer):
 
    def connect(self):
        """Event when client connects"""
        # Accept the connection
        self.accept()
        # Make session task list
        if "tasks" not in self.scope["session"]:
            self.scope["session"]["tasks"] = []
            self.scope["session"].save()
def receive_json(self, data_received):
        # Get the data
        data = data_received["data"]
        # Depending on the action we will do one task or another.
        match data_received["action"]:
 # Other actions
            case "Add task":
                actions.add_task(self, data)</pre></li>
				<li>In <code>actions.py</code>, we declare the <code>add_task</code> function, which will add the task to the session, but <a id="_idIndexMarker335"/>we will also create <code>context</code> for <code>home</code> with <a id="_idIndexMarker336"/>the <code>session</code> variable:<pre>from .forms import LoginForm, SignupForm
from asgiref.sync import async_to_sync
from django.template.loader import render_to_string
from django.urls import reverse
from channels.auth import login, logout
from django.contrib.auth.models import User
from django.contrib.auth import authenticate
from datetime import datetime
 
 
def send_page(self, page):
    """Render HTML and send page to client"""
 
    # Prepare context data for page
    context = {}
    match page:
        case "home":
            context = {"tasks": self.scope["session"]
                ["tasks"] if "tasks" in self.scope
                    ["session"] else []}
        case "login":
            context = {"form": LoginForm()}
        case "signup":
            context = {"form": SignupForm()}
...
   
def add_lap(self):
    "Add lap to Home page"""""
    # Send current time to client
    self.send_html({
        "selector": "#laps",
        "html": render_to_string
            ("components/_lap.html", {"time": 
                datetime.now()}),
        "append: True,
    })
 
def add_task(self, data):
    "Add task from TODO section"""""
    # Update task list
    self.send_html({
        "selector": "#all",
        "html": render_to_string("components/_task-
            item.html", {"task": data["task"]}),
        "append: True,
    })
    # Add task to list
    self.scope["session"]["tasks"].append(data["task"])
    self.scope["session"].save()</pre></li>
				<li>Finally, in<a id="_idIndexMarker337"/> JavaScript, we add a <code>click</code> event <a id="_idIndexMarker338"/>to the button to send the text with the task to the <code>Consumer</code> class:<pre>/**
* Send new task to TODO list
* @param event
* @return {void}
*/
function addTask(event) {
    const task = document.querySelector('#task');
    sendData({
        action: 'Add task',
        data: {
            task: task.value
        }
    }, myWebSocket);
    // Clear input
    task.value = '';
}
/**
* Update events in every page
* return {void}
*/
function updateEvents() {
    // Nav
    setEventsNavigation(myWebSocket);
...
    // Add task
    const addTaskButton = document.querySelector
        ('#add-task');
    if (addTaskButton !== null) {
        addTaskButton.removeEventListener('click', 
            addTask, false);
        addTaskButton.addEventListener('click', 
            addTask, false);
    }
}</pre></li>
			</ol>
			<p>We must update<a id="_idIndexMarker339"/> if new DOM elements have <a id="_idIndexMarker340"/>appeared. Otherwise, the events will stop working if the previous HTML has been deleted. The steps to follow are to stop listening to the previous events if they exist, and add the new ones. If we don’t do this, the events will be lost or duplicated.</p>
			<p>The event to be executed is simple. We capture the <code>#task</code> field and send the <code>Consumer</code> class the text of the task.</p>
			<div><div><img src="img/Figure_6.07_B18321.jpg" alt="Figure 6.7 – Displaying a list of tasks from a session&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Displaying a list of tasks from a session</p>
			<p>We are already able to work with sessions and even create HTML from their content. Now, we just need to implement some security measures to prevent CSRF exploits.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor150"/>Avoiding cross-site request forgery (CSRF) with WebSockets</h1>
			<p>By using sessions, we<a id="_idIndexMarker341"/> are exposing users<a id="_idIndexMarker342"/> to a CSRF attack unless we put appropriate measures in place.</p>
			<p class="callout-heading">CSRF attacks</p>
			<p class="callout">CSRF attacks are malicious attacks on a website in which unauthorized commands are sent from one user to a second site with hidden forms, AJAX requests, or any other method in a hidden way. </p>
			<p class="callout">You can find a reference here: <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">https://en.wikipedia.org/wiki/Cross-site_request_forgery</a>.</p>
			<p>Channels <a id="_idIndexMarker343"/>provides a tool that will <a id="_idIndexMarker344"/>help us to avoid this type of attack in a simple way:</p>
			<ol>
				<li value="1">We define the allowed Hosts in <code>project_template/settings.py</code>. In our case, we are using environment variables inside Docker:<pre>ALLOWED_HOSTS = os.environ.get("ALLOWED_HOSTS"). split(",")</pre></li>
				<li>We edit <code>project_template/asgi.py</code>, by importing <code>OriginValidator</code>. We must pass two parameters: <code>URLRouter</code> (or any intermediary middleware) and the <code>Hosts</code> we want to protect:<pre># project_template/asgi.py
import django
 
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "project_template.settings")
from django.conf import settings
django.setup()
from django.core.asgi import get_asgi_application
from channels.security.websocket import OriginValidator # New line
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from django.urls import re_path
from app.app_template.consumers import ExampleConsumer
 
 
application = ProtocolTypeRouter(
    {
        # Django's ASGI application to handle traditional HTTP requests
        "http": get_asgi_application(),
        # WebSocket handler
        # Update
        "websocket": OriginValidator
            (AuthMiddlewareStack(
            URLRouter(
                [
                    re_path(r"^ws/example/$", 
                        ExampleConsumer.as_asgi()),
                
            
        ), settings.ALLOWED_HOSTS)
    }</pre></li>
			</ol>
			<p>As this <a id="_idIndexMarker345"/>functionality is so quick to<a id="_idIndexMarker346"/> implement, it is highly recommended that it always be part of our future projects or integrated into the template that we use as a base.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor151"/>Summary</h1>
			<p>In this chapter, we have added some very interesting new capabilities to our project: switching between pages, creating server-side rendering versions of each path, creating a dynamic page, modifying URLs, updating specific sections, working with sessions, and avoiding CSRF with WebSockets. </p>
			<p>We now already have the basic skills to build a dynamic site with database access, group management, partial or full HTML rendering, event control that triggers backend actions, form creation, and some security measures. One question may be echoing in your head: was it worth all the effort? Just think that we can now create SPAs with minimal use of JavaScript, we don’t need to build an API to connect the frontend and the backend, and the time between requests and their responses is ridiculously low, avoiding the use of loading in many cases. The complexity of the projects also has decreased and we can avoid the installation of several frontend libraries. Judge for yourself. The most amazing thing is that we have only used Django and Channels; the potential we can achieve by adding other Python extensions is infinite.</p>
			<p>In the next chapter, <a href="B18321_07_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 7</em></a>, <em class="italic">Creating a Real-Time Blog Using Only Django</em>, we will put all the pieces together to exemplify a real case that we can use for our own project or an external one.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>