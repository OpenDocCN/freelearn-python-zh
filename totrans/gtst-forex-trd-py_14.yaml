- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where to Go Now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the previous chapter sounded like the end of the book, I thought it
    would be unfair to leave you without giving some guidelines regarding further
    development of your knowledge and skills in FX markets and creating trading algorithms
    (algo). Unlike previous chapters, where each chapter was dedicated to a single
    large topic, this one is a collection of short stories about different aspects
    of FX algo trading, aiming to provide you with starting points for further research.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering any complex subject requires effort and trading is probably the most
    time- and labor-consuming activity, which requires a very special attitude combining
    the mindsets of a scientist and a businessman. Any successful trading strategy
    or algorithm is a result of many hours of work, of which only 10-20% is spent
    on actual coding, debugging, and refactoring; the majority of time is always spent
    on studying the markets, in search of trading ideas and endless trial-and-error
    proofs of concept. This chapter will give you hints both on finding your own edge
    in the market and making your trading apps more robust.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that we are all perpetual students of the market, and you will
    keep learning as long as you are in this complex yet exciting business of algo
    trading.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing limit and stop orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The correct way to calculate the number of trades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From trading ideas to implementation – another sample strategy using limit and
    stop orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Money management and handling multiple entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting strategy performance – more metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More about the risks specific to algo trading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classical technical trading setups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization – the blessing and the curse of algo trading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing limit and stop orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171), *Types of Orders and Their
    Simulation in Python*, we considered three main types of orders: market, limit,
    and stop. However, so far, we have only used market orders in actual codes. Although
    we noted that a live trading application may not ever use stop and limit orders
    because they can be emulated on the client side and sent to the market as market
    orders when necessary, it would be definitely useful to have both types of orders
    implemented in the backtester to simplify the development of trading strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s quickly recall the essence of limit and stop orders.
  prefs: []
  type: TYPE_NORMAL
- en: A **limit order** is always executed at a price equal to the order price *or
    better*. This means that if the market price is currently 100 and a buy limit
    order is sent below the market, for example, at 99, then it will be filled only
    when the price becomes 99 *or lower*. If a buy limit order is sent above the market,
    for example, at 101, then it will be executed immediately and its price will work
    as a cap for possible adverse price increase during the order execution.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a **stop order** is always executed at a price equal to the order
    price *or worse*. Using the same example, if a buy stop order is sent below the
    market, then it is executed immediately, and if it is sent above the market, then
    it will be executed only when the market price reaches the order level. When executing
    a stop order, there is no limit on how the price may grow during the execution.
  prefs: []
  type: TYPE_NORMAL
- en: With sell orders, the situation is symmetrical.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we emulate the execution of limit and stop orders using tick data, we
    can always check whether a certain tick satisfies the order condition and then
    assume it as the price at which the order was executed. However, when we work
    with compressed data, for example, 1 minute, 1 hour, 1 day, and so on, we have
    no idea at which tick the order would be actually executed. Instead, we assume
    that if the bar’s high or low crosses the order level, then the order is supposed
    to be filled. *Table 14.1* summarizes all the possible fill conditions for limit
    and stop orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** **of order** | **Side** | **Fill condition** | **Fill price** |'
  prefs: []
  type: TYPE_TB
- en: '| Limit | Buy | Bar’s low < order price | Minimum of the order price and the
    bar’s open |'
  prefs: []
  type: TYPE_TB
- en: '| Limit | Sell | Bar’s high > order price | Maximum of the order price and
    the bar’s open |'
  prefs: []
  type: TYPE_TB
- en: '| Stop | Buy | Bar’s high > order price | Maximum of the order price and the
    bar’s open |'
  prefs: []
  type: TYPE_TB
- en: '| Stop | Sell | Bar’s low < order price | Minimum of the order price and the
    bar’s open |'
  prefs: []
  type: TYPE_TB
- en: Table 14.1 – Conditions to trigger limit and stop orders and their assumed execution
    price
  prefs: []
  type: TYPE_NORMAL
- en: You can see that when backtesting using compressed data, the price at which
    we assume the order was executed is not necessarily equal to the order price.
    In some cases, it can be that the bar’s open. Why?
  prefs: []
  type: TYPE_NORMAL
- en: To answer this question, we should recall that the market price is not continuous,
    and sometimes adjacent ticks have quite a significant difference in prices between
    them. In a bar chart, it can be seen as an *empty space* between the bar’s closed
    and the next bar’s open. These empty spaces are called **gaps**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, gaps on bar charts in FX markets can be seen between the close of
    the market on Friday and its re-opening on late Sunday. Normally, these gaps are
    not very large, but sometimes they may be quite dramatic, especially if there
    was some important economic or political news during the weekend. The following
    graph illustrates a weekend gap for USD/JPY on February 6, 2023:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Weekend gap in USD/JPY (chart by Multicharts)](img/B19145_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Weekend gap in USD/JPY (chart by Multicharts)
  prefs: []
  type: TYPE_NORMAL
- en: The market closed on Friday, February 3, 2023, at **131.141** and opened on
    Monday, February 6, 2023, at **132.194**. The difference between these prices
    is shown by the gray arrow. It is more than 100 pips, which is comparable to the
    average daily price movement. If on Friday’s close we sent a stop order to buy
    at, say, 131.50, then in reality, this order would have been executed only at
    132.194 (and in reality, most likely even worse because of slippage during an
    illiquid time after the open of the market). If we sold on Friday’s close, even
    if we protected our position with a stop loss – which is in fact just a stop order
    – well... we could only hope that the position size was small enough not to ruin
    the trading account with one huge loss.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, we now can see why we always check whether the order price is beyond
    the open price of the bar and why we suggest calculating the actual execution
    price as per the **Fill price** column in *Table 14.1*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how we can realistically emulate limit and stop orders,
    let’s proceed to coding. We will be working with the backtester code that we developed
    in [*Chapter 11*](B19145_11.xhtml#_idTextAnchor186), *Backtesting and Theoretical
    Performance*, and we are going to modify the `emulateBrokerExecution()` function
    because the order execution is isolated in it (remember the ideology of keeping
    the code logic modular? Now, we start to really benefit from this approach).
  prefs: []
  type: TYPE_NORMAL
- en: 'Presently the `emulateBrokerExecution()` function contains an implementation
    only of market orders. Let’s add the following block of code directly below it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I hope the code is transparent enough to see that it just implements the logic
    outlined in *Table 14.1*.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to emulate issues with execution, which are typical for limit orders,
    then you may want to replace `<=` with `<` and `>=` with `>` in the code, which
    check whether the bar’s price matches the order price. In this case, you assume
    that the limit order had a guaranteed fill (see [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    *Types of Orders and Their Simulation* *in Python*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add a very similar block to simulate the execution of stop orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code is absolutely symmetrical to that of limit order simulation.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to emulate slippage, which is typical for stop orders, then you
    may want to add or subtract a small amount from the executed price. Normally,
    if we trade liquid markets such as EUR/USD and send orders from 7 am until 9:50
    p.m. GMT, we may not add or subtract anything. If we trade less liquid currency
    pairs, such as AUD/USD, then a slippage of 0.00001 to 0.00005 pips looks reasonable.
    If you are into more unusual pairs, such as TRY/MXN, then check the order book
    (if your broker provides such a pair at all!) See again [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    *Types of Orders and Their Simulation in Python*, for details on stop orders and
    slippage.
  prefs: []
  type: TYPE_NORMAL
- en: Note an important difference between the way we treat market, limit, or stop
    orders. A market order’s status is set to `Executed` immediately as soon as the
    order is received by the `emulateBrokerExecution()` function, but the status of
    a limit or a stop order is first set to `Submitted`. The `Submitted` status is
    assigned because once generated, these orders should remain in the orders queue
    either until they are executed or canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added two new types of orders, we should check whether we did
    everything correctly. As we did in [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171)
    to test the execution of market orders, we will use the same source data file,
    which contains 1-minute bars of EUR/USD. We are only going to read the first 20
    bars and execute one limit and one stop order to make sure that they are simulated
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do any testing, let’s open the source data file in any text editor,
    copy the first 21 lines, and paste them into an Excel spreadsheet. Then, we will
    build a chart using the **Financial** chart type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Test chart using the first 20 bars from the EUR/USD source
    data file](img/B19145_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Test chart using the first 20 bars from the EUR/USD source data
    file
  prefs: []
  type: TYPE_NORMAL
- en: The price data starts from about **1.1295** and falls below **1.1290** on the
    fourth bar. Great, let’s place a buy limit order at **1.1290**. Then, we can see
    that the price starts growing, but eventually falls below **1.1285**, so let’s
    place a sell stop order at this level – thus emulating a stop-loss (remember that
    a stop-loss protects an open position from excessive losses and is always placed
    on the side opposite to the position, so in our example, it will be a sell stop).
    This stop order should be executed on the 11th bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s get to coding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, in the `getBar()` function, we set the maximum number of bars to be
    read from the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we implement the *strategy* logic so it produces only two orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we now try to run the backtest, it will produce no output because we do
    not process an order status of `processOrders()` function yet. The logic of this
    processing is quite simple: if the order status is **Submitted**, we should return
    it to the orders queue.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we should be very careful with returning orders to the queue. Don’t
    forget that the `processOrders()` function uses an internal infinite loop, which
    retrieves orders from the queue and finishes working only when there is no order
    left. If we return submitted orders back to the queue inside the same infinite
    loop, we will never get out of it.
  prefs: []
  type: TYPE_NORMAL
- en: Again, there are different solutions to this problem, and maybe you will suggest
    a better one, but let’s use the most straightforward approach for now. Let’s add
    temporary storage where we will store orders that were processed but not executed,
    and then put them back in the orders queue after all orders have been processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the `self.orders_buffer = []` temporary storage to the
    constructor of the `tradingSystemMetadata` class. Then, let’s add the following
    code below the `if order[''Status''] == ''Executed'':` logical block in the `processOrders()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the submitted order to the buffer. And finally, we will rewrite
    the `except:` clause as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that if there are no more orders in the orders queue, it raises
    an exception, so we can safely return all submitted orders temporarily accumulated
    in the buffer back to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the backtest and look at the resulting equity curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Equity curve](img/B19145_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Equity curve
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the buy limit order indeed was executed on the 4th bar (remember
    that we count from zero), then the equity started to grow, then it dropped, and,
    finally, the sell stop order was executed on the 11th bar. In the console, we
    can check the information about the number of trades and the average trade value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But wait a moment! There’s something wrong with it now. According to the price
    levels at which the orders were executed, the distance between the entry and the
    exit should be exactly 5 pips, but the average trade is -2.7 pips, which is even
    not an integer value. What happened? To answer this question, we should revise
    the way we calculate the number of trades.
  prefs: []
  type: TYPE_NORMAL
- en: The correct way to calculate the number of trades
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we were working with the trend-following strategy in [*Chapter 12*](B19145_12.xhtml#_idTextAnchor203),
    *Sample Strategy – Trend-Following*, we only opened new positions, and each opening
    closed the previously open one. This is normal for always-in-the-market strategies.
    In this case, indeed, the number of trades coincides with the number of executed
    orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example with a limit and a stop order, we use two orders to actually
    perform just one trade: buying and then exiting the market with a profit or loss.
    Therefore, we should only use the amount of entry orders to calculate the average
    trade. How can we distinguish between opening and closing orders?'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways of doing that. One of the possible options would be
    adding another key to the order with values of `Entry` or `Exit`, but we will
    use a different approach: we will add a new attribute to the `tradingSystemMetadata`
    class, which will hold the actual number of trades, and we will update it only
    when the market position after the order execution is not zero, that is, the last
    executed order was not a closing order:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s add `self.number_of_trades = 0` to the constructor of the `tradingSystemMetadata`
    class. This is where we’re going to save the number of trades.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to modify the way we count trades. The right place to do it is
    when we update the market position in the `processOrders()` function. Presently,
    we use code that only updates the market position and does not check whether the
    market position is zero or not after the execution of the last order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’re going to replace this piece of code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see that this code checks whether the market position changed to non-zero
    after the trade and only in this case increases the number of trades. Thus, if
    the last order only closed the position without opening a new one, it won’t be
    taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing to fix now is at the very end of the code, where we print the
    number of trades and calculate the average trade:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we now re-run the backtest, we will see the correct output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Almost there! The number of trades is correct, but strangely there are 0.4 extra
    pips in the average trade value – and according to the levels we specified in
    the strategy logic, the average trade should be exactly -5 pips, not -5.4\. Where
    does the difference come from?
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer this question, we should once again critically revise the `processOrders()`
    function. When we developed it to process only market orders generated at the
    end of a bar, we placed the following three lines before the `while True` loop,
    which processes the orders queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Therefore, recalculating the equity based on the bar’s closing price is the
    first thing the function does before orders start processing. If we only use market
    orders, that’s fine, we update the `System.last_price` value when we process the
    order and it will always coincide with the bar’s close. However, now that an order
    can be executed anywhere between the bar’s low and the bar’s high, we have an
    extra amount of `processOrders()` function with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move the block of three lines that update the equity from the top of the
    code (before the `while True` loop) to the end (after the `while True` loop).
    See the `Stop and limit orders.py` code and the `processOrders()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After `if order[''Status''] == ''Executed''`, let’s add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This way, we update the equity value by multiplying the price difference between
    the previous bar’s close (which is stored in `System.last_price` at the moment
    of execution of this line) and the price at which the order was executed by the
    market position, *which existed before the order was executed*. Then, at the end
    of the `processOrders()` function, the equity is updated once again, this time
    by calculating the difference between the order price and the bar’s close, *multiplied
    by the new market position*. This gives us a perfectly precise calculation of
    the strategy equity and, consequently, the value of the average trade.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I intentionally have not published the entire code of the modified backtester
    here in this book. My goal now is to train you in the mental process of discovering
    new shortcomings and suggesting solutions. After you’re done with all modifications,
    I recommend downloading my code from GitHub and comparing it – this will give
    you an excellent opportunity to improve your skills in upgrading code logic, which
    is the most important and sensitive part of the entire development in algo trading.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the final code now, we will get absolutely precise values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have mastered limit and stop orders, let me give you several hints
    regarding further development of both backtesting and live trading applications.
  prefs: []
  type: TYPE_NORMAL
- en: From trading ideas to implementation – another sample strategy using limit and
    stop orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s consider a practical application of the limit and stop orders that we
    have just implemented. I like using this example because it illustrates the importance
    of having a trading idea before writing the code and shows that trading ideas
    do not have to be complex. In practice, the simpler the trading idea, the greater
    the chance that it will work in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may remember from [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044), *FX
    Market Overview from a Developer’s Standpoint*, most FX markets undergo a bank
    settlement procedure, which happens at 5 p.m. New York time. The price at the
    settlement is very important because it’s used to evaluate many other financial
    instruments and is used for settlement in all cash trades between any parties.
    So, comparing an intraday price to the last settlement price may give us an idea
    about the overall sentiment in this market: if it’s greater than the last settlement
    price, then the sentiment is positive – if it’s lower, the sentiment is negative.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we may want to suppose that if the overall market sentiment is positive,
    then we can try opening a long position, and if it’s negative, a short position.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have to decide when we may want to do so. Naturally, it should be the
    time of the next settlement because, during the day, external factors such as
    news breaking can move the price up and down many times. However, remember that
    it’s impossible to send an order at exactly 5 p.m. because at that time, the market
    is closed and the order will be rejected. Besides that, several minutes before
    the settlement, the liquidity becomes thinner and thinner, so it may be problematic
    to trade, say, 1 minute before the settlement even with a small trading size.
    So, we will try entering the market 10 minutes before the settlement time.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we have to decide how long we stay in the market, or at which price
    we liquidate our positions. Let’s not be greedy and just exit with a small profit
    of 5 pips. We will use limit orders to exit the position at a certain distance
    from the entry price – such an order is frequently referred to as a **profit target**.
    However, if the market develops the opposite way, we should liquidate our position
    with a loss, so we will use a stop order for this purpose. The question is at
    which level we place this stop order.
  prefs: []
  type: TYPE_NORMAL
- en: There are many opposite opinions on this subject. Many authors believe that
    stops should always be smaller than potential profits because otherwise, it looks
    like you risk more than you can potentially win. Others argue that not only the
    size of the win and loss matter but their probabilities are also important. Indeed,
    we can win a game even if the average loss is 2 times the average win if the percentage
    of wins is greater than 67%.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the luxury of quickly testing both approaches: let’s first try setting
    the stop-loss amount the same as the profit target and then increase it to stay
    at the position for a longer time in the hope that sooner or later, it will reach
    our profit target level.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we build a market model again, as we did in [*Chapter 11*](B19145_11.xhtml#_idTextAnchor186),
    but this time, the model doesn’t aim to explain the entire price time series.
    Instead, this model describes only quite a short-term market process, which may
    take place in the market at regular intervals. Generally speaking, we can even
    model the entire price series this way if we find a sufficient amount of regularly
    appearing market processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to summarize, the trading algorithm should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: At 5 p.m. NY time, we save the close price as the reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At 4:50 p.m. NY time the next day, we compare the price to the reference. If
    the difference is positive, we buy. If the difference is negative, we sell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set a profit target of 5 pips and a stop loss of 5 pips.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We stay in the market until either the profit target or the stop-loss is hit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is that all?
  prefs: []
  type: TYPE_NORMAL
- en: No. We have to cancel the other order in the *profit target – stop-loss* pair
    when either of them is executed. Otherwise, the remaining order may be triggered
    when the market position is flat (zero), and it will open an unexpected and unwanted
    position that we’ll be unable to manage. Orders whose execution depends on the
    execution of other orders are called **contingent orders**.
  prefs: []
  type: TYPE_NORMAL
- en: Contingent orders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The backtesting and live trading codes developed in this book assume that any
    order is sent to the broker and then is never modified. However, sometimes you
    want to change something in an order that has already been submitted but not executed
    yet. For example, you sent a stop-loss order, but the market conditions changed
    and you now want to increase or decrease the order price.
  prefs: []
  type: TYPE_NORMAL
- en: Our codes don’t support this functionality, and not all brokers support it either.
    If you want to implement it, the easiest way to do so is to add a unique identifier
    to each order, and then refer to it in the orders queue when modification is necessary.
    First, you have to remove the old order from the queue and then issue a new order.
    This will provide compatibility with virtually any broker because this is the
    preferred way of modifying orders on the broker’s side.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to implement a universal order management solution that requires
    the introduction of order IDs and appropriate order handling methods for now,
    as it is outside the scope of this book. We will add a small piece of code to
    the `processOrders()` function that clears the entire orders queue as soon as
    a limit or a stop order is executed. This way, we can effectively implement contingent
    profit targets and stop-loss orders.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The suggested workaround only works if we have jsut one pair of contingent orders.
    If you want to implement a more sophisticated strategy that utilizes multiple
    contingent orders, there is no other way of doing it than adding order IDs and
    implementing routines that handle orders individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement our simple workaround, let’s add the following code to the `processOrders()`
    function at the end of the `if order[''Status''] == ''Executed'':` branch, right
    after `System.last_price =` `order[''Executed Price'']`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The idea of this code is that if any of the contingent orders have been executed
    (and remember, we add this to the processing of the **Executed** order status),
    then we cancel all other orders. Let me repeat once again that this workaround
    only works if we have just one pair of contingent orders in the orders queue and
    no other order is in there.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that we now have to do is add the strategy logic. As always, we only modify
    the code between the `trade logic starts here` and `trade logic ends here` comments.
    The code is very simplistic and implements the four-step logic just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We check whether the price is greater or less than the reference price, open
    a position with a market order, and immediately send a limit order to take a profit
    and a stop order to exit with a loss.
  prefs: []
  type: TYPE_NORMAL
- en: I am not going to consider the entire strategy code here because most of it
    has remained the same as developed in [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    and the modifications that introduced limit and stop orders were considered earlier
    in this chapter (see the *Implementing limit and stop orders* section). You can
    download the code from GitHub, analyze the changes made, and run it to make sure
    you get the correct results.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code using EUR/USD 1-minute bars as the source data, we will
    get an equity curve like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Equity curve of a strategy with tight stops](img/B19145_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Equity curve of a strategy with tight stops
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also get the following basic performance metrics: 1,464 total trades
    with an average trade of about -0.12 pips.'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the strategy doesn’t work, and we even don’t have to go through an
    in-depth analysis of its performance. So, the idea of putting stops at the same
    distance as profit targets doesn’t work. What if we now set the stop at 50 pips
    instead of 5 and run the code again?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following graph, you can see that now the result is dramatically different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Equity curve of a strategy with wider stops](img/B19145_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Equity curve of a strategy with wider stops
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have 1,428 trades and an average trade of 1.18 pips.
  prefs: []
  type: TYPE_NORMAL
- en: Is this strategy tradable?
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to understand whether the average trade can cover all
    trading costs. The instrument traded here, the euro versus the US dollar, is by
    far the most liquid in the FX market and thus normally at the time of the entry,
    spreads are about 0.00001-0.00002 pips, with at least 100,000 to 500,000 at top
    of the order book (depending on the trading venue). So, we shouldn’t suffer from
    slippage if we keep the trading size reasonable, and at first glance, it seems
    like we can actually trade this strategy.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to follow all steps considered in [*Chapter 13*](B19145_13.xhtml#_idTextAnchor215),
    *To Trade or Not to Trade – Performance Analysis,* and make your final decision
    about this strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to take into consideration overnight swaps. See how they affect
    the strategy performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, regardless of whether this strategy is tradable or not, let me emphasize
    once again the importance of a trading idea behind the code. Trading ideas do
    not come out of the blue: they are all based on various factors specific to a
    particular market. I’d even go further and say that *trading ideas are always
    based on factors that distinguish the market from a random process* in a mathematical
    sense. That’s why we have spent so much time on market fundamentals in this book,
    and I hope you will be able to find many other trading ideas amid the massive
    heap of facts that we have considered.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been working only with strategies that open new positions only
    either when the market position is zero or to reverse the currently open position.
    In this case, the edge of the strategy logic is in its ability to properly time
    entries and exits. However, there is a whole class of strategies that achieve
    an edge in managing multiple positions open in the same direction. In this case,
    we say that a strategy has an edge in terms of *money management*.
  prefs: []
  type: TYPE_NORMAL
- en: Money management and multiple entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To give you an idea about what money management is and how it may affect strategy
    performance, let me tell you about probably the most famous – or infamous – kind
    of money management technique, known as **martingale**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The origin of martingale is in gambling. Imagine the simplest gambling game
    of a coin toss. You toss the coin and if it comes up heads, you win; if it comes
    up tails, you lose. We can use `1` for wins and `-1` for losses and the series
    of tosses can be represented by a sequence as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you put at stake an equal amount of money each time you toss the coin, we
    can multiply the sequence by that amount and write it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, `b` refers to the size of the bet. Obviously, your total win in the game
    is the sum of the entire series. In an idealistic model, the results of each toss
    are independent of each other, and the probability of the coin coming up as heads
    or tails is strictly 50%. Therefore in the long term, the sum of the series will
    always be around zero and there is no chance to win this game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sum of this series is indeed zero. However, things change dramatically
    if you start using money management in form of a martingale. After each new loss,
    you double your stake, and after each new win, you reset the bet size to its initial
    value. Then, the sequence of wins and losses transforms into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It’s clear that now the sum of the sequence is very far from zero; in our example,
    it is 5b. This means that by using money management, it is possible to win a game
    with outcomes of equal probability.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, the martingale looks like the ultimate method to win any game,
    but there are two pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method may work only in a game whose outcomes are truly independent. In
    the theory of probability, processes of this kind are called **stochastic** (see
    [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101), *Basics of Fundamental Analysis
    and Its Possible Use in FX Trading*). Financial time series are frequently considered
    in academic research to be stochastic, at least at the tick level, but we already
    know that there are certain moments and even relatively long periods when this
    is not true: for example, after the release of important economic news, it’s clear
    that upticks or downticks will prevail for some time, depending on the resonance
    of the news (see again [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101), *Basics
    of Fundamental Analysis and Its Possible Use in* *FX Trading*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with a *pure* random walk process, the equal probability of outcomes is
    achieved only in long term (to be absolutely precise, only in an infinitely long
    series). If we analyze a short-term subsequence of outcomes, we may see a series
    of identical outcomes, and no one can guarantee that such a series will definitely
    end at a certain outcome number – exactly because the probability of a new outcome
    does not depend on previous outcomes! If you start with just $100 and double your
    stake with each loss, then you have to put ![](img/Formula_B19145_14_001.png)
    on the table after the n-th loss in a series. After the 3rd loss, you will have
    to bet $800, after the 4th loss, $1,600, and so on, and if you are so unlucky
    to face a series of 10 losses in a row, then you should call your bank and ask
    them to provide you with a credit line because now you have to bet $102,400!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope you understand why the martingale is so popular in books for illustrative
    purposes but *highly not recommended* for practical use.
  prefs: []
  type: TYPE_NORMAL
- en: In trading, there is a modification of the martingale known as **averaging down**.
    Let’s suppose that we opened a long position, but the market price went down.
    Instead of liquidating the position or just waiting until the price returns to
    the initial level, we open long new positions, increasing the trading size and
    moving the average entry price down. For example, if we originally opened a long
    position of 1 contract at 100.00 and then added another 1 contract at 90.00, then
    we actually have a position of 2 contracts opened at 95.00.
  prefs: []
  type: TYPE_NORMAL
- en: Both the martingale and averaging may have only limited uses and normally, traders
    who use them in any form apply some restrictions to the maximum size of the open
    position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like many other authors, I used the martingale and averaging down for illustrative
    purposes: only because they give a very clear idea of what money management is
    about. There are more conservative money management strategies, and some of them
    are quite sophisticated. If you are interested in learning more about money management
    strategies and looking for a single source, I’d recommend the ultimate guide written
    by the money management guru Van Tharp, *Definitive Guide to Position Sizing Strategies*.
    If you have a more academic interest in the subject or are more inclined to collect
    information from various sources, I’d recommend starting with understanding the
    stochastic processes in general ([https://en.wikipedia.org/wiki/Stochastic_process](https://en.wikipedia.org/wiki/Stochastic_process))
    and random walks in particular ([https://en.wikipedia.org/wiki/Random_walk](https://en.wikipedia.org/wiki/Random_walk)),
    and then referring to a book by Ralph Vince, *The Mathematics of Money Management:
    Risk Analysis Techniques for* *Traders* ([https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387](https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387)).'
  prefs: []
  type: TYPE_NORMAL
- en: To work with money management strategies, you should be very careful with the
    order size. Presently, we have worked only with strategies that open a position
    with a fixed size and then close it before opening a new one. If you increase
    the position by using multiple orders in the same direction, you should carefully
    calculate the order size when you try to liquidate a position. If you make a mistake,
    the strategy will leave one or more positions open, and this may highly adversely
    impact the strategy’s performance. So, generally, the order handling methods mentioned
    in this chapter are required for the correct implementation of money management
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: I would be happy to continue our discussions about the FX markets, systematic,
    and algo trading at the same level of detail as before, but unfortunately, the
    book’s size is limited, so I will just give you general guidelines on a few more
    important subjects for your own further studies. They are presented here as separate
    topics, without any evident logical connection between them.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy performance revisited – more metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 13*](B19145_13.xhtml#_idTextAnchor215), *To Trade or Not to Trade
    – Performance Analysis*, we considered only the very basic performance metrics.
    Of course, there are many others that are no less important. I recommend starting
    with the nice overview from *Quantinsti* ([https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/](https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/)),
    implementing each metric in the code, and then you can analyze your strategies
    as market professionals do.
  prefs: []
  type: TYPE_NORMAL
- en: More about the risks specific to algo trading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already considered the main risks in any trading: operational, systemic,
    and transactional. Let’s highlight another kind of risk that is specific to algo
    trading.'
  prefs: []
  type: TYPE_NORMAL
- en: When you develop and backtest a strategy using compressed data, along with limit
    or stop orders, there is a risk that more than one of these orders will be simulated
    on the same bar. Typically, this happens when the order prices are too close to
    each other and the data resolution is not granular enough. For example, if you
    place a limit and a stop order at a distance of 5 pips from each other and run
    a backtest using daily data, then on most days, both orders should be executed
    during a single bar. This is what you want to avoid at all costs because the backtester
    has no idea about how the price has actually moved inside this single bar and
    therefore no one knows which of the two orders will have been triggered first
    and which next. So, it is extremely important to correctly choose the data resolution
    so that the backtesting results are realistic.
  prefs: []
  type: TYPE_NORMAL
- en: The rule of thumb for choosing the data resolution
  prefs: []
  type: TYPE_NORMAL
- en: Always choose the data resolution for which the average range of a bar (the
    difference between a bar’s high and low values) is less than the distance between
    order prices. If you place limit or stop orders of 100+ pips, then you can use
    daily data. If you use limit or stop orders of 20+ pips, then most likely, a timeframe
    of 30 minutes may work. If you use tight stops or limits, as in the previous example,
    then a 1-minute resolution is the way to go. Remember that only testing using
    tick data can give you the ultimately correct picture, although this kind of backtest
    will take a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Classical technical trading setups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 7*](B19145_07.xhtml#_idTextAnchor114), *Technical Analysis and
    Its Implementation in Python*, we considered a number of classical technical analysis
    indicators, such as the RSI, a stochastic oscillator, moving averages, and Bollinger
    bands. We saw that each of these indicators is able to bring into focus a certain
    property of the price time series: for example, Bollinger bands are a volatility
    indicator, and moving averages are digital filters that remove higher frequencies
    from the price data. However, we didn’t consider any classical trading setup with
    any of these indicators. Why?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question is twofold. First, these setups can be found in
    literally any book or internet publication about technical analysis. You can start
    with an overview of technical indicators at Investopedia ([https://www.investopedia.com/terms/t/technicalindicator.asp](https://www.investopedia.com/terms/t/technicalindicator.asp))
    and then follow the links to articles on specific indicators to see how they are
    supposed to be used to generate trading signals.
  prefs: []
  type: TYPE_NORMAL
- en: The second and more important reason we don’t go into detail on these classical
    setups here is that none of them can create a profitable trading strategy as they
    are. You can try building a simple strategy by implementing any of the classical
    setups, then run it in multiple markets using different data resolutions, and
    you will see that unfortunately, none of the combinations deliver anything that
    could be considered satisfactory performance.
  prefs: []
  type: TYPE_NORMAL
- en: Why does this happen? And does it mean that technical analysis indicators are
    useless for practical trading?
  prefs: []
  type: TYPE_NORMAL
- en: This happens because all of the classical indicators were developed to highlight
    specific processes that took place in specific markets at a specific time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Welles Wilder, the creator of the RSI, developed this indicator
    when he traded commodity futures back in the 1970s. At that time, the market was
    relatively illiquid and was open for only a few hours a day. Only select traders
    had access to it and trades were placed either in the pit or by phone – and this
    is what commodity futures markets used to be in the 1970s. On the contrary, the
    present-day FX market is open 24/7 and is full of liquidity, with many diverse
    kinds of market participants, from big banks to retail traders. Its computerized
    ordering can process thousands of transactions per second. Compare these two markets
    and you will understand why the indicators of the old days may not indicate what
    they are supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the second question – whether classical technical indicators are
    useless these days – is negative. We still can use any or all of these indicators
    *if we understand what exactly they show us*. That’s why I tried to focus on their
    meaning rather than just listing the well-known use cases, such as moving averages
    crossover (see [https://www.investopedia.com/terms/c/crossover.asp](https://www.investopedia.com/terms/c/crossover.asp))
    or overbought/oversold zones identified with the RSI or a stochastic oscillator
    (see [https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp](https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp)).
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, despite the present-day electronic FX markets being very different
    from good old pit-traded futures markets, I would highly recommend reading the
    classic books written by the creators of technical indicators – because, in these
    books, they explain *why they suggested* a particular indicator, *which market
    process* they tried to identify using an indicator, and *how we are supposed to
    profit* from the suggested setups.
  prefs: []
  type: TYPE_NORMAL
- en: Spending a couple of days on thorough reading may be way more valuable than
    wasting weeks and months trying to fit a particular well-known technical trading
    setup to a market that it simply doesn’t fit by nature. I can recommend starting
    with a classic by Welles Wilder Jr., *New Concepts in Technical Trading Systems*,
    in which he carefully explains *how he noticed certain potentially profitable
    market processes*, *how he tried to formalize them*, *how he eventually came to
    a set of technical indicators*, and *how he actually used them to make profits*.
    Focus on this *mental process*, not just the numbers, and you will develop a way
    better understanding of the process of developing a trading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that behind any formula and any code, there should stand a trading
    idea, and trading ideas can be found only in the analysis of markets, not in crunching
    numbers or fitting an irrelevant model to the market. In the next section, we
    will see why excessive fitting may not only be counterproductive but also dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization – the blessing and the curse of algo trading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you remember how the performance of a simple overnight strategy that we created
    earlier in this chapter radically changed when we replaced a tight stop of 5 pips
    with a wider stop of 50 pips?
  prefs: []
  type: TYPE_NORMAL
- en: 'But this fact raises another important question: why 5 and 50 pips? Why not
    6 and 45? Or 10 and 76?'
  prefs: []
  type: TYPE_NORMAL
- en: Any quantitative strategy depends on the values of its parameters, and the procedure
    of finding the best combination of parameters that delivers the best results of
    the backtesting is called **optimization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimization is a massive topic. I’d even say it’s overwhelmingly vast and
    complex. At first glance, it looks straightforward: let’s find the best combination
    of parameter values and then run the strategy live with these very values. However,
    the problem is that we always test and optimize our strategies using past data.
    And I hope you already understood and remember well that markets are anything
    but stationary processes. This means that the price behavior may change in the
    future, and the same strategy with the same *best* combination of parameters will
    start losing money.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A situation in which a strategy has been optimized using insufficient data or
    inappropriate logic and then starts losing money in live trading is known as **overfitting**
    or **curve fitting**. This is considered to be the plague of all algo trading
    and the reason why many discretionary traders are still skeptical about it.
  prefs: []
  type: TYPE_NORMAL
- en: How to mitigate this specific risk?
  prefs: []
  type: TYPE_NORMAL
- en: There are various workarounds, **forward testing** probably being the most popular.
    When running a forward test, we first optimize the strategy parameters using only
    a subset of the entire past market data and then generate the performance report
    for backtesting, run on another subset of data. For example, if we have data from
    2015 to 2023, then we may want to optimize the strategy using data from 2015 to
    2017 and then test using data from 2018 to 2023\. The backtest using the first
    subset is then called **in-sample** and the backtest using the second subset is
    called **out-of-sample**. If the out-of-sample strategy demonstrates performance
    comparable to that of the in-sample, we can estimate that it will continue working
    even in the future (although in reality, things may be far more complex).
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to make a forward test only on a relatively small amount
    of out-of-sample data, then re-optimize the strategy using newer data, and repeat
    the forward test on another, newer portion of out-of-sample data, and so on. In
    our example, we can perform a forward test optimizing the strategy using data
    from 2015 to 2017, then run a forward test on 2018 only, then re-optimize the
    strategy using data from 2016 to 2018, run a forward test on 2019, and so on.
    Such an approach is called **walk-forward optimization**.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have already realized, optimization is an extremely resource- and
    time-consuming process. Indeed, we need to run a backtest with one set of parameter
    values, then save the result, modify the parameters, run a backtest again, and
    repeat. In our sample strategy, if we wanted to find the best values for the stop-loss
    and profit target between 5 and 50 pips with a step of 5 pips, it would require
    100 runs of the entire backtest, which would take hours on most computers. That’s
    why optimization algorithms are mostly developed using compiled versions of Python,
    such as Cython or Numba.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in developing a true understanding of optimization, I’d
    recommend starting with the concise yet nice introduction by Davide Scassola at
    *Triality* ([https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies](https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies))
    and then reading Robert Pardo’s book, *The Evaluation and Optimization of Trading*
    *Strategies* ([https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011](https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011)).
  prefs: []
  type: TYPE_NORMAL
- en: Final words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, any story comes to an end sooner or later, and this book is no exception.
    Even if you opened it with no idea about FX markets and algo trading, now you
    have definitely taken yourself to a new level. You have knowledge about FX markets
    comparable to that of a beginner professional desk trader. You know how to develop
    trading applications for both live trading and producing reliable backtests. You
    also know the risks pertaining to trading, for algo trading in particular. You
    have plenty of roads to go down — in terms of money management, performance analysis,
    and optimization – but there is one thing I really want you to always remember
    whatever you do:'
  prefs: []
  type: TYPE_NORMAL
- en: Any good trading strategy always has a trading idea behind it. No sophisticated
    mathematics, no money management, and no optimization will help if the strategy
    is just a randomly chosen combination of technical analysis studies and parameters.
    Look for ideas in the market and use the mathematical and programming apparatus
    to implement, test, and run them – without fear or greed.
  prefs: []
  type: TYPE_NORMAL
