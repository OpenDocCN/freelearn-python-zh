- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Where to Go Now?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在去哪里？
- en: Although the previous chapter sounded like the end of the book, I thought it
    would be unfair to leave you without giving some guidelines regarding further
    development of your knowledge and skills in FX markets and creating trading algorithms
    (algo). Unlike previous chapters, where each chapter was dedicated to a single
    large topic, this one is a collection of short stories about different aspects
    of FX algo trading, aiming to provide you with starting points for further research.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上一章听起来像是书的结尾，但我认为不给你一些关于进一步发展你在外汇市场和创建交易算法（算法）的知识和技能的指导是不公平的。与之前的章节不同，其中每一章都专注于一个大型主题，这一章是关于外汇算法交易不同方面的短篇故事集，旨在为你提供进一步研究的起点。
- en: Mastering any complex subject requires effort and trading is probably the most
    time- and labor-consuming activity, which requires a very special attitude combining
    the mindsets of a scientist and a businessman. Any successful trading strategy
    or algorithm is a result of many hours of work, of which only 10-20% is spent
    on actual coding, debugging, and refactoring; the majority of time is always spent
    on studying the markets, in search of trading ideas and endless trial-and-error
    proofs of concept. This chapter will give you hints both on finding your own edge
    in the market and making your trading apps more robust.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握任何复杂主题都需要努力，而交易可能是耗时和劳动密集型活动，它需要结合科学家和商人的心态的非常特殊的态度。任何成功的交易策略或算法都是许多小时工作的结果，其中只有10-20%的时间用于实际的编码、调试和重构；大部分时间总是花在研究市场上，寻找交易想法和无数试验和错误的证明概念。本章将给你提示，如何在市场上找到自己的优势，并使你的交易应用更加健壮。
- en: Don’t forget that we are all perpetual students of the market, and you will
    keep learning as long as you are in this complex yet exciting business of algo
    trading.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，我们都是市场的终身学生，只要你在算法交易这个复杂而激动人心的行业中，你将不断学习。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Implementing limit and stop orders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施限价单和止损单
- en: The correct way to calculate the number of trades
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算交易次数的正确方法
- en: From trading ideas to implementation – another sample strategy using limit and
    stop orders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从交易想法到实施——使用限价单和止损单的另一个示例策略
- en: Money management and handling multiple entries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资金管理和处理多个入场
- en: Revisiting strategy performance – more metrics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视策略表现——更多指标
- en: More about the risks specific to algo trading
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于算法交易特定风险的更多内容
- en: Classical technical trading setups
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典的技术交易设置
- en: Optimization – the blessing and the curse of algo trading
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化——算法交易的祝福与诅咒
- en: Implementing limit and stop orders
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施限价单和止损单
- en: 'In [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171), *Types of Orders and Their
    Simulation in Python*, we considered three main types of orders: market, limit,
    and stop. However, so far, we have only used market orders in actual codes. Although
    we noted that a live trading application may not ever use stop and limit orders
    because they can be emulated on the client side and sent to the market as market
    orders when necessary, it would be definitely useful to have both types of orders
    implemented in the backtester to simplify the development of trading strategies.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B19145_10.xhtml#_idTextAnchor171)“在Python中考虑订单类型及其模拟”中，我们考虑了三种主要的订单类型：市价单、限价单和止损单。然而，到目前为止，我们只在实际代码中使用了市价单。虽然我们指出，实际交易应用可能永远不会使用止损单和限价单，因为它们可以在客户端模拟，并在必要时作为市价单发送到市场，但在回测器中实现这两种类型的订单肯定是有用的，以简化交易策略的开发。
- en: Let’s quickly recall the essence of limit and stop orders.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下限价单和止损单的精髓。
- en: A **limit order** is always executed at a price equal to the order price *or
    better*. This means that if the market price is currently 100 and a buy limit
    order is sent below the market, for example, at 99, then it will be filled only
    when the price becomes 99 *or lower*. If a buy limit order is sent above the market,
    for example, at 101, then it will be executed immediately and its price will work
    as a cap for possible adverse price increase during the order execution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**限价单**总是以等于订单价格或更好的价格执行。这意味着如果市场价格目前是100，并且发送了一个低于市场的买入限价单，例如，在99，那么它只有在价格变为99或更低时才会被填充。如果发送了一个高于市场的买入限价单，例如，在101，那么它将立即执行，其价格将作为订单执行期间可能出现的价格上涨的限制。'
- en: Similarly, a **stop order** is always executed at a price equal to the order
    price *or worse*. Using the same example, if a buy stop order is sent below the
    market, then it is executed immediately, and if it is sent above the market, then
    it will be executed only when the market price reaches the order level. When executing
    a stop order, there is no limit on how the price may grow during the execution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，**停损单**总是以等于订单价格或更差的价格执行。使用相同的例子，如果发送一个低于市场的买入停损单，那么它将立即执行；如果发送一个高于市场的停损单，那么它将只在市场价格达到订单水平时执行。在执行停损单时，对价格在执行过程中的增长没有限制。
- en: With sell orders, the situation is symmetrical.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于卖出订单，情况是对称的。
- en: 'When we emulate the execution of limit and stop orders using tick data, we
    can always check whether a certain tick satisfies the order condition and then
    assume it as the price at which the order was executed. However, when we work
    with compressed data, for example, 1 minute, 1 hour, 1 day, and so on, we have
    no idea at which tick the order would be actually executed. Instead, we assume
    that if the bar’s high or low crosses the order level, then the order is supposed
    to be filled. *Table 14.1* summarizes all the possible fill conditions for limit
    and stop orders:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用tick数据模拟执行限价单和停损单时，我们总能检查某个tick是否满足订单条件，然后假设它为执行订单的价格。然而，当我们处理压缩数据时，例如1分钟、1小时、1天等，我们不知道订单会在哪个tick实际执行。相反，我们假设如果K线的最高价或最低价穿过订单水平，那么订单应该被成交。*表14.1*总结了限价单和停损单所有可能的成交条件：
- en: '| **Type** **of order** | **Side** | **Fill condition** | **Fill price** |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **订单类型** | **方向** | **成交条件** | **成交价格** |'
- en: '| Limit | Buy | Bar’s low < order price | Minimum of the order price and the
    bar’s open |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 限价 | 买入 | K线最低价 < 订单价格 | 订单价格和K线开盘价的最小值 |'
- en: '| Limit | Sell | Bar’s high > order price | Maximum of the order price and
    the bar’s open |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 限价 | 卖出 | K线最高价 > 订单价格 | 订单价格和K线开盘价的最大值 |'
- en: '| Stop | Buy | Bar’s high > order price | Maximum of the order price and the
    bar’s open |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 停损 | 买入 | K线最高价 > 订单价格 | 订单价格和K线开盘价的最大值 |'
- en: '| Stop | Sell | Bar’s low < order price | Minimum of the order price and the
    bar’s open |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 停损 | 卖出 | K线最低价 < 订单价格 | 订单价格和K线开盘价的最小值 |'
- en: Table 14.1 – Conditions to trigger limit and stop orders and their assumed execution
    price
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1 – 触发限价单和停损单的条件及其假设执行价格
- en: You can see that when backtesting using compressed data, the price at which
    we assume the order was executed is not necessarily equal to the order price.
    In some cases, it can be that the bar’s open. Why?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当使用压缩数据进行回测时，我们假设订单执行的价格并不一定等于订单价格。在某些情况下，它可能是K线的开盘价。为什么？
- en: To answer this question, we should recall that the market price is not continuous,
    and sometimes adjacent ticks have quite a significant difference in prices between
    them. In a bar chart, it can be seen as an *empty space* between the bar’s closed
    and the next bar’s open. These empty spaces are called **gaps**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，我们应该回想一下市场价格不是连续的，有时相邻的tick之间价格差异可能相当显著。在K线图中，这可以看作是K线收盘和下一根K线开盘之间的*空隙*。这些空隙被称为**缺口**。
- en: 'Typically, gaps on bar charts in FX markets can be seen between the close of
    the market on Friday and its re-opening on late Sunday. Normally, these gaps are
    not very large, but sometimes they may be quite dramatic, especially if there
    was some important economic or political news during the weekend. The following
    graph illustrates a weekend gap for USD/JPY on February 6, 2023:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，外汇市场的K线图在周五市场收盘和周日晚些时候重新开盘之间会有缺口。通常，这些缺口并不很大，但有时它们可能非常显著，尤其是在周末期间有重要的经济或政治新闻。以下图表展示了2023年2月6日USD/JPY的周末缺口：
- en: '![Figure 14.1 – Weekend gap in USD/JPY (chart by Multicharts)](img/B19145_14_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – USD/JPY的周末缺口（由Multicharts图表）](img/B19145_14_01.jpg)'
- en: Figure 14.1 – Weekend gap in USD/JPY (chart by Multicharts)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – USD/JPY的周末缺口（由Multicharts图表）
- en: The market closed on Friday, February 3, 2023, at **131.141** and opened on
    Monday, February 6, 2023, at **132.194**. The difference between these prices
    is shown by the gray arrow. It is more than 100 pips, which is comparable to the
    average daily price movement. If on Friday’s close we sent a stop order to buy
    at, say, 131.50, then in reality, this order would have been executed only at
    132.194 (and in reality, most likely even worse because of slippage during an
    illiquid time after the open of the market). If we sold on Friday’s close, even
    if we protected our position with a stop loss – which is in fact just a stop order
    – well... we could only hope that the position size was small enough not to ruin
    the trading account with one huge loss.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, we now can see why we always check whether the order price is beyond
    the open price of the bar and why we suggest calculating the actual execution
    price as per the **Fill price** column in *Table 14.1*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how we can realistically emulate limit and stop orders,
    let’s proceed to coding. We will be working with the backtester code that we developed
    in [*Chapter 11*](B19145_11.xhtml#_idTextAnchor186), *Backtesting and Theoretical
    Performance*, and we are going to modify the `emulateBrokerExecution()` function
    because the order execution is isolated in it (remember the ideology of keeping
    the code logic modular? Now, we start to really benefit from this approach).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Presently the `emulateBrokerExecution()` function contains an implementation
    only of market orders. Let’s add the following block of code directly below it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I hope the code is transparent enough to see that it just implements the logic
    outlined in *Table 14.1*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: If you want to emulate issues with execution, which are typical for limit orders,
    then you may want to replace `<=` with `<` and `>=` with `>` in the code, which
    check whether the bar’s price matches the order price. In this case, you assume
    that the limit order had a guaranteed fill (see [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    *Types of Orders and Their Simulation* *in Python*).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add a very similar block to simulate the execution of stop orders:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code is absolutely symmetrical to that of limit order simulation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: If you want to emulate slippage, which is typical for stop orders, then you
    may want to add or subtract a small amount from the executed price. Normally,
    if we trade liquid markets such as EUR/USD and send orders from 7 am until 9:50
    p.m. GMT, we may not add or subtract anything. If we trade less liquid currency
    pairs, such as AUD/USD, then a slippage of 0.00001 to 0.00005 pips looks reasonable.
    If you are into more unusual pairs, such as TRY/MXN, then check the order book
    (if your broker provides such a pair at all!) See again [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    *Types of Orders and Their Simulation in Python*, for details on stop orders and
    slippage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Note an important difference between the way we treat market, limit, or stop
    orders. A market order’s status is set to `Executed` immediately as soon as the
    order is received by the `emulateBrokerExecution()` function, but the status of
    a limit or a stop order is first set to `Submitted`. The `Submitted` status is
    assigned because once generated, these orders should remain in the orders queue
    either until they are executed or canceled.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added two new types of orders, we should check whether we did
    everything correctly. As we did in [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171)
    to test the execution of market orders, we will use the same source data file,
    which contains 1-minute bars of EUR/USD. We are only going to read the first 20
    bars and execute one limit and one stop order to make sure that they are simulated
    correctly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do any testing, let’s open the source data file in any text editor,
    copy the first 21 lines, and paste them into an Excel spreadsheet. Then, we will
    build a chart using the **Financial** chart type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Test chart using the first 20 bars from the EUR/USD source
    data file](img/B19145_14_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Test chart using the first 20 bars from the EUR/USD source data
    file
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The price data starts from about **1.1295** and falls below **1.1290** on the
    fourth bar. Great, let’s place a buy limit order at **1.1290**. Then, we can see
    that the price starts growing, but eventually falls below **1.1285**, so let’s
    place a sell stop order at this level – thus emulating a stop-loss (remember that
    a stop-loss protects an open position from excessive losses and is always placed
    on the side opposite to the position, so in our example, it will be a sell stop).
    This stop order should be executed on the 11th bar.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s get to coding:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, in the `getBar()` function, we set the maximum number of bars to be
    read from the file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we implement the *strategy* logic so it produces only two orders:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we now try to run the backtest, it will produce no output because we do
    not process an order status of `processOrders()` function yet. The logic of this
    processing is quite simple: if the order status is **Submitted**, we should return
    it to the orders queue.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: However, we should be very careful with returning orders to the queue. Don’t
    forget that the `processOrders()` function uses an internal infinite loop, which
    retrieves orders from the queue and finishes working only when there is no order
    left. If we return submitted orders back to the queue inside the same infinite
    loop, we will never get out of it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Again, there are different solutions to this problem, and maybe you will suggest
    a better one, but let’s use the most straightforward approach for now. Let’s add
    temporary storage where we will store orders that were processed but not executed,
    and then put them back in the orders queue after all orders have been processed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the `self.orders_buffer = []` temporary storage to the
    constructor of the `tradingSystemMetadata` class. Then, let’s add the following
    code below the `if order[''Status''] == ''Executed'':` logical block in the `processOrders()`
    function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`tradingSystemMetadata`类的构造函数中添加`self.orders_buffer = []`临时存储开始。然后，在`processOrders()`函数中`if
    order['Status'] == 'Executed':`逻辑块下方添加以下代码：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will add the submitted order to the buffer. And finally, we will rewrite
    the `except:` clause as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把提交的订单添加到缓冲区。最后，我们将重写`except:`子句如下：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The idea is that if there are no more orders in the orders queue, it raises
    an exception, so we can safely return all submitted orders temporarily accumulated
    in the buffer back to the queue.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是，如果没有更多的订单在订单队列中，它将引发一个异常，因此我们可以安全地将暂时积累在缓冲区中的所有提交的订单返回到队列中。
- en: 'Now, let’s run the backtest and look at the resulting equity curve:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行回测并查看产生的权益曲线：
- en: '![Figure 14.3 – Equity curve](img/B19145_14_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 权益曲线](img/B19145_14_03.jpg)'
- en: Figure 14.3 – Equity curve
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 权益曲线
- en: 'We can see that the buy limit order indeed was executed on the 4th bar (remember
    that we count from zero), then the equity started to grow, then it dropped, and,
    finally, the sell stop order was executed on the 11th bar. In the console, we
    can check the information about the number of trades and the average trade value:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，买入限价订单确实在第四个柱上执行（记住我们从零开始计数），然后权益开始增长，然后下降，最后在第十一根柱上执行了卖出止损订单。在控制台中，我们可以检查交易次数和平均交易价值的信息：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But wait a moment! There’s something wrong with it now. According to the price
    levels at which the orders were executed, the distance between the entry and the
    exit should be exactly 5 pips, but the average trade is -2.7 pips, which is even
    not an integer value. What happened? To answer this question, we should revise
    the way we calculate the number of trades.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！现在有些不对劲。根据执行订单的价格水平，入场和出场之间的距离应该是正好5个点，但平均交易是-2.7个点，甚至不是一个整数值。发生了什么？为了回答这个问题，我们应该修改我们计算交易次数的方式。
- en: The correct way to calculate the number of trades
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算交易次数的正确方法
- en: When we were working with the trend-following strategy in [*Chapter 12*](B19145_12.xhtml#_idTextAnchor203),
    *Sample Strategy – Trend-Following*, we only opened new positions, and each opening
    closed the previously open one. This is normal for always-in-the-market strategies.
    In this case, indeed, the number of trades coincides with the number of executed
    orders.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第12章*](B19145_12.xhtml#_idTextAnchor203)中处理趋势跟踪策略时，*示例策略 – 趋势跟踪*，我们只打开新的仓位，每次打开都会关闭之前打开的仓位。这对于始终在市场中的策略来说是正常的。在这种情况下，确实，交易次数与执行订单次数相匹配。
- en: 'In our example with a limit and a stop order, we use two orders to actually
    perform just one trade: buying and then exiting the market with a profit or loss.
    Therefore, we should only use the amount of entry orders to calculate the average
    trade. How can we distinguish between opening and closing orders?'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的限价和止损订单示例中，我们使用两个订单实际上只执行一笔交易：买入然后以盈利或亏损退出市场。因此，我们应该只使用入场订单的数量来计算平均交易。我们如何区分开仓和平仓订单？
- en: 'There are multiple ways of doing that. One of the possible options would be
    adding another key to the order with values of `Entry` or `Exit`, but we will
    use a different approach: we will add a new attribute to the `tradingSystemMetadata`
    class, which will hold the actual number of trades, and we will update it only
    when the market position after the order execution is not zero, that is, the last
    executed order was not a closing order:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以做到这一点。其中一种可能的选择是在订单顺序中添加另一个键，其值为`Entry`或`Exit`，但我们将采用不同的方法：我们将在`tradingSystemMetadata`类中添加一个新的属性，该属性将保存实际的交易次数，并且我们只会在订单执行后的市场位置不为零时更新它，也就是说，最后执行的订单不是一个平仓订单：
- en: First, let’s add `self.number_of_trades = 0` to the constructor of the `tradingSystemMetadata`
    class. This is where we’re going to save the number of trades.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在`tradingSystemMetadata`类的构造函数中添加`self.number_of_trades = 0`。这是我们保存交易次数的地方。
- en: 'Next, we need to modify the way we count trades. The right place to do it is
    when we update the market position in the `processOrders()` function. Presently,
    we use code that only updates the market position and does not check whether the
    market position is zero or not after the execution of the last order:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们计算交易的方式。正确的地方是在`processOrders()`函数中更新市场头寸时。目前，我们使用只更新市场头寸而不检查在执行最后一个订单后市场头寸是否为零的代码：
- en: '[PRE22]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we’re going to replace this piece of code with the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将用以下代码替换这段代码：
- en: '[PRE26]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see that this code checks whether the market position changed to non-zero
    after the trade and only in this case increases the number of trades. Thus, if
    the last order only closed the position without opening a new one, it won’t be
    taken into account.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这段代码检查交易后市场头寸是否变为非零，并且只有在这种情况下才会增加交易次数。因此，如果最后一个订单只是关闭了头寸而没有打开新的头寸，它将不会被考虑。
- en: 'The only thing to fix now is at the very end of the code, where we print the
    number of trades and calculate the average trade:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在唯一要修复的是代码的末尾，在那里我们打印交易次数并计算平均交易：
- en: '[PRE34]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we now re-run the backtest, we will see the correct output:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在重新运行回测，我们将看到正确的输出：
- en: '[PRE36]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Almost there! The number of trades is correct, but strangely there are 0.4 extra
    pips in the average trade value – and according to the levels we specified in
    the strategy logic, the average trade should be exactly -5 pips, not -5.4\. Where
    does the difference come from?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 差不多完成了！交易次数是正确的，但奇怪的是平均交易价值中多出了0.4个点——根据我们在策略逻辑中指定的水平，平均交易应该是正好-5个点，而不是-5.4个点。差异是从哪里来的？
- en: 'To answer this question, we should once again critically revise the `processOrders()`
    function. When we developed it to process only market orders generated at the
    end of a bar, we placed the following three lines before the `while True` loop,
    which processes the orders queue:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要回答这个问题，我们应该再次批判性地审查`processOrders()`函数。当我们开发它来处理仅在K线结束时生成的市价订单时，我们在`while True`循环之前放置了以下三行代码，该循环处理订单队列：
- en: '[PRE38]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Therefore, recalculating the equity based on the bar’s closing price is the
    first thing the function does before orders start processing. If we only use market
    orders, that’s fine, we update the `System.last_price` value when we process the
    order and it will always coincide with the bar’s close. However, now that an order
    can be executed anywhere between the bar’s low and the bar’s high, we have an
    extra amount of `processOrders()` function with the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在开始处理订单之前，函数首先根据K线的收盘价重新计算权益。如果我们只使用市价订单，那就没问题，我们在处理订单时更新`System.last_price`的值，它将始终与K线的收盘价一致。然而，现在订单可以在K线的低点和高点之间任何位置执行，所以我们有额外的`processOrders()`函数步骤如下：
- en: Let’s move the block of three lines that update the equity from the top of the
    code (before the `while True` loop) to the end (after the `while True` loop).
    See the `Stop and limit orders.py` code and the `processOrders()` function.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将更新权益的三行代码块从代码的顶部（在`while True`循环之前）移动到末尾（在`while True`循环之后）。参见`Stop and
    limit orders.py`代码和`processOrders()`函数。
- en: 'After `if order[''Status''] == ''Executed''`, let’s add the following line:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if order['Status'] == 'Executed'`之后，让我们添加以下行：
- en: '[PRE41]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This way, we update the equity value by multiplying the price difference between
    the previous bar’s close (which is stored in `System.last_price` at the moment
    of execution of this line) and the price at which the order was executed by the
    market position, *which existed before the order was executed*. Then, at the end
    of the `processOrders()` function, the equity is updated once again, this time
    by calculating the difference between the order price and the bar’s close, *multiplied
    by the new market position*. This gives us a perfectly precise calculation of
    the strategy equity and, consequently, the value of the average trade.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们通过将前一个K线的收盘价（在执行此行时存储在`System.last_price`中）与订单执行的价格之间的价格差异乘以市场头寸，*即订单执行之前存在的头寸*来更新权益值。然后，在`processOrders()`函数的末尾，权益再次更新，这次是通过计算订单价格与K线收盘价之间的差异，*乘以新的市场头寸*。这为我们提供了策略权益的完美精确计算，从而也提供了平均交易的价值。
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I intentionally have not published the entire code of the modified backtester
    here in this book. My goal now is to train you in the mental process of discovering
    new shortcomings and suggesting solutions. After you’re done with all modifications,
    I recommend downloading my code from GitHub and comparing it – this will give
    you an excellent opportunity to improve your skills in upgrading code logic, which
    is the most important and sensitive part of the entire development in algo trading.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意没有在这本书中发布修改后的回测代码的完整代码。我的目标现在是训练你在发现新的不足并提出解决方案的心理过程。在你完成所有修改后，我建议你从GitHub下载我的代码并与之比较——这将为你提供一个极好的机会来提高你在升级代码逻辑方面的技能，这是算法交易整个开发过程中最重要和最敏感的部分。
- en: 'If we run the final code now, we will get absolutely precise values:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在运行最终代码，我们将得到绝对精确的值：
- en: '[PRE42]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we have mastered limit and stop orders, let me give you several hints
    regarding further development of both backtesting and live trading applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了限价和止损订单，让我给你一些关于进一步开发回测和实盘交易应用的提示。
- en: From trading ideas to implementation – another sample strategy using limit and
    stop orders
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从交易想法到实施——使用限价和止损订单的另一个示例策略
- en: Let’s consider a practical application of the limit and stop orders that we
    have just implemented. I like using this example because it illustrates the importance
    of having a trading idea before writing the code and shows that trading ideas
    do not have to be complex. In practice, the simpler the trading idea, the greater
    the chance that it will work in production.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们刚刚实施的限价和止损订单的实际应用。我喜欢使用这个例子，因为它说明了在编写代码之前拥有交易想法的重要性，并表明交易想法不必复杂。在实践中，交易想法越简单，它在生产中成功的可能性就越大。
- en: 'As you may remember from [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044), *FX
    Market Overview from a Developer’s Standpoint*, most FX markets undergo a bank
    settlement procedure, which happens at 5 p.m. New York time. The price at the
    settlement is very important because it’s used to evaluate many other financial
    instruments and is used for settlement in all cash trades between any parties.
    So, comparing an intraday price to the last settlement price may give us an idea
    about the overall sentiment in this market: if it’s greater than the last settlement
    price, then the sentiment is positive – if it’s lower, the sentiment is negative.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[*第三章*](B19145_03.xhtml#_idTextAnchor044)《从开发者角度的FX市场概述》中可能记得，大多数外汇市场都经历一个银行结算程序，这个程序在纽约时间下午5点进行。结算时的价格非常重要，因为它被用来评估许多其他金融工具，并且用于任何双方之间的所有现金交易的结算。因此，将日内价格与最后结算价格进行比较，可以给我们这个市场的整体情绪提供一个想法：如果它大于最后结算价格，那么情绪是积极的——如果它低于，那么情绪是消极的。
- en: Next, we may want to suppose that if the overall market sentiment is positive,
    then we can try opening a long position, and if it’s negative, a short position.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可能想要假设，如果整体市场情绪是积极的，那么我们可以尝试开多仓，如果它是消极的，那么开空仓。
- en: Then, we have to decide when we may want to do so. Naturally, it should be the
    time of the next settlement because, during the day, external factors such as
    news breaking can move the price up and down many times. However, remember that
    it’s impossible to send an order at exactly 5 p.m. because at that time, the market
    is closed and the order will be rejected. Besides that, several minutes before
    the settlement, the liquidity becomes thinner and thinner, so it may be problematic
    to trade, say, 1 minute before the settlement even with a small trading size.
    So, we will try entering the market 10 minutes before the settlement time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须决定何时进行这样的操作。自然，这应该是下一次结算的时间，因为在一天中，外部因素如新闻的发布可能会使价格上下波动多次。然而，记住，在下午5点时发送订单是不可能的，因为那时市场已经关闭，订单将被拒绝。除此之外，在结算前几分钟，流动性变得越来越稀薄，所以在结算前1分钟进行交易，即使交易规模很小，也可能有问题。因此，我们将尝试在结算时间前10分钟进入市场。
- en: And finally, we have to decide how long we stay in the market, or at which price
    we liquidate our positions. Let’s not be greedy and just exit with a small profit
    of 5 pips. We will use limit orders to exit the position at a certain distance
    from the entry price – such an order is frequently referred to as a **profit target**.
    However, if the market develops the opposite way, we should liquidate our position
    with a loss, so we will use a stop order for this purpose. The question is at
    which level we place this stop order.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须决定我们在市场中的停留时间，或者在我们以哪个价格平仓头寸。让我们不要贪婪，只以5点的微小利润退出。我们将使用限价订单在入场价格的一定距离处退出头寸——这样的订单通常被称为**盈利目标**。然而，如果市场向相反方向发展，我们将以亏损平仓头寸，因此我们将使用止损订单来完成这个目的。问题是我们在哪个水平放置这个止损订单。
- en: There are many opposite opinions on this subject. Many authors believe that
    stops should always be smaller than potential profits because otherwise, it looks
    like you risk more than you can potentially win. Others argue that not only the
    size of the win and loss matter but their probabilities are also important. Indeed,
    we can win a game even if the average loss is 2 times the average win if the percentage
    of wins is greater than 67%.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个问题，有很多不同的观点。许多作者认为，止损应该始终小于潜在利润，否则，看起来你冒的风险比你可能赢得的要多。其他人则认为，不仅赢和输的大小很重要，它们的概率也很重要。事实上，如果我们赢的百分比大于67%，即使平均损失是平均赢利的2倍，我们仍然可以赢得比赛。
- en: 'We have the luxury of quickly testing both approaches: let’s first try setting
    the stop-loss amount the same as the profit target and then increase it to stay
    at the position for a longer time in the hope that sooner or later, it will reach
    our profit target level.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有快速测试这两种方法的奢侈：让我们首先尝试将止损金额设定与盈利目标相同，然后增加它以保持头寸更长时间，希望迟早会达到我们的盈利目标水平。
- en: As you can see, we build a market model again, as we did in [*Chapter 11*](B19145_11.xhtml#_idTextAnchor186),
    but this time, the model doesn’t aim to explain the entire price time series.
    Instead, this model describes only quite a short-term market process, which may
    take place in the market at regular intervals. Generally speaking, we can even
    model the entire price series this way if we find a sufficient amount of regularly
    appearing market processes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们再次构建市场模型，就像我们在[*第11章*](B19145_11.xhtml#_idTextAnchor186)中所做的那样，但这次，模型的目标不是解释整个价格时间序列。相反，这个模型只描述了相当短期的市场过程，这种过程可能会在市场上定期发生。一般来说，如果我们找到足够数量的定期出现的市场过程，我们甚至可以用这种方式模拟整个价格序列。
- en: 'So, to summarize, the trading algorithm should be as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，交易算法应该是这样的：
- en: At 5 p.m. NY time, we save the close price as the reference.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下午5点纽约时间，我们将收盘价作为参考。
- en: At 4:50 p.m. NY time the next day, we compare the price to the reference. If
    the difference is positive, we buy. If the difference is negative, we sell.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二天下午4:50纽约时间，我们将价格与参考价进行比较。如果差异为正，则买入。如果差异为负，则卖出。
- en: We set a profit target of 5 pips and a stop loss of 5 pips.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设定盈利目标为5点，止损为5点。
- en: We stay in the market until either the profit target or the stop-loss is hit.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在市场中的停留时间，直到盈利目标或止损被触及。
- en: Is that all?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了吗？
- en: No. We have to cancel the other order in the *profit target – stop-loss* pair
    when either of them is executed. Otherwise, the remaining order may be triggered
    when the market position is flat (zero), and it will open an unexpected and unwanted
    position that we’ll be unable to manage. Orders whose execution depends on the
    execution of other orders are called **contingent orders**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不。当其中任何一个订单被执行时，我们必须取消*盈利目标-止损*对中的另一个订单。否则，当市场位置为平仓（零）时，剩余的订单可能会被触发，这将打开一个意外且不希望出现的头寸，我们将无法管理。依赖于其他订单执行的订单被称为**权限订单**。
- en: Contingent orders
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限订单
- en: The backtesting and live trading codes developed in this book assume that any
    order is sent to the broker and then is never modified. However, sometimes you
    want to change something in an order that has already been submitted but not executed
    yet. For example, you sent a stop-loss order, but the market conditions changed
    and you now want to increase or decrease the order price.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本书开发的后测试和实时交易代码假设任何订单都发送给经纪人，然后永远不会修改。然而，有时你想要修改已经提交但尚未执行的订单中的某些内容。例如，你发送了一个止损订单，但市场条件发生了变化，你现在想要增加或减少订单价格。
- en: Our codes don’t support this functionality, and not all brokers support it either.
    If you want to implement it, the easiest way to do so is to add a unique identifier
    to each order, and then refer to it in the orders queue when modification is necessary.
    First, you have to remove the old order from the queue and then issue a new order.
    This will provide compatibility with virtually any broker because this is the
    preferred way of modifying orders on the broker’s side.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to implement a universal order management solution that requires
    the introduction of order IDs and appropriate order handling methods for now,
    as it is outside the scope of this book. We will add a small piece of code to
    the `processOrders()` function that clears the entire orders queue as soon as
    a limit or a stop order is executed. This way, we can effectively implement contingent
    profit targets and stop-loss orders.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The suggested workaround only works if we have jsut one pair of contingent orders.
    If you want to implement a more sophisticated strategy that utilizes multiple
    contingent orders, there is no other way of doing it than adding order IDs and
    implementing routines that handle orders individually.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement our simple workaround, let’s add the following code to the `processOrders()`
    function at the end of the `if order[''Status''] == ''Executed'':` branch, right
    after `System.last_price =` `order[''Executed Price'']`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The idea of this code is that if any of the contingent orders have been executed
    (and remember, we add this to the processing of the **Executed** order status),
    then we cancel all other orders. Let me repeat once again that this workaround
    only works if we have just one pair of contingent orders in the orders queue and
    no other order is in there.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'All that we now have to do is add the strategy logic. As always, we only modify
    the code between the `trade logic starts here` and `trade logic ends here` comments.
    The code is very simplistic and implements the four-step logic just described:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We check whether the price is greater or less than the reference price, open
    a position with a market order, and immediately send a limit order to take a profit
    and a stop order to exit with a loss.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: I am not going to consider the entire strategy code here because most of it
    has remained the same as developed in [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    and the modifications that introduced limit and stop orders were considered earlier
    in this chapter (see the *Implementing limit and stop orders* section). You can
    download the code from GitHub, analyze the changes made, and run it to make sure
    you get the correct results.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code using EUR/USD 1-minute bars as the source data, we will
    get an equity curve like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Equity curve of a strategy with tight stops](img/B19145_14_04.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Equity curve of a strategy with tight stops
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also get the following basic performance metrics: 1,464 total trades
    with an average trade of about -0.12 pips.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the strategy doesn’t work, and we even don’t have to go through an
    in-depth analysis of its performance. So, the idea of putting stops at the same
    distance as profit targets doesn’t work. What if we now set the stop at 50 pips
    instead of 5 and run the code again?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following graph, you can see that now the result is dramatically different:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Equity curve of a strategy with wider stops](img/B19145_14_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Equity curve of a strategy with wider stops
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have 1,428 trades and an average trade of 1.18 pips.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Is this strategy tradable?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to understand whether the average trade can cover all
    trading costs. The instrument traded here, the euro versus the US dollar, is by
    far the most liquid in the FX market and thus normally at the time of the entry,
    spreads are about 0.00001-0.00002 pips, with at least 100,000 to 500,000 at top
    of the order book (depending on the trading venue). So, we shouldn’t suffer from
    slippage if we keep the trading size reasonable, and at first glance, it seems
    like we can actually trade this strategy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to follow all steps considered in [*Chapter 13*](B19145_13.xhtml#_idTextAnchor215),
    *To Trade or Not to Trade – Performance Analysis,* and make your final decision
    about this strategy.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to take into consideration overnight swaps. See how they affect
    the strategy performance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'However, regardless of whether this strategy is tradable or not, let me emphasize
    once again the importance of a trading idea behind the code. Trading ideas do
    not come out of the blue: they are all based on various factors specific to a
    particular market. I’d even go further and say that *trading ideas are always
    based on factors that distinguish the market from a random process* in a mathematical
    sense. That’s why we have spent so much time on market fundamentals in this book,
    and I hope you will be able to find many other trading ideas amid the massive
    heap of facts that we have considered.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been working only with strategies that open new positions only
    either when the market position is zero or to reverse the currently open position.
    In this case, the edge of the strategy logic is in its ability to properly time
    entries and exits. However, there is a whole class of strategies that achieve
    an edge in managing multiple positions open in the same direction. In this case,
    we say that a strategy has an edge in terms of *money management*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Money management and multiple entries
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To give you an idea about what money management is and how it may affect strategy
    performance, let me tell you about probably the most famous – or infamous – kind
    of money management technique, known as **martingale**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The origin of martingale is in gambling. Imagine the simplest gambling game
    of a coin toss. You toss the coin and if it comes up heads, you win; if it comes
    up tails, you lose. We can use `1` for wins and `-1` for losses and the series
    of tosses can be represented by a sequence as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you put at stake an equal amount of money each time you toss the coin, we
    can multiply the sequence by that amount and write it like so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, `b` refers to the size of the bet. Obviously, your total win in the game
    is the sum of the entire series. In an idealistic model, the results of each toss
    are independent of each other, and the probability of the coin coming up as heads
    or tails is strictly 50%. Therefore in the long term, the sum of the series will
    always be around zero and there is no chance to win this game.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The sum of this series is indeed zero. However, things change dramatically
    if you start using money management in form of a martingale. After each new loss,
    you double your stake, and after each new win, you reset the bet size to its initial
    value. Then, the sequence of wins and losses transforms into the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It’s clear that now the sum of the sequence is very far from zero; in our example,
    it is 5b. This means that by using money management, it is possible to win a game
    with outcomes of equal probability.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, the martingale looks like the ultimate method to win any game,
    but there are two pitfalls:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'This method may work only in a game whose outcomes are truly independent. In
    the theory of probability, processes of this kind are called **stochastic** (see
    [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101), *Basics of Fundamental Analysis
    and Its Possible Use in FX Trading*). Financial time series are frequently considered
    in academic research to be stochastic, at least at the tick level, but we already
    know that there are certain moments and even relatively long periods when this
    is not true: for example, after the release of important economic news, it’s clear
    that upticks or downticks will prevail for some time, depending on the resonance
    of the news (see again [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101), *Basics
    of Fundamental Analysis and Its Possible Use in* *FX Trading*).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with a *pure* random walk process, the equal probability of outcomes is
    achieved only in long term (to be absolutely precise, only in an infinitely long
    series). If we analyze a short-term subsequence of outcomes, we may see a series
    of identical outcomes, and no one can guarantee that such a series will definitely
    end at a certain outcome number – exactly because the probability of a new outcome
    does not depend on previous outcomes! If you start with just $100 and double your
    stake with each loss, then you have to put ![](img/Formula_B19145_14_001.png)
    on the table after the n-th loss in a series. After the 3rd loss, you will have
    to bet $800, after the 4th loss, $1,600, and so on, and if you are so unlucky
    to face a series of 10 losses in a row, then you should call your bank and ask
    them to provide you with a credit line because now you have to bet $102,400!
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope you understand why the martingale is so popular in books for illustrative
    purposes but *highly not recommended* for practical use.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In trading, there is a modification of the martingale known as **averaging down**.
    Let’s suppose that we opened a long position, but the market price went down.
    Instead of liquidating the position or just waiting until the price returns to
    the initial level, we open long new positions, increasing the trading size and
    moving the average entry price down. For example, if we originally opened a long
    position of 1 contract at 100.00 and then added another 1 contract at 90.00, then
    we actually have a position of 2 contracts opened at 95.00.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Both the martingale and averaging may have only limited uses and normally, traders
    who use them in any form apply some restrictions to the maximum size of the open
    position.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Like many other authors, I used the martingale and averaging down for illustrative
    purposes: only because they give a very clear idea of what money management is
    about. There are more conservative money management strategies, and some of them
    are quite sophisticated. If you are interested in learning more about money management
    strategies and looking for a single source, I’d recommend the ultimate guide written
    by the money management guru Van Tharp, *Definitive Guide to Position Sizing Strategies*.
    If you have a more academic interest in the subject or are more inclined to collect
    information from various sources, I’d recommend starting with understanding the
    stochastic processes in general ([https://en.wikipedia.org/wiki/Stochastic_process](https://en.wikipedia.org/wiki/Stochastic_process))
    and random walks in particular ([https://en.wikipedia.org/wiki/Random_walk](https://en.wikipedia.org/wiki/Random_walk)),
    and then referring to a book by Ralph Vince, *The Mathematics of Money Management:
    Risk Analysis Techniques for* *Traders* ([https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387](https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387)).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: To work with money management strategies, you should be very careful with the
    order size. Presently, we have worked only with strategies that open a position
    with a fixed size and then close it before opening a new one. If you increase
    the position by using multiple orders in the same direction, you should carefully
    calculate the order size when you try to liquidate a position. If you make a mistake,
    the strategy will leave one or more positions open, and this may highly adversely
    impact the strategy’s performance. So, generally, the order handling methods mentioned
    in this chapter are required for the correct implementation of money management
    strategies.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: I would be happy to continue our discussions about the FX markets, systematic,
    and algo trading at the same level of detail as before, but unfortunately, the
    book’s size is limited, so I will just give you general guidelines on a few more
    important subjects for your own further studies. They are presented here as separate
    topics, without any evident logical connection between them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Strategy performance revisited – more metrics
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 13*](B19145_13.xhtml#_idTextAnchor215), *To Trade or Not to Trade
    – Performance Analysis*, we considered only the very basic performance metrics.
    Of course, there are many others that are no less important. I recommend starting
    with the nice overview from *Quantinsti* ([https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/](https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/)),
    implementing each metric in the code, and then you can analyze your strategies
    as market professionals do.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: More about the risks specific to algo trading
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already considered the main risks in any trading: operational, systemic,
    and transactional. Let’s highlight another kind of risk that is specific to algo
    trading.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: When you develop and backtest a strategy using compressed data, along with limit
    or stop orders, there is a risk that more than one of these orders will be simulated
    on the same bar. Typically, this happens when the order prices are too close to
    each other and the data resolution is not granular enough. For example, if you
    place a limit and a stop order at a distance of 5 pips from each other and run
    a backtest using daily data, then on most days, both orders should be executed
    during a single bar. This is what you want to avoid at all costs because the backtester
    has no idea about how the price has actually moved inside this single bar and
    therefore no one knows which of the two orders will have been triggered first
    and which next. So, it is extremely important to correctly choose the data resolution
    so that the backtesting results are realistic.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The rule of thumb for choosing the data resolution
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Always choose the data resolution for which the average range of a bar (the
    difference between a bar’s high and low values) is less than the distance between
    order prices. If you place limit or stop orders of 100+ pips, then you can use
    daily data. If you use limit or stop orders of 20+ pips, then most likely, a timeframe
    of 30 minutes may work. If you use tight stops or limits, as in the previous example,
    then a 1-minute resolution is the way to go. Remember that only testing using
    tick data can give you the ultimately correct picture, although this kind of backtest
    will take a lot of time.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Classical technical trading setups
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 7*](B19145_07.xhtml#_idTextAnchor114), *Technical Analysis and
    Its Implementation in Python*, we considered a number of classical technical analysis
    indicators, such as the RSI, a stochastic oscillator, moving averages, and Bollinger
    bands. We saw that each of these indicators is able to bring into focus a certain
    property of the price time series: for example, Bollinger bands are a volatility
    indicator, and moving averages are digital filters that remove higher frequencies
    from the price data. However, we didn’t consider any classical trading setup with
    any of these indicators. Why?'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question is twofold. First, these setups can be found in
    literally any book or internet publication about technical analysis. You can start
    with an overview of technical indicators at Investopedia ([https://www.investopedia.com/terms/t/technicalindicator.asp](https://www.investopedia.com/terms/t/technicalindicator.asp))
    and then follow the links to articles on specific indicators to see how they are
    supposed to be used to generate trading signals.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The second and more important reason we don’t go into detail on these classical
    setups here is that none of them can create a profitable trading strategy as they
    are. You can try building a simple strategy by implementing any of the classical
    setups, then run it in multiple markets using different data resolutions, and
    you will see that unfortunately, none of the combinations deliver anything that
    could be considered satisfactory performance.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Why does this happen? And does it mean that technical analysis indicators are
    useless for practical trading?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: This happens because all of the classical indicators were developed to highlight
    specific processes that took place in specific markets at a specific time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: For example, Welles Wilder, the creator of the RSI, developed this indicator
    when he traded commodity futures back in the 1970s. At that time, the market was
    relatively illiquid and was open for only a few hours a day. Only select traders
    had access to it and trades were placed either in the pit or by phone – and this
    is what commodity futures markets used to be in the 1970s. On the contrary, the
    present-day FX market is open 24/7 and is full of liquidity, with many diverse
    kinds of market participants, from big banks to retail traders. Its computerized
    ordering can process thousands of transactions per second. Compare these two markets
    and you will understand why the indicators of the old days may not indicate what
    they are supposed to.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the second question – whether classical technical indicators are
    useless these days – is negative. We still can use any or all of these indicators
    *if we understand what exactly they show us*. That’s why I tried to focus on their
    meaning rather than just listing the well-known use cases, such as moving averages
    crossover (see [https://www.investopedia.com/terms/c/crossover.asp](https://www.investopedia.com/terms/c/crossover.asp))
    or overbought/oversold zones identified with the RSI or a stochastic oscillator
    (see [https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp](https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, despite the present-day electronic FX markets being very different
    from good old pit-traded futures markets, I would highly recommend reading the
    classic books written by the creators of technical indicators – because, in these
    books, they explain *why they suggested* a particular indicator, *which market
    process* they tried to identify using an indicator, and *how we are supposed to
    profit* from the suggested setups.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Spending a couple of days on thorough reading may be way more valuable than
    wasting weeks and months trying to fit a particular well-known technical trading
    setup to a market that it simply doesn’t fit by nature. I can recommend starting
    with a classic by Welles Wilder Jr., *New Concepts in Technical Trading Systems*,
    in which he carefully explains *how he noticed certain potentially profitable
    market processes*, *how he tried to formalize them*, *how he eventually came to
    a set of technical indicators*, and *how he actually used them to make profits*.
    Focus on this *mental process*, not just the numbers, and you will develop a way
    better understanding of the process of developing a trading strategy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that behind any formula and any code, there should stand a trading
    idea, and trading ideas can be found only in the analysis of markets, not in crunching
    numbers or fitting an irrelevant model to the market. In the next section, we
    will see why excessive fitting may not only be counterproductive but also dangerous.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Optimization – the blessing and the curse of algo trading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you remember how the performance of a simple overnight strategy that we created
    earlier in this chapter radically changed when we replaced a tight stop of 5 pips
    with a wider stop of 50 pips?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'But this fact raises another important question: why 5 and 50 pips? Why not
    6 and 45? Or 10 and 76?'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Any quantitative strategy depends on the values of its parameters, and the procedure
    of finding the best combination of parameters that delivers the best results of
    the backtesting is called **optimization**.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimization is a massive topic. I’d even say it’s overwhelmingly vast and
    complex. At first glance, it looks straightforward: let’s find the best combination
    of parameter values and then run the strategy live with these very values. However,
    the problem is that we always test and optimize our strategies using past data.
    And I hope you already understood and remember well that markets are anything
    but stationary processes. This means that the price behavior may change in the
    future, and the same strategy with the same *best* combination of parameters will
    start losing money.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: A situation in which a strategy has been optimized using insufficient data or
    inappropriate logic and then starts losing money in live trading is known as **overfitting**
    or **curve fitting**. This is considered to be the plague of all algo trading
    and the reason why many discretionary traders are still skeptical about it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: How to mitigate this specific risk?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: There are various workarounds, **forward testing** probably being the most popular.
    When running a forward test, we first optimize the strategy parameters using only
    a subset of the entire past market data and then generate the performance report
    for backtesting, run on another subset of data. For example, if we have data from
    2015 to 2023, then we may want to optimize the strategy using data from 2015 to
    2017 and then test using data from 2018 to 2023\. The backtest using the first
    subset is then called **in-sample** and the backtest using the second subset is
    called **out-of-sample**. If the out-of-sample strategy demonstrates performance
    comparable to that of the in-sample, we can estimate that it will continue working
    even in the future (although in reality, things may be far more complex).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to make a forward test only on a relatively small amount
    of out-of-sample data, then re-optimize the strategy using newer data, and repeat
    the forward test on another, newer portion of out-of-sample data, and so on. In
    our example, we can perform a forward test optimizing the strategy using data
    from 2015 to 2017, then run a forward test on 2018 only, then re-optimize the
    strategy using data from 2016 to 2018, run a forward test on 2019, and so on.
    Such an approach is called **walk-forward optimization**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: As you may have already realized, optimization is an extremely resource- and
    time-consuming process. Indeed, we need to run a backtest with one set of parameter
    values, then save the result, modify the parameters, run a backtest again, and
    repeat. In our sample strategy, if we wanted to find the best values for the stop-loss
    and profit target between 5 and 50 pips with a step of 5 pips, it would require
    100 runs of the entire backtest, which would take hours on most computers. That’s
    why optimization algorithms are mostly developed using compiled versions of Python,
    such as Cython or Numba.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in developing a true understanding of optimization, I’d
    recommend starting with the concise yet nice introduction by Davide Scassola at
    *Triality* ([https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies](https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies))
    and then reading Robert Pardo’s book, *The Evaluation and Optimization of Trading*
    *Strategies* ([https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011](https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Final words
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, any story comes to an end sooner or later, and this book is no exception.
    Even if you opened it with no idea about FX markets and algo trading, now you
    have definitely taken yourself to a new level. You have knowledge about FX markets
    comparable to that of a beginner professional desk trader. You know how to develop
    trading applications for both live trading and producing reliable backtests. You
    also know the risks pertaining to trading, for algo trading in particular. You
    have plenty of roads to go down — in terms of money management, performance analysis,
    and optimization – but there is one thing I really want you to always remember
    whatever you do:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Any good trading strategy always has a trading idea behind it. No sophisticated
    mathematics, no money management, and no optimization will help if the strategy
    is just a randomly chosen combination of technical analysis studies and parameters.
    Look for ideas in the market and use the mathematical and programming apparatus
    to implement, test, and run them – without fear or greed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
