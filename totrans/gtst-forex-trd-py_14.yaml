- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Where to Go Now?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在去哪里？
- en: Although the previous chapter sounded like the end of the book, I thought it
    would be unfair to leave you without giving some guidelines regarding further
    development of your knowledge and skills in FX markets and creating trading algorithms
    (algo). Unlike previous chapters, where each chapter was dedicated to a single
    large topic, this one is a collection of short stories about different aspects
    of FX algo trading, aiming to provide you with starting points for further research.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上一章听起来像是书的结尾，但我认为不给你一些关于进一步发展你在外汇市场和创建交易算法（算法）的知识和技能的指导是不公平的。与之前的章节不同，其中每一章都专注于一个大型主题，这一章是关于外汇算法交易不同方面的短篇故事集，旨在为你提供进一步研究的起点。
- en: Mastering any complex subject requires effort and trading is probably the most
    time- and labor-consuming activity, which requires a very special attitude combining
    the mindsets of a scientist and a businessman. Any successful trading strategy
    or algorithm is a result of many hours of work, of which only 10-20% is spent
    on actual coding, debugging, and refactoring; the majority of time is always spent
    on studying the markets, in search of trading ideas and endless trial-and-error
    proofs of concept. This chapter will give you hints both on finding your own edge
    in the market and making your trading apps more robust.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握任何复杂主题都需要努力，而交易可能是耗时和劳动密集型活动，它需要结合科学家和商人的心态的非常特殊的态度。任何成功的交易策略或算法都是许多小时工作的结果，其中只有10-20%的时间用于实际的编码、调试和重构；大部分时间总是花在研究市场上，寻找交易想法和无数试验和错误的证明概念。本章将给你提示，如何在市场上找到自己的优势，并使你的交易应用更加健壮。
- en: Don’t forget that we are all perpetual students of the market, and you will
    keep learning as long as you are in this complex yet exciting business of algo
    trading.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，我们都是市场的终身学生，只要你在算法交易这个复杂而激动人心的行业中，你将不断学习。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Implementing limit and stop orders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施限价单和止损单
- en: The correct way to calculate the number of trades
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算交易次数的正确方法
- en: From trading ideas to implementation – another sample strategy using limit and
    stop orders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从交易想法到实施——使用限价单和止损单的另一个示例策略
- en: Money management and handling multiple entries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资金管理和处理多个入场
- en: Revisiting strategy performance – more metrics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视策略表现——更多指标
- en: More about the risks specific to algo trading
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于算法交易特定风险的更多内容
- en: Classical technical trading setups
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典的技术交易设置
- en: Optimization – the blessing and the curse of algo trading
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化——算法交易的祝福与诅咒
- en: Implementing limit and stop orders
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施限价单和止损单
- en: 'In [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171), *Types of Orders and Their
    Simulation in Python*, we considered three main types of orders: market, limit,
    and stop. However, so far, we have only used market orders in actual codes. Although
    we noted that a live trading application may not ever use stop and limit orders
    because they can be emulated on the client side and sent to the market as market
    orders when necessary, it would be definitely useful to have both types of orders
    implemented in the backtester to simplify the development of trading strategies.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B19145_10.xhtml#_idTextAnchor171)“在Python中考虑订单类型及其模拟”中，我们考虑了三种主要的订单类型：市价单、限价单和止损单。然而，到目前为止，我们只在实际代码中使用了市价单。虽然我们指出，实际交易应用可能永远不会使用止损单和限价单，因为它们可以在客户端模拟，并在必要时作为市价单发送到市场，但在回测器中实现这两种类型的订单肯定是有用的，以简化交易策略的开发。
- en: Let’s quickly recall the essence of limit and stop orders.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下限价单和止损单的精髓。
- en: A **limit order** is always executed at a price equal to the order price *or
    better*. This means that if the market price is currently 100 and a buy limit
    order is sent below the market, for example, at 99, then it will be filled only
    when the price becomes 99 *or lower*. If a buy limit order is sent above the market,
    for example, at 101, then it will be executed immediately and its price will work
    as a cap for possible adverse price increase during the order execution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**限价单**总是以等于订单价格或更好的价格执行。这意味着如果市场价格目前是100，并且发送了一个低于市场的买入限价单，例如，在99，那么它只有在价格变为99或更低时才会被填充。如果发送了一个高于市场的买入限价单，例如，在101，那么它将立即执行，其价格将作为订单执行期间可能出现的价格上涨的限制。'
- en: Similarly, a **stop order** is always executed at a price equal to the order
    price *or worse*. Using the same example, if a buy stop order is sent below the
    market, then it is executed immediately, and if it is sent above the market, then
    it will be executed only when the market price reaches the order level. When executing
    a stop order, there is no limit on how the price may grow during the execution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，**停损单**总是以等于订单价格或更差的价格执行。使用相同的例子，如果发送一个低于市场的买入停损单，那么它将立即执行；如果发送一个高于市场的停损单，那么它将只在市场价格达到订单水平时执行。在执行停损单时，对价格在执行过程中的增长没有限制。
- en: With sell orders, the situation is symmetrical.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于卖出订单，情况是对称的。
- en: 'When we emulate the execution of limit and stop orders using tick data, we
    can always check whether a certain tick satisfies the order condition and then
    assume it as the price at which the order was executed. However, when we work
    with compressed data, for example, 1 minute, 1 hour, 1 day, and so on, we have
    no idea at which tick the order would be actually executed. Instead, we assume
    that if the bar’s high or low crosses the order level, then the order is supposed
    to be filled. *Table 14.1* summarizes all the possible fill conditions for limit
    and stop orders:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用tick数据模拟执行限价单和停损单时，我们总能检查某个tick是否满足订单条件，然后假设它为执行订单的价格。然而，当我们处理压缩数据时，例如1分钟、1小时、1天等，我们不知道订单会在哪个tick实际执行。相反，我们假设如果K线的最高价或最低价穿过订单水平，那么订单应该被成交。*表14.1*总结了限价单和停损单所有可能的成交条件：
- en: '| **Type** **of order** | **Side** | **Fill condition** | **Fill price** |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **订单类型** | **方向** | **成交条件** | **成交价格** |'
- en: '| Limit | Buy | Bar’s low < order price | Minimum of the order price and the
    bar’s open |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 限价 | 买入 | K线最低价 < 订单价格 | 订单价格和K线开盘价的最小值 |'
- en: '| Limit | Sell | Bar’s high > order price | Maximum of the order price and
    the bar’s open |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 限价 | 卖出 | K线最高价 > 订单价格 | 订单价格和K线开盘价的最大值 |'
- en: '| Stop | Buy | Bar’s high > order price | Maximum of the order price and the
    bar’s open |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 停损 | 买入 | K线最高价 > 订单价格 | 订单价格和K线开盘价的最大值 |'
- en: '| Stop | Sell | Bar’s low < order price | Minimum of the order price and the
    bar’s open |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 停损 | 卖出 | K线最低价 < 订单价格 | 订单价格和K线开盘价的最小值 |'
- en: Table 14.1 – Conditions to trigger limit and stop orders and their assumed execution
    price
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1 – 触发限价单和停损单的条件及其假设执行价格
- en: You can see that when backtesting using compressed data, the price at which
    we assume the order was executed is not necessarily equal to the order price.
    In some cases, it can be that the bar’s open. Why?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当使用压缩数据进行回测时，我们假设订单执行的价格并不一定等于订单价格。在某些情况下，它可能是K线的开盘价。为什么？
- en: To answer this question, we should recall that the market price is not continuous,
    and sometimes adjacent ticks have quite a significant difference in prices between
    them. In a bar chart, it can be seen as an *empty space* between the bar’s closed
    and the next bar’s open. These empty spaces are called **gaps**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，我们应该回想一下市场价格不是连续的，有时相邻的tick之间价格差异可能相当显著。在K线图中，这可以看作是K线收盘和下一根K线开盘之间的*空隙*。这些空隙被称为**缺口**。
- en: 'Typically, gaps on bar charts in FX markets can be seen between the close of
    the market on Friday and its re-opening on late Sunday. Normally, these gaps are
    not very large, but sometimes they may be quite dramatic, especially if there
    was some important economic or political news during the weekend. The following
    graph illustrates a weekend gap for USD/JPY on February 6, 2023:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，外汇市场的K线图在周五市场收盘和周日晚些时候重新开盘之间会有缺口。通常，这些缺口并不很大，但有时它们可能非常显著，尤其是在周末期间有重要的经济或政治新闻。以下图表展示了2023年2月6日USD/JPY的周末缺口：
- en: '![Figure 14.1 – Weekend gap in USD/JPY (chart by Multicharts)](img/B19145_14_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – USD/JPY的周末缺口（由Multicharts图表）](img/B19145_14_01.jpg)'
- en: Figure 14.1 – Weekend gap in USD/JPY (chart by Multicharts)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – USD/JPY的周末缺口（由Multicharts图表）
- en: The market closed on Friday, February 3, 2023, at **131.141** and opened on
    Monday, February 6, 2023, at **132.194**. The difference between these prices
    is shown by the gray arrow. It is more than 100 pips, which is comparable to the
    average daily price movement. If on Friday’s close we sent a stop order to buy
    at, say, 131.50, then in reality, this order would have been executed only at
    132.194 (and in reality, most likely even worse because of slippage during an
    illiquid time after the open of the market). If we sold on Friday’s close, even
    if we protected our position with a stop loss – which is in fact just a stop order
    – well... we could only hope that the position size was small enough not to ruin
    the trading account with one huge loss.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 市场于2023年2月3日星期五收盘价为**131.141**，并于2023年2月6日星期一开盘价为**132.194**。这两个价格之间的差异由灰色箭头表示。这个差异超过100点，与平均每日价格波动相当。如果在周五收盘时我们发送了一个以131.50为买入止损订单，那么实际上，这个订单只会以132.194的价格成交（实际上，由于市场开盘后流动性较差的时间段的滑点，可能甚至更差）。如果我们周五收盘时卖出，即使我们用止损单保护我们的头寸——实际上这只是一种止损订单——嗯...我们只能希望头寸大小足够小，不至于因为一次巨大的损失而毁掉交易账户。
- en: Anyway, we now can see why we always check whether the order price is beyond
    the open price of the bar and why we suggest calculating the actual execution
    price as per the **Fill price** column in *Table 14.1*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不管怎样，我们现在可以理解为什么我们总是检查订单价格是否超过条的开盘价，以及为什么我们建议根据*第14.1表*中的**成交价格**列计算实际执行价格。
- en: Now that we understand how we can realistically emulate limit and stop orders,
    let’s proceed to coding. We will be working with the backtester code that we developed
    in [*Chapter 11*](B19145_11.xhtml#_idTextAnchor186), *Backtesting and Theoretical
    Performance*, and we are going to modify the `emulateBrokerExecution()` function
    because the order execution is isolated in it (remember the ideology of keeping
    the code logic modular? Now, we start to really benefit from this approach).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何现实地模拟限价和止损订单，让我们继续编码。我们将使用我们在[*第11章*](B19145_11.xhtml#_idTextAnchor186)，*回测和理论表现*中开发的回测代码，我们将修改`emulateBrokerExecution()`函数，因为订单执行被隔离在其中（还记得保持代码逻辑模块化的理念吗？现在，我们开始真正从这种方法中受益）。
- en: 'Presently the `emulateBrokerExecution()` function contains an implementation
    only of market orders. Let’s add the following block of code directly below it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`emulateBrokerExecution()`函数只包含市场订单的实现。让我们直接在其下方添加以下代码块：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I hope the code is transparent enough to see that it just implements the logic
    outlined in *Table 14.1*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望代码足够透明，以便可以看到它只是实现了在第14.1表中概述的逻辑。
- en: If you want to emulate issues with execution, which are typical for limit orders,
    then you may want to replace `<=` with `<` and `>=` with `>` in the code, which
    check whether the bar’s price matches the order price. In this case, you assume
    that the limit order had a guaranteed fill (see [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    *Types of Orders and Their Simulation* *in Python*).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想模拟限价订单典型的执行问题，那么你可能想在代码中将`<=`替换为`<`，将`>=`替换为`>`，以检查条的价格是否与订单价格匹配。在这种情况下，你假设限价订单有一个保证的成交（参见[*第10章*](B19145_10.xhtml#_idTextAnchor171)，*Python中的订单类型及其模拟*）。
- en: 'Now, let’s add a very similar block to simulate the execution of stop orders:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个非常相似的代码块来模拟止损订单的执行：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code is absolutely symmetrical to that of limit order simulation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与限价订单模拟的代码绝对是对称的。
- en: If you want to emulate slippage, which is typical for stop orders, then you
    may want to add or subtract a small amount from the executed price. Normally,
    if we trade liquid markets such as EUR/USD and send orders from 7 am until 9:50
    p.m. GMT, we may not add or subtract anything. If we trade less liquid currency
    pairs, such as AUD/USD, then a slippage of 0.00001 to 0.00005 pips looks reasonable.
    If you are into more unusual pairs, such as TRY/MXN, then check the order book
    (if your broker provides such a pair at all!) See again [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    *Types of Orders and Their Simulation in Python*, for details on stop orders and
    slippage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要模拟止损订单典型的滑点，那么你可能想在执行价格上添加或减去一小部分金额。通常，如果我们交易流动性较高的市场，如EUR/USD，并且从早上7点交易到GMT晚上9:50，我们可能不需要添加或减去任何东西。如果我们交易流动性较低的货币对，如AUD/USD，那么0.00001到0.00005点的滑点看起来是合理的。如果你交易的是更不寻常的货币对，如TRY/MXN，那么检查订单簿（如果你的经纪商甚至提供这样的对！）。再次参见[*第10章*](B19145_10.xhtml#_idTextAnchor171)，*Python中的订单类型及其模拟*，以获取关于止损订单和滑点的详细信息。
- en: Note an important difference between the way we treat market, limit, or stop
    orders. A market order’s status is set to `Executed` immediately as soon as the
    order is received by the `emulateBrokerExecution()` function, but the status of
    a limit or a stop order is first set to `Submitted`. The `Submitted` status is
    assigned because once generated, these orders should remain in the orders queue
    either until they are executed or canceled.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们对待市价、限价或止损订单的方式之间的重要区别。市价订单的状态在订单被`emulateBrokerExecution()`函数接收后立即设置为`已执行`，但限价或止损订单的状态首先设置为`已提交`。`已提交`状态被分配，因为这些订单一旦生成，应该保留在订单队列中，直到它们被执行或取消。
- en: Now that we have added two new types of orders, we should check whether we did
    everything correctly. As we did in [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171)
    to test the execution of market orders, we will use the same source data file,
    which contains 1-minute bars of EUR/USD. We are only going to read the first 20
    bars and execute one limit and one stop order to make sure that they are simulated
    correctly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了两种新的订单类型，我们应该检查我们是否一切都做得正确。正如我们在[*第10章*](B19145_10.xhtml#_idTextAnchor171)中测试市价订单执行时所做的，我们将使用相同的源数据文件，它包含EUR/USD的1分钟记录。我们只将读取前20条记录，并执行一个限价订单和一个止损订单，以确保它们被正确模拟。
- en: 'Before we do any testing, let’s open the source data file in any text editor,
    copy the first 21 lines, and paste them into an Excel spreadsheet. Then, we will
    build a chart using the **Financial** chart type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何测试之前，让我们在任何文本编辑器中打开源数据文件，复制前21行，并将它们粘贴到Excel电子表格中。然后，我们将使用**金融**图表类型构建一个图表：
- en: '![Figure 14.2 – Test chart using the first 20 bars from the EUR/USD source
    data file](img/B19145_14_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 使用EUR/USD源数据文件的前20条记录制作的测试图表](img/B19145_14_02.jpg)'
- en: Figure 14.2 – Test chart using the first 20 bars from the EUR/USD source data
    file
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 使用EUR/USD源数据文件的前20条记录制作的测试图表
- en: The price data starts from about **1.1295** and falls below **1.1290** on the
    fourth bar. Great, let’s place a buy limit order at **1.1290**. Then, we can see
    that the price starts growing, but eventually falls below **1.1285**, so let’s
    place a sell stop order at this level – thus emulating a stop-loss (remember that
    a stop-loss protects an open position from excessive losses and is always placed
    on the side opposite to the position, so in our example, it will be a sell stop).
    This stop order should be executed on the 11th bar.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 价格数据从大约**1.1295**开始，在第四条记录时跌至**1.1290**。太好了，让我们在**1.1290**处放置一个买入限价订单。然后，我们可以看到价格开始上涨，但最终跌至**1.1285**，所以让我们在这个水平放置一个卖出止损订单——从而模拟止损（记住，止损可以保护开放头寸免受过度损失，并且总是放置在头寸相反的一侧，所以在我们这个例子中，它将是一个卖出止损）。这个止损订单应该在第11条记录时执行。
- en: 'Now, let’s get to coding:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编码：
- en: 'Firstly, in the `getBar()` function, we set the maximum number of bars to be
    read from the file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`getBar()`函数中，我们设置从文件中读取的最大条数：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we implement the *strategy* logic so it produces only two orders:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实现*策略*逻辑，使其只产生两个订单：
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we now try to run the backtest, it will produce no output because we do
    not process an order status of `processOrders()` function yet. The logic of this
    processing is quite simple: if the order status is **Submitted**, we should return
    it to the orders queue.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行回测，它将不会产生任何输出，因为我们还没有处理`processOrders()`函数的订单状态。这个处理逻辑相当简单：如果订单状态是**已提交**，我们应该将其返回到订单队列。
- en: However, we should be very careful with returning orders to the queue. Don’t
    forget that the `processOrders()` function uses an internal infinite loop, which
    retrieves orders from the queue and finishes working only when there is no order
    left. If we return submitted orders back to the queue inside the same infinite
    loop, we will never get out of it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在将订单返回队列时应该非常小心。别忘了`processOrders()`函数使用了一个内部无限循环，它从队列中检索订单，并且只有当没有订单剩下时才会停止工作。如果我们在这个无限循环中返回提交的订单回队列，我们将永远无法从中退出。
- en: Again, there are different solutions to this problem, and maybe you will suggest
    a better one, but let’s use the most straightforward approach for now. Let’s add
    temporary storage where we will store orders that were processed but not executed,
    and then put them back in the orders queue after all orders have been processed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个问题有几种不同的解决方案，也许你会建议一个更好的方案，但现在让我们使用最直接的方法。让我们添加临时存储，我们将在这里存储已处理但未执行的订单，然后在所有订单处理完毕后将它们放回订单队列。
- en: 'Let’s start by adding the `self.orders_buffer = []` temporary storage to the
    constructor of the `tradingSystemMetadata` class. Then, let’s add the following
    code below the `if order[''Status''] == ''Executed'':` logical block in the `processOrders()`
    function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`tradingSystemMetadata`类的构造函数中添加`self.orders_buffer = []`临时存储开始。然后，在`processOrders()`函数中`if
    order['Status'] == 'Executed':`逻辑块下方添加以下代码：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will add the submitted order to the buffer. And finally, we will rewrite
    the `except:` clause as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把提交的订单添加到缓冲区。最后，我们将重写`except:`子句如下：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The idea is that if there are no more orders in the orders queue, it raises
    an exception, so we can safely return all submitted orders temporarily accumulated
    in the buffer back to the queue.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是，如果没有更多的订单在订单队列中，它将引发一个异常，因此我们可以安全地将暂时积累在缓冲区中的所有提交的订单返回到队列中。
- en: 'Now, let’s run the backtest and look at the resulting equity curve:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行回测并查看产生的权益曲线：
- en: '![Figure 14.3 – Equity curve](img/B19145_14_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 权益曲线](img/B19145_14_03.jpg)'
- en: Figure 14.3 – Equity curve
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 权益曲线
- en: 'We can see that the buy limit order indeed was executed on the 4th bar (remember
    that we count from zero), then the equity started to grow, then it dropped, and,
    finally, the sell stop order was executed on the 11th bar. In the console, we
    can check the information about the number of trades and the average trade value:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，买入限价订单确实在第四个柱上执行（记住我们从零开始计数），然后权益开始增长，然后下降，最后在第十一根柱上执行了卖出止损订单。在控制台中，我们可以检查交易次数和平均交易价值的信息：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But wait a moment! There’s something wrong with it now. According to the price
    levels at which the orders were executed, the distance between the entry and the
    exit should be exactly 5 pips, but the average trade is -2.7 pips, which is even
    not an integer value. What happened? To answer this question, we should revise
    the way we calculate the number of trades.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！现在有些不对劲。根据执行订单的价格水平，入场和出场之间的距离应该是正好5个点，但平均交易是-2.7个点，甚至不是一个整数值。发生了什么？为了回答这个问题，我们应该修改我们计算交易次数的方式。
- en: The correct way to calculate the number of trades
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算交易次数的正确方法
- en: When we were working with the trend-following strategy in [*Chapter 12*](B19145_12.xhtml#_idTextAnchor203),
    *Sample Strategy – Trend-Following*, we only opened new positions, and each opening
    closed the previously open one. This is normal for always-in-the-market strategies.
    In this case, indeed, the number of trades coincides with the number of executed
    orders.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第12章*](B19145_12.xhtml#_idTextAnchor203)中处理趋势跟踪策略时，*示例策略 – 趋势跟踪*，我们只打开新的仓位，每次打开都会关闭之前打开的仓位。这对于始终在市场中的策略来说是正常的。在这种情况下，确实，交易次数与执行订单次数相匹配。
- en: 'In our example with a limit and a stop order, we use two orders to actually
    perform just one trade: buying and then exiting the market with a profit or loss.
    Therefore, we should only use the amount of entry orders to calculate the average
    trade. How can we distinguish between opening and closing orders?'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的限价和止损订单示例中，我们使用两个订单实际上只执行一笔交易：买入然后以盈利或亏损退出市场。因此，我们应该只使用入场订单的数量来计算平均交易。我们如何区分开仓和平仓订单？
- en: 'There are multiple ways of doing that. One of the possible options would be
    adding another key to the order with values of `Entry` or `Exit`, but we will
    use a different approach: we will add a new attribute to the `tradingSystemMetadata`
    class, which will hold the actual number of trades, and we will update it only
    when the market position after the order execution is not zero, that is, the last
    executed order was not a closing order:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以做到这一点。其中一种可能的选择是在订单顺序中添加另一个键，其值为`Entry`或`Exit`，但我们将采用不同的方法：我们将在`tradingSystemMetadata`类中添加一个新的属性，该属性将保存实际的交易次数，并且我们只会在订单执行后的市场位置不为零时更新它，也就是说，最后执行的订单不是一个平仓订单：
- en: First, let’s add `self.number_of_trades = 0` to the constructor of the `tradingSystemMetadata`
    class. This is where we’re going to save the number of trades.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在`tradingSystemMetadata`类的构造函数中添加`self.number_of_trades = 0`。这是我们保存交易次数的地方。
- en: 'Next, we need to modify the way we count trades. The right place to do it is
    when we update the market position in the `processOrders()` function. Presently,
    we use code that only updates the market position and does not check whether the
    market position is zero or not after the execution of the last order:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们计算交易的方式。正确的地方是在`processOrders()`函数中更新市场头寸时。目前，我们使用只更新市场头寸而不检查在执行最后一个订单后市场头寸是否为零的代码：
- en: '[PRE22]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we’re going to replace this piece of code with the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将用以下代码替换这段代码：
- en: '[PRE26]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see that this code checks whether the market position changed to non-zero
    after the trade and only in this case increases the number of trades. Thus, if
    the last order only closed the position without opening a new one, it won’t be
    taken into account.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这段代码检查交易后市场头寸是否变为非零，并且只有在这种情况下才会增加交易次数。因此，如果最后一个订单只是关闭了头寸而没有打开新的头寸，它将不会被考虑。
- en: 'The only thing to fix now is at the very end of the code, where we print the
    number of trades and calculate the average trade:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在唯一要修复的是代码的末尾，在那里我们打印交易次数并计算平均交易：
- en: '[PRE34]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we now re-run the backtest, we will see the correct output:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在重新运行回测，我们将看到正确的输出：
- en: '[PRE36]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Almost there! The number of trades is correct, but strangely there are 0.4 extra
    pips in the average trade value – and according to the levels we specified in
    the strategy logic, the average trade should be exactly -5 pips, not -5.4\. Where
    does the difference come from?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 差不多完成了！交易次数是正确的，但奇怪的是平均交易价值中多出了0.4个点——根据我们在策略逻辑中指定的水平，平均交易应该是正好-5个点，而不是-5.4个点。差异是从哪里来的？
- en: 'To answer this question, we should once again critically revise the `processOrders()`
    function. When we developed it to process only market orders generated at the
    end of a bar, we placed the following three lines before the `while True` loop,
    which processes the orders queue:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要回答这个问题，我们应该再次批判性地审查`processOrders()`函数。当我们开发它来处理仅在K线结束时生成的市价订单时，我们在`while True`循环之前放置了以下三行代码，该循环处理订单队列：
- en: '[PRE38]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Therefore, recalculating the equity based on the bar’s closing price is the
    first thing the function does before orders start processing. If we only use market
    orders, that’s fine, we update the `System.last_price` value when we process the
    order and it will always coincide with the bar’s close. However, now that an order
    can be executed anywhere between the bar’s low and the bar’s high, we have an
    extra amount of `processOrders()` function with the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在开始处理订单之前，函数首先根据K线的收盘价重新计算权益。如果我们只使用市价订单，那就没问题，我们在处理订单时更新`System.last_price`的值，它将始终与K线的收盘价一致。然而，现在订单可以在K线的低点和高点之间任何位置执行，所以我们有额外的`processOrders()`函数步骤如下：
- en: Let’s move the block of three lines that update the equity from the top of the
    code (before the `while True` loop) to the end (after the `while True` loop).
    See the `Stop and limit orders.py` code and the `processOrders()` function.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将更新权益的三行代码块从代码的顶部（在`while True`循环之前）移动到末尾（在`while True`循环之后）。参见`Stop and
    limit orders.py`代码和`processOrders()`函数。
- en: 'After `if order[''Status''] == ''Executed''`, let’s add the following line:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if order['Status'] == 'Executed'`之后，让我们添加以下行：
- en: '[PRE41]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This way, we update the equity value by multiplying the price difference between
    the previous bar’s close (which is stored in `System.last_price` at the moment
    of execution of this line) and the price at which the order was executed by the
    market position, *which existed before the order was executed*. Then, at the end
    of the `processOrders()` function, the equity is updated once again, this time
    by calculating the difference between the order price and the bar’s close, *multiplied
    by the new market position*. This gives us a perfectly precise calculation of
    the strategy equity and, consequently, the value of the average trade.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们通过将前一个K线的收盘价（在执行此行时存储在`System.last_price`中）与订单执行的价格之间的价格差异乘以市场头寸，*即订单执行之前存在的头寸*来更新权益值。然后，在`processOrders()`函数的末尾，权益再次更新，这次是通过计算订单价格与K线收盘价之间的差异，*乘以新的市场头寸*。这为我们提供了策略权益的完美精确计算，从而也提供了平均交易的价值。
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I intentionally have not published the entire code of the modified backtester
    here in this book. My goal now is to train you in the mental process of discovering
    new shortcomings and suggesting solutions. After you’re done with all modifications,
    I recommend downloading my code from GitHub and comparing it – this will give
    you an excellent opportunity to improve your skills in upgrading code logic, which
    is the most important and sensitive part of the entire development in algo trading.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意没有在这本书中发布修改后的回测代码的完整代码。我的目标现在是训练你在发现新的不足并提出解决方案的心理过程。在你完成所有修改后，我建议你从GitHub下载我的代码并与之比较——这将为你提供一个极好的机会来提高你在升级代码逻辑方面的技能，这是算法交易整个开发过程中最重要和最敏感的部分。
- en: 'If we run the final code now, we will get absolutely precise values:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在运行最终代码，我们将得到绝对精确的值：
- en: '[PRE42]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we have mastered limit and stop orders, let me give you several hints
    regarding further development of both backtesting and live trading applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了限价和止损订单，让我给你一些关于进一步开发回测和实盘交易应用的提示。
- en: From trading ideas to implementation – another sample strategy using limit and
    stop orders
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从交易想法到实施——使用限价和止损订单的另一个示例策略
- en: Let’s consider a practical application of the limit and stop orders that we
    have just implemented. I like using this example because it illustrates the importance
    of having a trading idea before writing the code and shows that trading ideas
    do not have to be complex. In practice, the simpler the trading idea, the greater
    the chance that it will work in production.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们刚刚实施的限价和止损订单的实际应用。我喜欢使用这个例子，因为它说明了在编写代码之前拥有交易想法的重要性，并表明交易想法不必复杂。在实践中，交易想法越简单，它在生产中成功的可能性就越大。
- en: 'As you may remember from [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044), *FX
    Market Overview from a Developer’s Standpoint*, most FX markets undergo a bank
    settlement procedure, which happens at 5 p.m. New York time. The price at the
    settlement is very important because it’s used to evaluate many other financial
    instruments and is used for settlement in all cash trades between any parties.
    So, comparing an intraday price to the last settlement price may give us an idea
    about the overall sentiment in this market: if it’s greater than the last settlement
    price, then the sentiment is positive – if it’s lower, the sentiment is negative.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[*第三章*](B19145_03.xhtml#_idTextAnchor044)《从开发者角度的FX市场概述》中可能记得，大多数外汇市场都经历一个银行结算程序，这个程序在纽约时间下午5点进行。结算时的价格非常重要，因为它被用来评估许多其他金融工具，并且用于任何双方之间的所有现金交易的结算。因此，将日内价格与最后结算价格进行比较，可以给我们这个市场的整体情绪提供一个想法：如果它大于最后结算价格，那么情绪是积极的——如果它低于，那么情绪是消极的。
- en: Next, we may want to suppose that if the overall market sentiment is positive,
    then we can try opening a long position, and if it’s negative, a short position.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可能想要假设，如果整体市场情绪是积极的，那么我们可以尝试开多仓，如果它是消极的，那么开空仓。
- en: Then, we have to decide when we may want to do so. Naturally, it should be the
    time of the next settlement because, during the day, external factors such as
    news breaking can move the price up and down many times. However, remember that
    it’s impossible to send an order at exactly 5 p.m. because at that time, the market
    is closed and the order will be rejected. Besides that, several minutes before
    the settlement, the liquidity becomes thinner and thinner, so it may be problematic
    to trade, say, 1 minute before the settlement even with a small trading size.
    So, we will try entering the market 10 minutes before the settlement time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须决定何时进行这样的操作。自然，这应该是下一次结算的时间，因为在一天中，外部因素如新闻的发布可能会使价格上下波动多次。然而，记住，在下午5点时发送订单是不可能的，因为那时市场已经关闭，订单将被拒绝。除此之外，在结算前几分钟，流动性变得越来越稀薄，所以在结算前1分钟进行交易，即使交易规模很小，也可能有问题。因此，我们将尝试在结算时间前10分钟进入市场。
- en: And finally, we have to decide how long we stay in the market, or at which price
    we liquidate our positions. Let’s not be greedy and just exit with a small profit
    of 5 pips. We will use limit orders to exit the position at a certain distance
    from the entry price – such an order is frequently referred to as a **profit target**.
    However, if the market develops the opposite way, we should liquidate our position
    with a loss, so we will use a stop order for this purpose. The question is at
    which level we place this stop order.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须决定我们在市场中的停留时间，或者在我们以哪个价格平仓头寸。让我们不要贪婪，只以5点的微小利润退出。我们将使用限价订单在入场价格的一定距离处退出头寸——这样的订单通常被称为**盈利目标**。然而，如果市场向相反方向发展，我们将以亏损平仓头寸，因此我们将使用止损订单来完成这个目的。问题是我们在哪个水平放置这个止损订单。
- en: There are many opposite opinions on this subject. Many authors believe that
    stops should always be smaller than potential profits because otherwise, it looks
    like you risk more than you can potentially win. Others argue that not only the
    size of the win and loss matter but their probabilities are also important. Indeed,
    we can win a game even if the average loss is 2 times the average win if the percentage
    of wins is greater than 67%.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个问题，有很多不同的观点。许多作者认为，止损应该始终小于潜在利润，否则，看起来你冒的风险比你可能赢得的要多。其他人则认为，不仅赢和输的大小很重要，它们的概率也很重要。事实上，如果我们赢的百分比大于67%，即使平均损失是平均赢利的2倍，我们仍然可以赢得比赛。
- en: 'We have the luxury of quickly testing both approaches: let’s first try setting
    the stop-loss amount the same as the profit target and then increase it to stay
    at the position for a longer time in the hope that sooner or later, it will reach
    our profit target level.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有快速测试这两种方法的奢侈：让我们首先尝试将止损金额设定与盈利目标相同，然后增加它以保持头寸更长时间，希望迟早会达到我们的盈利目标水平。
- en: As you can see, we build a market model again, as we did in [*Chapter 11*](B19145_11.xhtml#_idTextAnchor186),
    but this time, the model doesn’t aim to explain the entire price time series.
    Instead, this model describes only quite a short-term market process, which may
    take place in the market at regular intervals. Generally speaking, we can even
    model the entire price series this way if we find a sufficient amount of regularly
    appearing market processes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们再次构建市场模型，就像我们在[*第11章*](B19145_11.xhtml#_idTextAnchor186)中所做的那样，但这次，模型的目标不是解释整个价格时间序列。相反，这个模型只描述了相当短期的市场过程，这种过程可能会在市场上定期发生。一般来说，如果我们找到足够数量的定期出现的市场过程，我们甚至可以用这种方式模拟整个价格序列。
- en: 'So, to summarize, the trading algorithm should be as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，交易算法应该是这样的：
- en: At 5 p.m. NY time, we save the close price as the reference.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下午5点纽约时间，我们将收盘价作为参考。
- en: At 4:50 p.m. NY time the next day, we compare the price to the reference. If
    the difference is positive, we buy. If the difference is negative, we sell.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二天下午4:50纽约时间，我们将价格与参考价进行比较。如果差异为正，则买入。如果差异为负，则卖出。
- en: We set a profit target of 5 pips and a stop loss of 5 pips.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设定盈利目标为5点，止损为5点。
- en: We stay in the market until either the profit target or the stop-loss is hit.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在市场中的停留时间，直到盈利目标或止损被触及。
- en: Is that all?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了吗？
- en: No. We have to cancel the other order in the *profit target – stop-loss* pair
    when either of them is executed. Otherwise, the remaining order may be triggered
    when the market position is flat (zero), and it will open an unexpected and unwanted
    position that we’ll be unable to manage. Orders whose execution depends on the
    execution of other orders are called **contingent orders**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不。当其中任何一个订单被执行时，我们必须取消*盈利目标-止损*对中的另一个订单。否则，当市场位置为平仓（零）时，剩余的订单可能会被触发，这将打开一个意外且不希望出现的头寸，我们将无法管理。依赖于其他订单执行的订单被称为**权限订单**。
- en: Contingent orders
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限订单
- en: The backtesting and live trading codes developed in this book assume that any
    order is sent to the broker and then is never modified. However, sometimes you
    want to change something in an order that has already been submitted but not executed
    yet. For example, you sent a stop-loss order, but the market conditions changed
    and you now want to increase or decrease the order price.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本书开发的后测试和实时交易代码假设任何订单都发送给经纪人，然后永远不会修改。然而，有时你想要修改已经提交但尚未执行的订单中的某些内容。例如，你发送了一个止损订单，但市场条件发生了变化，你现在想要增加或减少订单价格。
- en: Our codes don’t support this functionality, and not all brokers support it either.
    If you want to implement it, the easiest way to do so is to add a unique identifier
    to each order, and then refer to it in the orders queue when modification is necessary.
    First, you have to remove the old order from the queue and then issue a new order.
    This will provide compatibility with virtually any broker because this is the
    preferred way of modifying orders on the broker’s side.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码不支持这项功能，而且并非所有经纪商都支持。如果您想实现它，最简单的方法是为每个订单添加一个唯一标识符，然后在需要修改时在订单队列中引用它。首先，您必须从队列中删除旧订单，然后发出新订单。这将与几乎任何经纪商兼容，因为这是经纪商侧修改订单的首选方式。
- en: We are not going to implement a universal order management solution that requires
    the introduction of order IDs and appropriate order handling methods for now,
    as it is outside the scope of this book. We will add a small piece of code to
    the `processOrders()` function that clears the entire orders queue as soon as
    a limit or a stop order is executed. This way, we can effectively implement contingent
    profit targets and stop-loss orders.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会实现一个需要引入订单ID和适当的订单处理方法的通用订单管理解决方案，因为这超出了本书的范围。我们将在`processOrders()`函数中添加一小段代码，以便在限价或止损订单执行后立即清除整个订单队列。这样，我们可以有效地实现附带利润目标和止损订单。
- en: Important note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The suggested workaround only works if we have jsut one pair of contingent orders.
    If you want to implement a more sophisticated strategy that utilizes multiple
    contingent orders, there is no other way of doing it than adding order IDs and
    implementing routines that handle orders individually.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的解决方案仅在我们只有一个附带订单对时有效。如果您想实现一个更复杂的策略，该策略利用多个附带订单，除了添加订单ID并实现处理单个订单的例程外，没有其他方法可以做到。
- en: 'To implement our simple workaround, let’s add the following code to the `processOrders()`
    function at the end of the `if order[''Status''] == ''Executed'':` branch, right
    after `System.last_price =` `order[''Executed Price'']`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的简单解决方案，让我们在`processOrders()`函数的`if order['Status'] == 'Executed':`分支末尾添加以下代码，紧接在`System.last_price
    = order['Executed Price']`之后：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The idea of this code is that if any of the contingent orders have been executed
    (and remember, we add this to the processing of the **Executed** order status),
    then we cancel all other orders. Let me repeat once again that this workaround
    only works if we have just one pair of contingent orders in the orders queue and
    no other order is in there.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的思路是，如果任何附带订单已被执行（记住，我们将此添加到**已执行**订单状态的处理中），那么我们将取消所有其他订单。让我再次重复一遍，这个解决方案只在我们只有一个附带订单对在订单队列中，且没有其他订单时才有效。
- en: 'All that we now have to do is add the strategy logic. As always, we only modify
    the code between the `trade logic starts here` and `trade logic ends here` comments.
    The code is very simplistic and implements the four-step logic just described:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的只是添加策略逻辑。一如既往，我们只修改位于`trade logic starts here`和`trade logic ends here`注释之间的代码。代码非常简单，实现了刚刚描述的四步逻辑：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We check whether the price is greater or less than the reference price, open
    a position with a market order, and immediately send a limit order to take a profit
    and a stop order to exit with a loss.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查价格是高于还是低于参考价格，使用市价单开仓，然后立即发送一个限价单以获取利润和一个止损单以亏损退出。
- en: I am not going to consider the entire strategy code here because most of it
    has remained the same as developed in [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    and the modifications that introduced limit and stop orders were considered earlier
    in this chapter (see the *Implementing limit and stop orders* section). You can
    download the code from GitHub, analyze the changes made, and run it to make sure
    you get the correct results.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里考虑整个策略代码，因为其中大部分代码与在第[*第10章*](B19145_10.xhtml#_idTextAnchor171)中开发的内容相同，而引入限价和止损订单的修改已在本章早期讨论（见*实现限价和止损订单*部分）。您可以从GitHub下载代码，分析所做的更改，并运行它以确保您得到正确的结果。
- en: 'If we run the code using EUR/USD 1-minute bars as the source data, we will
    get an equity curve like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用EUR/USD 1分钟K线作为源数据运行代码，我们将得到这样的权益曲线：
- en: '![Figure 14.4 – Equity curve of a strategy with tight stops](img/B19145_14_04.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 具有紧止损策略的权益曲线](img/B19145_14_04.jpg)'
- en: Figure 14.4 – Equity curve of a strategy with tight stops
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 具有紧止损策略的权益曲线
- en: 'We will also get the following basic performance metrics: 1,464 total trades
    with an average trade of about -0.12 pips.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将获得以下基本性能指标：1,464笔总交易，平均交易约为-0.12点。
- en: Clearly, the strategy doesn’t work, and we even don’t have to go through an
    in-depth analysis of its performance. So, the idea of putting stops at the same
    distance as profit targets doesn’t work. What if we now set the stop at 50 pips
    instead of 5 and run the code again?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个策略不起作用，我们甚至不需要深入分析其表现。因此，将止损点设置与利润目标相同距离的想法是无效的。如果我们现在将止损点设置为50点而不是5点，再次运行代码会怎样呢？
- en: 'In the following graph, you can see that now the result is dramatically different:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图表中，您可以看到结果现在有了戏剧性的变化：
- en: '![Figure 13.5 – Equity curve of a strategy with wider stops](img/B19145_14_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 具有更宽止损策略的权益曲线](img/B19145_14_05.jpg)'
- en: Figure 13.5 – Equity curve of a strategy with wider stops
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 具有更宽止损策略的权益曲线
- en: Now, we have 1,428 trades and an average trade of 1.18 pips.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有1,428笔交易，平均交易为1.18点。
- en: Is this strategy tradable?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个策略可交易吗？
- en: First of all, we need to understand whether the average trade can cover all
    trading costs. The instrument traded here, the euro versus the US dollar, is by
    far the most liquid in the FX market and thus normally at the time of the entry,
    spreads are about 0.00001-0.00002 pips, with at least 100,000 to 500,000 at top
    of the order book (depending on the trading venue). So, we shouldn’t suffer from
    slippage if we keep the trading size reasonable, and at first glance, it seems
    like we can actually trade this strategy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解平均交易是否可以覆盖所有交易成本。这里交易的工具，欧元兑美元，在FX市场中远比其他货币流动性高，因此在入场时，点差大约为0.00001-0.00002点，至少有100,000到500,000个订单簿顶部（取决于交易场所）。因此，如果我们保持合理的交易规模，就不应该遭受滑点，从表面上看，我们实际上可以交易这个策略。
- en: I encourage you to follow all steps considered in [*Chapter 13*](B19145_13.xhtml#_idTextAnchor215),
    *To Trade or Not to Trade – Performance Analysis,* and make your final decision
    about this strategy.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您遵循[*第13章*](B19145_13.xhtml#_idTextAnchor215)中考虑的所有步骤，“交易还是不交易 – 性能分析”，并就这个策略做出最终决定。
- en: Hint
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t forget to take into consideration overnight swaps. See how they affect
    the strategy performance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记考虑隔夜掉期。看看它们如何影响策略表现。
- en: 'However, regardless of whether this strategy is tradable or not, let me emphasize
    once again the importance of a trading idea behind the code. Trading ideas do
    not come out of the blue: they are all based on various factors specific to a
    particular market. I’d even go further and say that *trading ideas are always
    based on factors that distinguish the market from a random process* in a mathematical
    sense. That’s why we have spent so much time on market fundamentals in this book,
    and I hope you will be able to find many other trading ideas amid the massive
    heap of facts that we have considered.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论这个策略是否可交易，让我再次强调代码背后的交易理念的重要性。交易理念不是凭空出现的：它们都是基于特定市场的各种特定因素。我甚至可以说，*交易理念始终基于将市场从随机过程中区分开来的因素*，从数学意义上讲。这就是为什么我们在本书中花费了大量时间研究市场基本面，并希望您能够在我们所考虑的大量事实中找到许多其他交易理念。
- en: So far, we have been working only with strategies that open new positions only
    either when the market position is zero or to reverse the currently open position.
    In this case, the edge of the strategy logic is in its ability to properly time
    entries and exits. However, there is a whole class of strategies that achieve
    an edge in managing multiple positions open in the same direction. In this case,
    we say that a strategy has an edge in terms of *money management*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用那些只在市场位置为零或需要反转当前开放头寸时才开新头寸的策略。在这种情况下，策略逻辑的优势在于其正确地把握进出时机。然而，存在一类策略，通过管理同一方向上的多个开放头寸来获得优势。在这种情况下，我们说策略在*资金管理*方面具有优势。
- en: Money management and multiple entries
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资金管理和多重入场
- en: To give you an idea about what money management is and how it may affect strategy
    performance, let me tell you about probably the most famous – or infamous – kind
    of money management technique, known as **martingale**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解资金管理是什么以及它可能如何影响策略表现，让我向您介绍可能是最著名或臭名昭著的资金管理技术，即**马丁格尔**。
- en: 'The origin of martingale is in gambling. Imagine the simplest gambling game
    of a coin toss. You toss the coin and if it comes up heads, you win; if it comes
    up tails, you lose. We can use `1` for wins and `-1` for losses and the series
    of tosses can be represented by a sequence as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁格尔的起源在于赌博。想象一下最简单的赌博游戏——抛硬币。你抛硬币，如果正面朝上，你赢；如果反面朝上，你输。我们可以用`1`表示赢，用`-1`表示输，投掷序列可以用以下序列表示：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you put at stake an equal amount of money each time you toss the coin, we
    can multiply the sequence by that amount and write it like so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你每次投掷硬币时都下注相同数量的钱，我们可以将序列乘以那个数量，并写成如下形式：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, `b` refers to the size of the bet. Obviously, your total win in the game
    is the sum of the entire series. In an idealistic model, the results of each toss
    are independent of each other, and the probability of the coin coming up as heads
    or tails is strictly 50%. Therefore in the long term, the sum of the series will
    always be around zero and there is no chance to win this game.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`b`指的是赌注的大小。显然，你在游戏中的总赢利是整个数列的和。在一个理想化的模型中，每次投掷的结果是相互独立的，硬币正面或反面的概率严格为50%。因此，从长远来看，数列的和将始终围绕零，没有赢得这个游戏的机会。
- en: 'The sum of this series is indeed zero. However, things change dramatically
    if you start using money management in form of a martingale. After each new loss,
    you double your stake, and after each new win, you reset the bet size to its initial
    value. Then, the sequence of wins and losses transforms into the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数列的和确实为零。然而，如果你开始使用马丁格尔形式的资金管理，情况将发生戏剧性的变化。每次新的亏损后，你将你的赌注翻倍，每次新的胜利后，你将赌注大小重置为其初始值。然后，胜负序列将转变为以下形式：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It’s clear that now the sum of the sequence is very far from zero; in our example,
    it is 5b. This means that by using money management, it is possible to win a game
    with outcomes of equal probability.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，现在序列的和与零相差甚远；在我们的例子中，它是5b。这意味着通过使用资金管理，有可能以等概率的结果赢得游戏。
- en: 'At first glance, the martingale looks like the ultimate method to win any game,
    but there are two pitfalls:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，马丁格尔似乎是一种赢得任何游戏的终极方法，但有两个陷阱：
- en: 'This method may work only in a game whose outcomes are truly independent. In
    the theory of probability, processes of this kind are called **stochastic** (see
    [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101), *Basics of Fundamental Analysis
    and Its Possible Use in FX Trading*). Financial time series are frequently considered
    in academic research to be stochastic, at least at the tick level, but we already
    know that there are certain moments and even relatively long periods when this
    is not true: for example, after the release of important economic news, it’s clear
    that upticks or downticks will prevail for some time, depending on the resonance
    of the news (see again [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101), *Basics
    of Fundamental Analysis and Its Possible Use in* *FX Trading*).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法可能只适用于结果真正独立的游戏。在概率论中，这类过程被称为**随机**（参见[*第6章*](B19145_06.xhtml#_idTextAnchor101)，*基本分析及其在FX交易中的可能用途*）。在学术研究中，金融时间序列通常被认为是随机的，至少在分笔级别上，但我们已经知道，在某些时刻甚至相对较长的时期，这并不成立：例如，在发布重要经济新闻后，很明显，上涨或下跌将占主导地位一段时间，这取决于新闻的共鸣（再次参见[*第6章*](B19145_06.xhtml#_idTextAnchor101)，*基本分析及其在*
    *FX交易* *中的可能用途*）。
- en: Even with a *pure* random walk process, the equal probability of outcomes is
    achieved only in long term (to be absolutely precise, only in an infinitely long
    series). If we analyze a short-term subsequence of outcomes, we may see a series
    of identical outcomes, and no one can guarantee that such a series will definitely
    end at a certain outcome number – exactly because the probability of a new outcome
    does not depend on previous outcomes! If you start with just $100 and double your
    stake with each loss, then you have to put ![](img/Formula_B19145_14_001.png)
    on the table after the n-th loss in a series. After the 3rd loss, you will have
    to bet $800, after the 4th loss, $1,600, and so on, and if you are so unlucky
    to face a series of 10 losses in a row, then you should call your bank and ask
    them to provide you with a credit line because now you have to bet $102,400!
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是**纯粹**的随机游走过程，只有在长期（为了绝对精确，只有在无限长的序列中）才能实现结果的等概率。如果我们分析结果的短期子序列，我们可能会看到一系列相同的结果，而且没有人能保证这样的序列一定会以某个特定的结果数结束——正是因为新结果发生的概率不依赖于先前结果！如果你最初只有100美元，每次亏损后都将赌注翻倍，那么在n次亏损后，你必须在桌面上放![](img/Formula_B19145_14_001.png)美元。在第三次亏损后，你将不得不赌800美元，在第四次亏损后，1600美元，以此类推，如果你不幸连续遭遇10次亏损，那么你应该打电话给你的银行，要求他们提供信用额度，因为现在你不得不赌102,400美元！
- en: I hope you understand why the martingale is so popular in books for illustrative
    purposes but *highly not recommended* for practical use.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能理解为什么马丁格尔策略在说明书中如此受欢迎，但在实际应用中却**高度不推荐**。
- en: In trading, there is a modification of the martingale known as **averaging down**.
    Let’s suppose that we opened a long position, but the market price went down.
    Instead of liquidating the position or just waiting until the price returns to
    the initial level, we open long new positions, increasing the trading size and
    moving the average entry price down. For example, if we originally opened a long
    position of 1 contract at 100.00 and then added another 1 contract at 90.00, then
    we actually have a position of 2 contracts opened at 95.00.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在交易中，有一种马丁格尔策略的变体，称为**平均下降**。假设我们开了一个多头仓位，但市场价格下跌。我们不会平仓这个仓位或只是等待价格回到初始水平，而是开立新的多头仓位，增加交易规模并将平均入场价格向下移动。例如，如果我们最初以100.00的价格开了一个1手的多头仓位，然后以90.00的价格再增加1手，那么我们实际上有一个在95.00的价格开立的2手仓位。
- en: Both the martingale and averaging may have only limited uses and normally, traders
    who use them in any form apply some restrictions to the maximum size of the open
    position.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁格尔策略和平均策略可能只有有限的用途，通常情况下，使用这些策略的投资者会对持仓的最大规模施加一些限制。
- en: 'Like many other authors, I used the martingale and averaging down for illustrative
    purposes: only because they give a very clear idea of what money management is
    about. There are more conservative money management strategies, and some of them
    are quite sophisticated. If you are interested in learning more about money management
    strategies and looking for a single source, I’d recommend the ultimate guide written
    by the money management guru Van Tharp, *Definitive Guide to Position Sizing Strategies*.
    If you have a more academic interest in the subject or are more inclined to collect
    information from various sources, I’d recommend starting with understanding the
    stochastic processes in general ([https://en.wikipedia.org/wiki/Stochastic_process](https://en.wikipedia.org/wiki/Stochastic_process))
    and random walks in particular ([https://en.wikipedia.org/wiki/Random_walk](https://en.wikipedia.org/wiki/Random_walk)),
    and then referring to a book by Ralph Vince, *The Mathematics of Money Management:
    Risk Analysis Techniques for* *Traders* ([https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387](https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387)).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '像许多其他作者一样，我使用马丁格尔策略和平均下降策略是为了说明目的：仅仅因为它们能非常清楚地说明资金管理是什么。还有更多保守的资金管理策略，其中一些相当复杂。如果你对学习更多关于资金管理策略感兴趣，并希望找到一个单一的资源，我推荐由资金管理大师范·瑟普撰写的终极指南，《**定位大小策略的终极指南**》（[Definitive
    Guide to Position Sizing Strategies](https://wiki.example.org/definitive_guide_to_position_sizing_strategies)）。如果你对这一主题有更学术的兴趣，或者更倾向于从各种来源收集信息，我建议从了解一般随机过程（[https://zh.wikipedia.org/wiki/随机过程](https://zh.wikipedia.org/wiki/随机过程)）和特定随机游走（[https://zh.wikipedia.org/wiki/随机游走](https://zh.wikipedia.org/wiki/随机游走)）开始，然后参考拉尔夫·文斯所著的书籍，《**金钱管理的数学：交易者的风险分析技术**》（[The
    Mathematics of Money Management: Risk Analysis Techniques for Traders](https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387)）。'
- en: To work with money management strategies, you should be very careful with the
    order size. Presently, we have worked only with strategies that open a position
    with a fixed size and then close it before opening a new one. If you increase
    the position by using multiple orders in the same direction, you should carefully
    calculate the order size when you try to liquidate a position. If you make a mistake,
    the strategy will leave one or more positions open, and this may highly adversely
    impact the strategy’s performance. So, generally, the order handling methods mentioned
    in this chapter are required for the correct implementation of money management
    strategies.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用资金管理策略，你应该非常小心地处理订单大小。目前，我们只与那些以固定大小开仓并在开新仓之前关闭的策略合作。如果你通过同一方向的多笔订单增加仓位，当你尝试平仓时，你应该仔细计算订单大小。如果你出错，策略可能会留下一个或多个未平仓的仓位，这可能会严重影响策略的表现。因此，通常情况下，本章中提到的订单处理方法对于正确实施资金管理策略是必需的。
- en: I would be happy to continue our discussions about the FX markets, systematic,
    and algo trading at the same level of detail as before, but unfortunately, the
    book’s size is limited, so I will just give you general guidelines on a few more
    important subjects for your own further studies. They are presented here as separate
    topics, without any evident logical connection between them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我很高兴继续我们关于外汇市场、系统交易和算法交易的讨论，但遗憾的是，本书的篇幅有限，所以我只能就一些更重要的主题提供一些一般性指导，供你自己进一步研究。它们在这里作为独立主题呈现，它们之间没有明显的逻辑联系。
- en: Strategy performance revisited – more metrics
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略性能回顾——更多指标
- en: In [*Chapter 13*](B19145_13.xhtml#_idTextAnchor215), *To Trade or Not to Trade
    – Performance Analysis*, we considered only the very basic performance metrics.
    Of course, there are many others that are no less important. I recommend starting
    with the nice overview from *Quantinsti* ([https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/](https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/)),
    implementing each metric in the code, and then you can analyze your strategies
    as market professionals do.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第13章*](B19145_13.xhtml#_idTextAnchor215)《交易还是不交易——性能分析》中，我们只考虑了非常基本的性能指标。当然，还有很多其他同样重要的指标。我建议从*Quantinsti*提供的良好概述开始（[https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/](https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/)），在代码中实现每个指标，然后你可以像市场专业人士一样分析你的策略。
- en: More about the risks specific to algo trading
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于算法交易特定风险的介绍
- en: 'We have already considered the main risks in any trading: operational, systemic,
    and transactional. Let’s highlight another kind of risk that is specific to algo
    trading.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了任何交易中的主要风险：操作风险、系统风险和交易风险。让我们强调另一种特定于算法交易的风险。
- en: When you develop and backtest a strategy using compressed data, along with limit
    or stop orders, there is a risk that more than one of these orders will be simulated
    on the same bar. Typically, this happens when the order prices are too close to
    each other and the data resolution is not granular enough. For example, if you
    place a limit and a stop order at a distance of 5 pips from each other and run
    a backtest using daily data, then on most days, both orders should be executed
    during a single bar. This is what you want to avoid at all costs because the backtester
    has no idea about how the price has actually moved inside this single bar and
    therefore no one knows which of the two orders will have been triggered first
    and which next. So, it is extremely important to correctly choose the data resolution
    so that the backtesting results are realistic.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用压缩数据开发和回测策略，并使用限价或止损订单时，存在一个风险，即这些订单中的多个可能会在同一根K线上被模拟。通常情况下，这发生在订单价格彼此过于接近且数据分辨率不够细粒度时。例如，如果你在彼此相距5个点的地方放置限价和止损订单，并使用每日数据运行回测，那么在大多数日子里，这两个订单都应该在同一根K线上被执行。这是你无论如何都要避免的事情，因为回测器根本不知道价格在这根K线内的实际移动情况，因此没有人知道哪两个订单会首先被触发，哪个会随后触发。因此，正确选择数据分辨率对于使回测结果真实至关重要。
- en: The rule of thumb for choosing the data resolution
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数据分辨率的经验法则
- en: Always choose the data resolution for which the average range of a bar (the
    difference between a bar’s high and low values) is less than the distance between
    order prices. If you place limit or stop orders of 100+ pips, then you can use
    daily data. If you use limit or stop orders of 20+ pips, then most likely, a timeframe
    of 30 minutes may work. If you use tight stops or limits, as in the previous example,
    then a 1-minute resolution is the way to go. Remember that only testing using
    tick data can give you the ultimately correct picture, although this kind of backtest
    will take a lot of time.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 总是选择一个柱状图平均范围（柱状图的高值和低值之间的差）小于订单价格之间距离的数据分辨率。如果你放置100+点数的限价或止损订单，那么你可以使用日数据。如果你使用20+点数的限价或止损订单，那么可能30分钟的时间框架会工作。如果你使用像前一个例子中的紧止损或限价，那么1分钟分辨率是最佳选择。记住，只有使用tick数据进行测试才能给出最终正确的画面，尽管这种回测会花费很多时间。
- en: Classical technical trading setups
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典技术交易设置
- en: 'In [*Chapter 7*](B19145_07.xhtml#_idTextAnchor114), *Technical Analysis and
    Its Implementation in Python*, we considered a number of classical technical analysis
    indicators, such as the RSI, a stochastic oscillator, moving averages, and Bollinger
    bands. We saw that each of these indicators is able to bring into focus a certain
    property of the price time series: for example, Bollinger bands are a volatility
    indicator, and moving averages are digital filters that remove higher frequencies
    from the price data. However, we didn’t consider any classical trading setup with
    any of these indicators. Why?'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第七章*](B19145_07.xhtml#_idTextAnchor114)《技术分析及其在Python中的应用》中，我们考虑了多个经典的技术分析指标，例如RSI、随机振荡器、移动平均线和布林带。我们看到了每个指标都能聚焦于价格时间序列的某个特定属性：例如，布林带是波动性指标，而移动平均线是去除价格数据中高频的数字滤波器。然而，我们没有考虑任何经典交易设置与这些指标的结合。为什么？
- en: The answer to this question is twofold. First, these setups can be found in
    literally any book or internet publication about technical analysis. You can start
    with an overview of technical indicators at Investopedia ([https://www.investopedia.com/terms/t/technicalindicator.asp](https://www.investopedia.com/terms/t/technicalindicator.asp))
    and then follow the links to articles on specific indicators to see how they are
    supposed to be used to generate trading signals.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案有两个方面。首先，这些设置可以在任何关于技术分析的书或网络出版物中找到。你可以从Investopedia（[https://www.investopedia.com/terms/t/technicalindicator.asp](https://www.investopedia.com/terms/t/technicalindicator.asp)）上的技术指标概述开始，然后通过链接到特定指标的文章来了解它们应该如何被用来生成交易信号。
- en: The second and more important reason we don’t go into detail on these classical
    setups here is that none of them can create a profitable trading strategy as they
    are. You can try building a simple strategy by implementing any of the classical
    setups, then run it in multiple markets using different data resolutions, and
    you will see that unfortunately, none of the combinations deliver anything that
    could be considered satisfactory performance.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不深入探讨这些经典设置的第二和更重要的原因是，它们中的任何一个都无法直接创造出盈利的交易策略。你可以尝试通过实施任何经典设置来构建一个简单的策略，然后在多个市场使用不同的数据分辨率运行它，你会发现不幸的是，没有任何组合能够提供令人满意的表现。
- en: Why does this happen? And does it mean that technical analysis indicators are
    useless for practical trading?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？这难道意味着技术分析指标对实际交易没有用吗？
- en: This happens because all of the classical indicators were developed to highlight
    specific processes that took place in specific markets at a specific time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为所有经典指标都是为突出特定市场在特定时间发生的特定过程而开发的。
- en: For example, Welles Wilder, the creator of the RSI, developed this indicator
    when he traded commodity futures back in the 1970s. At that time, the market was
    relatively illiquid and was open for only a few hours a day. Only select traders
    had access to it and trades were placed either in the pit or by phone – and this
    is what commodity futures markets used to be in the 1970s. On the contrary, the
    present-day FX market is open 24/7 and is full of liquidity, with many diverse
    kinds of market participants, from big banks to retail traders. Its computerized
    ordering can process thousands of transactions per second. Compare these two markets
    and you will understand why the indicators of the old days may not indicate what
    they are supposed to.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，RSI的创造者Welles Wilder在20世纪70年代进行商品期货交易时开发了这一指标。当时，市场相对流动性较差，每天只开放几个小时。只有少数交易者可以访问它，交易要么在交易池中进行，要么通过电话进行——这就是20世纪70年代的商品期货市场。相反，现在的外汇市场全天24小时开放，流动性充足，市场参与者种类繁多，从大型银行到零售交易者。其计算机化订单可以每秒处理数千笔交易。比较这两个市场，你就会明白为什么旧日的指标可能无法指示它们应该指示的内容。
- en: The answer to the second question – whether classical technical indicators are
    useless these days – is negative. We still can use any or all of these indicators
    *if we understand what exactly they show us*. That’s why I tried to focus on their
    meaning rather than just listing the well-known use cases, such as moving averages
    crossover (see [https://www.investopedia.com/terms/c/crossover.asp](https://www.investopedia.com/terms/c/crossover.asp))
    or overbought/oversold zones identified with the RSI or a stochastic oscillator
    (see [https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp](https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个问题——是否古典技术指标在当今已经无用——的回答是否定的。如果我们理解它们确切显示的内容，我们仍然可以使用这些指标中的任何一个或全部。这就是为什么我试图关注它们的含义，而不仅仅是列出众所周知的用例，例如移动平均线交叉（见[https://www.investopedia.com/terms/c/crossover.asp](https://www.investopedia.com/terms/c/crossover.asp)）或通过RSI或随机振荡器确定的超买/超卖区域（见[https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp](https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp))）。
- en: Nevertheless, despite the present-day electronic FX markets being very different
    from good old pit-traded futures markets, I would highly recommend reading the
    classic books written by the creators of technical indicators – because, in these
    books, they explain *why they suggested* a particular indicator, *which market
    process* they tried to identify using an indicator, and *how we are supposed to
    profit* from the suggested setups.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在的电子外汇市场与过去良好的场内交易期货市场大不相同，但我强烈推荐阅读由技术指标创造者撰写的经典书籍——因为在这本书中，他们解释了*为什么建议*使用特定的指标，*他们试图通过指标识别哪种市场过程*，以及*我们如何从建议的配置中获利*。
- en: Spending a couple of days on thorough reading may be way more valuable than
    wasting weeks and months trying to fit a particular well-known technical trading
    setup to a market that it simply doesn’t fit by nature. I can recommend starting
    with a classic by Welles Wilder Jr., *New Concepts in Technical Trading Systems*,
    in which he carefully explains *how he noticed certain potentially profitable
    market processes*, *how he tried to formalize them*, *how he eventually came to
    a set of technical indicators*, and *how he actually used them to make profits*.
    Focus on this *mental process*, not just the numbers, and you will develop a way
    better understanding of the process of developing a trading strategy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在彻底阅读上花费几天时间可能比试图将一个特定的知名技术交易设置拟合到一个本质上不适合市场的市场上浪费几周和几个月的时间更有价值。我可以推荐从Welles
    Wilder Jr.的经典著作《技术交易系统的新概念》开始，其中他仔细解释了*他是如何注意到某些可能有利可图的市场过程的*，*他是如何尝试使它们形式化的*，*他最终形成了一套技术指标*，以及*他实际上是如何使用它们来获利的*。专注于这个*心理过程*，而不仅仅是数字，你将更好地理解制定交易策略的过程。
- en: Keep in mind that behind any formula and any code, there should stand a trading
    idea, and trading ideas can be found only in the analysis of markets, not in crunching
    numbers or fitting an irrelevant model to the market. In the next section, we
    will see why excessive fitting may not only be counterproductive but also dangerous.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，任何公式和任何代码背后都应有一个交易理念，而交易理念只能通过市场分析找到，而不是在数字处理或将不相关的模型拟合到市场上。在下一节中，我们将看到过度拟合不仅可能适得其反，而且可能危险。
- en: Optimization – the blessing and the curse of algo trading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化——算法交易的祝福与诅咒
- en: Do you remember how the performance of a simple overnight strategy that we created
    earlier in this chapter radically changed when we replaced a tight stop of 5 pips
    with a wider stop of 50 pips?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在这章早期创建的一个简单隔夜策略的表现，当我们将5点的紧止损替换为50点的宽止损时，其表现是如何彻底改变的吗？
- en: 'But this fact raises another important question: why 5 and 50 pips? Why not
    6 and 45? Or 10 and 76?'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个事实又提出了另一个重要问题：为什么是5点和50点？为什么不是6点和45点？或者10点和76点？
- en: Any quantitative strategy depends on the values of its parameters, and the procedure
    of finding the best combination of parameters that delivers the best results of
    the backtesting is called **optimization**.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 任何量化策略都依赖于其参数的值，而寻找最佳参数组合以获得最佳回测结果的过程被称为**优化**。
- en: 'Optimization is a massive topic. I’d even say it’s overwhelmingly vast and
    complex. At first glance, it looks straightforward: let’s find the best combination
    of parameter values and then run the strategy live with these very values. However,
    the problem is that we always test and optimize our strategies using past data.
    And I hope you already understood and remember well that markets are anything
    but stationary processes. This means that the price behavior may change in the
    future, and the same strategy with the same *best* combination of parameters will
    start losing money.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是一个庞大的主题。我甚至可以说它非常庞大且复杂。乍一看，这似乎很简单：让我们找到最佳参数值的组合，然后使用这些值实时运行策略。然而，问题在于我们总是使用过去的数据来测试和优化我们的策略。我希望你已经理解和很好地记住了市场根本不是平稳过程。这意味着价格行为可能会在未来发生变化，并且使用相同参数组合的相同*最佳*策略将开始亏损。
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A situation in which a strategy has been optimized using insufficient data or
    inappropriate logic and then starts losing money in live trading is known as **overfitting**
    or **curve fitting**. This is considered to be the plague of all algo trading
    and the reason why many discretionary traders are still skeptical about it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个策略使用不足的数据或不适当的逻辑进行优化，然后在实盘交易中开始亏损的情况被称为**过度拟合**或**曲线拟合**。这被认为是所有算法交易中的瘟疫，也是为什么许多交易员仍然对其持怀疑态度的原因。
- en: How to mitigate this specific risk?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如何减轻这种具体风险？
- en: There are various workarounds, **forward testing** probably being the most popular.
    When running a forward test, we first optimize the strategy parameters using only
    a subset of the entire past market data and then generate the performance report
    for backtesting, run on another subset of data. For example, if we have data from
    2015 to 2023, then we may want to optimize the strategy using data from 2015 to
    2017 and then test using data from 2018 to 2023\. The backtest using the first
    subset is then called **in-sample** and the backtest using the second subset is
    called **out-of-sample**. If the out-of-sample strategy demonstrates performance
    comparable to that of the in-sample, we can estimate that it will continue working
    even in the future (although in reality, things may be far more complex).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种解决方案，**前向测试**可能是最受欢迎的。在进行前向测试时，我们首先使用整个过去市场数据的一个子集来优化策略参数，然后为回测生成性能报告，在另一个数据子集上运行。例如，如果我们有2015年到2023年的数据，那么我们可能希望使用2015年到2017年的数据来优化策略，然后使用2018年到2023年的数据来测试。使用第一个子集进行的回测被称为**样本内**回测，使用第二个子集进行的回测被称为**样本外**回测。如果样本外策略的表现与样本内策略相当，我们可以估计它将在未来继续有效（尽管在现实中，事情可能要复杂得多）。
- en: Another approach is to make a forward test only on a relatively small amount
    of out-of-sample data, then re-optimize the strategy using newer data, and repeat
    the forward test on another, newer portion of out-of-sample data, and so on. In
    our example, we can perform a forward test optimizing the strategy using data
    from 2015 to 2017, then run a forward test on 2018 only, then re-optimize the
    strategy using data from 2016 to 2018, run a forward test on 2019, and so on.
    Such an approach is called **walk-forward optimization**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是仅对相对少量的样本外数据进行前向测试，然后使用新数据重新优化策略，并在另一个新的样本外数据部分上重复前向测试，依此类推。在我们的例子中，我们可以使用2015年到2017年的数据来优化策略，然后仅对2018年进行前向测试，然后使用2016年到2018年的数据重新优化策略，对2019年进行前向测试，依此类推。这种方法被称为**前向优化**。
- en: As you may have already realized, optimization is an extremely resource- and
    time-consuming process. Indeed, we need to run a backtest with one set of parameter
    values, then save the result, modify the parameters, run a backtest again, and
    repeat. In our sample strategy, if we wanted to find the best values for the stop-loss
    and profit target between 5 and 50 pips with a step of 5 pips, it would require
    100 runs of the entire backtest, which would take hours on most computers. That’s
    why optimization algorithms are mostly developed using compiled versions of Python,
    such as Cython or Numba.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所可能已经意识到的，优化是一个极其耗费资源和时间的流程。确实，我们需要使用一组参数值运行回测，然后保存结果，修改参数，再次运行回测，并重复这个过程。在我们的样本策略中，如果我们想要在5到50点之间，以5点的步长找到最佳止损和盈利目标值，这将需要运行整个回测100次，这在大多数计算机上可能需要数小时。这就是为什么优化算法大多数情况下都是使用Python的编译版本开发的，例如Cython或Numba。
- en: If you are interested in developing a true understanding of optimization, I’d
    recommend starting with the concise yet nice introduction by Davide Scassola at
    *Triality* ([https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies](https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies))
    and then reading Robert Pardo’s book, *The Evaluation and Optimization of Trading*
    *Strategies* ([https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011](https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要真正理解优化，我建议从Davide Scassola在*Triality*上简洁而优美的介绍开始，阅读[《优化算法在交易策略中的应用介绍》](https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies)，然后阅读Robert
    Pardo的书籍，《交易策略的评估与优化》*策略*([https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011](https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011))。
- en: Final words
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的话
- en: 'Well, any story comes to an end sooner or later, and this book is no exception.
    Even if you opened it with no idea about FX markets and algo trading, now you
    have definitely taken yourself to a new level. You have knowledge about FX markets
    comparable to that of a beginner professional desk trader. You know how to develop
    trading applications for both live trading and producing reliable backtests. You
    also know the risks pertaining to trading, for algo trading in particular. You
    have plenty of roads to go down — in terms of money management, performance analysis,
    and optimization – but there is one thing I really want you to always remember
    whatever you do:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，任何故事迟早都会结束，这本书也不例外。即使你一开始对FX市场和算法交易一无所知，现在你无疑已经提升到了一个新的水平。你对FX市场的了解与初出茅庐的专业交易员相当。你知道如何开发用于实时交易和生成可靠回测的交易应用。你还了解与交易相关的风险，特别是算法交易的风险。你有许多道路可以选择——在资金管理、性能分析和优化方面——但有一件事我真心希望你无论做什么都始终记住：
- en: Any good trading strategy always has a trading idea behind it. No sophisticated
    mathematics, no money management, and no optimization will help if the strategy
    is just a randomly chosen combination of technical analysis studies and parameters.
    Look for ideas in the market and use the mathematical and programming apparatus
    to implement, test, and run them – without fear or greed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 任何好的交易策略都一定有其背后的交易理念。如果策略只是随机选择的技术分析和参数的组合，那么再复杂的数学、再好的资金管理或再优化的算法都无法帮助。在市场中寻找灵感，并使用数学和编程工具来实施、测试和运行它们——不要害怕或贪婪。
