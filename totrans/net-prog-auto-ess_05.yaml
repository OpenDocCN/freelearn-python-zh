- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dos and Don’ts for Network Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing code for networks is exciting because when it fails, it is challenging,
    and when it works, it is rewarding. If you are an experienced programmer, you
    will have an easier ride, but if you are a newbie, it will be stormy. Let’s dive
    into some coding practices that will help you get through these storms easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to focus on this chapter on coding aspects for Python and Go related
    to network programming. The subject covered here would be also good for any type
    of programming; however, we are going to focus on programming for networks, and
    these are the topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Coding topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying best practices in coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding formatters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning and concurrent development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you should be familiar with coding terms used by
    the community and which of them matter most. You will be able to understand coding
    best practices and how to become a better network code developer. If you are an
    experienced coder, it will be a good refresh. If you are new, this chapter will
    be your mantra when writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing code used to be very simple and straightforward; it only required the
    ability to understand a program’s workflow, its performance, and its algorithms.
    But today, the story is a bit different. Coding now has a culture that has evolved
    in the last few decades. What matters most is the code’s reusability and, therefore,
    its style. To be reusable, code has to be easy to understand and should have few
    or no bugs or security issues.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to coding, or network coding, it is important to know all the
    topics used in coding culture today. Let’s discuss briefly the most important
    ones in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Peer review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not recommended to write code and publish without a **peer review**. Peer
    review allows the coder to be consistent with the team and avoid undesirable mistakes.
    However, for most organizations, this process can be slow and sometimes expensive.
    One alternative is to use software robots that can perform most of the peer review
    that was once done by another software engineer.
  prefs: []
  type: TYPE_NORMAL
- en: A peer review is a conscious and objective review done by another developer
    that has the objective of checking team standards, language standards, and community
    best practices, sharing knowledge, verifying code repetition and name convention,
    and aligning design with implementation, among others. As the list is long, the
    peer review process is not an easy and straightforward job; it sometimes takes
    longer to review the code than to write it.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to keep track of your code by measuring and storing the date
    of creation, compilation (if any), and distribution. This is done by having some
    sort of life-cycle management. With a life cycle, it is possible to trigger actions
    to go back to the source code and verify whether the current recommendations are
    still valid on the source code, and also check whether there is any new security
    vulnerability. There are tools that do life-cycle management automatically to
    your code base and your applications; use them when possible.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In computer programming, **refactoring** (or **code refactoring**) is the term
    used to change the code without changing its external behaviors in terms of output
    and input. Refactoring can be used to fix bugs, improve performance, remove security
    vulnerabilities, or comply with new code styling. The important thing here is
    that refactoring does not change the features of the code. In other words, the
    external behavior, inputs, and outputs are preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Check more on code refactoring on the site [https://refactoring.guru/](https://refactoring.guru/).
  prefs: []
  type: TYPE_NORMAL
- en: Copying code and licensing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you should do before publishing your code is to think about
    the **copyright** and **code license**. Why? Because if your code is good, it
    will definitely be reusable by someone else or will be copied for other purposes,
    unless you strictly specify the rules of copying on the license document. In addition,
    if you are importing or using external libraries, you might be compromised by
    copyright issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, it is important to create appropriate license documents and read
    the license documents of the code you are using or copying. The types of licenses
    that are attributed to software are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trade secret licenses**: No information made public; private internal usage;
    unpublished'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proprietary licenses**: Have copyrights; no public licenses and no source
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noncommercial licenses**: Used for noncommercial use and no source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copyleft licenses**: Grant use rights; forbids relicensing and public source
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissive licenses**: Grant use rights; allows relicensing and public source
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public domain licenses**: All possible grants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we care about these types of licenses? Because you are not supposed to
    distribute or publish the software you are working on. You could receive legal
    penalties and fines for breaching the license agreement on the code you are creating
    locally at your company. Most of the time, you are probably going to reuse someone
    else’s library or code into a major piece of software. Before using an external
    library or code, the best way is to consult the legal department and check whether
    there are any licenses that are forbidden for use internally.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, it is recommended when writing code to check the license disclaimer
    document provided. It is normally located in the root directory of the source
    code, in capital letters, with names such as `LICENSE` or `LICENSE.rst`, but sometimes
    `COPYRIGHT`, `COPYING`, or something similar is used to express the copy grants.
  prefs: []
  type: TYPE_NORMAL
- en: For open source, the code also can rely on rules defined by definitions created
    by other entities; to do that, you just need to read the `LICENSE` file and check
    which one is applied. One of the most used ones in open source code is the **MIT
    License**.
  prefs: []
  type: TYPE_NORMAL
- en: Before using the open source library or copying it into your code, make sure
    the license does not present a risk to your organization. The open source code
    that presents the most risk when reusing it in private organizations is **GPL
    2.0** and **GPL 3.0** (**GNU General Public License**). The low-risk ones are
    **MIT License**, **Apache License 2.0**, and **BSD License 2.0**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the top five most used licenses in projects at GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Rank** | **License** | **% of projects** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | MIT | 44.69 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Other | 15.68 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | GLP 2.0 | 12.96 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Apache | 11.19 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | GLP 3.0 | 8.88 |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Rank of the most used licenses in GitHub projects
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the evolution of GitHub project licenses from
    2008 to 2015\. Note the growth of MIT licenses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – License usage in GitHub projects (source: github.blog)](img/B18165_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1 – License usage in GitHub projects (source: github.blog)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with the most popular code licenses, let’s progress
    with discussing code quality and perception.
  prefs: []
  type: TYPE_NORMAL
- en: Code quality and perception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Code quality** is a term normally heard among software engineers, but to
    be very clear, it is not an easy subject, and the definition of quality is normally
    subjective and prone to personal preferences.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid such an ambiguous definition, code quality should focus on team or
    company guidelines and standards. If the company that you have just started has
    loose or no code guidelines, the code *quality* probably relies on the senior
    engineer. But that must—and should—be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Code quality should be measured by using standards and code practices, not by
    a person. If there are no standards or code practices in your team, use this chapter
    to guide you while creating one.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining the quality of the code, try to use measurable metrics that will
    allow software engineers to understand poor quality without taking it personally.
    Look for the following characteristics in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**: Measure how many times the code runs without failures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Measure how easily the code can be changed, including
    size, complexity, and structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: Measure how the code can be controlled, observed, and isolated
    to create automated testing such as unit tests (which will be discussed in the
    *Testing your code* section later in this chapter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: How easily the code can run in different environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: Measure how the code can be reused by dependencies or by copying'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When possible, use automated tools that can classify and format the code, which
    avoids personal subjective analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture and modeling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software architecture and design is a very long and wide topic. Depending on
    the size of your project, you might not need to do a design or architecture when
    working with network automation code. However, it is important to know they exist
    and can be used effectively to have a better code structure and better organization.
  prefs: []
  type: TYPE_NORMAL
- en: I would suggest that the most important part of software architecture is the
    modeling, which helps a lot in the early stages to validate the structure and
    the organization of the code. Communication with a model is easy with customers
    and can be understood even if you are not a software developer.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular used models are **Unified Modeling Language** (**UML**) as
    generic, **Systems Modeling Language** (**SysML**), a subset of UML, **Service-oriented
    architecture Modeling language** (**SoaML**), also a subset of UML, and the **C4
    model**. It does not matter which one you will choose; using any model before
    you start coding will help you to get the code right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the deployment pipeline described in [*Chapter 4*](B18165_04.xhtml#_idTextAnchor100)
    as an example to create a software model of the solution. *Figure 5.2* illustrates
    how it would be a very simple model for the deployment pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Deployment pipeline software model example described in Chapter
    4](img/B18165_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Deployment pipeline software model example described in [Chapter
    4](B18165_04.xhtml#_idTextAnchor100)
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates, using arrows and boxes, how a developer would
    tackle the problem of constructing a deployment pipeline. The inputs are the router
    definition and templates, then a configuration render creates the configuration
    and stores it at the desired state. The syntax is checked, and then the running
    config is verified if it is equal to `applied`. If not, it stops and waits for
    manual intervention; if it is okay, then launch a network simulation. Then, all
    tests are done. If the tests are passed, update the approved configs. The next
    step is to apply the configuration to the routers, and if it is applied correctly,
    then update the `applied` configs.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed in this section a few code culture topics that are used nowadays
    within the developing community. In the next section, we are going to dive into
    what the best practices are for writing code for Python and Go.
  prefs: []
  type: TYPE_NORMAL
- en: Applying best practices in coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are points that are not necessarily standards, but they are important when
    we are writing code for networks.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the '90s, the internet was starting to grow fast, and programmers started
    to become more present in the community. Shell scripting started to grow as a
    viable tool to help system engineers work with their servers. Then came **Perl**
    as a powerful scripting language to help as well. Other languages were also mature,
    such as C, C++, and Java. But every developer wrote differently with their own
    style, which did not help code collaboration and made sharing code a disaster.
    When Python was created, the coding style problem already existed. Something had
    to be done to avoid confusion when sharing code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check now what the standards are for Python and Go languages.
  prefs: []
  type: TYPE_NORMAL
- en: Python standard style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python can be written in so many different ways. If you are an old programmer,
    you would remember Perl, which was a scripting language like Python but without
    any particular style, which was a mess. There are documents that help programmers
    to write better code in Python. The documents are created by the Python community,
    and they are called **PEPs**, which stands for **Python Enhancement Proposals**.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, the PEP process was created to propose and discuss consensus on new
    features, but it is also used to document information. A PEP is similar to an
    internet **Request For Comments** (**RFC**) for Python, and when describing new
    features, it has to contain a description of the feature in detail and a rationale
    for the creation of it.
  prefs: []
  type: TYPE_NORMAL
- en: When proposing new features for Python, the writer is responsible for building
    consensus within the community, describing different options, collecting input
    from the community, and documenting it.
  prefs: []
  type: TYPE_NORMAL
- en: Some PEPs are informational and are basically used to guide Python coding style.
    If you are planning to become a Python code developer, a PEP is like your daily
    journal to check and read. It is important to keep updated with the latest PEP
    and make sure your code follows the recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: So far, there are a few useful PEPs to help the community with guidance and
    best practices on how to write code with Python. Let’s check the most important
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code with the guidance of PEP-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*PEP-8* is perhaps the most important PEP you have to read if you are new to
    Python because it describes in detail all styles and conventions when writing
    code in Python. Although the language does not force you to select a style when
    writing, using *PEP-8* (or *PEP8*) will make your code easy to understand for
    anyone in the Python community.'
  prefs: []
  type: TYPE_NORMAL
- en: When you are new to Python, it might be difficult to remember what a part of
    the code you wrote weeks or a few days ago was supposed to do. However, if you
    follow *PEP-8*, you can be sure that you have named your variables well, you have
    added enough whitespace, and you have commented your code well. Following these
    guidelines will make your code more readable for others and for you when coming
    back to read after a while. Beginners will also learn Python much faster and with
    ease when following *PEP-8*.
  prefs: []
  type: TYPE_NORMAL
- en: The *PEP-8* document is very clear; it shows a wrong code style and then a correct
    style with an explanation of why to use that style.
  prefs: []
  type: TYPE_NORMAL
- en: Go standard style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before describing the standards in the Go language, it is important to note
    that Go is also known as `golang.org`. Now, the Go language is hosted on `go.dev`.
  prefs: []
  type: TYPE_NORMAL
- en: Go is quite different from Python in terms of code formatting and style. Go
    does not have PEP-like documents to point out how to write better code in Go.
    So, the style standard relies mostly on the internal formatting tool, called `gofmt`,
    which is responsible for formatting the source code in a predictable way.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `gofmt` formatter can be skipped, it is highly recommended to use
    it as soon as you change something in your code and before publishing it. Some
    tools will run the formatter automatically before running or compiling your Go
    program. In addition to `gofmt`, there are Go **linters** that can point out style
    errors or suspicious constructions; we are going to describe these in the *Coding
    formatters* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the Go community has published several guidelines that help with
    writing better code. Here is a list of the best ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/uber-go/guide/blob/master/style.md](https://github.com/uber-go/guide/blob/master/style.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/dgryski/awesome-go-style](https://github.com/dgryski/awesome-go-style)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://staticcheck.io/docs/checks/](https://staticcheck.io/docs/checks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mindful code writing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time, we are going to be reading code instead of writing because
    the process of writing code drives you to read other parts of the code. So, you
    know where your code goes, how your code follows the existing design, and the
    behaviors the existing code has so that it doesn’t crash. The important point
    here is, even if you have no intention to share your code with anyone else, it
    will be probably forgotten by you in a few months, and if you might need to update
    it, you will have a hard time understanding what it does. So, write always thinking
    about someone reading it, even if this is just you.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the process of writing code must be much more mindful than the process
    of reading. When someone reads part of the code, it should not create any doubts;
    it should be straightforward and easy, and quick to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: Making it extremely readable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing code, don’t save words or phrases. If you have the opportunity
    to choose a mistake when writing your code, choose the one that over-explains
    your code. Why? Because your code should be understandable by anyone, and that
    includes you, in a few months or years. Therefore, make sure your code is easy
    to understand and easy to follow by someone new.
  prefs: []
  type: TYPE_NORMAL
- en: Commenting your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code should be clear to understand; however, sometimes, it is necessary
    to comment on your code to help readers and reviewers understand your code. You
    should add comments throughout the code when you want to emphasize nuances in
    your code, describe details of some algorithms, or warn the reader about something
    odd.
  prefs: []
  type: TYPE_NORMAL
- en: Comment headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some text headers in comments are used to help the reader avoid spending time
    on code that should or might be changed. When you start coding with your team,
    check which terms are used for helping code readers and code reviewers. The comment
    headings listed here are not fixed and change between organizations and teams.
    Here are the most popular comment headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TODO`: Perhaps the most common comment used is `TODO`, which is used to designate
    part of the code that needs to be added or refactored. This comment helps the
    reviewer avoid spending time reviewing a chunk of code that needs to be modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIXME`: Some developers when writing code also use the `FIXME` comment heading,
    which designates the part of the code that is wrong, ugly, has performance issues,
    or is too complicated. Use `FIXME` when you know something is wrong and should
    be fixed soon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HACK`: This text heading is used to designate part of the code that has a
    workaround to fix a bug or to help performance. The `HACK` heading is also another
    important comment to show the reader a quick workaround to be fixed later, helping
    them understand why that part of the code is there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUG`: This heading is used to show a problem in the code, which must be fixed
    soon. The author has identified the problem and decided to comment on that part
    of the code as a bug. The code reviewer can then evaluate and decide whether they
    have to accept the code with the bug or ask for corrections. Again, these comments
    save the time of the reviewer as they do not need to evaluate that part of the
    code in depth. Use this whenever you see a problem in the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOTE`: This heading is for the author to communicate with the readers some
    notable gotchas or particular details to help readers understand the code faster.
    Use them wisely to help reviewers understand, as too many `NOTE` headings can
    also be annoying and create a distraction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docstring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A docstring refers to a comment string that is used in Python to describe a
    module, function, class, or method. Docstrings are particular to Python and are
    detailed in *PEP-257*.
  prefs: []
  type: TYPE_NORMAL
- en: Some **integrated development environments** (**IDEs**) such as PyCharm and
    IntelliJ will automatically create a docstring for you as soon as you define a
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a multiline docstring for a Python function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the docstring is always initiated and ended with triple-double quotes
    (`"""`). The preceding example is a suggestion and other styles are possible.
    To visualize all possible styles, read the docstring conventions in *PEP-257*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Docstring documentation can be found at [https://peps.python.org/pep-0257/](https://peps.python.org/pep-0257/).
  prefs: []
  type: TYPE_NORMAL
- en: Godoc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Go, there is g`odoc`, which is simpler than a docstring as it is not a language
    construct or machine-readable syntax; it is just string text comments. The convention
    is simple: to document a variable, function, package, or constant, just write
    comments directly before its declaration. Here is an example of the comments used
    for the `Asin` function in the Go `math` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this example, the comments are placed before the `Asin` function,
    and they describe in detail what to expect with the function and its special cases.
    Comments are always text that starts with a double slash (`//`).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example was taken from the Go source code at [https://github.com/golang/go/blob/master/src/math/asin.go#L14-L25](https://github.com/golang/go/blob/master/src/math/asin.go#L14-L25).
  prefs: []
  type: TYPE_NORMAL
- en: After commenting your code in Go, add explanations on functions such as in the
    preceding example. Developers can use the `godoc` tool, which extracts text and
    generates documentation in HTML or TXT format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `godoc` documentation is available at [https://pkg.go.dev/golang.org/x/tools/cmd/godoc](https://pkg.go.dev/golang.org/x/tools/cmd/godoc).
  prefs: []
  type: TYPE_NORMAL
- en: Use IP libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Newbies in programming for networks may think IP addresses can be treated as
    a string or a list of characters. But when dealing with networks, it is very important
    to use the correspondent IP library to load an IP from a text file or to create
    one from a loop. There are several reasons you might want to avoid strings for
    IPs; some are presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid numbers that are out of the scope of an IP, such as the number 256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid malformed text IP addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure not to overlap other space addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to find the network, mask, and broadcast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy transition from IP version 4 to IP version 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s check how to use these IP libraries in Python and Go.
  prefs: []
  type: TYPE_NORMAL
- en: IP libraries in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IP address library in Python did not exist natively until version 3.3\.
    Before version 3.3, Python coders had to use external libraries to handle IP addresses.
    Python had to incorporate this library internally after realizing its importance.
    The transition was documented in *PEP-3144* ([https://peps.python.org/pep-3144/](https://peps.python.org/pep-3144/)).
  prefs: []
  type: TYPE_NORMAL
- en: Examples of IP manipulation using Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, let’s print all valid IP addresses in a subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output type is `IPv4Address` and not a string. The `ipaddress.ip_network()`
    method automatically detects whether it is an IPv4 or IPv6 address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s print the subnets that exist in a larger subnet, excluding one subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that the type on the output is not an IP address type as it was before,
    but a network type called `IPv4Network`.
  prefs: []
  type: TYPE_NORMAL
- en: IP libraries in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go is different from Python as IP address libraries came after the Go language’s
    first version. IP manipulations in Go are faster than in Python because Go is
    not interpreted like Python but compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of IP manipulation using Go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Go, we are first going to check whether an IP address belongs to a subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output: `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `10.8.8.22` IP address does not belong to the `10.8.8.0/29` subnet as the
    program prints `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example checks whether a subnet belongs to another subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output: `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `first_subnet` belongs to `second_subnet`, so they overlap.
    Note that in this example, we used a `"net/netip"` import instead of `"net"`,
    which is a newer IP manipulation package introduced to the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of comparison, the Python built-in library has more features for IP
    manipulation than the built-in Go IP packages. On the other hand, Go can manipulate
    IPs faster.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for particular features for IP manipulation that are not
    present in `net` or `net/netip`, you can use a newly developed community package
    called `inet.af/netaddr`, described at [https://pkg.go.dev/inet.af/netaddr](https://pkg.go.dev/inet.af/netaddr).
  prefs: []
  type: TYPE_NORMAL
- en: Follow naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is wise to verify with your team what the local development name conventions
    are before starting to publish any code for review. There are particular differences
    that might be a problem to use in your organization. Here, we are going to describe
    the most popular name conventions used, but feel free to adapt this to your local
    team culture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting to describe the name conventions, let’s define three ways of
    writing multi-word names, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`myFirstTestName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyFirstTestName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_first_test_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of defining constants, all characters in the name must be in uppercase
    for most programming languages. Therefore, snake case is used always in lowercase,
    unless the name is describing a constant. Here’s an example of a name describing
    a constant that will define the maximum storage capacity: `MAX_STORAGE_CAPACITY`.'
  prefs: []
  type: TYPE_NORMAL
- en: Naming in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Python, there are a few rules to follow when writing variable names. Here
    is a short list of what to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable names can start only with letters or underscore characters (`_`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable name can only have alphanumeric characters and underscores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never start a variable name with a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashes (`-`) are used only for package and module names, never for variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double underscore characters starting in variables are reserved for Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use pascal case for class names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use snake case for module names and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants in Python use all uppercase characters—for example, `MYCONSTANT`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Google has a created a great name convention guide for Python, available publicly
    at [https://google.github.io/styleguide/pyguide.html#316-naming](https://google.github.io/styleguide/pyguide.html#316-naming).
  prefs: []
  type: TYPE_NORMAL
- en: Naming in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Go, there are a few rules to follow. Here is a list of the major ones to
    follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable names use camel case or pascal case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with variable names, function names use camel case or pascal case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable or function names don’t start with a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use only alphanumeric characters for variable and function names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashes or underscores are normally not used for names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go allows the use of snake case for variable names, but check whether your organization’s
    name convention allows it, because it is not common to use snake case in the Go
    community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constants in Go are like in Python: use all uppercase characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, Go has a particular difference from other languages, and uses uppercase
    in the variables inside a Go package (or module). So, if the variable name starts
    with uppercase, it is normally a variable that can be accessed from outside the
    Go package. When the variable starts with lowercase, it’s a local variable that
    is only accessible with code within the same Go package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A good reference for names in Go can be obtained at [https://go.dev/doc/effective_go](https://go.dev/doc/effective_go).
  prefs: []
  type: TYPE_NORMAL
- en: Don’t shorten variable names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early times of computer programming, variable names had to be small to
    save more space in memory when saving the uncompiled code. But today, this is
    not a problem, so don’t save memory when writing variable names.
  prefs: []
  type: TYPE_NORMAL
- en: If you have to write a variable for representing the number of birds flying,
    write `number_of_birds_flying` in snake case or `numberOfBirdsFlying` in camel
    case.
  prefs: []
  type: TYPE_NORMAL
- en: There is an exception to this rule if you are using variables inside list comprehension
    or variables in a loop such as counters or indexes; then, shortened variables
    are okay to use.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid complex loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loops are added to code for several reasons: to increment, interact with a
    list, repeat an operation, and read a stream, among others. It is possible to
    use loops for deterministic or non-deterministic sizes, which can be very useful
    when you don’t know what you are going to interact with.'
  prefs: []
  type: TYPE_NORMAL
- en: But irrespective of the intention you are using a loop in your code for, use
    them wisely so that they don’t become unreadable or too complex to understand.
    A good rule of thumb is to avoid too many lines inside a loop. I would say that
    20 lines would be the limit. Another good practice is to avoid nested loops or
    loops within loops. If you have to do a nested loop, limit the number of levels
    to no more than two. Loops are hard to read when they are nested, and even worse
    when there are too many lines inside them.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the best way to create a loop with fewer than 20 lines? The suggestion
    is to group a few operations into functions that can be called inside the loop.
    Name the function whatever you want it to do, and add the operations to it. When
    you are reading the loop, the function call will be easy to spot and the name
    of the function will indicate what the operation is doing, which is really easy
    to read and understand. Also, it is easier to write unit tests when using this
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: How to avoid nested loops? Use functions to call a loop. Instead, you can also
    use generators, list comprehensions, or maps to avoid loops. Using maps has the
    advantage of making your code even faster as you don’t need to interact with it.
    List comprehensions are used in Python. Generators can be used in Python and are
    implemented using goroutines in Golang. So, whenever you need a nested loop, try
    not to overcomplicate it, and, if possible, use one of these mechanisms to avoid
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t repeat code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In software development, there is one term that is called **DRY** or **Don’t
    Repeat Yourself**. The worst a developer can do is repeat code. Yes, it is bad—really
    bad. Why? Because if you write code that performs a task over and over in multiple
    places, whenever you want to modify that task, you will be required to carry out
    the same change in several places. The other problem is that you will have to
    write multiple unit tests for the same task.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite view of DRY is **WET**, which stands for **Write Everything Twice**.
    A WET solution might occur because of multi-tiered architecture where developers
    have different tasks, and in the end, repetition may happen. A DRY approach should
    eliminate code redundancy by using a framework that helps developers avoid repetition.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen some examples of how we can use best practices
    when writing code. In the next section, we are going to explore how we can use
    tools to help us write better code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are many more suggestions on best practices when writing code. A more
    extensive list can be found at [https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)
    and https://go.dev/doc/effective_go.
  prefs: []
  type: TYPE_NORMAL
- en: For Python, I recommend the book *Effective Python* by Scott Meyers.
  prefs: []
  type: TYPE_NORMAL
- en: Coding formatters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we can now see, there are several rules and conventions to follow when writing
    code in Go or Python, and the list is long, which does not help when you are a
    beginner. But thanks to the community, there are tools that help to fix the code
    format for you. These tools can automatically fix your code or suggest modifications.
    Let’s have a look at a few code formatters for Python and Go.
  prefs: []
  type: TYPE_NORMAL
- en: Python Black
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Black** is a very popular code formatter for Python. It is *PEP-8* compliant,
    so it checks all *PEP-8* recommendations. The default run will reformat the code
    to be *PEP-8* compliant, but you can run it as a preview to identify the code
    change suggestions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With Black, it is possible to fix Python code automatically. Here is an example
    of wrong code written for Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After running Black, the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Black does apply all recommendations of *PEP-8* and also has its own style.
    In the preceding example, Black has correctly changed the `if` statement and added
    the correct indentation. In addition, it changed the strings assignment from single
    quotes to double quotes. There is no specific PEP designating if you have to write
    strings with double or single quotes, but Black’s own style uses double quotes
    for strings.
  prefs: []
  type: TYPE_NORMAL
- en: I personally think code that has single quotes in some strings and double quotes
    in other strings looks very ugly. So, I would recommend using double quotes only
    for strings, as Black does.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'More on Python Black can be found here: [https://github.com/psf/black](https://github.com/psf/black).'
  prefs: []
  type: TYPE_NORMAL
- en: Python isort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important bit that is not actually explained easily are the import lines
    that are present in the Python code. Sometimes there are dozens of imports, and
    if they are not properly organized, it is difficult to realize which ones are
    used and which are not.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the `isort` utility, it is possible to fix `import` statements, group
    them correctly, and sort them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one example of code that has a loose ugly `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After running `isort`, the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that `isort` grouped the imports and sorted them in a predictable way.
    If you need to add extra imports, you will not repeat or miss them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'More on `isort` can be found here: [https://pypi.org/project/isort/](https://pypi.org/project/isort/).'
  prefs: []
  type: TYPE_NORMAL
- en: Python YAPF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although *PEP-8* guidelines may allow you to write code in a way that other
    developers will appreciate, it does not necessarily mean your code looks good.
    The **YAPF** acronym is not actually explained on the tool’s page, but it perhaps
    means **Yet Another Python Formatter**.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, YAPF is similar to Black, which has its own style besides the *PEP-8*
    recommendations, but a major difference is that it can be configured for fine-tuning
    style formatting.
  prefs: []
  type: TYPE_NORMAL
- en: YAPF is based on `clang-format` developed by Daniel Jasper, which takes the
    original code and reformats it using the YAPF style guide, even if the original
    code did not violate any *PEP-8* guidelines. If used in all code, the style remains
    consistent throughout the project, and reviewers would not need to discuss or
    argue about the style during code review.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'More on YAPF can be found here: [https://github.com/google/yapf](https://github.com/google/yapf).'
  prefs: []
  type: TYPE_NORMAL
- en: YAPF, `isort`, and Black are the three major Python code formatters, but the
    list of Python formatters is very extensive. Other formatters can be found at
    [https://github.com/life4/awesome-python-code-formatters](https://github.com/life4/awesome-python-code-formatters).
  prefs: []
  type: TYPE_NORMAL
- en: Go gofmt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Go language has its own formatter that comes with the Go language package,
    and it is called `gofmt`. Its objective is similar to Python Black and Python
    YAPF, which formats the source code to the best format that can be done consistently.
    The formatter is used with the CLI command of `go`—for example, `go fmt myprogram.go`.
  prefs: []
  type: TYPE_NORMAL
- en: Some platforms run automatically `gofmt` every time you want to build or run
    a Go program.
  prefs: []
  type: TYPE_NORMAL
- en: Go golines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`golines` is a formatter that shortens long lines in addition to fixes done
    by `gofmt`. This formatter was created because `gofmt` does not break long lines
    and it is hard to visualize when lines are too long.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example before running `golines`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After running `golines`, the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: More details on how `golines` works are available at [https://yolken.net/blog/cleaner-go-code-golines](https://yolken.net/blog/cleaner-go-code-golines).
  prefs: []
  type: TYPE_NORMAL
- en: Go golangci-lint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A programming language lint or linter is software used to point errors, bugs,
    style errors, and suspicious constructs in the source code. It does not fix these
    automatically but flags errors and warnings to be fixed. For Go, the best linter
    package is `golangci-lint`, described in detail at [https://golangci-lint.run/](https://golangci-lint.run/).
    The original linter used for Go was located at [https://github.com/golang/lint](https://github.com/golang/lint)
    but was deprecated and frozen because of a lack of contribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several checks that `golangci-lint` can do. The default most important
    checks are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`govet`: Checks whether format strings in `Printf` calls have correct aligned
    arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unused`: Checks unused variables, functions, and types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gosimple`: Points to parts of the code that can be simplified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`structcheck`: Verifies unused struct fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deadcode`: Verifies any code that is not being used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete list of linters available can be found at [https://golangci-lint.run/usage/linters/](https://golangci-lint.run/usage/linters/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A list of additional Go code formatters can be obtained at [https://github.com/life4/awesome-go-code-formatters](https://github.com/life4/awesome-go-code-formatters).
  prefs: []
  type: TYPE_NORMAL
- en: There are many more awesome tools that can format your code, not only via command-line
    tools but also via integrated IDE formatting tools. This section was created to
    introduce some of the tools used by Python and Go and show how to use them to
    help your code improve. In the next section, we are going to talk about how to
    use tools when developing code to help concurrent development and versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning and concurrent development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, writing code is not only about the lines of code you are creating
    but also about the code others are writing to contribute to your software. In
    addition, code that has changes requires some information regarding why the changes
    are there and some version tags to identify these so that developers can easily
    revert changes or use different versions when testing or deploying.
  prefs: []
  type: TYPE_NORMAL
- en: How can we accomplish such tasks when writing code? The best answer is to use
    a version control system. Today the most popular free tools are **Git**, **SVN**,
    **Mercurial**, and **CVS**. Git, for sure, is the most popular of all, basically
    because of Linux and the growth of the GitHub website. *Table 5.2* shows a quick
    comparison between these four version control systems.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Version system** | **Year created** | **Famous for** | **Website** |'
  prefs: []
  type: TYPE_TB
- en: '| Git | 2005 | Linux and [github.com](http://github.com) | [www.git-scm.com](http://www.git-scm.com)
    |'
  prefs: []
  type: TYPE_TB
- en: '| SVN | 2000 | FreeBSD and [sourceforge.com](http://sourceforge.com) | [subversion.apache.org](http://subversion.apache.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| CVS | 1986 | NetBSD and OpenBSD | [www.nongnu.org/cvs/](http://www.nongnu.org/cvs/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mercurial | 2005 | Python and Mozilla | [www.mercurial-scm.org](http://www.mercurial-scm.org)
    |'
  prefs: []
  type: TYPE_TB
- en: Table 5.2 – Most popular version control systems comparison
  prefs: []
  type: TYPE_NORMAL
- en: When writing code, it is recommended to use a source version control system,
    which allows the software to be edited by multiple developers at the same mechanism
    to avoid adding code to the system without syncing the changes. Several different
    terms are used in versioning systems; the terms are almost the same over different
    systems such as Git or SVN.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s describe the most common commands used by versioning systems.
  prefs: []
  type: TYPE_NORMAL
- en: clone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`clone` is a command to copy the whole source code, including subdirectories
    and versioning system data, to your local directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the command being used in Git: `git clone https://github.com/brnuts/matrix.git`.'
  prefs: []
  type: TYPE_NORMAL
- en: checkout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`checkout` is a command to update files in the working directory to match the
    source tree source code. It is also used to switch to another code branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the command being used in Git for updating the current
    branch: `git checkout`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s an example of it being used in Git for checking out another branch:
    `git checkout mybranch`.'
  prefs: []
  type: TYPE_NORMAL
- en: commit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While changing the source code is recommended to change small chunks, each small
    change should attach a text tag describing the changes. The `commit` command is
    a command that adds a text tag to the code and a checkpoint number. As your code
    changes, you add commits to each small change. After the whole change is complete,
    you will have a change log that has multiple commit text explanations, helping
    the reader understand why and how the changes were made.
  prefs: []
  type: TYPE_NORMAL
- en: Mainline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Mainline** is normally the name of the main **branch** of the code. Other
    branches of the code normally ramify from the main branch or from other branches,
    which after ramification have a parent branch. In this sense, the mainline is
    a branch that has no parent branch.'
  prefs: []
  type: TYPE_NORMAL
- en: The mainline branch is known as the trunk of the source code tree and can also
    be called **master** or sometimes **baseline**.
  prefs: []
  type: TYPE_NORMAL
- en: Branching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use versioning systems to create branches in your code. A **branch**
    is normally a ramification of the code from another branch. The goal of having
    a branch is to make particular changes to the code without interfering with the
    parent branch.
  prefs: []
  type: TYPE_NORMAL
- en: The code branch can then have as many changes as needed, and when ready can
    be added to the parent branch by using the `merge` command.
  prefs: []
  type: TYPE_NORMAL
- en: There are several advantages of using branches—one of them is to clarify the
    communication on the intention of a large change by adding several small change
    **commits** on the branch, with an explanation of each change. Another advantage
    is to allow other developers to continue to add changes to the parent branch.
  prefs: []
  type: TYPE_NORMAL
- en: A branch without a parent branch is the mainline branch or the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A code `merge` command checks whether code can be added without interfering
    with the mainline branch code. If there is interference, it will create code `merge`
    command can also be done between individual branches without a mainline.
  prefs: []
  type: TYPE_NORMAL
- en: The merging technique is the safest technique used to combine branches without
    compromising any code that differs from other code. But sometimes, there are so
    many conflicts to be resolved that this might not be feasible. When that occurs,
    it is recommended to start a new branch and try to add the changes, gradually
    merging eventually, or to use the `rebase` command, which allows the commit to
    be applied from one branch to another branch interactively if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A description of the mainline commits and branches](img/B18165_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – A description of the mainline commits and branches
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.3* shows an example with all details of the versioning system for
    the mainline and the branches. You can also spot the commits and merges that are
    done for each branch and for the mainline as well. Note that branch 1 (green)
    was created to add two files, called `LICENSE` and `COPYRIGHT`, then was merged
    to the mainline. Branch 2 was created from a `432384DC` commit and has not been
    merged to the mainline yet.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we investigated how versioning tools help a great deal when
    developing code concurrently. Use a versioning system whenever you can to organize
    your development. In the next section, we are going to explore why and how we
    add testing to our code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing code is another subject that has grown in the past decades. In the early
    '70s, testing code was not actually part of the development process but part of
    the debugging process when there was a problem with the software. Testing assumed
    significance when American computer scientist Glenford Myers published the classic
    book *The Art of Software Testing* in 1979, proposing the separation of debugging
    from testing.
  prefs: []
  type: TYPE_NORMAL
- en: Since then, much has improved in the development process with testing. Today,
    it is about preventing errors, and the process to develop code with tests that
    prevent errors is called **test-driven development** or **TDD**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the process of developing the code, the developer must identify two parts
    of the code: **testable** and **non-testable** code. Testable code is pieces of
    code that are easily verified by low-level testing, such as a unit test. Non-testable
    code is pieces of code (such as the import of a library) that are not easily tested
    at a lower level and normally are tested with higher-level testing such as integration
    tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when writing code, the developer must be mindful of when and how
    tests would be performed for that part of the code. The developer will easily
    identify which part of the code can be done with lower- or higher-level testing.
    There are several levels of testing. Let’s discuss a few of them in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Unit tests** are the lower level of testing because they are intended to
    cover a small part of code, which is the smallest piece of code that can be logically
    isolated. These pieces of code can be subroutines, functions, methods, loops,
    or properties. The goal of unit tests is to show that individual parts of the
    code are correct and—when used in methods or functions—to make sure they work
    as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: If in the future, code has its libraries or modules upgraded or refactored,
    the unit tests created before are able to identify whether the code still works
    with the change, making it robust against eventual bugs introduced with upgrades.
    For that, unit tests have to be written to cover all functions, modules, methods,
    and properties; then, whatever change happens that could cause a fault would be
    quickly identified by the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests can be written in several ways: some would write a function and
    then write the unit tests for this function; some would write the unit tests and
    then write the function. When unit tests are written first, this is normally called
    **test-driven development** (**TDD**) or **extreme programming** (**XP**).'
  prefs: []
  type: TYPE_NORMAL
- en: As some code cannot be tested with unit tests, each team and organization has
    a **test coverage** parameter used to evaluate each software package. The number
    varies, but normally it is higher than 50% test coverage for the software package,
    and something higher than 80% for all new functions and methods introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are easy to create when a function or method has clear input parameters
    and some outputs, but it is not easy to create when a function interacts with
    external elements such as a database. For dealing with these external environments,
    some languages have **mock capabilities** (or **mockups**) to simulate the external
    behavior, without doing it.
  prefs: []
  type: TYPE_NORMAL
- en: If part of the code is not unit-testable (mocks are not available), it will
    probably be covered by higher-level testing, as with the ones we are going to
    talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Integration tests** are used to fill the gaps of tests not possible to be
    performed with unit tests. These are normally tests that touch or require external
    environments such as databases, external files, or service APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: From a testing order perspective, integration testing is the second step after
    the unit tests have been done successfully and before the **end-to-end** (**E2E**)
    testing (if required). Integration testing normally uses broader code coverage
    in terms of modules and functions. It groups them into a large aggregate and applies
    a test plan to validate the expected outputs. Individual functions and modules
    are tested using unit tests. During integration tests, they are not necessarily
    tested individually but in a higher-level group.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to set up a test environment that can support integration testing,
    such as an external test database. During integration tests, the mockups added
    in the unit tests are not used, but real external testing environments are used.
    The external testing environment is normally separated from production and is
    dedicated to integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: When performing integration tests, the test environment should behave in the
    same manner as the production environment, or at least very close to production.
    With similar production behavior, we can have more confidence, after the integration
    tests are passed, that the software will work in production.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests can run on someone’s computer; on the other hand, integration tests
    can’t because they rely on a testing environment that would validate the external
    communication from the software. Someone might say, *set up an environment for
    integration testing on your computer*, but it would then not be possible to validate
    some tests that require consistency.
  prefs: []
  type: TYPE_NORMAL
- en: E2E testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most tests can be done by unit tests and integration tests; however, some might
    still be missing. **E2E tests** are added in another level of testing, which will
    evaluate the overall software, including performance, under a production-like
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: If possible and allowed, the ideal way is to run the E2E testing in the production
    environment. If it is not possible to run this in production, an isolated production-like
    environment can be used. The goal is to simulate the real scenario of the software
    running from the start to the end so that passing tests can validate the software
    and can be used without restrictions in production.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of testing time and cycle, the E2E test should run last, as these tests
    take much longer to run than the integration tests. The test coverage should cover
    broader behavior, not only touching external interfaces but also using the whole
    workflow process that the software belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize unit tests, integration tests, and E2E tests, let’s use an example.
    Imagine your software creates a robot that can paint cars. What would the responsibility
    of each testing level be? Here’s a possible implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: Lower-level testing of small modules of the software:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move *x*, *y*, and *z* directions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-identify unalignments
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify which color a container has
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Spray paint evenly in all directions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t leak paint
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the ending paint in the container
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**: Higher-level testing with external modules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can paint a car full
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can refill paint in an empty paint container
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can paint car with different colors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn’t leave blank color spots in the car
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E2E tests**: These would be the higher level, ultimate tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Car can be painted in *X* minutes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No interference on the next car or previous car when painting the current car
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Robot can paint *Y* number of cars per hour, with paint refill and color change
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see in this example, the number of tests is normally higher when the
    level of testing is lower. So, unit tests would have more tests than integration
    or E2E tests. However, the time to run tests is slower as we go higher up the
    levels. E2E testing should take longer to finish than integration or unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Other testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several other testing classifications. For our network automation,
    we are going to use only the three levels we just described: unit tests, integration
    tests, and E2E tests. The others we are going to explain here, for reference,
    can be added to your automation work if you think they are necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk briefly about them now.
  prefs: []
  type: TYPE_NORMAL
- en: System testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Technically speaking, all tests can be done by unit tests, integration tests,
    and E2E testing. The **system testing** is to add an extra testing phase that
    can be used to evaluate the system’s compliance with the specified requirements.
    Therefore, system testing is another name for testing in a formal procedure to
    verify that all requirements have been met.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When dealing with projects that involve end customers, it is important to align
    the expectations of the behavior of the software. Acceptance testing is a mechanism
    to negotiate and communicate with the end customer about the correct behavior
    of the system. **Acceptance tests** are like a contract between the end customer
    and the developer to delineate the final delivery of the software. The end customer
    is normally involved when selecting a test plan and tests so that the tests cover
    the system’s behavior and expectations.
  prefs: []
  type: TYPE_NORMAL
- en: The usual terms used here are **user acceptance test** (or **UAT**) and **operational
    acceptance test** (or **OAT**).
  prefs: []
  type: TYPE_NORMAL
- en: If your network automation code is highly dependable on a customer’s use, with
    clear requirements, I would highly recommend writing test cases with the customer
    for UAT and OAT. But if your work is for internal usage and has no end-user requirements,
    integration and unit tests are sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Security testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your software is deployed in restricted or vulnerable areas or touches network
    devices in a sensitive area, you might need to run security testing. Different
    from the other tests, **security testing** focuses on vulnerabilities of the code
    that you have created and also on all module dependencies that are imported by
    your code. The versions of all modules are also checked, and some versions might
    be prohibited because of some internal security policies.
  prefs: []
  type: TYPE_NORMAL
- en: One additional test is called a **pentest** or a **penetration test**, which
    is performed on the system your software is created on. The idea of a pentest
    is to perform a simulated cyberattack on the final system used by your code. The
    test has the objective of identifying weaknesses and potential access for unauthorized
    people to data or the system.
  prefs: []
  type: TYPE_NORMAL
- en: Security testing also verifies the password management in the code and any cryptography
    used. There are some best practices when using passwords, such as cryptography
    and secrets that reduce the risk of unauthorized people accessing the system.
  prefs: []
  type: TYPE_NORMAL
- en: For our network automation, security testing would be required if the devices
    we are going to automate were located in a vulnerable area, or if the software
    might be exposed to external parties or to the internet. But in general, there
    is no need for security testing for internal usage.
  prefs: []
  type: TYPE_NORMAL
- en: For sure, there is more to discuss in terms of security testing, but that would
    probably require a book on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Destructive testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Destructive software testing** or **DST** is performed in the software to
    evaluate the robustness of the final system with the code that has been added.
    The tests are intended to stress the system or to enter invalid inputs so that
    the software starts to fail. The success of the test is to expose possible design
    weaknesses and performance limitations under normal and strained conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: Failures during destructive tests are seen as good results if the system shows
    clearly the methods it has used to recover or to avoid breaking down completely.
    The performance is measured under the test, and the system resources are stressed
    to the maximum until degradation or failure occurs. It is possible to use the
    measurements taken during the performance stress later to add input system limitations
    for the current implementation, consequently avoiding any degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Alpha and beta testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When tests are performed before going to production, some would call them **alpha**
    or **beta testing**. Normally, alpha tests are performed before beta tests, just
    because of the alphabetical order. The tests are not necessarily different from
    integration or E2E testing, but normally they are performed in a production-like
    environment, or sometimes in production.
  prefs: []
  type: TYPE_NORMAL
- en: Some beta tests also involve customers that are aware of the new features being
    tested and can help evaluate the new software before it goes to other customers
    in production. Therefore, beta testing would be the final stage before the software
    is considered reliable enough to be deployed in full production. Beta and alpha
    tests can have windows of testing that can last from hours to days.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! At this point, you are familiar with the coding practices used
    today. You know how to use tools to help your source code in terms of quality
    and concurrent development. You are also able to perceive the importance of having
    unit tests and integration tests added to your code.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, as a new code developer for automation, you are more equipped with
    the jargon and terms used in the software development community. You are able
    to improve not only the quality of your code but also your team’s code quality.
    Use the tools and the topics discussed here throughout your automation development
    career.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to have more practical examples of how to
    use Go and Python for network automation. We are going to explore some examples
    of automation in Go and Python and compare them.
  prefs: []
  type: TYPE_NORMAL
