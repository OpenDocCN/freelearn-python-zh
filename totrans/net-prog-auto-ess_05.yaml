- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Dos and Don’ts for Network Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络编程的禁忌与注意事项
- en: Writing code for networks is exciting because when it fails, it is challenging,
    and when it works, it is rewarding. If you are an experienced programmer, you
    will have an easier ride, but if you are a newbie, it will be stormy. Let’s dive
    into some coding practices that will help you get through these storms easier.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为网络编写代码是令人兴奋的，因为当它失败时，挑战重重，而当它成功时，则令人满意。如果你是一位经验丰富的程序员，那么这个过程会容易一些，但如果你是新手，那么可能会遇到风暴。让我们深入了解一些有助于你更容易度过这些风暴的编码实践。
- en: 'We are going to focus on this chapter on coding aspects for Python and Go related
    to network programming. The subject covered here would be also good for any type
    of programming; however, we are going to focus on programming for networks, and
    these are the topics we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于本章中与网络编程相关的Python和Go的编码方面。这里涉及的主题也适用于任何类型的编程；然而，我们将专注于网络编程的编程，以下是我们将涵盖的主题：
- en: Coding topics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码主题
- en: Applying best practices in coding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编码中应用最佳实践
- en: Coding formatters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码格式化
- en: Versioning and concurrent development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制和并发开发
- en: Testing your code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的代码
- en: At the end of this chapter, you should be familiar with coding terms used by
    the community and which of them matter most. You will be able to understand coding
    best practices and how to become a better network code developer. If you are an
    experienced coder, it will be a good refresh. If you are new, this chapter will
    be your mantra when writing code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该熟悉社区使用的编码术语以及其中哪些最重要。你将能够理解编码最佳实践以及如何成为一名更好的网络代码开发者。如果你是一位经验丰富的编码者，这将是一个很好的复习。如果你是新手，那么这一章将成为你编写代码时的座右铭。
- en: Coding topics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码主题
- en: Writing code used to be very simple and straightforward; it only required the
    ability to understand a program’s workflow, its performance, and its algorithms.
    But today, the story is a bit different. Coding now has a culture that has evolved
    in the last few decades. What matters most is the code’s reusability and, therefore,
    its style. To be reusable, code has to be easy to understand and should have few
    or no bugs or security issues.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码曾经非常简单直接；它只需要理解程序的工作流程、性能和算法。但今天，情况略有不同。编码现在有一个在过去几十年中演变的文化。最重要的是代码的可重用性，因此是它的风格。为了可重用，代码必须易于理解，并且应该有很少或没有错误或安全问题。
- en: If you are new to coding, or network coding, it is important to know all the
    topics used in coding culture today. Let’s discuss briefly the most important
    ones in this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始编码，或者对网络编码不熟悉，了解今天编码文化中使用的所有主题是很重要的。让我们简要讨论本节中最重要的几个主题。
- en: Peer review
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同行评审
- en: It’s not recommended to write code and publish without a **peer review**. Peer
    review allows the coder to be consistent with the team and avoid undesirable mistakes.
    However, for most organizations, this process can be slow and sometimes expensive.
    One alternative is to use software robots that can perform most of the peer review
    that was once done by another software engineer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议在没有**同行评审**的情况下编写代码并发布。同行评审可以让编码者与团队保持一致，避免不希望出现的错误。然而，对于大多数组织来说，这个过程可能很慢，有时甚至很昂贵。一个替代方案是使用软件机器人，它可以执行以前由另一位软件工程师完成的许多同行评审工作。
- en: A peer review is a conscious and objective review done by another developer
    that has the objective of checking team standards, language standards, and community
    best practices, sharing knowledge, verifying code repetition and name convention,
    and aligning design with implementation, among others. As the list is long, the
    peer review process is not an easy and straightforward job; it sometimes takes
    longer to review the code than to write it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同行评审是由另一位具有检查团队标准、语言标准和社区最佳实践、分享知识、验证代码重复和命名约定、以及将设计与实现对齐等目标的开发人员进行的自觉和客观的评审。由于列表很长，同行评审过程并不容易和直接；有时评审代码的时间比编写代码的时间还要长。
- en: Life cycle
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期
- en: It is important to keep track of your code by measuring and storing the date
    of creation, compilation (if any), and distribution. This is done by having some
    sort of life-cycle management. With a life cycle, it is possible to trigger actions
    to go back to the source code and verify whether the current recommendations are
    still valid on the source code, and also check whether there is any new security
    vulnerability. There are tools that do life-cycle management automatically to
    your code base and your applications; use them when possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测量和存储创建日期、编译（如果有）和分发日期来跟踪你的代码是很重要的。这是通过某种生命周期管理来完成的。有了生命周期，就可以触发操作回到源代码，并验证当前的建议是否仍然适用于源代码，并检查是否存在任何新的安全漏洞。有一些工具可以自动对你的代码库和应用程序进行生命周期管理；在可能的情况下使用它们。
- en: Refactoring
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构
- en: In computer programming, **refactoring** (or **code refactoring**) is the term
    used to change the code without changing its external behaviors in terms of output
    and input. Refactoring can be used to fix bugs, improve performance, remove security
    vulnerabilities, or comply with new code styling. The important thing here is
    that refactoring does not change the features of the code. In other words, the
    external behavior, inputs, and outputs are preserved.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，**重构**（或**代码重构**）是指在不改变其输出和输入的外部行为的情况下改变代码的术语。重构可以用来修复错误、提高性能、移除安全漏洞或遵守新的代码风格。这里重要的是重构不会改变代码的功能。换句话说，外部行为、输入和输出都得到了保留。
- en: Important note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Check more on code refactoring on the site [https://refactoring.guru/](https://refactoring.guru/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于代码重构的信息，请访问网站 [https://refactoring.guru/](https://refactoring.guru/)。
- en: Copying code and licensing
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码复制和许可
- en: The first thing you should do before publishing your code is to think about
    the **copyright** and **code license**. Why? Because if your code is good, it
    will definitely be reusable by someone else or will be copied for other purposes,
    unless you strictly specify the rules of copying on the license document. In addition,
    if you are importing or using external libraries, you might be compromised by
    copyright issues.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布你的代码之前，你应该首先考虑**版权**和**代码许可证**。为什么？因为如果你的代码很好，它肯定会被其他人重用或被复制用于其他目的，除非你在许可证文件中严格指定复制的规则。此外，如果你正在导入或使用外部库，你可能会因为版权问题而受到损害。
- en: 'Therefore, it is important to create appropriate license documents and read
    the license documents of the code you are using or copying. The types of licenses
    that are attributed to software are listed here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建适当的许可证文件并阅读你使用或复制的代码的许可证文件是很重要的。这里列出了分配给软件的许可证类型：
- en: '**Trade secret licenses**: No information made public; private internal usage;
    unpublished'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**商业秘密许可证**：不公开信息；私人内部使用；未发表'
- en: '**Proprietary licenses**: Have copyrights; no public licenses and no source
    code'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专有许可证**：拥有版权；没有公开许可证和源代码'
- en: '**Noncommercial licenses**: Used for noncommercial use and no source code'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非商业许可证**：用于非商业用途且无源代码'
- en: '**Copyleft licenses**: Grant use rights; forbids relicensing and public source
    code'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版权许可证**：授予使用权利；禁止重新许可和公开源代码'
- en: '**Permissive licenses**: Grant use rights; allows relicensing and public source
    code'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**许可许可证**：授予使用权利；允许重新许可和公开源代码'
- en: '**Public domain licenses**: All possible grants'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公有领域许可证**：所有可能的授权'
- en: Why do we care about these types of licenses? Because you are not supposed to
    distribute or publish the software you are working on. You could receive legal
    penalties and fines for breaching the license agreement on the code you are creating
    locally at your company. Most of the time, you are probably going to reuse someone
    else’s library or code into a major piece of software. Before using an external
    library or code, the best way is to consult the legal department and check whether
    there are any licenses that are forbidden for use internally.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么关心这些类型的许可证？因为你不应该分发或发布你正在工作的软件。如果你违反了你在公司本地创建的代码的许可证协议，你可能会受到法律处罚和罚款。大多数情况下，你可能将重用他人的库或代码到主要软件中。在使用外部库或代码之前，最好的办法是咨询法律部门，检查是否有任何禁止内部使用的许可证。
- en: Consequently, it is recommended when writing code to check the license disclaimer
    document provided. It is normally located in the root directory of the source
    code, in capital letters, with names such as `LICENSE` or `LICENSE.rst`, but sometimes
    `COPYRIGHT`, `COPYING`, or something similar is used to express the copy grants.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议在编写代码时检查提供的许可证免责声明文档。它通常位于源代码的根目录中，用大写字母书写，名称如`LICENSE`或`LICENSE.rst`，但有时也使用`COPYRIGHT`、`COPYING`或类似名称来表达版权许可。
- en: For open source, the code also can rely on rules defined by definitions created
    by other entities; to do that, you just need to read the `LICENSE` file and check
    which one is applied. One of the most used ones in open source code is the **MIT
    License**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开源软件，代码也可以依赖于其他实体创建的定义中的规则；要做到这一点，你只需要阅读`LICENSE`文件并检查哪个被应用。在开源代码中最常用的一个是**MIT许可证**。
- en: Before using the open source library or copying it into your code, make sure
    the license does not present a risk to your organization. The open source code
    that presents the most risk when reusing it in private organizations is **GPL
    2.0** and **GPL 3.0** (**GNU General Public License**). The low-risk ones are
    **MIT License**, **Apache License 2.0**, and **BSD License 2.0**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用开源库或将其复制到你的代码之前，确保许可证不会对你的组织构成风险。在私有组织中重新使用时，风险最高的开源代码是**GPL 2.0**和**GPL
    3.0**（**GNU通用公共许可证**）。低风险的包括**MIT许可证**、**Apache许可证2.0**和**BSD许可证2.0**。
- en: 'The following table shows the top five most used licenses in projects at GitHub:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了GitHub项目中使用最广泛的五个许可证：
- en: '| **Rank** | **License** | **% of projects** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **排名** | **许可证** | **项目百分比** |'
- en: '| 1 | MIT | 44.69 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 1 | MIT | 44.69 |'
- en: '| 2 | Other | 15.68 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 其他 | 15.68 |'
- en: '| 3 | GLP 2.0 | 12.96 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 3 | GLP 2.0 | 12.96 |'
- en: '| 4 | Apache | 11.19 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Apache | 11.19 |'
- en: '| 5 | GLP 3.0 | 8.88 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 5 | GLP 3.0 | 8.88 |'
- en: Table 5.1 – Rank of the most used licenses in GitHub projects
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – GitHub项目中使用最广泛的许可证排名
- en: 'The following screenshot shows the evolution of GitHub project licenses from
    2008 to 2015\. Note the growth of MIT licenses:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了GitHub项目许可证从2008年到2015年的演变。注意MIT许可证的增长：
- en: '![Figure 5.1 – License usage in GitHub projects (source: github.blog)](img/B18165_05_001.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – GitHub项目中的许可证使用情况（来源：github.blog）](img/B18165_05_001.jpg)'
- en: 'Figure 5.1 – License usage in GitHub projects (source: github.blog)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – GitHub项目中的许可证使用情况（来源：github.blog）
- en: Now that you are familiar with the most popular code licenses, let’s progress
    with discussing code quality and perception.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了最流行的代码许可证，让我们继续讨论代码质量和认知。
- en: Code quality and perception
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码质量和认知
- en: '**Code quality** is a term normally heard among software engineers, but to
    be very clear, it is not an easy subject, and the definition of quality is normally
    subjective and prone to personal preferences.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码质量**是软件工程师中常听到的术语，但为了非常清楚，这不是一个容易的主题，质量的定义通常是主观的，并容易受到个人偏好的影响。'
- en: To avoid such an ambiguous definition, code quality should focus on team or
    company guidelines and standards. If the company that you have just started has
    loose or no code guidelines, the code *quality* probably relies on the senior
    engineer. But that must—and should—be avoided.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种含糊的定义，代码质量应侧重于团队或公司的指南和标准。如果你刚刚开始的公司有宽松或没有代码指南，代码的*质量*可能依赖于资深工程师。但这是必须的——并且应该避免。
- en: Code quality should be measured by using standards and code practices, not by
    a person. If there are no standards or code practices in your team, use this chapter
    to guide you while creating one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用标准和代码实践来衡量代码质量，而不是个人。如果你的团队没有标准或代码实践，使用本章来指导你创建一个。
- en: 'When defining the quality of the code, try to use measurable metrics that will
    allow software engineers to understand poor quality without taking it personally.
    Look for the following characteristics in the code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义代码质量时，尽量使用可衡量的指标，这样软件工程师可以理解低质量代码，而无需将其个人化。在代码中寻找以下特征：
- en: '**Reliability**: Measure how many times the code runs without failures'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：衡量代码在无故障的情况下运行了多少次'
- en: '**Maintainability**: Measure how easily the code can be changed, including
    size, complexity, and structure'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：衡量代码如何容易更改，包括大小、复杂性和结构'
- en: '**Testability**: Measure how the code can be controlled, observed, and isolated
    to create automated testing such as unit tests (which will be discussed in the
    *Testing your code* section later in this chapter)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：衡量代码如何被控制、观察和隔离以创建自动化测试，例如单元测试（将在本章后面的*测试你的代码*部分讨论）'
- en: '**Portability**: How easily the code can run in different environments'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：代码在不同环境中运行的容易程度'
- en: '**Reusability**: Measure how the code can be reused by dependencies or by copying'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：衡量代码可以通过依赖关系或复制进行重用的程度'
- en: When possible, use automated tools that can classify and format the code, which
    avoids personal subjective analysis.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用能够分类和格式化代码的自动化工具，这样可以避免个人主观分析。
- en: Architecture and modeling
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构和建模
- en: Software architecture and design is a very long and wide topic. Depending on
    the size of your project, you might not need to do a design or architecture when
    working with network automation code. However, it is important to know they exist
    and can be used effectively to have a better code structure and better organization.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构和设计是一个非常广泛且漫长的主题。根据你项目的大小，在与网络自动化代码一起工作时，你可能不需要进行设计或架构。然而，了解它们的存在并且能够有效地使用它们来获得更好的代码结构和更好的组织是很重要的。
- en: I would suggest that the most important part of software architecture is the
    modeling, which helps a lot in the early stages to validate the structure and
    the organization of the code. Communication with a model is easy with customers
    and can be understood even if you are not a software developer.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议软件架构最重要的部分是建模，这在代码的早期阶段验证结构和组织非常有帮助。与客户通过模型进行沟通很容易，即使你不是软件开发者也能理解。
- en: The most popular used models are **Unified Modeling Language** (**UML**) as
    generic, **Systems Modeling Language** (**SysML**), a subset of UML, **Service-oriented
    architecture Modeling language** (**SoaML**), also a subset of UML, and the **C4
    model**. It does not matter which one you will choose; using any model before
    you start coding will help you to get the code right.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的模型是**统一建模语言**（**UML**），作为通用语言，**系统建模语言**（**SysML**），UML的一个子集，**面向服务的架构建模语言**（**SoaML**），也是UML的一个子集，以及**C4模型**。选择哪一个不重要；在开始编码之前使用任何模型都将帮助你编写正确的代码。
- en: 'Let’s use the deployment pipeline described in [*Chapter 4*](B18165_04.xhtml#_idTextAnchor100)
    as an example to create a software model of the solution. *Figure 5.2* illustrates
    how it would be a very simple model for the deployment pipeline:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以[*第 4 章*](B18165_04.xhtml#_idTextAnchor100)中描述的部署管道为例，创建一个解决方案的软件模型。*图 5.2*说明了它将是一个非常简单的部署管道模型：
- en: '![Figure 5.2 – Deployment pipeline software model example described in Chapter
    4](img/B18165_05_002.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 第 4 章中描述的部署管道软件模型示例](img/B18165_05_002.jpg)'
- en: Figure 5.2 – Deployment pipeline software model example described in [Chapter
    4](B18165_04.xhtml#_idTextAnchor100)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 第 4 章中描述的部署管道软件模型示例 [Chapter 4](B18165_04.xhtml#_idTextAnchor100)
- en: The preceding diagram illustrates, using arrows and boxes, how a developer would
    tackle the problem of constructing a deployment pipeline. The inputs are the router
    definition and templates, then a configuration render creates the configuration
    and stores it at the desired state. The syntax is checked, and then the running
    config is verified if it is equal to `applied`. If not, it stops and waits for
    manual intervention; if it is okay, then launch a network simulation. Then, all
    tests are done. If the tests are passed, update the approved configs. The next
    step is to apply the configuration to the routers, and if it is applied correctly,
    then update the `applied` configs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表使用箭头和方框说明了开发者如何处理构建部署管道的问题。输入是路由定义和模板，然后配置渲染创建配置并将其存储在所需状态。检查语法，然后验证运行配置是否等于
    `applied`。如果不等于，则停止并等待人工干预；如果一切正常，则启动网络模拟。然后，进行所有测试。如果测试通过，则更新批准的配置。下一步是将配置应用到路由器上，如果正确应用，则更新
    `applied` 配置。
- en: We have discussed in this section a few code culture topics that are used nowadays
    within the developing community. In the next section, we are going to dive into
    what the best practices are for writing code for Python and Go.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了一些现在在开发社区中使用的代码文化话题。在下一节中，我们将深入探讨编写 Python 和 Go 代码的最佳实践。
- en: Applying best practices in coding
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用编码最佳实践
- en: Here are points that are not necessarily standards, but they are important when
    we are writing code for networks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些点可能不是标准，但在我们编写网络代码时很重要。
- en: Follow the standards
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循标准
- en: In the '90s, the internet was starting to grow fast, and programmers started
    to become more present in the community. Shell scripting started to grow as a
    viable tool to help system engineers work with their servers. Then came **Perl**
    as a powerful scripting language to help as well. Other languages were also mature,
    such as C, C++, and Java. But every developer wrote differently with their own
    style, which did not help code collaboration and made sharing code a disaster.
    When Python was created, the coding style problem already existed. Something had
    to be done to avoid confusion when sharing code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代，互联网开始迅速增长，程序员开始在社区中更加活跃。Shell脚本开始作为一种可行的工具帮助系统工程师处理他们的服务器。然后出现了**Perl**，作为一种强大的脚本语言来提供帮助。其他语言也变得成熟，如C、C++和Java。但每个开发者都以自己的风格编写代码，这不利于代码协作，使得代码共享成为一场灾难。当Python被创建时，编码风格问题已经存在。必须做些事情来避免在代码共享时产生混淆。
- en: Let’s check now what the standards are for Python and Go languages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看Python和Go语言的编码标准是什么。
- en: Python standard style
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python标准风格
- en: Python can be written in so many different ways. If you are an old programmer,
    you would remember Perl, which was a scripting language like Python but without
    any particular style, which was a mess. There are documents that help programmers
    to write better code in Python. The documents are created by the Python community,
    and they are called **PEPs**, which stands for **Python Enhancement Proposals**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以用很多不同的方式编写。如果你是一位老程序员，你会记得Perl，它就像Python一样是一种脚本语言，但没有特定的风格，这造成了一团糟。有一些文档可以帮助程序员在Python中编写更好的代码。这些文档是由Python社区创建的，它们被称为**PEPs**，代表**Python增强提案**。
- en: Initially, the PEP process was created to propose and discuss consensus on new
    features, but it is also used to document information. A PEP is similar to an
    internet **Request For Comments** (**RFC**) for Python, and when describing new
    features, it has to contain a description of the feature in detail and a rationale
    for the creation of it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，PEP流程是为了提出和讨论对新特性的共识而创建的，但它也被用来记录信息。PEP类似于Python的互联网**请求评论**（**RFC**），在描述新特性时，它必须包含对该特性的详细描述以及创建它的理由。
- en: When proposing new features for Python, the writer is responsible for building
    consensus within the community, describing different options, collecting input
    from the community, and documenting it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当提出Python的新特性时，作者负责在社区内建立共识，描述不同的选项，收集社区的反馈，并对其进行记录。
- en: Some PEPs are informational and are basically used to guide Python coding style.
    If you are planning to become a Python code developer, a PEP is like your daily
    journal to check and read. It is important to keep updated with the latest PEP
    and make sure your code follows the recommendations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一些PEP是信息性的，基本上用于指导Python编码风格。如果你打算成为一名Python代码开发者，一个PEP就像你的日常日记，用来检查和阅读。保持对最新PEP的更新很重要，并确保你的代码遵循这些建议。
- en: So far, there are a few useful PEPs to help the community with guidance and
    best practices on how to write code with Python. Let’s check the most important
    ones.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，有一些有用的PEP（Python Enhancement Proposals）可以帮助社区在如何用Python编写代码方面获得指导和最佳实践。让我们来看看其中最重要的几个。
- en: Writing code with the guidance of PEP-8
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在PEP-8的指导下编写代码
- en: '*PEP-8* is perhaps the most important PEP you have to read if you are new to
    Python because it describes in detail all styles and conventions when writing
    code in Python. Although the language does not force you to select a style when
    writing, using *PEP-8* (or *PEP8*) will make your code easy to understand for
    anyone in the Python community.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*PEP-8*可能是如果你是Python新手的话必须阅读的最重要PEP，因为它详细描述了在Python中编写代码时的所有风格和约定。尽管语言在编写代码时并不强迫你选择一种风格，但使用*PEP-8*（或*PEP8*）会使你的代码对Python社区中的任何人来说都更容易理解。'
- en: When you are new to Python, it might be difficult to remember what a part of
    the code you wrote weeks or a few days ago was supposed to do. However, if you
    follow *PEP-8*, you can be sure that you have named your variables well, you have
    added enough whitespace, and you have commented your code well. Following these
    guidelines will make your code more readable for others and for you when coming
    back to read after a while. Beginners will also learn Python much faster and with
    ease when following *PEP-8*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对Python还不太熟悉时，可能很难记住你几周或几天前写的代码的一部分原本是要做什么的。然而，如果你遵循*PEP-8*，你可以确信你已经很好地命名了变量，添加了足够的空白，并且很好地注释了代码。遵循这些指南将使你的代码对他人以及你自己在一段时间后回来阅读时更加易读。初学者在遵循*PEP-8*时也会更快、更轻松地学习Python。
- en: The *PEP-8* document is very clear; it shows a wrong code style and then a correct
    style with an explanation of why to use that style.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*PEP-8* 文档非常清晰；它展示了错误代码风格，然后是正确风格，并解释了为什么使用这种风格。'
- en: Go standard style
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go 标准风格
- en: Before describing the standards in the Go language, it is important to note
    that Go is also known as `golang.org`. Now, the Go language is hosted on `go.dev`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述 Go 语言的标准之前，重要的是要注意，Go 语言也被称为 `golang.org`。现在，Go 语言托管在 `go.dev` 上。
- en: Go is quite different from Python in terms of code formatting and style. Go
    does not have PEP-like documents to point out how to write better code in Go.
    So, the style standard relies mostly on the internal formatting tool, called `gofmt`,
    which is responsible for formatting the source code in a predictable way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码格式和风格方面，Go 与 Python 相差甚远。Go 没有类似于 PEP 的文档来指出如何在 Go 中编写更好的代码。因此，风格标准主要依赖于内部格式化工具，称为
    `gofmt`，它负责以可预测的方式格式化源代码。
- en: Although the `gofmt` formatter can be skipped, it is highly recommended to use
    it as soon as you change something in your code and before publishing it. Some
    tools will run the formatter automatically before running or compiling your Go
    program. In addition to `gofmt`, there are Go **linters** that can point out style
    errors or suspicious constructions; we are going to describe these in the *Coding
    formatters* section later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以跳过 `gofmt` 格式化器，但强烈建议在更改代码后以及发布之前使用它。一些工具在运行或编译你的 Go 程序之前会自动运行格式化器。除了 `gofmt`
    之外，还有 Go **linters** 可以指出风格错误或可疑结构；我们将在本章后面的 *编码格式化器* 部分描述这些。
- en: 'Furthermore, the Go community has published several guidelines that help with
    writing better code. Here is a list of the best ones:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Go 社区已经发布了几个有助于编写更好代码的指南。以下是其中最好的几个：
- en: '[https://github.com/uber-go/guide/blob/master/style.md](https://github.com/uber-go/guide/blob/master/style.md)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/uber-go/guide/blob/master/style.md](https://github.com/uber-go/guide/blob/master/style.md)'
- en: '[https://github.com/dgryski/awesome-go-style](https://github.com/dgryski/awesome-go-style)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dgryski/awesome-go-style](https://github.com/dgryski/awesome-go-style)'
- en: '[https://staticcheck.io/docs/checks/](https://staticcheck.io/docs/checks/)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://staticcheck.io/docs/checks/](https://staticcheck.io/docs/checks/)'
- en: Mindful code writing
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细编写代码
- en: Most of the time, we are going to be reading code instead of writing because
    the process of writing code drives you to read other parts of the code. So, you
    know where your code goes, how your code follows the existing design, and the
    behaviors the existing code has so that it doesn’t crash. The important point
    here is, even if you have no intention to share your code with anyone else, it
    will be probably forgotten by you in a few months, and if you might need to update
    it, you will have a hard time understanding what it does. So, write always thinking
    about someone reading it, even if this is just you.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们将阅读代码而不是编写代码，因为编写代码的过程会驱使我们阅读代码的其他部分。所以，你知道你的代码去哪里了，你的代码是如何遵循现有设计的，以及现有代码的行为，这样它就不会崩溃。这里的重要点是，即使你没有打算与他人分享你的代码，你可能在几个月后就会忘记它，如果你可能需要更新它，你将很难理解它做了什么。所以，编写代码时始终要考虑到有人会阅读它，即使这仅仅是你自己。
- en: Therefore, the process of writing code must be much more mindful than the process
    of reading. When someone reads part of the code, it should not create any doubts;
    it should be straightforward and easy, and quick to comprehend.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编写代码的过程必须比阅读代码的过程更加谨慎。当有人阅读代码的一部分时，它不应该产生任何疑问；它应该是直截了当的，易于理解，并且快速掌握。
- en: Making it extremely readable
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其极其易于阅读
- en: When writing code, don’t save words or phrases. If you have the opportunity
    to choose a mistake when writing your code, choose the one that over-explains
    your code. Why? Because your code should be understandable by anyone, and that
    includes you, in a few months or years. Therefore, make sure your code is easy
    to understand and easy to follow by someone new.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码时，不要节省单词或短语。如果你有机会在编写代码时选择错误，请选择一个过度解释你代码的错误。为什么？因为你的代码应该被任何人理解，包括几个月或几年后的你。因此，确保你的代码易于理解和跟踪，对于新手来说也是如此。
- en: Commenting your code
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释你的代码
- en: The code should be clear to understand; however, sometimes, it is necessary
    to comment on your code to help readers and reviewers understand your code. You
    should add comments throughout the code when you want to emphasize nuances in
    your code, describe details of some algorithms, or warn the reader about something
    odd.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该易于理解；然而，有时，对代码进行注释以帮助读者和审阅者理解代码是必要的。当你想要强调代码中的细微差别、描述某些算法的细节或警告读者有关某些异常时，你应该在代码中添加注释。
- en: Comment headers
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释标题
- en: 'Some text headers in comments are used to help the reader avoid spending time
    on code that should or might be changed. When you start coding with your team,
    check which terms are used for helping code readers and code reviewers. The comment
    headings listed here are not fixed and change between organizations and teams.
    Here are the most popular comment headers:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注释中的某些文本标题用于帮助读者避免在应该或可能需要更改的代码上浪费时间。当你开始与团队一起编码时，检查用于帮助代码阅读者和代码审阅者的术语。这里列出的注释标题不是固定的，它们在不同的组织和团队之间会有所变化。以下是最受欢迎的注释标题：
- en: '`TODO`: Perhaps the most common comment used is `TODO`, which is used to designate
    part of the code that needs to be added or refactored. This comment helps the
    reviewer avoid spending time reviewing a chunk of code that needs to be modified.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TODO`: 可能最常用的注释是`TODO`，它用于指定需要添加或重构的代码部分。这个注释帮助审阅者避免在需要修改的代码块上浪费时间。'
- en: '`FIXME`: Some developers when writing code also use the `FIXME` comment heading,
    which designates the part of the code that is wrong, ugly, has performance issues,
    or is too complicated. Use `FIXME` when you know something is wrong and should
    be fixed soon.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIXME`: 一些开发者在编写代码时也会使用`FIXME`注释标题，它指定了代码中错误、丑陋、性能问题或过于复杂的部分。当你知道某些东西是错误的并且应该尽快修复时，请使用`FIXME`。'
- en: '`HACK`: This text heading is used to designate part of the code that has a
    workaround to fix a bug or to help performance. The `HACK` heading is also another
    important comment to show the reader a quick workaround to be fixed later, helping
    them understand why that part of the code is there.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HACK`: 这个文本标题用于指定有解决错误或帮助性能的绕过方案的代码部分。`HACK`标题也是另一个重要的注释，向读者展示一个快速修复方案，稍后将其修复，帮助他们理解为什么代码的这一部分存在。'
- en: '`BUG`: This heading is used to show a problem in the code, which must be fixed
    soon. The author has identified the problem and decided to comment on that part
    of the code as a bug. The code reviewer can then evaluate and decide whether they
    have to accept the code with the bug or ask for corrections. Again, these comments
    save the time of the reviewer as they do not need to evaluate that part of the
    code in depth. Use this whenever you see a problem in the code.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUG`: 这个标题用于显示代码中的问题，必须尽快修复。作者已经识别了问题，并决定将代码的这一部分作为错误进行注释。代码审阅者可以评估并决定是否需要接受带有错误的代码或要求更正。同样，这些注释节省了审阅者的时间，因为他们不需要深入评估代码的这一部分。当你看到代码中的问题时，请使用此功能。'
- en: '`NOTE`: This heading is for the author to communicate with the readers some
    notable gotchas or particular details to help readers understand the code faster.
    Use them wisely to help reviewers understand, as too many `NOTE` headings can
    also be annoying and create a distraction.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`注意`: 这个标题是为了让作者与读者沟通一些值得注意的陷阱或特定细节，以帮助读者更快地理解代码。要明智地使用它们，以帮助审阅者理解，因为过多的`注意`标题也可能令人烦恼并造成干扰。'
- en: Docstring
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档字符串
- en: A docstring refers to a comment string that is used in Python to describe a
    module, function, class, or method. Docstrings are particular to Python and are
    detailed in *PEP-257*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串指的是在Python中用于描述模块、函数、类或方法的注释字符串。文档字符串是Python特有的，在*PEP-257*中有详细说明。
- en: Some **integrated development environments** (**IDEs**) such as PyCharm and
    IntelliJ will automatically create a docstring for you as soon as you define a
    function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一些**集成开发环境**（**IDEs**）如PyCharm和IntelliJ在你定义函数时将自动为你创建文档字符串。
- en: 'Here’s an example of a multiline docstring for a Python function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个Python函数多行文档字符串的例子：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the docstring is always initiated and ended with triple-double quotes
    (`"""`). The preceding example is a suggestion and other styles are possible.
    To visualize all possible styles, read the docstring conventions in *PEP-257*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文档字符串始终以三重双引号（`"""`）开始和结束。前面的例子只是一个建议，其他样式也是可能的。要可视化所有可能的样式，请阅读*PEP-257*中的文档字符串约定。
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Docstring documentation can be found at [https://peps.python.org/pep-0257/](https://peps.python.org/pep-0257/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Docstring 文档可以在 [https://peps.python.org/pep-0257/](https://peps.python.org/pep-0257/)
    找到。
- en: Godoc
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Godoc
- en: 'In Go, there is g`odoc`, which is simpler than a docstring as it is not a language
    construct or machine-readable syntax; it is just string text comments. The convention
    is simple: to document a variable, function, package, or constant, just write
    comments directly before its declaration. Here is an example of the comments used
    for the `Asin` function in the Go `math` package:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，有 g`odoc`，它比 docstring 简单，因为它不是一个语言构造或机器可读的语法；它只是字符串文本注释。惯例很简单：要注释变量、函数、包或常量，只需在其声明之前直接写注释。以下是在
    Go `math` 包中用于 `Asin` 函数的注释示例：
- en: '[PRE1]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that in this example, the comments are placed before the `Asin` function,
    and they describe in detail what to expect with the function and its special cases.
    Comments are always text that starts with a double slash (`//`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，注释放在 `Asin` 函数之前，并详细描述了函数及其特殊情况。注释总是以双斜杠（`//`）开头的文本。
- en: The preceding example was taken from the Go source code at [https://github.com/golang/go/blob/master/src/math/asin.go#L14-L25](https://github.com/golang/go/blob/master/src/math/asin.go#L14-L25).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例取自 Go 源代码 [https://github.com/golang/go/blob/master/src/math/asin.go#L14-L25](https://github.com/golang/go/blob/master/src/math/asin.go#L14-L25)。
- en: After commenting your code in Go, add explanations on functions such as in the
    preceding example. Developers can use the `godoc` tool, which extracts text and
    generates documentation in HTML or TXT format.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中注释你的代码后，添加与前面示例中类似的功能说明。开发者可以使用 `godoc` 工具，该工具提取文本并生成 HTML 或 TXT 格式的文档。
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `godoc` documentation is available at [https://pkg.go.dev/golang.org/x/tools/cmd/godoc](https://pkg.go.dev/golang.org/x/tools/cmd/godoc).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`godoc` 文档可在 [https://pkg.go.dev/golang.org/x/tools/cmd/godoc](https://pkg.go.dev/golang.org/x/tools/cmd/godoc)
    找到。'
- en: Use IP libraries
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IP 库
- en: 'Newbies in programming for networks may think IP addresses can be treated as
    a string or a list of characters. But when dealing with networks, it is very important
    to use the correspondent IP library to load an IP from a text file or to create
    one from a loop. There are several reasons you might want to avoid strings for
    IPs; some are presented here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络编程的新手来说，可能会认为 IP 地址可以像字符串或字符列表一样处理。但在处理网络时，使用相应的 IP 库从文本文件中加载 IP 或从循环中创建
    IP 非常重要。你可能想避免使用字符串作为 IP 的几个原因如下：
- en: Avoid numbers that are out of the scope of an IP, such as the number 256
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免超出 IP 范围的数字，例如数字 256
- en: Avoid malformed text IP addresses
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免格式不正确的文本 IP 地址
- en: Make sure not to overlap other space addresses
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保不要与其他空间地址重叠
- en: Easy to find the network, mask, and broadcast
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易找到网络、掩码和广播地址
- en: Easy transition from IP version 4 to IP version 6
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易从 IP 版本 4 转换到 IP 版本 6
- en: Let’s check how to use these IP libraries in Python and Go.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何在 Python 和 Go 中使用这些 IP 库。
- en: IP libraries in Python
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 中的 IP 库
- en: The IP address library in Python did not exist natively until version 3.3\.
    Before version 3.3, Python coders had to use external libraries to handle IP addresses.
    Python had to incorporate this library internally after realizing its importance.
    The transition was documented in *PEP-3144* ([https://peps.python.org/pep-3144/](https://peps.python.org/pep-3144/)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.3 版本之前，Python 中的 IP 地址库不是原生存在的。在 3.3 版本之前，Python 程序员必须使用外部库来处理 IP
    地址。Python 在意识到其重要性后，必须将此库内部化。这一过渡在 *PEP-3144* 中进行了记录([https://peps.python.org/pep-3144/](https://peps.python.org/pep-3144/))。
- en: Examples of IP manipulation using Python
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Python 进行 IP 操作的示例
- en: 'First, let’s print all valid IP addresses in a subnet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打印出子网中的所有有效 IP 地址：
- en: '[PRE2]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s the output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the output type is `IPv4Address` and not a string. The `ipaddress.ip_network()`
    method automatically detects whether it is an IPv4 or IPv6 address.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出类型是 `IPv4Address` 而不是字符串。`ipaddress.ip_network()` 方法会自动检测它是一个 IPv4 还是 IPv6
    地址。
- en: 'Now, let’s print the subnets that exist in a larger subnet, excluding one subnet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打印出较大子网中存在的子网，排除一个子网：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the type on the output is not an IP address type as it was before,
    but a network type called `IPv4Network`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出中的类型不再是之前的 IP 地址类型，而是一个名为 `IPv4Network` 的网络类型。
- en: IP libraries in Go
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go 中的 IP 库
- en: Go is different from Python as IP address libraries came after the Go language’s
    first version. IP manipulations in Go are faster than in Python because Go is
    not interpreted like Python but compiled.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Go 与 Python 不同，因为 IP 地址库是在 Go 语言的第一版之后出现的。Go 中的 IP 操作比 Python 中更快，因为 Go 不是像
    Python 那样被解释，而是被编译。
- en: Examples of IP manipulation using Go
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Go 进行 IP 操作的示例
- en: 'In Go, we are first going to check whether an IP address belongs to a subnet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，我们首先将检查一个 IP 地址是否属于一个子网：
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the output: `false`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：`false`。
- en: The `10.8.8.22` IP address does not belong to the `10.8.8.0/29` subnet as the
    program prints `false`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址 `10.8.8.22` 不属于 `10.8.8.0/29` 子网，因为程序输出 `false`。
- en: 'The next example checks whether a subnet belongs to another subnet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例检查一个子网是否属于另一个子网：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s the output: `true`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：`true`。
- en: In this example, `first_subnet` belongs to `second_subnet`, so they overlap.
    Note that in this example, we used a `"net/netip"` import instead of `"net"`,
    which is a newer IP manipulation package introduced to the Go language.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`first_subnet` 属于 `second_subnet`，因此它们重叠。请注意，在这个例子中，我们使用了 `"net/netip"`
    导入而不是 `"net"`，这是 Go 语言中引入的一个较新的 IP 操作包。
- en: In terms of comparison, the Python built-in library has more features for IP
    manipulation than the built-in Go IP packages. On the other hand, Go can manipulate
    IPs faster.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较方面，Python 的内置库在 IP 操作方面比内置的 Go IP 包具有更多功能。另一方面，Go 操作 IP 地址的速度更快。
- en: If you are looking for particular features for IP manipulation that are not
    present in `net` or `net/netip`, you can use a newly developed community package
    called `inet.af/netaddr`, described at [https://pkg.go.dev/inet.af/netaddr](https://pkg.go.dev/inet.af/netaddr).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找 `net` 或 `net/netip` 中不存在的特定 IP 操作功能，你可以使用一个新开发的社区包 `inet.af/netaddr`，详情请见
    [https://pkg.go.dev/inet.af/netaddr](https://pkg.go.dev/inet.af/netaddr)。
- en: Follow naming conventions
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循命名规范
- en: It is wise to verify with your team what the local development name conventions
    are before starting to publish any code for review. There are particular differences
    that might be a problem to use in your organization. Here, we are going to describe
    the most popular name conventions used, but feel free to adapt this to your local
    team culture.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始发布任何代码以供审查之前，与你的团队核实本地开发命名规范是明智的。可能会有一些特定的差异，在你的组织中使用可能会出现问题。在这里，我们将描述最流行的命名规范，但请根据你当地的团队文化进行适当调整。
- en: 'Before starting to describe the name conventions, let’s define three ways of
    writing multi-word names, as listed here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始描述命名规范之前，让我们定义三种书写多词名称的方式，如下所示：
- en: '`myFirstTestName`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myFirstTestName`'
- en: '`MyFirstTestName`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyFirstTestName`'
- en: '`my_first_test_name`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_first_test_name`'
- en: 'In the case of defining constants, all characters in the name must be in uppercase
    for most programming languages. Therefore, snake case is used always in lowercase,
    unless the name is describing a constant. Here’s an example of a name describing
    a constant that will define the maximum storage capacity: `MAX_STORAGE_CAPACITY`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义常量的情况下，大多数编程语言中名称中的所有字符都必须是大写。因此，蛇形命名法始终使用小写，除非名称描述的是常量。以下是一个描述常量的名称示例，它将定义最大存储容量：`MAX_STORAGE_CAPACITY`。
- en: Naming in Python
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 中的命名
- en: 'For Python, there are a few rules to follow when writing variable names. Here
    is a short list of what to do:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python，编写变量名时有一些规则需要遵循。以下是一个简短的列表，说明应该做什么：
- en: Variable names can start only with letters or underscore characters (`_`)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名只能以字母或下划线字符（`_`）开头
- en: The variable name can only have alphanumeric characters and underscores
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名只能包含字母数字字符和下划线
- en: Never start a variable name with a number
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名决不能以数字开头
- en: Dashes (`-`) are used only for package and module names, never for variables
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破折号（`-`）仅用于包和模块名称，决不用于变量
- en: Double underscore characters starting in variables are reserved for Python
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名开头的双下划线字符在 Python 中是保留的
- en: Use pascal case for class names
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名使用帕斯卡命名法
- en: Use snake case for module names and functions
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块名和函数使用蛇形命名法
- en: Constants in Python use all uppercase characters—for example, `MYCONSTANT`
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中的常量使用全部大写字母——例如，`MYCONSTANT`
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Google has a created a great name convention guide for Python, available publicly
    at [https://google.github.io/styleguide/pyguide.html#316-naming](https://google.github.io/styleguide/pyguide.html#316-naming).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Google 为 Python 创建了一个出色的命名规范指南，公开可访问于 [https://google.github.io/styleguide/pyguide.html#316-naming](https://google.github.io/styleguide/pyguide.html#316-naming)。
- en: Naming in Go
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go 中的命名
- en: 'For Go, there are a few rules to follow. Here is a list of the major ones to
    follow:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Go 语言，有一些规则需要遵循。以下是一些主要规则的列表：
- en: Variable names use camel case or pascal case
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名使用驼峰式（camel case）或帕斯卡式（pascal case）。
- en: As with variable names, function names use camel case or pascal case
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与变量名一样，函数名也使用驼峰式或帕斯卡式。
- en: Variable or function names don’t start with a number
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量或函数名不以数字开头。
- en: Use only alphanumeric characters for variable and function names
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和函数名仅使用字母数字字符。
- en: Dashes or underscores are normally not used for names
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破折号或下划线通常不用于命名。
- en: Go allows the use of snake case for variable names, but check whether your organization’s
    name convention allows it, because it is not common to use snake case in the Go
    community
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 允许使用蛇形命名法（snake case）来命名变量，但请检查您所在组织的命名规范是否允许这样做，因为在 Go 社区中不常用蛇形命名法。
- en: 'Constants in Go are like in Python: use all uppercase characters'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 中的常量与 Python 中的类似：使用全部大写字母。
- en: Moreover, Go has a particular difference from other languages, and uses uppercase
    in the variables inside a Go package (or module). So, if the variable name starts
    with uppercase, it is normally a variable that can be accessed from outside the
    Go package. When the variable starts with lowercase, it’s a local variable that
    is only accessible with code within the same Go package.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Go 与其他语言有一个特别的不同之处，它使用大写字母在 Go 包（或模块）内部的变量中。因此，如果变量名以大写字母开头，通常是一个可以从 Go 包外部访问的变量。当变量以小写字母开头时，它通常是一个局部变量，只能在同一
    Go 包内的代码中访问。
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A good reference for names in Go can be obtained at [https://go.dev/doc/effective_go](https://go.dev/doc/effective_go).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://go.dev/doc/effective_go](https://go.dev/doc/effective_go) 获取 Go
    中命名的好参考。
- en: Don’t shorten variable names
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要缩短变量名。
- en: In the early times of computer programming, variable names had to be small to
    save more space in memory when saving the uncompiled code. But today, this is
    not a problem, so don’t save memory when writing variable names.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程的早期，变量名必须小写以在保存未编译代码时节省内存空间。但如今，这已不再是问题，因此在编写变量名时无需考虑内存节省。
- en: If you have to write a variable for representing the number of birds flying,
    write `number_of_birds_flying` in snake case or `numberOfBirdsFlying` in camel
    case.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要编写一个变量来表示飞翔的鸟的数量，请使用蛇形命名法写成 `number_of_birds_flying` 或驼峰式命名法写成 `NumberOfBirdsFlying`。
- en: There is an exception to this rule if you are using variables inside list comprehension
    or variables in a loop such as counters or indexes; then, shortened variables
    are okay to use.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在列表推导式或循环中的变量（如计数器或索引）中使用变量，则对此规则有一个例外；在这种情况下，使用缩写变量是可以接受的。
- en: Avoid complex loops
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免复杂的循环。
- en: 'Loops are added to code for several reasons: to increment, interact with a
    list, repeat an operation, and read a stream, among others. It is possible to
    use loops for deterministic or non-deterministic sizes, which can be very useful
    when you don’t know what you are going to interact with.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 循环被添加到代码中有几个原因：增加、与列表交互、重复操作和读取流等。可以使用循环处理确定或非确定的大小，这在不知道将要交互的内容时非常有用。
- en: But irrespective of the intention you are using a loop in your code for, use
    them wisely so that they don’t become unreadable or too complex to understand.
    A good rule of thumb is to avoid too many lines inside a loop. I would say that
    20 lines would be the limit. Another good practice is to avoid nested loops or
    loops within loops. If you have to do a nested loop, limit the number of levels
    to no more than two. Loops are hard to read when they are nested, and even worse
    when there are too many lines inside them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论您在代码中使用循环的意图是什么，都要明智地使用它们，以免它们变得难以阅读或过于复杂。一个很好的经验法则是避免循环内部有太多的行。我会说20行应该是极限。另一个好的做法是避免嵌套循环或循环中的循环。如果您必须进行嵌套循环，请将层数限制在不超过两层。嵌套循环难以阅读，当它们内部有太多行时，情况会更糟。
- en: So, what is the best way to create a loop with fewer than 20 lines? The suggestion
    is to group a few operations into functions that can be called inside the loop.
    Name the function whatever you want it to do, and add the operations to it. When
    you are reading the loop, the function call will be easy to spot and the name
    of the function will indicate what the operation is doing, which is really easy
    to read and understand. Also, it is easier to write unit tests when using this
    approach.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，创建少于20行的循环的最佳方法是什么？建议是将几个操作组合成可以在循环内调用的函数。给函数命名，使其能够完成你想让它做的事情，并将操作添加到其中。当你阅读循环时，函数调用将很容易被发现，函数的名称将表明操作在做什么，这非常容易阅读和理解。此外，使用这种方法编写单元测试也更容易。
- en: How to avoid nested loops? Use functions to call a loop. Instead, you can also
    use generators, list comprehensions, or maps to avoid loops. Using maps has the
    advantage of making your code even faster as you don’t need to interact with it.
    List comprehensions are used in Python. Generators can be used in Python and are
    implemented using goroutines in Golang. So, whenever you need a nested loop, try
    not to overcomplicate it, and, if possible, use one of these mechanisms to avoid
    it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如何避免嵌套循环？使用函数来调用循环。相反，你也可以使用生成器、列表推导式或映射来避免循环。使用映射的优势在于，你不需要与之交互，因此可以使你的代码运行得更快。列表推导式在Python中使用。生成器可以在Python中使用，在Golang中通过goroutines实现。所以，每当你需要嵌套循环时，尽量不要使它过于复杂，如果可能的话，使用这些机制之一来避免它。
- en: Don’t repeat code
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重复代码
- en: In software development, there is one term that is called **DRY** or **Don’t
    Repeat Yourself**. The worst a developer can do is repeat code. Yes, it is bad—really
    bad. Why? Because if you write code that performs a task over and over in multiple
    places, whenever you want to modify that task, you will be required to carry out
    the same change in several places. The other problem is that you will have to
    write multiple unit tests for the same task.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，有一个术语称为 **DRY** 或 **Don’t Repeat Yourself**。开发者最糟糕的事情就是重复代码。是的，这是很糟糕——真的很糟糕。为什么？因为如果你在多个地方重复执行同一个任务的代码，那么每次你想修改这个任务时，你都需要在多个地方执行同样的更改。另一个问题是，你将不得不为同一个任务编写多个单元测试。
- en: The opposite view of DRY is **WET**, which stands for **Write Everything Twice**.
    A WET solution might occur because of multi-tiered architecture where developers
    have different tasks, and in the end, repetition may happen. A DRY approach should
    eliminate code redundancy by using a framework that helps developers avoid repetition.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: DRY的反面是 **WET**，代表 **Write Everything Twice**。WET解决方案可能发生在多层架构中，开发者有不同的任务，最终可能会出现重复。DRY方法应该通过使用帮助开发者避免重复的框架来消除代码冗余。
- en: In this section, we have seen some examples of how we can use best practices
    when writing code. In the next section, we are going to explore how we can use
    tools to help us write better code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了一些示例，说明了我们如何在编写代码时使用最佳实践。在下一节中，我们将探讨如何使用工具帮助我们编写更好的代码。
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are many more suggestions on best practices when writing code. A more
    extensive list can be found at [https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)
    and https://go.dev/doc/effective_go.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码的最佳实践方面还有许多建议。更详尽的列表可以在[https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)和https://go.dev/doc/effective_go找到。
- en: For Python, I recommend the book *Effective Python* by Scott Meyers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python，我推荐斯科特·迈耶斯的《Effective Python》。
- en: Coding formatters
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码格式化工具
- en: As we can now see, there are several rules and conventions to follow when writing
    code in Go or Python, and the list is long, which does not help when you are a
    beginner. But thanks to the community, there are tools that help to fix the code
    format for you. These tools can automatically fix your code or suggest modifications.
    Let’s have a look at a few code formatters for Python and Go.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到，在Go或Python中编写代码时，有许多规则和约定需要遵循，而且列表很长，这对于初学者来说并不有帮助。但是，多亏了社区，有一些工具可以帮助你修复代码格式。这些工具可以自动修复你的代码或提出修改建议。让我们看看Python和Go的一些代码格式化工具。
- en: Python Black
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python Black
- en: '**Black** is a very popular code formatter for Python. It is *PEP-8* compliant,
    so it checks all *PEP-8* recommendations. The default run will reformat the code
    to be *PEP-8* compliant, but you can run it as a preview to identify the code
    change suggestions.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**Black** 是一个非常流行的Python代码格式化工具。它是符合 *PEP-8* 的，因此它会检查所有的 *PEP-8* 建议。默认运行会将代码重新格式化为
    *PEP-8* 兼容，但你也可以运行它作为预览来识别代码更改建议。'
- en: 'With Black, it is possible to fix Python code automatically. Here is an example
    of wrong code written for Python:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Black，可以自动修复Python代码。以下是一个为Python编写的错误代码示例：
- en: '[PRE8]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After running Black, the code will look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Black后，代码将看起来像这样：
- en: '[PRE9]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Black does apply all recommendations of *PEP-8* and also has its own style.
    In the preceding example, Black has correctly changed the `if` statement and added
    the correct indentation. In addition, it changed the strings assignment from single
    quotes to double quotes. There is no specific PEP designating if you have to write
    strings with double or single quotes, but Black’s own style uses double quotes
    for strings.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Black确实应用了所有*PEP-8*的建议，并且也有自己的风格。在先前的例子中，Black正确地更改了`if`语句并添加了正确的缩进。此外，它将字符串赋值从单引号更改为双引号。没有具体的PEP指定你必须用双引号或单引号编写字符串，但Black自己的风格使用双引号来表示字符串。
- en: I personally think code that has single quotes in some strings and double quotes
    in other strings looks very ugly. So, I would recommend using double quotes only
    for strings, as Black does.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人认为，某些字符串使用单引号而其他字符串使用双引号的代码看起来非常丑陋。因此，我建议只使用双引号来表示字符串，就像Black一样。
- en: Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'More on Python Black can be found here: [https://github.com/psf/black](https://github.com/psf/black).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Python Black的信息，请参阅[https://github.com/psf/black](https://github.com/psf/black)。
- en: Python isort
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python isort
- en: One important bit that is not actually explained easily are the import lines
    that are present in the Python code. Sometimes there are dozens of imports, and
    if they are not properly organized, it is difficult to realize which ones are
    used and which are not.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际上不容易解释的重要部分是Python代码中存在的导入行。有时有数十个导入，如果它们没有得到适当的组织，就很难意识到哪些被使用，哪些没有被使用。
- en: Thanks to the `isort` utility, it is possible to fix `import` statements, group
    them correctly, and sort them automatically.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢`isort`实用程序，可以修复`import`语句，正确分组它们，并自动排序。
- en: 'Here is one example of code that has a loose ugly `import` statement:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例代码，它有一个松散且丑陋的`import`语句：
- en: '[PRE10]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After running `isort`, the code looks like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`isort`后，代码看起来像这样：
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that `isort` grouped the imports and sorted them in a predictable way.
    If you need to add extra imports, you will not repeat or miss them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`isort`将导入分组并按可预测的方式排序。如果你需要添加额外的导入，你不会重复或遗漏它们。
- en: Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'More on `isort` can be found here: [https://pypi.org/project/isort/](https://pypi.org/project/isort/).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`isort`的信息，请参阅[https://pypi.org/project/isort/](https://pypi.org/project/isort/)。
- en: Python YAPF
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python YAPF
- en: Although *PEP-8* guidelines may allow you to write code in a way that other
    developers will appreciate, it does not necessarily mean your code looks good.
    The **YAPF** acronym is not actually explained on the tool’s page, but it perhaps
    means **Yet Another Python Formatter**.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*PEP-8*指南可能允许你以其他开发者会欣赏的方式编写代码，但这并不一定意味着你的代码看起来很好。**YAPF**的缩写实际上在工具页面上没有解释，但它可能意味着**另一个Python格式化工具**。
- en: In essence, YAPF is similar to Black, which has its own style besides the *PEP-8*
    recommendations, but a major difference is that it can be configured for fine-tuning
    style formatting.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，YAPF与Black类似，除了遵循*PEP-8*建议外，它还有自己的风格，但一个主要区别是它可以配置以微调样式格式。
- en: YAPF is based on `clang-format` developed by Daniel Jasper, which takes the
    original code and reformats it using the YAPF style guide, even if the original
    code did not violate any *PEP-8* guidelines. If used in all code, the style remains
    consistent throughout the project, and reviewers would not need to discuss or
    argue about the style during code review.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: YAPF基于由Daniel Jasper开发的`clang-format`，它使用YAPF风格指南对原始代码进行重新格式化，即使原始代码没有违反任何*PEP-8*指南。如果在整个代码中使用，则整个项目的风格保持一致，并且审查者不需要在代码审查期间讨论或争论风格。
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'More on YAPF can be found here: [https://github.com/google/yapf](https://github.com/google/yapf).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于YAPF的信息，请参阅[https://github.com/google/yapf](https://github.com/google/yapf)。
- en: YAPF, `isort`, and Black are the three major Python code formatters, but the
    list of Python formatters is very extensive. Other formatters can be found at
    [https://github.com/life4/awesome-python-code-formatters](https://github.com/life4/awesome-python-code-formatters).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: YAPF、`isort`和Black是三大Python代码格式化工具，但Python格式化工具的列表非常广泛。其他格式化工具可以在[https://github.com/life4/awesome-python-code-formatters](https://github.com/life4/awesome-python-code-formatters)找到。
- en: Go gofmt
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go gofmt
- en: The Go language has its own formatter that comes with the Go language package,
    and it is called `gofmt`. Its objective is similar to Python Black and Python
    YAPF, which formats the source code to the best format that can be done consistently.
    The formatter is used with the CLI command of `go`—for example, `go fmt myprogram.go`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言自带一个格式化工具，它包含在Go语言包中，称为`gofmt`。其目标与Python Black和Python YAPF类似，即格式化源代码到最佳格式，并保持一致性。格式化工具与`go`命令行工具一起使用——例如，`go
    fmt myprogram.go`。
- en: Some platforms run automatically `gofmt` every time you want to build or run
    a Go program.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一些平台在每次你想构建或运行Go程序时都会自动运行`gofmt`。
- en: Go golines
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go golines
- en: '`golines` is a formatter that shortens long lines in addition to fixes done
    by `gofmt`. This formatter was created because `gofmt` does not break long lines
    and it is hard to visualize when lines are too long.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`golines`是一个格式化工具，除了修复`gofmt`所做的修复外，还可以缩短长行。这个格式化工具之所以被创建，是因为`gofmt`不会打断长行，当行太长时很难可视化。'
- en: 'Here is an example before running `golines`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`golines`之前，这是一个示例：
- en: '[PRE12]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After running `golines`, the code looks like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`golines`后，代码看起来像这样：
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: More details on how `golines` works are available at [https://yolken.net/blog/cleaner-go-code-golines](https://yolken.net/blog/cleaner-go-code-golines).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`golines`如何工作的更多详细信息，请参阅[https://yolken.net/blog/cleaner-go-code-golines](https://yolken.net/blog/cleaner-go-code-golines)。
- en: Go golangci-lint
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go golangci-lint
- en: A programming language lint or linter is software used to point errors, bugs,
    style errors, and suspicious constructs in the source code. It does not fix these
    automatically but flags errors and warnings to be fixed. For Go, the best linter
    package is `golangci-lint`, described in detail at [https://golangci-lint.run/](https://golangci-lint.run/).
    The original linter used for Go was located at [https://github.com/golang/lint](https://github.com/golang/lint)
    but was deprecated and frozen because of a lack of contribution.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言代码检查器或linter是一种用于指出源代码中的错误、bug、风格错误和可疑结构的软件。它不会自动修复这些问题，而是标记错误和警告以便修复。对于Go语言，最好的linter包是`golangci-lint`，详细信息请参阅[https://golangci-lint.run/](https://golangci-lint.run/)。最初用于Go语言的原始linter位于[https://github.com/golang/lint](https://github.com/golang/lint)，但由于缺乏贡献而被弃用并冻结。
- en: 'There are several checks that `golangci-lint` can do. The default most important
    checks are listed here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`golangci-lint`可以执行几个检查。这里列出了默认最重要的检查：'
- en: '`govet`: Checks whether format strings in `Printf` calls have correct aligned
    arguments'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`govet`：检查`Printf`调用中的格式字符串是否有正确对齐的参数'
- en: '`unused`: Checks unused variables, functions, and types'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unused`：检查未使用的变量、函数和类型'
- en: '`gosimple`: Points to parts of the code that can be simplified'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gosimple`：指出可以简化的代码部分'
- en: '`structcheck`: Verifies unused struct fields'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`structcheck`：验证未使用的结构体字段'
- en: '`deadcode`: Verifies any code that is not being used'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deadcode`：验证未使用的任何代码'
- en: A complete list of linters available can be found at [https://golangci-lint.run/usage/linters/](https://golangci-lint.run/usage/linters/).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://golangci-lint.run/usage/linters/](https://golangci-lint.run/usage/linters/)找到可用的完整linter列表。
- en: Note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A list of additional Go code formatters can be obtained at [https://github.com/life4/awesome-go-code-formatters](https://github.com/life4/awesome-go-code-formatters).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://github.com/life4/awesome-go-code-formatters](https://github.com/life4/awesome-go-code-formatters)获取额外的Go代码格式化工具列表。
- en: There are many more awesome tools that can format your code, not only via command-line
    tools but also via integrated IDE formatting tools. This section was created to
    introduce some of the tools used by Python and Go and show how to use them to
    help your code improve. In the next section, we are going to talk about how to
    use tools when developing code to help concurrent development and versioning.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他优秀的工具可以格式化你的代码，不仅限于命令行工具，还包括集成IDE格式化工具。本节创建的目的是介绍Python和Go使用的某些工具，并展示如何使用它们来帮助你的代码改进。在下一节中，我们将讨论如何在开发代码时使用工具来帮助并发开发和版本控制。
- en: Versioning and concurrent development
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制和并发开发
- en: Nowadays, writing code is not only about the lines of code you are creating
    but also about the code others are writing to contribute to your software. In
    addition, code that has changes requires some information regarding why the changes
    are there and some version tags to identify these so that developers can easily
    revert changes or use different versions when testing or deploying.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编写代码不仅关乎你创建的代码行数，还关乎其他人编写的代码，以贡献到你的软件中。此外，有变更的代码需要一些关于变更原因的信息，以及一些版本标签来识别这些变更，以便开发者可以轻松地回滚更改或在不同版本测试或部署时使用。
- en: How can we accomplish such tasks when writing code? The best answer is to use
    a version control system. Today the most popular free tools are **Git**, **SVN**,
    **Mercurial**, and **CVS**. Git, for sure, is the most popular of all, basically
    because of Linux and the growth of the GitHub website. *Table 5.2* shows a quick
    comparison between these four version control systems.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，我们如何完成这样的任务？最好的答案是使用版本控制系统。如今，最受欢迎的免费工具是 **Git**、**SVN**、**Mercurial**
    和 **CVS**。Git无疑是其中最受欢迎的，这基本上是因为Linux和GitHub网站的增长。*表5.2* 展示了这四种版本控制系统的快速比较。
- en: '| **Version system** | **Year created** | **Famous for** | **Website** |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **版本控制系统** | **创建年份** | **著名于** | **网站** |'
- en: '| Git | 2005 | Linux and [github.com](http://github.com) | [www.git-scm.com](http://www.git-scm.com)
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| Git | 2005 | Linux 和 [github.com](http://github.com) | [www.git-scm.com](http://www.git-scm.com)
    |'
- en: '| SVN | 2000 | FreeBSD and [sourceforge.com](http://sourceforge.com) | [subversion.apache.org](http://subversion.apache.org)
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| SVN | 2000 | FreeBSD 和 [sourceforge.com](http://sourceforge.com) | [subversion.apache.org](http://subversion.apache.org)
    |'
- en: '| CVS | 1986 | NetBSD and OpenBSD | [www.nongnu.org/cvs/](http://www.nongnu.org/cvs/)
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| CVS | 1986 | NetBSD 和 OpenBSD | [www.nongnu.org/cvs/](http://www.nongnu.org/cvs/)
    |'
- en: '| Mercurial | 2005 | Python and Mozilla | [www.mercurial-scm.org](http://www.mercurial-scm.org)
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| Mercurial | 2005 | Python 和 Mozilla | [www.mercurial-scm.org](http://www.mercurial-scm.org)
    |'
- en: Table 5.2 – Most popular version control systems comparison
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2 – 最受欢迎的版本控制系统比较
- en: When writing code, it is recommended to use a source version control system,
    which allows the software to be edited by multiple developers at the same mechanism
    to avoid adding code to the system without syncing the changes. Several different
    terms are used in versioning systems; the terms are almost the same over different
    systems such as Git or SVN.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码时，建议使用源代码版本控制系统，这允许多个开发者以相同的方式编辑软件，从而避免在不同步更改的情况下向系统中添加代码。版本控制系统中使用了几个不同的术语；这些术语在不同的系统如Git或SVN中几乎相同。
- en: Let’s describe the most common commands used by versioning systems.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下版本控制系统中最常用的命令。
- en: clone
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: clone
- en: '`clone` is a command to copy the whole source code, including subdirectories
    and versioning system data, to your local directory.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone` 是一个命令，用于将整个源代码（包括子目录和版本控制系统数据）复制到您的本地目录。'
- en: 'Here’s an example of the command being used in Git: `git clone https://github.com/brnuts/matrix.git`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Git中使用该命令的示例：`git clone https://github.com/brnuts/matrix.git`。
- en: checkout
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: checkout
- en: '`checkout` is a command to update files in the working directory to match the
    source tree source code. It is also used to switch to another code branch.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkout` 是一个命令，用于将工作目录中的文件更新为与源树源代码匹配。它还用于切换到另一个代码分支。'
- en: 'Here’s an example of the command being used in Git for updating the current
    branch: `git checkout`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Git中用于更新当前分支的命令示例：`git checkout`。
- en: 'And here’s an example of it being used in Git for checking out another branch:
    `git checkout mybranch`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在Git中用于检出另一个分支的示例：`git checkout mybranch`。
- en: commit
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: commit
- en: While changing the source code is recommended to change small chunks, each small
    change should attach a text tag describing the changes. The `commit` command is
    a command that adds a text tag to the code and a checkpoint number. As your code
    changes, you add commits to each small change. After the whole change is complete,
    you will have a change log that has multiple commit text explanations, helping
    the reader understand why and how the changes were made.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改源代码时，建议更改小块代码，每个小块更改都应该附上描述更改的文本标签。`commit` 命令是一个将文本标签添加到代码和检查点编号的命令。随着代码的变化，您会对每个小块更改添加提交。当整个更改完成后，您将有一个包含多个提交文本说明的更改日志，帮助读者理解更改的原因和方法。
- en: Mainline
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主分支
- en: '**Mainline** is normally the name of the main **branch** of the code. Other
    branches of the code normally ramify from the main branch or from other branches,
    which after ramification have a parent branch. In this sense, the mainline is
    a branch that has no parent branch.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**主分支**通常是代码的主要 **分支** 的名称。代码的其他分支通常从主分支或其他分支分支出来，分支后有一个父分支。在这个意义上，主分支是一个没有父分支的分支。'
- en: The mainline branch is known as the trunk of the source code tree and can also
    be called **master** or sometimes **baseline**.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 主分支也被称为源代码树的主干，有时也称为 **master** 或 **基线**。
- en: Branching
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支
- en: You can use versioning systems to create branches in your code. A **branch**
    is normally a ramification of the code from another branch. The goal of having
    a branch is to make particular changes to the code without interfering with the
    parent branch.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用版本控制系统在代码中创建分支。一个 **分支** 通常是从另一个分支分叉出来的代码。拥有分支的目的是在不干扰父分支的情况下对代码进行特定的更改。
- en: The code branch can then have as many changes as needed, and when ready can
    be added to the parent branch by using the `merge` command.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分支可以拥有所需的所有更改，当准备就绪时，可以使用 `merge` 命令将其添加到父分支。
- en: There are several advantages of using branches—one of them is to clarify the
    communication on the intention of a large change by adding several small change
    **commits** on the branch, with an explanation of each change. Another advantage
    is to allow other developers to continue to add changes to the parent branch.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分支有几个优点——其中之一是通过在分支上添加几个小的更改 **提交** 来阐明大改动的意图，并对每个更改进行解释。另一个优点是允许其他开发者继续向父分支添加更改。
- en: A branch without a parent branch is the mainline branch or the master branch.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 没有父分支的分支是主分支或主分支。
- en: Merging
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并
- en: A code `merge` command checks whether code can be added without interfering
    with the mainline branch code. If there is interference, it will create code `merge`
    command can also be done between individual branches without a mainline.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 `merge` 命令检查代码是否可以添加而不会干扰主分支代码。如果有干扰，它将创建代码 `merge` 命令也可以在单个分支之间进行，而不需要主分支。
- en: The merging technique is the safest technique used to combine branches without
    compromising any code that differs from other code. But sometimes, there are so
    many conflicts to be resolved that this might not be feasible. When that occurs,
    it is recommended to start a new branch and try to add the changes, gradually
    merging eventually, or to use the `rebase` command, which allows the commit to
    be applied from one branch to another branch interactively if necessary.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 合并技术是用于合并分支而不影响与其他代码不同的任何代码的最安全的技术。但有时，需要解决的冲突太多，这可能不可行。当这种情况发生时，建议开始一个新的分支，并尝试添加更改，最终逐步合并，或者使用
    `rebase` 命令，如果需要，允许将提交交互式地应用于另一个分支。
- en: 'Have a look at the following diagram:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的图：
- en: '![Figure 5.3 – A description of the mainline commits and branches](img/B18165_05_003.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 主分支提交和分支的描述](img/B18165_05_003.jpg)'
- en: Figure 5.3 – A description of the mainline commits and branches
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 主分支提交和分支的描述
- en: '*Figure 5.3* shows an example with all details of the versioning system for
    the mainline and the branches. You can also spot the commits and merges that are
    done for each branch and for the mainline as well. Note that branch 1 (green)
    was created to add two files, called `LICENSE` and `COPYRIGHT`, then was merged
    to the mainline. Branch 2 was created from a `432384DC` commit and has not been
    merged to the mainline yet.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.3* 展示了一个示例，其中包含了主分支和分支的版本控制系统的所有详细信息。您还可以看到为每个分支和主分支所做的提交和合并。请注意，分支 1（绿色）是为了添加两个文件而创建的，称为
    `LICENSE` 和 `COPYRIGHT`，然后被合并到主分支。分支 2 是从 `432384DC` 提交创建的，尚未合并到主分支。'
- en: In this section, we investigated how versioning tools help a great deal when
    developing code concurrently. Use a versioning system whenever you can to organize
    your development. In the next section, we are going to explore why and how we
    add testing to our code.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了版本控制工具在并发开发代码时如何大有裨益。尽可能使用版本控制系统来组织您的开发。在下一节中，我们将探讨为什么以及如何将测试添加到我们的代码中。
- en: Testing your code
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的代码
- en: Testing code is another subject that has grown in the past decades. In the early
    '70s, testing code was not actually part of the development process but part of
    the debugging process when there was a problem with the software. Testing assumed
    significance when American computer scientist Glenford Myers published the classic
    book *The Art of Software Testing* in 1979, proposing the separation of debugging
    from testing.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码是另一个在过去几十年中增长的主题。在 70 年代初，测试代码实际上并不是开发过程的一部分，而是在软件出现问题时作为调试过程的一部分。当美国计算机科学家
    Glenford Myers 在 1979 年发表了经典书籍 *软件测试的艺术* 时，测试变得重要，他提出了将调试与测试分离。
- en: Since then, much has improved in the development process with testing. Today,
    it is about preventing errors, and the process to develop code with tests that
    prevent errors is called **test-driven development** or **TDD**.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，开发过程中的测试得到了很大的改进。如今，重点是防止错误，而使用测试来防止错误的代码开发过程被称为**测试驱动开发**或**TDD**。
- en: 'In the process of developing the code, the developer must identify two parts
    of the code: **testable** and **non-testable** code. Testable code is pieces of
    code that are easily verified by low-level testing, such as a unit test. Non-testable
    code is pieces of code (such as the import of a library) that are not easily tested
    at a lower level and normally are tested with higher-level testing such as integration
    tests.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发代码的过程中，开发者必须识别代码的两大部分：**可测试**和**不可测试**的代码。可测试的代码是指那些可以通过低级测试（如单元测试）轻松验证的代码片段。不可测试的代码（如库的导入）则是在较低级别上不易测试的代码片段，通常需要通过高级测试（如集成测试）进行测试。
- en: Therefore, when writing code, the developer must be mindful of when and how
    tests would be performed for that part of the code. The developer will easily
    identify which part of the code can be done with lower- or higher-level testing.
    There are several levels of testing. Let’s discuss a few of them in the following
    subsections.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在编写代码时，开发者必须注意何时以及如何对该代码部分进行测试。开发者将很容易识别哪些代码部分可以使用低级或高级测试。有多个测试级别。以下小节中，我们将讨论其中的一些。
- en: Unit testing
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: '**Unit tests** are the lower level of testing because they are intended to
    cover a small part of code, which is the smallest piece of code that can be logically
    isolated. These pieces of code can be subroutines, functions, methods, loops,
    or properties. The goal of unit tests is to show that individual parts of the
    code are correct and—when used in methods or functions—to make sure they work
    as expected.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是测试的较低级别，因为它们旨在覆盖代码的小部分，这是可以逻辑上隔离的最小代码片段。这些代码片段可以是子程序、函数、方法、循环或属性。单元测试的目标是证明代码的各个部分是正确的，并且当它们在方法或函数中使用时，确保它们按预期工作。'
- en: If in the future, code has its libraries or modules upgraded or refactored,
    the unit tests created before are able to identify whether the code still works
    with the change, making it robust against eventual bugs introduced with upgrades.
    For that, unit tests have to be written to cover all functions, modules, methods,
    and properties; then, whatever change happens that could cause a fault would be
    quickly identified by the unit tests.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在未来，代码的库或模块进行了升级或重构，之前创建的单元测试能够识别代码是否仍然适用于这些变化，使其对升级过程中可能引入的最终错误具有鲁棒性。为此，必须编写单元测试来覆盖所有函数、模块、方法和属性；然后，无论发生什么可能导致故障的变化，都会被单元测试迅速识别。
- en: 'Unit tests can be written in several ways: some would write a function and
    then write the unit tests for this function; some would write the unit tests and
    then write the function. When unit tests are written first, this is normally called
    **test-driven development** (**TDD**) or **extreme programming** (**XP**).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以以多种方式编写：有些人会先写一个函数，然后为这个函数编写单元测试；有些人会先编写单元测试，然后编写函数。当单元测试首先编写时，这通常被称为**测试驱动开发**（**TDD**）或**极限编程**（**XP**）。
- en: As some code cannot be tested with unit tests, each team and organization has
    a **test coverage** parameter used to evaluate each software package. The number
    varies, but normally it is higher than 50% test coverage for the software package,
    and something higher than 80% for all new functions and methods introduced.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些代码无法通过单元测试进行测试，每个团队和组织都有一个用于评估每个软件包的**测试覆盖率**参数。这个数字各不相同，但通常软件包的测试覆盖率高于50%，所有新引入的功能和方法则高于80%。
- en: Unit tests are easy to create when a function or method has clear input parameters
    and some outputs, but it is not easy to create when a function interacts with
    external elements such as a database. For dealing with these external environments,
    some languages have **mock capabilities** (or **mockups**) to simulate the external
    behavior, without doing it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数或方法有明确的输入参数和一些输出时，单元测试很容易创建，但当函数与外部元素（如数据库）交互时，创建单元测试就不那么容易了。为了处理这些外部环境，一些语言有**模拟能力**（或**模拟**）来模拟外部行为，而不实际执行。
- en: If part of the code is not unit-testable (mocks are not available), it will
    probably be covered by higher-level testing, as with the ones we are going to
    talk about next.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码的一部分不可进行单元测试（没有可用的模拟），它可能会被更高级别的测试覆盖，就像我们接下来要讨论的那样。
- en: Integration testing
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: '**Integration tests** are used to fill the gaps of tests not possible to be
    performed with unit tests. These are normally tests that touch or require external
    environments such as databases, external files, or service APIs.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**用于填补无法通过单元测试执行的测试的空白。这些通常是涉及或需要外部环境，如数据库、外部文件或服务API的测试。'
- en: From a testing order perspective, integration testing is the second step after
    the unit tests have been done successfully and before the **end-to-end** (**E2E**)
    testing (if required). Integration testing normally uses broader code coverage
    in terms of modules and functions. It groups them into a large aggregate and applies
    a test plan to validate the expected outputs. Individual functions and modules
    are tested using unit tests. During integration tests, they are not necessarily
    tested individually but in a higher-level group.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试顺序的角度来看，集成测试是在单元测试成功完成后和**端到端测试（E2E**）（如果需要）之前的第二步。集成测试通常在模块和功能方面使用更广泛的代码覆盖率。它将它们组合成一个大的聚合体，并应用测试计划来验证预期的输出。单个函数和模块使用单元测试进行测试。在集成测试期间，它们不一定单独测试，而是在一个更高级别的组中测试。
- en: It is important to set up a test environment that can support integration testing,
    such as an external test database. During integration tests, the mockups added
    in the unit tests are not used, but real external testing environments are used.
    The external testing environment is normally separated from production and is
    dedicated to integration testing.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个可以支持集成测试的测试环境，例如外部测试数据库，这是很重要的。在集成测试期间，单元测试中添加的模拟不再使用，而是使用真实的外部测试环境。外部测试环境通常与生产环境分离，并专门用于集成测试。
- en: When performing integration tests, the test environment should behave in the
    same manner as the production environment, or at least very close to production.
    With similar production behavior, we can have more confidence, after the integration
    tests are passed, that the software will work in production.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行集成测试时，测试环境应该以与生产环境相同或至少非常接近的方式表现。在集成测试通过后，具有类似的生产行为，我们可以更有信心地认为软件将在生产环境中运行。
- en: Unit tests can run on someone’s computer; on the other hand, integration tests
    can’t because they rely on a testing environment that would validate the external
    communication from the software. Someone might say, *set up an environment for
    integration testing on your computer*, but it would then not be possible to validate
    some tests that require consistency.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以在某人的电脑上运行；另一方面，集成测试不能运行，因为它们依赖于一个验证软件外部通信的测试环境。有人可能会说，*在你的电脑上设置一个集成测试环境*，但那样的话，就无法验证一些需要一致性的测试了。
- en: E2E testing
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Most tests can be done by unit tests and integration tests; however, some might
    still be missing. **E2E tests** are added in another level of testing, which will
    evaluate the overall software, including performance, under a production-like
    environment.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试可以通过单元测试和集成测试来完成；然而，可能还有一些测试仍然缺失。**端到端测试（E2E tests**）在另一个测试级别中被添加，这将评估整体软件，包括性能，在一个类似生产环境下的表现。
- en: If possible and allowed, the ideal way is to run the E2E testing in the production
    environment. If it is not possible to run this in production, an isolated production-like
    environment can be used. The goal is to simulate the real scenario of the software
    running from the start to the end so that passing tests can validate the software
    and can be used without restrictions in production.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能并且允许的话，理想的方式是在生产环境中运行端到端测试。如果无法在生产环境中运行，可以使用一个隔离的类似生产环境。目标是模拟软件从开始到结束的真实场景，以便通过测试可以验证软件，并且可以在生产环境中无限制地使用。
- en: In terms of testing time and cycle, the E2E test should run last, as these tests
    take much longer to run than the integration tests. The test coverage should cover
    broader behavior, not only touching external interfaces but also using the whole
    workflow process that the software belongs to.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时间和周期方面，端到端测试应该最后运行，因为这些测试的运行时间比集成测试长得多。测试覆盖率应该覆盖更广泛的行为，不仅触及外部接口，还使用软件所属的整个工作流程过程。
- en: 'To summarize unit tests, integration tests, and E2E tests, let’s use an example.
    Imagine your software creates a robot that can paint cars. What would the responsibility
    of each testing level be? Here’s a possible implementation:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结单元测试、集成测试和端到端测试，让我们用一个例子来说明。想象一下，你的软件创建了一个可以喷漆的机器人。每个测试级别的责任是什么？以下是一个可能的实现：
- en: '**Unit tests**: Lower-level testing of small modules of the software:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：软件小型模块的底层测试：'
- en: Move *x*, *y*, and *z* directions
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动*x*，*y*，和*z*方向
- en: Self-identify unalignments
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自我识别不匹配
- en: Identify which color a container has
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别容器具有哪种颜色
- en: Spray paint evenly in all directions
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有方向上均匀喷涂油漆
- en: Don’t leak paint
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要泄漏油漆
- en: Identify the ending paint in the container
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别容器中的剩余油漆
- en: '**Integration tests**: Higher-level testing with external modules:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：与外部模块的高级测试：'
- en: Can paint a car full
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以涂装满一辆汽车
- en: Can refill paint in an empty paint container
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在空油漆容器中补充油漆
- en: Can paint car with different colors
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用不同颜色涂装汽车
- en: Doesn’t leave blank color spots in the car
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车中不留空白颜色区域
- en: '**E2E tests**: These would be the higher level, ultimate tests:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：这些将是更高层次、终极的测试：'
- en: Car can be painted in *X* minutes
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车可以在*X*分钟内涂装
- en: No interference on the next car or previous car when painting the current car
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涂装当前汽车时，对下一辆或上一辆汽车无干扰
- en: Robot can paint *Y* number of cars per hour, with paint refill and color change
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人每小时可以涂装*Y*辆汽车，包括油漆补充和颜色更换
- en: As we can see in this example, the number of tests is normally higher when the
    level of testing is lower. So, unit tests would have more tests than integration
    or E2E tests. However, the time to run tests is slower as we go higher up the
    levels. E2E testing should take longer to finish than integration or unit tests.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，测试数量通常在测试级别较低时更高。因此，单元测试会比集成或端到端测试有更多的测试。然而，随着测试级别的提高，运行测试的时间会变慢。端到端测试应该比集成或单元测试花费更长的时间来完成。
- en: Other testing
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他测试
- en: 'There are several other testing classifications. For our network automation,
    we are going to use only the three levels we just described: unit tests, integration
    tests, and E2E tests. The others we are going to explain here, for reference,
    can be added to your automation work if you think they are necessary.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几种测试分类。对于我们网络自动化，我们将只使用我们刚刚描述的三个级别：单元测试、集成测试和端到端测试。这里我们将解释的其他测试，仅供参考，如果您认为有必要，可以添加到您的自动化工作中。
- en: Let’s talk briefly about them now.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈它们。
- en: System testing
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统测试
- en: Technically speaking, all tests can be done by unit tests, integration tests,
    and E2E testing. The **system testing** is to add an extra testing phase that
    can be used to evaluate the system’s compliance with the specified requirements.
    Therefore, system testing is another name for testing in a formal procedure to
    verify that all requirements have been met.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，所有测试都可以通过单元测试、集成测试和端到端测试来完成。**系统测试**是添加一个额外的测试阶段，可以用来评估系统是否符合指定的要求。因此，系统测试是正式程序中验证所有要求都已满足的另一种说法。
- en: Acceptance testing
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验收测试
- en: When dealing with projects that involve end customers, it is important to align
    the expectations of the behavior of the software. Acceptance testing is a mechanism
    to negotiate and communicate with the end customer about the correct behavior
    of the system. **Acceptance tests** are like a contract between the end customer
    and the developer to delineate the final delivery of the software. The end customer
    is normally involved when selecting a test plan and tests so that the tests cover
    the system’s behavior and expectations.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理涉及最终客户的项目时，对软件行为预期的对齐很重要。验收测试是一种协商和与最终客户沟通系统正确行为的机制。**验收测试**是最终客户和开发者之间的一种合同，用于界定软件的最终交付。通常，在选择测试计划和测试时，最终客户会参与其中，以确保测试覆盖系统的行为和预期。
- en: The usual terms used here are **user acceptance test** (or **UAT**) and **operational
    acceptance test** (or **OAT**).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里常用的术语是**用户验收测试**（或**UAT**）和**操作验收测试**（或**OAT**）。
- en: If your network automation code is highly dependable on a customer’s use, with
    clear requirements, I would highly recommend writing test cases with the customer
    for UAT and OAT. But if your work is for internal usage and has no end-user requirements,
    integration and unit tests are sufficient.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的网络自动化代码高度依赖于客户的使用，并有明确的要求，我强烈建议与客户一起编写测试用例进行UAT和OAT。但如果您的工作是内部使用且没有最终用户需求，集成和单元测试就足够了。
- en: Security testing
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全测试
- en: If your software is deployed in restricted or vulnerable areas or touches network
    devices in a sensitive area, you might need to run security testing. Different
    from the other tests, **security testing** focuses on vulnerabilities of the code
    that you have created and also on all module dependencies that are imported by
    your code. The versions of all modules are also checked, and some versions might
    be prohibited because of some internal security policies.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的软件部署在受限或易受攻击的区域，或者触及敏感区域的网络设备，您可能需要运行安全测试。与其他测试不同，**安全测试**侧重于您所创建代码的漏洞，以及所有由您的代码导入的模块依赖项。所有模块的版本也会进行检查，某些版本可能因某些内部安全策略而被禁止。
- en: One additional test is called a **pentest** or a **penetration test**, which
    is performed on the system your software is created on. The idea of a pentest
    is to perform a simulated cyberattack on the final system used by your code. The
    test has the objective of identifying weaknesses and potential access for unauthorized
    people to data or the system.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个额外的测试称为**渗透测试**或**pentest**，它是在软件创建的系统上执行的。渗透测试的想法是对最终系统进行模拟网络攻击。测试的目标是识别弱点以及未经授权的人对数据或系统的潜在访问。
- en: Security testing also verifies the password management in the code and any cryptography
    used. There are some best practices when using passwords, such as cryptography
    and secrets that reduce the risk of unauthorized people accessing the system.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试还验证了代码中的密码管理和所使用的任何加密技术。在使用密码时有一些最佳实践，例如加密和秘密，这些可以降低未经授权的人访问系统的风险。
- en: For our network automation, security testing would be required if the devices
    we are going to automate were located in a vulnerable area, or if the software
    might be exposed to external parties or to the internet. But in general, there
    is no need for security testing for internal usage.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的网络自动化，如果我们将要自动化的设备位于易受攻击的区域，或者软件可能暴露给外部各方或互联网，那么就需要进行安全测试。但一般来说，对于内部使用，不需要进行安全测试。
- en: For sure, there is more to discuss in terms of security testing, but that would
    probably require a book on its own.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在安全测试方面还有更多可讨论的内容，但这可能需要一本自己的书来详细说明。
- en: Destructive testing
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 破坏性测试
- en: '**Destructive software testing** or **DST** is performed in the software to
    evaluate the robustness of the final system with the code that has been added.
    The tests are intended to stress the system or to enter invalid inputs so that
    the software starts to fail. The success of the test is to expose possible design
    weaknesses and performance limitations under normal and strained conditions.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**破坏性软件测试**或**DST**是在软件中执行的，以评估添加代码后最终系统的鲁棒性。测试的目的是对系统施加压力或输入无效输入，使软件开始失败。测试的成功在于在正常和压力条件下暴露可能的设计弱点和性能限制。'
- en: Failures during destructive tests are seen as good results if the system shows
    clearly the methods it has used to recover or to avoid breaking down completely.
    The performance is measured under the test, and the system resources are stressed
    to the maximum until degradation or failure occurs. It is possible to use the
    measurements taken during the performance stress later to add input system limitations
    for the current implementation, consequently avoiding any degradation.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在破坏性测试中，如果系统清楚地显示了它所使用的恢复或避免完全崩溃的方法，那么失败被视为良好的结果。在测试期间测量性能，并将系统资源压力最大化，直到出现退化或故障。可以使用在性能压力测试期间采取的测量结果，为当前实现添加输入系统限制，从而避免任何退化。
- en: Alpha and beta testing
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阿尔法和贝塔测试
- en: When tests are performed before going to production, some would call them **alpha**
    or **beta testing**. Normally, alpha tests are performed before beta tests, just
    because of the alphabetical order. The tests are not necessarily different from
    integration or E2E testing, but normally they are performed in a production-like
    environment, or sometimes in production.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当在投入生产之前进行测试时，有些人会称之为**alpha**或**beta测试**。通常，alpha测试是在beta测试之前进行的，仅仅是因为字母顺序。这些测试不一定与集成或端到端测试不同，但通常它们是在类似生产的环境中进行，有时甚至是在生产环境中进行。
- en: Some beta tests also involve customers that are aware of the new features being
    tested and can help evaluate the new software before it goes to other customers
    in production. Therefore, beta testing would be the final stage before the software
    is considered reliable enough to be deployed in full production. Beta and alpha
    tests can have windows of testing that can last from hours to days.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一些beta测试还涉及了解正在测试的新功能的客户，他们可以在新软件投入生产环境中的其他客户之前帮助评估新软件。因此，beta测试将是软件被认为足够可靠以全面部署在生产环境之前的最终阶段。beta和alpha测试可以有从数小时到数天的测试窗口。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! At this point, you are familiar with the coding practices used
    today. You know how to use tools to help your source code in terms of quality
    and concurrent development. You are also able to perceive the importance of having
    unit tests and integration tests added to your code.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！到目前为止，你已经熟悉了当今使用的编码实践。你知道如何使用工具来帮助你的源代码在质量和并发开发方面。你也能够认识到在代码中添加单元测试和集成测试的重要性。
- en: From now on, as a new code developer for automation, you are more equipped with
    the jargon and terms used in the software development community. You are able
    to improve not only the quality of your code but also your team’s code quality.
    Use the tools and the topics discussed here throughout your automation development
    career.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，作为一名自动化新代码开发者，你将更加熟悉软件开发社区中使用的术语和行话。你不仅能够提高你自己的代码质量，还能提高你团队的代码质量。在整个自动化开发生涯中，使用这里讨论的工具和主题。
- en: In the next chapter, we are going to have more practical examples of how to
    use Go and Python for network automation. We are going to explore some examples
    of automation in Go and Python and compare them.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将提供更多关于如何使用 Go 和 Python 进行网络自动化的实际示例。我们将探讨 Go 和 Python 中的自动化示例，并进行比较。
