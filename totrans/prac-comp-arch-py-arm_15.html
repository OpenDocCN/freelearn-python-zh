<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-202" lang="en-GB"><a id="_idTextAnchor219"/>Appendices – Summary of Key Concepts</h1>&#13;
			<p lang="en-GB">In these appendices, we will provide a brief summary of several of the aspects we introduced in this book. We will begin with an introduction to IDLE, the Python interpreter that lets you rapidly develop programs and test Python’s features.</p>&#13;
			<p lang="en-GB">The second appendix provides a very brief summary of some of the Linux commands that you might need when developing ARM assembly language programs with Raspberry Pi.</p>&#13;
			<p lang="en-GB">The third appendix provides a demonstration of the running and debugging of an ARM assembly program. The purpose of this example is to bring together in one place all the steps required to debug a program.</p>&#13;
			<p lang="en-GB">The fourth appendix covers some concepts that can cause students confusion, such as the computer use of the terms up and down, which sometimes mean something different from the normal meaning of up and down. For example, adding something to a computer stack causes the computer stack to grow up toward lower addresses.</p>&#13;
			<p lang="en-GB">The final appendix defines some of the concepts that we use when discussing computer languages such as Python.</p>&#13;
			<h1 id="_idParaDest-203" lang="en-GB"><a id="_idTextAnchor220"/>Using IDLE</h1>&#13;
			<p lang="en-GB">The Python programs in this book have been written in Python, saved as a <code>.py</code> file, and then executed in an <em class="italic">integrated development environment</em>. However, there is another approach to executing Python that you will see mentioned in many texts. This is the Python IDLE environment (included with the Python package) that lets you execute Python code line by line.</p>&#13;
			<p lang="en-GB">IDLE is an interpreter that reads a line of Python as it is <a id="_idIndexMarker712"/>input and then executes it. This is very helpful if you want to test a few lines of code without going to the trouble of creating a source program.</p>&#13;
			<p lang="en-GB">Consider the following example, where the text in bold font is my input:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Python 3.9.7 (tags/v3.9.7:1016ef3, Aug 30 2021, 20:19:38) [MSC v.1929 64 bit (AMD64)] on win32&#13;
Type "help", "copyright", "credits" or "license" for more information.&#13;
&gt;&gt;&gt; <strong class="bold">x = 4</strong>&#13;
&gt;&gt;&gt; <strong class="bold">y = 5</strong>&#13;
&gt;&gt;&gt; <strong class="bold">print('Sum =', x+y)</strong>&#13;
Sum = 9</pre>&#13;
			<pre class="source-code">&gt;&gt;&gt;</pre>&#13;
			<p lang="en-GB">When you run a compiled Python program, the output is displayed in the run window. Here, as you can see, each input line after the <code>&gt;&gt;&gt;</code> prompt is read and interpreted, and the result is printed.</p>&#13;
			<p lang="en-GB">This window is, in fact, part of the IDLE environment. This means that if your program crashes, you are able to examine variables <em class="italic">after</em> the crash. Consider the following example, where we create and run a program that contains an error:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# An error example&#13;
x = 5&#13;
y = input('Type a number = ')&#13;
z = x + y&#13;
print('x + y =',z)</pre>&#13;
			<p lang="en-GB">If we run this program, the execution window displays <a id="_idIndexMarker713"/>the following message:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Type a number = 3&#13;
Traceback (most recent call last):&#13;
  File "E:/ArchitectureWithPython/IDE_Test.py", line 4, in &lt;module&gt;&#13;
    z = x + y&#13;
TypeError: unsupported operand type(s) for +: 'int' and 'str'&#13;
&gt;&gt;&gt;</pre>&#13;
			<p lang="en-GB">The Python interpreter has indicated a <em class="italic">type error</em> because we entered a string and tried to add it to an integer. We can continue in the display window and look at the <code>x</code> and <code>y</code> variables and then modify the code as follows. All keyboard input is in bold:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
&gt;&gt;&gt; <strong class="bold">x</strong>&#13;
5&#13;
&gt;&gt;&gt; <strong class="bold">y</strong>&#13;
'3'&#13;
&gt;&gt;&gt; <strong class="bold">y = int(y)</strong>&#13;
&gt;&gt;&gt; <strong class="bold">z = x + y</strong>&#13;
&gt;&gt;&gt; <strong class="bold">z</strong>&#13;
8&#13;
&gt;&gt;&gt;</pre>&#13;
			<p lang="en-GB">We have now located and corrected the problem. Of course, it would be necessary to edit the original Python program to correct the source code.</p>&#13;
			<p lang="en-GB">Because IDLE executes a statement at a time, it appears impossible to execute a loop because that requires more than one line of code. There is a way. IDLE automatically indents instructions in loops, which allows multiple statements. In order to finish (close) the loop, you must type TWO enters. Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
&gt;&gt;&gt; <strong class="bold">i = 0</strong>&#13;
&gt;&gt;&gt; <strong class="bold">for j in range(0,5):</strong>  @ Here we've started a loop&#13;
      <strong class="bold">i = i + j*j</strong>         @ Add a statement. Note the automatic indentation&#13;
                          @ Now hit the enter key twice.&#13;
&gt;&gt;&gt; <strong class="bold">print(i)</strong>               @ We have exited the loop and added a new statement&#13;
30                         @ And here is the result&#13;
&gt;&gt;&gt;</pre>&#13;
			<h1 id="_idParaDest-204" lang="en-GB"><a id="_idTextAnchor221"/>Instructions and commands</h1>&#13;
			<p lang="en-GB">This appendix lists some of the popular <a id="_idIndexMarker714"/>commands you will use when running programs on Raspberry Pi:</p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Linux</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
cd ..                     @ Change dictionary to parent&#13;
mkdir /home/pi/testProg   @ Create new file called testProg in folder pi&#13;
ls /home/pi               @ List files in folder pi&#13;
as -g -0 file.o file.s    @ Assemble source file file.s to create object file file.o&#13;
ld -0 file file.o         @ Link object file file.o&#13;
gdb file                  @ Call debugger to debug file&#13;
sudo apt-get update       @ Download packages in your configuration source files&#13;
sudo apt-get upgrade      @ Updates all installed packages</pre>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Assembler directives</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
.text                     @ This is a code section&#13;
.global _start            @ _start is a label (first instruction)&#13;
.word                     @ Bind 32-bit value to label and store in memory&#13;
.byte                     @ Bind 8-bit value to label and store in memory&#13;
.equ                      @ .equ x,7 binds or equates 7 to the name x&#13;
.asciz                    @ Bind ASCII string to label and store (terminated by 0)&#13;
.balign                   @ .balign 4 locates instruction/data is on a word boundary</pre>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">gdb debugger</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
file toDebug              @ Load code file toDebug for debugging&#13;
b address                 @ Insert breakpoint at &lt;address&gt; (maybe line number or label)&#13;
x/4xw &lt;address&gt;           @ Display memory: four 32-bit words in hexadecimal format&#13;
x/7db &lt;address&gt;           @ Display memory: seven bytes in decimal format&#13;
r                         @ Run program (to a breakpoint or its termination)&#13;
s                         @ Step (execute) an instruction&#13;
n                         @ Same as step an instruction&#13;
i r                       @ Display registers&#13;
i b                       @ Display breakpoints</pre>&#13;
			<pre class="source-code">c                         @ Continue from breakpoint</pre>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Template for an ARM assembly language program</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                     .text          @ Indicate this is code&#13;
        .global _start              @ Provide entry point&#13;
_start: mov   r0,#0                 @ Start of the code&#13;
        mov   r0,#0                 @ Exit parameter (optional)&#13;
        mov   r7,#goHome            @ Set up leave command&#13;
        svc   #0                    @ Call operating system to exit this code&#13;
test:   .word  0xABCD1234           @ Store a word in memory with label 'test'&#13;
        .equ   goHome, 1            @ Equate name to value</pre>&#13;
			<h1 id="_idParaDest-205" lang="en-GB"><a id="_idTextAnchor222"/>Running an ARM program</h1>&#13;
			<p lang="en-GB">Here, we’ve put together all the information you need to run and debug a program on Raspberry Pi. We’re going to take the string copying example from <a href="B19624_11.xhtml#_idTextAnchor197"><em class="italic">Chapter 11</em></a> and go through it in more detail to provide a template for program development. This program takes an ASCII string and reverses it. In this case, the string is <code>"Hello!!!".</code> We have made <a id="_idIndexMarker715"/>it eight characters long so that it fits into two consecutive words (8 * 8 bits = 64 bits = 2 words).</p>&#13;
			<p lang="en-GB">We have located the source string, <code>string1</code>, in the body of the program, in the <code>.text</code> section, because it is only read from and never written to.</p>&#13;
			<p lang="en-GB">The destination, <code>str2</code>, that will receive the reversed string is in read/write memory in the <code>.data</code> section. Consequently, we have to use the technique of indirect pointers – that is, the .text portion has a pointer at <code>adr_str2</code> that contains the address of the actual string, <code>str2</code>.</p>&#13;
			<p lang="en-GB">The program contains several labels that are not accessed by the code (e.g., <code>preLoop</code> and <code>Wait</code>). The purpose of these labels is to make it easy to use breakpoints when debugging by giving them names.</p>&#13;
			<p lang="en-GB">A final feature is the use of <em class="italic">markers</em>. We have inserted markers in memory that follow both strings – that is, <code>0xAAFFFFBB</code> and <code>0xCCFFFFCC</code>. These make it easier to locate data when you look at memory because they stand out.</p>&#13;
			<p lang="en-GB">This program tests pointer-based addressing, bytes load and store, and auto-incrementing and decrementing of pointer registers. We will step through the execution of this program using <code>gdb</code>’s facilities:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
          .equ    len,8             @ Length of string to reverse (8 bytes/chars)&#13;
          .text                     @ Program (code) area&#13;
          .global _start            @&#13;
_start:   mov     r1,#len           @ Number of characters to move in r1&#13;
          adr     r2,string1        @ r2 points at source string1 in this section&#13;
          adr     r3,adr_str2       @ r3 points at dest string str2 address in this section&#13;
          ldr     r4,[r3]           @ r4 points to dest str2 in data section&#13;
preLoop:  add     r5,r4,#len-1      @ r5 points to bottom of dest str2&#13;
Loop:     ldrb    r6,[r2],#1        @ Get byte char from source in r6 inc pointer&#13;
          strb    r6,[r5],#-1       @ Store char in destination, decrement pointer&#13;
          subs    r1,r1,#1          @ Decrement char count&#13;
          bne     Loop              @ REPEAT until all done&#13;
Wait:     nop                       @ Stop here for testing&#13;
 &#13;
Exit:     mov     r0,#0             @ Stop here&#13;
          mov     r7,#1             @ Exit parameter required by svc&#13;
          svc     0                 @ Call operating system to exit program&#13;
 &#13;
string1:  .ascii  "Hello!!!"        @ The source string&#13;
marker:   .word   0xAAFFFFBB        @ Marker for testing&#13;
     &#13;
adr_str2: .word   str2              @ POINTER to source string2 in data area&#13;
 &#13;
          .data                     @ The read/write data area&#13;
str2:     .byte   0,0,0,0,0,0,0,0   @ Clear destination string&#13;
          .word   0xCCFFFFCC        @ Marker and terminator&#13;
          .end</pre>&#13;
			<p lang="en-GB">The program is loaded into the <code>gdb</code> and debugged <a id="_idIndexMarker716"/>by the following. Note that my input is in bold font:</p>&#13;
			<p lang="en-GB"><code>alan@raspberrypi:~/Desktop $ </code>gdb pLoop</p>&#13;
			<p lang="en-GB">The first step is to place three breakpoints on the labels so that we can execute code up to those points and then examine registers or memory:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">b _start</strong>&#13;
Breakpoint 1 at 0x10074: file pLoop.s, line 5.&#13;
(gdb) <strong class="bold">b preLoop</strong>&#13;
Breakpoint 2 at 0x10084: file pLoop.s, line 9.&#13;
(gdb) <strong class="bold">b Wait</strong>&#13;
Breakpoint 3 at 0x10098: file pLoop.s, line 14.</pre>&#13;
			<p lang="en-GB">We have set three breakpoints by using <code>b &lt;label&gt;</code> three times. We can check these breakpoints by using the <code>info b</code> command, which displays the state of the breakpoints:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">(gdb) info b</strong>&#13;
Num     Type           Disp Enb Address    What&#13;
1       breakpoint     keep y   0x00010074 pLoop.s:5&#13;
2       breakpoint     keep y   0x00010084 pLoop.s:9</pre>&#13;
			<pre class="source-code">3       breakpoint     keep y   0x00010098 pLoop.s:14</pre>&#13;
			<p lang="en-GB">The next step is to run the program as far as the first instruction:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">r</strong>&#13;
Starting program: /home/alan/Desktop/pLoop&#13;
Breakpoint 1, _start () at pLoop.s:5&#13;
5 _start:   mov     r1,#len            @ Number of characters to move in r1&#13;
(gdb) <strong class="bold">c</strong>&#13;
Continuing.</pre>&#13;
			<p lang="en-GB">There’s not a lot to see here. So, we hit <code>c</code> to continue to the <a id="_idIndexMarker717"/>next breakpoint, and then enter <code>i r</code> to display the registers. Note we have not displayed registers that have not been accessed:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Breakpoint 2, preLoop () at pLoop.s:9&#13;
9 preLoop:  add     r5,r4,#len-1       @ r5 points to bottom of dest str2&#13;
(gdb) i r&#13;
r0             0x0                 0&#13;
r1             0x8                 8&#13;
r2             0x100a8             65704      Pointer to string1&#13;
r3             0x100b4             65716      Pointer to str2 <strong class="bold">address</strong>&#13;
r4             0x200b8             131256     Pointer to str2 <strong class="bold">value</strong>&#13;
sp             0x7efff360          0x7efff360&#13;
lr             0x0                 0&#13;
pc             0x10084             0x10084 &lt;preLoop&gt;</pre>&#13;
			<p lang="en-GB">Let’s have a look at the data section in the code. Register <code>r2</code> points at this area, and the command means four words of memory in the hexadecimal form are displayed, starting at <code>0x100A8</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">(gdb) x/4wx 0x100a8</strong>&#13;
0x100a8 &lt;string1&gt;: 0x6c6c6548 0x2121216f 0xaaffffbb 0x000200b8</pre>&#13;
			<p lang="en-GB">The three highlighted values present the string <code>"Hello!!!"</code> and the marker <code>0xCCFFFFCC</code>. Note how these values appear <em class="italic">back to front</em>. This is a consequence of the little-endian byte ordering mode. The least-significant byte is located at the least-significant end of a word. In terms of ASCII characters, these are <code>lleH !!!o</code>.</p>&#13;
			<p lang="en-GB">We next perform a single step and display the memory in the data region. At this stage, the code had not been executed fully and this region should be as originally set up:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">(gdb) si 1</strong>&#13;
Loop () at pLoop.s:10&#13;
10 Loop:     ldrb    r6,[r2],#1        @ Get byte char from source in r6 inc pointer&#13;
(gdb) <strong class="bold">x/4wx 0x200b8</strong></pre>&#13;
			<pre class="source-code">0x200b8: 0x00000000 0x00000000 0xccffffcc 0x00001141</pre>&#13;
			<p lang="en-GB">Here, you can see the zeros loaded at bytes and the marker following them. We then enter <code>c</code> again and continue to the <code>Wait</code> breakpoint when the code should have been completed. Finally, we look at the registers and then the data memory:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) c&#13;
Continuing.&#13;
Breakpoint 3, Wait () at pLoop.s:14&#13;
14 Wait:     nop                       @ Stop here for testing&#13;
   &#13;
(gdb) <strong class="bold">i r</strong>&#13;
r0             0x0                 0&#13;
r1             0x0                 0&#13;
r2             0x100b0             65712&#13;
r3             0x100b4             65716&#13;
r4             0x200b8             131256&#13;
r5             0x200b7             131255&#13;
r6             0x21                33&#13;
sp             0x7efff360          0x7efff360&#13;
lr             0x0                 0&#13;
pc             0x10098             0x10098 &lt;Wait&gt;&#13;
<strong class="bold">(gdb) x/4wx 0x200b8</strong>&#13;
0x200b8: 0x6f212121 0x48656c6c 0xccffffcc 0x00001141</pre>&#13;
			<p lang="en-GB">Note that the data is changed. As you can see, the order <a id="_idIndexMarker718"/>has been reversed. Again, note the effect of the little-endianism on the byte order within words. The sequence of the data is now <code>o!!! Hell</code>. Finally, we enter <code>c</code> again and the program is completed:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) c&#13;
Continuing.&#13;
[Inferior 1 (process 11670) exited normally]&#13;
(gdb)</pre>&#13;
			<h1 id="_idParaDest-206" lang="en-GB"><a id="_idTextAnchor223"/>Common confusions</h1>&#13;
			<p lang="en-GB">The growth of computing from the 1960s to today was rapid and chaotic. The chaos arose because the technology developed so rapidly that systems became obsolete in months, and that meant much of the design was obsolete but had been incorporated in systems <a id="_idIndexMarker719"/>that were now being held back by it. Similarly, many different notations and conventions arose – for example, does <code>MOVE A,B</code> move <code>A</code> to <code>B</code>, or <code>B</code> to <code>A</code>? Both conventions were used at the same time by different computers. Here are a few pointers to help with the confusion.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In this book, we will largely adopt the right-to-left convention for data movement. For example, <code>add </code>r1<code>,r2,r2</code> indicates the addition of<code> r2</code> and <code>r3</code>, and the sum is put in <code>r1</code>. As a means of highlighting this, I often put the destination operand of an operation in bold font.</p>&#13;
			<p lang="en-GB">Symbols are often used with different meanings. This is particularly true of<code> #</code>,<code> @</code>,<code> </code>and<code> %</code>.</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>if x &gt; y: z = 2</code>.  <code>#</code> Reset <code>z</code> if <code>x</code> ever exceeds <code>y</code>. The hash is used in ARM assembly language to indicate a literal value – for example, <code>add </code>r0<code>,r1,#5</code>.  <code>@</code> Add the integer <code>5</code> to the contents of <code>r1</code> and put in <code>r2</code>.</li>&#13;
				<li lang="en-GB"><strong class="bold">@</strong>: The <em class="italic">at</em> symbol is used to indicate <a id="_idIndexMarker721"/>a comment in the ARM assembly language.</li>&#13;
				<li lang="en-GB"><code>add </code>r1<code>,r2,#%1010</code> means add the literal value expressed in the binary form. Python uses the prefix <code>0b</code> to indicate binary values (e.g., 0b1010).</li>&#13;
				<li lang="en-GB"><code>0x</code> to indicate hexadecimal values (e.g., 0xA10C).</li>&#13;
				<li lang="en-GB"><strong class="bold">Register indirect addressing</strong>: A key concept in <a id="_idIndexMarker724"/>programming at the assembly language level is the pointer – that is, a variable that is the address of an element in memory. This addressing mode is called register indirect, pointer-based, or even indexed addressing.</li>&#13;
				<li lang="en-GB"><strong class="bold">Up and down</strong>: In normal everyday use, up and down <a id="_idIndexMarker725"/>indicate the direction toward the sky (up) or toward the ground (down). In arithmetic, they indicate increasing a number (up) or decreasing it (down). In computing, when data items are added to a stack, the stack grows up. However, by convention, the address grows down as items are added. Consequently, the stack pointer is decremented when items are added to the stack and incremented when items are removed.</li>&#13;
				<li lang="en-GB"><code>ldr r0,=0x12345678</code>, a big endian computer would store the bytes in byte memory at increasing addresses in the order 12,34,56,78, whereas a little endian computer would store the bytes in the order 78,56,34,12. The ARM is a little endian machine, although it can be programmed to operate in a big endian mode. In practice, this means that you must be careful when debugging programs and looking at memory dumps. Equally, you must be careful when performing byte operations on word values to ensure that you select the correct byte.</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-207" lang="en-GB"><a id="_idTextAnchor224"/>Vocabulary</h1>&#13;
			<p lang="en-GB">All specializations have their <a id="_idIndexMarker727"/>own vocabulary, and programming is no exception. Here are a few words that you might find helpful in understanding the text and its context.</p>&#13;
			<ul>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB"><code>1</code>s and <code>0</code>s. Humans write programs in a high-level language such as Python that is close to plain English. Before a high-level language program can be executed, a piece of software called a <em class="italic">compiler</em> translates it into binary code. When you run a Python program on your computer, your source code is automatically translated into machine code by a compiler working with the operating system. Mercifully, you don’t have to worry about all the actions that take place invisibly in the background during compilation.</li>&#13;
				<li lang="en-GB"><code>y = "4" + 1</code>. This is a syntax error because I’m adding two different entities that can’t be added. The "<code>4</code>" is a character (you can print it), whereas the <code>1</code> is an integer. You can write <code>y = "4" + "1" </code>or<code> z = 4 + 1</code>. These are both syntactically correct, and <code>y</code> is <code>"41"</code>, whereas <code>z</code> is <code>5</code>.</li>&#13;
				<li lang="en-GB"><strong class="bold">Semantic error</strong>: Semantics is <a id="_idIndexMarker730"/>concerned with meaning. A syntax error means that the sentence is grammatically wrong even if it is syntactically correct. An example of a sentence in English with a semantic error is, <em class="italic">“Twas brillig, and the slithy toves did gyre and gimble in the wabe.”</em> This is grammatically correct but does not have a meaning – that is, it’s semantically incorrect. In computing, a semantic error means that your program doesn’t do what you intended. A compiler can detect a syntax error but not usually a semantic error.</li>&#13;
				<li lang="en-GB"><code>age = 25</code>, you’ve created a new variable called <code>age</code> with the value <code>25</code>. If you refer to age, the actual value will be substituted. The expression <code>y = age + 10</code> would give y the value <code>35</code>. A variable has four attributes – its name (what you call it), its address (where it’s stored in the computer), its value (what it actually is), and its type (e.g., an integer, list, character, or string).</li>&#13;
				<li lang="en-GB"><code>c = 2πr</code>, where <code>2</code> and <code>π</code> are constants. Both <code>c</code> and <code>r</code> are variables.</li>&#13;
				<li lang="en-GB"><code>c</code> and its radius <code>r</code>. We give the irrational number <code>3.1415926</code> the symbolic name <code>π</code>. When a program is compiled into machine code, symbolic names are replaced by actual values.</li>&#13;
				<li lang="en-GB"><code>1234</code>. A programmer normally does not have to worry about where data is actually located in memory. Translating addresses from the logical addresses used in programs to the physical addresses of memory devices is the domain of the operating system.</li>&#13;
				<li lang="en-GB"><code>c = 2πr</code>, what is <code>r</code>? We (humans) see <code>r</code> as the symbolic name for the value of the radius – say, 5. But the computer sees <code>r</code> as the memory address 1234, which has to be read to provide the actual value of <code>r</code>. If we write <code>r = r + 1</code>, do we mean <code>r = 5 + 1 = 6</code> or do we mean <code>r = 1234 + 1 = 1235</code>? It’s important to distinguish between an <em class="italic">address</em> and its <em class="italic">contents</em>. This factor becomes significant when we introduce pointers.</li>&#13;
				<li lang="en-GB"><code>i</code> is really a pointer; we just call it an <em class="italic">index</em>. If we change the pointer (index) we can step through the elements of a table, array, or matrix and step through elements x1, x2, x3, and x4.</li>&#13;
			</ul>&#13;
		</p>&#13;
	</div></body></html>