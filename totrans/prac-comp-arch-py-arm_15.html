<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer095" class="_idGenObjectStyleOverride-1">&#13;
			<h1 id="_idParaDest-202" lang="en-GB"><a id="_idTextAnchor219"/>Appendices – Summary of Key Concepts</h1>&#13;
			<p lang="en-GB">In these appendices, we will provide a brief summary of several of the aspects we introduced in this book. We will begin with an introduction to IDLE, the Python interpreter that lets you rapidly develop programs and test <span class="No-Break">Python’s features.</span></p>&#13;
			<p lang="en-GB">The second appendix provides a very brief summary of some of the Linux commands that you might need when developing ARM assembly language programs with <span class="No-Break">Raspberry Pi.</span></p>&#13;
			<p lang="en-GB">The third appendix provides a demonstration of the running and debugging of an ARM assembly program. The purpose of this example is to bring together in one place all the steps required to debug <span class="No-Break">a program.</span></p>&#13;
			<p lang="en-GB">The fourth appendix covers some concepts that can cause students confusion, such as the computer use of the terms up and down, which sometimes mean something different from the normal meaning of up and down. For example, adding something to a computer stack causes the computer stack to grow up toward <span class="No-Break">lower addresses.</span></p>&#13;
			<p lang="en-GB">The final appendix defines some of the concepts that we use when discussing computer languages such <span class="No-Break">as Python.</span></p>&#13;
			<h1 id="_idParaDest-203" lang="en-GB"><a id="_idTextAnchor220"/>Using IDLE</h1>&#13;
			<p lang="en-GB">The Python programs in this book have been written in Python, saved as a <strong class="source-inline">.py</strong> file, and then executed in an <em class="italic">integrated development environment</em>. However, there is another approach to executing Python that you will see mentioned in many texts. This is the Python IDLE environment (included with the Python package) that lets you execute Python code line <span class="No-Break">by line.</span></p>&#13;
			<p lang="en-GB">IDLE is an interpreter that reads a line of Python as it is <a id="_idIndexMarker712"/>input and then executes it. This is very helpful if you want to test a few lines of code without going to the trouble of creating a <span class="No-Break">source program.</span></p>&#13;
			<p lang="en-GB">Consider the following example, where the text in bold font is <span class="No-Break">my input:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Python 3.9.7 (tags/v3.9.7:1016ef3, Aug 30 2021, 20:19:38) [MSC v.1929 64 bit (AMD64)] on win32</span>&#13;
<span>Type "help", "copyright", "credits" or "license" for more information.</span>&#13;
<span>&gt;&gt;&gt; <strong class="bold">x = 4</strong></span>&#13;
<span>&gt;&gt;&gt; <strong class="bold">y = 5</strong></span>&#13;
<span>&gt;&gt;&gt; <strong class="bold">print('Sum =', x+y)</strong></span>&#13;
<span>Sum = 9</span></pre>&#13;
			<pre class="source-code">&gt;&gt;&gt;</pre>&#13;
			<p lang="en-GB">When you run a compiled Python program, the output is displayed in the run window. Here, as you can see, each input line after the <strong class="source-inline">&gt;&gt;&gt;</strong> prompt is read and interpreted, and the result <span class="No-Break">is printed.</span></p>&#13;
			<p lang="en-GB">This window is, in fact, part of the IDLE environment. This means that if your program crashes, you are able to examine variables <em class="italic">after</em> the crash. Consider the following example, where we create and run a program that contains <span class="No-Break">an error:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span># An error example</span>&#13;
<span>x = 5</span>&#13;
<span>y = input('Type a number = ')</span>&#13;
<span>z = x + y</span>&#13;
<span>print('x + y =',z)</span></pre>&#13;
			<p lang="en-GB">If we run this program, the execution window displays <a id="_idIndexMarker713"/>the <span class="No-Break">following message:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Type a number = 3</span>&#13;
<span>Traceback (most recent call last):</span>&#13;
<span>  File "E:/ArchitectureWithPython/IDE_Test.py", line 4, in &lt;module&gt;</span>&#13;
<span>    z = x + y</span>&#13;
<span><span class="Color-Red">TypeError: unsupported operand type(s) for +: 'int' and 'str'</span></span>&#13;
<span>&gt;&gt;&gt;</span></pre>&#13;
			<p lang="en-GB">The Python interpreter has indicated a <em class="italic">type error</em> because we entered a string and tried to add it to an integer. We can continue in the display window and look at the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> variables and then modify the code as follows. All keyboard input is <span class="No-Break">in bold:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>&gt;&gt;&gt; <strong class="bold">x</strong></span>&#13;
<span>5</span>&#13;
<span>&gt;&gt;&gt; <strong class="bold">y</strong></span>&#13;
<span>'3'</span>&#13;
<span>&gt;&gt;&gt; <strong class="bold">y = int(y)</strong></span>&#13;
<span>&gt;&gt;&gt; <strong class="bold">z = x + y</strong></span>&#13;
<span>&gt;&gt;&gt; <strong class="bold">z</strong></span>&#13;
<span>8</span>&#13;
<span>&gt;&gt;&gt;</span></pre>&#13;
			<p lang="en-GB">We have now located and corrected the problem. Of course, it would be necessary to edit the original Python program to correct the <span class="No-Break">source code.</span></p>&#13;
			<p lang="en-GB">Because IDLE executes a statement at a time, it appears impossible to execute a loop because that requires more than one line of code. There is a way. IDLE automatically indents instructions in loops, which allows multiple statements. In order to finish (close) the loop, you must type TWO enters. Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>&gt;&gt;&gt; <strong class="bold">i = 0</strong></span>&#13;
<span>&gt;&gt;&gt; <strong class="bold">for j in range(0,5):</strong>  <span class="sc-comment">@ Here we've started a loop</span></span>&#13;
<span><span class="sc-comment CharOverride-1">      </span><strong class="bold">i = i + j*j</strong><span class="sc-comment CharOverride-1">         </span><span class="sc-comment">@ Add a statement. Note the automatic indentation</span></span>&#13;
<span><span class="sc-comment CharOverride-1">                          </span><span class="sc-comment">@ Now hit the enter key twice.</span></span>&#13;
<span><span class="sc-comment">&gt;&gt;&gt; </span><strong class="bold">print(i)</strong><span class="sc-comment CharOverride-1">               </span><span class="sc-comment">@ We have exited the loop and added a new statement</span></span>&#13;
<span><span class="sc-comment">30 </span><span class="sc-comment CharOverride-1">                        </span><span class="sc-comment">@ And here is the result</span></span>&#13;
<span>&gt;&gt;&gt;</span></pre>&#13;
			<h1 id="_idParaDest-204" lang="en-GB"><a id="_idTextAnchor221"/>Instructions and commands</h1>&#13;
			<p lang="en-GB">This appendix lists some of the popular <a id="_idIndexMarker714"/>commands you will use when running programs on <span class="No-Break">Raspberry Pi:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Linux</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>cd ..                     <span class="sc-comment">@ Change dictionary to parent</span></span>&#13;
<span>mkdir /home/pi/testProg   <span class="sc-comment">@ Create new file called testProg in folder pi</span></span>&#13;
<span>ls /home/pi               <span class="sc-comment">@ List files in folder pi</span></span>&#13;
<span>as -g -0 file.o file.s    <span class="sc-comment">@ Assemble source file file.s to create object file file.o</span></span>&#13;
<span>ld -0 file file.o         <span class="sc-comment">@ Link object file file.o</span></span>&#13;
<span>gdb file                  <span class="sc-comment">@ Call debugger to debug file</span></span>&#13;
<span>sudo apt-get update       <span class="sc-comment">@ Download packages in your configuration source files</span></span>&#13;
<span>sudo apt-get upgrade      <span class="sc-comment">@ Updates all installed packages</span></span></pre>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Assembler directives</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>.text                     <span class="sc-comment">@ This is a code section</span></span>&#13;
<span>.global _start            <span class="sc-comment">@ _start is a label (first instruction)</span></span>&#13;
<span>.word                     <span class="sc-comment">@ Bind 32-bit value to label and store in memory</span></span>&#13;
<span>.byte                     <span class="sc-comment">@ Bind 8-bit value to label and store in memory</span></span>&#13;
<span>.equ                      <span class="sc-comment">@ .equ x,7 binds or equates 7 to the name x</span></span>&#13;
<span>.asciz                    <span class="sc-comment">@ Bind ASCII string to label and store (terminated by 0)</span></span>&#13;
<span>.balign                   <span class="sc-comment">@ .balign 4 locates instruction/data is on a word boundary</span></span></pre>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">gdb debugger</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>file toDebug              <span class="sc-comment">@ Load code file toDebug for debugging</span></span>&#13;
<span>b address                 <span class="sc-comment">@ Insert breakpoint at &lt;address&gt; (maybe line number or label)</span></span>&#13;
<span>x/4xw &lt;address&gt;           <span class="sc-comment">@ Display memory: four 32-bit words in hexadecimal format</span></span>&#13;
<span>x/7db &lt;address&gt;           <span class="sc-comment">@ Display memory: seven bytes in decimal format</span></span>&#13;
<span>r                         <span class="sc-comment">@ Run program (to a breakpoint or its termination)</span></span>&#13;
<span>s                         <span class="sc-comment">@ Step (execute) an instruction</span></span>&#13;
<span>n                         <span class="sc-comment">@ Same as step an instruction</span></span>&#13;
<span>i r                       <span class="sc-comment">@ Display registers</span></span>&#13;
<span>i b                       <span class="sc-comment">@ Display breakpoints</span></span></pre>&#13;
			<pre class="source-code">c                         <span class="sc-comment">@ Continue from breakpoint</span></pre>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Template for an ARM assembly language program</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                     .text          <span class="sc-comment">@ Indicate this is code</span></span>&#13;
<span>        .global _start              <span class="sc-comment">@ Provide entry point</span></span>&#13;
<span>_start: mov   r0,#0                 <span class="sc-comment">@ Start of the code</span></span>&#13;
<span>        mov   r0,#0                 <span class="sc-comment">@ Exit parameter (optional)</span></span>&#13;
<span>        mov   r7,#goHome            <span class="sc-comment">@ Set up leave command</span></span>&#13;
<span>        svc   #0                    <span class="sc-comment">@ Call operating system to exit this code</span></span>&#13;
<span>test:   .word  0xABCD1234           <span class="sc-comment">@ Store a word in memory with label 'test'</span></span>&#13;
<span>        .equ   goHome, 1            <span class="sc-comment">@ Equate name to value</span></span></pre>&#13;
			<h1 id="_idParaDest-205" lang="en-GB"><a id="_idTextAnchor222"/>Running an ARM program</h1>&#13;
			<p lang="en-GB">Here, we’ve put together all the information you need to run and debug a program on Raspberry Pi. We’re going to take the string copying example from <a href="B19624_11.xhtml#_idTextAnchor197"><span class="No-Break"><em class="italic">Chapter 11</em></span></a> and go through it in more detail to provide a template for program development. This program takes an ASCII string and reverses it. In this case, the string is <strong class="source-inline">"Hello!!!".</strong> We have made <a id="_idIndexMarker715"/>it eight characters long so that it fits into two consecutive words (8 * 8 bits = 64 bits = <span class="No-Break">2 words).</span></p>&#13;
			<p lang="en-GB">We have located the source string, <strong class="source-inline">string1</strong>, in the body of the program, in the <strong class="source-inline">.text</strong> section, because it is only read from and never <span class="No-Break">written to.</span></p>&#13;
			<p lang="en-GB">The destination, <strong class="source-inline">str2</strong>, that will receive the reversed string is in read/write memory in the <strong class="source-inline">.data</strong> section. Consequently, we have to use the technique of indirect pointers – that is, the .text portion has a pointer at <strong class="source-inline">adr_str2</strong> that contains the address of the actual <span class="No-Break">string, </span><span class="No-Break"><strong class="source-inline">str2</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The program contains several labels that are not accessed by the code (e.g., <strong class="source-inline">preLoop</strong> and <strong class="source-inline">Wait</strong>). The purpose of these labels is to make it easy to use breakpoints when debugging by giving <span class="No-Break">them names.</span></p>&#13;
			<p lang="en-GB">A final feature is the use of <em class="italic">markers</em>. We have inserted markers in memory that follow both strings – that is, <strong class="source-inline">0xAAFFFFBB</strong> and <strong class="source-inline">0xCCFFFFCC</strong>. These make it easier to locate data when you look at memory because they <span class="No-Break">stand out.</span></p>&#13;
			<p lang="en-GB">This program tests pointer-based addressing, bytes load and store, and auto-incrementing and decrementing of pointer registers. We will step through the execution of this program using <span class="No-Break"><strong class="source-inline">gdb</strong></span><span class="No-Break">’s facilities:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>          .equ    len,8             <span class="sc-comment">@ Length of string to reverse (8 bytes/chars)</span></span>&#13;
<span>          .text                     <span class="sc-comment">@ Program (code) area</span></span>&#13;
<span>          .global _start            <span class="sc-comment">@</span></span>&#13;
<span>_start:   mov     r1,#len           <span class="sc-comment">@ Number of characters to move in r1</span></span>&#13;
<span>          adr     r2,string1        <span class="sc-comment">@ r2 points at source string1 in this section</span></span>&#13;
<span>          adr     r3,adr_str2       <span class="sc-comment">@ r3 points at dest string str2 address in this section</span></span>&#13;
<span>          ldr     r4,[r3]           <span class="sc-comment">@ r4 points to dest str2 in data section</span></span>&#13;
<span>preLoop:  add     r5,r4,#len-1      <span class="sc-comment">@ r5 points to bottom of dest str2</span></span>&#13;
<span>Loop:     ldrb    r6,[r2],#1        <span class="sc-comment">@ Get byte char from source in r6 inc pointer</span></span>&#13;
<span>          strb    r6,[r5],#-1       <span class="sc-comment">@ Store char in destination, decrement pointer</span></span>&#13;
<span>          subs    r1,r1,#1          <span class="sc-comment">@ Decrement char count</span></span>&#13;
<span>          bne     Loop              <span class="sc-comment">@ REPEAT until all done</span></span>&#13;
<span>Wait:     nop                       <span class="sc-comment">@ Stop here for testing</span></span>&#13;
<span> </span>&#13;
<span>Exit:     mov     r0,#0             <span class="sc-comment">@ Stop here</span></span>&#13;
<span>          mov     r7,#1             <span class="sc-comment">@ Exit parameter required by svc</span></span>&#13;
<span>          svc     0                 <span class="sc-comment">@ Call operating system to exit program</span></span>&#13;
<span> </span>&#13;
<span>string1:  .ascii  "Hello!!!"        <span class="sc-comment">@ The source string</span></span>&#13;
<span>marker:   .word   0xAAFFFFBB        <span class="sc-comment">@ Marker for testing</span></span>&#13;
<span>     </span>&#13;
<span>adr_str2: .word   str2              <span class="sc-comment">@ POINTER to source string2 in data area</span></span>&#13;
<span> </span>&#13;
<span>          .data                     <span class="sc-comment">@ The read/write data area</span></span>&#13;
<span>str2:     .byte   0,0,0,0,0,0,0,0   <span class="sc-comment">@ Clear destination string</span></span>&#13;
<span>          .word   0xCCFFFFCC        <span class="sc-comment">@ Marker and terminator</span></span>&#13;
<span>          .end</span></pre>&#13;
			<p lang="en-GB">The program is loaded into the <strong class="source-inline">gdb</strong> and debugged <a id="_idIndexMarker716"/>by the following. Note that my input is in <span class="No-Break">bold font:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">alan@raspberrypi:~/Desktop $ </strong><span class="No-Break"><span class="pcode-bold">gdb pLoop</span></span></p>&#13;
			<p lang="en-GB">The first step is to place three breakpoints on the labels so that we can execute code up to those points and then examine registers <span class="No-Break">or memory:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">b _start</strong></span>&#13;
<span>Breakpoint 1 at 0x10074: file pLoop.s, line 5.</span>&#13;
<span>(gdb) <strong class="bold">b preLoop</strong></span>&#13;
<span>Breakpoint 2 at 0x10084: file pLoop.s, line 9.</span>&#13;
<span>(gdb) <strong class="bold">b Wait</strong></span>&#13;
<span>Breakpoint 3 at 0x10098: file pLoop.s, line 14.</span></pre>&#13;
			<p lang="en-GB">We have set three breakpoints by using <strong class="source-inline">b &lt;label&gt;</strong> three times. We can check these breakpoints by using the <strong class="source-inline">info b</strong> command, which displays the state of <span class="No-Break">the breakpoints:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">(gdb) info b</strong></span>&#13;
<span>Num     Type           Disp Enb Address    What</span>&#13;
<span>1       breakpoint     keep y   0x00010074 pLoop.s:5</span>&#13;
<span>2       breakpoint     keep y   0x00010084 pLoop.s:9</span></pre>&#13;
			<pre class="source-code">3       breakpoint     keep y   0x00010098 pLoop.s:14</pre>&#13;
			<p lang="en-GB">The next step is to run the program as far as the <span class="No-Break">first instruction:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">r</strong></span>&#13;
<span>Starting program: /home/alan/Desktop/pLoop</span>&#13;
<span>Breakpoint 1, _start () at pLoop.s:5</span>&#13;
<span>5 _start:   mov     r1,#len            <span class="sc-comment">@ Number of characters to move in r1</span></span>&#13;
<span>(gdb) <strong class="bold">c</strong></span>&#13;
<span>Continuing.</span></pre>&#13;
			<p lang="en-GB">There’s not a lot to see here. So, we hit <strong class="source-inline">c</strong> to continue to the <a id="_idIndexMarker717"/>next breakpoint, and then enter <strong class="source-inline">i r</strong> to display the registers. Note we have not displayed registers that have not <span class="No-Break">been accessed:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Breakpoint 2, preLoop () at pLoop.s:9</span>&#13;
<span>9 preLoop:  add     r5,r4,#len-1       <span class="sc-comment">@ r5 points to bottom of dest str2</span></span>&#13;
<span>(gdb) i r</span>&#13;
<span>r0             0x0                 0</span>&#13;
<span>r1             0x8                 8</span>&#13;
<span>r2             0x100a8             65704      Pointer to string1</span>&#13;
<span>r3             0x100b4             65716      Pointer to str2 <strong class="bold">address</strong></span>&#13;
<span>r4             0x200b8             131256     Pointer to str2 <strong class="bold">value</strong></span>&#13;
<span>sp             0x7efff360          0x7efff360</span>&#13;
<span>lr             0x0                 0</span>&#13;
<span>pc             0x10084             0x10084 &lt;preLoop&gt;</span></pre>&#13;
			<p lang="en-GB">Let’s have a look at the data section in the code. Register <strong class="source-inline">r2</strong> points at this area, and the command means four words of memory in the hexadecimal form are displayed, starting <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">0x100A8</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">(gdb) x/4wx 0x100a8</strong></span>&#13;
<span>0x100a8 &lt;string1&gt;: <span class="Color-Red">0x6c6c6548 0x2121216f 0xaaffffbb</span> 0x000200b8</span></pre>&#13;
			<p lang="en-GB">The three highlighted values present the string <strong class="source-inline">"Hello!!!"</strong> and the marker <strong class="source-inline">0xCCFFFFCC</strong>. Note how these values appear <em class="italic">back to front</em>. This is a consequence of the little-endian byte ordering mode. The least-significant byte is located at the least-significant end of a word. In terms of ASCII characters, these are <span class="No-Break"><strong class="source-inline">lleH !!!o</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">We next perform a single step and display the memory in the data region. At this stage, the code had not been executed fully and this region should be as originally <span class="No-Break">set up:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">(gdb) si 1</strong></span>&#13;
<span>Loop () at pLoop.s:10</span>&#13;
<span>10 Loop:     ldrb    r6,[r2],#1        <span class="sc-comment">@ Get byte char from source in r6 inc pointer</span></span>&#13;
<span>(gdb) <strong class="bold">x/4wx 0x200b8</strong></span></pre>&#13;
			<pre class="source-code">0x200b8: 0x00000000 0x00000000 0xccffffcc 0x00001141</pre>&#13;
			<p lang="en-GB">Here, you can see the zeros loaded at bytes and the marker following them. We then enter <strong class="source-inline">c</strong> again and continue to the <strong class="source-inline">Wait</strong> breakpoint when the code should have been completed. Finally, we look at the registers and then the <span class="No-Break">data memory:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) c</span>&#13;
<span>Continuing.</span>&#13;
<span>Breakpoint 3, Wait () at pLoop.s:14</span>&#13;
<span>14 Wait:     nop                       <span class="sc-comment">@ Stop here for testing</span></span>&#13;
<span>   </span>&#13;
<span>(gdb) <strong class="bold">i r</strong></span>&#13;
<span>r0             0x0                 0</span>&#13;
<span>r1             0x0                 0</span>&#13;
<span>r2             0x100b0             65712</span>&#13;
<span>r3             0x100b4             65716</span>&#13;
<span>r4             0x200b8             131256</span>&#13;
<span>r5             0x200b7             131255</span>&#13;
<span>r6             0x21                33</span>&#13;
<span>sp             0x7efff360          0x7efff360</span>&#13;
<span>lr             0x0                 0</span>&#13;
<span>pc             0x10098             0x10098 &lt;Wait&gt;</span>&#13;
<span><strong class="bold">(gdb) x/4wx 0x200b8</strong></span>&#13;
<span>0x200b8: <span class="Color-Red">0x6f212121 0x48656c6c 0xccffffcc</span> 0x00001141</span></pre>&#13;
			<p lang="en-GB">Note that the data is changed. As you can see, the order <a id="_idIndexMarker718"/>has been reversed. Again, note the effect of the little-endianism on the byte order within words. The sequence of the data is now <strong class="source-inline">o!!! Hell</strong>. Finally, we enter <strong class="source-inline">c</strong> again and the program <span class="No-Break">is completed:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) c</span>&#13;
<span>Continuing.</span>&#13;
<span>[Inferior 1 (process 11670) exited normally]</span>&#13;
<span>(gdb)</span></pre>&#13;
			<h1 id="_idParaDest-206" lang="en-GB"><a id="_idTextAnchor223"/>Common confusions</h1>&#13;
			<p lang="en-GB">The growth of computing from the 1960s to today was rapid and chaotic. The chaos arose because the technology developed so rapidly that systems became obsolete in months, and that meant much of the design was obsolete but had been incorporated in systems <a id="_idIndexMarker719"/>that were now being held back by it. Similarly, many different notations and conventions arose – for example, does <strong class="source-inline">MOVE A,B</strong> move <strong class="source-inline">A</strong> to <strong class="source-inline">B</strong>, or <strong class="source-inline">B</strong> to <strong class="source-inline">A</strong>? Both conventions were used at the same time by different computers. Here are a few pointers to help with <span class="No-Break">the confusion.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In this book, we will largely adopt the right-to-left convention for data movement. For example, <strong class="source-inline">add </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r2,r2</strong> indicates the addition of<strong class="source-inline"> r2</strong> and <strong class="source-inline">r3</strong>, and the sum is put in <strong class="source-inline">r1</strong>. As a means of highlighting this, I often put the destination operand of an operation in <span class="No-Break">bold font.</span></p>&#13;
			<p lang="en-GB">Symbols are often used with different meanings. This is particularly true of<strong class="source-inline"> #</strong>,<strong class="source-inline"> @</strong>,<strong class="source-inline"> </strong><span class="No-Break">and</span><span class="No-Break"><strong class="source-inline"> %</strong></span><span class="No-Break">.</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="bold">#</strong>: The <em class="italic">hash</em> (or pound) sign is used in Python <a id="_idIndexMarker720"/>programs to indicate a comment field – for example, <strong class="source-inline">if x &gt; y: z = 2</strong>.  <strong class="source-inline">#</strong> Reset <strong class="source-inline">z</strong> if <strong class="source-inline">x</strong> ever exceeds <strong class="source-inline">y</strong>. The hash is used in ARM assembly language to indicate a literal value – for example, <strong class="source-inline">add </strong><span class="pcode-bold">r0</span><strong class="source-inline">,r1,#5</strong>.  <strong class="source-inline">@</strong> Add the integer <strong class="source-inline">5</strong> to the contents of <strong class="source-inline">r1</strong> and put <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">r2</strong></span><span class="No-Break">.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">@</strong>: The <em class="italic">at</em> symbol is used to indicate <a id="_idIndexMarker721"/>a comment in the ARM <span class="No-Break">assembly language.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">%</strong>: The <em class="italic">percentage sign</em> is used to indicate a binary <a id="_idIndexMarker722"/>value in some language – for example, <strong class="source-inline">add </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r2,#%1010</strong> means add the literal value expressed in the binary form. Python uses the prefix <strong class="source-inline">0b</strong> to indicate binary values (<span class="No-Break">e.g., 0b1010).</span></li>&#13;
				<li lang="en-GB"><strong class="bold">$</strong>: In some <a id="_idIndexMarker723"/>languages, the <em class="italic">dollar symbol</em> indicates hexadecimal; for example, $A10C. Python uses the prefix <strong class="source-inline">0x</strong> to indicate hexadecimal values (<span class="No-Break">e.g., 0xA10C).</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Register indirect addressing</strong>: A key concept in <a id="_idIndexMarker724"/>programming at the assembly language level is the pointer – that is, a variable that is the address of an element in memory. This addressing mode is called register indirect, pointer-based, or even <span class="No-Break">indexed addressing.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Up and down</strong>: In normal everyday use, up and down <a id="_idIndexMarker725"/>indicate the direction toward the sky (up) or toward the ground (down). In arithmetic, they indicate increasing a number (up) or decreasing it (down). In computing, when data items are added to a stack, the stack grows up. However, by convention, the address grows down as items are added. Consequently, the stack pointer is decremented when items are added to the stack and incremented when items <span class="No-Break">are removed.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Endian</strong>: Considerable confusion can be <a id="_idIndexMarker726"/>caused when reading a program or when interfacing one system with another because of the two standards – big endian and little endian. If you were to write <strong class="source-inline">ldr r0,=0x12345678</strong>, a big endian computer would store the bytes in byte memory at increasing addresses in the order 12,34,56,78, whereas a little endian computer would store the bytes in the order 78,56,34,12. The ARM is a little endian machine, although it can be programmed to operate in a big endian mode. In practice, this means that you must be careful when debugging programs and looking at memory dumps. Equally, you must be careful when performing byte operations on word values to ensure that you select the <span class="No-Break">correct byte.</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-207" lang="en-GB"><a id="_idTextAnchor224"/>Vocabulary</h1>&#13;
			<p lang="en-GB">All specializations have their <a id="_idIndexMarker727"/>own vocabulary, and programming is no exception. Here are a few words that you might find helpful in understanding the text and <span class="No-Break">its context.</span></p>&#13;
			<ul>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB"><strong class="bold">Compiler</strong>: Computers execute binary <a id="_idIndexMarker728"/>programs expressed as <strong class="source-inline">1</strong>s and <strong class="source-inline">0</strong>s. Humans write programs in a high-level language such as Python that is close to plain English. Before a high-level language program can be executed, a piece of software called a <em class="italic">compiler</em> translates it into binary code. When you run a Python program on your computer, your source code is automatically translated into machine code by a compiler working with the operating system. Mercifully, you don’t have to worry about all the actions that take place invisibly in the background <span class="No-Break">during compilation.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Syntax error</strong>: Like a human language, a program is made up of <em class="italic">sentences</em> that conform to a set of rules called <em class="italic">grammar</em>. If a sentence has an error, so it <a id="_idIndexMarker729"/>does not conform to the grammar, it is called a syntax error. If I said, “<em class="italic">I is hot</em>”, that would be an error of English syntax, even though the meaning (semantics) is clear. A typical syntax error in Python is <strong class="source-inline">y = "4" + 1</strong>. This is a syntax error because I’m adding two different entities that can’t be added. The "<strong class="source-inline">4</strong>" is a character (you can print it), whereas the <strong class="source-inline">1</strong> is an integer. You can write <strong class="source-inline">y = "4" + "1" </strong>or<strong class="source-inline"> z = 4 + 1</strong>. These are both syntactically correct, and <strong class="source-inline">y</strong> is <strong class="source-inline">"41"</strong>, whereas <strong class="source-inline">z</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Semantic error</strong>: Semantics is <a id="_idIndexMarker730"/>concerned with meaning. A syntax error means that the sentence is grammatically wrong even if it is syntactically correct. An example of a sentence in English with a semantic error is, <em class="italic">“Twas brillig, and the slithy toves did gyre and gimble in the wabe.”</em> This is grammatically correct but does not have a meaning – that is, it’s semantically incorrect. In computing, a semantic error means that your program doesn’t do what you intended. A compiler can detect a syntax error but not usually a <span class="No-Break">semantic error.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Variable</strong>: An item of data is a <a id="_idIndexMarker731"/>variable if its value can change. If you write <strong class="source-inline">age = 25</strong>, you’ve created a new variable called <strong class="source-inline">age</strong> with the value <strong class="source-inline">25</strong>. If you refer to age, the actual value will be substituted. The expression <strong class="source-inline">y = age + 10</strong> would give y the value <strong class="source-inline">35</strong>. A variable has four attributes – its name (what you call it), its address (where it’s stored in the computer), its value (what it actually is), and its type (e.g., an integer, list, character, <span class="No-Break">or string).</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Constant</strong>: A value that cannot be <a id="_idIndexMarker732"/>changed is a constant. The circumference of a circle is expressed as <strong class="source-inline">c = 2πr</strong>, where <strong class="source-inline">2</strong> and <strong class="source-inline">π</strong> are constants. Both <strong class="source-inline">c</strong> and <strong class="source-inline">r</strong> <span class="No-Break">are variables.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Symbolic name</strong>: We often refer to a variable <a id="_idIndexMarker733"/>or a constant by a name – for example, we call the circumference of the circle <strong class="source-inline">c</strong> and its radius <strong class="source-inline">r</strong>. We give the irrational number <strong class="source-inline">3.1415926</strong> the symbolic name <strong class="source-inline">π</strong>. When a program is compiled into machine code, symbolic names are replaced by <span class="No-Break">actual values.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Address</strong>: Information is stored in <a id="_idIndexMarker734"/>memory locations, and each location has a unique address. For example, the radius of a circle may be stored in computer memory at address <strong class="source-inline">1234</strong>. A programmer normally does not have to worry about where data is actually located in memory. Translating addresses from the logical addresses used in programs to the physical addresses of memory devices is the domain of the <span class="No-Break">operating system.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Value and location</strong>: When we refer to <a id="_idIndexMarker735"/>the expression <strong class="source-inline">c = 2πr</strong>, what is <strong class="source-inline">r</strong>? We (humans) see <strong class="source-inline">r</strong> as the symbolic name for the value of the radius – say, 5. But the computer sees <strong class="source-inline">r</strong> as the memory address 1234, which has to be read to provide the actual value of <strong class="source-inline">r</strong>. If we write <strong class="source-inline">r = r + 1</strong>, do we mean <strong class="source-inline">r = 5 + 1 = 6</strong> or do we mean <strong class="source-inline">r = 1234 + 1 = 1235</strong>? It’s important to distinguish between an <em class="italic">address</em> and its <em class="italic">contents</em>. This factor becomes significant when we <span class="No-Break">introduce pointers.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Pointer</strong>: A pointer is a variable whose <a id="_idIndexMarker736"/>value is an address. If you modify a pointer, it points to a different location. In conventional arithmetic, we write x<span class="subscript">i</span> where <strong class="source-inline">i</strong> is really a pointer; we just call it an <em class="italic">index</em>. If we change the pointer (index) we can step through the elements of a table, array, or matrix and step through elements x<span class="subscript">1</span>, x<span class="subscript">2</span>, x<span class="subscript">3</span>, <span class="No-Break">and x</span><span class="No-Break"><span class="subscript">4</span></span><span class="No-Break">.</span></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>