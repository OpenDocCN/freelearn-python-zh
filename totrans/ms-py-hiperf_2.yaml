- en: Chapter 2. The Profilers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。分析器
- en: In the previous chapter, we covered the basics of profiling and understood its
    importance. You learned how it will help the development process if we incorporate
    the practice of profiling into the cycle of development. We also went over some
    good profiling practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了分析的基础知识，并了解了它的重要性。你学习了如果我们将分析实践纳入开发周期，它将如何帮助开发过程。我们还讨论了一些良好的分析实践。
- en: Finally, we covered some theory about the different execution times our program
    can have. In this chapter, we'll use the first part (the part about profiling).
    Then, with the help of two specific Python profilers (`cProfile` and `line_profilers`),
    we'll start putting into practice some theory that you have learned.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了程序可能具有的不同执行时间的理论。在本章中，我们将使用第一部分（关于分析的部分）。然后，借助两个特定的 Python 分析器（`cProfile`
    和 `line_profiler`），我们将开始将你所学的一些理论付诸实践。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Some basic information about each profiler
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个分析器的基本信息
- en: How to download and install each profiler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何下载和安装每个分析器
- en: Use cases examples with different options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同选项的使用案例
- en: Differences and similarities between both profilers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个分析器之间的差异和相似之处
- en: 'Getting to know our new best friends: the profilers'
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认识我们的新好朋友：分析器
- en: 'After all the theory and generic examples from the previous chapter, it is
    time for some real Python. So, let''s begin with two of the most known and used
    Python profilers: `cProfile` and `line_profiler`. They will help us profile our
    code in two different ways.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的所有理论和通用示例之后，现在是时候看看一些真正的 Python 了。所以，让我们从两个最知名和最常用的 Python 分析器开始：`cProfile`
    和 `line_profiler`。它们将帮助我们以两种不同的方式分析代码。
- en: On one hand, we have `cProfile` ([https://docs.python.org/2/library/profile.html#module-cProfile](https://docs.python.org/2/library/profile.html#module-cProfile)),
    It comes by default with Python since version 2.5 and is the recommended profiler
    for most use cases. At least that is what the official Python documentation says
    about it. On the other hand, we have `line_profiler` ([https://github.com/rkern/line_profiler](https://github.com/rkern/line_profiler)),
    which is not an official part of the Python programming language, but it's a well-known
    profiler out there.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，我们有 `cProfile` ([https://docs.python.org/2/library/profile.html#module-cProfile](https://docs.python.org/2/library/profile.html#module-cProfile))，自
    Python 2.5 版本起就默认包含在 Python 中，并且是大多数用例推荐的分析器。至少这是官方 Python 文档对它的描述。另一方面，我们有 `line_profiler`
    ([https://github.com/rkern/line_profiler](https://github.com/rkern/line_profiler))，它不是
    Python 编程语言的官方部分，但它是那里广为人知的一个分析器。
- en: Let's go over both of them in more detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解这两个分析器。
- en: cProfile
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cProfile
- en: Like I've already mentioned, `cProfile` comes by default with the standard Python
    interpreter (`cPython`) since version 2.5\. Other versions, such as PyPy, don't
    have it. It is a deterministic profiler. It provides a set of APIs that allow
    the developers to gather information about the execution of Python programs, more
    specifically, about the CPU time used by each function. It also provides other
    details, such as the number of times a function was called.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，`cProfile` 自 Python 2.5 版本起就默认包含在标准 Python 解释器（`cPython`）中。其他版本，如 PyPy，则没有这个功能。它是一个确定性分析器。它提供了一套
    API，允许开发者收集有关 Python 程序执行的信息，更具体地说，是关于每个函数使用的 CPU 时间。它还提供了其他详细信息，例如一个函数被调用的次数。
- en: It exclusively measures CPU time and pays no attention to memory consumption
    and other memory related stats. Nonetheless, it is a great starter point, since
    most of the times, if we're trying to optimize code, this type of analysis will
    provide an immediate set of optimization candidates.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它仅测量 CPU 时间，并不关注内存消耗和其他内存相关统计信息。尽管如此，它是一个很好的起点，因为大多数时候，如果我们试图优化代码，这种分析将提供一组立即的优化候选者。
- en: There is no need for installation, since it's part of the language already.
    To use it, all you have to do is to import the `cProfile` package.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它已经是语言的一部分，无需安装。要使用它，你只需导入 `cProfile` 包即可。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A deterministic profiler is just another name for an event-based profiler (check
    out the previous chapter for more details). This means that that this profiler
    will be aware of every function call, return statement, and other events during
    the execution of our code. It will also measure everything that happens during
    that time (unlike the statistical profiler we saw in the previous chapter).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性分析器只是基于事件的分析器（详情请参阅上一章）的另一个名称。这意味着这个分析器将知道我们代码执行过程中的每一个函数调用、返回语句和其他事件。它还会测量这段时间内发生的所有事情（与我们在上一章中看到的统计分析器不同）。
- en: 'Here is a very simple example taken from Python''s documentation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个来自Python文档的非常简单的例子：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code outputs the following text:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码输出了以下文本：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From this output, the following information can be gathered:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，可以收集以下信息：
- en: The first line tells us that 197 function calls were monitored, and out of them,
    192 were primitive calls, which means no recursion was involved.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行告诉我们，共监视了197个函数调用，其中192个是原始调用，这意味着没有涉及递归。
- en: '`ncalls` reports the number of calls to the function. If there are two numbers
    in this column, it means there was recursion. The second one is the number of
    primitive calls, and the first one is the total number of calls. This number can
    be helpful to identify the possible bugs (unexpected high numbers) or possible
    inline expansion points.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ncalls`报告对函数的调用次数。如果这一列有两个数字，这意味着存在递归。第二个数字是原始调用的次数，第一个数字是总调用次数。这个数字可以帮助识别可能的错误（意外的过高数字）或可能的内联扩展点。'
- en: '`tottime` is the total time spent inside the function (excluding the time spent
    doing subcalls to other functions). This particular information can help the developer
    find long running loops that could be optimized.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tottime`是在函数内部花费的总时间（不包括调用其他函数的子调用的时间）。这个特定的信息可以帮助开发者找到可能被优化的长时间运行的循环。'
- en: '`percall` is simply the quotient of `tottime` divided by `ncalls`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`只是`tottime`除以`ncalls`的商。'
- en: '`cumtime` is the cumulative time spent inside the function including the time
    spent in subfunctions (this includes recursive calls as well). This number could
    help identify higher level errors, such as those in the selection of the algorithm.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumtime`是在函数内部花费的总时间，包括在子函数中花费的时间（这包括递归调用）。这个数字可以帮助识别更高层次的错误，例如算法选择中的错误。'
- en: '`percall` is the quotient of `cumtime` divided by primitive calls.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`是`cumtime`除以原始调用的商。'
- en: '`filename:lineno(function)` provides the file name, line number, and function
    name of the analyzed function.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename:lineno(function)`提供了分析函数的文件名、行号和函数名。'
- en: A note about limitations
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于限制的说明
- en: There is no such thing as the invisible profiler. This means that even in the
    case of `cProfile`, which has a very small overhead, it still adds an overhead
    to our code. On every event that is triggered, there is some lag between the time
    that the event actually happens and that time that the profiler gets to query
    the state of the internal clock. At the same time, there is some lag between the
    moment the program counter leaves the profiler's code and goes back into the user's
    code to continue with the execution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这样的东西叫做不可见分析器。这意味着即使在`cProfile`这种开销非常小的案例中，它仍然会给我们的代码增加开销。在每次触发事件时，事件实际发生的时间和性能分析器查询内部时钟状态的时间之间会有一些延迟。同时，当程序计数器离开性能分析器的代码并返回用户代码以继续执行时，也会有一些延迟。
- en: Adding to the fact, that as any piece of data inside a computer, the internal
    clock has a set precision, and any measurement that is smaller than that precision
    will be lost. That being said, the developer needs to have a special consideration
    when profiling code with a high number of recursive calls or, in particular cases,
    when a function calls many other functions, since that error can accumulate and
    begin to be significant.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，作为计算机内部的数据，内部时钟有一个固定的精度，任何小于这个精度的测量都会丢失。因此，当开发者使用具有大量递归调用或特定情况下函数调用许多其他函数的代码进行性能分析时，需要特别注意，因为这种误差可能会累积并变得显著。
- en: The API provided
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供的API
- en: 'The `cProfile` profiler provides a set of methods that will help the developer
    gather statistics in different contexts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile`分析器提供了一套方法，可以帮助开发者在不同上下文中收集统计数据：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This classic method used in the preceding example gathers statistics about
    the execution of the command. After that, it calls the following function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中使用的方法是一个经典方法，用于收集命令执行的统计数据。之后，它调用以下函数：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If no file name is given, it''ll create a new instance of `stats` (more on
    this class in a minute). Here is the preceding same example, but using the extra
    parameters:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供文件名，它将创建一个新的`stats`实例（关于这个类的更多内容，请稍后了解）。以下是前一个相同的示例，但使用了额外的参数：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run the preceding code, you''ll notice that nothing gets printed out.
    However, if you inspect the content of the folder, you''ll notice a new file,
    called `stats`. If you try to open that file, you won''t be able to understand
    its meaning because it was saved using a binary format. In a few minutes, we''ll
    see how to read that information and manipulate it to create our own reports:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你会注意到没有任何内容被打印出来。然而，如果你检查文件夹的内容，你会注意到一个名为`stats`的新文件。如果你尝试打开该文件，你将无法理解其含义，因为它是以二进制格式保存的。在几分钟内，我们将看到如何读取这些信息并对其进行操作以创建我们自己的报告：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This method is very similar to the preceding one. The only difference is that
    it also receives the `globals` and `locals` dictionaries for the command-line
    string. After that, it executes the following function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与前一个方法非常相似。唯一的区别是它还接收命令行字符串的`globals`和`locals`字典。之后，它执行以下函数：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It gathers profiling statistics just like `run` does. Let's see an example of
    the main difference between `run` and `runctx`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它收集分析统计数据，就像`run`一样。让我们看看`run`和`runctx`之间主要区别的示例。
- en: 'Let''s stick to `run` and write the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们坚持使用`run`并编写以下代码：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What we would actually get when running the code is the following error message:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际运行代码时，我们会得到以下错误消息：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `re` module is not found by the `run` method because as we saw earlier that
    `run` calls the `exec` function with the `__main__.__dict__` as parameters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`re`模块在`run`方法中找不到，因为我们之前看到`run`使用`__main__.__dict__`作为参数调用`exec`函数。'
- en: 'Now, let''s use `runctx` in the following manner:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以下面的方式使用`runctx`：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then the output would change into a valid one as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输出将变为以下有效格式：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Profile(timer=None, timeunit=0.0, subcalls=True, builtins=True)` method
    returns a class, providing more control to the developer during the profiling
    process than `run` and `runctx` do.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Profile(timer=None, timeunit=0.0, subcalls=True, builtins=True)`方法返回一个类，在分析过程中比`run`和`runctx`提供了更多的控制。'
- en: The `timer` parameter is a custom function that can be used to measure time
    in a different way than the one provided by default. It must be a function returning
    a number representing the current time. If the developer needs a custom function,
    it should be as fast as possible to lower overhead and avoid problems of calibration
    (please refer to *A note about limitations* section a few pages back).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer`参数是一个自定义函数，可以用来以不同于默认方式测量时间。它必须是一个返回表示当前时间的数字的函数。如果开发者需要自定义函数，它应该尽可能快，以降低开销并避免校准问题（请参阅几页前的*关于限制的说明*部分）。'
- en: If the number returned by the timer is an integer, the `timeunit` parameter
    specifies the multiplier that represents the duration of each unit of time. For
    example, if the returned value is in milliseconds, then `timeunit` would be `.001`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计时器返回的数字是整数，则`timeunit`参数指定表示每个时间单位持续时间的乘数。例如，如果返回的值以毫秒为单位，则`timeunit`将是`.001`。
- en: 'Let''s also take a look at the methods provided by the returned class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看返回类提供的方法：
- en: '`enable()`: This starts collecting profiling data'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable()`: 这开始收集分析数据'
- en: '`disable()`: This stops collecting profiling data'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disable()`: 这停止收集分析数据'
- en: '`create_stats()`: This stops collecting data and records the information gathered
    as the current profile'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_stats()`: 这停止收集数据并将收集到的信息记录为当前配置文件'
- en: '`print_stats(sort=-1)`: This creates a `stats` object and prints the result
    into `STDOUT`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_stats(sort=-1)`: 这创建一个`stats`对象并将结果打印到`STDOUT`'
- en: '`dump_stats(filename)`: This writes the content of the current profile into
    a file'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dump_stats(filename)`: 这将当前配置文件的内容写入文件'
- en: '`run(cmd)`: This is same as the `run` function we saw earlier'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run(cmd)`: 这与之前看到的`run`函数相同'
- en: '`runctx(cmd, globals, locals)`: This is same as the `runctx` function we saw
    earlier'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runctx(cmd, globals, locals)`: 这与之前看到的`runctx`函数相同'
- en: '`runcall(func, *args, **kwargs)`: This gathers profiling information about
    the function called'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runcall(func, *args, **kwargs)`: 这收集被调用的函数的分析信息'
- en: 'Let''s see the preceding example, using the following method this time:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的例子，这次使用以下方法：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are more lines involved to get the profiling going, but it is clearly
    less invasive to the original code. That is an advantage when trying to profile
    code that's already been written and tested. This way, we can add and remove our
    profiling code without having to modify the original code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动分析，涉及更多的行，但这对原始代码的侵入性明显较小。当尝试分析已经编写和测试的代码时，这是一个优点。这样，我们可以在不修改原始代码的情况下添加和删除我们的分析代码。
- en: 'There is an even less invasive alternative, which involves not adding code
    at all, but using some specific command-line parameters when running the script
    instead:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更不侵入的替代方案，它不涉及添加任何代码，而是在运行脚本时使用一些特定的命令行参数：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that this will profile the entire code, so if you were actually just profiling
    a specific portion of your script, the preceding approach would not return the
    same results.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这将分析整个代码，所以如果你实际上只是分析脚本的一个特定部分，前面的方法不会返回相同的结果。
- en: Now, before going into more detailed and interesting examples, let's first look
    at the `Stats` class and understand what it can do for us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在进入更详细和有趣的例子之前，让我们首先看看`Stats`类，并了解它能为我们做什么。
- en: The Stats class
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Stats`类'
- en: The `pstats` module provides the developer with the `Stats` class, which, in
    turn, allows them to read and manipulate the content of the `stats` file (the
    file into which we saved the profiling information using one of the methods described
    earlier).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`pstats`模块为开发者提供了`Stats`类，它反过来允许他们读取和操作`stats`文件的内容（我们使用前面描述的方法之一保存到该文件中的分析信息）。'
- en: 'For example, the following code loads the `stats` file and prints out the sorted
    statistics:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码加载`stats`文件并打印出排序后的统计信息：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `Stats` class constructor is able to receive a `cProfile.Profile`
    instance instead of the file name as the source of the data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Stats`类构造函数能够接收一个`cProfile.Profile`实例作为数据源，而不是文件名。
- en: 'Let''s take a closer look at the methods provided by the `pstats.Stats` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`pstats.Stats`类提供的方法：
- en: '`strip_dirs()`: This removes all the leading paths'' information from the file
    names in the report. This method modifies the `stats` instance, so any instance
    that has this method executed will be considered to have its items in a random
    order. If two entries are considered to be the same (same line on the same file
    name having the same function name), then those entries would be accumulated.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strip_dirs()`: 此方法从报告中文件名的所有前缀路径信息中删除。此方法修改了`stats`实例，因此任何执行了此方法的实例都将被视为其项目顺序是随机的。如果两个条目被认为是相同的（同一文件名上的同一行具有相同的函数名），则这些条目将被累积。'
- en: '`add(*filenames)`: This method loads more information into `stats` from the
    files referenced in the file names. It''s worth mentioning that just like with
    only one file, the `stats` entries that reference the same function (file name,
    and line and function name) will be accumulated.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(*filenames)`: 此方法将更多信息加载到`stats`中，来自文件名中引用的文件。值得注意的是，就像只有一个文件一样，引用相同函数（文件名、行和函数名）的`stats`条目将被累积。'
- en: '`dump_stats(filename)`: Just like in the `cProfile.Profile` class, this method
    saves the data loaded into the `Stats` class inside a file.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dump_stats(filename)`: 就像在`cProfile.Profile`类中一样，此方法将加载到`Stats`类中的数据保存到文件中。'
- en: '`sort_stats(*keys)`: This method is present since version 2.3, and it modifies
    the `stats` object by sorting its entries by the given criteria. When more than
    one criteria is given, then the additional ones are used only when there is equality
    in the previous ones. For instance, if `sort_stats (''name'', ''file'')` is used,
    it would sort all entries by function name, and when that name is the same, it
    would sort those entries by file name.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort_stats(*keys)`: 此方法自2.3版本以来一直存在，它通过给定的标准对`stats`对象中的条目进行排序。当给出多个标准时，额外的标准仅在先前标准相等时才会使用。例如，如果使用`sort_stats
    (''name'', ''file'')`，则将所有条目按函数名称排序，当该名称相同时，将按文件名对这些条目进行排序。'
- en: 'The method is smart enough to understand abbreviations as long as they''re
    unambiguous, so be careful there. The full list of the currently supported sorting
    criteria is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法足够智能，可以理解只要它们是不含糊的缩写，所以请小心。目前支持的排序标准完整列表如下：
- en: '| Criteria | Meaning | Ascending/Descending |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 标准 | 含义 | 升序/降序 |'
- en: '| --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `calls` | Total number of calls | Descending |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `calls` | 调用总数 | 降序 |'
- en: '| `cumulative` | Cumulative time | Descending |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `cumulative` | 累计时间 | 降序 |'
- en: '| `cumtime` | Cumulative time | Descending |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `cumtime` | 累计时间 | 降序 |'
- en: '| `file` | File name | Ascending |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `file` | 文件名 | 升序 |'
- en: '| `filename` | File name | Ascending |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `filename` | 文件名 | 升序 |'
- en: '| `module` | File name | Ascending |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `module` | 文件名 | 升序 |'
- en: '| `ncalls` | Total number of calls | Descending |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `ncalls` | 调用总数 | 降序 |'
- en: '| `pcalls` | Primitive call count | Descending |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `pcalls` | 原始调用计数 | 降序 |'
- en: '| `line` | Line number | Ascending |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `line` | 行号 | 升序 |'
- en: '| `name` | Function name | Ascending |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 函数名 | 升序 |'
- en: '| `nfl` | Composite of name/file/line | Descending |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `nfl` | 名称/文件/行组合 | 降序 |'
- en: '| `stdname` | Standard name | Ascending |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `stdname` | 标准名称 | 升序 |'
- en: '| `time` | Internal time | Descending |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `time` | 内部时间 | 降序 |'
- en: '| `tottime` | Internal time | Descending |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `tottime` | 内部时间 | 降序 |'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A note on nfl versus stdname**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于nfl与stdname的注意事项**'
- en: The main difference between these two sort types is that the latter is a sort
    of the printed name. This means the line numbers will be sorted as strings (which
    means that for 4, 20, and 30 the sorting will be 20, 30, 4). The `nfl` sort does
    a numeric comparison of the line number fields.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种排序类型之间的主要区别在于后者是对打印名称的排序。这意味着行号将按字符串排序（这意味着对于4、20和30，排序将是20、30、4）。`nfl`排序对行号字段进行数值比较。
- en: Finally, for backward compatibility reasons, some numeric values are accepted,
    instead of the ones in the preceding table. They are `-1`, `0`, `1`, and `2`,
    and they're translated into `stdname`, `calls`, `time`, and `cumulative`, respectively.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，出于向后兼容性的原因，一些数值被接受，而不是前面表格中的那些。它们是`-1`、`0`、`1`和`2`，分别对应`stdname`、`calls`、`time`和`cumulative`。
- en: '`reverse_order()`: This method reverses the default order of the sort key selected
    (so, if the key is by the default ascending order, it would be in the descending
    order now).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse_order()`：此方法反转所选排序键的默认顺序（因此，如果键是默认升序，现在将是降序）。'
- en: '`print_stats(*restrictions)`: This method takes care of printing out the stats
    into `STDOUT`. The optional argument is meant to restrict the output of this function.
    It can either be an integer value, a decimal value, or a string. They are explained
    here:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_stats(*restrictions)`：此方法负责将统计信息打印到`STDOUT`。可选参数旨在限制此函数的输出。它可以是整数值、小数值或字符串。它们在此处解释：'
- en: '`integer`: This will limit the number of lines printed'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`integer`：这将限制打印的行数'
- en: '`Decimal between 0.0 and 1.0 (inclusive)`: This will select the percentage
    of the lines'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decimal between 0.0 and 1.0 (inclusive)`：这将选择行百分比'
- en: '`String`: This is a regular expression to match against the standard name'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`：这是一个与标准名称匹配的正则表达式'
- en: '![The Stats class](img/B02088_02_01.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Stats类](img/B02088_02_01.jpg)'
- en: 'The preceding screenshot shows the output we get from calling the `print_stats`
    method as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了调用`print_stats`方法时得到的输出如下：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If more than one parameter is passed, then they are applied sequentially. As
    we've seen in the preceding lines of code, the output of this profiler can be
    quite long. However, if we sort it properly, then we can summarize that output
    using this parameter and still get relevant information.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了多个参数，则它们将按顺序应用。正如我们在前面的代码行中看到的，这个分析器的输出可以相当长。然而，如果我们正确排序，则可以使用此参数总结输出，同时仍然获得相关信息。
- en: The `print_callers(*restrictions)` function works with the same input and restriction
    rules than the previous one, but the output is a bit different. For every function
    called during the execution of our program, it'll show the number of times each
    call was made, the total and cumulative times, and a combination of filename,
    and the line and function names.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_callers(*restrictions)`函数与之前的输入和限制规则相同，但输出略有不同。对于程序执行期间调用的每个函数，它将显示每个调用被调用的次数、总时间和累计时间，以及文件名、行号和函数名的组合。'
- en: 'Let''s look at a quick example of how using `cProfile.Profile` and `Stats`
    can render the list of caller functions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`cProfile.Profile`和`Stats`如何渲染调用函数列表的快速示例：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice how we''re combining the `pstats.Stats` class with the `cProfile.Profile`
    class. They''re working together to gather and show the information in the way
    we need it. Now, look at the output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何将`pstats.Stats`类与`cProfile.Profile`类结合使用的。它们共同工作，以我们所需的方式收集和展示信息。现在，看看输出：
- en: '![The Stats class](img/B02088_02_02.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Stats类](img/B02088_02_02.jpg)'
- en: The `print_callees(*restrictions)` method prints a list of functions that call
    other functions. The format of the data shown and the restrictions are same as
    the preceding example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_callees(*restrictions)`方法打印调用其他函数的函数列表。显示的数据格式和限制与前面的示例相同。'
- en: 'You may encounter a block like the one shown in the following screenshot as
    part of the output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在输出中遇到如下截图所示的块：
- en: '![The Stats class](img/B02088_02_03.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Stats类](img/B02088_02_03.jpg)'
- en: This output means that the functions on the right-hand side were called by the
    same function on the left-hand side.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出意味着右侧的函数是由左侧的相同函数调用的。
- en: Profiling examples
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析示例
- en: Now that we've seen the basics of how to use `cProfile` and `Stats`, let's dig
    into some more interesting and practical examples.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用`cProfile`和`Stats`的基本方法，让我们深入研究一些更有趣和实用的例子。
- en: Fibonacci again
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 斐波那契再次
- en: Let's go back to the Fibonacci example, since a basic recursive Fibonacci sequence
    calculator has a lot of room for improvement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到斐波那契的例子，因为基本的递归斐波那契序列计算器有很多改进的空间。
- en: 'Let''s first look at the unprofiled, unoptimized code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看未经性能分析、未经优化的代码：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code will output the following results:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出以下结果：
- en: '![Fibonacci again](img/B02088_02_04.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![斐波那契再次](img/B02088_02_04.jpg)'
- en: 'The output is printed correctly, but look at the highlighted sections in the
    preceding screenshot. These sections are explained here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出打印正确，但请看前面截图中的高亮部分。这些部分在这里解释：
- en: There are 57.356 function calls during those 0.114 seconds
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在那0.114秒内，有57.356次函数调用
- en: Out of those, only 66 were primitive calls (not called by recursion)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中只有66个是原始调用（不是通过递归调用）
- en: In line 3 of our code, 57.270 (57.291—21) were recursion-induced function calls
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们代码的第3行，57.270（57.291—21）是递归引起的函数调用
- en: As we all know, the act of calling another function adds an overhead to our
    time. Since it looks like (for the `cumtime` column) that most of the execution
    time is spent inside this function, we can safely assume that if we speed this
    up, the entire script's time would be affected.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，调用另一个函数会增加我们的时间开销。由于（对于`cumtime`列）大多数执行时间似乎都花在这个函数内部，我们可以安全地假设，如果我们加快这个速度，整个脚本的时间也会受到影响。
- en: 'Now, let''s apply a simple decorator to the `fib` function that will allow
    us to cache the previously calculated values (a technique also known as memoization,
    about which you''ll read in the upcoming chapters) so that we don''t have to call
    fib more than once per value:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给`fib`函数应用一个简单的装饰器，这样我们就可以缓存之前计算过的值（这种技术也称为记忆化，你将在接下来的章节中了解到）以便我们不必对每个值调用fib多次：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s run the code again and look at the output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行代码并查看输出：
- en: '![Fibonacci again](img/B02088_02_05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![斐波那契再次](img/B02088_02_05.jpg)'
- en: We went from around 57k total calls to only 145 and from 0.114 seconds to 0.001\.
    That's an amazing improvement! However, we have more primitive calls, but we also
    have significantly less recursive calls.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从大约57k的总调用次数减少到只有145次，从0.114秒减少到0.001秒。这是一个惊人的改进！然而，我们有了更多的原始调用，但我们也有显著更少的递归调用。
- en: 'Let''s continue with another possible optimization. Our example works quite
    fast for a single call, but let''s try to do several runs in a row and get the
    combined stats for that execution. Perhaps, we''ll get something interesting back.
    To do this, we need to use the stats module. Let''s see an example for this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行另一个可能的优化。我们的例子对于单个调用来说运行得相当快，但让我们尝试连续运行几次，并获取该执行的组合统计数据。也许我们会得到一些有趣的结果。为此，我们需要使用stats模块。让我们看看一个示例：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''ve pushed the envelope here. Getting the Fibonacci sequence for 1000 might
    be too much to ask, especially from a recursive implementation. Indeed, we ran
    out of recursion depth. This is mainly due to the fact that `cPython` has a guard
    to prevent a stack overflow error generated by the amount of recursive calls (ideally,
    a tail recursion optimization would solve this, but `cPython` does not provide
    it). So, we just found another issue. Let''s try to fix it and reanalyze the code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里已经达到了极限。获取1000的斐波那契序列可能要求过高，尤其是从递归实现中获取。事实上，我们已经达到了递归深度限制。这主要是因为`cPython`有一个保护机制来防止由递归调用数量产生的栈溢出错误（理想情况下，尾递归优化可以解决这个问题，但`cPython`没有提供）。因此，我们发现了另一个问题。让我们尝试修复它并重新分析代码：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding lines of code print a huge list of really big numbers, but these
    lines prove that we made it. We can now compute the Fibonacci sequence for the
    number 1000\. Now, let's analyze it and see what we find.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行打印了一大堆非常大的数字，但这些行证明了我们已经做到了。现在，我们可以计算数字1000的斐波那契数列了。现在，让我们分析一下，看看我们发现了什么。
- en: 'Using the new profiling code, but requiring the iterative version of the Fibonacci
    implementation, we will get this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的分析代码，但需要斐波那契实现的迭代版本，我们将得到以下结果：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This, in turn, will yield the following result into the console:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来会在控制台产生以下结果：
- en: '![Fibonacci again](img/B02088_02_06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Fibonacci again](img/B02088_02_06.jpg)'
- en: Our new code is taking 0.187 seconds to calculate the Fibonacci sequence of
    1000 five times. It's not a bad number, but we know we can improve it by caching
    the results, just like we did earlier. *As you can see, we have 5005 calls to
    the* `fib` *function. If we cache it, we would have a lot less function calls,
    which would mean less execution time*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新代码计算1000的斐波那契数列需要0.187秒，计算五次。这并不是一个糟糕的数字，但我们知道我们可以通过缓存结果来改进它。*正如你所见，我们有5005次对`fib`函数的调用。如果我们缓存它，我们将有更少的函数调用，这意味着更少的执行时间*。
- en: 'With very little effort, we can improve that time by caching the calls to the
    `fib` function, which, according the preceding report, is called 5005 times:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 只需做很少的工作，我们就可以通过缓存对`fib`函数的调用来提高这个时间，根据前面的报告，这个函数被调用了5005次：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should get something like the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下类似的输出：
- en: '![Fibonacci again](img/B02088_02_07.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Fibonacci again](img/B02088_02_07.jpg)'
- en: Simply by caching the call to `fib`, we went from 0.187 seconds to 0.006 seconds.
    This is an amazing improvement. Well done!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 只需缓存对`fib`函数的调用，我们就从0.187秒缩短到了0.006秒。这是一个惊人的改进。做得好！
- en: Tweet stats
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tweet stats
- en: Let's look at another example, something a bit more conceptually complex, since
    calculating the Fibonacci sequence is not really an everyday use case. Let's do
    something a bit more interesting. These days, Twitter allows you to download your
    complete list of tweets in the form of a CSV file. We'll use this file to generate
    some statistics from our feed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，这个例子在概念上稍微复杂一些，因为计算斐波那契数列并不是一个日常用例。让我们做一些更有趣的事情。如今，Twitter允许你以CSV文件的形式下载你的完整推文列表。我们将使用这个文件来从我们的源生成一些统计数据。
- en: 'Using the data provided, we''ll calculate the following statistics:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的数据，我们将计算以下统计数据：
- en: The percentage of messages that are actual replies
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际回复消息的百分比
- en: The percentage of tweets that were made from the website ([https://twitter.com](https://twitter.com))
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网站([https://twitter.com](https://twitter.com))发布的推文的百分比
- en: The percentage of tweets that were made from a mobile phone
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用手机发布的推文的百分比
- en: 'The output form our script will look like the one shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的输出将类似于以下截图所示：
- en: '![Tweet stats](img/B02088_02_08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Tweet stats](img/B02088_02_08.jpg)'
- en: To keep things simple, we'll take care of parsing the CSV file and doing these
    basic calculations. We won't use any third-party modules; that way, we'll be in
    total control of the code and its analysis. This means leaving out obvious things,
    such as using the CSV module from Python.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将负责解析CSV文件和进行这些基本的计算。我们不会使用任何第三方模块；这样，我们将完全控制代码及其分析。这意味着省略一些明显的事情，比如使用Python的CSV模块。
- en: Other bad practices shown earlier, such as the `inc_stat` function or the fact
    that we're loading the entire file into memory before processing it, will remind
    you that this is just an example to show basic improvements.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的其他不良做法，例如`inc_stat`函数或我们在处理之前将整个文件加载到内存中的事实，将提醒你，这只是一个示例，用来展示基本的改进。
- en: 'Here is the initial code of the script:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是脚本的初始代码：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To be fair, the code doesn't do anything too complicated. It loads the content
    of the file, splits it into lines, and then it splits each line into different
    fields. Finally, it counts things. One might think that with this explanation,
    there is nothing much to optimize, but we're about to see that there is always
    room for some optimization.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，这段代码并没有做太多复杂的事情。它加载文件的內容，将其分割成行，然后又将每一行分割成不同的字段。最后，它进行计数。有人可能会认为，有了这个解释，就没有太多可以优化的地方了，但我们将看到，总有优化的空间。
- en: Another important thing to note is that the CSV file we'll be processing has
    almost 150 MB of tweets data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要事项是，我们将处理的CSV文件几乎有150MB的推文数据。
- en: 'Here is the script that imports that code, uses it, and generates a profiling
    report:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是导入这段代码、使用它并生成性能报告的脚本：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output we get from this execution is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这次执行得到的输出如下：
- en: '![Tweet stats](img/B02088_02_09.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![推文统计数据](img/B02088_02_09.jpg)'
- en: 'There are three main areas of interest in the preceding screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，有三个主要感兴趣的区域：
- en: Total execution time
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总执行时间
- en: Cumulative times of individual function calls
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个函数调用的累积时间
- en: Total number of calls for individual functions
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个函数的总调用次数
- en: 'Our aim is to lower the total execution time. For that, we will pay special
    attention to the cumulative times of individual functions and the total number
    of calls for individual functions. We can infer the following conclusions for
    the last two points:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是降低总执行时间。为此，我们将特别关注单个函数的累积时间和单个函数的总调用次数。对于最后两点，我们可以得出以下结论：
- en: The `build_twit_stats` function is the one that takes the most time. However,
    as you can see in the preceding lines of code, it just calls all other functions,
    so it makes sense. We can focus on `read_data` since it's the second most time-consuming
    function. This is interesting, because it means that our bottleneck is not when
    we calculate the stats, but when we load the data for it.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_twit_stats` 函数是耗时最长的函数。然而，正如您在代码的前几行中看到的，它只是调用所有其他函数，所以这是有道理的。我们可以专注于
    `read_data`，因为它是耗时第二多的函数。这很有趣，因为这意味着我们的瓶颈不是在计算统计数据时，而是在加载数据时。'
- en: In the third line of the code, we also see exactly our bottleneck inside `read_data`.
    We perform too many `split` commands and they add up.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码的第三行，我们也可以看到 `read_data` 中的瓶颈。我们执行了太多的 `split` 命令，它们加在一起。
- en: We also see that the fourth most time-consuming function is `get_stats`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还看到，第四个最耗时的函数是 `get_stats`。
- en: So, let's tackle these issues and see if we get better results. The biggest
    bottleneck we had was the way we were loading data. We were loading it all into
    memory first and then iterating over it to calculate our stats. We can improve
    this by reading the file line by line and calculating the stats after each one.
    Let's see how that code would look.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们解决这些问题，看看我们是否能得到更好的结果。我们最大的瓶颈是我们加载数据的方式。我们首先将所有数据加载到内存中，然后迭代它来计算我们的统计数据。我们可以通过逐行读取文件并在每行之后计算统计数据来改进这一点。让我们看看这段代码会是什么样子。
- en: 'The new `read_data` method looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `read_data` 方法看起来像这样：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We had to add some logic to take into account multiline tweets, which are also
    saved as multiline records on our CSV file. We changed our `get_stats` function
    into `get_line_stats`, which simplifies its logic since it only calculates the
    values for the current record:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不添加一些逻辑来考虑多行推文，这些推文也作为多行记录保存在我们的CSV文件中。我们将 `get_stats` 函数更改为 `get_line_stats`，这简化了其逻辑，因为它只为当前记录计算值：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The two final improvements were to remove the calls to `inc_stat`, since, thanks
    to the dictionary we're using, the call is unnecessary. We also replaced the usage
    of the find method using the more proficient `in` operator.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两项改进是移除对 `inc_stat` 的调用，因为，多亏了我们使用的字典，这个调用是不必要的。我们还用更高效的 `in` 操作符替换了查找方法的用法。
- en: 'Let''s run the code again and see the changes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行代码并查看更改：
- en: '![Tweet stats](img/B02088_02_10.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![推文统计数据](img/B02088_02_10.jpg)'
- en: We went from 2 seconds to 1.6; that was a considerable improvement. The `read_data`
    function is still up there with the most time-consuming functions, but that's
    just because it now also calls the `get_line_stats` function. We can also improve
    on this, since even though the `get_line_stats` function does very little, we're
    incurring in a lookup time by calling it so often inside the loop. We could inline
    this function and see if that helps.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从2秒减少到1.6秒；这是一个相当大的改进。`read_data` 函数仍然是最耗时的函数之一，但这仅仅是因为它现在也调用了 `get_line_stats`
    函数。我们也可以在这方面进行改进，因为尽管 `get_line_stats` 函数做得很少，但我们通过在循环中频繁调用它而产生了查找时间。我们可以将这个函数内联，看看是否有所帮助。
- en: 'The new code would look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码将看起来像这样：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, with the new changes, the report will look like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着新更改，报告将看起来像这样：
- en: '![Tweet stats](img/B02088_02_11.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![推文统计数据](img/B02088_02_11.jpg)'
- en: There is a notable improvement between the first screenshot and the preceding
    one. We got the time down to barely above 1.4 seconds from 2 seconds. The number
    of function calls is considerably lower as well (it went from around 3 million
    calls to 1.7 million), which in turn should help lower the time spent doing lookups
    and calls.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张截图和前一张截图之间有一个显著的改进。我们将时间降低到略高于1.4秒，从2秒降至。函数调用的数量也显著降低（从大约300万次调用降至170万次），这反过来应该有助于降低查找和调用所花费的时间。
- en: 'As an added bonus, we will improve the readability of our code by simplifying
    it. Here is the final code all together:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的奖励，我们将通过简化代码来提高代码的可读性。以下是所有代码的最终版本：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is it for our review of `cProfile`. With it, we managed to profile our
    scripts, getting per-function numbers and total function calls. It helped us improve
    on the overall view of the system. We'll now look at a different profiler, which
    will give us per-line details that `cProfile` is not capable of providing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`cProfile`的回顾就到这里。通过它，我们成功地分析了脚本，得到了每个函数的数字和总函数调用次数。它帮助我们改进了对系统的整体视图。现在我们将查看一个不同的分析器，它将提供`cProfile`无法提供的每行细节。
- en: line_profiler
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: line_profiler
- en: This profiler is different from `cProfile`. It helps you profile a function
    line by line instead of doing a deterministic profiling, like the other one does.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分析器与`cProfile`不同。它帮助你逐行分析函数，而不是像其他分析器那样进行确定性分析。
- en: 'To install this profiler, you can use the pip ([https://pypi.python.org/pypi/pip](https://pypi.python.org/pypi/pip))
    command-line tool, with the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这个分析器，你可以使用pip ([https://pypi.python.org/pypi/pip](https://pypi.python.org/pypi/pip))
    命令行工具，以下是一个命令：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you run into any trouble, such as missing files during installation, make
    sure you have all development dependencies installed. In the case of Ubuntu, you
    can ensure that all the dependencies are installed by running the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在安装过程中遇到任何问题，例如缺少文件，请确保你已经安装了所有开发依赖项。在Ubuntu的情况下，你可以通过运行以下命令来确保所有依赖项都已安装：
- en: '`$ sudo apt-get install python-dev libxml2-dev libxslt-dev`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo apt-get install python-dev libxml2-dev libxslt-dev`'
- en: This profiler is trying to fill in a breach left by `cProfile` and others like
    it. Other profilers cover CPU time on function calls. Most of the time, this is
    more than enough to catch the problems and fix them (we saw that earlier). However,
    sometimes, the problem or bottleneck is related to one specific line inside the
    function and that is where `line_profiler` comes into play.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分析器试图填补`cProfile`和其他类似工具留下的空白。其他分析器覆盖了函数调用上的CPU时间。大多数情况下，这已经足够捕捉到问题并进行修复（我们之前已经看到过）。然而，有时问题或瓶颈与函数中的一行特定代码相关，这就是`line_profiler`发挥作用的地方。
- en: The author recommends us to use the `kernprof` utility, so we'll look at examples
    of it. Kernprof will create an instance of the profiler and insert it into the
    `__builtins__` namespace with the name, profile. The profiler was designed to
    be used as a decorator, so you can just decorate any function you want, and it
    will time the execution for each line of it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 作者推荐我们使用`kernprof`工具，因此我们将查看它的示例。Kernprof将创建一个分析器实例，并将其以`profile`的名称插入到`__builtins__`命名空间中。分析器被设计成用作装饰器，因此你可以装饰任何你想要的函数，并且它会为每一行计时。
- en: 'This is how we''ll execute the profiler:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们执行分析器的方式：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The decorated function is ready to be profiled:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰过的函数已经准备好进行分析了：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'By default, `kernprof` will save the results into a file called `script_to_profile.py.lprof`,
    but you can tell it to display the results right away using the `-v` attribute:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`kernprof`会将结果保存到名为`script_to_profile.py.lprof`的文件中，但你可以使用`-v`属性来告诉它立即显示结果：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is a simple example output to help you understand what you''ll be looking
    at:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的输出示例，以帮助您理解您将看到的内容：
- en: '![line_profiler](img/B02088_02_12.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![line_profiler](img/B02088_02_12.jpg)'
- en: 'The output contains every line of the function, next to the timing information.
    There are six columns of information, and this is what they mean:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包含函数的每一行，旁边是时间信息。共有六列信息，以下是它们的含义：
- en: '`Line #`: This is the line number inside the file.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`行号`：这是文件内的行号。'
- en: '`Hits`: This is the number of times this line is executed during the profiling.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`命中次数`：这是在分析期间此行被执行的次数。'
- en: '`Time`: This is the total execution time of that line, specified in timer''s
    unit. In the header information before the table with the results, you''ll notice
    a field called `Timer unit`, that number is the conversion factor to seconds (to
    calculate the actual time, you''ll have to do time `x` timer''s unit). It might
    be different on different systems.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`时间`: 这是该行的总执行时间，以计时器单位指定。在结果表之前的信息中，你会注意到一个名为 `计时器单位` 的字段，那个数字是转换为秒的转换因子（要计算实际时间，你必须将时间
    `x` 计时器单位）。在不同的系统上可能会有所不同。'
- en: '`Per hit`: The average amount of time spent executing that line of code. This
    is also specified in timer''s units.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Per hit`: 执行该行代码的平均时间。这也在计时器的单位中指定。'
- en: '`% Time`: The percentage of time spent executing that line, relative to the
    total time spent executing the entire function.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`% 时间`: 执行该行代码所花费的时间百分比，相对于整个函数执行的总时间。'
- en: 'If you''re building another tool that leverages `line_profiler`, there are
    two ways to let it know which functions to profile: using the constructor and
    using the `add_function` method.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建另一个利用 `line_profiler` 的工具，有两种方式让它知道要分析哪些函数：使用构造函数和使用 `add_function` 方法。
- en: The `line_profiler` also provides the same `run`, `runctx`, `runcall`, `enable`,
    and `disable` methods that `cProfile.Profile` provides. However, the last two
    aren't safe when nesting, so be careful. After profiling, you can dump the `stats`
    into a file using the `dump_stats(filename)` method, or you can print them using
    the `print_stats([stream])` method. It'll print the results into `sys.stdout`
    or whatever other stream you pass it as parameter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`line_profiler` 也提供了与 `cProfile.Profile` 相同的 `run`、`runctx`、`runcall`、`enable`
    和 `disable` 方法。然而，在嵌套时最后两个并不安全，所以请小心。分析完成后，你可以使用 `dump_stats(filename)` 方法将 `stats`
    输出到文件，或者使用 `print_stats([stream])` 方法打印它们。它将结果打印到 `sys.stdout` 或你作为参数传递的任何其他流。'
- en: 'Here is an example of the same function from earlier. This time, the function
    is being profiled using the `line_profiler` API:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是之前相同函数的一个例子。这次，函数是使用 `line_profiler` API 进行分析的：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: kernprof
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kernprof
- en: 'The `kernprof` is the profiling utility that comes bundled with `line_profiler`
    and allows us to abstract most of the profiling code from our own source code.
    This means we can use it to profile our application, like we saw earlier. `kernprof`
    will do several things for us:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`kernprof` 是与 `line_profiler` 一起打包的剖析工具，允许我们将大部分剖析代码从我们的源代码中抽象出来。这意味着我们可以像之前看到的那样使用它来分析我们的应用程序。`kernprof`
    会为我们做几件事情：'
- en: It'll work with `cProfile`, `lsprof`, and even the profile module, depending
    on which one is available.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以与 `cProfile`、`lsprof` 以及甚至 profile 模块一起工作，具体取决于哪个可用。
- en: It'll find our script properly. If the script is not inside the current folder,
    it'll even check the `PATH` variable.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会正确地找到我们的脚本。如果脚本不在当前文件夹中，它甚至会检查 `PATH` 变量。
- en: It'll instantiate and insert the profiler into the `__builtins__` namespace
    with the name `profile`. This will allow us to use the profiler inside our code.
    In the case of `line_profiler`, we can even use it as a decorator without having
    to worry about importing anything.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会实例化并将剖析器插入到 `__builtins__` 命名空间中，名称为 `profile`。这将允许我们在代码中使用剖析器。在 `line_profiler`
    的情况下，我们甚至可以用作装饰器而无需担心导入任何内容。
- en: 'The output files with the profiling `stats` can be viewed using the `pstats.Stats`
    class or even from the command line as follows:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有分析 `stats` 的输出文件可以使用 `pstats.Stats` 类查看，甚至可以从命令行如下查看：
- en: '[PRE33]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or in the case of `lprof` files:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，在 `lprof` 文件的情况下：
- en: '[PRE34]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Some things to consider about kernprof
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 kernprof 需要考虑的一些事项
- en: 'There are a couple of things to take into consideration when reading the output
    from kernprof. In some cases, the output might be confusing, or the numbers might
    not add up. Here are the answers to some of the most common questions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 kernprof 的输出时，有一些事情需要考虑。在某些情况下，输出可能令人困惑，或者数字可能不匹配。以下是一些最常见问题的答案：
- en: '**Line-by-line time doesn''t add up to total time when the profile function
    calls another one**: When profiling a function that gets called by another profiled
    function, sometimes, it might happen that the numbers don''t add up. This is because
    `kernprof` is only recording the time spent inside the function and tries to avoid
    measuring any overhead added by the profiler itself, as shown in the following
    screenshot:![Some things to consider about kernprof](img/B02088_02_13.jpg)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当分析函数调用另一个分析函数时，按行时间不等于总时间**：当分析一个被另一个分析函数调用的函数时，有时数字可能不会相加。这是因为 `kernprof`
    只记录函数内部花费的时间，并试图避免测量分析器本身添加的任何开销，如下面的截图所示：![关于 kernprof 需要考虑的一些事项](img/B02088_02_13.jpg)'
- en: The preceding screenshot shows an example of this. The `printI` function takes
    `0.010539` seconds according to the profiler. However, inside the `test` function,
    the total amount of time spent seems to be `19567` timer's units, which amounts
    to `0.019567` seconds.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的截图展示了这个例子。根据分析器，`printI` 函数耗时 `0.010539` 秒。然而，在 `test` 函数内部，似乎总共花费了 `19567`
    个计时器单位，相当于 `0.019567` 秒。
- en: '**List comprehension lines have a lot more hits than they should inside the
    report**: This is basically because the report is adding one hit per iteration
    inside the expression. Here is an example of this:![Some things to consider about
    kernprof](img/B02088_02_14.jpg)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表推导式行在报告中命中次数远多于应有的数量**：这基本上是因为报告在表达式中每迭代一次就增加一个命中。以下是一个例子：![关于 kernprof
    需要考虑的一些事项](img/B02088_02_14.jpg)'
- en: You can see how the actual expression line has `102` hits, `2` for each time
    the `printExpression` function is called, and the other 100 due to the range used.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到实际的代码行有 `102` 次命中，每次调用 `printExpression` 函数时命中 `2` 次，其余 `100` 次是由于使用的范围导致的。
- en: Profiling examples
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析示例
- en: Now that we've seen the basics of how to use `line_profiler` and `kernprof`,
    let's get our hands dirty with more interesting examples.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用 `line_profiler` 和 `kernprof` 的基础知识，让我们通过更有趣的例子来实际操作。
- en: Back to Fibonacci
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回到斐波那契数列
- en: Yes, let's again profile our original Fibonacci code. It'll be good to compare
    the output from both profilers to see how they work.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，让我们再次分析我们的原始斐波那契代码。比较两个分析器的输出将有助于了解它们的工作方式。
- en: 'Let''s first look at the output from this new profiler:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看这个新分析器的输出：
- en: '![Back to Fibonacci](img/B02088_02_15.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![回到斐波那契数列](img/B02088_02_15.jpg)'
- en: Out of all the numbers in the report, we can rest assured that timing is not
    an issue. Inside the `fib` function, none of the lines take too long (nor should
    they). Inside `fib_seq`, only one does, but that's because of the recursion shown
    inside `fib`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告中的所有数字中，我们可以放心，计时并不是问题。在 `fib` 函数内部，没有任何一行代码耗时过长（也不应该）。在 `fib_seq` 中，只有一行，但这是因为
    `fib` 函数内部的递归导致的。
- en: So, our problem (as we already know) is the recursion and the number of times
    we're executing the `fib` function (57, 291 times to be exact). Every time we
    make a function call, the interpreter has to do a lookup by name and then execute
    the function. Every time we call the `fib` function, two more calls are made.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的问题（正如我们已经知道的）是递归和执行 `fib` 函数的次数（确切地说，是 57,291 次）。每次我们进行函数调用，解释器都必须通过名称进行查找然后执行函数。每次我们调用
    `fib` 函数，就会再调用两个函数。
- en: 'The first thing that comes to mind is to somehow lower the number of recursive
    calls. We can rewrite it into an iterative version or do a quick fix by adding
    the cached decorator, like we did earlier. We can see the results in the following
    report:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个想到的是降低递归调用的次数。我们可以将其重写为迭代版本，或者像之前那样通过添加缓存的装饰器进行快速修复。我们可以在以下报告中看到结果：
- en: '![Back to Fibonacci](img/B02088_02_16.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![回到斐波那契数列](img/B02088_02_16.jpg)'
- en: The number of hits for the `fib` function went from 57, 291 hits to `21`. This
    is another proof that the cached decorator is a great optimization in this case.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`fib` 函数的命中次数从 57,291 次减少到 `21`。这又是一个证明，在这个情况下，缓存的装饰器是一个很好的优化。'
- en: Inverted index
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 倒排索引
- en: 'Instead of repeating the second example from within a different profiler, let''s
    look at another problem: creating an inverted index ([http://en.wikipedia.org/wiki/inverted_index](http://en.wikipedia.org/wiki/inverted_index)).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再重复第二个例子，而是看看另一个问题：创建倒排索引 ([http://en.wikipedia.org/wiki/inverted_index](http://en.wikipedia.org/wiki/inverted_index))。
- en: An inverted index is a resource used by many search engines to find words in
    several files at the same time. The way they work is by pre-scanning all files,
    splitting their content into words, and then saving the relations between those
    words and the files (some even save the position of the word too). This way, when
    a search is made on a specific word, the searching time is `O(1)` (constant).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 倒排索引是许多搜索引擎用来同时查找多个文件中单词的资源。它们的工作方式是预先扫描所有文件，将它们的内容分割成单词，然后保存这些单词与文件之间的关系（有些甚至保存单词的位置）。这样，当对特定单词进行搜索时，搜索时间可以达到`O(1)`（常数）。
- en: 'Let''s see a simple example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So now, if we were to look for the word `file`, we know it''s in both files
    (at different positions). Let''s see the code that calculates this index (again,
    the point of the following code is to show classic improvement opportunities,
    so stick with us until we see the optimized version of the code):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们现在要查找单词`file`，我们知道它在两个文件中（在不同的位置）。让我们看看计算这个索引的代码（再次，以下代码的目的是展示经典的改进机会，所以请继续跟随我们，直到我们看到代码的优化版本）：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding code is as simple as it gets. It gets the job done for simple
    `.txt` files, and that is what we want right now. It'll load all `.txt` files
    inside the files folder, split their content into words, and calculate the offset
    of those words inside the document. Finally, it'll save all this information into
    a file called `index-file.txt`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码尽可能简单。它能够处理简单的`.txt`文件，这正是我们目前想要的。它将加载文件文件夹内的所有`.txt`文件，将它们的内容分割成单词，并计算这些单词在文档中的偏移量。最后，它将所有这些信息保存到一个名为`index-file.txt`的文件中。
- en: So, let's begin profiling and see what we get. Since we don't really know exactly
    which are the heavy-duty functions and which ones are the light ones, let's add
    the `@profile` decorator to all of them and run the profiler.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始分析并看看我们能得到什么。由于我们并不确切知道哪些是重负载函数，哪些是轻负载函数，让我们给所有这些函数都添加`@profile`装饰器并运行分析器。
- en: getOffsetUpToWord
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: getOffsetUpToWord
- en: The `getOffsetUpToWord` function looks like a great candidate for optimization,
    since it gets called quite a few times during execution. Let's keep the decorator
    on it for now.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOffsetUpToWord`函数看起来是一个很好的优化候选，因为它在执行过程中被调用了好几次。我们现在暂时保留这个装饰器。'
- en: '![getOffsetUpToWord](img/B02088_02_17.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![getOffsetUpToWord](img/B02088_02_17.jpg)'
- en: getWords
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: getWords
- en: The `getWords` function does a lot of processing. It even has two nested `for`
    loops, so we'll keep the decorator on as well.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWords`函数做了很多处理。它甚至有两个嵌套的`for`循环，所以我们也保留这个装饰器。'
- en: '![getWords](img/B02088_02_18.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![getWords](img/B02088_02_18.jpg)'
- en: list2dict
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: list2dict
- en: The `list2dict` function takes care of grabbing a list of arrays with two elements
    and returning a dictionary, using the first element of the array items as key
    and the second one as values. We'll leave the `@profile` decorator on for now.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`list2dict`函数负责获取包含两个元素的数组列表，并返回一个字典，使用数组项的第一个元素作为键，第二个元素作为值。我们现在暂时保留`@profile`装饰器。'
- en: '![list2dict](img/B02088_02_19.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![list2dict](img/B02088_02_19.jpg)'
- en: readFileContent
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: readFileContent
- en: The `readFileContent` function has two lines, and the significant one simply
    calls the `split` method on the content of the file. There is not a lot to improve
    here, so we'll discard it and focus on the other ones.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFileContent`函数有两行，其中重要的一行只是简单地调用文件内容的`split`方法。这里没有太多可以改进的地方，所以我们将它排除，并专注于其他函数。'
- en: '![readFileContent](img/B02088_02_20.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![readFileContent](img/B02088_02_20.jpg)'
- en: saveIndex
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: saveIndex
- en: The `saveIndex` function writes the results of the processing to a file, using
    a specific format. We might be able to get some better numbers here too.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveIndex`函数将处理结果写入文件，使用特定的格式。我们也许能在这里得到一些更好的数字。'
- en: '![saveIndex](img/B02088_02_21.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![saveIndex](img/B02088_02_21.jpg)'
- en: __start__
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: __start__
- en: Finally, the main method, `__start__`, takes care of calling the other functions
    and doesn't do much heavy lifting, so we'll also discard it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主方法`__start__`负责调用其他函数，并没有做太多繁重的工作，所以我们也将其排除在外。
- en: '![__start__](img/B02088_02_22.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![__start__](img/B02088_02_22.jpg)'
- en: So, let's summarize. We originally had six functions, out of which we discarded
    two, because they were too trivial or just didn't do anything relevant. Now, we
    have a total of four functions to review and optimize.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们总结一下。我们最初有六个函数，其中我们排除了两个，因为它们太简单或者根本就没有做任何相关的事情。现在，我们总共有四个函数需要审查和优化。
- en: getOffsetUpToWord
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: getOffsetUpToWord
- en: Let's first look at the `getOffsetUpToWord` function, which has a lot of lines
    for something as simple as adding up the length of the words leading up to the
    current index. There is probably a more Pythonic way to go about it, so let's
    try it out.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看`getOffsetUpToWord`函数，对于如此简单的任务——即计算到当前索引为止的单词长度之和——它却有很多行代码。可能存在一种更Pythonic的方式来处理这个问题，所以让我们试试看。
- en: 'This function originally comprised 1.4 seconds of the total execution time,
    so let''s try to lower that number by simplifying the code. The adding up of the
    length of the words can be translated into a reduce expression, as shown here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数原本占用了总执行时间的1.4秒，所以让我们尝试通过简化代码来降低这个数字。单词长度的累加可以转换成一个reduce表达式，如下所示：
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This simplification removes the need for extra time doing variable assignments
    and lookups. It might not seem like much. However, if we run the profiler again
    with this new code, the time would go down to 0.9 seconds. There is still an obvious
    drawback to that implementation: the lambda function. We''re dynamically creating
    a function every time we call `getOffsetUpToWord`. We''re calling it 313,868 times,
    so it would be a good idea to have this function already created. We can just
    add a reference to it in the reduce expression, as shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化消除了进行变量赋值和查找额外时间的需要。这看起来可能不多。然而，如果我们用这段新代码再次运行性能分析器，时间会降低到0.9秒。这个实现仍然有一个明显的缺点：lambda函数。我们每次调用`getOffsetUpToWord`时都会动态创建一个函数。我们调用了313,868次，所以最好提前创建这个函数。我们可以在reduce表达式中添加对这个函数的引用，如下所示：
- en: '[PRE38]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output should be similar to the following screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下截图：
- en: '![getOffsetUpToWord](img/B02088_02_23.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![getOffsetUpToWord](img/B02088_02_23.jpg)'
- en: With this minor improvement, the execution time goes down to 0.8 seconds. In
    the preceding screenshot, we can see that there are still a lot of unwanted hits
    (and therefore time) spent in the first two lines of the function. This check
    is unnecessary because the reduce function already defaults to 0\. Finally, the
    assignment to the length variable can be removed, and we can return directly the
    sum of the length, the index, and the integer 1.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小小的改进，执行时间降低到了0.8秒。在先前的截图上，我们可以看到函数的前两行仍然有大量的不必要的调用（因此耗时）。这个检查是不必要的，因为reduce函数默认就是0。最后，可以移除对长度变量的赋值，并直接返回长度、索引和整数1的总和。
- en: 'With that, we''re left with the following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们剩下的代码如下：
- en: '[PRE39]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The total execution time for this function went from 1.4 to an amazing 0.67
    seconds.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的总执行时间从1.4秒降低到了惊人的0.67秒。
- en: getWords
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: getWords
- en: 'Let''s now move on to the next one: the `getWords` function. It is a pretty
    slow one. According to the screenshot, the execution of this function adds up
    to 4 seconds. That''s not good. Let''s see what we can do about it. First things
    first, the most expensive (time-consuming) line in this function is the one that
    calls the `getOffsetUpToWord` function. Since we already optimized that one, the
    total time of this function is now 2.2 seconds (down from 4 seconds).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向下一个函数：`getWords`函数。这是一个相当慢的函数。根据截图，这个函数的执行时间达到了4秒。这可不是什么好事。让我们看看我们能做些什么。首先，这个函数中最耗时的（耗时最多的）一行是调用`getOffsetUpToWord`函数的那一行。由于我们已经优化了那个函数，所以现在这个函数的总执行时间已经降低到了2.2秒（从4秒减少）。
- en: That's a pretty decent side effect optimization, but we can still do a bit more
    for this function. We're using a normal dictionary for the `wordIndexDict` variable,
    so we have to check whether a key is set before actually using it. Doing that
    check inside this function takes up about 0.2 seconds. It is not a lot, but an
    optimization nonetheless. To remove that check, we can use the `defaultdict` class.
    It is a subclass of the `dict` class, which adds an extra functionality. It sets
    a default value for when a key doesn't exist. This will remove the need for those
    0.2 seconds inside the function.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当不错的副作用优化，但我们还可以为这个函数做更多。我们使用普通的字典作为`wordIndexDict`变量，因此我们必须在使用之前检查键是否已设置。在这个函数中进行这个检查大约需要0.2秒。这虽然不多，但也是一种优化。为了消除这个检查，我们可以使用`defaultdict`类。它是`dict`类的一个子类，它增加了一个额外的功能。它为键不存在时设置一个默认值。这将消除函数内部0.2秒的需要。
- en: 'Another trivial but helpful optimization is the assignment of results to variables.
    It might seem like a small thing, but doing it 313,868 times will no doubt hurt
    our timing. So, take a look at these lines:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个微不足道但很有帮助的优化是将结果赋值给变量。这看起来可能微不足道，但做313,868次无疑会损害我们的性能。所以，看看这些行：
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These lines can be changed into a single line of code, as shown here:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行可以简化为单行代码，如下所示：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With that, we shaved off another 0.2 seconds. Finally, we're doing a strip operation
    on every line and then on every word. We can simplify this by calling the `replace`
    method several times for the entire content when loading the file. This will take
    care of cleaning up the text we'll be processing and remove added time for lookups
    and method calls inside the `getWords` function.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们节省了另外0.2秒。最后，我们在每一行和每个单词上执行了strip操作。我们可以通过在加载文件时多次调用`replace`方法来简化这一点，以处理我们将要处理的文本，并从`getWords`函数内部的查找和调用方法中移除额外的时间。
- en: 'The new code looks like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码看起来像这样：
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It only takes 1.57 seconds to run. There is one extra optimization that we
    might want to look at. It fits this particular case, because the `getOffsetUpToWord`
    function is only used in one place. Since this function got reduced to a one-liner,
    we can just put the one-liner in place of the function call. This one-liner will
    subtract the lookup time and give us a whopping 1.07 seconds (that''s a 0.50 seconds
    reduction!). This is how the latest version of the function looks:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间仅需1.57秒。还有一个额外的优化我们可能想看看。它适用于这个特定情况，因为`getOffsetUpToWord`函数只在一个地方使用。由于这个函数简化为了一行代码，我们只需将这一行代码放在函数调用的位置。这一行代码将减少查找时间，给我们带来1.07秒的巨大提升（这是0.50秒的减少！）。这就是最新版本的函数看起来是这样的：
- en: '![getWords](img/B02088_02_24.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![getWords](img/B02088_02_24.jpg)'
- en: If you'll call the function from several places, this might be an optimization
    that is not worth having, since it'll hurt the code maintainability. Code maintainability
    is also an important aspect when developing. It should be a deciding factor when
    trying to figure out when to stop with the optimization process.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将从多个地方调用该函数，这可能是一个不值得拥有的优化，因为它会损害代码的可维护性。在开发过程中，代码的可维护性也是一个重要的方面。在尝试确定何时停止优化过程时，它应该是一个决定性因素。
- en: list2dict
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: list2dict
- en: 'Moving on, for the `list2dict` function, we can''t really do much, but we can
    clean it up to get a more readable code and shave of about 0.1 seconds. Again,
    we''re not doing this strictly for the speed gain, but for the readability gain.
    We have a chance to use the `defaultdict` class again and remove the check for
    a key so that the new code looks like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于`list2dict`函数，我们实际上无法做太多，但我们可以清理它以获得更易读的代码，并节省大约0.1秒。再次强调，我们这样做不是为了速度的提升，而是为了可读性的提升。我们有再次使用`defaultdict`类的机会，并移除对键的检查，使新代码看起来像这样：
- en: '[PRE43]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding code has less lines, is easier to read, and more easy to understand.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行数较少，更易于阅读，也更容易理解。
- en: saveIndex
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: saveIndex
- en: Finally, let's take a look at the `saveIndex` function. According to our initial
    report, this function took 0.23 seconds to preprocess and save the data into the
    index file. That's a pretty good number already, but we can do a bit better by
    taking a second look at all the string concatenations we have.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看`saveIndex`函数。根据我们的初步报告，这个函数预处理并保存数据到索引文件需要0.23秒。这已经是一个相当不错的数字了，但我们可以通过再次审视所有的字符串连接来做得更好。
- en: Before saving the data, for every word we generate a string by concatenating
    several pieces together. In that same loop, we will also reset the `indexLine`
    and `glue` variables. These actions will add up to a lot of time, so we might
    want to change our strategy.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存数据之前，对于每个生成的单词，我们通过连接几个部分来生成一个字符串。在同一个循环中，我们还将重置`indexLine`和`glue`变量。这些操作将花费很多时间，所以我们可能想要改变我们的策略。
- en: 'This is shown in the following code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下代码中显示：
- en: '[PRE44]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see in the preceding code, we changed the entire `for` loop. Now,
    instead of adding the new string to the `indexLine` variable, we appended it into
    a list. We also removed the map call, which was making sure we were dealing with
    strings during the `join` call. That `map` was moved into the `list2dict` function,
    casting the indexes to the string directly while appending them.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们改变了整个`for`循环。现在，我们不再将新字符串添加到`indexLine`变量中，而是将其追加到列表中。我们还移除了确保在`join`调用期间处理字符串的`map`调用。那个`map`被移动到`list2dict`函数中，在追加时直接将索引转换为字符串。
- en: Finally, we used the `+` operator to concatenate strings instead of doing string
    expansion, which is a more expensive operation. In the end, this function went
    down from 0.23 seconds to 0.13, giving us a 0.10-second gain in speed.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用了`+`运算符来连接字符串，而不是执行更昂贵的字符串展开操作。最终，这个函数的速度从0.23秒下降到0.13秒，给我们带来了0.10秒的速度提升。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'To sum things up, we''ve seen two major profilers used with Python: `cProfile`,
    which comes bundled with the language, and `line_profiler`, which gives us the
    chance to look at each line of code independently. We also covered some examples
    of analysis and optimization using them.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们看到了两种在Python中使用的主要分析器：`cProfile`，它是语言自带的功能，以及`line_profiler`，它让我们有机会独立查看每一行代码。我们还介绍了使用它们进行分析和优化的几个示例。
- en: In the next chapter, we will look at a set of visual tools that will help us
    in our job by displaying the same data we covered in this chapter, but in a graphic
    manner.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一系列视觉工具，这些工具将通过以图形方式展示本章中涵盖的相同数据来帮助我们完成工作。
