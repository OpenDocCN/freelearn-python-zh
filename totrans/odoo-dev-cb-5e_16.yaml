- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: The Odoo Web Library (OWL)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Odoo Web Library (OWL)
- en: The Odoo V17 Javascript framework uses a custom component framework called **OWL**
    (short for **Odoo Web Library**). It is a declarative component system loosely
    inspired by **Vue** and **React**. **OWL** is a component-based UI framework and
    uses QWeb templates for structure. OWL is very fast compared to Odoo’s legacy
    widget system and introduces tons of new features, including **hooks**, **reactivity**,
    the **auto instantiation** of **subcomponents**, and more besides.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo V17 JavaScript 框架使用一个名为 **OWL**（代表 **Odoo Web Library**）的自定义组件框架。它是一个受
    **Vue** 和 **React** 灵感启发的声明式组件系统。**OWL** 是一个基于组件的 UI 框架，并使用 QWeb 模板进行结构。与 Odoo
    的传统小部件系统相比，OWL 非常快，并引入了大量的新功能，包括 **hooks**、**reactivity**、**子组件**的 **自动实例化**以及更多。
- en: 'In this chapter, we will learn how to use an OWL component to generate interactive
    UI elements. We will start with a minimal OWL component and then we will learn
    about the component’s life cycle. Finally, we will create a new field widget for
    the form view. In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 OWL 组件生成交互式 UI 元素。我们将从一个最小的 OWL 组件开始，然后我们将了解组件的生命周期。最后，我们将为表单视图创建一个新的字段小部件。在本章中，我们将涵盖以下菜谱：
- en: Creating an OWL component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 OWL 组件
- en: Managing user actions in an OWL component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OWL 组件中管理用户操作
- en: Making OWL components with hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用钩子制作 OWL 组件
- en: Understanding the OWL component life cycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 OWL 组件的生命周期
- en: Adding an OWL field to the form view
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单视图中添加 OWL 字段
- en: Note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following question may occur to you: why is Odoo not using some well-known
    JavaScript frameworks, such as React.js or Vue.js? Please check out the following
    link for more information: [https://github.com/odoo/owl/blob/master/doc/miscellaneous/comparison.md](https://github.com/odoo/owl/blob/master/doc/miscellaneous/comparison.md).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问这样一个问题：为什么 Odoo 不使用一些知名的 JavaScript 框架，比如 React.js 或 Vue.js？请查看以下链接获取更多信息：[https://github.com/odoo/owl/blob/master/doc/miscellaneous/comparison.md](https://github.com/odoo/owl/blob/master/doc/miscellaneous/comparison.md)。
- en: You can refer to [https://github.com/odoo/owl](https://github.com/odoo/owl)
    to learn more about the OWL framework.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考[https://github.com/odoo/owl](https://github.com/odoo/owl)了解 OWL 框架的更多信息。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: OWL components are defined with ES6 classes. In this chapter, we will be using
    some ES6 syntax. Also, some ES6 syntaxes are not supported by old browsers, so
    make sure you are using the latest version of Chrome or Firefox. You will find
    the code for this chapter at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OWL 组件使用 ES6 类定义。在本章中，我们将使用一些 ES6 语法。此外，一些 ES6 语法在旧浏览器中不受支持，所以请确保您正在使用最新版本的
    Chrome 或 Firefox。您可以在[https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16)找到本章的代码。
- en: Creating an OWL component
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 OWL 组件
- en: The main building blocks of OWL are components and templates.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OWL 的主要构建块是组件和模板。
- en: 'In OWL, every part of the UI is managed by a component: they hold the logic
    and define the templates that are used to render the user interface'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OWL 中，UI 的每个部分都由一个组件管理：它们持有逻辑并定义用于渲染用户界面的模板
- en: The goal of this recipe is to learn the basics of an OWL component. We will
    create a minimal OWL component and append it to the Odoo web client. In this recipe,
    we will create a component for a small horizontal bar with some text.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的目标是学习 OWL 组件的基础知识。我们将创建一个最小的 OWL 组件并将其附加到 Odoo 网络客户端。在这个菜谱中，我们将创建一个用于小型水平栏的组件，其中包含一些文本。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will be using the `my_hostel` module with basic fields and
    views. You will find the basic `my_hostel` module in the [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/00_initial_module/my_hostel](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/00_initial_module/my_hostel)
    directory in the GitHub repository.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用具有基本字段和视图的 `my_hostel` 模块。您可以在 GitHub 仓库的[https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/00_initial_module/my_hostel](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/00_initial_module/my_hostel)目录中找到基本的
    `my_hostel` 模块。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will add a small horizontal bar component to the Odoo web client. Follow
    these steps to add your first component to the Odoo web client:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向 Odoo 网页客户端添加一个小型水平栏组件。按照以下步骤将您的第一个组件添加到 Odoo 网页客户端：
- en: 'Add a `my_hostel/static/src/js/component.js` JavaScript file and define the
    new module’s namespace:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `my_hostel/static/src/js/component.js` JavaScript 文件中添加一个新的模块命名空间：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the component JavaScript to `assets`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件 JavaScript 添加到 `assets`：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the OWL utilities to the `component.js` file created in *step 1*:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中创建的 `component.js` 文件中定义 OWL 工具：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the OWL component and its basic template to the `component.js` file created
    in *step 1*:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 OWL 组件及其基本模板添加到 *步骤 1* 中创建的 `component.js` 文件：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Initialize and append the component to the web client. Add this to the `component.js`
    file added in *step 1*:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化并将组件添加到网页客户端。将以下内容添加到 *步骤 1* 中添加的 `component.js` 文件：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Install/upgrade the `my_hostel` module to apply our changes. Once our module
    is loaded in Odoo, you will see the horizontal bar, as shown in the following
    screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 安装/升级 `my_hostel` 模块以应用我们的更改。一旦我们的模块在 Odoo 中加载，您将看到水平栏，如下面的截图所示：
- en: '![Figure 16.1 – OWL component](img/B20997_16_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.1 – OWL 组件](img/B20997_16_01.jpg)'
- en: Figure 16.1 – OWL component
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – OWL 组件
- en: This is just a simple component. Right now, it will not handle any user events
    and you cannot remove it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的组件。目前，它不会处理任何用户事件，并且无法将其删除。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* and *step 2*, we added a JavaScript file and listed it in the backend
    assets. If you want to learn more about assets, refer to the *Static assets management*
    recipe in [*Chapter 14*](B20997_14.xhtml#_idTextAnchor734)*, CMS* *Website Development*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 和 *步骤 2* 中，我们添加了一个 JavaScript 文件并将其列入后端资产。如果您想了解更多关于资产的信息，请参阅 [*第 14
    章*](B20997_14.xhtml#_idTextAnchor734) 中的 *静态资产管理* 菜谱，CMS *网站开发*。
- en: In *step* *3*, we initialized a variable from OWL. All the utilities from OWL
    are available under a single global variable, `owl`. In our example, we pulled
    an OWL utility. we declared `Component`, `mount`, `xml` , `whenReady`. `Component`
    is the main class for the `OWL` component and, by extending it, we will create
    our own components.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们从 OWL 初始化了一个变量。所有 OWL 工具都在一个全局变量 `owl` 下可用。在我们的例子中，我们拉取了一个 OWL
    工具。我们声明了 `Component`、`mount`、`xml`、`whenReady`。`Component` 是 OWL 组件的主要类，通过扩展它，我们将创建自己的组件。
- en: In *step 4,* we created our component, `MyComponent`, by extending OWL’s `Component`
    class. For the sake of simplicity, we have just added the QWeb template to the
    definition of the `MyComponent` class. Here, as you may have noticed, we have
    used `` xml`…` `` to declare our template. This syntax is known as an inline template.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 中，我们通过扩展 OWL 的 `Component` 类创建了我们的组件 `MyComponent`。为了简化，我们只是将 QWeb
    模板添加到 `MyComponent` 类的定义中。这里，如您所注意到的，我们使用了 `` xml`…` `` 来声明我们的模板。这种语法被称为内联模板。
- en: However, you can load QWeb templates via separate files, which is usually the
    case. We will see examples of external QWeb templates in the upcoming recipes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以通过单独的文件加载 QWeb 模板，这通常是情况。我们将在接下来的菜谱中看到外部 QWeb 模板的示例。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Inline QWeb templates do not support translations or modifications via inheritance.
    So, always endeavor to load QWeb templates from a separate file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 内联 QWeb 模板不支持通过继承进行翻译或修改。因此，始终努力从单独的文件中加载 QWeb 模板。
- en: In *step 5*, we instantiated the `MyComponent` component and appended it to
    the body. The OWL component is an ES6 class, so you can create an object via the
    `new` keyword. Then you can use the `mount()` method to add the component to the
    page. If you notice, we have placed our code inside the `whenReady()` callback.
    This will ensure that all OWL functionality is properly loaded before we start
    using OWL components.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，我们实例化了 `MyComponent` 组件并将其附加到主体上。OWL 组件是一个 ES6 类，因此您可以通过 `new` 关键字创建一个对象。然后您可以使用
    `mount()` 方法将组件添加到页面。如果您注意到，我们将代码放在了 `whenReady()` 回调中。这将确保在开始使用 OWL 组件之前，所有 OWL
    功能都已正确加载。
- en: There’s more...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: OWL is a separate library and is loaded in Odoo as an external JavaScript library.
    You can use OWL in your other projects, too. The OWL library is listed at [https://github.com/odoo/owl](https://github.com/odoo/owl).
    There is also an online playground available in case you just want to test OWL
    without setting it in your local machine. You can play with OWL at [https://odoo.github.io/owl/playground/](https://odoo.github.io/owl/playground/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: OWL是一个独立的库，作为外部JavaScript库加载到Odoo中。您也可以在其他项目中使用OWL库。OWL库的链接为[https://github.com/odoo/owl](https://github.com/odoo/owl)。如果您只想在本地机器上测试OWL而不设置它，还有一个在线游乐场可供使用。您可以在[https://odoo.github.io/owl/playground/](https://odoo.github.io/owl/playground/)上与OWL互动。
- en: Managing user actions in an OWL component
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OWL组件中管理用户动作
- en: To make the UI interactive, components need to handle `user actions` such as
    `click`, `hover`, and `form submission`. In this recipe, we will add a button
    to our component, and we will handle a click event.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使UI交互式，组件需要处理`用户动作`，如`点击`、`悬停`和`表单提交`。在这个菜谱中，我们将向我们的组件添加一个按钮，并将处理点击事件。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will continue using the `my_hostel` module from the previous
    recipe.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将继续使用前一个菜谱中的`my_hostel`模块。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will add a delete button to the component. Upon clicking
    the delete button, the component gets removed. Perform the following steps to
    add a delete button and its event in the component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将向组件添加一个删除按钮。点击删除按钮后，组件将被移除。按照以下步骤添加删除按钮及其事件到组件中：
- en: 'Update the QWeb template and add an icon to remove the bar:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新QWeb模板并添加一个图标以删除栏：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To remove the component, add the `onRemove` method to the `MyComponent` class,
    as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除组件，请将`onRemove`方法添加到`MyComponent`类中，如下所示：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update the module to apply the changes. Following the update, you will see
    a little cross icon on the right side of the bar, as in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模块以应用更改。更新后，您将在栏的右侧看到一个小十字图标，如下面的截图所示：
- en: '![Figure 16.2 – The remove button on the top bar component](img/B20997_16_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2 – 顶部栏组件上的删除按钮](img/B20997_16_02.jpg)'
- en: Figure 16.2 – The remove button on the top bar component
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 顶部栏组件上的删除按钮
- en: Upon clicking the remove icon, our OWL component will be removed. The bar will
    reappear when you reload the page.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 点击删除图标后，我们的OWL组件将被移除。当您重新加载页面时，栏将重新出现。
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In *step 1*, we added a remove icon to the component. We have added a `t-on-click`
    attribute. This will be used to bind a click event. The value of the attribute
    will be the method in the component. In our example, we have used `t-on-click="onRemove"`.
    This implies that when the user clicks on the remove icon, the `onRemove` method
    in the component will be called. The syntax to define the event is simple:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们向组件添加了一个删除图标。我们添加了`t-on-click`属性。这将用于绑定点击事件。属性的值将是组件中的方法。在我们的例子中，我们使用了`t-on-click="onRemove"`。这意味着当用户点击删除图标时，组件中的`onRemove`方法将被调用。定义事件的语法很简单：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For example, if you want to call the method when the user moves the mouse over
    the component, you can do so by adding the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想在用户将鼠标移至组件上时调用方法，您可以通过添加以下代码来实现：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After adding the preceding code, whenever the user moves the mouse cursor over
    the component, OWL will call the `onMouseover` method specified in the component.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 添加前面的代码后，每当用户将鼠标光标移至组件上时，OWL将调用组件中指定的`onMouseover`方法。
- en: In *step 2*, we have added the `onRemove` method. This method will be called
    when the user clicks on the remove icon. In the method, we have called the `remove()`
    method, which will remove the component from the DOM. We will be seeing several
    default methods in the upcoming recipes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们添加了`onRemove`方法。当用户点击删除图标时，此方法将被调用。在方法中，我们调用了`remove()`方法，这将从DOM中删除组件。在接下来的菜谱中，我们将看到几个默认方法。
- en: There’s more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Event handling is not limited to the DOM events. You can use your custom events
    as well. For instance, if you are manually triggering the event called `my-custom-event`,
    you can use `t-on-my-custom-event` to catch custom-triggered events.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理不仅限于DOM事件。您还可以使用您自定义的事件。例如，如果您手动触发名为`my-custom-event`的事件，您可以使用`t-on-my-custom-event`来捕获自定义触发的事件。
- en: Making OWL components with hooks
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用钩子制作OWL组件
- en: OWL is a powerful framework and supports automatic updates for the UI based
    on **hooks**. With update hooks, a component’s UI will be automatically updated
    when the internal state of the component is changed. In this recipe, we will update
    the message in the component based on user actions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: OWL 是一个强大的框架，支持基于 **钩子** 的 UI 自动更新。使用更新钩子，当组件的内部状态发生变化时，组件的 UI 将自动更新。在这个菜谱中，我们将根据用户操作更新组件中的消息。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will continue using the `my_hostel` module from the previous
    recipe.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将继续使用上一个菜谱中的 `my_hostel` 模块。
- en: How to do it…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we will add arrows around the text in the component. When we
    click on the arrow, we will change the message. Follow these steps to make the
    OWL component reactive:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将在组件中的文本周围添加箭头。当我们点击箭头时，我们将更改消息。按照以下步骤使 OWL 组件具有响应性：
- en: 'Update the XML template of the component. Add two buttons with an event directive
    around the text. Also, retrieve the message dynamically from the list:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新组件的 XML 模板。在文本周围添加两个带有事件指令的按钮。同时，从列表中动态检索消息：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the JavaScript file of the component, import the `useState` hook as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的 JavaScript 文件中，按照以下方式导入 `useState` 钩子：
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the `setup` method to the component and initialize some variables as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `setup` 方法添加到组件中，并初始化一些变量如下：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `Component` class, add methods to handle the user’s click event:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Component` 类中，添加处理用户点击事件的函数：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Restart and update the module to apply the changes to the module. Following
    the update, you will see the two arrow icons around the text like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动并更新模块以将更改应用到模块。更新后，你将看到文本周围的两个箭头图标，如下所示：
- en: '![Figure 16.3 – Arrows around the text](img/B20997_16_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.3 – 文本周围的箭头](img/B20997_16_03.jpg)'
- en: Figure 16.3 – Arrows around the text
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 – 文本周围的箭头
- en: If you click on the arrow, the message text will be changed based on the list
    of messages in the constructor.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击箭头，消息文本将根据构造函数中的消息列表进行更改。
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, we updated the XML template of our component. Basically, we made
    two changes to the template. We rendered the text message from the list of messages,
    and we selected the message based on the value of `currentIndex` in the state
    variable. We added two arrow icons around the text block. In the arrow icons,
    we added `the t-on-click` attribute to bind the click event to the arrow.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们更新了组件的 XML 模板。基本上，我们对模板进行了两项更改。我们渲染了消息列表中的文本消息，并根据状态变量中的 `currentIndex`
    值选择消息。我们在文本块周围添加了两个箭头图标。在箭头图标中，我们添加了 `the t-on-click` 属性来绑定点击事件到箭头。
- en: In *step 2*, we imported the `useState` hook from OWL. This hook is used to
    handle the state of the component.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们从 OWL 导入了 `useState` 钩子。此钩子用于处理组件的状态。
- en: In *step 3*, we added a `setup`. This will be called when you create an instance
    of the object. In the `setup`, we added a list of messages that we want to show,
    and then we added the `state` variable using the `useState` hook. This will make
    the component reactive. When the `state` is `changed`, the `UI` will be updated
    based on the new state. In our example, we used `currentIndex` in the `useState`
    hook. This implies that whenever the value of `currentIndex` changes, the UI will
    be updated as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们添加了一个 `setup`。这将在你创建对象实例时被调用。在 `setup` 中，我们添加了我们想要显示的消息列表，然后使用
    `useState` 钩子添加了 `state` 变量。这将使组件具有响应性。当 `state` 发生变化时，`UI` 将根据新的状态进行更新。在我们的例子中，我们使用了
    `useState` 钩子中的 `currentIndex`。这意味着每当 `currentIndex` 的值发生变化时，UI 也会更新。
- en: Important information
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: 'There is only one rule for defining hooks, which is that the hooks will only
    work if you have declared them in `setup`. Several other types of hooks are available,
    which you can find here: [https://github.com/odoo/owl/blob/master/doc/reference/hooks.md](https://github.com/odoo/owl/blob/master/doc/reference/hooks.md).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 定义钩子只有一个规则，即钩子只有在你在 `setup` 中声明它们时才会工作。还有其他几种类型的钩子可供使用，你可以在以下位置找到它们：[https://github.com/odoo/owl/blob/master/doc/reference/hooks.md](https://github.com/odoo/owl/blob/master/doc/reference/hooks.md)。
- en: In *step 4*, we added methods to handle the click events of the arrow. Upon
    clicking the arrow, we are changing the state of the component. As we are using
    a hook on the state, the UI of the component will be automatically updated.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 中，我们添加了处理箭头点击事件的函数。点击箭头时，我们正在更改组件的状态。由于我们正在使用状态上的钩子，组件的 UI 将自动更新。
- en: Understanding the OWL component life cycle
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 OWL 组件的生命周期
- en: 'OWL components have several methods that help developers to create powerful
    and interactive components. Some of the important methods of the OWL components
    are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: OWL组件有几个方法可以帮助开发者创建强大且交互式的组件。OWL组件的一些重要方法如下：
- en: '`setup()`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup()`'
- en: '`onWillStart()`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onWillStart()`'
- en: '`onWillRender()`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onWillRender()`'
- en: '`onRendered()`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRendered()`'
- en: '`onMounted()`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMounted()`'
- en: '`onWillUpdateProps()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onWillUpdateProps()`'
- en: '`onWillPatch()`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onWillPatch()`'
- en: '`onPatched()`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPatched()`'
- en: '`onMounted()`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMounted()`'
- en: '`onWillUnmount()`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onWillUnmount()`'
- en: '`onWillDestroy()`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onWillDestroy()`'
- en: '`onError()`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError()`'
- en: In this recipe, we will log the message in the console to help us understand
    the life cycle of the OWL component.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将记录控制台中的消息，以帮助我们理解OWL组件的生命周期。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will continue using the `my_hostel` module from the previous
    recipe.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将继续使用前一个菜谱中的`my_hostel`模块。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To add methods of the component to show the life cycle of an OWL component,
    you need to carry out the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要将组件的方法添加以显示OWL组件的生命周期，您需要执行以下步骤：
- en: 'First, you need to import the `all` hook, as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要导入`all`钩子，如下所示：
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we already have `setup` in the component, let’s add a message to the console
    like this:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经在组件中有了`setup`，让我们向控制台添加如下消息：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the `willStart` method to the component:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`willStart`方法添加到组件中：
- en: '[PRE15]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the `willrender` method to the component:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`willrender`方法添加到组件中：
- en: '[PRE16]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the `render` method to the component:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`render`方法添加到组件中：
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the `mounted` method to the component:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`mounted`方法添加到组件中：
- en: '[PRE18]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the `willUpdateProps` method to the component:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`willUpdateProps`方法添加到组件中：
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the `willPatch` method to the component:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`willPatch`方法添加到组件中：
- en: '[PRE20]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the `patched` method to the component:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`patched`方法添加到组件中：
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the `willUnmount` method to the component:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`willUnmount`方法添加到组件中：
- en: '[PRE22]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the `willDestroy` method to the component:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`willDestroy`方法添加到组件中：
- en: '[PRE23]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the `Error` method to the component:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Error`方法添加到组件中：
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Restart and update the module to apply the module changes. Following the update,
    perform some operations, such as changing the message via arrows and removing
    the component. In the browser console, you will see the logs like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动并更新模块以应用模块更改。更新后，执行一些操作，例如通过箭头更改消息和删除组件。在浏览器控制台中，您将看到如下日志：
- en: '![Figure 16.4 – Logs in the browser console](img/B20997_16_04.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4 – 浏览器控制台中的日志](img/B20997_16_04.jpg)'
- en: Figure 16.4 – Logs in the browser console
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 – 浏览器控制台中的日志
- en: You may have different logs based on the operation you have performed on the
    component.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会根据对组件执行的操作看到不同的日志。
- en: How it works…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we have added several methods and added logged messages to the
    method. You can use these methods based on your requirements. Let’s see the life
    cycle of the component and when these methods are called.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们添加了几个方法，并将日志消息添加到方法中。您可以根据需求使用这些方法。让我们看看组件的生命周期以及这些方法何时被调用。
- en: setup
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setup
- en: '`setup` is run just after the component is constructed. It is a life cycle
    method that’s very similar to the `constructor`, except that it does not receive
    any arguments.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup`在组件构建后立即运行。它是一个与`constructor`非常相似的生命周期方法，不同之处在于它不接收任何参数。'
- en: It is the proper place to call hook functions. Note that one of the main reasons
    to have the setup hook in the component lifecycle is to make it possible to **monkey
    patch** it. It is a common need in the Odoo ecosystem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用钩子函数的正确位置。请注意，在组件生命周期中设置setup钩子的主要原因是使其能够**猴子补丁**。这是Odoo生态系统中的一种常见需求。
- en: willStart
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: willStart
- en: '`willStart` is an asynchronous hook that can be implemented to perform some
    (most of the time asynchronous) action before the initial rendering of a component.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`willStart`是一个异步钩子，可以用来在组件的初始渲染之前执行一些（大多数情况下是异步的）操作。'
- en: It will be called exactly once before the initial rendering. It is useful in
    some cases, for example, to load external assets (such as a JavaScript library)
    before the component is rendered. Another use case is to load data from a server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在初始渲染之前恰好被调用一次。在某些情况下很有用，例如，在组件渲染之前加载外部资源（如JavaScript库）。另一个用例是从服务器加载数据。
- en: 'The `onWillStart` hook is used to register a function that will be executed:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`onWillStart`钩子用于注册一个将被执行的函数：'
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: willRender
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: willRender
- en: It is uncommon, but you may need to execute code just before a component is
    rendered (more precisely, when its compiled template function is executed). To
    do that, we can use the `onWillRender` hook.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不常见，但您可能需要在组件渲染之前执行代码（更精确地说，当其编译的模板函数执行时）。为此，我们可以使用 `onWillRender` 钩子。
- en: '`willRender` hooks are called just before rendering templates, parent first,
    then children.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`willRender` 钩子在渲染模板之前被调用，首先是父组件，然后是子组件。'
- en: rendered
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rendered
- en: Similarly, it is uncommon, but you may need to execute code just after a component
    is rendered (more precisely, when its compiled template function is executed).
    To do that, we can use the `onRendered` hook.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，虽然不常见，但您可能需要在组件渲染后立即执行代码（更精确地说，当其编译的模板函数执行时）。为此，我们可以使用 `onRendered` 钩子。
- en: '`rendered` hooks are called just after rendering templates, parent first, then
    children. Note that at this moment, the actual DOM may not exist yet (if it is
    the first rendering), or is not updated yet. This will be done in the next animation
    frame, as soon as all the components are ready.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`rendered` 钩子在模板渲染后立即被调用，首先是父组件，然后是子组件。请注意，在这个时候，实际的 DOM 可能还不存在（如果是第一次渲染），或者尚未更新。这将在下一个动画帧中完成，一旦所有组件都准备就绪。'
- en: mounted
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mounted
- en: The `mounted` hook is called each time a component is attached to the DOM, after
    the initial rendering. At this point, the component is considered active. This
    is a good place to add some listeners, or to interact with the DOM, if the component
    needs to perform some measure for example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`mounted` 钩子每次组件被附加到 DOM 上，在初始渲染之后被调用。此时，组件被认为是活动的。这是一个添加监听器或与 DOM 交互的好地方，如果组件需要执行某些测量操作的话。'
- en: It is the opposite of `willUnmount`. If a component has been mounted, it will
    always be unmounted at some point in the future.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它是 `willUnmount` 的对立面。如果一个组件已经被挂载，它将在未来的某个时刻被卸载。
- en: The `mounted` method will be called recursively on each of its children. First
    children, then parents.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`mounted` 方法将在其每个子组件上递归调用。首先是子组件，然后是父组件。'
- en: It is allowed (but not encouraged) to modify the state in the mounted hook.
    Doing so will cause a rerender, which will not be perceptible by the user, but
    will slightly slow down the component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载钩子中修改状态是被允许的（但不鼓励）。这样做将导致重新渲染，用户可能不会察觉，但会稍微减慢组件的运行速度。
- en: The `onMounted` hook is used to register a function that will be executed at
    this moment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMounted` 钩子用于注册一个将在此时执行的功能。'
- en: willUpdateProps
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: willUpdateProps
- en: '`willUpdateProps` is an asynchronous hook that is called just before new props
    are set. This is useful if the component needs to perform an asynchronous task,
    depending on the props (for example, assuming that the props are some record ID,
    fetching the record data).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`willUpdateProps` 是一个在设置新属性之前被调用的异步钩子。如果组件需要根据属性执行异步任务（例如，假设属性是一些记录 ID，获取记录数据），这很有用。'
- en: The `onWillUpdateProps` hook is used to register a function that will be executed
    at this moment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`onWillUpdateProps` 钩子用于注册一个将在此时执行的功能。'
- en: Notice that it receives the next props for the component.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它接收组件的下一个属性。
- en: 'This hook is not called during the first render (but `willStart` is called
    and performs a similar job). Also, like most hooks, it is called in the usual
    order: parents first, then children.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子在第一次渲染期间不会被调用（但会调用 `willStart` 并执行类似的工作）。同样，像大多数钩子一样，它按照常规顺序调用：首先是父组件，然后是子组件。
- en: willPatch
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: willPatch
- en: The `willPatch` hook is called just before the DOM patching process starts.
    It is not called on the initial render. This is useful to read information from
    the DOM, such as the current position of the scrollbar.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`willPatch` 钩子在 DOM 补丁过程开始之前被调用。在初始渲染时不会调用。这有助于从 DOM 中读取信息，例如滚动条当前的位置。'
- en: Note that modifying the state is not allowed here. This method is called just
    before an actual DOM patch, and is only intended to be used to save some local
    DOM state. Also, it will not be called if the component is not in the DOM.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里不允许修改状态。此方法在真正的 DOM 补丁之前被调用，并且仅用于保存一些本地 DOM 状态。此外，如果组件不在 DOM 中，则不会调用。
- en: The `onWillPatch` hook is used to register a function that will be executed
    at this moment. `willPatch` is called in the usual parent/children order.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`onWillPatch` 钩子用于注册一个将在此时执行的功能。`willPatch` 按照常规的父/子顺序调用。'
- en: patched
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: patched
- en: This hook is called whenever a component actually updates its DOM (most likely
    via a change in its state/props or environment).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件实际上更新其 DOM 时（最可能通过其状态/属性或环境的变化），会调用此钩子。
- en: This method is not called on the initial render. It is useful to interact with
    the DOM (for example, through an external library) whenever the component is patched.
    Note that this hook will not be called if the component is not in the DOM.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在初始渲染时不会被调用。当组件被修补时，它用于与 DOM（例如，通过外部库）进行交互。请注意，如果组件不在 DOM 中，则此钩子不会被调用。
- en: The `onPatched` hook is used to register a function that will be executed at
    this moment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`onPatched` 钩子用于注册一个将在此时执行的功能。'
- en: Updating the component state in this hook is possible, but not recommended.
    We need to be careful because updates here will create additional rendering, which
    in turn will cause other calls to the `patched` method. So, we need to be particularly
    careful to prevent endless cycles.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此钩子中更新组件状态是可能的，但并不推荐。我们需要小心，因为这里的更新将创建额外的渲染，这反过来又会引起对 `patched` 方法的其他调用。因此，我们需要特别小心，以防止无限循环。
- en: 'Like `mounted`, the `patched` hook is called in the order: children first,
    then parent.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `mounted` 一样，`patched` 钩子的调用顺序是：先子组件，然后是父组件。
- en: willUnmount
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: willUnmount
- en: '`willUnmount` is a hook that is called just before a component is unmounted
    from the DOM. This is a good place to remove listeners, for example.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`willUnmount` 是在组件从 DOM 中卸载之前被调用的钩子。这是一个移除监听器的好地方，例如。'
- en: The `onWillUnmount` hook is used to register a function that will be executed
    at this moment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`onWillUnmount` 钩子用于注册一个将在此时执行的功能。'
- en: This is the opposite method of `mounted`. Note that if a component is destroyed
    before being mounted, the `willUnmount` method may not be called.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `mounted` 方法的相反方法。请注意，如果一个组件在挂载之前被销毁，则 `willUnmount` 方法可能不会被调用。
- en: Parent `willUnmount` hooks will be called before children.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 父 `willUnmount` 钩子将在子组件之前被调用。
- en: willDestroy
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: willDestroy
- en: Sometimes, components need to do some action in the setup and clean it up when
    they are inactive. However, the `willUnmount` hook is not appropriate for the
    cleaning operation, since the component may be destroyed before it has even been
    mounted. The `willDestroy` hook is useful in this situation since it is always
    called.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，组件需要在设置时执行某些操作，并在它们不活跃时清理它们。然而，`willUnmount` 钩子不适合清理操作，因为组件可能在挂载之前就被销毁了。在这种情况下，`willDestroy`
    钩子非常有用，因为它总是会被调用。
- en: The `onWillUnmount` hook is used to register a function that will be executed
    at this moment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`onWillUnmount` 钩子用于注册一个将在此时执行的功能。'
- en: '`willDestroy` hooks are first called on children, then on parents.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`willDestroy` 钩子首先在子组件上被调用，然后是在父组件上。'
- en: onError
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onError
- en: Sadly, components may crash at runtime. This is an unfortunate reality, and
    this is why OWL needs to provide a way to handle these errors.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，组件可能在运行时崩溃。这是一个不幸的现实，这也是为什么 OWL 需要提供一种处理这些错误的方法。
- en: The `onError` hook is useful when we need to intercept and properly react to
    errors that occur in some sub-components.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要拦截并适当地对某些子组件中发生的错误做出反应时，`onError` 钩子非常有用。
- en: There’s more…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There is one more method in the component life cycle, but it is used when you
    are using subcomponents. OWL passes the parent component state via the `props`
    parameter, and when `props` is changed, the `willUpdateProps` method is called.
    This is an asynchronous method, which means you can perform an asynchronous operation
    such as RPC here.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 组件生命周期中还有一个方法，但它在使用子组件时使用。OWL 通过 `props` 参数传递父组件状态，当 `props` 发生变化时，会调用 `willUpdateProps`
    方法。这是一个异步方法，这意味着你可以在其中执行异步操作，例如 RPC。
- en: Adding an OWL field to the form view
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 OWL 字段添加到表单视图中
- en: Up to this point, we have learned about all the basics of OWL. Now we will move
    on to more advanced aspects and create a field widget that can be used in the
    form view, just like the field widget recipe from the previous chapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了 OWL 的所有基础知识。现在我们将继续学习更高级的方面，并创建一个可以在表单视图中使用的字段小部件，就像前一章中的字段小部件配方一样。
- en: Odoo has many widgets in the UI for different functionalities, such as a status
    bar, checkboxes, and radio buttons. which makes the operations in Odoo simpler
    and run with ease. For example, we used `widget='image'` to display a binary field
    as an image. To demonstrate how to create your own widget, we’ll write one widget
    that lets the user choose an integer field, but we will display it differently.
    Instead of an input box, we will display a color picker so that we can select
    a color number. Here, each number will be mapped to a color.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo在UI中为不同的功能提供了许多小部件，例如状态栏、复选框和单选按钮，这使得Odoo中的操作更加简单，运行更加顺畅。例如，我们使用`widget='image'`来显示二进制字段作为图像。为了演示如何创建自己的小部件，我们将编写一个小部件，允许用户选择一个整数字段，但我们将以不同的方式显示它。而不是输入框，我们将显示一个颜色选择器，以便我们可以选择一个颜色编号。在这里，每个数字都将映射到一个颜色。
- en: In this recipe, we will create a color picker widget that will save integer
    values based on the color selected.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个颜色选择器小部件，它将根据所选颜色保存整数值。
- en: To make the example more informative, we will use some advanced concepts of
    OWL.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例更具信息性，我们将使用一些OWL的高级概念。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will be using the `my_hostel` module.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用`my_hostel`模块。
- en: How to do it…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We’ll add a JavaScript file that contains our widget’s logic, an XML file that
    contains design logic, and an SCSS file to do some styling. Then, we will add
    one integer field to the books form to use our new widget.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个包含我们小部件逻辑的JavaScript文件，一个包含设计逻辑的XML文件，以及一个用于一些样式的SCSS文件。然后，我们将向图书表单添加一个整数字段以使用我们新的小部件。
- en: 'Perform the following steps to add a new field widget:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以添加新的字段小部件：
- en: 'Add the category integer field to the `hostel.room` model as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式将整数字段类别添加到`hostel.room`模型中：
- en: '[PRE26]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the same field to the form view, with a `widget` attribute as well:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相同的字段添加到表单视图，并添加一个`widget`属性：
- en: '[PRE27]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the QWeb templates for the field at `static/src/xml/field_widget.xml`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`static/src/xml/field_widget.xml`中添加字段的QWeb模板：
- en: '[PRE28]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'List the QWeb file in the module’s `manifest` file:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块的`manifest`文件中列出QWeb文件：
- en: '[PRE29]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we want to add some SCSS for the field at `static/src/scss/field_widget.scss`.
    As the content of SCSS is too long, please find the content of the SCSS file in
    this book’s GitHub repository at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/05_owl_field/my_hostel/static/src/scss](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/05_owl_field/my_hostel/static/src/scss).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想在`static/src/scss/field_widget.scss`中添加一些SCSS。由于SCSS的内容太长，请在此书的GitHub仓库中找到SCSS文件的内容：[https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/05_owl_field/my_hostel/static/src/scss](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/05_owl_field/my_hostel/static/src/scss)。
- en: 'Add the static `/src/js/field_widget.js` JavaScript file with the following
    basic content:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下基本内容的静态`/src/js/field_widget.js` JavaScript文件：
- en: '[PRE30]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add JavaScript and an SCSS file to the backend assets as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式将JavaScript和SCSS文件添加到后端资源中：
- en: '[PRE31]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Restart and update the module to apply the module changes. Open the room form
    view. You will be able to see the color picker widget, as shown in the following
    screenshot:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动并更新模块以应用模块更改。打开房间表单视图。您将能够看到颜色选择器小部件，如下面的截图所示：
- en: '![Figure 16.5 – Color picker OWL widget](img/B20997_16_05.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5 – 颜色选择器OWL小部件](img/B20997_16_05.jpg)'
- en: Figure 16.5 – Color picker OWL widget
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 – 颜色选择器OWL小部件
- en: This field looks just like the color widget from the last chapter, but the actual
    difference lies under the hood. This new field is built with OWL components and
    subcomponents, while the previous one was built with widgets.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个字段看起来就像上一章中的颜色小部件，但实际上差异在于底层。这个新字段是用OWL组件和子组件构建的，而之前的那个是用小部件构建的。
- en: The benefit of this subcomponent is to provide a comprehensive framework for
    building modern, responsive, and interactive UIs in OWL. By modularizing functionality
    into small, reusable units, developers can create more maintainable and extensible
    applications while reducing code duplication and improving development efficiency.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个子组件的好处是提供了一个全面的框架，用于在OWL中构建现代、响应式和交互式UI。通过将功能模块化成小的、可重用的单元，开发者可以创建更易于维护和扩展的应用程序，同时减少代码重复并提高开发效率。
- en: How it works…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, we added an integer field to the `hostel.room` model.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们将一个整数字段添加到`hostel.room`模型中。
- en: In *step 2*, we added the field to the form view of the room.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们将字段添加到房间的表单视图中。
- en: In *step 3*, we added the QWeb template file. If you notice, we added two templates
    to the file, one for the color pill and the other for the field itself. We used
    two templates because we want to see the concept of the `subcomponent`. If you
    observe the template closely, you will find that we have used the `<ColorPill>`
    tag. This will be used to instantiate the subcomponent. On the `<ColorPill>` tag,
    we have passed the active and color attributes. These attributes will be received
    as `props` in the template of the subcomponent. Also note that the `onClickColorUpdated`
    attribute is used to listen to the custom event triggered from the subcomponent.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 步* 中，我们添加了 QWeb 模板文件。如果你注意到，我们在文件中添加了两个模板，一个用于颜色药丸，另一个用于字段本身。我们使用两个模板是因为我们想看到
    `subcomponent` 的概念。如果你仔细观察模板，你会发现我们使用了 `<ColorPill>` 标签。这将用于实例化子组件。在 `<ColorPill>`
    标签上，我们传递了 active 和 color 属性。这些属性将在子组件的模板中作为 `props` 接收。还要注意，`onClickColorUpdated`
    属性用于监听从子组件触发的自定义事件。
- en: Important information
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Odoo v17 uses both the widget system and the OWL framework.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo v17 使用了小部件系统和 OWL 框架。
- en: In *step 4*, we listed our QWeb template in the manifest. This will automatically
    load our template in the browser.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 步* 中，我们在清单中列出了我们的 QWeb 模板。这将自动在浏览器中加载我们的模板。
- en: In *step 5*, we added SCSS for the color. This will help us to have a beautiful
    UI for the color picker.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 5 步* 中，我们为颜色添加了 SCSS。这将帮助我们拥有一个漂亮的颜色选择器 UI。
- en: In *step 6*, we added JavaScript for the field component.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 6 步* 中，我们为字段组件添加了 JavaScript。
- en: We imported the OWL utility and we also imported the component and `fieldRegistry`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了 OWL 工具，同时也导入了组件和 `fieldRegistry`。
- en: '`fieldRegistry` is used to list the OWL component as a field component.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`fieldRegistry` 用于将 OWL 组件列为字段组件。'
- en: In *step 7*, we created the `ColorPill` component. The `template` variable on
    the component is the name of the template that is loaded from the external XML
    file. The `ColorPill` component has the `pillClicked` method, which is called
    when the user clicks on the color pill. Inside the method body, we have triggered
    the `onClickColorUpdated` event, which will be captured by the parent `OWLCategColorField`
    component as we used `colorUpdated` on the `OWLCategColorField` component.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 7 步* 中，我们创建了 `ColorPill` 组件。组件上的 `template` 变量是加载自外部 XML 文件的模板名称。`ColorPill`
    组件具有 `pillClicked` 方法，当用户点击颜色药丸时会被调用。在方法体内，我们触发了 `onClickColorUpdated` 事件，该事件将被我们使用
    `colorUpdated` 在 `OWLCategColorField` 组件上设置的父 `OWLCategColorField` 组件捕获。
- en: In *step 8* and *step 9*, we created the `OWLCategColorField` component by extending
    `Component`. We used the `Component` because it will have all the utilities that
    are required to create the field widget.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 8 步* 和 *第 9 步* 中，我们通过扩展 `Component` 创建了 `OWLCategColorField` 组件。我们使用 `Component`
    是因为它将包含创建字段小部件所需的所有实用工具。
- en: If you notice, we used the `components` static variable at the start. You need
    to list the components via the `components` static variable when you are using
    subcomponents in the template. We also added the `onWillStart` method in our example.
    The `willStart` method is an asynchronous method, so we have called RPC (network
    call) to fetch data regarding the number of the room booked for a particular color.
    Toward the end, we added the `colorUpdated` method, which will be called when
    the user clicks on the pill. So, we are changing the values of the field. The
    `this.props.record.update` method is used to set the field values (which will
    be saved in the database). Note here that the data triggered from the child component
    is available under the `detail` attribute in the `event` parameter. Finally, we
    registered our widget in `fieldRegistry`, implying that henceforth, we will be
    able to use our field via the `widget` attribute in the form view.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，我们在开始时使用了 `components` 静态变量。当你使用模板中的子组件时，你需要通过 `components` 静态变量列出组件。我们还在我们的示例中添加了
    `onWillStart` 方法。`willStart` 方法是一个异步方法，所以我们调用了 RPC（网络调用）来获取有关特定颜色预订房间数量的数据。在最后，我们添加了
    `colorUpdated` 方法，当用户点击药丸时会被调用。因此，我们正在更改字段值。`this.props.record.update` 方法用于设置字段值（这些值将保存在数据库中）。注意，从子组件触发的数据在
    `event` 参数的 `detail` 属性下可用。最后，我们在 `fieldRegistry` 中注册了我们的小部件，这意味着从此以后，我们将通过表单视图中的
    `widget` 属性使用我们的字段。
- en: In *step 10*, we loaded JavaScript and SCSS files into the backend assets.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 10 步* 中，我们将 JavaScript 和 SCSS 文件加载到后端资源中。
- en: There’s more…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Understanding QWeb
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 QWeb
- en: '`t-`, for instance, `t-if` for conditionals, with elements and other attributes
    being rendered directly. The following are the different operations of the QWeb
    template:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`t-`，比如 `t-if` 用于条件，元素和其他属性将被直接渲染。以下 QWeb 模板的不同操作：
- en: '`out`, will automatically HTML-escape its input, limiting XSS risks when displaying
    user-provided content. `out` takes an expression, evaluates it, and injects the
    result into the document:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out` 将自动对输入进行 HTML 转义，限制显示用户提供的内时 XSS 风险。`out` 接受一个表达式，评估它，并将结果注入到文档中：'
- en: '[PRE32]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`set` directive, which takes the name of the variable to create. The value
    of `set` can be provided in two ways:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set` 指令，它接受要创建的变量的名称。`set` 的值可以以两种方式提供：'
- en: 'A `t-value` attribute containing an expression, and the result of its evaluation
    will be set:'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含表达式的 `t-value` 属性，其评估结果将被设置：
- en: '[PRE33]'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`if`, which evaluates an expression given as an attribute value:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`，它评估作为属性值给出的表达式：'
- en: '[PRE34]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The element is rendered if the condition is `true`:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果条件为 `true`，则渲染该元素：
- en: '[PRE35]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'But if the condition is `false`, it is removed from the result:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但如果条件为 `false`，它将从结果中移除：
- en: '[PRE36]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Extra conditional branching directives, `t-elif` and `t-else`, are also available:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 额外的条件分支指令，`t-elif` 和 `t-else`，也都可以使用：
- en: '[PRE37]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`foreach`, which takes an expression that returns the collection to iterate
    on, and a second parameter, `t-as`, providing the name to use for the current
    item of the iteration:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foreach`，它接受一个返回要迭代的集合的表达式，以及第二个参数 `t-as`，提供迭代当前项的名称：'
- en: '[PRE38]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will be rendered as follows:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将呈现如下：
- en: '[PRE39]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`t-att` (attribute) directive, which exists in three different forms:'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t-att`（属性）指令，它存在三种不同的形式：'
- en: '[PRE40]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will be rendered as follows:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将呈现如下：
- en: '[PRE41]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: < li class="row even">1</li>
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<li class="row even">1</li>`'
- en: <li class="row odd">2</li>
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<li class="row odd">2</li>`'
- en: <li class="row even">3</li>
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<li class="row even">3</li>`'
- en: t-att=mapping
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t-att=mapping
- en: '<div t-att="{''a'': 1, ''b'': 2}"/>'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<div t-att="{''a'': 1, ''b'': 2}"/>`'
- en: '[PRE42]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <div a="1" b="2"></div>
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<div a="1" b="2"></div>`'
- en: t-att=pair
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t-att=pair
- en: <div t-att="['a', 'b']"/>
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<div t-att="[''a'', ''b'']"/>`'
- en: '[PRE43]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <div a="b">
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<div a="b">`'
- en: </div>
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE44]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`t-call` directive:'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t-call` 指令：'
- en: '[PRE45]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding call will be rendered as `<p/> (``no content)`.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的调用将呈现为 `<p/> (无内容)`。
- en: '[PRE46]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <div>
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<div>`'
- en: 'This template was called with content:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个模板被调用时包含以下内容：
- en: <t t-out="0"/>
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<t t-out="0"/>`'
- en: </div>
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </div>
- en: 'This will result in the following:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致以下结果：
- en: '[PRE47]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Understanding subcomponents
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解子组件
- en: In the context of OWL, subcomponents refer to small, modular units of functionality
    that can be integrated into larger components to enhance their capabilities or
    provide additional features.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OWL 的上下文中，子组件指的是可以集成到更大组件中以增强其功能或提供额外功能的小型、模块化功能单元。
- en: Subcomponents in OWL can include various elements, such as widgets, utilities,
    services, and views, which are designed to work together within the OWL framework
    to create rich, interactive UIs and manage client-side logic efficiently.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: OWL 中的子组件可以包括各种元素，如小部件、实用工具、服务和视图，这些元素被设计成在 OWL 框架内协同工作，以创建丰富、交互式的 UI 并有效地管理客户端逻辑。
- en: These subcomponents work together to provide a comprehensive framework for building
    modern, responsive, and interactive UIs in OWL. By modularizing functionality
    into small, reusable units, developers can create more maintainable and extensible
    applications while reducing code duplication and improving development efficiency.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子组件协同工作，为在 OWL 中构建现代、响应式和交互式 UI 提供了一个全面的框架。通过将功能模块化成小型、可重用的单元，开发者可以创建更易于维护和扩展的应用程序，同时减少代码重复并提高开发效率。
- en: 'It is convenient to define a component using other (sub) components. This is
    called composition and is very powerful in practice. To do that in OWL, we can
    just use a tag starting with a capital letter in its template, and register the
    subcomponent class in its static `component` object:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他（子）组件定义组件非常方便。这被称为组合，在实践中非常强大。在 OWL 中，我们只需在其模板中使用以大写字母开头的标签，并在其静态 `component`
    对象中注册子组件类：
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, `<Child>` has `subcomponent`. This example also shows how we can pass
    information from the parent component to the child component as props. In OWL,
    `props` (short for properties) is an object that contains every piece of data
    given to a component by its parent. Note that `props` is an object that only makes
    sense from the perspective of the child component.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<Child>` 有 `subcomponent`。这个例子也展示了我们如何将信息从父组件传递给子组件作为 props。在 OWL 中，`props`（简称属性）是一个包含所有由父组件提供给组件的数据的对象。请注意，`props`
    是一个只有从子组件的角度才有意义的对象。
- en: 'The `props` object is made of every attribute defined on the template, with
    the following exceptions: every attribute starting with `t-` is not a prop (they
    are QWeb directives).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`props` 对象由模板上定义的每个属性组成，但有以下例外：以 `t-` 开头的每个属性都不是属性（它们是 QWeb 指令）。'
- en: 'In the following example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `props` object contains the following keys:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`props` 对象包含以下键：'
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
