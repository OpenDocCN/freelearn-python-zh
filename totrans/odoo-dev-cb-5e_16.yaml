- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Odoo Web Library (OWL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Odoo V17 Javascript framework uses a custom component framework called **OWL**
    (short for **Odoo Web Library**). It is a declarative component system loosely
    inspired by **Vue** and **React**. **OWL** is a component-based UI framework and
    uses QWeb templates for structure. OWL is very fast compared to Odoo’s legacy
    widget system and introduces tons of new features, including **hooks**, **reactivity**,
    the **auto instantiation** of **subcomponents**, and more besides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to use an OWL component to generate interactive
    UI elements. We will start with a minimal OWL component and then we will learn
    about the component’s life cycle. Finally, we will create a new field widget for
    the form view. In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an OWL component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing user actions in an OWL component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making OWL components with hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the OWL component life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an OWL field to the form view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The following question may occur to you: why is Odoo not using some well-known
    JavaScript frameworks, such as React.js or Vue.js? Please check out the following
    link for more information: [https://github.com/odoo/owl/blob/master/doc/miscellaneous/comparison.md](https://github.com/odoo/owl/blob/master/doc/miscellaneous/comparison.md).'
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to [https://github.com/odoo/owl](https://github.com/odoo/owl)
    to learn more about the OWL framework.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OWL components are defined with ES6 classes. In this chapter, we will be using
    some ES6 syntax. Also, some ES6 syntaxes are not supported by old browsers, so
    make sure you are using the latest version of Chrome or Firefox. You will find
    the code for this chapter at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an OWL component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main building blocks of OWL are components and templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In OWL, every part of the UI is managed by a component: they hold the logic
    and define the templates that are used to render the user interface'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this recipe is to learn the basics of an OWL component. We will
    create a minimal OWL component and append it to the Odoo web client. In this recipe,
    we will create a component for a small horizontal bar with some text.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will be using the `my_hostel` module with basic fields and
    views. You will find the basic `my_hostel` module in the [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/00_initial_module/my_hostel](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/00_initial_module/my_hostel)
    directory in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add a small horizontal bar component to the Odoo web client. Follow
    these steps to add your first component to the Odoo web client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `my_hostel/static/src/js/component.js` JavaScript file and define the
    new module’s namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the component JavaScript to `assets`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the OWL utilities to the `component.js` file created in *step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the OWL component and its basic template to the `component.js` file created
    in *step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize and append the component to the web client. Add this to the `component.js`
    file added in *step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install/upgrade the `my_hostel` module to apply our changes. Once our module
    is loaded in Odoo, you will see the horizontal bar, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – OWL component](img/B20997_16_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – OWL component
  prefs: []
  type: TYPE_NORMAL
- en: This is just a simple component. Right now, it will not handle any user events
    and you cannot remove it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* and *step 2*, we added a JavaScript file and listed it in the backend
    assets. If you want to learn more about assets, refer to the *Static assets management*
    recipe in [*Chapter 14*](B20997_14.xhtml#_idTextAnchor734)*, CMS* *Website Development*.
  prefs: []
  type: TYPE_NORMAL
- en: In *step* *3*, we initialized a variable from OWL. All the utilities from OWL
    are available under a single global variable, `owl`. In our example, we pulled
    an OWL utility. we declared `Component`, `mount`, `xml` , `whenReady`. `Component`
    is the main class for the `OWL` component and, by extending it, we will create
    our own components.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4,* we created our component, `MyComponent`, by extending OWL’s `Component`
    class. For the sake of simplicity, we have just added the QWeb template to the
    definition of the `MyComponent` class. Here, as you may have noticed, we have
    used `` xml`…` `` to declare our template. This syntax is known as an inline template.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can load QWeb templates via separate files, which is usually the
    case. We will see examples of external QWeb templates in the upcoming recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Inline QWeb templates do not support translations or modifications via inheritance.
    So, always endeavor to load QWeb templates from a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we instantiated the `MyComponent` component and appended it to
    the body. The OWL component is an ES6 class, so you can create an object via the
    `new` keyword. Then you can use the `mount()` method to add the component to the
    page. If you notice, we have placed our code inside the `whenReady()` callback.
    This will ensure that all OWL functionality is properly loaded before we start
    using OWL components.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OWL is a separate library and is loaded in Odoo as an external JavaScript library.
    You can use OWL in your other projects, too. The OWL library is listed at [https://github.com/odoo/owl](https://github.com/odoo/owl).
    There is also an online playground available in case you just want to test OWL
    without setting it in your local machine. You can play with OWL at [https://odoo.github.io/owl/playground/](https://odoo.github.io/owl/playground/).
  prefs: []
  type: TYPE_NORMAL
- en: Managing user actions in an OWL component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make the UI interactive, components need to handle `user actions` such as
    `click`, `hover`, and `form submission`. In this recipe, we will add a button
    to our component, and we will handle a click event.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will continue using the `my_hostel` module from the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will add a delete button to the component. Upon clicking
    the delete button, the component gets removed. Perform the following steps to
    add a delete button and its event in the component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the QWeb template and add an icon to remove the bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To remove the component, add the `onRemove` method to the `MyComponent` class,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the module to apply the changes. Following the update, you will see
    a little cross icon on the right side of the bar, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – The remove button on the top bar component](img/B20997_16_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – The remove button on the top bar component
  prefs: []
  type: TYPE_NORMAL
- en: Upon clicking the remove icon, our OWL component will be removed. The bar will
    reappear when you reload the page.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *step 1*, we added a remove icon to the component. We have added a `t-on-click`
    attribute. This will be used to bind a click event. The value of the attribute
    will be the method in the component. In our example, we have used `t-on-click="onRemove"`.
    This implies that when the user clicks on the remove icon, the `onRemove` method
    in the component will be called. The syntax to define the event is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you want to call the method when the user moves the mouse over
    the component, you can do so by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After adding the preceding code, whenever the user moves the mouse cursor over
    the component, OWL will call the `onMouseover` method specified in the component.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we have added the `onRemove` method. This method will be called
    when the user clicks on the remove icon. In the method, we have called the `remove()`
    method, which will remove the component from the DOM. We will be seeing several
    default methods in the upcoming recipes.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event handling is not limited to the DOM events. You can use your custom events
    as well. For instance, if you are manually triggering the event called `my-custom-event`,
    you can use `t-on-my-custom-event` to catch custom-triggered events.
  prefs: []
  type: TYPE_NORMAL
- en: Making OWL components with hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OWL is a powerful framework and supports automatic updates for the UI based
    on **hooks**. With update hooks, a component’s UI will be automatically updated
    when the internal state of the component is changed. In this recipe, we will update
    the message in the component based on user actions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will continue using the `my_hostel` module from the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will add arrows around the text in the component. When we
    click on the arrow, we will change the message. Follow these steps to make the
    OWL component reactive:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the XML template of the component. Add two buttons with an event directive
    around the text. Also, retrieve the message dynamically from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the JavaScript file of the component, import the `useState` hook as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `setup` method to the component and initialize some variables as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Component` class, add methods to handle the user’s click event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart and update the module to apply the changes to the module. Following
    the update, you will see the two arrow icons around the text like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – Arrows around the text](img/B20997_16_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – Arrows around the text
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the arrow, the message text will be changed based on the list
    of messages in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we updated the XML template of our component. Basically, we made
    two changes to the template. We rendered the text message from the list of messages,
    and we selected the message based on the value of `currentIndex` in the state
    variable. We added two arrow icons around the text block. In the arrow icons,
    we added `the t-on-click` attribute to bind the click event to the arrow.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we imported the `useState` hook from OWL. This hook is used to
    handle the state of the component.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we added a `setup`. This will be called when you create an instance
    of the object. In the `setup`, we added a list of messages that we want to show,
    and then we added the `state` variable using the `useState` hook. This will make
    the component reactive. When the `state` is `changed`, the `UI` will be updated
    based on the new state. In our example, we used `currentIndex` in the `useState`
    hook. This implies that whenever the value of `currentIndex` changes, the UI will
    be updated as well.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one rule for defining hooks, which is that the hooks will only
    work if you have declared them in `setup`. Several other types of hooks are available,
    which you can find here: [https://github.com/odoo/owl/blob/master/doc/reference/hooks.md](https://github.com/odoo/owl/blob/master/doc/reference/hooks.md).'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we added methods to handle the click events of the arrow. Upon
    clicking the arrow, we are changing the state of the component. As we are using
    a hook on the state, the UI of the component will be automatically updated.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OWL component life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OWL components have several methods that help developers to create powerful
    and interactive components. Some of the important methods of the OWL components
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onWillStart()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onWillRender()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onRendered()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMounted()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onWillUpdateProps()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onWillPatch()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPatched()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMounted()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onWillUnmount()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onWillDestroy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will log the message in the console to help us understand
    the life cycle of the OWL component.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will continue using the `my_hostel` module from the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add methods of the component to show the life cycle of an OWL component,
    you need to carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to import the `all` hook, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we already have `setup` in the component, let’s add a message to the console
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `willStart` method to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `willrender` method to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `render` method to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `mounted` method to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `willUpdateProps` method to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `willPatch` method to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `patched` method to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `willUnmount` method to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `willDestroy` method to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `Error` method to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart and update the module to apply the module changes. Following the update,
    perform some operations, such as changing the message via arrows and removing
    the component. In the browser console, you will see the logs like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – Logs in the browser console](img/B20997_16_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – Logs in the browser console
  prefs: []
  type: TYPE_NORMAL
- en: You may have different logs based on the operation you have performed on the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have added several methods and added logged messages to the
    method. You can use these methods based on your requirements. Let’s see the life
    cycle of the component and when these methods are called.
  prefs: []
  type: TYPE_NORMAL
- en: setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`setup` is run just after the component is constructed. It is a life cycle
    method that’s very similar to the `constructor`, except that it does not receive
    any arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: It is the proper place to call hook functions. Note that one of the main reasons
    to have the setup hook in the component lifecycle is to make it possible to **monkey
    patch** it. It is a common need in the Odoo ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: willStart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`willStart` is an asynchronous hook that can be implemented to perform some
    (most of the time asynchronous) action before the initial rendering of a component.'
  prefs: []
  type: TYPE_NORMAL
- en: It will be called exactly once before the initial rendering. It is useful in
    some cases, for example, to load external assets (such as a JavaScript library)
    before the component is rendered. Another use case is to load data from a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onWillStart` hook is used to register a function that will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: willRender
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is uncommon, but you may need to execute code just before a component is
    rendered (more precisely, when its compiled template function is executed). To
    do that, we can use the `onWillRender` hook.
  prefs: []
  type: TYPE_NORMAL
- en: '`willRender` hooks are called just before rendering templates, parent first,
    then children.'
  prefs: []
  type: TYPE_NORMAL
- en: rendered
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly, it is uncommon, but you may need to execute code just after a component
    is rendered (more precisely, when its compiled template function is executed).
    To do that, we can use the `onRendered` hook.
  prefs: []
  type: TYPE_NORMAL
- en: '`rendered` hooks are called just after rendering templates, parent first, then
    children. Note that at this moment, the actual DOM may not exist yet (if it is
    the first rendering), or is not updated yet. This will be done in the next animation
    frame, as soon as all the components are ready.'
  prefs: []
  type: TYPE_NORMAL
- en: mounted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mounted` hook is called each time a component is attached to the DOM, after
    the initial rendering. At this point, the component is considered active. This
    is a good place to add some listeners, or to interact with the DOM, if the component
    needs to perform some measure for example.
  prefs: []
  type: TYPE_NORMAL
- en: It is the opposite of `willUnmount`. If a component has been mounted, it will
    always be unmounted at some point in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The `mounted` method will be called recursively on each of its children. First
    children, then parents.
  prefs: []
  type: TYPE_NORMAL
- en: It is allowed (but not encouraged) to modify the state in the mounted hook.
    Doing so will cause a rerender, which will not be perceptible by the user, but
    will slightly slow down the component.
  prefs: []
  type: TYPE_NORMAL
- en: The `onMounted` hook is used to register a function that will be executed at
    this moment.
  prefs: []
  type: TYPE_NORMAL
- en: willUpdateProps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`willUpdateProps` is an asynchronous hook that is called just before new props
    are set. This is useful if the component needs to perform an asynchronous task,
    depending on the props (for example, assuming that the props are some record ID,
    fetching the record data).'
  prefs: []
  type: TYPE_NORMAL
- en: The `onWillUpdateProps` hook is used to register a function that will be executed
    at this moment.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that it receives the next props for the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This hook is not called during the first render (but `willStart` is called
    and performs a similar job). Also, like most hooks, it is called in the usual
    order: parents first, then children.'
  prefs: []
  type: TYPE_NORMAL
- en: willPatch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `willPatch` hook is called just before the DOM patching process starts.
    It is not called on the initial render. This is useful to read information from
    the DOM, such as the current position of the scrollbar.
  prefs: []
  type: TYPE_NORMAL
- en: Note that modifying the state is not allowed here. This method is called just
    before an actual DOM patch, and is only intended to be used to save some local
    DOM state. Also, it will not be called if the component is not in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The `onWillPatch` hook is used to register a function that will be executed
    at this moment. `willPatch` is called in the usual parent/children order.
  prefs: []
  type: TYPE_NORMAL
- en: patched
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This hook is called whenever a component actually updates its DOM (most likely
    via a change in its state/props or environment).
  prefs: []
  type: TYPE_NORMAL
- en: This method is not called on the initial render. It is useful to interact with
    the DOM (for example, through an external library) whenever the component is patched.
    Note that this hook will not be called if the component is not in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The `onPatched` hook is used to register a function that will be executed at
    this moment.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the component state in this hook is possible, but not recommended.
    We need to be careful because updates here will create additional rendering, which
    in turn will cause other calls to the `patched` method. So, we need to be particularly
    careful to prevent endless cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `mounted`, the `patched` hook is called in the order: children first,
    then parent.'
  prefs: []
  type: TYPE_NORMAL
- en: willUnmount
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`willUnmount` is a hook that is called just before a component is unmounted
    from the DOM. This is a good place to remove listeners, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: The `onWillUnmount` hook is used to register a function that will be executed
    at this moment.
  prefs: []
  type: TYPE_NORMAL
- en: This is the opposite method of `mounted`. Note that if a component is destroyed
    before being mounted, the `willUnmount` method may not be called.
  prefs: []
  type: TYPE_NORMAL
- en: Parent `willUnmount` hooks will be called before children.
  prefs: []
  type: TYPE_NORMAL
- en: willDestroy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, components need to do some action in the setup and clean it up when
    they are inactive. However, the `willUnmount` hook is not appropriate for the
    cleaning operation, since the component may be destroyed before it has even been
    mounted. The `willDestroy` hook is useful in this situation since it is always
    called.
  prefs: []
  type: TYPE_NORMAL
- en: The `onWillUnmount` hook is used to register a function that will be executed
    at this moment.
  prefs: []
  type: TYPE_NORMAL
- en: '`willDestroy` hooks are first called on children, then on parents.'
  prefs: []
  type: TYPE_NORMAL
- en: onError
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sadly, components may crash at runtime. This is an unfortunate reality, and
    this is why OWL needs to provide a way to handle these errors.
  prefs: []
  type: TYPE_NORMAL
- en: The `onError` hook is useful when we need to intercept and properly react to
    errors that occur in some sub-components.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is one more method in the component life cycle, but it is used when you
    are using subcomponents. OWL passes the parent component state via the `props`
    parameter, and when `props` is changed, the `willUpdateProps` method is called.
    This is an asynchronous method, which means you can perform an asynchronous operation
    such as RPC here.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an OWL field to the form view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have learned about all the basics of OWL. Now we will move
    on to more advanced aspects and create a field widget that can be used in the
    form view, just like the field widget recipe from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Odoo has many widgets in the UI for different functionalities, such as a status
    bar, checkboxes, and radio buttons. which makes the operations in Odoo simpler
    and run with ease. For example, we used `widget='image'` to display a binary field
    as an image. To demonstrate how to create your own widget, we’ll write one widget
    that lets the user choose an integer field, but we will display it differently.
    Instead of an input box, we will display a color picker so that we can select
    a color number. Here, each number will be mapped to a color.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a color picker widget that will save integer
    values based on the color selected.
  prefs: []
  type: TYPE_NORMAL
- en: To make the example more informative, we will use some advanced concepts of
    OWL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will be using the `my_hostel` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll add a JavaScript file that contains our widget’s logic, an XML file that
    contains design logic, and an SCSS file to do some styling. Then, we will add
    one integer field to the books form to use our new widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to add a new field widget:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the category integer field to the `hostel.room` model as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the same field to the form view, with a `widget` attribute as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the QWeb templates for the field at `static/src/xml/field_widget.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List the QWeb file in the module’s `manifest` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we want to add some SCSS for the field at `static/src/scss/field_widget.scss`.
    As the content of SCSS is too long, please find the content of the SCSS file in
    this book’s GitHub repository at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/05_owl_field/my_hostel/static/src/scss](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter16/05_owl_field/my_hostel/static/src/scss).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the static `/src/js/field_widget.js` JavaScript file with the following
    basic content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add JavaScript and an SCSS file to the backend assets as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart and update the module to apply the module changes. Open the room form
    view. You will be able to see the color picker widget, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.5 – Color picker OWL widget](img/B20997_16_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – Color picker OWL widget
  prefs: []
  type: TYPE_NORMAL
- en: This field looks just like the color widget from the last chapter, but the actual
    difference lies under the hood. This new field is built with OWL components and
    subcomponents, while the previous one was built with widgets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The benefit of this subcomponent is to provide a comprehensive framework for
    building modern, responsive, and interactive UIs in OWL. By modularizing functionality
    into small, reusable units, developers can create more maintainable and extensible
    applications while reducing code duplication and improving development efficiency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we added an integer field to the `hostel.room` model.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we added the field to the form view of the room.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we added the QWeb template file. If you notice, we added two templates
    to the file, one for the color pill and the other for the field itself. We used
    two templates because we want to see the concept of the `subcomponent`. If you
    observe the template closely, you will find that we have used the `<ColorPill>`
    tag. This will be used to instantiate the subcomponent. On the `<ColorPill>` tag,
    we have passed the active and color attributes. These attributes will be received
    as `props` in the template of the subcomponent. Also note that the `onClickColorUpdated`
    attribute is used to listen to the custom event triggered from the subcomponent.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: Odoo v17 uses both the widget system and the OWL framework.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we listed our QWeb template in the manifest. This will automatically
    load our template in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we added SCSS for the color. This will help us to have a beautiful
    UI for the color picker.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we added JavaScript for the field component.
  prefs: []
  type: TYPE_NORMAL
- en: We imported the OWL utility and we also imported the component and `fieldRegistry`.
  prefs: []
  type: TYPE_NORMAL
- en: '`fieldRegistry` is used to list the OWL component as a field component.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7*, we created the `ColorPill` component. The `template` variable on
    the component is the name of the template that is loaded from the external XML
    file. The `ColorPill` component has the `pillClicked` method, which is called
    when the user clicks on the color pill. Inside the method body, we have triggered
    the `onClickColorUpdated` event, which will be captured by the parent `OWLCategColorField`
    component as we used `colorUpdated` on the `OWLCategColorField` component.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 8* and *step 9*, we created the `OWLCategColorField` component by extending
    `Component`. We used the `Component` because it will have all the utilities that
    are required to create the field widget.
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, we used the `components` static variable at the start. You need
    to list the components via the `components` static variable when you are using
    subcomponents in the template. We also added the `onWillStart` method in our example.
    The `willStart` method is an asynchronous method, so we have called RPC (network
    call) to fetch data regarding the number of the room booked for a particular color.
    Toward the end, we added the `colorUpdated` method, which will be called when
    the user clicks on the pill. So, we are changing the values of the field. The
    `this.props.record.update` method is used to set the field values (which will
    be saved in the database). Note here that the data triggered from the child component
    is available under the `detail` attribute in the `event` parameter. Finally, we
    registered our widget in `fieldRegistry`, implying that henceforth, we will be
    able to use our field via the `widget` attribute in the form view.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 10*, we loaded JavaScript and SCSS files into the backend assets.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding QWeb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`t-`, for instance, `t-if` for conditionals, with elements and other attributes
    being rendered directly. The following are the different operations of the QWeb
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '`out`, will automatically HTML-escape its input, limiting XSS risks when displaying
    user-provided content. `out` takes an expression, evaluates it, and injects the
    result into the document:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`set` directive, which takes the name of the variable to create. The value
    of `set` can be provided in two ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `t-value` attribute containing an expression, and the result of its evaluation
    will be set:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`if`, which evaluates an expression given as an attribute value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The element is rendered if the condition is `true`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But if the condition is `false`, it is removed from the result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extra conditional branching directives, `t-elif` and `t-else`, are also available:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foreach`, which takes an expression that returns the collection to iterate
    on, and a second parameter, `t-as`, providing the name to use for the current
    item of the iteration:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will be rendered as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`t-att` (attribute) directive, which exists in three different forms:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will be rendered as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: < li class="row even">1</li>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <li class="row odd">2</li>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <li class="row even">3</li>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: t-att=mapping
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<div t-att="{''a'': 1, ''b'': 2}"/>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <div a="1" b="2"></div>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: t-att=pair
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <div t-att="['a', 'b']"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <div a="b">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </div>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`t-call` directive:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding call will be rendered as `<p/> (``no content)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <div>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This template was called with content:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <t t-out="0"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </div>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This will result in the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Understanding subcomponents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the context of OWL, subcomponents refer to small, modular units of functionality
    that can be integrated into larger components to enhance their capabilities or
    provide additional features.
  prefs: []
  type: TYPE_NORMAL
- en: Subcomponents in OWL can include various elements, such as widgets, utilities,
    services, and views, which are designed to work together within the OWL framework
    to create rich, interactive UIs and manage client-side logic efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: These subcomponents work together to provide a comprehensive framework for building
    modern, responsive, and interactive UIs in OWL. By modularizing functionality
    into small, reusable units, developers can create more maintainable and extensible
    applications while reducing code duplication and improving development efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is convenient to define a component using other (sub) components. This is
    called composition and is very powerful in practice. To do that in OWL, we can
    just use a tag starting with a capital letter in its template, and register the
    subcomponent class in its static `component` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<Child>` has `subcomponent`. This example also shows how we can pass
    information from the parent component to the child component as props. In OWL,
    `props` (short for properties) is an object that contains every piece of data
    given to a component by its parent. Note that `props` is an object that only makes
    sense from the perspective of the child component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `props` object is made of every attribute defined on the template, with
    the following exceptions: every attribute starting with `t-` is not a prop (they
    are QWeb directives).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `props` object contains the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
