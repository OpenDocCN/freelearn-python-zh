- en: Chapter 1. Start your Engines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 启动你的引擎
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The Shortest Python Program
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最短的 Python 程序
- en: Ensure the Python Modules are present
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保Python模块存在
- en: A Basic Python GUI in Tkinter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Tkinter 的基本 Python GUI
- en: Make a Compiled Executable under Linux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 下创建编译可执行文件
- en: Make a Compiled Executable under MS Windows
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MS Windows 下创建编译可执行文件
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This book is a collection of code recipes for creating and animating graphic
    objects using the marvelous Python language. In order to create and manipulate
    graphic objects, Python makes use of the Tkinter module. The prerequisite for
    using Python and Tkinter is obviously to have both installed. Both are free and
    Open Source and instructions for obtaining and installing them are abundantly
    available on the web. Just Google phrases like "install Python" and you will be
    spoilt for choice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是使用神奇的 Python 语言创建和动画图形对象的代码食谱集合。为了创建和操作图形对象，Python 使用 Tkinter 模块。使用 Python
    和 Tkinter 的先决条件显然是两者都已安装。它们都是免费和开源的，获取和安装它们的说明在网络上大量可用。只需在 Google 上搜索类似“安装 Python”的短语，你将有很多选择。
- en: Our first task is to prove that Python and Tkinter are installed and working
    on our computer. In this book, we use Python version 2.6\. Python 3.0 which came
    out in 2010 requires some changes in syntax that we won't be using in this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是证明 Python 和 Tkinter 已安装且在我们的计算机上运行正常。在这本书中，我们使用 Python 版本 2.6。2010 年发布的
    Python 3.0 需要一些语法上的更改，我们在这本书中不会使用。
- en: Let's look at some simple tests to check if Python is installed. If we download
    and install Python on Windows, it automatically includes Tkinter as one of the
    essential modules so we do not need to acquire and install it separately.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些简单的测试来检查 Python 是否已安装。如果我们下载并安装 Windows 上的 Python，它将自动包括 Tkinter 作为其中一个基本模块，因此我们不需要单独获取和安装它。
- en: Running a shortest Python program
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行最短的 Python 程序
- en: We need a one line Python program that will prove that the Python interpreter
    is installed and working on our computer platform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个单行 Python 程序，以证明 Python 解释器已安装且在我们的计算机平台上运行。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a folder (directory) called something like `construction_work` or `constr`
    for short. You will place all your Python programs inside this directory. In a
    text editor such as **gedit** on Linux or notepad on Windows. If we are working
    in Windows, there is a nice editor called "Context" that can be downloaded for
    free from [http://www.contexteditor.org/](http://www.contexteditor.org/) Context,
    that is sensitive to Python syntax and has a search-and-replace function that
    is useful.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `construction_work` 或简称 `constr` 的文件夹（目录）。你将把所有的 Python 程序放在这个目录中。在一个文本编辑器中，例如
    Linux 上的 **gedit** 或 Windows 上的记事本。如果我们正在 Windows 上工作，有一个名为 "Context" 的优秀编辑器可以免费从
    [http://www.contexteditor.org/](http://www.contexteditor.org/) 下载。Context 对 Python
    语法敏感，并具有一个有用的搜索和替换功能。
- en: 'Type the following line:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下行：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save this as a file named `simple_1.py`, inside the directory called `constr`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存为名为 `simple_1.py` 的文件，位于名为 `constr` 的目录中。
- en: Open up an X terminal or a DOS window if you are using MS Windows.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用 MS Windows，请打开 X 终端或 DOS 窗口。
- en: Change directory into `constr` - where `simple_1.py` is located.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `constr` 目录 - `simple_1.py` 所在的位置。
- en: Type `python simple_1.py` and your program will execute. The result should look
    like the following screenshot:![How to do it...](img/3845_01_01.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`python simple_1.py`，你的程序将会执行。结果应该看起来像下面的截图：![如何操作...](img/3845_01_01.jpg)
- en: This proves that your Python interpreter works, your editor works, and that
    you understand all that is needed to run all the programs in this book. Congratulations.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这证明了你的 Python 解释器工作正常，你的编辑器工作正常，并且你理解了运行本书中所有程序所需的所有内容。恭喜你。
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Any instructions you type into a Linux X terminal or DOS terminal in MS Windows
    are treated as operating system commands. By starting these commands from within
    the same directory where your Python program is stored you do not have to tell
    the Python and operating system where to search for your code. You could store
    the code in another directory but you would then need to precede the program name
    with the path.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 Linux X 终端或 MS Windows 的 DOS 终端中输入的任何指令都被视为操作系统命令。通过从你的 Python 程序存储的同一目录中启动这些命令，你不需要告诉
    Python 和操作系统在哪里搜索你的代码。你也可以将代码存储在另一个目录中，但那时你需要在程序名称前加上路径。
- en: There's more...
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Try the longer version of the same basic print instructions shown in the following
    program.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下程序中显示的相同基本打印指令的较长版本。
- en: All the text between the """ (triple quotation marks) is purely for the sake
    of good documentation and record keeping. It is for the use of programmers, and
    that includes you. Alas, the human memory is imperfect. Bitter experience will
    persuade you that it is wise to provide fairly complete information as a header
    in your programs as well as comments inside the program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在 """（三重引号）之间的文本纯粹是为了良好的文档记录。它是为程序员准备的，包括你。唉，人类的记忆是不完美的。痛苦的经验会说服你，在程序中提供相当完整的信息作为标题以及程序内的注释是明智的。
- en: However, in the interest of saving space and avoiding distractions, these header
    comments have been left out in the rest of this book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了节省空间和避免干扰，本书的其余部分省略了这些标题注释。
- en: Ensuring that the Python modules are present
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保Python模块存在
- en: 'Here is a slightly longer version of the previous program. However, the following
    modules are commanded to "report for duty" inside our program even though they
    are not actually used at this time: `Tkinter, math, random, time, tkFont`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是上一个程序的稍长版本。然而，以下模块在我们的程序中被命令“报到”以备使用，尽管它们在这个时候实际上并没有被使用：`Tkinter, math, random,
    time, tkFont`。
- en: We need the assurance that all the Python modules we will be using later are
    present and accessible to Python, and therefore, to our code. Each module is a
    self-contained library of code functions and objects that are called frequently
    by the commands in your programs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们稍后将要使用的所有Python模块都存在并且可以被Python以及我们的代码访问。每个模块都是一个包含代码函数和对象的独立库，这些函数和对象经常被程序中的命令调用。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做...
- en: In a text editor type the lines given in the following code.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中输入以下代码行。
- en: Save this as a file named `simple_2.py`, inside the directory called `constr`
    as we did previously.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存为名为 `simple_2.py` 的文件，放在之前提到的 `constr` 目录中。
- en: As before, open up an X terminal or a DOS window, if you are using MS Windows.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，如果你使用的是MS Windows，请打开X终端或DOS窗口。
- en: Change directory into `constr` - where `simple_1.py` is located.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `constr` 目录 - `simple_1.py` 所在的位置。
- en: Type `python simple_2.py` and our program should execute. The result should
    look like the following screenshot:![How to do it...](img/3845_01_02.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `python simple_2.py`，我们的程序应该执行。结果应该看起来像以下截图：![如何做...](img/3845_01_02.jpg)
- en: This proves that your Python interpreter can access the necessary library functions
    it will need.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这证明了你的Python解释器可以访问它将需要的必要库函数。
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `print` command is an instruction to write or print any text between quotation
    marks like "show *these words"* onto the monitor screen attached to your computer.
    It will also print the values of any named variables or expressions typed after
    print.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 命令是一条指令，用于将引号之间的任何文本（如“显示 *这些单词*”）写入或打印到连接到你的计算机的监视器屏幕上。它还会打印在 `print`
    后面输入的任何命名变量或表达式的值。'
- en: 'For example: print "dog''s `name:`", `dog_name`. Where `dog_name` is the name
    of a variable used to store some data.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：打印 "狗的 `名字:`"，`dog_name`。其中 `dog_name` 是用于存储一些数据的变量的名字。
- en: The `print` command is very useful when you are debugging a complicated sequence
    of code because even if the execution fails to complete because of errors, any
    print commands encountered before the error is reached will be respected. So by
    thoughtful placing of various print statements in your code, you are able to zero
    in on what is causing your program to crash.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 命令在调试复杂代码序列时非常有用，因为即使执行因错误而未能完成，到达错误之前遇到的任何 `print` 命令都将被尊重。因此，通过在代码中巧妙地放置各种打印语句，你可以聚焦于导致程序崩溃的原因。'
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you are writing a piece of Python code for the first time, you are often
    a bit unsure if your understanding of the logic is completely correct. So we would
    like to watch the progress of instruction execution in an exploratory way. It
    is a great help to be able to see that at least part of the code works. A major
    strength of Python is the way it takes our instructions one at a time and executes
    them progressively. It will only stop when the end is reached or a when programming
    flaw halts progress. If we have a twenty line program and only the first five
    lines are bug-free and the rest are unexecutable garbage, the Python interpreter
    will at least execute the first five. This is where the `print` command is a really
    potent little tool.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次编写一段Python代码时，你通常有点不确定你对逻辑的理解是否完全正确。因此，我们希望以探索的方式观察指令执行的进度。能够看到至少部分代码是有效的非常有帮助。Python的一个主要优势是它一次执行一条指令，并逐步执行。它只会在达到终点或编程错误阻止进度时停止。如果我们有一个20行的程序，只有前五行是正确的，其余的都是无法执行的垃圾，Python解释器至少会执行前五行。这就是`print`命令真正强大的地方。
- en: This is how you use print and the Python interpreter. When we are having trouble
    with our code and it just won't work and we are battling to figure out why, we
    can just insert print statements at various chosen points in our program. This
    way you can get some intermediate values of variables as your own private status
    reports. When we want to switch off our print watchdogs we simply type a hash
    (#) symbol in front, thus transforming them into passive comments. Later on, if
    you change your mind and want the prints to be active again you just remove the
    leading hash symbols.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用print和Python解释器。当我们遇到代码问题，它就是无法工作，我们正在努力找出原因时，我们可以在程序的各个选定的点上插入print语句。这样，你可以得到一些变量的中间值作为你自己的私有状态报告。当我们想要关闭我们的print监视器时，我们只需在前面输入一个hash（#）符号，这样就可以将它们转换成被动注释。稍后，如果你改变主意，想要再次激活print，你只需移除前面的hash符号。
- en: A basic Tkinter program
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个基本的Tkinter程序
- en: Here we attempt to execute a Tkinter command inside the Python program. The
    Tkinter instruction will create a canvas and then draw a straight line on it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试在Python程序中执行一个Tkinter命令。Tkinter指令将创建一个画布，然后在上面画一条直线。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In a text editor, type the code given below.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中，输入以下代码。
- en: Save this as a file named `simple_line_1.py`, inside the directory called `constr`
    again.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存为名为`simple_line_1.py`的文件，再次放在名为`constr`的目录中。
- en: As before open up an X terminal or DOS window if you are using MS Windows.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，如果你使用的是MS Windows，请打开一个X终端或DOS窗口。
- en: Change directory into `constr` - where `simple_line_1.py` is located.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`constr`目录 - `simple_line_1.py`所在的位置。
- en: Type `python simple_line_1.py` and your program should execute. The command
    terminal result should look like the following screenshot:![How to do it...](img/3845_01_03.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`python simple_line_1.py`，你的程序应该执行。命令终端的结果应类似于以下截图：![如何做到这一点...](img/3845_01_03.jpg)
- en: The Tkinter canvas output should look like the following screenshot:![How to
    do it...](img/3845_01_04.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Tkinter画布输出应类似于以下截图：![如何做到这一点...](img/3845_01_04.jpg)
- en: This proves that your Python interpreter works, your editor works, and the Tkinter
    module works. This is not a trivial achievement you are definitely ready for great
    things. Well done.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这证明了你的Python解释器工作正常，你的编辑器工作正常，Tkinter模块也工作正常。这不是一个微不足道的成就，你肯定准备好迎接伟大的事情。做得好。
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To draw a line, we only need to give the start point and the end point.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要画一条线，我们只需要给出起点和终点。
- en: The start point is the first pair of numbers in `canvas_1.create_line(10,20
    , 50,70).In` another way, the start is given by the coordinates `x_start=10` and
    `y_start=20`. The end point of the line is specified by the second pair of numbers
    `x_end=50` and `y_end=70`. The units of measurement are pixels. A **pixel** is
    the smallest dot that can be displayed on our screen.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 起点是`canvas_1.create_line(10,20, 50,70)`中的第一对数字。另一种方式，起点由坐标`x_start=10`和`y_start=20`给出。线的终点由第二对数字指定`x_end=50`和`y_end=70`。计量单位是像素。**像素**是我们屏幕上可以显示的最小点。
- en: For all other properties like line thickness or color, default values of the
    `create_line()` method are used.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他属性，如线条粗细或颜色，默认的`create_line()`方法值被使用。
- en: However, should you want to change color or thickness, you just do it by specifying
    the settings.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要更改颜色或粗细，你只需通过指定设置来完成。
- en: Make a compiled executable under Windows and Linux
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Windows和Linux下创建一个编译后的可执行文件
- en: How do we create and execute a.exe file that will run a compiled version of
    our Python and Tkinter programs? Can we make a self-contained folder that will
    run on an MS Windows or Linux distribution that uses a different version of Python
    from the ones we use? The answers to both questions are yes and the tool to achieve
    this is an Open Source program called `cx_Freeze`. Often what we would like to
    do is have our working Python program on a memory stick or downloadable on a network
    and be able to demonstrate it to friends, colleagues, or clients without the need
    to download Python onto the client's system. `cx_Freeze` allows us to create a
    distributable form of our Python graphic program.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建和执行一个.exe文件，使其能够运行我们编译后的Python和Tkinter程序？我们能否制作一个自包含的文件夹，在MS Windows或Linux发行版上运行，而这些发行版使用的Python版本与我们使用的不同？这两个问题的答案都是肯定的，实现这一目标的工具是一个名为`cx_Freeze`的开源程序。我们通常希望将我们的工作Python程序放在U盘上或在网络上下载，并且能够向朋友、同事或客户展示，而无需在客户端系统上下载Python。`cx_Freeze`允许我们创建我们Python图形程序的发行版本。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to download `cx_Freeze` from [http://cx-freeze.sourceforge.net/](http://cx-freeze.sourceforge.net/).
    We need to pick a version that has the same version number as the Python version
    we are using. Currently, there are versions available from version 2.4 up to 3.1.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从[http://cx-freeze.sourceforge.net/](http://cx-freeze.sourceforge.net/)下载`cx_Freeze`。我们需要选择与我们所使用的Python版本相同版本的版本。目前，有从2.4版到3.1版的版本可供选择。
- en: 'MS Windows: Download `cx_Freeze-4.2.win32-py2.6.msi`, the windows installer
    for Python 2.6\. If we have another Python version, then we must choose the appropriate
    installer from [http://cx-freeze.sourceforge.net/](http://cx-freeze.sourceforge.net/).'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MS Windows：下载`cx_Freeze-4.2.win32-py2.6.msi`，这是Python 2.6的Windows安装程序。如果我们有其他Python版本，那么我们必须从[http://cx-freeze.sourceforge.net/](http://cx-freeze.sourceforge.net/)选择适当的安装程序。
- en: Save and run this installer.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行此安装程序。
- en: On completion of a successful Windows install we will see a folder named `cx_Freeze
    inside \Python26\Lib\site-packages\`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows安装成功完成后，我们将看到一个名为`cx_Freeze`的文件夹，位于`\Python26\Lib\site-packages\`中。
- en: In a terminal run the command `apt-get install cx-freeze`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行命令`apt-get install cx-freeze`。
- en: If this does not work we may need to first install a development-capable version
    of Python by running the command `apt-get install python-dev`. Then go back and
    repeat step 1.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这不起作用，我们可能需要首先通过运行命令`apt-get install python-dev`安装一个具有开发能力的Python版本。然后返回并重复步骤1。
- en: Test for success by typing in `python` in a command terminal to invoke the Python
    interpreter.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令终端中输入`python`来调用Python解释器进行成功测试。
- en: Then after the`>>>` prompt, type `import cx_Freeze`. If the interpreter returns
    a new line and the`>>>` prompt again, without any complaints, we have been successful.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`>>>`提示符后，输入`import cx_Freeze`。如果解释器返回新行和`>>>`提示符，且没有任何抱怨，我们就成功了。
- en: If the file we want to package as an executable is named `walking_birdy_1.py`
    in a folder called `/constr`, then we prepare a special setup file as follows.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要打包为可执行文件的文件名为`walking_birdy_1.py`，位于名为`/constr`的文件夹中，那么我们准备一个特殊的设置文件如下。
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save it as `setup.py`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存为`setup.py`。
- en: Then, in a command terminal run
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在命令终端中运行
- en: '[PRE5]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will see a lot of system compilation commands scrolling down the command
    terminal that will eventually stop without error messages.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们会在命令终端中看到许多系统编译命令滚动下来，最终会停止而不会出现错误信息。
- en: We will find our complete self-contained executable inside a folder named `build`.
    Under Linux, we will find it inside our home directory under `/build/exe.linux-i686-2.6`.
    Under MS Windows, we will find it inside `C:\Python26\build\exe.win-py2.6`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在名为`build`的文件夹中找到完整的自包含可执行文件。在Linux下，我们将在家目录下的`/build/exe.linux-i686-2.6`中找到它。在MS
    Windows下，我们将在`C:\Python26\build\exe.win-py2.6`中找到它。
- en: We just need to copy the folder `build` with all its contents to wherever we
    want to run our self-contained program.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要将包含所有内容的`build`文件夹复制到我们想要运行自包含程序的地方。
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A word of caution. If we use external files like images inside our code, then
    the path addresses of the files must be absolute because they are coded into,
    or frozen, into the executable version of our Python program. There are ways of
    setting up search paths which can be read at [http://cx-freeze.sourceforge.net/cx_Freeze.html](http://cx-freeze.sourceforge.net/cx_Freeze.html).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下。如果我们使用代码中的外部文件，如图片，那么文件的路径地址必须是绝对路径，因为它们被编码到或冻结到我们的Python程序的可执行版本中。有设置搜索路径的方法，可以在[http://cx-freeze.sourceforge.net/cx_Freeze.html](http://cx-freeze.sourceforge.net/cx_Freeze.html)查看。
- en: For example, say we want to use some `GIF` images in our program and then demonstrate
    them on other computers. First we place a folder called, for example, `/birdy_pics`,
    onto a USB memory stick. In the original program, `walking_birdy_1.py`, make sure
    the path addresses to the images point to the `/birdy_pics` folder on the stick.
    After compilation, copy the folder `build` onto the USB memory stick. Now when
    we double-click on the executable `walking_birdy_1` it can locate the images on
    the USB memory stick when it needs to. These files include everything that is
    needed for your program, and you should distribute the whole directory contents
    to any user who wants to run your program without needing to install Python or
    Tkinter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想在程序中使用一些 `GIF` 图片，并在其他计算机上展示它们。首先，我们将一个名为，例如，`/birdy_pics` 的文件夹放置在 U
    盘上。在原始程序 `walking_birdy_1.py` 中，确保路径地址指向 U 盘上的 `/birdy_pics` 文件夹。编译后，将 `build`
    文件夹复制到 U 盘上。现在，当我们双击可执行文件 `walking_birdy_1` 时，它可以在需要时定位到 U 盘上的图片。这些文件包含了程序所需的所有内容，你应该将整个目录内容分发给任何想要运行你的程序但不需要安装
    Python 或 Tkinter 的用户。
- en: There is another program called `py2exe` that will also create executables to
    run on MS Windows. However, it cannot create self-contained binary executables
    to run under Linux whereas `cx_Freeze`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个名为 `py2exe` 的程序，它也能创建在 MS Windows 上运行的可执行文件。然而，它无法创建在 Linux 下运行的独立二进制可执行文件，而
    `cx_Freeze`
