<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer060" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">2</h1>&#13;
    <h1 id="_idParaDest-44" class="chapterTitle">Interactive Python Interpreters</h1>&#13;
    <p class="normal">Now that we have a working Python installation, we need to run some code. The most obvious way is to create a Python file and execute it. Often, it can be faster to interactively develop code from an interactive Python interpreter, however. While the standard Python interpreter is already quite powerful, many enhancements and alternatives are available.</p>&#13;
    <p class="normal">The alternative interpreters/shells offer features such as:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Smart autocompletion</li>&#13;
      <li class="bulletList">Syntax highlighting</li>&#13;
      <li class="bulletList">Saving and loading sessions</li>&#13;
      <li class="bulletList">Automatic indenting</li>&#13;
      <li class="bulletList">Graphing/charting output</li>&#13;
    </ul>&#13;
    <p class="normal">In this chapter, you will learn about:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Alternative interpreters:<ul>&#13;
          <li class="bulletList"><code class="inlineCode">bpython</code></li>&#13;
          <li class="bulletList"><code class="inlineCode">ptpython</code></li>&#13;
          <li class="bulletList"><code class="inlineCode">ipython</code></li>&#13;
          <li class="bulletList"><code class="inlineCode">jupyter</code></li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="bulletList">How to enhance interpreters</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-45" class="heading-1">The Python interpreter</h1>&#13;
    <p class="normal">The<a id="_idIndexMarker037"/> standard Python interpreter is already fairly powerful, but more options are available through customization. First, let’s start with a <code class="inlineCode">'Hello world!'</code>. Because the interpreter uses REPL, all output will be automatically printed and we can simply create a string.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Sometimes interactive interpreters are referred to as <strong class="keyWord">REPL</strong>. This stands for <strong class="keyWord">Read-Eval-Print-Loop</strong>. This <a id="_idIndexMarker038"/>effectively means that all of your statements will be executed and printed to your screen immediately.</p>&#13;
    </div>&#13;
    <p class="normal">First, we need to start the interpreter; after that, we can type our commands:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3&#13;
Python 3.9.0&#13;
[GCC 7.4.0] on linux&#13;
Type "help", "copyright", "credits" or "license" for more information.&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'Hello world!'</span>&#13;
'Hello world!'&#13;
</code></pre>&#13;
    <p class="normal">That was easy enough. And note that we didn’t have to use <code class="inlineCode">print('Hello world!')</code> to show the output.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">Many interpreters have only limited support for Windows. While they all work to some degree, your experience will be better with Linux or OS X systems. I recommend trying them from a (virtual) Linux/Unix machine at least once to experience the full range of features.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-46" class="heading-2">Modifying the interpreter</h2>&#13;
    <p class="normal">As our<a id="_idIndexMarker039"/> first enhancement, we will add a few convenient shortcuts to the scope of the interpreter. Instead of having to type <code class="inlineCode">import pprint; pprint.pprint(...)</code> to pretty-print our output, it would be useful to use <code class="inlineCode">pp(...)</code> instead without having to run an <code class="inlineCode">import</code> statement every time we start our interpreter. To do this, we will create a Python file that will be executed every time we run Python. On Linux and OS X systems, I would recommend ~<code class="inlineCode">/.config/python/init.py</code>; on Windows, something like <code class="inlineCode">C:\Users\rick\AppData\Local\Python\init.py</code> might be more suitable. Within this file, we can add regular Python code that will be executed.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Python won’t find the file automatically; you need to tell Python where to look for the file by using the <code class="inlineCode">PYTHONSTARTUP</code> environment variable. On Linux and OS X, you can change the <code class="inlineCode">~/.zshrc</code>, <code class="inlineCode">~/.bashrc</code> file, or whatever your shell has, and add:</p>&#13;
      <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> export PYTHONSTARTUP=~/.config/python/init.py&#13;
</code></pre>&#13;
      <p class="normal">This file is automatically executed every time you open a new shell session. So, once you open a new shell session, you are done.</p>&#13;
      <p class="normal">If you want to activate this for your current shell, you can also run the export line above in your current shell.</p>&#13;
      <p class="normal">On Windows, you need to find the Advanced System Settings and change the environment variables on that screen.</p>&#13;
    </div>&#13;
    <p class="normal">Now <a id="_idIndexMarker040"/>we can add these lines to the file to make pretty print (<code class="inlineCode">pprint</code>/<code class="inlineCode">pp</code>) and pretty format (<code class="inlineCode">pformat</code>/<code class="inlineCode">pf</code>) available by default:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint <span class="hljs-keyword">as</span> pp&#13;
<span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pformat <span class="hljs-keyword">as</span> pf&#13;
</code></pre>&#13;
    <p class="normal">When we run the Python interpreter, now we will have <code class="inlineCode">pp</code> and <code class="inlineCode">pf</code> available in our scope:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> pp(<span class="hljs-con-built_in">dict</span>(spam=<span class="hljs-con-number">0xA</span>, eggs=<span class="hljs-con-number">0xB</span>))&#13;
{'eggs': 11, 'spam': 10}&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pf(<span class="hljs-con-built_in">dict</span>(spam=<span class="hljs-con-number">0xA</span>, eggs=<span class="hljs-con-number">0xB</span>))&#13;
"{'eggs': 11, 'spam': 10}"&#13;
</code></pre>&#13;
    <p class="normal">With a few of these minor changes, you can make your life a lot easier. You could modify your <code class="inlineCode">sys.path</code> to include a directory with custom libraries, for example. And you can also change your prompt using the <code class="inlineCode">sys.ps1</code> and <code class="inlineCode">sys.ps2</code> variables. To illustrate, we’ll look at the interpreter before our changes:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Modifying prompt</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">if</span> <span class="hljs-con-literal">True</span>:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'Hello!'</span>)&#13;
Hello!&#13;
</code></pre>&#13;
    <p class="normal">And now we will modify <code class="inlineCode">sys.ps1</code> and <code class="inlineCode">sys.ps2</code> and run the exact same code again:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> sys&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sys.ps1 = <span class="hljs-con-string">'&gt; '</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sys.ps2 = <span class="hljs-con-string">'</span><span class="hljs-con-string">. '</span>&#13;
&#13;
<span class="hljs-con-comment"># With modified prompt</span>&#13;
&gt; if True:&#13;
.     print('Hello!')&#13;
Hello!&#13;
</code></pre>&#13;
    <p class="normal">The configuration<a id="_idIndexMarker041"/> above shows that you can easily change the interpreter to a slightly different output if you wish. For consistency purposes, however, it might be better to keep it the same.</p>&#13;
    <h3 id="_idParaDest-47" class="heading-3">Enabling and enhancing autocompletion</h3>&#13;
    <p class="normal">One of the most <a id="_idIndexMarker042"/>useful additions to the interpreter is the <code class="inlineCode">rlcompleter</code> module. This<a id="_idIndexMarker043"/> module enables tab-activated autocompletion in your interpreter and is automatically activated if the <code class="inlineCode">readline</code> module is available.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">The <code class="inlineCode">rlcompleter</code> module depends on the availability of the <code class="inlineCode">readline</code> module, which is not bundled with Python on Windows systems. Luckily, an alternative can be installed easily: </p>&#13;
      <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install pyreadline&#13;
</code></pre>&#13;
    </div>&#13;
    <p class="normal">It would be very useful to add some extra <a id="_idIndexMarker044"/>options to the autocompletion. First, look at the default output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich = <span class="hljs-con-built_in">dict</span>(spam=<span class="hljs-con-number">2</span>, eggs=<span class="hljs-con-number">1</span>, sausage=<span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich.&lt;TAB&gt;&#13;
sandwich.clear(       sandwich.fromkeys(    sandwich.items(       sandwich.pop(&#13;
sandwich.setdefault(  sandwich.values(      sandwich.copy(        sandwich.get(&#13;
sandwich.keys(        sandwich.popitem(     sandwich.update(&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich[&lt;TAB&gt;&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the tab completion for "<code class="inlineCode">.</code>" works perfectly, but the tab completion for "<code class="inlineCode">[</code>" does nothing. It would be useful to know the available items, so now we will work on adding that feature. It should be noted that this example uses a few techniques that are explained in later<a id="_idIndexMarker045"/> chapters, but that shouldn’t matter for now:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> __main__&#13;
<span class="hljs-keyword">import</span> re&#13;
<span class="hljs-keyword">import</span> atexit&#13;
<span class="hljs-keyword">import</span> readline&#13;
<span class="hljs-keyword">import</span> rlcompleter&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Completer</span><span class="hljs-class">(</span><span class="hljs-params">rlcompleter.Completer</span><span class="hljs-class">):</span>&#13;
    ITEM_RE = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r'(?P&lt;expression&gt;.+?)\[(?P&lt;key&gt;[^\[]*)'</span>)&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">complete</span><span class="hljs-function">(</span><span class="hljs-params">self, text, state</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-comment"># Init namespace. From 'rlcompleter.Completer.complete'</span>&#13;
        <span class="hljs-keyword">if</span> self.use_main_ns:&#13;
            self.namespace = __main__.__dict__&#13;
&#13;
        <span class="hljs-comment"># If we find a [, try and return the keys</span>&#13;
        <span class="hljs-keyword">if</span> <span class="hljs-string">'['</span> <span class="hljs-keyword">in</span> text:&#13;
            <span class="hljs-comment"># At state 0 we need to prefetch the matches, after</span>&#13;
            <span class="hljs-comment"># that we use the cached results</span>&#13;
            <span class="hljs-keyword">if</span> state == <span class="hljs-number">0</span>:&#13;
                self.matches = <span class="hljs-built_in">list</span>(self.item_matches(text))&#13;
&#13;
            <span class="hljs-comment"># Try and return the match if it exists</span>&#13;
            <span class="hljs-keyword">try</span>:&#13;
                <span class="hljs-keyword">return</span> self.matches[state]&#13;
            <span class="hljs-keyword">except</span> IndexError:&#13;
                <span class="hljs-keyword">pass</span>&#13;
        <span class="hljs-keyword">else</span>:&#13;
            <span class="hljs-comment"># Fallback to the normal completion</span>&#13;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().complete(text, state)&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">item_matches</span><span class="hljs-function">(</span><span class="hljs-params">self, text</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-comment"># Look for the pattern expression[key</span>&#13;
        match = self.ITEM_RE.match(text)&#13;
        <span class="hljs-keyword">if</span> match:&#13;
            search_key = match.group(<span class="hljs-string">'</span><span class="hljs-string">key'</span>).lstrip()&#13;
            expression = match.group(<span class="hljs-string">'expression'</span>)&#13;
&#13;
            <span class="hljs-comment"># Strip quotes from the key</span>&#13;
            <span class="hljs-keyword">if</span> search_key <span class="hljs-keyword">and</span> search_key[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> {<span class="hljs-string">"'"</span>, <span class="hljs-string">'"'</span>}:&#13;
                search_key = search_key.strip(search_key[<span class="hljs-number">0</span>])&#13;
&#13;
            <span class="hljs-comment"># Fetch the object from the namespace</span>&#13;
            object_ = <span class="hljs-built_in">eval</span>(expression, self.namespace)&#13;
&#13;
            <span class="hljs-comment"># Duck typing, check if we have a 'keys()' attribute</span>&#13;
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(object_, <span class="hljs-string">'keys'</span>):&#13;
                <span class="hljs-comment"># Fetch the keys by executing the 'keys()' method</span>&#13;
                <span class="hljs-comment"># Can you guess where the bug is?</span>&#13;
                keys = object_.keys()&#13;
                <span class="hljs-keyword">for</span> i, key <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(keys):&#13;
                    <span class="hljs-comment"># Limit to 25 items for safety, could be infinite</span>&#13;
                    <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">25</span>:&#13;
                        <span class="hljs-keyword">break</span>&#13;
&#13;
                    <span class="hljs-comment"># Only return matching results</span>&#13;
                    <span class="hljs-keyword">if</span> key.startswith(search_key):&#13;
                        <span class="hljs-keyword">yield</span> <span class="hljs-string">f'</span><span class="hljs-subst">{expression}</span><span class="hljs-string">[</span><span class="hljs-subst">{key!r}</span><span class="hljs-string">]'</span>&#13;
&#13;
<span class="hljs-comment"># By default readline doesn't call the autocompleter for [ because</span>&#13;
<span class="hljs-comment"># it's considered a delimiter. With a little bit of work we can</span>&#13;
<span class="hljs-comment"># fix this however :)</span>&#13;
delims = readline.get_completer_delims()&#13;
<span class="hljs-comment"># Remove [, ' and " from the delimiters</span>&#13;
delims = delims.replace(<span class="hljs-string">'['</span>, <span class="hljs-string">''</span>).replace(<span class="hljs-string">'"'</span>, <span class="hljs-string">''</span>).replace(<span class="hljs-string">"'"</span>, <span class="hljs-string">''</span>)&#13;
<span class="hljs-comment"># Set the delimiters</span>&#13;
readline.set_completer_delims(delims)&#13;
&#13;
<span class="hljs-comment"># Create and set the completer</span>&#13;
completer = Completer()&#13;
readline.set_completer(completer.complete)&#13;
<span class="hljs-comment"># Add a cleanup call on Python exit</span>&#13;
atexit.register(<span class="hljs-keyword">lambda</span>: readline.set_completer(<span class="hljs-literal">None</span>))&#13;
print(<span class="hljs-string">'Done initializing the tab completer'</span>)&#13;
</code></pre>&#13;
    <p class="normal">That was quite a bit <a id="_idIndexMarker046"/>of code, and if you look carefully, you’ll notice multiple potential bugs in this limited example. I’m just trying to show a working example here without introducing too much complexity, so several edge cases are not considered. To make the script work, we need to store it in the <code class="inlineCode">PYTHONSTARTUP</code> file as we discussed earlier. You should see the result from <code class="inlineCode">print()</code> after opening the interpreter so you can verify whether the script was loaded. With this addition, we can now complete dictionary keys as well:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Done initializing the tab completer&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich = <span class="hljs-con-built_in">dict</span>(spam=<span class="hljs-con-number">2</span>, eggs=<span class="hljs-con-number">1</span>, sausage=<span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich[<span class="hljs-con-string">'&lt;TAB&gt;</span>&#13;
sandwich['eggs']     sandwich['sausage']  sandwich['spam']&#13;
</code></pre>&#13;
    <p class="normal">Naturally, you<a id="_idIndexMarker047"/> could expand this to include colors, other completions, and many more useful features.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Since this completion calls <code class="inlineCode">object.keys()</code>, there is a potential risk here. This code could be dangerous if, for some reason, the <code class="inlineCode">object.keys()</code> method code is not safe to execute. Perhaps you are running on an external library, or your code has overridden the <code class="inlineCode">keys() </code>method to execute a heavy database function. And if <code class="inlineCode">object.keys()</code> is a generator that is exhausted after executing once, you won’t have any results when running your actual code afterward.</p>&#13;
      <p class="normal">Additionally, the <code class="inlineCode">eval() </code>function can be dangerous to execute on unknown code. In this case, <code class="inlineCode">eval()</code> is only executing the line we typed ourselves, so that is less of an issue here.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-48" class="heading-1">Alternative interpreters</h1>&#13;
    <p class="normal">Now that you <a id="_idIndexMarker048"/>have seen some of the features of the regular Python interpreter, let’s look at some enhanced alternatives. There are many options available, but we will limit ourselves to the most popular ones here:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">bpython</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">ptpython</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">ipython</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">jupyter</code> (web-based <code class="inlineCode">ipython</code>)</li>&#13;
    </ul>&#13;
    <p class="normal">Let’s get started.</p>&#13;
    <h2 id="_idParaDest-49" class="heading-2">bpython</h2>&#13;
    <p class="normal">The <code class="inlineCode">bpython</code> interpreter<a id="_idIndexMarker049"/> is a <code class="inlineCode">curses</code> interface for the<a id="_idIndexMarker050"/> Python interpreter that offers many useful features, while still being very similar to the regular Python interpreter.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The <code class="inlineCode">curses</code> library allows you to create a fully functioning <strong class="keyWord">text-based user interface</strong> (<strong class="keyWord">TUI</strong>). A TUI <a id="_idIndexMarker051"/>gives you full control over where you want to write to the screen. The regular Python interpreter<a id="_idIndexMarker052"/> is a <strong class="keyWord">command-line interface</strong> (<strong class="keyWord">CLI</strong>), which normally only allows you to append to the screen. With a TUI, you can write to any position on the screen, making its features somewhat comparable<a id="_idIndexMarker053"/> to a <strong class="keyWord">graphical user interface</strong> (<strong class="keyWord">GUI</strong>).</p>&#13;
    </div>&#13;
    <p class="normal">Some key <a id="_idIndexMarker054"/>features of <code class="inlineCode">bpython</code>:</p>&#13;
    <ul>&#13;
      <li class="bulletList">As-you-type autocompletion (as opposed to tab completion with <code class="inlineCode">rlcompleter</code>)</li>&#13;
      <li class="bulletList">In-line syntax highlighting while typing</li>&#13;
      <li class="bulletList">Automatic function parameter documentation</li>&#13;
      <li class="bulletList">A undo/rewind feature that removes the last line</li>&#13;
      <li class="bulletList">Easy reloading of imported modules, so your external code changes can be tested without restarting the interpreter</li>&#13;
      <li class="bulletList">Quick changing of code in an external editor (convenient for multiline functions/code blocks)</li>&#13;
      <li class="bulletList">The ability to save the session to file/pastebin</li>&#13;
    </ul>&#13;
    <p class="normal">Most of these features work fully automatically and transparently for you. Before we can start with <code class="inlineCode">bpython</code>, we need to install it. A simple <code class="inlineCode">pip install</code> should suffice:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install bpython&#13;
</code></pre>&#13;
    <p class="normal">To illustrate<a id="_idIndexMarker055"/> the automatically enabled features, here is the output of the code we used for the regular Python interpreter completion:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> bpython&#13;
bpython version 0.21 on top of Python 3.9.6&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich = <span class="hljs-con-built_in">dict</span>(spam=<span class="hljs-con-number">2</span>, eggs=<span class="hljs-con-number">1</span>, sausage=<span class="hljs-con-number">1</span>)&#13;
┌────────────────────────────────────────────────────────────────┐&#13;
│ dict: (self, *args, **kwargs)                                  │&#13;
│ Initialize self.  See help(type(self)) for accurate signature. │&#13;
└────────────────────────────────────────────────────────────────┘&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich.&#13;
┌────────────────────────────────────────────────────────────────┐&#13;
│ clear               copy                fromkeys               │&#13;
│ get                 items               keys                   │&#13;
│ pop                 popitem             setdefault             │&#13;
│ update              values                                     │&#13;
└────────────────────────────────────────────────────────────────┘&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich[&#13;
┌────────────────────────────────────────────────────────────────┐&#13;
│ 'eggs'     'sausage'  'spam'                                   │&#13;
└────────────────────────────────────────────────────────────────┘&#13;
</code></pre>&#13;
    <p class="normal">If you <a id="_idIndexMarker056"/>ran this <a id="_idIndexMarker057"/>code on your own system, you would see highlighting as well as the intermediate states of autocompletion. I encourage you to give it a try; the preceding excerpt does not show enough.</p>&#13;
    <h3 id="_idParaDest-50" class="heading-3">Rewinding your session</h3>&#13;
    <p class="normal">As for the <a id="_idIndexMarker058"/>more advanced features, let’s give those a try as well. First, let’s start with the rewind feature. While it appears to simply remove the last line, in the background it actually replays your entire history, except for the last line. This means that if your code is not safe to be run more than once, it can cause errors. The following code illustrates the usage and limitations of the rewind feature:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span> <span class="hljs-con-built_in">open</span>(<span class="hljs-con-string">'bpython.txt'</span>, <span class="hljs-con-string">'a'</span>) <span class="hljs-con-keyword">as</span> fh:&#13;
<span class="hljs-con-meta">...</span>     fh.write(<span class="hljs-con-string">'x'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
1&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span> <span class="hljs-con-built_in">open</span>(<span class="hljs-con-string">'bpython.txt'</span>) <span class="hljs-con-keyword">as</span> fh:&#13;
<span class="hljs-con-meta">...</span>     print(fh.read())&#13;
<span class="hljs-con-meta">...</span>&#13;
x&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich = <span class="hljs-con-built_in">dict</span>(spam=<span class="hljs-con-number">2</span>, eggs=<span class="hljs-con-number">1</span>, sausage=<span class="hljs-con-number">1</span>)&#13;
</code></pre>&#13;
    <p class="normal">Now if we press <em class="keystroke">Ctrl </em>+ <em class="keystroke">R</em> to “rewind” the last line, we get the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span> <span class="hljs-con-built_in">open</span>(<span class="hljs-con-string">'bpython.txt'</span>, <span class="hljs-con-string">'a'</span>) <span class="hljs-con-keyword">as</span> fh:&#13;
<span class="hljs-con-meta">...</span>     fh.write(<span class="hljs-con-string">'x'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
1&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span> <span class="hljs-con-built_in">open</span>(<span class="hljs-con-string">'bpython.txt'</span>) <span class="hljs-con-keyword">as</span> fh:&#13;
<span class="hljs-con-meta">...</span>     print(fh.read())&#13;
<span class="hljs-con-meta">...</span>&#13;
xx&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span>&#13;
</code></pre>&#13;
    <p class="normal">As you <a id="_idIndexMarker059"/>can see, the last line is gone now, but that’s not all; the output of the <code class="inlineCode">fh.read()</code> line is now <code class="inlineCode">xx</code> instead of <code class="inlineCode">x,</code> which means that the line that writes <code class="inlineCode">x</code> was executed twice. Additionally, the partial line will be executed as well, so when rewinding an indented block of code, you will see an error until you’ve executed valid code again.</p>&#13;
    <h3 id="_idParaDest-51" class="heading-3">Reloading modules</h3>&#13;
    <p class="normal">Often, when <a id="_idIndexMarker060"/>developing, I will write code in my regular editor and test the execution in the Python shell. </p>&#13;
    <p class="normal">When developing like this, a very useful feature of Python is the ability to reload imported modules using <code class="inlineCode">importlib.reload()</code>. When you have multiple (nested) modules, this can get tedious fast, however. This is where the reload shortcut in <code class="inlineCode">bpython</code> can help a lot. By using the <em class="italic">F6</em> button on your keyboard, <code class="inlineCode">bpython</code> will not only run <code class="inlineCode">importlib.reload()</code> on all modules in <code class="inlineCode">sys.modules</code>, but it will also rerun the code in your session in a similar way to the rewind feature you saw earlier.</p>&#13;
    <p class="normal">To demonstrate this, we will start by creating a file named <code class="inlineCode">bpython_reload.py</code> with the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'reload.txt'</span>, <span class="hljs-string">'a+'</span>) <span class="hljs-keyword">as</span> fh:&#13;
    fh.write(<span class="hljs-string">'x'</span>)&#13;
    fh.seek(<span class="hljs-number">0</span>)&#13;
    print(fh.read())&#13;
</code></pre>&#13;
    <p class="normal">This opens the <code class="inlineCode">reload.txt</code> file for reading and writing in append mode. This means that <code class="inlineCode">fh.write('x')</code> will append to the end of the file. The <code class="inlineCode">fh.seek(0)</code> will jump to the beginning of the file (position 0) so that <code class="inlineCode">print(fh.read())</code> can print the entire file content to the screen.</p>&#13;
    <p class="normal">Now we open the <code class="inlineCode">bpython</code> shell and import the module:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> bpython_reload&#13;
x&#13;
</code></pre>&#13;
    <p class="normal">If we <a id="_idIndexMarker061"/>press the <em class="italic">F6</em> button within that same shell, we will see that an extra character has been written and the code has been re-executed:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> bpython_reload&#13;
xx&#13;
Reloaded at ... by user.&#13;
</code></pre>&#13;
    <p class="normal">This is an extremely useful feature with the same caveat as the rewind feature that not all code is safe to re-execute without side effects.</p>&#13;
    <h2 id="_idParaDest-52" class="heading-2">ptpython</h2>&#13;
    <p class="normal">The <code class="inlineCode">ptpython</code> interpreter<a id="_idIndexMarker062"/> is younger (available since 2014) than <code class="inlineCode">bpython</code> (available since 2009), so it might be slightly less mature and feature rich. It is, however, very <a id="_idIndexMarker063"/>actively developing and certainly worth mentioning. While there is (currently) no code reload feature similar to the one in <code class="inlineCode">bpython</code>, there are several <a id="_idIndexMarker064"/>other useful features that <code class="inlineCode">bpython</code> currently lacks:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Multiline code editing</li>&#13;
      <li class="bulletList">Mouse support</li>&#13;
      <li class="bulletList">Both Vi and Emacs key bindings</li>&#13;
      <li class="bulletList">Syntax checking while typing</li>&#13;
      <li class="bulletList">A history browser</li>&#13;
      <li class="bulletList">Output highlighting</li>&#13;
    </ul>&#13;
    <p class="normal">These features are all ones you need to experience yourself, though; a book is not the right medium for a demonstration in this case. In any case, this interpreter is certainly worth looking at.</p>&#13;
    <p class="normal">Installation can be done with a simple <code class="inlineCode">pip install</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install ptpython&#13;
</code></pre>&#13;
    <p class="normal">After installing, you can run it using the <code class="inlineCode">ptpython</code> command:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> ptpython&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span>&#13;
</code></pre>&#13;
    <p class="normal">Once the interpreter is running, you can configure <code class="inlineCode">ptpython</code> using the built-in menu (press <em class="italic">F2</em>). In that <a id="_idIndexMarker065"/>menu,<a id="_idIndexMarker066"/> you can configure and enable/disable features such as completion for dictionaries, completion while typing, input validation, color depth, and highlighting colors.</p>&#13;
    <h2 id="_idParaDest-53" class="heading-2">IPython and Jupyter</h2>&#13;
    <p class="normal">The<a id="_idIndexMarker067"/> IPython interpreter<a id="_idIndexMarker068"/> is a completely different beast from the previously mentioned interpreters. In addition to being the interpreter with the most features, it is part of a whole ecosystem of packages that includes parallel computing, integrations with visual toolkits, interactive widgets, and a web-based interpreter (Jupyter).</p>&#13;
    <p class="normal">Some key <a id="_idIndexMarker069"/>features of the IPython interpreter:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Easy object introspection</li>&#13;
      <li class="bulletList">Output formatting (instead of <code class="inlineCode">repr()</code>, IPython calls <code class="inlineCode">pprint.pformat()</code>)</li>&#13;
      <li class="bulletList">Command history can be accessed through variables and magic methods from both new and old sessions</li>&#13;
      <li class="bulletList">Saving and loading sessions</li>&#13;
      <li class="bulletList">A whole range of magic commands and shortcuts</li>&#13;
      <li class="bulletList">Access to regular shell commands such as <code class="inlineCode">cd</code> and <code class="inlineCode">ls</code></li>&#13;
      <li class="bulletList">Extensible tab completion, supporting not just Python methods and functions but filenames as well</li>&#13;
    </ul>&#13;
    <p class="normal">Several of the other features of the IPython project are covered in the chapters about debugging, multiprocessing, scientific programming, and machine learning.</p>&#13;
    <p class="normal">The basic installation of IPython can be done using a <code class="inlineCode">pip install</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install ipython&#13;
</code></pre>&#13;
    <p class="normal">Installing through Anaconda is also a good option, though, especially if you are planning to use a lot of data science packages, which are often far easier to install and manage through <code class="inlineCode">conda</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> conda install ipython&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-54" class="heading-3">Basic interpreter usage</h3>&#13;
    <p class="normal">The<a id="_idIndexMarker070"/> IPython interpreter can be used in a similar way to the other interpreters, but has somewhat different output from the other interpreters. Here’s an example covering some of the key features:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> ipython&#13;
Python 3.9.6 (default, Jun 29 2021, 05:25:02)&#13;
Type 'copyright', 'credits' or 'license' for more information&#13;
IPython 7.25.0 -- An enhanced Interactive Python. Type '?' for help.&#13;
In [1]: sandwich = dict(spam=2, eggs=1, sausage=1)&#13;
&#13;
In [2]: sandwich&#13;
Out[2]: {'spam': 2, 'eggs': 1, 'sausage': 1}&#13;
&#13;
In [3]: sandwich = dict(spam=2, eggs=1, sausage=1, bacon=1, chees&#13;
   ...: e=2, lettuce=1, tomatoes=3, pickles=1)&#13;
&#13;
In [4]: sandwich&#13;
Out[4]:&#13;
{'spam': 2,&#13;
 'eggs': 1,&#13;
 'sausage': 1,&#13;
 'bacon': 1,&#13;
 'cheese': 2,&#13;
 'lettuce': 1,&#13;
 'tomatoes': 3,&#13;
 'pickles': 1}&#13;
&#13;
In [5]: _i1&#13;
Out[5]: 'sandwich = dict(spam=2, eggs=1, sausage=1)'&#13;
&#13;
In [6]: !echo "$_i2"&#13;
sandwich&#13;
</code></pre>&#13;
    <p class="normal">The first line is a simple variable declaration; nothing special there. The second line shows the print output for the variable declared in the first line. </p>&#13;
    <p class="normal">Now we declare a similar dictionary with more items in it. You can see that the output is now automatically formatted and split over multiple lines for readability if the line is too long for the screen. This effectively comes down to <code class="inlineCode">print()</code> versus <code class="inlineCode">pprint.pprint()</code>.</p>&#13;
    <p class="normal">At <code class="inlineCode">In [5]: _i1,</code> we see one of the useful internal variables, the input line. The <code class="inlineCode">_i&lt;N&gt;</code> and <code class="inlineCode">_ih[&lt;N&gt;]</code> variables give you the lines you wrote. Similarly, the last three entered lines are available through <code class="inlineCode">_i</code>, <code class="inlineCode">_ii</code>, and <code class="inlineCode">_iii</code>, respectively.</p>&#13;
    <p class="normal">If the <a id="_idIndexMarker071"/>command generated output, it will be available through <code class="inlineCode">_&lt;N&gt;</code>. And the last three output results are available through <code class="inlineCode">_</code>, <code class="inlineCode">__</code>, and <code class="inlineCode">___</code>.</p>&#13;
    <p class="normal">Finally, we call the external shell function <code class="inlineCode">echo</code> by prefixing the line with <code class="inlineCode">!</code> while passing along the Python variable <code class="inlineCode">_i2</code>. When executing external shell functions, we can pass along Python variables by prefixing them with a <code class="inlineCode">$</code>.</p>&#13;
    <h3 id="_idParaDest-55" class="heading-3">Saving and loading sessions</h3>&#13;
    <p class="normal">The <a id="_idIndexMarker072"/>ability to save and load a session so you can always come <a id="_idIndexMarker073"/>back to it is an incredibly useful feature. As is usually the case with IPython, there are several ways of achieving this goal. First of all, every session is already automatically saved for you, requiring no effort whatsoever. To load the previous session, you can run:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">In [1]: %load ~1/&#13;
&#13;
In [2]: # %load ~1/&#13;
   ...: sandwich = dict(spam=2, eggs=1, sausage=1)&#13;
&#13;
In [3]: sandwich&#13;
Out[3]: {'spam': 2, 'eggs': 1, 'sausage': 1}&#13;
</code></pre>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">This command uses the same syntax as the <code class="inlineCode">%history</code> command. Here is a quick overview of how the <code class="inlineCode">%history</code> syntax works:</p>&#13;
      <ul>&#13;
        <li class="bulletList"><code class="inlineCode">5</code>: Line 5</li>&#13;
        <li class="bulletList"><code class="inlineCode">-t 5</code>: Line 5 as pure Python (without IPython magic)</li>&#13;
        <li class="bulletList"><code class="inlineCode">10-20</code>: Lines 10 to 20</li>&#13;
        <li class="bulletList"><code class="inlineCode">10/20</code>: Session 10, line 20</li>&#13;
        <li class="bulletList"><code class="inlineCode">~0/</code>: Current session</li>&#13;
        <li class="bulletList"><code class="inlineCode">~1/10-20</code>: Previous session lines 10 to 20</li>&#13;
        <li class="bulletList"><code class="inlineCode">~5/-~2</code>: Everything from 5 sessions ago to 2 sessions ago</li>&#13;
      </ul>&#13;
    </div>&#13;
    <p class="normal">If you <a id="_idIndexMarker074"/>know that a session will be an important one and you want to make sure it gets saved, use <code class="inlineCode">%logstart</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">In [1]: %logstart&#13;
Activating auto-logging. Current session state plus future input saved.&#13;
Filename       : ipython_log.py&#13;
Mode           : rotate&#13;
Output logging : False&#13;
Raw input log  : False&#13;
Timestamping   : False&#13;
State          : active&#13;
</code></pre>&#13;
    <p class="normal">As can be <a id="_idIndexMarker075"/>seen in the output, this feature is configurable. By default, it will write to (and rotate, if it exists) <code class="inlineCode">ipython_log.py</code>. As soon as you run this command again, the previous logfile will be renamed to <code class="inlineCode">ipython_log.001~</code> and so on for the older files.</p>&#13;
    <p class="normal">Loading is done using the <code class="inlineCode">%load</code> command and will immediately reactivate auto-logging since it’s replaying that line as well:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">In [1]: %load ipython_log.py&#13;
&#13;
In [2]: # %load ipython_log.py&#13;
   ...: # IPython log file&#13;
   ...:&#13;
   ...: get_ipython().run_line_magic('logstart', '')&#13;
   ...:&#13;
Activating auto-logging. Current session state plus future input saved.&#13;
Filename       : ipython_log.py&#13;
Mode           : rotate&#13;
Output logging : False&#13;
Raw input log  : False&#13;
Timestamping   : False&#13;
State          : active&#13;
</code></pre>&#13;
    <p class="normal">Naturally, manually saving is also an option using <code class="inlineCode">%save</code>. I would recommend adding the <code class="inlineCode">-r</code> parameter so the session is saved as raw instead of a regular Python file. Let’s illustrate the difference:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">In [1]: %save session_filename ~0/&#13;
The following commands were written to file 'session_filename.py':&#13;
get_ipython().run_line_magic('save', 'session_filename ~0/')&#13;
&#13;
In [2]: %save -r raw_session ~0/&#13;
The following commands were written to file 'raw_session.ipy':&#13;
%save session_filename ~0/&#13;
%save -r raw_session ~0/&#13;
</code></pre>&#13;
    <p class="normal">If you don’t need<a id="_idIndexMarker076"/> to run the session from a regular<a id="_idIndexMarker077"/> Python interpreter, using the raw files is somewhat more legible.</p>&#13;
    <h3 id="_idParaDest-56" class="heading-3">Regular Python prompt/doctest mode</h3>&#13;
    <p class="normal">The <a id="_idIndexMarker078"/>default <code class="inlineCode">ipython</code> prompt is very useful but it can feel a little verbose at times and you can’t easily copy the results to a file for doctests (we will cover more about doctests in <em class="chapterRef">Chapter 10</em>, <em class="italic">Testing and Logging – Preparing for Bugs</em>). Because of that, it <a id="_idIndexMarker079"/>can be convenient to activate the <code class="inlineCode">%doctest_mode</code> magic function so your prompt looks like the familiar Python interpreter:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">In [1]: sandwich = dict(spam=2, eggs=1, sausage=1, bacon=1, chees&#13;
   ...: e=2, lettuce=1, tomatoes=3, pickles=1)&#13;
&#13;
In [2]: sandwich&#13;
Out[2]:&#13;
{'spam': 2,&#13;
 'eggs': 1,&#13;
 'sausage': 1,&#13;
 'bacon': 1,&#13;
 'cheese': 2,&#13;
 'lettuce': 1,&#13;
 'tomatoes': 3,&#13;
 'pickles': 1}&#13;
&#13;
In [3]: %doctest_mode&#13;
Exception reporting mode: Plain&#13;
Doctest mode is: ON&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich&#13;
{'spam': 2, 'eggs': 1, 'sausage': 1, 'bacon': 1, 'cheese': 2, 'lettuce': 1, 'tomatoes': 3, 'pickles': 1}&#13;
</code></pre>&#13;
    <p class="normal">As you can see, this also influences how the output is formatted, so it’s really similar to the regular<a id="_idIndexMarker080"/> Python shell. While<a id="_idIndexMarker081"/> magic functions can still be used, the output is nearly identical to the regular Python shell.</p>&#13;
    <h3 id="_idParaDest-57" class="heading-3">Introspection and help</h3>&#13;
    <p class="normal">One of the most <a id="_idIndexMarker082"/>useful shortcuts of IPython is <code class="inlineCode">?</code>. That is the shortcut for accessing the IPython help, object help, and object introspection. If you’re looking for an up-to-date overview of the IPython interpreter features, start by typing ? and start reading. If you’re planning to use IPython, I definitely recommend doing so.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">The <code class="inlineCode">?</code> and <code class="inlineCode">??</code> can be used both as a suffix and as a prefix. So, both <code class="inlineCode">?history</code> and <code class="inlineCode">history?</code> will return in the documentation for the <code class="inlineCode">%history</code> command.</p>&#13;
    </div>&#13;
    <p class="normal">Because the <code class="inlineCode">?</code> shortcut <a id="_idIndexMarker083"/>shows the documentation, it is useful for both regular Python objects and the magic functions in IPython. The magic functions are really not that magic; besides having a name that’s prefixed with a <code class="inlineCode">%</code>, they are just regular Python functions. In addition to <code class="inlineCode">?</code>, there is also <code class="inlineCode">??,</code> which attempts to show the source of the object:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">In [1]: import pathlib&#13;
&#13;
In [2]: pathlib.Path.name?&#13;
Type:        property&#13;
String form: &lt;property object at 0x10c540ef0&gt;&#13;
Docstring:   The final path component, if any.&#13;
&#13;
In [3]: pathlib.Path.name??&#13;
Type:        property&#13;
String form: &lt;property object at 0x10c540ef0&gt;&#13;
Source:&#13;
# pathlib.Path.name.fget&#13;
@property&#13;
def name(self):&#13;
    """The final path component, if any."""&#13;
    parts = self._parts&#13;
    if len(parts) == (1 if (self._drv or self._root) else 0):&#13;
        return ''&#13;
    return parts[-1]&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-58" class="heading-3">Autocompletion</h3>&#13;
    <p class="normal">Autocompletion<a id="_idIndexMarker084"/> is where <code class="inlineCode">ipython</code> really gets interesting. In addition to the regular code completion, <code class="inlineCode">ipython</code> will complete filenames and LaTeX/Unicode for special characters as well.</p>&#13;
    <p class="normal">The really useful part starts when creating your own objects, though. While regular automatic autocompletion will work without a hitch, you can customize the autocompletion to only return specific items, or do dynamic lookups from a database if needed. Usage is certainly easy enough:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">In [1]: class CompletionExample:&#13;
   ...:     def __dir__(self):&#13;
   ...:         return ['attribute', 'autocompletion']&#13;
   ...:&#13;
   ...:     def _ipython_key_completions_(self):&#13;
   ...:         return ['key', 'autocompletion']&#13;
   ...:&#13;
&#13;
In [2]: completion = CompletionExample()&#13;
&#13;
In [3]: completion.a&lt;TAB&gt;&#13;
                     attribute&#13;
                     autocompletion&#13;
&#13;
In [4]: completion['aut&lt;TAB&gt;&#13;
                        %autoawait     %autoindent&#13;
                        %autocall      %automagic&#13;
                        autocompletion&#13;
</code></pre>&#13;
    <p class="normal">Now for the LaTeX/Unicode character completion. While this might not be something you need to use that often, I find it really useful in the cases that you do need it:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">In [1]: '\pi&lt;TAB&gt;'&#13;
&#13;
In [1]: 'π&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-59" class="heading-3">Jupyter</h3>&#13;
    <p class="normal">The <a id="_idIndexMarker085"/>Jupyter <a id="_idIndexMarker086"/>project offers an amazing web-based interpreter (Jupyter Notebook) that makes Python much more accessible for people who need to<a id="_idIndexMarker087"/> write some scripts but aren’t programmers by trade. It allows a seamless mix of Python code, LaTeX, and other markup.</p>&#13;
    <p class="normal">The web-based interpreter isn’t the only or even most important feature of the Jupyter project, though. The biggest advantage of the Jupyter project is that it allows you to connect to remote systems (called “kernels”) from your local machine.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Originally, the project was part of the IPython project when <code class="inlineCode">ipython</code> was still a large monolithic application that contained all components internally. Since then, the IPython project has been split into multiple IPython projects and several projects under the Jupyter name. Internally, they are still using much of the same code base and Jupyter heavily depends on IPython.</p>&#13;
    </div>&#13;
    <p class="normal">Before we continue, we should look at the current structure of the Jupyter and IPython projects and <a id="_idIndexMarker088"/>describe the <a id="_idIndexMarker089"/>most important projects:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">jupyter</code>: The metapackage that contains all the Jupyter projects.</li>&#13;
      <li class="bulletList"><code class="inlineCode">notebook</code>: The web-based interpreter, which is part of the Jupyter project.</li>&#13;
      <li class="bulletList"><code class="inlineCode">lab</code>: The next-generation web-based interpreter offering multiple notebooks side by side and even supporting code embedded in other languages such as Markdown, R, and LaTeX.</li>&#13;
      <li class="bulletList"><code class="inlineCode">ipython</code>: The Python terminal interface with the magic functions.</li>&#13;
      <li class="bulletList"><code class="inlineCode">jupyter_console</code>: The Jupyter version of <code class="inlineCode">ipython</code>. </li>&#13;
      <li class="bulletList"><code class="inlineCode">ipywidgets</code>: Interactive widgets that can be used as user input in <code class="inlineCode">notebook</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">ipyparallel</code>: The library for easy parallel execution of Python code across multiple servers. There will be more about this in <em class="chapterRef">Chapter 14</em>, <em class="italic">Multiprocessing - When a Single CPU Core Is Not Enough</em>. </li>&#13;
      <li class="bulletList"><code class="inlineCode">traitlets</code>: The config system used by IPython and Jupyter, which allows you to create configurable objects with validation. There will be more about this in <em class="chapterRef">Chapter 8</em>, <em class="italic">Metaclasses - Making Classes (Not Instances) Smarter</em>.</li>&#13;
    </ul>&#13;
    <p class="normal"><em class="italic">Figure 2.1</em> shows the complexity and the size of the Jupyter and IPython projects and how they work together:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_02_01.png" alt="Architecture diagram of project relationships" width="772" height="912"/></figure>&#13;
    <p class="packt_figref">Figure 2.1: Jupyter and IPython project structure</p>&#13;
    <p class="normal">From this overview, you might wonder why both <code class="inlineCode">ipython</code> and <code class="inlineCode">jupyter console</code> exist. The difference is that <code class="inlineCode">ipython</code> runs completely locally in a single process, and <code class="inlineCode">jupyter console</code> runs <a id="_idIndexMarker090"/>everything on a remote kernel. When running locally, this <a id="_idIndexMarker091"/>means that Jupyter will automatically start a background processing kernel that any Jupyter application can connect to.</p>&#13;
    <p class="normal">The Jupyter project could easily fill several books by itself so we will cover only the most common features in this chapter. Additionally, <em class="chapterRef">Chapter 14</em> covers the multiprocessing aspect in more detail. And <em class="chapterRef">Chapter 15</em>, <em class="italic">Scientific Python and Plotting</em>, depends on Jupyter Notebook as well.</p>&#13;
    <h3 id="_idParaDest-60" class="heading-3">Installing Jupyter</h3>&#13;
    <p class="normal">First, let’s <a id="_idIndexMarker092"/>start with the installation. The installation is easy enough with a simple <code class="inlineCode">pip install</code> or <code class="inlineCode">conda install</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install --upgrade jupyterlab&#13;
</code></pre>&#13;
    <p class="normal">Now, all that’s left is to start it. Once you run the following command, your web browser should automatically open:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> jupyter lab&#13;
</code></pre>&#13;
    <p class="normal">Docker images are available as well if, for some reason, the installation gives you trouble or if you want an easy installation for a lot of dependency-heavy packages. For the data science chapter later in the book, the <code class="inlineCode">jupyter/tensorflow-notebook</code> Docker image is used:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> docker run -p 8888:8888 jupyter/tensorflow-notebook&#13;
</code></pre>&#13;
    <p class="normal">This will run the Docker image and forward port <code class="inlineCode">8888</code> to the running <code class="inlineCode">jupyter lab</code> so you can access it. Note that because of the default security, you will need to open <code class="inlineCode">jupyter lab</code> through the links provided in the console, which contains the randomly generated security token. It should look something like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">http://127.0.0.1:8888/?token=..........&#13;
</code></pre>&#13;
    <p class="normal">Once you have it up and running, you should see something like this in your browser:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_02_02.png" alt="" width="765" height="316"/></figure>&#13;
    <p class="packt_figref">Figure 2.2: Jupyter dashboard</p>&#13;
    <p class="normal">Now you can <a id="_idIndexMarker093"/>create a new notebook:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_02_03.png" alt="" width="239" height="273"/></figure>&#13;
    <p class="packt_figref">Figure 2.3: A new file in Jupyter</p>&#13;
    <p class="normal">And start typing with tab completion and all the features that are similar to <code class="inlineCode">ipython</code>:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_02_04.png" alt="" width="585" height="313"/></figure>&#13;
    <p class="packt_figref">Figure 2.4: Jupyter tab completion</p>&#13;
    <p class="normal">Within a <a id="_idIndexMarker094"/>notebook, you can have multiple cells. Each cell can have multiple lines of code and behave similarly to the IPython interpreter with one key difference: <em class="italic">only the last line</em> decides what is returned as the output, instead of each line being printed separately. But that doesn’t prevent you from using <code class="inlineCode">print()</code> functions.</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_02_05.png" alt="" width="526" height="115"/></figure>&#13;
    <p class="packt_figref">Figure 2.5: Jupyter output</p>&#13;
    <p class="normal">Each of these cells can be (re-)executed separately if needed, or all at once, to make sure the notebook still functions properly. In addition to code cells, Jupyter also supports several types of markup languages, such as Markdown, to add nicely formatted documentation.</p>&#13;
    <p class="normal">And because it’s a web-based format, you can attach all sorts of objects, such as videos, audio files, PDF files, images, and renders. LaTeX formulas, for example, are mostly impossible to<a id="_idIndexMarker095"/> render in a normal interpreter, but with Jupyter, rendering a LaTeX formula is easily possible:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_02_06.png" alt="" width="614" height="170"/></figure>&#13;
    <p class="packt_figref">Figure 2.6: A LaTeX formula in Jupyter</p>&#13;
    <p class="normal">Lastly, we have interactive widgets, which are one of the best features of using notebooks over a regular shell session:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_02_07.png" alt="" width="614" height="296"/></figure>&#13;
    <p class="packt_figref">Figure 2.7: Jupyter widgets</p>&#13;
    <p class="normal">By moving the slider, the function will be called again and the result will be immediately updated. This is <a id="_idIndexMarker096"/>extremely useful when debugging functions. In the chapter about user interfaces, you will learn how to create our own.</p>&#13;
    <h3 id="_idParaDest-61" class="heading-3">IPython summary</h3>&#13;
    <p class="normal">The entire list of features in the IPython and Jupyter projects could easily fill several books by itself, so we have only glossed over a very small portion of what the interpreter supports. </p>&#13;
    <p class="normal">Later chapters will cover some other parts of the project, but the IPython documentation is your friend. The documentation is really detailed and largely up to date.</p>&#13;
    <p class="normal">An overview of some of the<a id="_idIndexMarker097"/> shortcuts/magic functions that you’ll want<a id="_idIndexMarker098"/> to look at follows:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">%quickref</code>: A quick reference for most of the interpreter features and a list of the magic functions.</li>&#13;
      <li class="bulletList"><code class="inlineCode">%cd</code>: Change the current working directory for your <code class="inlineCode">ipython</code> session.</li>&#13;
      <li class="bulletList"><code class="inlineCode">%paste</code>: Paste a pre-formatted code block from the clipboard so your indentation is pasted correctly and not mutilated/clobbered due to auto-indentation.</li>&#13;
      <li class="bulletList"><code class="inlineCode">%edit</code>: Open an external editor for easy editing of code blocks. This is very useful when quickly testing multiline code blocks. The <code class="inlineCode">%edit -p</code> command, for example, will re-edit the previous (<code class="inlineCode">-p</code>) code block.</li>&#13;
      <li class="bulletList"><code class="inlineCode">%timeit</code>: A shortcut to quickly benchmark a line of Python code using the <code class="inlineCode">timeit</code> module.</li>&#13;
      <li class="bulletList"><code class="inlineCode">?</code>: Look at the documentation for any object.</li>&#13;
      <li class="bulletList"><code class="inlineCode">??</code>: Look at the source for any Python object. Native methods such as <code class="inlineCode">sum()</code> are compiled C code, so the source can’t be fetched easily.</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-62" class="heading-1">Exercises</h1>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">The <code class="inlineCode">rlcompleter</code> enhancement we created currently only handles dictionaries. Try and extend the code so it supports lists, strings, and tuples as well.</li>&#13;
      <li class="numberedList">Add colors to the completer (hint: use <code class="inlineCode">colorama</code> for the coloring).</li>&#13;
      <li class="numberedList">Instead of manually completing using our own object introspection, try and use the <code class="inlineCode">jedi</code> library for autocompletion, which does static code analysis.<div class="note">&#13;
          <p class="normal">Static code analysis inspects code without executing it. This means it’s entirely safe to run, even on foreign code, as opposed to the autocompletion we wrote earlier, which runs the code in <code class="inlineCode">object.keys()</code>.</p>&#13;
        </div>&#13;
      </li>&#13;
      <li class="numberedList">Try to create a <code class="inlineCode">Hello &lt;ipywidget&gt;</code> so the name of the person can be edited through a notebook without code changes.</li>&#13;
      <li class="numberedList">Try and create a script that will look for a given pattern through all of your previous <code class="inlineCode">ipython</code> sessions.</li>&#13;
</ol>&#13;
      <div class="note">&#13;
          <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_2.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
        </div>&#13;
      &#13;
    <h1 id="_idParaDest-63" class="heading-1">Summary</h1>&#13;
    <p class="normal">This chapter has shown you several of the available Python interpreters and some of the pros and cons. Additionally, you have had a small glimpse of what IPython and Jupyter can offer us. <em class="chapterRef">Chapter 15</em>, <em class="italic">Scientific Python and Plotting</em>, almost exclusively uses Jupyter Notebooks and demonstrates a few more powerful features, such as plotting integration.</p>&#13;
    <p class="normal">For most generic Python programmers, I would suggest using either <code class="inlineCode">bpython</code> or <code class="inlineCode">ptpython</code>, since they are really fast and lightweight interpreters to (re-)start that still offer a lot of useful features.</p>&#13;
    <p class="normal">If your focus is more on scientific programming and/or handling large datasets in your shell, then IPython or JupyterLab are probably more useful. These are far more powerful tools, but they come at the cost of having slightly higher start up times and system requirements. I personally use both depending on the use case. When testing a few simple lines of Python and/or verifying the behavior of a small code block, I mostly use <code class="inlineCode">bpython</code>/<code class="inlineCode">ptpython</code>. When working with larger blocks of code and/or data, I tend to use IPython (or <code class="inlineCode">ptipython</code>) or even JupyterLab.</p>&#13;
    <p class="normal">The next chapter covers the Python style guide, which rules are important, and why they matter. Readability is one of the most important aspects of the Python philosophy, and you will learn methods and styles for writing cleaner and more readable Python code. In short, you will learn what Pythonic code is and how to write it.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>