<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Drawing an Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Drawing an Application</h1></div></div></div><p>We are now on to developing our last major Tkinter application. In this project, we will develop a drawing application, making extensive use of the Tkinter Canvas widget while applying everything else that we have learned so far.</p><div class="section" title="Mission Briefing"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Mission Briefing</h1></div></div></div><p>Our<a id="id501" class="indexterm"/> drawing program will enable the user to draw basic shapes such as lines, circles, rectangles, and polygons. It will also let the user draw with the brush tool using different colors that can be chosen from the color palette.</p><p>In its final form, our drawing program will look like the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_06_01.jpg" alt="Mission Briefing"/></div><div class="section" title="Why Is It Awesome?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec120"/>Why Is It Awesome?</h2></div></div></div><p>While the<a id="id502" class="indexterm"/> application itself is rudimentary, it is sufficient to demonstrate some important aspects related to GUI programming.</p><p>This project aims to drive home two important lessons. First, we will experience the power of the Canvas widget. Second, we will learn how to develop higher-level custom GUI frameworks for our applications.</p><p>As we<a id="id503" class="indexterm"/> shall see, custom GUI frameworks enable us to develop programs rapidly with minimal amount of code repetition.</p><p>By the end of this project, you should not only be in a position to extend this application to add many more features, but you should also be able to take up and implement GUI projects of increasing complexity.</p></div><div class="section" title="Your Hotshot Objectives"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec121"/>Your Hotshot Objectives</h2></div></div></div><p>The key learning objectives for this project can be outlined as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learning<a id="id504" class="indexterm"/> to build custom GUI frameworks for rapid application development</li><li class="listitem" style="list-style-type: disc">Writing small unit tests for our code</li><li class="listitem" style="list-style-type: disc">Understanding how to use inheritance in our projects</li><li class="listitem" style="list-style-type: disc">Getting to know of other Tkinter modules, such as <code class="literal">tkColorChooser</code></li><li class="listitem" style="list-style-type: disc">Creating and manipulating items on the Canvas widget</li><li class="listitem" style="list-style-type: disc">Working with the tk ComboBox widget</li><li class="listitem" style="list-style-type: disc">Getting to know the available <code class="literal">winfo</code> methods</li><li class="listitem" style="list-style-type: disc">Working with mouse events on the Canvas widget</li><li class="listitem" style="list-style-type: disc">Reinforcing things that we have learned in previous projects</li></ul></div></div><div class="section" title="Mission Checklist"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec122"/>Mission Checklist</h2></div></div></div><p>If you have developed the game of chess, you might have installed the <span class="strong"><strong>Python Imaging Library</strong></span> (<span class="strong"><strong>PIL</strong></span>)<a id="id505" class="indexterm"/> to render PNG files. This is the only external dependency for our program. If you<a id="id506" class="indexterm"/> haven't already done so, download and install PIL from:</p><p>
<a class="ulink" href="http://www.pythonware.com/products/pil/">http://www.pythonware.com/products/pil/</a>
</p><p>If you are working on windows x64 (64 bit) or MacOSX machine, you may instead need to install and work with Pillow, which is a replacement for PIL available at:</p><p>
<a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow">http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow</a>
</p><p>After you have installed the package, go to your Python interactive prompt and type:</p><p>
<code class="literal">&gt;&gt;from PIL import ImageTk</code>
</p><p>If this executes without any error messages, you are ready to make our drawing application.</p></div></div></div>
<div class="section" title="Developing a bare bone GUI framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Developing a bare bone GUI framework</h1></div></div></div><p>One of <a id="id507" class="indexterm"/>the most important lessons aimed in this project is to learn to develop custom GUI frameworks. Tkinter in itself is a GUI framework. However, the kind of framework we intend to build here is a higher-level framework, built on top of Tkinter to suit our custom programming needs.</p><p>We will not develop a full-blown framework. Rather, we will develop only a small segment of it to give you a flavor of building a custom framework.</p><div class="section" title="Prepare for Lift Off"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec123"/>Prepare for Lift Off</h2></div></div></div><p>So why do we need another framework on top of Tkinter?</p><p>Consider a large program which has say 10 different menus, each menu having say 10 menu items. We will have to then write 100 lines of code simply to display these 100 menu items.</p><p>You not only need to make each widget by hand, but also have to link each of them manually to other commands besides having to set tons of options for each of them.</p><p>If we keep doing this for all our widgets, our GUI programming becomes an exercise in typing. Every extra line of code that you write adds to the program complexity, in a sense that it becomes more difficult for someone else to read, maintain, modify, and/or debug the code.</p><p>This is where developing a custom framework comes to our aid. Let's see what it means.</p><p>Assume that we anticipate that our drawing program will have a large number of menu items. Now we know how to add menu and menu items. Each new menu item would take at least one line of code to display.</p><p>To avoid writing so many lines of code, let's first make a framework to address this.</p><p>To ease the process of menu creation, we will write a piece of code that takes menu items listed as a tuple, and converts it to an equivalent menu code.</p><p>So given a tuple as follows:</p><div class="informalexample"><pre class="programlisting">menuitems = ('File- &amp;New/Ctrl+N/self.new_file, &amp;Open/Ctrl+O/self.open_file','Edit- Undo/Ctrl+Z/self.undo, Sep','About- About//self.about')</pre></div><p>should produce the corresponding menu items, where the first item of the string (before dash (<code class="literal">-</code>)) represents the menu button, and each subsequent part of string separated by commas represents one menu item, its accelerator key, and the attached command callback. The position of ampersand symbol (<code class="literal">&amp;</code>) represents the position of the shortcut key to be underlined.</p><p>We also<a id="id508" class="indexterm"/> need to take care of adding separators between our menu items. To add a separator, we would add the string <code class="literal">Sep</code> at positions where it is required. More precisely, the string <code class="literal">Sep</code> must be capitalized.</p><p>In short, passing this tuple through our method should produce a GUI, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_06_02.jpg" alt="Prepare for Lift Off"/></div><p>To extend our menu items, all we would need to do is to extend the preceding tuple and simultaneously adding the corresponding command callback method.</p></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec124"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – creating the GUI framework class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec86"/>Step 1 – creating the GUI framework class</h3></div></div></div><p>We build our framework in a file named <code class="literal">framework.py</code>, where we define a new class named <code class="literal">GUIFramework</code> as follows:</p><div class="informalexample"><pre class="programlisting">import Tkinter as tk
class GUIFramework(object):
	menuitems = None
	def __init__(self, root):
		self.root = root
		if self.menuitems is not None:
			self.build_menu()</pre></div></div><div class="section" title="Step 2 – creating menu builder"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec87"/>Step 2 – creating menu builder</h3></div></div></div><p>The two methods of <code class="literal">GUIFramework </code>that are used to create menu builder are as follows:</p><div class="informalexample"><pre class="programlisting">def build_menu(self):
        self.menubar = tk.Menu(self.root)
        for v in self.menuitems:
            menu = tk.Menu(self.menubar, tearoff=0)
            label, items = v.split('-')
            items = map(str.strip, items.split(','))
            for item in items:
                self.__add_menu_command(menu, item)
            self.menubar.add_cascade(label=label, menu=menu)
        self.root.config(menu=self.menubar)
            
    def __add_menu_command(self, menu, item):
        if item == 'Sep':
            menu.add_separator()
        else:
            name, acc, cmd = item.split('/')
            try:
                underline = name.index('&amp;')
                name = name.replace('&amp;', '', 1)
            except ValueError:
                underline = None
            menu.add_command(label=name, underline=underline,
                           accelerator=acc, command=eval(cmd))</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id509" class="indexterm"/>method, <code class="literal">build_menu</code>, operates on a tuple by the name <code class="literal">self.menubar</code>, which must specify all desired menu and menu items in the exact format, as previously discussed.</li><li class="listitem" style="list-style-type: disc">It iterates through each item in the tuple, splitting the item based on <code class="literal">-</code>delimiter, building the top-menu button for each item left to the <code class="literal">-</code> delimiter.</li><li class="listitem" style="list-style-type: disc">It then splits the second part of the string based on <code class="literal">,</code>(comma) delimiter.</li><li class="listitem" style="list-style-type: disc">It then iterates through this second part, creating menu items for each of the parts, adding the accelerator key, command callback, and underline key using another method, <code class="literal">__add_menu_command</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">__add_menu_command </code>method iterates through the string and adds a separator if it finds the string <code class="literal">Sep</code>. If not, it next searches for ampersand (<code class="literal">&amp;</code>) in the string. If it finds one, it calculates its index position and assigns it to the underline variable. It then replaces ampersand value with an empty string, because we do not want to display the ampersand in our menu item.</li><li class="listitem" style="list-style-type: disc">If ampersand is not found in a string, the code assigns <code class="literal">None</code> to the underline variable.</li><li class="listitem" style="list-style-type: disc">Finally, the code adds command callback, accelerator key, and underline value to the menu item.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>The<a id="id510" class="indexterm"/> logic that we used to define the menu builder is a completely arbitrary representation. We could have as well used a dictionary or a list. We could also have a separate logic altogether to represent our menu items, as long as it served the purpose of generating the menu items for us.</p></div></div></li></ul></div></div><div class="section" title="Step 3 – testing our new framework"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec88"/>Step 3 – testing our new framework</h3></div></div></div><p>Finally, we add a <code class="literal">TestThisFramework </code>class to our file to test if our framework in general and our <code class="literal">build_menu </code>method in particular, works as expected.</p><p>The code for the <code class="literal">TestThisFramework </code>class is as follows(<span class="emphasis"><em>framework.py</em></span>):</p><div class="informalexample"><pre class="programlisting">class TestThisFramework(GUIFramework):
    menuitems = (
        'File- &amp;New/Ctrl+N/self.new_file,&amp;Open/Ctrl+O/self.openFile',
        'Edit- Undo/Ctrl+Z/self.undo, Sep',
        'About- About//self.about'
    )    
    def new_file(self):
        print 'newfile tested OK'
    def openFile(self):
        print 'openfile tested OK'
    def undo(self):
        print 'undo tested OK'
    def about(self):
        print 'about tested OK'

if __name__ == '__main__':
	root= tk.Tk()
	app = TestThisFramework(root)
	root.mainloop()</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our <code class="literal">TestThisFramework </code>class inherits from the <code class="literal">GUIFramework </code>class, thus being in a position to use the <code class="literal">build_menu</code> method defined in the parent class.</li><li class="listitem" style="list-style-type: disc">It then adds a list of menu items, <code class="literal">menuitems</code>, and calls the method, <code class="literal">build_menu()</code>. It is important that the tuple be defined by the name, <code class="literal">menuitems</code>, because our <code class="literal">build_menu()</code> method is structured in the parent <code class="literal">GUIFramework </code>class to build menu only on the tuples named <code class="literal">menuitems</code>.</li><li class="listitem" style="list-style-type: disc">The test class also adds dummy commands to handle command callbacks for each of the menu items.</li><li class="listitem" style="list-style-type: disc">Running this test builds menu items as specified in the tuple. Try extending the tuple to add more menu items, and the framework will successfully include those items in the menu.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>Like we<a id="id511" class="indexterm"/> added code to generate menus for us, we could have added similar code for other widgets that we foresee to be repeatedly used in our program. But we will leave the framework development there itself and proceed to developing our drawing application.</p><p>Developing a framework for smaller programs may be overkill, but they are invaluable assets for longer programs. Hopefully, you should now be able to appreciate the benefits of writing your own custom frameworks for larger programs.</p></div></div></li></ul></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec125"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>Now that we have our <code class="literal">build_menu</code> ready, we can extend it to add as many menu items as required without having to write repetitive and similar code for each of them.</p><p>This ends our first iteration, where we laid the foundations for our custom GUI framework. We will not extend the framework further, but hopefully, you should now be in a position to extend it for other widgets, if required.</p></div><div class="section" title="Classified Intel"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec126"/>Classified Intel</h2></div></div></div><p>In this section, you also saw how our <code class="literal">TestThisFramework </code>class inherited features from our <code class="literal">GUIFramework </code>class. This is the first time we have used inheritance in our program.</p><p>So far, we have always passed objects created as classes as arguments to other classes, and then used them using the<code class="literal">.</code>(dot) notation. This is named <span class="strong"><strong>composition</strong></span>
<a id="id512" class="indexterm"/>.</p><p>With inheritance, we do not need to access methods of another class using the dot notation. We can use the methods of a superclass in the subclass as though they belong to the subclass.</p><p>Inheritance<a id="id513" class="indexterm"/> brings in the advantage of dynamic binding and polymorphism.</p><p>Dynamic binding means the method to be invoked is decided at runtime, thus providing greater flexibility to design of our code. Polymorphism implies that variables of a superclass hold a reference to an object created from itself or from any of its subclasses.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>Inheritance is fit for situations where the object of the subclass is of the same type as the superclass. In our example, menu items will remain the same whether you define them from the superclass or from the subclass. We, therefore, defined it in our superclass and inherited it in our subclass.</p><p>If, however, the object needs to appear or behave differently depending on an object's condition or state, composition is preferable.</p></div></div></div></div>
<div class="section" title="Structuring our drawing program"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Structuring our drawing program</h1></div></div></div><p>Let's now <a id="id514" class="indexterm"/>get down to setting the basic structure for our drawing program. We want to achieve a structure, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_06_03.jpg" alt="Structuring our drawing program"/></div><p>The structure here primarily consists of a top menu, which inherits from the GUI framework <code class="literal">build_menu</code> method that we created in the last iteration.</p><p>In addition, we create a top-bar frame towards the top(marked in yellow) with a method, <code class="literal">create_top_bar()</code>, and a toolbar frame to the left (marked with dark grey background) with <code class="literal">create_tool_bar()</code>. We also create a Canvas widget on the right side using the <code class="literal">create_drawing_canvas()</code> method, which is to serve as our drawing area.</p><p>We will <a id="id515" class="indexterm"/>not be reproducing the code for making the frames and canvas area, because we have done similar things in our previous projects and you should be comfortable making them by now. However, you can check the actual code in the file, <span class="emphasis"><em>6.01.py</em></span>.</p><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec127"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – importing framework"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec89"/>Step 1 – importing framework</h3></div></div></div><p>The first thing to note here is that we import our previously created framework module here and inherit its property in our main class, as follows:</p><div class="informalexample"><pre class="programlisting">import framework
class GUI(framework.GUIFramework):</pre></div><p>This enables us to use the <code class="literal">build_menu</code> method that we had defined in the framework as though it belongs to the child class.</p></div><div class="section" title="Step 2: building the top menu"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec90"/>Step 2: building the top menu</h3></div></div></div><p>Next, we define the actual menu items to build the top menu in a method defined <code class="literal">create_menu</code>, as follows:</p><div class="informalexample"><pre class="programlisting">def create_menu(self):
	self.menubar = Menu(self.root)
	self.menuitems = (
				'File- &amp;New/Ctrl+N/self.new_file,									&amp;Open/Ctrl+O/self.open_file, 
				Save/Ctrl+S/self.save, 
				SaveAs//self.save_as, 
				Sep, 
				Exit/Alt+F4/self.close', 
				'Edit- Undo/Ctrl+Z/self.undo, Sep',
				'About- About//self.about')
	self.build_menu()
	self.root.config(menu=self.menubar)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This actually creates three menu buttons: <span class="strong"><strong>File</strong></span>, <span class="strong"><strong>Edit</strong></span>, and <span class="strong"><strong>About</strong></span>, adding menu items to each of them as per preceding provided tuple.</li><li class="listitem" style="list-style-type: disc">Creating the menu also necessitates the creation of their associated command callbacks again, as defined in the preceding tuple. Accordingly, we create the methods associated with these command callbacks.</li><li class="listitem" style="list-style-type: disc">We will not reproduce the code for functionalities, such as <code class="literal">new_file</code>, <code class="literal">open_file</code>, <code class="literal">close</code>, <code class="literal">undo</code>, and <code class="literal">about</code>, because we have done similar coding in our previous projects. However, let's take a look at the undo and save operations.</li></ul></div></div><div class="section" title="Step 3 – undo operation on the Canvas widget"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec91"/>Step 3 – undo operation on the Canvas widget</h3></div></div></div><p>Recall that the Tkinter text widget has built-in support for unlimited undo/redo functionality. The Canvas widget, however, does not have this built-in feature.</p><p>Here,<a id="id516" class="indexterm"/> we implement a very basic undo operation, which lets us delete the last drawn item on the canvas as follows:</p><div class="informalexample"><pre class="programlisting">def undo(self, event=None):
	self.canvas.delete(self.currentobject)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Canvas widget provides a <code class="literal">widget.delete(items)</code> method that deletes a given item from the canvas.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>However, once you delete a canvas item, it is gone forever. You cannot restore it unless you have implemented a method which stores all the configurable options for that item before deleting.</p><p>While it is possible to implement fully-featured undo/redo operation by storing all configurations for an item being deleted in an undo stack, we will not implement it here, because it would be a deviation from our core topic.</p></div></div></li></ul></div></div><div class="section" title="Step 4 – saving canvas objects"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec92"/>Step 4 – saving canvas objects</h3></div></div></div><p>Tkinter lets you save canvas objects as a postscript file using the command <code class="literal">postscript()</code>, as follows (see <span class="emphasis"><em>code 6.01.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def actual_save(self):
	self.canvas.postscript(file=self.filename, colormode='color')
	self.root.title(self.filename)</pre></div><p>Note, however, that this command does not include the images and embedded widgets on the canvas.</p></div><div class="section" title="Step 5 – creating buttons in the left tool bar"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec93"/>Step 5 – creating buttons in the left tool bar</h3></div></div></div><p>Having <a id="id517" class="indexterm"/>coded command callbacks for all our menu items, let's now create buttons on the left toolbar. As per our original plan, we will need eight buttons on the toolbar. For now, let's show the button text as <code class="literal">0 </code>through <code class="literal">7</code> as follows:</p><div class="informalexample"><pre class="programlisting">def create_tool_bar_buttons(self):
	for i in range(8):
		self.button = Button(self.toolbar, text=i, command=lambda i=i:self.selected_tool_bar_item(i))
		self.button.grid(row=i/2, column=1+i%2, sticky='nsew')</pre></div><p>This creates eight buttons, arranging them in two columns depending on whether the button number is odd or even.</p></div><div class="section" title="Step 6 – adding command callback to buttons"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec94"/>Step 6 – adding command callback to buttons</h3></div></div></div><p>All buttons are attached to the same command callback, <code class="literal">selected_tool_bar_item</code>, which takes the button number as its argument. The callback method will be taken forward in the next iteration. However, for now, let's simply define the callback to print the number of the button that is clicked on, as follows:</p><div class="informalexample"><pre class="programlisting">def selected_tool_bar_item(self, i):
	print'You selected button {}'.format(i)</pre></div></div><div class="section" title="Step 7 – creating color palettes and color selection dialog"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec95"/>Step 7 – creating color palettes and color selection dialog</h3></div></div></div><p>Lastly, let's create two color palettes to keep track of two colors named background and foreground color.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>Tkinter provides a <code class="literal">tkColorChooser</code> module that pops up a color chooser dialog. When a user selects a color and clicks the <span class="strong"><strong>OK</strong></span> button, the module returns a tuple of the form:</p><div class="informalexample"><pre class="programlisting">((r,g,b), 'hex color code')</pre></div><p>The first element of the returned tuple is itself a tuple specifying the RGB coordinates for the given color, while the second element is the hexadecimal color code for the selected color.</p></div></div><p>The idea here is that clicking on a palette should open a color chooser. When a<a id="id518" class="indexterm"/> user selects a given color, it should update the foreground and background color attributes of the object, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_06_04.jpg" alt="Step 7 – creating color palettes and color selection dialog"/></div><p>The code to achieve this functionality is as follows(see <span class="emphasis"><em>code 6.01.py</em></span>):</p><div class="informalexample"><pre class="programlisting">from tkColorChooser import askcolor
	def create_color_pallete(self):
		self.colorpallete= Canvas(self.toolbar, height=55, width =55)
		self.colorpallete.grid(row=10, column=1, columnspan=2, 							pady=5, padx=3)
		self.backgroundpallete = 									self.colorpallete.create_rectangle	(15, 						15,48,48,tags="backgroundpallete", 							outline=self.background, fill=self.background)
		self.foregroundpallete = 									self.colorpallete.create_rectangle(1,1,33,33,tags="foregroundpallete", outline=self.foreground, fill=self.foreground)
		self.colorpallete.tag_bind(self.backgroundpallete, 
				"&lt;Button-1&gt;", self.set_background_color)
		self.colorpallete.tag_bind(self.foregroundpallete, 					"&lt;Button-1&gt;", self.set_foreground_color)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We add two different tags to each of the square pieces, and then use the <code class="literal">tag_bind</code> command to bind them to the click of mouse button over them. Take a note of the difference between widget-level<a id="id519" class="indexterm"/> binding(<code class="literal">widget.bind</code>) and the item-specific binding using the <code class="literal">tag_bind</code> method</li><li class="listitem" style="list-style-type: disc">To create the color palettes, we first create a Canvas widget within the toolbar frame. Within this canvas, we create two square areas using <code class="literal">canvas.create_rectangle</code> and bind them to a single mouse click event to call <code class="literal">set_background_color</code> and <code class="literal">set_foreground_color </code>respectively.</li></ul></div></div><div class="section" title="Step 8 – setting color of background and foreground palette"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec96"/>Step 8 – setting color of background and foreground palette</h3></div></div></div><p>Color of the background and foreground palette can be set as follows:</p><div class="informalexample"><pre class="programlisting">def set_background_color(self, event=None):
	self.background = askcolor()[-1]
	self.colorpallete.itemconfig(self.backgroundpallete, 					outline=self.background, fill=self.background) 

def set_foreground_color(self, event=None):
	self.foreground = askcolor()[-1]
	self.colorpallete.itemconfig(self.foregroundpallete,outline=self.foreground, fill=self.foreground)</pre></div></div><div class="section" title="Step 9 – displaying x and y coordinates of mouse movement"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec97"/>Step 9 – displaying x and y coordinates of mouse movement</h3></div></div></div><p>Finally, we add a static label to our toolbar frame to track the x and y coordinates of mouse movement. The actual tracking function will be created later but let's reserve the space by putting a static label for now, as follows:</p><div class="informalexample"><pre class="programlisting">self.curcoordlabel = Label(self.toolbar, text='x: 0\ny:0') self.curcoordlabel.grid(row=13, column=1, columnspan=2, pady=5, 						padx=1, sticky='w')</pre></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec128"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This completes our second iteration. In this iteration, we set the basic structure for our drawing program.</p><p>Importantly, we saw how to inherit features from our previously created framework to create menu items with minimal coding.</p><p>We also added the color selection dialog using the <code class="literal">tkColorChooser</code> module, which sets in two<a id="id520" class="indexterm"/> attributes, <code class="literal">self.background</code> and <code class="literal">self.foreground</code>, to be used application-wide.</p></div></div>
<div class="section" title="Handling mouse events"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Handling mouse events</h1></div></div></div><p>Before <a id="id521" class="indexterm"/>we let the user draw on the canvas, we need to bind the canvas event to mouse movements and mouse click.</p><p>Drawing or adding any item on to the Canvas widget first requires that we know the coordinates of the location where the item is to be placed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>The Canvas widget uses two coordinate systems to track positions:</p><p>
<span class="strong"><strong>Window coordinate system</strong></span>: Coordinate as expressed in relation to root window</p><p>
<span class="strong"><strong>Canvas coordinate system</strong></span>: Coordinate as expressed as position of item within the canvas</p><p>You can convert from window coordinates to canvas coordinates using the <code class="literal">canvasx</code> and <code class="literal">canvasy</code> methods as follows:</p><div class="informalexample"><pre class="programlisting">canx = canvas.canvasx(event.x)
cany = canvas.canvasy(event.y)</pre></div></div></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec129"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – binding mouse down, mouse motion, and mouse release over the canvas"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec98"/>Step 1 – binding mouse down, mouse motion, and mouse release over the canvas</h3></div></div></div><p>Drawing any item on the canvas would begin when the user clicks the mouse button. The drawing needs to continue till the mouse is moved with the button pressed and up to the time the mouse button is released.</p><p>Thus, we need to track the position of initial mouse down event. This is to be followed by tracking the mouse movement while the button is clicked on, up to the final button release event.</p><p>Accordingly, we add the following widget binding to our canvas (see <span class="emphasis"><em>code 6.02.py</em></span>):</p><div class="informalexample"><pre class="programlisting">self.canvas.bind("&lt;Button-1&gt;", self.mouse_down)
self.canvas.bind("&lt;Button1-Motion&gt;", self.mouse_down_motion)
self.canvas.bind("&lt;Button1-ButtonRelease&gt;", self.mouse_up)</pre></div></div><div class="section" title="Step 2 – calculating coordinates of mouse movement"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec99"/>Step 2 – calculating coordinates of mouse movement</h3></div></div></div><p>Having bound the mouse click, mouse movement, and mouse release events, it's now time to define their corresponding callback methods.</p><p>In<a id="id522" class="indexterm"/> particular, we want the <code class="literal">mouse_down</code> method to give us the x and y coordinates for the first mouse click event, as follows:</p><div class="informalexample"><pre class="programlisting">def mouse_down(self, event):
	self.currentobject = None
	self.lastx = self.startx = self.canvas.canvasx(event.x)
	self.lasty = self.starty = self.canvas.canvasy(event.y)</pre></div><p>We want to keep updating the <code class="literal">lastx</code> and <code class="literal">lasty</code> coordinates up till the mouse stops moving, as follows:</p><div class="informalexample"><pre class="programlisting">def mouse_down_motion(self, event):
	self.lastx = self.canvas.canvasx(event.x)
	self.lasty = self.canvas.canvasy(event.y)</pre></div><p>Our <code class="literal">mouse_up</code> method<a id="id523" class="indexterm"/> should make the final update to our <code class="literal">lastx</code> and <code class="literal">lasty</code> coordinates, as follows:</p><div class="informalexample"><pre class="programlisting">def mouse_up(self, event):
	self.lastx = self.canvas.canvasx(event.x)
	self.lasty = self.canvas.canvasy(event.y)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">mouse_down</code> method simply initializes the values of <code class="literal">startx</code>, <code class="literal">starty</code>, <code class="literal">lastx</code>, and <code class="literal">lasty</code> to the coordinates of the mouse click position.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">mouse_down_motion</code> method changes the value of <code class="literal">lastx</code> and <code class="literal">lasty</code> as the mouse motion keeps happening.</li><li class="listitem" style="list-style-type: disc">Finally, the <code class="literal">mouse_up </code>method sets the value of <code class="literal">lastx</code> and <code class="literal">lasty</code> as coordinates of the point where the mouse button is released.</li><li class="listitem" style="list-style-type: disc">Thus, using the three events: <code class="literal">mouse_down</code>, <code class="literal">mouse_down_motion</code>, and <code class="literal">mouse_up</code>, we manage to get the coordinates for starting point, coordinates for points through which the mouse pointer traverses, and the coordinates for the end point.</li><li class="listitem" style="list-style-type: disc">Now we can use these values to place any item on the canvas at the given coordinates.</li></ul></div></div><div class="section" title="Step 3 – updating the current mouse position label in the left tool bar"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec100"/>Step 3 – updating the current mouse position label in the left tool bar</h3></div></div></div><p>In addition, <a id="id524" class="indexterm"/>we would also like to track the motion of the mouse over the canvas, even when the mouse button is not clicked down. We need to track this to update the current mouse position in the left toolbar. This is simple, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">self.canvas.bind("&lt;Motion&gt;", self.show_current_coordinates)

def show_current_coordinates(self, event = None):
	lx = self.canvas.canvasx(event.x)
	ly = self.canvas.canvasy(event.y)
	cord = 'x: %d \ny: %d '%(lx, ly)
	self.curcoordlabel.config(text = cord)</pre></div><p>This code will ensure that any mouse movement over the canvas updates the label in the left toolbar with the current position of mouse.</p></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec130"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>Now our Canvas widget has become responsive to mouse movements and mouse clicks. Every time we click the mouse button over the canvas and drag the mouse pointer to a new place, the values of <code class="literal">startx</code>, <code class="literal">starty</code>, <code class="literal">lastx</code> and <code class="literal">lasty </code>get updated to reflect the coordinates for the mouse movement.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>Together, these coordinates constitute what is called the bounding box for an item. In fact, if there are items on a canvas, you can retrieve the coordinates for any given item using the API:</p><div class="informalexample"><pre class="programlisting">canvas.bbox(item=itemName)</pre></div><p>This returns the coordinates as a four-item tuple.</p><p>If the item name is not specified, this method returns the bounding box for all elements on the canvas.</p></div></div><p>Now that we have the coordinates available, we can think of drawing items on the canvas. <a id="id525" class="indexterm"/>We do some drawing in the next iteration.</p></div></div>
<div class="section" title="Drawing items on the canvas"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Drawing items on the canvas</h1></div></div></div><p>Let's now draw some items on the canvas. The Canvas widget natively supports drawing the following items:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Item</p>
</th><th style="text-align: left" valign="bottom">
<p>Code for adding the item</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Arc<a id="id526" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">w.create_arc( bbox, **options)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Bitmap<a id="id527" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">w.create_bitmap( bbox, **options)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Image<a id="id528" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">w.create_image( bbox, **options)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Line<a id="id529" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">w.create_line( bbox, **options)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Oval<a id="id530" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">w.create_oval( bbox, **options)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Polygon<a id="id531" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">w.create_ploygon( bbox, **options)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Rectangle <a id="id532" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">w.create_rectangle( bbox, **options)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Text<a id="id533" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">w.create_text( bbox, **options)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Window<a id="id534" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">w.create_window( bbox, **options)</code>
</p>
</td></tr></tbody></table></div><p>Let us add the<a id="id535" class="indexterm"/> ability to draw lines, rectangles, and ovals to our drawing program. We will also add a brush stroke feature to our program, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_06_05.jpg" alt="Drawing items on the canvas"/></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec131"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – creating a tuple of methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec101"/>Step 1 – creating a tuple of methods</h3></div></div></div><p>We <a id="id536" class="indexterm"/>first create a tuple of methods that we intend to define here as follows:</p><div class="informalexample"><pre class="programlisting">all_toolbar_functions = ('draw_line', 'draw_rectangle', 'draw_oval', 'draw_brush')</pre></div><p>Doing so ensures that we do not have to call each method explicitly from our code. We can instead use the index of the tuple to retrieve the method name and call it dynamically using:</p><div class="informalexample"><pre class="programlisting">getattr(self, self.all_toolbar_functions[index])</pre></div><p>This makes sense here, because we would eventually add more features to our drawing program by simply extending our <code class="literal">all_toolbar_functions</code>.</p></div><div class="section" title="Step 2 – add icons to our toolbar buttons"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec102"/>Step 2 – add icons to our toolbar buttons</h3></div></div></div><p>Our next task here is to add icons on the left toolbar for drawing these items.</p><p>We add the icons to our <code class="literal">icons</code> folder. We also ensure to rename each icon file<a id="id537" class="indexterm"/> to the name of the method called by it. This naming again helps in calling the methods dynamically, and this style of programming is what you could call programming using <a id="id538" class="indexterm"/>
<span class="strong"><strong>conventions over configuration</strong></span>.</p><p>Our current <code class="literal">create_tool_bar_buttons()</code>method creates eight buttons using a for loop. However, we will now modify our <code class="literal">create_tool_bar_buttons()</code>method<a id="id539" class="indexterm"/> to use the <code class="literal">enumerate()</code> method to loop overall items in our <code class="literal">all_toolbar_functions</code> tuple to add icons for each of the methods, as follows (see <span class="emphasis"><em>code 6.03.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def create_tool_bar_buttons(self):
	for i, item in enumerate(self.all_toolbar_functions):
		tbicon = PhotoImage(file='icons/'+item+'.gif')
		self.button = Button(self.toolbar, image=tbicon, 					command=lambda i=i:self.selected_tool_bar_item(i))
		self.button.grid(row=i/2, column=1+i%2, sticky='nsew')
		self.button.image = tbicon</pre></div></div><div class="section" title="Step 3 – keeping a tab on currently selected button"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec103"/>Step 3 – keeping a tab on currently selected button</h3></div></div></div><p>Next, we modify the method, <code class="literal">selected_tool_bar_item(i)</code>; the only purpose of which is to keep a tab on the currently selected button. Having this information, we can later call the associated method from <code class="literal">all_toolbar_functions </code>by using this index, as follows (see <span class="emphasis"><em>code 6.03.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def selected_tool_bar_item(self, i):
	self.selected_toolbar_func_index = i</pre></div></div><div class="section" title="Step 4 – code for drawing line, rectangle, and oval shapes"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec104"/>Step 4 – code for drawing line, rectangle, and oval shapes</h3></div></div></div><p>Now is the time to code the methods to draw these basic shapes. Note that this will not automatically create the drawings. Eventually, these methods will have to be called from somewhere to actually make the drawings. We will do that in step 6.</p><div class="informalexample"><pre class="programlisting">def draw_line(self, x, y, x2, y2):
	self.currentobject = self.canvas.create_line(x, y, x2, y2, fill= 					self.foreground )
	
def draw_rectangle(self, x, y, x2, y2):
	self.currentobject = self.canvas.create_rectangle(x, y, x2, 						y2, fill= self.foreground)
def draw_oval(self, x, y, x2, y2):
	self.currentobject=  self.canvas.create_oval(x, y, x2, 						y2, fill= self.foreground)</pre></div></div><div class="section" title="Step 5 – code for drawing in continuous stroke"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec105"/>Step 5 – code for drawing in continuous stroke</h3></div></div></div><p>Drawing in a continuous stroke is similar to drawing lines, but the fresh lines are redrawn after every small change in coordinates. In the current state of things, the value of <code class="literal">lastx </code>and <code class="literal">lasty</code> are only updated when the mouse button is released. But here we need to update the value of <code class="literal">lastx</code> and <code class="literal">lasty</code>, not on mouse release, but on mouse motion. To achieve this, we bind the mouse motion to a newly defined method <code class="literal">draw_brush_update_xy</code>, which updates the x and y coordinate in every subsequent loop turn.</p><p>Earlier, we had bound mouse down motion to another method named <code class="literal">mouse_down_motion</code>. For drawing continuous stroke, we will now bind it to a method named <code class="literal">draw_brush_update_xy</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>Adding an event binding to more than one method wipes away the previous binding, whereby the new binding replaces any existing binding. Thus, when you exit out of the <code class="literal">draw_brush</code> loop, you need to rebind the event back to the <code class="literal">mouse_down_motion</code> method.</p><p>Alternatively, you can use <code class="literal">add="+"</code> as an additional argument to keep more than one binding to the same event as follows:</p><div class="informalexample"><pre class="programlisting">mywidget.bind("&lt;SomeEvent&gt;", method1, add="+")
mywidget.bind("&lt;SameEvent&gt;", method2, add="+")</pre></div></div></div><p>Thus, we create a loop where the <code class="literal">draw_brush</code> method calls another method, <code class="literal">draw_brush_update_xy</code>, on successive mouse motions to update the x and y coordinates as follows (see <span class="emphasis"><em>code 6.03.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def draw_brush(self, x, y, x2, y2):
	if not self.all_toolbar_functions[ 							self.selected_toolbar_func_index] == 'draw_brush':
		self.canvas.bind("&lt;Button1-Motion&gt;",								self.mouse_down_motion)
		return# if condition to break out of draw_brush loop
	self.currentobject = 									self.canvas.create_line(x,y,x2,y2,fill=self.foreground)

self.canvas.bind("&lt;B1-Motion&gt;", self.draw_brush_update_xy)

def draw_brush_update_xy(self, event):
	self.startx, self.starty = self.lastx, self.lasty
	self.lastx, self.lasty = event.x, event.y
	self.draw_brush(self.startx, self.starty,self.lastx, self.lasty)</pre></div><p>If the Draw Brush button is unselected, we break out of the loop and rebind the mouse motion back to the canvas <code class="literal">mouse_down_motion</code>.</p></div><div class="section" title="Step 6 – executing code dynamically"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec106"/>Step 6 – executing code dynamically</h3></div></div></div><p>We <a id="id540" class="indexterm"/>have planned to execute methods dynamically, based on index from the names of methods given in a tuple named <code class="literal">all_toolbar_functions</code>. However, the names are stored as strings, and we just cannot take a piece of string and expect Python to evaluate it. In order to that, we will use Python's built-in <code class="literal">getattr()</code>method.</p><p>We now define a method that takes a string and makes it suitable for execution as a method, as follows:</p><div class="informalexample"><pre class="programlisting">def execute_method():
	fnc = getattr(self, self.all_toolbar_functions [self.selected_toolbar_func_index])
	fnc(self.startx, self.starty,self.lastx, self.lasty)</pre></div></div><div class="section" title="Step 7 – doing the actual drawing"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec107"/>Step 7 – doing the actual drawing</h3></div></div></div><p>Having defined methods to draw line, rectangle, oval, and brush strokes, we need to call them from somewhere for the drawing to happen. Intuitively, the drawings must begin on the first mouse down movement and the drawing must be deleted and redrawn up till the mouse button release.</p><p>Accordingly, these methods must be called from our <code class="literal">mouse_down_motion</code> method<a id="id541" class="indexterm"/>. We, therefore, modify our <code class="literal">mouse_down_motion</code> and <code class="literal">mouse_up </code>methods to do this, as follows:</p><div class="informalexample"><pre class="programlisting">def mouse_down_motion(self, event):
	self.lastx = self.canvas.canvasx(event.x)
	self.lasty = self.canvas.canvasy(event.y)
	if self.selected_toolbar_func_index:
		self.canvas.delete(self.currentobject)
		self.execute_method()

def mouse_up(self, event):
	self.lastx = self.canvas.canvasx(event.x)
	self.lasty = self.canvas.canvasy(event.y)
	self.canvas.delete(self.currentobject)
	self.currentobject = None
	self.execute_method()</pre></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec132"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This<a id="id542" class="indexterm"/> completes our objective for the iteration.</p><p>We began by creating a tuple of method names so as to be able to call a method dynamically by specifying its index in the tuple.</p><p>We then added icons for our toolbar buttons. We then associated a button click to a method that keeps tab on currently selected button by assigning its index to the variable, <code class="literal">self.selected_toolbar_func_index</code>. We then defined methods to draw line, rectangle, and oval shapes on our canvas. We also showed how to utilize the ability to draw lines to draw in continuous strokes.</p><p>Finally, we called all the draw methods from <code class="literal">mouse_down_motion</code> and <code class="literal">mouse_release </code>method to do the actual drawing.</p><p>A user can now draw basic shapes, such as lines, rectangles, ovals, and brush strokes on to the canvas. The shapes are drawn in the currently set foreground color.</p></div></div>
<div class="section" title="Setting the options toolbar at the top"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec63"/>Setting the options toolbar at the top</h1></div></div></div><p>Although our program can draw basic shapes, these shapes are currently filled with the foreground color and the outline of the shape is done in black.</p><p>The Canvas <a id="id543" class="indexterm"/>widget lets you specify the fill color, outline color, and border width for most of the shapes as its configurable options.</p><p>In addition to these, the Canvas widget also has several other configurable options for many of these basic shapes. For instance, for a line, you can specify if it will have an arrow head shape at the end or if it will be dashed.</p><p>Let's accordingly modify our program to allow the user to select configurable options for each of the four basic shapes, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_06_06.jpg" alt="Setting the options toolbar at the top"/></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec133"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – showing the selected button icon at the top"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec108"/>Step 1 – showing the selected button icon at the top</h3></div></div></div><p>Let<a id="id544" class="indexterm"/>'s start with a simple thing first. When a user clicks on a button in the left toolbar, the top frame should display the text <span class="strong"><strong>Selected Tool:</strong></span> followed by the icon representation for the selected button.</p><p>Because this event must occur on click of any button, we modify our <code class="literal">selected_tool_bar_item </code>method to include a call to two methods, as highlighted in the following code (see <span class="emphasis"><em>code 6.04.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def selected_tool_bar_item(self, i):
	self.selected_toolbar_func_index = i
	self.remove_options_from_topbar()
	self.show_selected_tool_icon_in_topbar()

def remove_options_from_topbar(self):
	for child in self.topbar.winfo_children():
		child.destroy()

def show_selected_tool_icon_in_topbar(self):
	Label(self.topbar,text='Selected Tool:').pack(side=LEFT)
	photo = PhotoImage(file='icons/'+								'self.all_toolbar_functions[self.selected_toolbar_func_index]+'.gif')
	label = Label(self.topbar, image=photo)
	label.image = photo
	label.pack(side=LEFT)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<a id="id545" class="indexterm"/> <code class="literal">remove_options_from_topbar</code> method ensures that when a new button is clicked, options for the previous button are deleted. The <code class="literal">show_selected_tool_icon_in_topbar </code>method actually displays the icon for the currently selected button.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>
<code class="literal">widget.winfo_children()</code> returns a list of all children for a given widget, in their stacking order from bottom to top.</p><p>You can extract a lot of window-related information using one of the many <code class="literal">winfo</code> methods. For a complete list of the <code class="literal">winfo</code> methods, refer to the <span class="emphasis"><em>The basic widget methods</em></span> section in <a class="link" href="apb.html" title="Appendix B. Quick Reference Sheets">Appendix B</a>, <span class="emphasis"><em>Quick Reference Sheets</em></span>.</p><p>Alternatively, each widget has also its own children attribute, which is a dictionary where the keys are the IDs and the values are the widgets. So if the order is not relevant, this is the same as <code class="literal">widget.children.values()</code>.</p></div></div></li></ul></div></div><div class="section" title="Step 2 – adding the Combobox widget to let user select different fill options"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec109"/>Step 2 – adding the Combobox widget to let user select different fill options</h3></div></div></div><p>Next, we <a id="id546" class="indexterm"/>need to define the selection combobox for a user to select options for fill, outline, width, arrow, and dash. We will use ttk Combobox to allow the user to make a selection, and as such, we import it into our current file, as follows:</p><div class="informalexample"><pre class="programlisting">import ttk</pre></div><p>We will not reproduce the entire code here. However, for each of the preceding options, we define two methods: one that displays the combobox and the other sets the value of the current selection made by the user.</p><p>Thus, we set the following two definitions for fill option, as follows (see <span class="emphasis"><em>code 6.04.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def fill_options_combobox(self):
	Label(self.topbar,text='Fill:').pack(side=LEFT)
	self.fillcmbobx = ttk.Combobox(self.topbar, 							state='readonly', width=5)
	self.fillcmbobx.pack(side=LEFT)
	self.fillcmbobx['values'] = ('none', 'fg', 'bg', 'black', 'white' )
	self.fillcmbobx.bind('&lt;&lt;ComboboxSelected&gt;&gt;',	self.set_fill)
	self.fillcmbobx.set(self.fill)

def set_fill(self, event=None):
	fl = self.fillcmbobx.get()
	if fl == 'none': self.fill = '' #transparent
	elif fl == 'fg': self.fill = self.foreground
	elif fl == 'bg': self.fill = self.background
	else: self.fill = fl</pre></div><p>We similarly define other pair of methods for each of the sets, namely (see <span class="emphasis"><em>code 6.04.py</em></span>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">outline_options_combobox:set_outline</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">width_options_combobox:set_width</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">arrow_options_combobox:set_arrow</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">dash_options_combobox:set_dash</code></li></ul></div></div><div class="section" title="Step 3 – modifying draw methods to add configurable options"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec110"/>Step 3 – modifying draw methods to add configurable options</h3></div></div></div><p>Now<a id="id547" class="indexterm"/> that we have ways to set different values for fill, outline, arrow, and dash configurable options, let's modify our drawing code to include these in the actual drawing, as follows (see <span class="emphasis"><em>code 6.04.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def draw_line(self, x, y, x2, y2):
	self.currentobject = self.canvas.create_line(x, y, x2, y2,
		fill= self.fill, arrow=self.arrow, width=self.width, 				dash=self.dash )

def draw_rectangle(self, x, y, x2, y2):
	self.currentobject = self.canvas.create_rectangle(x, y,x2, 				y2, outline=self.outline, fill=self.fill, 						width=self.width)

def draw_oval(self, x, y, x2, y2):
	self.currentobject=  self.canvas.create_oval(x, y, x2, 				y2, outline=self.outline, fill=self.fill, 						width=self.width)

def draw_brush(self, x, y, x2, y2):
	if not self.all_toolbar_functions[self.selected_toolbar_func_index]=='draw_brush':
		self.canvas.bind("&lt;Button1-Motion&gt;", 						self.mouse_down_motion)
		return
	self.currentobject = self.canvas.create_line(x,y,x2,y2,				fill=self.fill, width=self.width)

self.canvas.bind("&lt;B1-Motion&gt;", self.draw_brush_update_xy)</pre></div><p>Having defined all these methods, it is now time to call them from somewhere.</p><p>While<a id="id548" class="indexterm"/> the fill combobox would be applicable to all the four basic shapes, the arrow option would only be applicable to drawing lines. Because there will be a different set of comboboxes for different selections, we define the following methods (see <span class="emphasis"><em>code 6.04.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def draw_line_options(self):
	self.fill_options_combobox()
	self.width_options_combobox()
	self.arrow_options_combobox()
	self.dash_options_combobox()

def draw_rectangle_options(self):
	self.fill_options_combobox()
	self.outline_options_combobox()
	self.width_options_combobox()

def draw_oval_options(self):
	self.fill_options_combobox()
	self.outline_options_combobox()
	self.width_options_combobox()

def draw_brush_options(self):
	self.fill_options_combobox()
	self.width_options_combobox()</pre></div><p>Finally, these methods have to be called from somewhere, depending on the selection made. So we modify our <code class="literal">selected_tool_bar_item </code>method to call a method dynamically, named by appending the string <code class="literal">_options</code> to the name of selected method as follows (see <span class="emphasis"><em>code 6.04.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def selected_tool_bar_item(self, i):
	self.selected_toolbar_func_index = i
	self.remove_options_from_topbar()
	self.show_selected_tool_icon_in_topbar()
	opt = self.all_toolbar_functions[ self.selected_toolbar_func_index] +'_options'
	fnc = getattr(self, opt)
	fnc()</pre></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec134"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>The program <a id="id549" class="indexterm"/>user can now select from the various options provided for each of the toolbar buttons (see <span class="emphasis"><em>code 6.04.py</em></span>).</p><p>More importantly, we saw some of the configuration options available for items drawn on the Tkinter Canvas widget. We were also introduced to the <code class="literal">winfo </code>methods. These methods can be used to extract a lot of data about a widget and are a useful tool to have when programming a GUI application in Tkinter.</p></div></div>
<div class="section" title="Adding some more features"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Adding some more features</h1></div></div></div><p>Next in line, let's add a few more features to our drawing program. In particular, we will add the<a id="id550" class="indexterm"/> ability to delete objects from the canvas, add a paint bucket, the ability to move items up and down the stack, and the ability to drag items on the canvas, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_06_07.jpg" alt="Adding some more features"/></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec135"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – extending our methods tuple"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec111"/>Step 1 – extending our methods tuple</h3></div></div></div><p>As<a id="id551" class="indexterm"/> a first thing, let us extend our <code class="literal">all_toolbar_functions</code> method to make provisions for the new methods that we will define here, as follows (see <span class="emphasis"><em>code 6.05.py</em></span>):</p><div class="informalexample"><pre class="programlisting">all_toolbar_functions = ('draw_line', 'draw_rectangle', 'draw_oval', 'draw_brush', 'delete_object', 'fill_object', 'move_to_top', 'drag_item')</pre></div><p>As usual, we have added icons to the <code class="literal">icon</code> folder by the same name as the method that would handle it. The buttons are automatically displayed in our left toolbar merely by adding new methods to this tuple and by adding corresponding icons to our <code class="literal">icon</code> folder because of the way we have designed the <code class="literal">create_tool_bar_buttons</code> method.</p></div><div class="section" title="Step 2 – targeting a given item on the canvas"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec112"/>Step 2 – targeting a given item on the canvas</h3></div></div></div><p>Before define the methods for handling the new features, let's pause and think about the kind of work we need to do here.</p><p>The operations that we want to do now are slightly different from their predecessors. Earlier, we were creating items on the canvas. Now we have to target items already present on the canvas.</p><p>The items that need to be targeted are the ones on which the user clicks on with his or her mouse.</p><p>We, therefore, need to identify the item on which mouse has been clicked before we can do any modification to the item itself. To do that, we modify our <code class="literal">mouse_down </code>method as follows (see <span class="emphasis"><em>code 6.05.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def mouse_down(self, event):
	self.currentobject = None
	self.lastx = self.startx = self.canvas.canvasx(event.x)
	self.lasty = self.starty = self.canvas.canvasy(event.y)
	if self.all_toolbar_functions[										self.selected_toolbar_func_index] 
	in ['fill_object',	'delete_object', 'move_to_top', drag_item']:            		
		try:
			self.selected_object = 									self.canvas.find_closest(self.startx, self.starty)[0]
		except:
			self.selected_object = self.canvas</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This small modification to the <code class="literal">mouse_down </code>method means that if any of the last four buttons are clicked, the code locates the item located closest to the click position and assigns it to our newly defined attribute, <code class="literal">selected_object</code>, which stands for the current selected object.</li><li class="listitem" style="list-style-type: disc">If <a id="id552" class="indexterm"/>there are no items on the canvas, the entire canvas is set to the <code class="literal">selected_obj</code><code class="literal">ect </code>attribute.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>The canvas method has a method named: <code class="literal">find_closest(x, y, halo=None, start=None)</code>.</p><p>It returns the identifier for item closest to the given position on the canvas. This means that if there is only one item on the canvas, it will be selected regardless of how near or how far you click from it.</p><p>If on the other hand, you want that objects only within a certain distance are selected, the Canvas widget provides an alternate implementation named <code class="literal">find_overlapping</code>.</p><p>You will, however, have to place a small rectangle centered on the position to use this.</p></div></div></li></ul></div><p>Now that we have a hold on the item to be manipulated, we can proceed to do whatever we want to do with the item.</p></div><div class="section" title="Step 3 – deleting items from the canvas"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec113"/>Step 3 – deleting items from the canvas</h3></div></div></div><p>The first method to delete items from canvas is <code class="literal">delete_object</code>, which simply deletes the selected item. So our <code class="literal">delete_object</code> method is defined as follows (see <span class="emphasis"><em>code 6.05.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def delete_object(self, x0, y0, x1, y1):
	self.canvas.delete(self.selected_object)</pre></div><p>And, because our earlier code needed that for every method for which we define an options method, we define the method, <code class="literal">delete_object_options</code>, here. However, because we do not want to display anything in the option bar at the top, we simply ignore it with a pass statement, as follows:</p><div class="informalexample"><pre class="programlisting">def delete_object_options(self):
	pass</pre></div></div><div class="section" title="Step 4 – paint bucket feature"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec114"/>Step 4 – paint bucket feature</h3></div></div></div><p>Next, we code our <code class="literal">fill_object </code>method, which acts somewhat like a paint bucket in common drawing programs.</p><p>This<a id="id553" class="indexterm"/> again is simple. You simply need to fill the color on the background of the selected item. If there is no item on the canvas, it simply fills the color on to the entire canvas, as follows:</p><div class="informalexample"><pre class="programlisting">def fill_object(self,x0,y0,x1,y1):
	if self.selected_object == self.canvas:
		self.canvas.config(bg=self.fill)
	else:
		self.canvas.itemconfig(self.selected_object, fill=self.fill)</pre></div><p>And here, we want to let the user choose the fill color for the paint bucket. Hence, we call our previously defined method, <code class="literal">fill_options_combobox</code>, from within our <code class="literal">fill_object_options</code> method.</p><div class="informalexample"><pre class="programlisting">def fill_object_options(self):
	self.fill_options_combobox()</pre></div></div><div class="section" title="Step 5 – moving items on top of each other"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec115"/>Step 5 – moving items on top of each other</h3></div></div></div><p>Let's now define the methods for the next button. The button marked with a small hand icon can be used to raise items on top of others.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>When you draw multiple items on the canvas, the items are placed in a stack. By default, new items get added on top of items previously drawn on the canvas. You can, however, change the stacking order using: <code class="literal">canvas.tag_raise(item)</code>.</p><p>If multiple items match, they are all moved, with their relative order preserved.</p><p>However, this method will not change the stacking order for any new window item that you draw within the canvas.</p><p>Then there are <code class="literal">find_above</code> and <code class="literal">find_below </code>methods that you can use to find items above or below an item in the canvas stacking order.</p><p>In addition, there is a <code class="literal">find_all</code> method<a id="id554" class="indexterm"/> that returns a tuple containing identifiers for all items on the canvas.</p></div></div><p>Accordingly,<a id="id555" class="indexterm"/> the code for moving items to the top of stack is as follows (see <span class="emphasis"><em>code 6.05.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def move_to_top(self,x0,y0,x1,y1):
	self.canvas.tag_raise(self.selected_object)
def move_to_top_options(self):
	pass # no items to display on the top bar</pre></div></div><div class="section" title="Step 6 – dragging items on the canvas"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec116"/>Step 6 – dragging items on the canvas</h3></div></div></div><p>Finally, let's add drag-and-drop feature for items on the canvas. The ability to drag an item on the canvas requires that after selection of the object to be dragged, we recalculate the x and y coordinates for mouse movement, and move the object to the new coordinates provided by the mouse movement at small intervals.</p><p>In many ways the concept here is similar to one that we used for defining our paint brush.</p><p>The idea is to call our <a id="id556" class="indexterm"/>
<code class="literal">drag_items</code> method after every small mouse movement using another method, <code class="literal">drag_item_update_xy</code>, which recalculates x and y coordinates after small mouse motion, moving the item to the newly calculated coordinates every time.</p><p>Then, we have a condition check, which breaks out of this loop if any other button is selected from the toolbar, as follows (see <span class="emphasis"><em>code 6.05.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def drag_item(self,x0,y0,x1,y1):
	if not self.all_toolbar_functions[ 							self.selected_toolbar_func_index] == 'drag_item':
		self.canvas.bind("&lt;Button1-Motion&gt;",									self.mouse_down_motion)
		return # break out of loop
	self.currentobject = self.canvas.move(									self.selected_object, x1-x0, y1-	y0)
	self.canvas.bind("&lt;B1-Motion&gt;", self.drag_item_update_xy)

def drag_item_update_xy(self, event):
	self.startx, self.starty = self.lastx, self.lasty
	self.lastx, self.lasty = event.x, event.y
	self.drag_item(self.startx, self.starty,self.lastx, 					self.lasty)

def drag_item_options(self):
	pass # we want no options to be displayed at the top</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>The Canvas widget provides a method: <code class="literal">canvas.move(item, dx, dy)</code>.</p><p>The preceding method moves any matching item by a horizontal and vertical offset (<code class="literal">dx</code> and <code class="literal">dy</code>).</p></div></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec136"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This<a id="id557" class="indexterm"/> brings us to the end of this iteration. We have now successfully added four new features to our drawing program, namely: <code class="literal">delete_object</code>, <code class="literal">fill_object</code>, <code class="literal">move_to_top</code>, and <code class="literal">drag_item</code>.</p><p>In the process, we saw some of the methods provided by the Canvas widget for item manipulation. We also saw the strategy that one might adopt when working on existing items on the Canvas widget.</p></div><div class="section" title="Classified Intel"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec137"/>Classified Intel</h2></div></div></div><p>In this program, we extensively used the item identifier ID to target a particular item on the canvas. Recall that item identifier is the unique integer ID returned by the canvas method that creates the object.</p><p>So, for instance, when you create an oval item on your canvas, it returns an integer ID after creating the object. This is referred to its item identifier or the item handle, as follows:</p><div class="informalexample"><pre class="programlisting">my_item_identifier = self.canvas.create_oval(x, y, x2, y2)</pre></div><p>Now you can act upon this oval using the handle, my_item_identifier.</p><p>However, this is not the only method by which you can identify an item on the canvas. Additionally, you can add tags to items, and then use these tags to identify the object for manipulation.</p><div class="section" title="Working with item tags"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec117"/>Working with item tags</h3></div></div></div><p>Let's now look at some of the common operations involved in working with Canvas tags.</p></div><div class="section" title="Adding a tag"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec118"/>Adding a tag</h3></div></div></div><p>To add a<a id="id558" class="indexterm"/> tag to an item, you specify the tag (which is a string) as its configurable option either at the time of creating the object or later using the <code class="literal">itemconfig </code>method, or add them using the <code class="literal">addtag_withtag</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">rectid = canvas.create_rectangle(10, 10, 50, 50, tags="myshiny")
canvas.itemconfig(rectid, tags="shiv")
canvas.addtag_withtag("shiv", "takeonemore")</pre></div><p>The same tag can be applied to more than one item on the canvas.</p><p>You can add multiple tags to an item together by passing in the tags as a tuple of strings, as follows:</p><div class="informalexample"><pre class="programlisting">canvas.itemconfig(rectid, tags=("tagA", "tagB"))</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>Using tags to identify items to be manipulated is especially useful when you need to manipulate more than one item at one time, or if you want to manipulate items based on certain conditionals.</p></div></div></div><div class="section" title="Retrieving tags"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec119"/>Retrieving tags</h3></div></div></div><p>To get all tags associated with a specific item handle, use <code class="literal">gettags</code> as follows:</p><div class="informalexample"><pre class="programlisting">printcanvas.gettags(rectid)</pre></div><p>This<a id="id559" class="indexterm"/> returns a tuple of all tags associated with that item handle, as follows:</p><div class="informalexample"><pre class="programlisting">("myshiny", "shiv", "takeonemore", "tagA", "tagB")</pre></div></div><div class="section" title="Getting items with a given tag"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec120"/>Getting items with a given tag</h3></div></div></div><p>To get the <a id="id560" class="indexterm"/>item handles for all items having a given tag, use <code class="literal">find_withtag</code> as follows:</p><div class="informalexample"><pre class="programlisting">print canvas.find_withtag("shiv")</pre></div><p>This returns the item handles for all items as a tuple.</p></div><div class="section" title="Built-in tags"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec121"/>Built-in tags</h3></div></div></div><p>The canvas widget provides two built-in tags:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ALL or all: It matches<a id="id561" class="indexterm"/> all items on the canvas</li><li class="listitem" style="list-style-type: disc">CURRENT or current: It returns<a id="id562" class="indexterm"/> the item under the mouse pointer, if any</li></ul></div></div></div></div>
<div class="section" title="Mission Accomplished"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec65"/>Mission Accomplished</h1></div></div></div><p>There you have your own drawing program! You can easily extend it to add many more features.</p><p>Here's a quick summary of things we have seen in this project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building custom GUI frameworks for rapid application development</li><li class="listitem" style="list-style-type: disc">Understanding how to use inheritance in our projects</li><li class="listitem" style="list-style-type: disc">Getting to know the <code class="literal">tkColoChooser </code>module</li><li class="listitem" style="list-style-type: disc">Learning to create and manipulate items on the Canvas widget</li><li class="listitem" style="list-style-type: disc">Working with the tk ComboBox widget</li><li class="listitem" style="list-style-type: disc">Getting to know the available <code class="literal">winfo</code> methods</li><li class="listitem" style="list-style-type: disc">Working with mouse events on the Canvas widget</li><li class="listitem" style="list-style-type: disc">Reinforcing things that we have learned in previous projects</li></ul></div></div>
<div class="section" title="A Hotshot Challenge"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec66"/>A Hotshot Challenge</h1></div></div></div><p>Add the following<a id="id563" class="indexterm"/> features to your drawing program:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The accelerator keys don't work for our menu items because we have not bound them to key events. Bind the menu-item accelerator keys to their associated command callback.</li><li class="listitem" style="list-style-type: disc">Create an Eraser button and add its associated features.</li><li class="listitem" style="list-style-type: disc">We have not implemented drawing of some other basic shapes, such as arc and polygons, even though the Canvas widget provides for methods to draw them. Add the ability to draw arcs and polygons to the drawing program.</li><li class="listitem" style="list-style-type: disc">Create a new toolbar on the right side. Utilizing the stacking order for canvas items, display each item as a separate layer in the toolbar.</li><li class="listitem" style="list-style-type: disc">Go through all the available Canvas widget options in your IDE by using Python's interactive help feature. Try adding more features to the program utilizing one or more of the options.</li><li class="listitem" style="list-style-type: disc">We <a id="id564" class="indexterm"/>have already included the ability to add images to our program by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Open</strong></span>. Add a few menu items to manipulate those images. Using some imaging library, add image manipulation features, such as color adjustment, brightness, contrast, grayscale, and other facilities for image manipulation provided by the imaging library that you choose to use.</li><li class="listitem" style="list-style-type: disc">The Canvas widget is often used to draw custom widgets. Make a Progress Meter widget using the Canvas widget. Attach it to some function and run it to see that the oval should get filled with some color as the function progresses. You can use the fill option of the Canvas widget to show increase in progress.</li></ul></div></div></body></html>