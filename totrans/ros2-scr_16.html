<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-292"><a id="_idTextAnchor614" class="pcalibre calibre4 pcalibre1"/>13</h1>
			<h1 id="_idParaDest-293" class="calibre6"><a id="_idTextAnchor615" class="pcalibre calibre4 pcalibre1"/>Simulating a Robot in Gazebo</h1>
			<p class="calibre3">In the previous chapters, you wrote a URDF to describe a robot, published the TFs for that robot, and properly organized all files into the <strong class="source-inline1">my_robot_description</strong> package.</p>
			<p class="calibre3">You are now going to simulate the robot in Gazebo. This will be the end of the <em class="italic">Part 3</em> project. The goal here is to finish the book with a working simulation. After that, I will conclude by giving you some hints on what to do to further with ROS.</p>
			<p class="calibre3">We will start the chapter by understanding what Gazebo is, how it is integrated with ROS 2, and how to work with it. This will allow us to adapt the robot URDF for Gazebo, spawn it in the simulator, and control it with a plugin. We will also properly package the application so that we can start everything from one single launch file.</p>
			<p class="calibre3">By the end of this chapter, you will be able to simulate a robot in Gazebo and interact with it using ROS 2. After you’ve done the process once, it will be much easier for the next robot you want to simulate.</p>
			<p class="calibre3">The level of this chapter is more advanced than what we did before. We will reach a point where the documentation lacks a lot. Finding useful information usually means doing a lot of research on Google, as well as finding GitHub code that works and that you can use as an inspiration.</p>
			<p class="calibre3">To complete this chapter, you will also need to utilize what you have previously learned from this book —for example, creating and organizing packages, working with topics and parameters, and writing launch files. Don’t hesitate to refer to previous chapters if you have any doubts.</p>
			<p class="calibre3">We will use the code inside the <strong class="source-inline1">ch12</strong> folder (on the GitHub repository at <a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>) as a starting point. You can find the final code in the <strong class="source-inline1">ch13</strong> folder.</p>
			<p class="calibre3">In this chapter, we will cover the following topics:</p>
			<ul class="calibre9">
				<li class="calibre10">How Gazebo works</li>
				<li class="calibre10">Adapting the URDF for Gazebo</li>
				<li class="calibre10">Spawning the robot in Gazebo</li>
				<li class="calibre10">Controlling the robot in Gazebo</li>
			</ul>
			<h1 id="_idParaDest-294" class="calibre6"><a id="_idTextAnchor616" class="pcalibre calibre4 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">If you installed ROS 2 in a <strong class="bold">VM</strong> (as explained with VirtualBox at the beginning of the book), it probably worked well for all chapters in <em class="italic">Part 1</em> and <em class="italic">Part 2</em>, and possibly <a id="_idIndexMarker824" class="pcalibre calibre4 pcalibre1"/>for the previous chapters in <em class="italic">Part 3</em>, even when running RViz.</p>
			<p class="calibre3">However, with Gazebo, chances are that the VM won’t be enough. VirtualBox doesn’t work well with 3D simulation tools. From now on, I would strongly recommend that you have Ubuntu installed with a dual boot. I know that some people had more success with VMware Workstation (using the free version for personal use) or WSL 2 on Windows. If you find another combination that works for you, fine, but I would still recommend a dual boot, which will possibly be less buggy and bring you a better experience overall.</p>
			<p class="calibre3">So, if you are currently running a VM, take the time to set up a dual boot and install Ubuntu 24.04. Then, follow the instructions from <a href="B22403_02.xhtml#_idTextAnchor048" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 2</em></a> again to install ROS Jazzy. This will take you a bit of time in the short term, but it will surely be more efficient in the long term.<a id="_idTextAnchor617" class="pcalibre calibre4 pcalibre1"/></p>
			<h1 id="_idParaDest-295" class="calibre6"><a id="_idTextAnchor618" class="pcalibre calibre4 pcalibre1"/>How Gazebo works</h1>
			<p class="calibre3">Before we work on our application, it’s important to understand what Gazebo is and how it works.</p>
			<p class="calibre3">Gazebo is a <a id="_idIndexMarker825" class="pcalibre calibre4 pcalibre1"/>3D simulation engine. It contains a physics engine (with gravity, friction, and other physical constraints) with which you can simulate a robot, just like if it were in the real world.</p>
			<p class="calibre3">That’s one of the strengths of Gazebo. You can develop your application using mostly the Gazebo simulation and then work with the real robot. This brings a lot of benefits. For example, you can work on robots that don’t exist yet, test extreme use cases without damaging the real robot, create custom environments you can’t access on a daily basis, work remotely, and so on.</p>
			<p class="calibre3">In this section, we will start Gazebo and explore a few functionalities. We will also see how to connect Gazebo with ROS 2 and understand the steps we need to take to adapt our robot <a id="_idIndexMarker826" class="pcalibre calibre4 pcalibre1"/>for Gazebo. Before getting started with this, a common question that lots of people have at this point is, what is the difference between Gazebo and RViz<a id="_idTextAnchor619" class="pcalibre calibre4 pcalibre1"/>?</p>
			<h2 id="_idParaDest-296" class="calibre6"><a id="_idTextAnchor620" class="pcalibre calibre4 pcalibre1"/>Clarifying – Gazebo versus RViz</h2>
			<p class="calibre3">We are starting with this because I believe this is one of the first confusions you can have. We have already used RViz previously, and we could visualize the robot in it, as well as lots <a id="_idIndexMarker827" class="pcalibre calibre4 pcalibre1"/>of other information. So, why do we need Gazebo?</p>
			<p class="calibre3">To understand this, let’s first go back to what RViz is. RViz is a 3D visualization tool. With RViz, you can <a id="_idIndexMarker828" class="pcalibre calibre4 pcalibre1"/>visualize the URDF, the TFs, and the data you get from ROS topics. This is a great tool to use when developing, as you can check that what you are doing is correct.</p>
			<p class="calibre3">Now, RViz <strong class="bold">is not</strong> a simulation tool. You don’t simulate anything; you <strong class="bold">only visualize</strong> what already exists. So, the robot and all the data you see in RViz is only the representation of what’s happening externally (of RViz). Instead of seeing and interacting with all the data in the terminal, you can do that with a graphical interface and see the data in 3D. That’s (very simply put) what RViz brings to you.</p>
			<p class="calibre3">For example, with TFs, RViz will subscribe to the <strong class="source-inline1">/tf</strong> topic and display the TFs on the screen. However, RViz doesn’t control the TFs; it just shows them.</p>
			<p class="calibre3">Conversely, Gazebo is a simulation tool. It will simulate gravity and the real physical properties of the robot. It also has some control plugins so that you can simulate the hardware control, and even publish the joint states and TFs for your robot.</p>
			<p class="calibre3">So, what do we use here—Gazebo or RViz? Ultimately, it’s not a competition; both are complementary.</p>
			<p class="calibre3">Gazebo is available if you don’t have a real robot, if you don’t want to use it, or if you want to test a robotics system in a different environment, for example. With Gazebo, you can replicate the behavior of your robot, and make it very close to what it would do in real life.</p>
			<p class="calibre3">On top of Gazebo, you can use RViz to visualize the TFs and other important data from your application. RViz is still a very useful tool to have during the development phase. So, the dilemma is not <em class="italic">Gazebo versus RViz</em>, but instead, <em class="italic">real robot versus Gazebo</em>. In the end, you can have either:</p>
			<ul class="calibre9">
				<li class="calibre10">Real robot and RViz</li>
				<li class="calibre10">Gazebo simulation and RViz</li>
			</ul>
			<p class="calibre3">In this chapter, we will <a id="_idIndexMarker829" class="pcalibre calibre4 pcalibre1"/>use the second combination. We will spawn and <a id="_idIndexMarker830" class="pcalibre calibre4 pcalibre1"/>control our robot in Gazebo. Then, we will also visualize it in RViz. What we see in RViz will be a reflection of what’s happening in Gazebo. If, later on, we switched to a real robot, we would ditch Gazebo but still use RViz to see whether everything still works well.</p>
			<p class="calibre3">Now that we have made this clarification, we can get started with G<a id="_idTextAnchor621" class="pcalibre calibre4 pcalibre1"/>azebo.</p>
			<h2 id="_idParaDest-297" class="calibre6"><a id="_idTextAnchor622" class="pcalibre calibre4 pcalibre1"/>Starting Gazebo</h2>
			<p class="calibre3">Let’s run Gazebo and get used to the interface.</p>
			<p class="calibre3">First, you need <a id="_idIndexMarker831" class="pcalibre calibre4 pcalibre1"/>to install Gazebo. We installed ROS 2 previously with <strong class="source-inline1">ros-&lt;distro&gt;-desktop</strong>, which already contains a lot of packages. To get everything we need for Gazebo, install this additional package:</p>
			<pre class="console">
$ sudo apt install ros-&lt;distro&gt;-ros-gz</pre>			<p class="calibre3">Make sure to replace <strong class="source-inline1">&lt;distro&gt;</strong> with your current ROS 2 distribution, and after running this command, source your environment.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since we are <a id="_idIndexMarker832" class="pcalibre calibre4 pcalibre1"/>using Ubuntu 24.04, this will install <strong class="bold">Gazebo Harmonic</strong>. For other Ubuntu versions, you can find the recommended Gazebo versions here: <a href="https://gazebosim.org/docs/latest/getstarted/" class="pcalibre calibre4 pcalibre1">https://gazebosim.org/docs/latest/getstarted/</a>.</p>
			<p class="calibre3">It’s important to note that Gazebo is actually independent from ROS 2. You can run Gazebo on its own, without ROS 2. In fact, you could even install Gazebo without any ROS 2 packages.</p>
			<p class="calibre3">Gazebo has been designed as an independent robotics simulator that you can then use with ROS 2, as well as other robotics frameworks. Here, I will only focus on ROS 2. The reason I mention this is just to make you understand that Gazebo and ROS are separate projects.</p>
			<p class="calibre3">We will start by running Gazebo on its own. Then, we will see how to connect Gazebo and ROS, which will be useful for planning the steps to adapt our project and simulate our ROS robot on Gazebo.</p>
			<p class="calibre3">So, to start Gazebo (without ROS), run this command in a terminal:</p>
			<pre class="console">
$ gz sim</pre>			<p class="calibre3">You will be taken to a Gazebo quick-start menu. There, you can click on <strong class="bold">Empty</strong> to load an empty world. You also have other existing worlds (click on the different images, or use the search bar) that you can explore later on your own. Warning—some of these worlds may contain bugs and not work properly.</p>
			<p class="calibre3">To stop the simulation, press <em class="italic">Ctrl</em> + <em class="italic">C</em> in the terminal where you started Gazebo.</p>
			<p class="calibre3">When running <a id="_idIndexMarker833" class="pcalibre calibre4 pcalibre1"/>the Gazebo command, you can also directly specify the world you want to launch. World description files in Gazebo use the SDF format (a file with a <strong class="source-inline1">.sdf</strong> extension), which is quite similar to URDF. Let’s start Gazebo with the empty world:</p>
			<pre class="console">
$ gz sim empty.sdf</pre>			<p class="calibre3">Now, take the time to move around the space using mouse controls. You can also use a laptop touchpad, but if possible, I really recommend that you have a mouse, which will make things easier going forward.</p>
			<p class="calibre3">At the bottom left of the screen, you will see a play button. Click on it to start the simulation.</p>
			<p class="calibre3">After starting the simulation, you will see a percentage at the bottom-right part of the screen, representing the real-time factor. Basically, this will tell you immediately whether your computer is powerful enough for Gazebo. Personally, I have a real-time factor of about 98%, which means that the simulated time in Gazebo keeps up with real time at 98% speed (i.e., after 100 real seconds, 98 seconds have passed in Gazebo). If your percentage is too low, it may be a sign that you need better performance. If you’re not sure, continue with the chapter, and you will quickly see whether the robot simulation works properly or not.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Gazebo can be quite buggy, so don’t be surprised if it crashes at some point—even on a powerful computer. If you can’t close Gazebo properly (with <em class="italic">Ctrl</em> + <em class="italic">C</em> in the terminal), you may have some trouble when starting it again. In this case, you can try to stop all Gazebo processes that might still be running in the background. To do that, run <code>ps aux | grep gz</code> to find all <a id="_idIndexMarker834" class="pcalibre calibre4 pcalibre1"/>related processes. You will find a <code>pid</code> with four numbers for each <code>gz</code> process (if any). To stop a process, run <code>kill –9 &lt;pid&gt;</code>. If nothing works, the best thing to do is to restart your computer.</p>
			<p class="calibre3">Let’s return to the simulation we started—at the top of the screen, you can click on the different shapes and add them to the empty space. Take some time to experiment with this. Add a <a id="_idIndexMarker835" class="pcalibre calibre4 pcalibre1"/>box into the space. Find the translation mode and rotation mode. Move the box around (especially on the <em class="italic">z</em> axis) and see what happens. If you lift the box up, then you should see the box falling down on the floor. This is because of the gravity and physical properties of the box.</p>
			<div><div><img alt="Figure 13.1: The Gazebo simulator with a box in an empty world" src="img/B22403_13_1.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.1: The Gazebo simulator with a box in an empty world</p>
			<p class="calibre3">What we can do next is explore the communications used by Gazebo. Gazebo also uses topics and services, but those are not the same as ROS 2 topics and services.</p>
			<p class="calibre3">For example, you can list all Gazebo topics with this command:</p>
			<pre class="console">
$ gz topic -l</pre>			<p class="calibre3">You will see a lot of topics, but if you try to run <strong class="source-inline1">ros2 topic list</strong> in another terminal, none of <a id="_idIndexMarker836" class="pcalibre calibre4 pcalibre1"/>those topics will appear. Also, when running <strong class="source-inline1">ros2 node list</strong>, you won’t see any nodes.</p>
			<p class="calibre3">With this, you can see that Gazebo is completely independent of ROS 2, and they do not interact with <a id="_idTextAnchor623" class="pcalibre calibre4 pcalibre1"/>each other.</p>
			<h2 id="_idParaDest-298" class="calibre6"><a id="_idTextAnchor624" class="pcalibre calibre4 pcalibre1"/>How Gazebo works with ROS 2</h2>
			<p class="calibre3">We will now explore how Gazebo and ROS 2 can be connected.</p>
			<p class="calibre3">First of all, you can start Gazebo using a ROS 2 launch file from the <strong class="source-inline1">ros_gz_sim</strong> package. This <a id="_idIndexMarker837" class="pcalibre calibre4 pcalibre1"/>will be more practical for us because when we <a id="_idIndexMarker838" class="pcalibre calibre4 pcalibre1"/>write our own launch file, we can include this one:</p>
			<pre class="console">
$ ros2 launch ros_gz_sim gz_sim.launch.py</pre>			<p class="calibre3">This will start Gazebo the same way we did with the <strong class="source-inline1">gz sim</strong> command. You can also specify the world to launch with the <strong class="source-inline1">gz_args</strong> argument:</p>
			<pre class="console">
$ ros2 launch ros_gz_sim gz_sim.launch.py gz_ar<a id="_idTextAnchor625" class="calibre13 pcalibre1 pcalibre"/>gs:=empty.sdf</pre>			<p class="calibre3">However, even if we started Gazebo from a ROS 2 launch file, Gazebo is still independent. Try to list all the nodes and topics in a terminal; you will see the same result as before.</p>
			<p class="calibre3">To connect Gazebo and ROS 2 topics (or services), you need to create a bridge between them. The <strong class="source-inline1">ros_gz_bridge</strong> package does that for us, so we will use this package. We will only need to provide some configuration to specify which topics we want to bridge; how to write this configuration will be covered later in the chapter.</p>
			<div><div><img alt="Figure 13.2: Connecting Gazebo and ROS 2 with ros_gz_bridge" src="img/B22403_13_2.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.2: Connecting Gazebo and ROS 2 with ros_gz_bridge</p>
			<p class="calibre3">In <em class="italic">Figure 13</em><em class="italic">.2</em>, you can see the following:</p>
			<ul class="calibre9">
				<li class="calibre10">On the right, our current ROS 2 application with the <code>robot_state_publisher</code> node, publishing on the <code>/</code><code>tf</code> topic.</li>
				<li class="calibre10">On the left, <code>Gazebo</code>. Inside <code>Gazebo</code>, we will add plugins (also called systems) to simulate <a id="_idIndexMarker839" class="pcalibre calibre4 pcalibre1"/>the hardware behavior of the robot. For example, you could have one plugin to control the two wheels, and one plugin <a id="_idIndexMarker840" class="pcalibre calibre4 pcalibre1"/>to publish the joint states for the wheels. This is what we will implement in this chapter.</li>
				<li class="calibre10">Then, to make everything work together, we will use the <code>ros_gz_bridge</code> package. With the joint state example, the Gazebo Joint state publisher plugin will publish the joint states with a Gazebo topic. Using <code>ros_gz_bridge</code>, we will match this topic with the ROS 2 <code>/</code><code>joint_states</code> topic.</li>
			</ul>
			<p class="calibre3">The important thing to understand here is that Gazebo and ROS 2 exist in two different environments, but you can make them work together. Your ROS 2 application will be the same, whether you work on a Gazebo simulation or a real robot. If you work on a real robot, then you would directly control the wheels and get the joint state data from encoders. With Gazebo, you use plugins to simulate the hardware.</p>
			<p class="calibre3">Now, here are the steps we will take in the following sections to create the Gazebo simulation for our robot:</p>
			<ol class="calibre11">
				<li class="calibre10">Adapt the URDF for Gazebo. For a robot to work on Gazebo, we first need to provide inertial and collision properties in the URDF.</li>
				<li class="calibre10">Once the URDF is correct, we will start Gazebo and spawn the URDF in it. At this point, we will also create a package with a launch file.</li>
				<li class="calibre10">We will then add some plugins (systems) to control the robot, using the <code>ros_gz_bridge</code> package to make those plugins communicate with our ROS 2 application.</li>
			</ol>
			<p class="calibre3">You can <a id="_idIndexMarker841" class="pcalibre calibre4 pcalibre1"/>follow this process for basically any ROS 2 robot you <a id="_idIndexMarker842" class="pcalibre calibre4 pcalibre1"/>want to simulate in Gazebo. If some things are still not clear, continue with the chapter, work on the implementation, and come back to this section at the end. Everything will make more sense.</p>
			<p class="calibre3">Let’s start with<a id="_idTextAnchor626" class="pcalibre calibre4 pcalibre1"/> the first step.</p>
			<h1 id="_idParaDest-299" class="calibre6"><a id="_idTextAnchor627" class="pcalibre calibre4 pcalibre1"/>Adapting the URDF for Gazebo</h1>
			<p class="calibre3">We could try to spawn our robot directly into Gazebo, but it won’t work, as the URDF is missing two key elements—inertial and collision properties. Gazebo needs those to correctly simulate a robot.</p>
			<p class="calibre3">Thus, before we <a id="_idIndexMarker843" class="pcalibre calibre4 pcalibre1"/>do anything with Gazebo, we need to come back to our URDF and add those properties. For each link of the robot that represents a physical part, we will add an <strong class="source-inline1">&lt;inertial&gt;</strong> tag and a <strong class="source-inline1">&lt;collision&gt;</strong> tag. In this section, you will learn how to properly configure those.</p>
			<p class="calibre3">We will modify the URDF we created in the <strong class="source-inline1">my_robot_description</strong> package. As a quick recap, this package contains the URDF, a launch file to display the robot model in RViz, and an RViz configuration. The most important thing in this package is the URDF. The launch file will help us validate that the values we set in the URDF are correct.</p>
			<p class="calibre3">Let’s start with the inertial properties and then add th<a id="_idTextAnchor628" class="pcalibre calibre4 pcalibre1"/>e collision ones.</p>
			<h2 id="_idParaDest-300" class="calibre6"><a id="_idTextAnchor629" class="pcalibre calibre4 pcalibre1"/>Inertial tags</h2>
			<p class="calibre3">A URDF without inertial properties won’t load in Gazebo. Thus, this is the first thing you need to add.</p>
			<p class="calibre3">An <strong class="source-inline1">&lt;inertial&gt;</strong> tag will contain a few elements, including a 3x3 matrix representing an inertia tensor. In this book, we won’t dive into the theoretical inertia details; you can look that <a id="_idIndexMarker844" class="pcalibre calibre4 pcalibre1"/>up on your own if you want, as there is pretty good documentation on the internet. Instead, we will focus on finding the correct formulas and applying them, allowing us to spawn the robot and quickly move on to the next steps.</p>
			<p class="calibre3">So, currently, our URDF is split into three files. We will add some code to those files:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>common_properties.xacro</code>: Here, we will add some macros to specify the inertial properties for a box, a cylinder, and a sphere. This way, we only need to write the inertial formulas once for those shapes, and you can reuse them in any of your projects.</li>
				<li class="calibre10"><code>mobile_robot.xacro</code>: Inside each link representing a physical part, we will use the corresponding inertial macro we defined previously.</li>
				<li class="calibre10"><code>my_robot.urdf.xacro</code>: Nothing changes here; we still import the two previous files.</li>
			</ul>
			<p class="calibre3">Now, how do we write the inertial macros for the shapes we<a id="_idTextAnchor630" class="pcalibre calibre4 pcalibre1"/> have in our URDF?</p>
			<h3 class="calibre8">What do we write inside an &lt;inertial&gt; tag?</h3>
			<p class="calibre3">We will create three Xacro macros containing an <strong class="source-inline1">&lt;inertial&gt;</strong> tag—one for a box, one for a <a id="_idIndexMarker845" class="pcalibre calibre4 pcalibre1"/>cylinder, and one for a sphere. Inside a URDF <strong class="source-inline1">&lt;inertial&gt;</strong> tag, you will need to provide:</p>
			<ul class="calibre9">
				<li class="calibre10">The mass of the element (in kg).</li>
				<li class="calibre10">The origin for the inertia (in meters and radians).</li>
				<li class="calibre10">The nine elements of the inertia tensor, or matrix (in kg per sqm). Since the matrix is symmetrical, we only need six elements—<code>ixx</code>, <code>ixy</code>, <code>ixz</code>, <code>iyy</code>, <code>iyz</code>, and <code>izz</code> (for example, <code>ixy</code> and <code>iyx</code> are the same, so we omit the second one).</li>
			</ul>
			<p class="calibre3">As we don’t have a physical robot for this project, we will arbitrarily decide on a mass property for each link—while, of course, trying to have values that make sense.</p>
			<p class="calibre3">Now, how do we compute the inertia matrix? This is usually the hardest part when writing the <strong class="source-inline1">&lt;</strong><strong class="source-inline1">inertial&gt;</strong> tags.</p>
			<p class="calibre3">If you are designing your robot with CAD software—for example, with <strong class="bold">SolidWorks</strong>—then you can export each property directly from the software and add them to your URDF. As we <a id="_idIndexMarker846" class="pcalibre calibre4 pcalibre1"/>don’t have this software, we will need to make the computation ourselves.</p>
			<p class="calibre3">Fortunately, there are some helpful resources on the internet. You can find a list of moments of inertia on Wikipedia: <a href="https://en.wikipedia.org/wiki/List_of_moments_of_inertia" class="pcalibre calibre4 pcalibre1">https://en.wikipedia.org/wiki/List_of_moments_of_inertia</a>. There, you can also find the moment of inertia for each simple shape that we have, as well as a list of 3D inertia tensors, which are basically the matrices we need for the URDF. One thing to note is that the matrices only have three non-zero components—<strong class="source-inline1">ixx</strong>, <strong class="source-inline1">iyy</strong>, and <strong class="source-inline1">izz</strong>. All the other components are set to <strong class="source-inline1">0</strong>.</p>
			<p class="calibre3">With this information, we can start writing <a id="_idTextAnchor631" class="pcalibre calibre4 pcalibre1"/>the <strong class="source-inline1">&lt;</strong><strong class="source-inline1">inertial&gt;</strong> tags.</p>
			<h3 class="calibre8">Adding inertial macros for basic shapes</h3>
			<p class="calibre3">As the inertial macros for basic shapes could be used by any robot, we will add all macros <a id="_idIndexMarker847" class="pcalibre calibre4 pcalibre1"/>in the <strong class="source-inline1">common_properties.xacro</strong> file. This way, if you want to create another URDF for another robot, you can just reuse this Xacro file.</p>
			<p class="calibre3">The first macro will be for a box inertia. Now, if you look at the preceding Wikipedia link, things could be a bit confusing, as they use <strong class="bold">width</strong>, <strong class="bold">depth</strong>, and <strong class="bold">height</strong> (<em class="italic">w</em>, <em class="italic">d</em>, and <em class="italic">h</em>). In ROS 2, we have specified the length, width, and height for the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> dimensions. Which one corresponds to which?</p>
			<p class="calibre3">One easy way to write this matrix properly is to realize that one component for one dimension uses the two other dimensions. For example, to compute the <em class="italic">w</em> component (<strong class="source-inline1">ixx</strong> in the matrix), we use <em class="italic">h</em> (<em class="italic">z</em>) and <em class="italic">d</em> (<em class="italic">y</em>). Only following this can remove a lot of confusion, especially with the different naming conventions.</p>
			<p class="calibre3">Here is what we will use (on the left, the Wikipedia value, and on the right, the ROS 2 value):</p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">w</strong>: the <em class="italic">x</em> dimension</li>
				<li class="calibre10"><strong class="bold">d</strong>: the <em class="italic">y</em> dimension</li>
				<li class="calibre10"><strong class="bold">h</strong>: the <em class="italic">z</em> dimension (this is also the axis pointing up)</li>
			</ul>
			<p class="calibre3">Here is the <strong class="source-inline1">&lt;inertial&gt;</strong> tag for a box. You can add this after the <strong class="source-inline1">&lt;material&gt;</strong> tags, inside the <strong class="source-inline1">&lt;</strong><strong class="source-inline1">robot&gt;</strong> tag:</p>
			<pre class="source-code">
&lt;xacro:macro name="box_inertia" params="m x y z o_xyz o_rpy"&gt;
    &lt;inertial&gt;
        &lt;mass value="${m}" /&gt;
        &lt;origin xyz="${o_xyz}" rpy="${o_rpy}" /&gt;
        &lt;inertia ixx="${(m/12) * (z*z + y*y)}" ixy="0" ixz="0"
                 iyy="${(m/12) * (x*x + z*z)}" iyz="0"
                 izz="${(m/12) * (x*x + y*y)}" /&gt;
    &lt;/inertial&gt;
&lt;/xacro:macro&gt;</pre>			<p class="calibre3">To make it simple, I used <strong class="source-inline1">x</strong>, <strong class="source-inline1">y</strong>, and <strong class="source-inline1">z</strong> directly (instead of <em class="italic">w</em>, <em class="italic">d</em>, and <em class="italic">h</em>), which will make things <a id="_idIndexMarker848" class="pcalibre calibre4 pcalibre1"/>easier when we need to use the macro in our links, where the box dimensions are defined with <strong class="source-inline1">x</strong>, <strong class="source-inline1">y</strong>, and <strong class="source-inline1">z</strong>. When you develop an API/interface/macro/function, the best practice is to design the interface for the client of the API, not for the developer who’s writing the API.</p>
			<p class="calibre3">Let’s now write the macro for a cylinder. This one is a bit easier. We have two components—radius and height. This will correspond to the radius and length we defined in the URDF:</p>
			<pre class="source-code">
&lt;xacro:macro name="cylinder_inertia" params="m r l o_xyz o_rpy"&gt;
    &lt;inertial&gt;
        &lt;mass value="${m}" /&gt;
        &lt;origin xyz="${o_xyz}" rpy="${o_rpy}" /&gt;
        &lt;inertia ixx="${(m/12) * (3*r*r + l*l)}" ixy="0" ixz="0"
                 iyy="${(m/12) * (3*r*r + l*l)}" iyz="0"
                 izz="${(m/2) * (r*r)}" /&gt;
    &lt;/inertial&gt;
&lt;/xacro:macro&gt;</pre>			<p class="calibre3">Finally, we <a id="_idIndexMarker849" class="pcalibre calibre4 pcalibre1"/>can write the macro for a (solid) sphere. This is the easiest, and we only have one component —the sphere radius:</p>
			<pre class="source-code">
&lt;xacro:macro name="sphere_inertia" params="m r o_xyz o_rpy"&gt;
    &lt;inertial&gt;
        &lt;mass value="${m}" /&gt;
        &lt;origin xyz="${o_xyz}" rpy="${o_rpy}" /&gt;
        &lt;inertia ixx="${(2/5) * m * r * r}" ixy="0" ixz="0"
                 iyy="${(2/5) * m * r * r}" iyz="0"
                 izz="${(2/5) * m * r * r}" /&gt;
    &lt;/inertial&gt;
&lt;/xacro:macro&gt;</pre>			<p class="calibre3">With those three macros, we have everything we need for all <a id="_idTextAnchor632" class="pcalibre calibre4 pcalibre1"/>the basic URDF shapes.</p>
			<h3 class="calibre8">Including the inertial macros in the links</h3>
			<p class="calibre3">We can <a id="_idIndexMarker850" class="pcalibre calibre4 pcalibre1"/>now use those macros to provide the inertial property for each link of the robot.</p>
			<p class="calibre3">As the <strong class="source-inline1">base_footprint</strong> doesn’t represent a physical part (it’s what we call a virtual link), it won’t have an inertia. For all the other links (base, right wheel, left wheel, and sphere), we will use the inertial macros.</p>
			<p class="calibre3">Open the <strong class="source-inline1">mobile_base.xacro</strong> file, which is where we will continue with the code.</p>
			<p class="calibre3">Now, to add the inertial property for a link, you need to add an <strong class="source-inline1">&lt;inertial&gt;</strong> tag inside the <strong class="source-inline1">&lt;link&gt;</strong> tag. To add this tag, we will use the macros we previously created.</p>
			<p class="calibre3">Let’s start with <strong class="source-inline1">base_link</strong>. Inside the <strong class="source-inline1">&lt;link name="base_link"&gt;&lt;/link&gt;</strong> tag, and after the <strong class="source-inline1">&lt;visual&gt;</strong> tag, add the <strong class="source-inline1">box_inertia</strong> macro:</p>
			<pre class="source-code">
&lt;xacro:box_inertia m="5.0" x="${base_length}" y="${base_width}" z="${base_height}" o_xyz="0 0 ${base_height / 2.0}" o_rpy="0 0 0" /&gt;</pre>			<p class="callout-heading">Note</p>
			<p class="callout">Both the <code>&lt;visual&gt;</code> and <code>&lt;inertial&gt;</code> tags are children of the <code>&lt;link&gt;</code> tag; do not add the <code>&lt;inertial&gt;</code> tag inside the <code>&lt;</code><code>visual&gt;</code> tag.</p>
			<p class="calibre3">We <a id="_idIndexMarker851" class="pcalibre calibre4 pcalibre1"/>specify all the parameters required for the macro:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>5.0</code> kg.</li>
				<li class="calibre10"><code>x</code>, <code>y</code>, and <code>z</code> dimensions (we have created the macro so that we can use the ROS 2 axis system convention).</li>
				<li class="calibre10"><code>&lt;inertial&gt;</code> tags, we will verify the inertia in RViz. There, you can easily see whether the inertia is correctly placed.</li>
			</ul>
			<p class="calibre3">Now, add the inertia for the two wheels. You will add the <strong class="source-inline1">cylinder_inertia</strong> macro inside the <strong class="source-inline1">wheel_link</strong> macro (it’s perfectly fine to use a macro within another macro). Make sure to place it inside the <strong class="source-inline1">&lt;link&gt;</strong> tag and after the <strong class="source-inline1">&lt;visual&gt;</strong> tag. This inertia macro will apply to both wheels:</p>
			<pre class="source-code">
&lt;xacro:cylinder_inertia m="1.0" r="${wheel_radius}" l="${wheel_length}" o_xyz="0 0 0" o_rpy="${pi / 2.0} 0 0" /&gt;</pre>			<p class="calibre3">Here are the parameters we specify:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>1.0</code> kg.</li>
				<li class="calibre10"><strong class="bold">Cylinder properties</strong>: The radius and length of the cylinder.</li>
				<li class="calibre10"><code>z</code> axis. The wheels’ visual has been shifted by 90° on the <code>x</code> axis so that the rotation axis becomes the <code>y</code> axis. Here, we provide the same rotation for the origin. Basically, once again, you can use the same values you wrote in the visual origin.</li>
			</ul>
			<p class="calibre3">Finally, we add the <strong class="source-inline1">sphere_inertia</strong> macro for <strong class="source-inline1">caster_wheel_link</strong>:</p>
			<pre class="source-code">
&lt;xacro:sphere_inertia m="0.5" r="${wheel_radius / 2.0}"
    o_xyz="0 0 0" o_rpy="0 0 0" /&gt;</pre>			<p class="calibre3">This one <a id="_idIndexMarker852" class="pcalibre calibre4 pcalibre1"/>is quite easy. We choose <strong class="source-inline1">0.5</strong> kg for the mass, and then we provide <strong class="source-inline1">radius</strong>, which is the only sphere property. We don’t need to specify any offset for the origin.</p>
			<p class="calibre3">That’s it for the <strong class="source-inline1">&lt;inertial&gt;</strong> tags. The main difficulty was to define the macro for the simple shapes (but you only need to do this once), and then to correctly use the macros and provide the correct origin. Let’s now verify that we provided the correct dimension value<a id="_idTextAnchor633" class="pcalibre calibre4 pcalibre1"/>s and origins, using RViz.</p>
			<h3 class="calibre8">Validating inertia with RViz</h3>
			<p class="calibre3">To make sure that the inertial property is correct for each link, you can use RViz. As we already <a id="_idIndexMarker853" class="pcalibre calibre4 pcalibre1"/>have created a launch file inside the <strong class="source-inline1">my_robot_description</strong> package, let’s use it to visualize the URDF in RViz.</p>
			<p class="calibre3">Don’t forget to build and source the workspace before you start RViz. Then, start the launch file:</p>
			<pre class="console">
$ ros2 launch my_robot_description display.launch.xml</pre>			<p class="calibre3">You will see the same view and configuration from the previous chapter. To see the inertia, first disable the visual. On the left menu, open <strong class="bold">RobotModel</strong> and uncheck <strong class="bold">Visual Enabled</strong>. Then, still inside <strong class="bold">RobotModel</strong>, open <strong class="bold">Mass Properties</strong> and check the <strong class="bold">Inertia</strong> box. You should see something like this:</p>
			<div><div><img alt="Figure 13.3: Visualizing inertia in RViz" src="img/B22403_13_3.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.3: Visualizing inertia in RViz</p>
			<p class="calibre3">With this view, you can easily spot errors. For example, if the offset for the <strong class="source-inline1">base_link</strong> inertia <a id="_idIndexMarker854" class="pcalibre calibre4 pcalibre1"/>is not right, then the box will not be correctly placed. Another common error will be in the rotation of the wheel inertia. In the preceding figure, you can see that the inertia box is more or less on top of the wheel, correctly orientated. If that’s not the case, you know you have to fix the inertia in the code.</p>
			<p class="calibre3">Once you are done with the <strong class="source-inline1">&lt;inertial&gt;</strong> tags, you ca<a id="_idTextAnchor634" class="pcalibre calibre4 pcalibre1"/>n add the <strong class="source-inline1">&lt;</strong><strong class="source-inline1">collision&gt;</strong> tags.</p>
			<h2 id="_idParaDest-301" class="calibre6"><a id="_idTextAnchor635" class="pcalibre calibre4 pcalibre1"/>Collision tags</h2>
			<p class="calibre3">So far, inside <a id="_idIndexMarker855" class="pcalibre calibre4 pcalibre1"/>each link of our URDF, we have a <strong class="source-inline1">&lt;visual&gt;</strong> tag to <a id="_idIndexMarker856" class="pcalibre calibre4 pcalibre1"/>see the link and an <strong class="source-inline1">&lt;inertial&gt;</strong> tag to describe the physical properties for Gazebo.</p>
			<p class="calibre3">However, there is something missing. The visual is only for you to visualize the link in RViz or Gazebo. However, Gazebo needs more than this to simulate the robot. You will have to add <strong class="source-inline1">&lt;collision&gt;</strong> tags to the links so that Gazebo can compute how two parts collide with each other.</p>
			<p class="calibre3">To give you an idea, if you don’t have any collision property for your robot, then the robot will fall through the ground and continue falling indefinitely. With a collision property, the robot will <em class="italic">collide</em> with the ground and, thus, not fall. On top of that, that property <a id="_idIndexMarker857" class="pcalibre calibre4 pcalibre1"/>will be used to compute collisions between different parts of the robot, or collisions with other robots and elements in an environment. For example, if the <a id="_idIndexMarker858" class="pcalibre calibre4 pcalibre1"/>robot collides with a wall or an object, it will bump into it and not go through it. Once again, the <strong class="source-inline1">&lt;visual&gt;</strong> tag doesn’t do any of this.</p>
			<p class="calibre3">Before we write the <strong class="source-inline1">&lt;collision&gt;</strong> tags for our robot, let’s unders<a id="_idTextAnchor636" class="pcalibre calibre4 pcalibre1"/>tand how to define a collision.</p>
			<h3 class="calibre8">How to define a collision element</h3>
			<p class="calibre3">A <strong class="source-inline1">&lt;collision&gt;</strong> tag will contain more or less the same thing as a <strong class="source-inline1">&lt;visual&gt;</strong> tag: <strong class="source-inline1">&lt;geometry&gt;</strong> and <strong class="source-inline1">&lt;origin&gt;</strong> tags. You will basically define a shape.</p>
			<p class="calibre3">As a general rule, for a collision, you will use a simpler shape than for the visual (if possible). The reason is simple—the more complex the shape, the more computation power will <a id="_idIndexMarker859" class="pcalibre calibre4 pcalibre1"/>be required to compute the collision between the link and other elements. This could slow down the simulation a lot. Thus, designing simpler shapes is a best practice.</p>
			<p class="calibre3">Here are <a id="_idIndexMarker860" class="pcalibre calibre4 pcalibre1"/>a few more details about defining a collision element:</p>
			<ul class="calibre9">
				<li class="calibre10">If you are using complex Collada files (a few MB) for visuals, use simpler Collada or even STL files for the collisions. You can add those files to the <code>meshes</code> folder and include them in the URDF.</li>
				<li class="calibre10">If the shape is close to a basic one (a box, cylinder, or sphere), then you can use a basic shape for the collision. For example, if you design a mobile robot and the base of the robot looks like a box, then you can use a complex Collada or STL file for the visual, only using a box for the collision. For a wheel, you can use a cylinder, sphere, and so on.</li>
				<li class="calibre10">Even when using basic shapes, you could reduce the complexity—for example, by using a box for a collision when the visual is a cylinder or a sphere (however, we will see an exception to this later in this section in order to reduce friction in Gazebo).</li>
			</ul>
			<p class="calibre3">To find real examples of this shape simplification, you can simply search on GitHub for existing projects. Find a robot powered by ROS 2, and type <strong class="source-inline1">&lt;name of the robot&gt; </strong>+ <strong class="source-inline1">description</strong> + <strong class="source-inline1">github</strong> into Google—you can try with the <em class="italic">TurtleBot 3</em> (or a more recent version) robot. You will usually find a package similar to the one you created in the previous <a id="_idIndexMarker861" class="pcalibre calibre4 pcalibre1"/>chapter. In this package, search for the URDF or Xacro files, and find the <strong class="source-inline1">&lt;collision&gt;</strong> tags. You will often see that the collision uses a simplified STL file or a basic URDF shape.</p>
			<p class="calibre3">Now that we have this simplification mindset, let’s add the<a id="_idTextAnchor637" class="pcalibre calibre4 pcalibre1"/> <strong class="source-inline1">&lt;collision&gt;</strong> tags inside the URDF.</p>
			<h3 class="calibre8">Adding collision properties for the links</h3>
			<p class="calibre3">You will add <strong class="source-inline1">&lt;collision&gt;</strong> tags inside the <strong class="source-inline1">&lt;link&gt;</strong> tags, in the <strong class="source-inline1">mobile_base.xacro</strong> file.</p>
			<p class="calibre3">Pay <a id="_idIndexMarker862" class="pcalibre calibre4 pcalibre1"/>attention to where you add those tags. They should be at the same level as the <strong class="source-inline1">&lt;visual&gt;</strong> and <strong class="source-inline1">&lt;inertial&gt;</strong> tags, not inside them. The order doesn’t really matter, but to keep things clean, I usually start with <strong class="source-inline1">&lt;visual&gt;</strong>, then <strong class="source-inline1">&lt;collision&gt;</strong>, and finally, <strong class="source-inline1">&lt;inertial&gt;</strong>.</p>
			<p class="calibre3">Here is the <strong class="source-inline1">&lt;collision&gt;</strong> tag for <strong class="source-inline1">base_link</strong>:</p>
			<pre class="source-code">
&lt;collision&gt;
    &lt;geometry&gt;
        &lt;box size="${base_length} ${base_width} ${base_height}" /&gt;
    &lt;/geometry&gt;
    &lt;origin xyz="0 0 ${base_height / 2.0}" rpy="0 0 0" /&gt;
&lt;/collision&gt;</pre>			<p class="calibre3">A box is already the simplest shape you can have, so we just use another box. Then, we set the same dimensions and origin as for the visual. As you can see, adding the collision for this link basically means copying and pasting the content of the <strong class="source-inline1">&lt;visual&gt;</strong> tag (except for <strong class="source-inline1">&lt;material&gt;</strong>).</p>
			<p class="calibre3">Now, for the two wheels, the situation is a bit unique. They are cylinders, so it’s a quite basic shape. We could keep the same, or even use a box, which is much simpler.</p>
			<p class="calibre3">However, those wheels will be in direct contact with the floor in Gazebo. Using a box is not a good idea—imagine a car with square wheels; it’s probably not going to work well.</p>
			<p class="calibre3">We <a id="_idIndexMarker863" class="pcalibre calibre4 pcalibre1"/>could keep a cylinder, which is the second most simple shape, but if you do this, you might experience some unwanted friction later on in Gazebo, which will result in the robot not moving exactly how we want. For wheels that you control and that touch the floor, it’s best to use a sphere for the collision, as this reduces the number of contact points with the ground (basically, just one contact point) and, thus, reduces the unwanted friction.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This is more of a Gazebo <em class="italic">hack</em> than a real logical choice. Let’s be clear here—there is no way you can come up with this conclusion at this point; it’s something you have to experience in Gazebo and fix later. I’m not a big fan of such hacks, but sometimes, you don’t have a choice. Also, I’m giving you the correct solution beforehand to not make this chapter too long.</p>
			<p class="calibre3">Let’s add a sphere collision for our wheels, inside the <strong class="source-inline1">wheel_link</strong> macro:</p>
			<pre class="source-code">
&lt;collision&gt;
    &lt;geometry&gt;
        &lt;sphere radius="${wheel_radius}" /&gt;
    &lt;/geometry&gt;
    &lt;origin xyz="0 0 0" rpy="0 0 0" /&gt;
&lt;/collision&gt;</pre>			<p class="calibre3">We just use the wheel radius property; there is no need for the wheel length here. And since it’s a sphere, there’s no need to add any rotation for the origin.</p>
			<p class="calibre3">Finally, we add the collision for the caster wheel. As stated before, we could simplify the sphere with a box, but as the caster wheel is in direct contact with the ground, we don’t want to add unwanted friction. Thus, we use the same sphere for the visual and the collision:</p>
			<pre class="source-code">
&lt;collision&gt;
    &lt;geometry&gt;
        &lt;sphere radius="${wheel_radius / 2.0}" /&gt;
    &lt;/geometry&gt;
    &lt;origin xyz="0 0 0" rpy="0 0 0" /&gt;
&lt;/collision&gt;</pre>			<p class="calibre3">That’s <a id="_idIndexMarker864" class="pcalibre calibre4 pcalibre1"/>it for the <strong class="source-inline1">&lt;collision&gt;</strong> tags. The URDF <a id="_idTextAnchor638" class="pcalibre calibre4 pcalibre1"/>for our mobile robot is now complete.</p>
			<h3 class="calibre8">Validating collision with RViz</h3>
			<p class="calibre3">As with <a id="_idIndexMarker865" class="pcalibre calibre4 pcalibre1"/>everything we have written in the URDF, you can also visualize the collision properties in RViz.</p>
			<p class="calibre3">Build your workspace, source the environment, and start the <strong class="source-inline1">display.launch.xml</strong> launch file again.</p>
			<p class="calibre3">Open the <strong class="bold">RobotModel</strong> menu and uncheck the <strong class="bold">Visual Enabled</strong> box. Then, check the <strong class="bold">Collision </strong><strong class="bold">Enabled</strong> box.</p>
			<div><div><img alt="Figure 13.4: Visualizing collision in RViz" src="img/B22403_13_4.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.4: Visualizing collision in RViz</p>
			<p class="calibre3">There, you can see whether the collision properties are correct. In the <strong class="bold">Links</strong> menu (inside <strong class="bold">RobotModel</strong>), you can enable only some links if necessary, giving you a more precise view.</p>
			<p class="calibre3">If you see that some collision elements are not correctly placed, or if they are too big or too small, you can then go back to your URDF and fix them.</p>
			<p class="calibre3">As <a id="_idIndexMarker866" class="pcalibre calibre4 pcalibre1"/>you can see in the preceding figure, the collision view for the robot is almost the same as the visual. The difference is with the wheels, which are now spheres. You might also wonder, if the wheels are spheres, a part of them is inside the box, and thus they will collide with the box. That’s true, but this collision between adjacent links will not be taken into account by Gazebo.</p>
			<p class="calibre3">Now that you’ve added both the <strong class="source-inline1">&lt;inertial&gt;</strong> and <strong class="source-inline1">&lt;collision&gt;</strong> tags, we can go to the ne<a id="_idTextAnchor639" class="pcalibre calibre4 pcalibre1"/>xt step and spawn the robot in Gazebo.</p>
			<h1 id="_idParaDest-302" class="calibre6"><a id="_idTextAnchor640" class="pcalibre calibre4 pcalibre1"/>Spawning the robot in Gazebo</h1>
			<p class="calibre3">The first step of adapting the URDF for Gazebo was crucial, as without this, the robot either wouldn’t appear on Gazebo or behave incorrectly.</p>
			<p class="calibre3">Now that <a id="_idIndexMarker867" class="pcalibre calibre4 pcalibre1"/>the URDF is done (and has been verified in RViz), we can spawn the robot in Gazebo. In this section, you will see what commands <a id="_idIndexMarker868" class="pcalibre calibre4 pcalibre1"/>you need to run, and then we will create another package with a launch file to start everything.</p>
			<p class="calibre3">Here is what we will do:</p>
			<ol class="calibre11">
				<li class="calibre10">Run the <code>robot_state_publisher</code> node with the URDF as a parameter.</li>
				<li class="calibre10">Start the Gazebo simulator.</li>
				<li class="calibre10">Spawn the robot in Gazebo.</li>
			</ol>
			<p class="calibre3">Let’<a id="_idTextAnchor641" class="pcalibre calibre4 pcalibre1"/>s start this with the terminal commands.</p>
			<h2 id="_idParaDest-303" class="calibre6"><a id="_idTextAnchor642" class="pcalibre calibre4 pcalibre1"/>Spawning the robot from the terminal</h2>
			<p class="calibre3">As usual, before creating a launch file, we will run each command one by one in different <a id="_idIndexMarker869" class="pcalibre calibre4 pcalibre1"/>terminals, enabling us to clearly <a id="_idIndexMarker870" class="pcalibre calibre4 pcalibre1"/>understand what we need to run, with all the necessary details.</p>
			<p class="calibre3">Open three terminals to start all the commands.</p>
			<p class="calibre3">The first thing to start is the <strong class="source-inline1">robot_state_publisher</strong> node. This is what we did in <a href="B22403_12.xhtml#_idTextAnchor573" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 12</em></a>, and this is also usually the first thing you will start in any ROS 2 application.</p>
			<p class="calibre3">In Terminal 1, run the following command:</p>
			<pre class="console">
$ ros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:="$(xacro /home/&lt;user&gt;/my_robot_ws/src/my_robot_description/urdf/my_robot.urdf.xacro)"</pre>			<p class="calibre3">This is the same as in the previous chapter. We pass the URDF with the <strong class="source-inline1">robot_description</strong> parameter.</p>
			<p class="calibre3">After executing this command, the <strong class="source-inline1">robot_state_publisher</strong> node starts and does three things—subscribes to <strong class="source-inline1">/joint_states</strong>, publishes on <strong class="source-inline1">/tf</strong>, and also publishes the URDF on <strong class="source-inline1">/robot_description</strong>. You can verify this with <strong class="source-inline1">rqt_graph</strong> if needed (in this case, make sure to uncheck the <strong class="bold">Dead sinks</strong> and <strong class="bold">Leaf </strong><strong class="bold">topics</strong> boxes).</p>
			<p class="calibre3">In a second terminal, we start Gazebo. In fact, you could start Gazebo before <strong class="source-inline1">robot_state_publisher</strong>; the order doesn’t matter for those first two steps.</p>
			<p class="calibre3">In Terminal 2, run the following command:</p>
			<pre class="console">
$ ros2 launch ros_gz_sim gz_sim.launch.py gz_args:="empty.sdf -r"</pre>			<p class="calibre3">With this, we start an empty world in Gazebo. By default, the time is stopped when you launch Gazebo. We add the <strong class="source-inline1">-r</strong> option to start the time directly so that we don’t have to click the play button.</p>
			<p class="calibre3">Finally, once <a id="_idIndexMarker871" class="pcalibre calibre4 pcalibre1"/>you have done the first two steps, you can spawn the robot in Gazebo. For this, we will use the <strong class="source-inline1">create</strong> executable <a id="_idIndexMarker872" class="pcalibre calibre4 pcalibre1"/>from the <strong class="source-inline1">ros_gz_sim</strong> package. This will spawn a robot in Gazebo, using the URDF of the robot, which we can pass as a topic with the <strong class="source-inline1">-topic</strong> option. As the <strong class="source-inline1">robot_state_publisher</strong> node publishes the URDF on the <strong class="source-inline1">robot_description</strong> topic, we can use this topic.</p>
			<p class="calibre3">In Terminal 3, run the following command:</p>
			<pre class="console">
$ ros2 run ros_gz_sim create -topic robot_description</pre>			<p class="calibre3">After running this command, you should see the robot in Gazebo:</p>
			<div><div><img alt="Figure 13.5: The robot spawned in Gazebo" src="img/B22403_13_5.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.5: The robot spawned in Gazebo</p>
			<p class="calibre3">If you <a id="_idIndexMarker873" class="pcalibre calibre4 pcalibre1"/>get any error in any terminal, it probably <a id="_idIndexMarker874" class="pcalibre calibre4 pcalibre1"/>means that your URDF is not correct. In this case, go back to the Xacro files and double-check everything.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To see the importance of the <code>&lt;inertial&gt;</code> and <code>&lt;collision&gt;</code> tags, go back to the URDF, comment the inertia for the wheels, and then run the commands again. You will see that the wheels do not appear in Gazebo. Then, put the inertia back and comment the collision for the wheels. This time, the wheels will appear, but as they do not collide with the ground, you will see them going into the ground.</p>
			<p class="calibre3">Now that we know whic<a id="_idTextAnchor643" class="pcalibre calibre4 pcalibre1"/>h commands to run, let’s write a launch file.</p>
			<h2 id="_idParaDest-304" class="calibre6"><a id="_idTextAnchor644" class="pcalibre calibre4 pcalibre1"/>Spawning the robot from a launch file</h2>
			<p class="calibre3">We are <a id="_idIndexMarker875" class="pcalibre calibre4 pcalibre1"/>now going to write a launch file to start <a id="_idIndexMarker876" class="pcalibre calibre4 pcalibre1"/>those three commands. This will be a good base on which we can add more things later on.</p>
			<p class="calibre3">Let’s st<a id="_idTextAnchor645" class="pcalibre calibre4 pcalibre1"/>art by creating a new package in our workspace.</p>
			<h3 class="calibre8">Creating a _bringup package</h3>
			<p class="calibre3">If you remember what we did in <a href="B22403_09.xhtml#_idTextAnchor443" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 9</em></a>, the best practice is to create a dedicated package <a id="_idIndexMarker877" class="pcalibre calibre4 pcalibre1"/>for launch files and configuration files (we don’t have any configuration files yet, but we will add one later in this chapter).</p>
			<p class="calibre3">We made an exception for the <strong class="source-inline1">display.launch.xml</strong> file, which we placed inside the <strong class="source-inline1">my_robot_description</strong> package. As explained in <a href="B22403_12.xhtml#_idTextAnchor573" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 12</em></a>, this launch file is only used during development to visualize the URDF. Thus, it makes sense to have the launch file in the same package as the URDF. Here, and for any future launch and configuration files in our application, we will use a new dedicated package.</p>
			<p class="calibre3">Following the naming convention for such a package, we will start with the name of the robot or application, adding the <strong class="source-inline1">_bringup</strong> suffix. Thus, we will create the <strong class="source-inline1">my_robot_bringup</strong> package.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Be careful not to confuse this package with the <code>my_robot_bringup</code> package in the <code>ros2_ws</code> we created in <em class="italic">Part 2</em> of the book. Here, in <em class="italic">Part 3</em>, we are using another workspace, named <code>my_robot_ws</code>, so the <code>my_robot_bringup</code> package is a completely different one.</p>
			<p class="calibre3">Let’s create this package, remove the unnecessary folders, and add a <strong class="source-inline1">launch</strong> folder. We will also add a <strong class="source-inline1">config</strong> folder, which we will use later in the chapter:</p>
			<pre class="console">
$ cd ~/my_robot_ws/src/
$ ros2 pkg create my_robot_bringup --build-type ament_cmake
$ cd my_robot_bringup/
$ rm -r include/ src/
$ mkdir launch config</pre>			<p class="calibre3">Now, in the <strong class="source-inline1">CMakeLists.txt</strong> file of the <strong class="source-inline1">my_robot_bringup</strong> package, add the instruction to install the <strong class="source-inline1">launch</strong> and <strong class="source-inline1">config</strong> folders:</p>
			<pre class="source-code">
install(
  DIRECTORY launch config
  DESTINATION share/${PROJECT_NAME}/
)</pre>			<p class="calibre3">The package is correc<a id="_idTextAnchor646" class="pcalibre calibre4 pcalibre1"/>tly set up, so we can now add and install files.</p>
			<h3 class="calibre8">Writing the launch file</h3>
			<p class="calibre3">Let’s create, write, and install the launch file to spawn the robot in Gazebo.</p>
			<p class="calibre3">First, create <a id="_idIndexMarker878" class="pcalibre calibre4 pcalibre1"/>a new file inside the launch folder. As this launch file will be the main one, let’s simply use the name of the robot (or robotics application), <strong class="source-inline1">my_robot.launch.xml</strong>:</p>
			<pre class="console">
$ cd ~/my_robot_ws/src/my_robot_bringup/launch/
$ touch my_robot.launch.xml</pre>			<p class="calibre3">Open the file and write the minimal code for an XML launch file:</p>
			<pre class="source-code">
&lt;launch&gt;
&lt;/launch&gt;</pre>			<p class="calibre3">Then, inside this <strong class="source-inline1">&lt;launch&gt;</strong> tag, let’s add everything we need, step by step.</p>
			<p class="calibre3">The beginning of the launch file will be very similar to the <strong class="source-inline1">display.launch.xml</strong> file that we wrote in the previous chapter, so we can basically copy and paste a few parts. We start by adding a variable for the path to the URDF file:</p>
			<pre class="source-code">
&lt;let name="urdf_path" value="$(find-pkg-share my_robot_description)/urdf/my_robot.urdf.xacro" /&gt;</pre>			<p class="calibre3">Now, we can start the <strong class="source-inline1">robot_state_publisher</strong> node:</p>
			<pre class="source-code">
&lt;node pkg="robot_state_publisher" exec="robot_state_publisher"&gt;
    &lt;param name="robot_description"
           value="$(command 'xacro $(var urdf_path)')" /&gt;
&lt;/node&gt;</pre>			<p class="calibre3">Then, we start Gazebo with an empty world, and we also use the <strong class="source-inline1">-r</strong> option to start the time automatically:</p>
			<pre class="source-code">
&lt;include
    file="$(find-pkg-share ros_gz_sim)/launch/gz_sim.launch.py"&gt;
    &lt;arg name="gz_args" value="empty.sdf -r" /&gt;
&lt;/include&gt;</pre>			<p class="calibre3">Finally, we spawn the robot in Gazebo:</p>
			<pre class="source-code">
&lt;node pkg="ros_gz_sim" exec="create" args="-topic robot_description" /&gt;</pre>			<p class="calibre3">That’s it for <a id="_idIndexMarker879" class="pcalibre calibre4 pcalibre1"/>the launch file for now. Later, we will add more things and also start RViz to visualize the TFs. For now, we just want to see the robot in Gazebo.</p>
			<p class="calibre3">There is one thing we can do to make things a bit cleaner—as we are using files, nodes, and launch files from other packages, let’s add a dependency to them in the <strong class="source-inline1">package.xml</strong> file of the <strong class="source-inline1">my_robot_bringup</strong> package. After the <strong class="source-inline1">&lt;buildtool_depend&gt;</strong> line, add these lines:</p>
			<pre class="source-code">
&lt;exec_depend&gt;my_robot_description&lt;/exec_depend&gt;
&lt;exec_depend&gt;robot_state_publisher&lt;/exec_depend&gt;
&lt;exec_depend&gt;ros_gz_sim&lt;/exec_depend&gt;</pre>			<p class="calibre3">We use the less strict <strong class="source-inline1">&lt;exec_depend&gt;</strong> tag instead of <strong class="source-inline1">&lt;depend&gt;</strong>, as we only require those dependencies to run the launch file, not to compile any code. With this, if, for example, you didn’t install the <strong class="source-inline1">ros_gz_sim</strong> package and you try to build the <strong class="source-inline1">my_robot_bringup</strong> package, you will get an error when running <strong class="source-inline1">colcon build</strong>, and then you can fix things right away. Without those lines, the build would work, but you would then get an error when starting the launch file, which can be a big problem, especially in a production environment. So, the best practice is to specify all the dependencies you need in the <strong class="source-inline1">package.xml</strong> file.</p>
			<p class="calibre3">Now, save all the files, build the workspace, source the environment, and start the launch file (make sure that Gazebo is not running in another terminal before you do this):</p>
			<pre class="console">
$ ros2 launch my_robot_bringup my_robot.launch.xml</pre>			<p class="calibre3">You should get the same result <a id="_idTextAnchor647" class="pcalibre calibre4 pcalibre1"/>as when we ran all three commands in the terminal.</p>
			<h1 id="_idParaDest-305" class="calibre6"><a id="_idTextAnchor648" class="pcalibre calibre4 pcalibre1"/>Controlling the robot in Gazebo</h1>
			<p class="calibre3">Our mobile robot is now simulated in Gazebo with physics properties. Now what? The robot <a id="_idIndexMarker880" class="pcalibre calibre4 pcalibre1"/>is not doing anything. We will finish this chapter by <a id="_idIndexMarker881" class="pcalibre calibre4 pcalibre1"/>adding control plugins so that we can simulate the hardware of the robot and do the following:</p>
			<ul class="calibre9">
				<li class="calibre10">Send commands to make the robot move in Gazebo, just as if it were in the real world</li>
				<li class="calibre10">Read all necessary joint states from the robot to get all the TFs in our ROS 2 application</li>
			</ul>
			<p class="calibre3">Before we start discussing Gazebo systems and bridges, let’s dive a little bit deeper an<a id="_idTextAnchor649" class="pcalibre calibre4 pcalibre1"/>d understand what’s missing and what we need to add.</p>
			<h2 id="_idParaDest-306" class="calibre6"><a id="_idTextAnchor650" class="pcalibre calibre4 pcalibre1"/>What do we need to do?</h2>
			<p class="calibre3">When you start the <strong class="source-inline1">my_robot.launch.xml</strong> launch file, you see the robot in Gazebo. However, we don’t have any way to control it. In a terminal, if you list all nodes, topics, services, or even actions, you won’t find anything we can use.</p>
			<p class="calibre3">Also, after starting <a id="_idIndexMarker882" class="pcalibre calibre4 pcalibre1"/>the launch file, if you print the TF tree, you won’t see the TF for the right or left wheel. You can observe the same thing with RViz—to make things simple, you can start RViz using the previous configuration we saved:</p>
			<pre class="console">
$ ros2 run rviz2 rviz2 -d ~/my_robot_ws/src/my_robot_description/rviz/urdf_config.rviz</pre>			<p class="calibre3">You should see some errors in <strong class="bold">RobotModel</strong>, saying <strong class="bold">No transform from [left_wheel_link]</strong> and <strong class="bold">No transform </strong><strong class="bold">from [right_wheel_link]</strong>.</p>
			<div><div><img alt="Figure 13.6: TF errors in RViz after spawning the robot in Gazebo" src="img/B22403_13_6.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.6: TF errors in RViz after spawning the robot in Gazebo</p>
			<p class="calibre3">This lack of TF is <a id="_idIndexMarker883" class="pcalibre calibre4 pcalibre1"/>because nobody is publishing on the <strong class="source-inline1">/joint_states</strong> topic. In <a href="B22403_12.xhtml#_idTextAnchor573" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 12</em></a>, when we were just visualizing the robot model, we used a fake joint state publisher. We won’t do this here.</p>
			<p class="calibre3">So, what do we need to do?</p>
			<p class="calibre3">For a real robot, you would create a hardware driver to be able to control the wheels. This driver would expose a topic/service/action interface so that you could make the robot move. Then, you would read position/velocity data from encoders and publish this data on the <strong class="source-inline1">/joint_states</strong> topic. With this, the loop is closed.</p>
			<p class="calibre3">For a Gazebo simulation, we will do the same thing but, of course, without hardware. We will use Gazebo plugins (also called systems) to simulate the control of the robot and get the joint states. Then, we will configure a <em class="italic">bridge</em> to make those plugins communicate with our RO<a id="_idTextAnchor651" class="pcalibre calibre4 pcalibre1"/>S 2 application.</p>
			<p class="calibre3">Let’s start with the Gazebo systems.</p>
			<h2 id="_idParaDest-307" class="calibre6"><a id="_idTextAnchor652" class="pcalibre calibre4 pcalibre1"/>Adding Gazebo systems</h2>
			<p class="calibre3">A Gazebo <a id="_idIndexMarker884" class="pcalibre calibre4 pcalibre1"/>system is basically the simulation of a hardware component. You could have a system simulating a camera and publishing images, another one monitoring a battery state, and so on. For this book, we will use two systems—one to control a differential drive robot (two parallel wheels), and one to publish the joint states.</p>
			<p class="calibre3">Now, the good news is that there are a lot of existing systems already available to use, including the two that we need.</p>
			<p class="calibre3">The bad news is that documentation for those systems is almost non-existent (at the time of writing), and you will have to dive into the code itself to find what to include in your own code. Don’t worry about that—we will do this process step by step, and it is replicable for any other system that you use.</p>
			<p class="calibre3">For Gazebo <a id="_idIndexMarker885" class="pcalibre calibre4 pcalibre1"/>Harmonic and ROS 2 Jazzy, you can find all available Gazebo systems here on GitHub: <a href="https://github.com/gazebosim/gz-sim/tree/gz-sim8/src/systems" class="pcalibre calibre4 pcalibre1">https://github.com/gazebosim/gz-sim/tree/gz-sim8/src/systems</a> (for other Gazebo versions, you might have to use a different branch).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If there was not enough confusion already, on the internet you will often see the term <em class="italic">plugin</em> or <em class="italic">system</em>; they both refer to the same thing. Even if the word <em class="italic">system</em> should be preferred, in practice it’s not clear which one to use; for example, to include a system in our code, we will need to use a <code>&lt;plugin&gt;</code> tag. So, in this section, I will have to use both terms.</p>
			<p class="calibre3">Now, where are we going to add our systems for the <a id="_idTextAnchor653" class="pcalibre calibre4 pcalibre1"/>robot we want to simulate? We will do this in the URDF.</p>
			<h3 class="calibre8">Xacro file for Gazebo</h3>
			<p class="calibre3">The Gazebo systems for our robot will be specified in the URDF. So, we need to return to the <strong class="source-inline1">my_robot_description</strong> package.</p>
			<p class="calibre3">Our URDF is <a id="_idIndexMarker886" class="pcalibre calibre4 pcalibre1"/>now split into three files: one with common properties, one with the description of the robot (links and joints), and one to include the other two.</p>
			<p class="calibre3">To add the Gazebo systems, we will create yet another Xacro file, dedicated to all Gazebo-related stuff. By separating this file from the other ones, we make things cleaner. If, later on, you want to use the URDF without Gazebo, you only need to remove the inclusion of the Gazebo file.</p>
			<p class="calibre3">In the <strong class="source-inline1">urdf</strong> folder of your <strong class="source-inline1">my_robot_description</strong> package, add a fourth file, named <strong class="source-inline1">mobile_base_gazebo.xacro</strong>.</p>
			<p class="calibre3">Open the file and add the minimal Xacro code:</p>
			<pre class="source-code">
&lt;?xml version="1.0"?&gt;
&lt;robot &gt;
&lt;/robot&gt;</pre>			<p class="calibre3">Now, in <strong class="source-inline1">my_robot.urdf.xacro</strong>, include the file after the two other ones:</p>
			<pre class="source-code">
&lt;xacro:include filename="$(find my_robot_description)/urdf/mobile_base_gazebo.xacro" /&gt;</pre>			<p class="calibre3"><a id="_idTextAnchor654" class="pcalibre calibre4 pcalibre1"/>The Xacro <a id="_idIndexMarker887" class="pcalibre calibre4 pcalibre1"/>file is ready, and we can now add the systems.</p>
			<h3 class="calibre8">Differential drive controller</h3>
			<p class="calibre3">The first system we will add is a <strong class="bold">differential drive controller</strong>. By differential drive, we mean <a id="_idIndexMarker888" class="pcalibre calibre4 pcalibre1"/>a robot controlled by two wheels, one on each side of the robot.</p>
			<p class="calibre3">If you <a id="_idIndexMarker889" class="pcalibre calibre4 pcalibre1"/>browse the available systems (the link is provided on the preceding page), you can find a <strong class="source-inline1">diff_drive</strong> folder—usually <a id="_idIndexMarker890" class="pcalibre calibre4 pcalibre1"/>in ROS, we use <strong class="bold">diff drive</strong> as an abbreviation of <strong class="bold">differential drive</strong>.</p>
			<p class="calibre3">In this folder, you will see a <strong class="source-inline1">DiffDrive.hh</strong> file. Open this file, and there, near the beginning, you will find the XML tags related to the system (it’s possible that some tags will be missing here; for some systems, you might have to read the complete source code to find all available tags).</p>
			<p class="calibre3">Here is how to add the system to our Xacro file (<strong class="source-inline1">mobile_base_gazebo.xacro</strong>):</p>
			<pre class="source-code">
&lt;gazebo&gt;
    &lt;plugin
        filename="gz-sim-diff-drive-system"
        name="gz::sim::systems::DiffDrive"&gt;
        &lt;left_joint&gt;base_left_wheel_joint&lt;/left_joint&gt;
        &lt;right_joint&gt;base_right_wheel_joint&lt;/right_joint&gt;
        &lt;frame_id&gt;odom&lt;/frame_id&gt;
        &lt;child_frame_id&gt;base_footprint&lt;/child_frame_id&gt;
        &lt;wheel_separation&gt;0.45&lt;/wheel_separation&gt;
        &lt;wheel_radius&gt;0.1&lt;/wheel_radius&gt;
    &lt;/plugin&gt;
&lt;/gazebo&gt;</pre>			<p class="calibre3">We start <a id="_idIndexMarker891" class="pcalibre calibre4 pcalibre1"/>with a <strong class="source-inline1">&lt;gazebo&gt;</strong> tag. Everything related to Gazebo will be in such tags. Then, we include the system with a <strong class="source-inline1">&lt;plugin&gt;</strong> tag. We also need to specify the filename and name for the system.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Usually, the filename and name will follow this syntax:</p>
			<p class="callout"><code>gz-sim-&lt;name-with-dashes&gt;-system</code></p>
			<p class="callout"><code>gz::sim::systems::&lt;UpperCamelCaseName&gt;</code> (you can also find the name at the bottom of the <code>.cc</code> file of the system)</p>
			<p class="calibre3">Here is a bit more information about the different parameters for this diff drive system:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>left_joint</code> and <code>right_joint</code>: You need to provide the exact name of the joints you have defined for the wheels in the URDF.</li>
				<li class="calibre10"><code>frame_id</code>: As the robot moves, we will keep track of where it is relative to its starting <a id="_idIndexMarker892" class="pcalibre calibre4 pcalibre1"/>position. This starting position will be called <code>odom</code> (short for <strong class="bold">odometry</strong>).</li>
				<li class="calibre10"><code>child_frame_id</code>: We write <code>base_footprint</code>, as it is the root link for our robot and the one we want to use for odometry tracking.</li>
				<li class="calibre10"><code>wheel_separation</code>: We can compute that from the URDF. The base width is 0.4, and the origin for each wheel is centered on the wheel. As each wheel length is 0.05, we need to add 0.4 + 0.025 + 0.025, which makes <code>0.45</code>.</li>
				<li class="calibre10"><code>wheel_radius</code>: We get this value from the URDF, which is defined as <code>0.1</code>.</li>
				<li class="calibre10">Acceleration and velocity min and max: Optionally, you can set some limits. This can be a good idea so that the controller doesn’t accept a command that would make the robot move too fast and, potentially, become dangerous to itself or an environment. For the values, once again, you should use the metric system and radians for angles.</li>
			</ul>
			<p class="calibre3">That’s it <a id="_idIndexMarker893" class="pcalibre calibre4 pcalibre1"/>for the diff drive system. Now, in addition, there is one setting we need to add for the caster wheel. If you remember, the caster wheel is a passive joint, so we defined it as a fixed sphere.</p>
			<p class="calibre3">As the wheels turn and the robot moves, there will be some friction between the ground and the caster wheel. You won’t see the friction that much in Gazebo, but it will slow down the robot a bit, and later on, if you visualize the robot in RViz, you won’t have the same result.</p>
			<p class="calibre3">So, we will reduce the friction for the caster wheel. You can add this code just before the code for the diff drive system:</p>
			<pre class="source-code">
&lt;gazebo reference="caster_wheel_link"&gt;
    &lt;mu1 value="0.1" /&gt;
    &lt;mu2 value="0.1" /&gt;
&lt;/gazebo&gt;</pre>			<p class="calibre3">There are two parameters, <strong class="source-inline1">mu1</strong> and <strong class="source-inline1">mu2</strong>, that you can set to have more control over the friction. I have chose<a id="_idTextAnchor655" class="pcalibre calibre4 pcalibre1"/>n the value <strong class="source-inline1">0.1</strong>; later, you could reduce this value even more.</p>
			<h3 class="calibre8">Joint state publisher</h3>
			<p class="calibre3">We have <a id="_idIndexMarker894" class="pcalibre calibre4 pcalibre1"/>added a system to control the wheels, but before <a id="_idIndexMarker895" class="pcalibre calibre4 pcalibre1"/>we test it, let’s finish the Xacro file and add the second system we need. The diff drive system alone won’t publish the joint states for the wheels; we need to add a joint state publisher system.</p>
			<p class="calibre3">Go back to the systems page on GitHub, and you will find a <strong class="source-inline1">joint_state_publisher</strong> folder. In this folder, you can get the <em class="italic">documentation</em> for the XML tags in the <strong class="source-inline1">JointStatePublisher.hh</strong> file.</p>
			<p class="calibre3">Let’s add the system to the Xacro file, after the previous one:</p>
			<pre class="source-code">
&lt;gazebo&gt;
    &lt;plugin
        filename="gz-sim-joint-state-publisher-system"
        name="gz::sim::systems::JointStatePublisher"&gt;
    &lt;/plugin&gt;
&lt;/gazebo&gt;</pre>			<p class="calibre3">The joint <a id="_idIndexMarker896" class="pcalibre calibre4 pcalibre1"/>state publisher system is easier to set up. Also, we don’t specify any <strong class="source-inline1">&lt;joint_name&gt;</strong> tag here to publish all available joint states. If your robotics <a id="_idIndexMarker897" class="pcalibre calibre4 pcalibre1"/>system contains a lot of joints, it could be useful to only specify the joints you want to use.</p>
			<p class="calibre3">Our <strong class="source-inline1">mobile_base_gazebo.xacro</strong> file is now complete, and we won’t need to modify anything else in the URDF. We can spawn the<a id="_idTextAnchor656" class="pcalibre calibre4 pcalibre1"/> robot in Gazebo again and see how it interacts with those systems.</p>
			<h2 id="_idParaDest-308" class="calibre6"><a id="_idTextAnchor657" class="pcalibre calibre4 pcalibre1"/>Bridging Gazebo and ROS 2 communications</h2>
			<p class="calibre3">The last <a id="_idIndexMarker898" class="pcalibre calibre4 pcalibre1"/>thing we need to do, for this simulation to be complete, is to bridge Gaze<a id="_idTextAnchor658" class="pcalibre calibre4 pcalibre1"/>bo and ROS 2 communications.</p>
			<p class="calibre3">Let’s first understand what’s missing.</p>
			<h3 class="calibre8">What topics do we need to bridge?</h3>
			<p class="calibre3">If you remember, we talked about this at the beginning of the chapter. Gazebo uses topics and services, but those are independent from ROS 2. Thus, the systems we have just added will work, but they will only have a Gazebo interface.</p>
			<p class="calibre3">You can verify this by starting the <strong class="source-inline1">my_robot.launch.xml</strong> file again—make sure to compile and source the workspace beforehand so that you get the updated URDF.</p>
			<p class="calibre3">Then, in another terminal, list all Gazebo topics. The list will contain quite a lot of things; here, I only include the ones that we will use:</p>
			<pre class="console">
$ gz topic -l
/model/my_robot/tf
/world/empty/model/my_robot/joint_state
/model/my_robot/cmd_vel</pre>			<p class="calibre3">The first topic that ends with <strong class="source-inline1">/tf</strong> will contain the TF from the <strong class="source-inline1">odom</strong> frame to <strong class="source-inline1">base_footprint</strong>. The one with <strong class="source-inline1">/joint_state</strong> will contain the joint states for both wheels, and the topic with <strong class="source-inline1">/cmd_vel</strong> will be used to send a velocity command to the robot.</p>
			<p class="calibre3">However, if you check the ROS 2 topics with <strong class="source-inline1">ros2 topic list</strong>, you won’t see the <strong class="source-inline1">/cmd_vel</strong> topic. You will have <strong class="source-inline1">/joint_states</strong> and <strong class="source-inline1">/tf</strong>, but only because the <strong class="source-inline1">robot_state_publisher</strong> node creates a subscriber and publisher for those topics. Nothing is published; you can verify this with <strong class="source-inline1">ros2 topic </strong><strong class="source-inline1">echo &lt;topic&gt;</strong>.</p>
			<p class="calibre3">Thus, from the <a id="_idIndexMarker899" class="pcalibre calibre4 pcalibre1"/>ROS 2 side, we can’t communicate with Gazebo. We will need to create a bridge between ROS 2 and Gazebo using the <strong class="source-inline1">ros_gz_bridge</strong> package (see <em class="italic">Figure 13</em><em class="italic">.2</em> at the beginning of the chapter).</p>
			<p class="calibre3">To do that, we will run the <strong class="source-inline1">parameter_bridge</strong> node from the <strong class="source-inline1">ros_gz_bridge</strong> pac<a id="_idTextAnchor659" class="pcalibre calibre4 pcalibre1"/>kage, with a configuration for the interfaces that we want to bridge.</p>
			<h3 class="calibre8">Adding a configuration file to bridge topics</h3>
			<p class="calibre3">Let’s <a id="_idIndexMarker900" class="pcalibre calibre4 pcalibre1"/>start with the configuration file. In the <strong class="source-inline1">my_robot_bringup</strong> package, inside the <strong class="source-inline1">config</strong> folder (that we already created before), create a new file named <strong class="source-inline1">gazebo_bridge.yaml</strong>.</p>
			<p class="calibre3">Open this file to write the configuration. Here is the first bridge we will create:</p>
			<pre class="source-code">
- ros_topic_name: "/cmd_vel"
  gz_topic_name: "/model/my_robot/cmd_vel"
  ros_type_name: "geometry_msgs/msg/Twist"
  gz_type_name: "gz.msgs.Twist"
  direction: ROS_TO_GZ</pre>			<p class="calibre3">Here are the different fields that we will use:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>ros_topic_name</code>: The topic name on the ROS 2 side. Either you choose the topic name (<code>/cmd_vel</code> doesn’t exist yet, so we create it) or you make it match with an existing one (for the next one, we will have to specify exactly <code>/joint_states</code>).</li>
				<li class="calibre10"><code>gz_topic_name</code>: The topic name on the Gazebo size. We found it with <code>gz </code><code>topic -l</code>.</li>
				<li class="calibre10"><code>ros_type_name</code>: The topic interface for ROS 2.</li>
				<li class="calibre10"><code>gz_type_name</code>: The topic interface for Gazebo. You can find it with <code>gz topic -i -</code><code>t &lt;topic&gt;</code>.</li>
				<li class="calibre10"><code>direction</code>: Either <code>ROS_TO_GZ</code>, <code>GZ_TO_ROS</code>, or <code>BIDIRECTIONAL</code>. For example, <code>/cmd_vel</code> is a topic that we publish in ROS 2 and subscribe in Gazebo, so we use <code>ROS_TO_GZ</code>. For <code>/joint_states</code>, we publish in Gazebo and subscribe in ROS 2, so that will be <code>GZ_TO_ROS</code>. You can use <code>BIDIRECTIONAL</code> if you want to have publishers and subscribers on both sides of the same topic.</li>
			</ul>
			<p class="calibre3">As you <a id="_idIndexMarker901" class="pcalibre calibre4 pcalibre1"/>can see, we need to provide the topic name and interface on both sides and specify which direction to use for the communication. With this, the <strong class="source-inline1">ros_gz_bridge</strong> will create the connection.</p>
			<p class="calibre3">With this first bridge, we will be able to send commands to the robot to make it move with the diff drive system. Let’s now add the configuration for the <strong class="source-inline1">/joint_states</strong> topic (published by the joint state publisher system):</p>
			<pre class="source-code">
- ros_topic_name: "/joint_states"
  gz_topic_name: "/world/empty/model/my_robot/joint_state"
  ros_type_name: "sensor_msgs/msg/JointState"
  gz_type_name: "gz.msgs.Model"
  direction: GZ_TO_ROS</pre>			<p class="calibre3">That will allow us to get all joint states for the robot and, thus, see the wheel TFs in RViz. Finally, to get the <strong class="source-inline1">odom</strong> to <strong class="source-inline1">base_footprint</strong> TF (published by the diff drive system), we also add this bridge:</p>
			<pre class="source-code">
- ros_topic_name: "/tf"
  gz_topic_name: "/model/my_robot/tf"
  ros_type_name: "tf2_msgs/msg/TFMessage"
  gz_type_name: "gz.msgs.Pose_V"
  direction: GZ_TO_ROS</pre>			<p class="calibre3">The <a id="_idIndexMarker902" class="pcalibre calibre4 pcalibre1"/>configuration file is complete. As we have already added the instructio<a id="_idTextAnchor660" class="pcalibre calibre4 pcalibre1"/>n to install it in <strong class="source-inline1">CMakeLists.txt</strong>, there is no need to do anything else.</p>
			<h3 class="calibre8">Starting the Gazebo bridge with the configuration</h3>
			<p class="calibre3">We can now add a new node to our <strong class="source-inline1">my_robot.launch.xml</strong> file to start the bridge, using <a id="_idIndexMarker903" class="pcalibre calibre4 pcalibre1"/>the YAML configuration file we’ve just created.</p>
			<p class="calibre3">First, at the beginning of the file, let’s add a new variable to find the path for the configuration file:</p>
			<pre class="source-code">
&lt;let name="gazebo_config_path" value="$(find-pkg-share my_robot_bringup)/config/gazebo_bridge.yaml" /&gt;</pre>			<p class="calibre3">Then, after you spawn the robot in Gazebo with the <strong class="source-inline1">create</strong> executable from <strong class="source-inline1">ros_gz_sim</strong>, start the Gazebo bridge. You will need to pass the configuration file inside a <strong class="source-inline1">config_file</strong> parameter:</p>
			<pre class="source-code">
&lt;node pkg="ros_gz_bridge" exec="parameter_bridge"&gt;
    &lt;param name="config_file"
           value="$(var gazebo_config_path)" /&gt;
&lt;/node&gt;</pre>			<p class="calibre3">As we use the <strong class="source-inline1">ros_gz_bridge</strong> package inside <strong class="source-inline1">my_robot_bringup</strong>, we will also add a new dependency inside the <strong class="source-inline1">package.xml</strong> file:</p>
			<pre class="source-code">
&lt;exec_depend&gt;ros_gz_bridge&lt;/exec_depend&gt;</pre>			<p class="calibre3">The <a id="_idIndexMarker904" class="pcalibre calibre4 pcalibre1"/>Gazebo bridge is now correctly configured. When you start your <a id="_idTextAnchor661" class="pcalibre calibre4 pcalibre1"/>application, ROS 2 and Gazebo will be able to communicate with each other.</p>
			<h2 id="_idParaDest-309" class="calibre6"><a id="_idTextAnchor662" class="pcalibre calibre4 pcalibre1"/>Testing the robot</h2>
			<p class="calibre3">In this final section, we will make sure that everything works by testing the behavior of the robot, and also <a id="_idIndexMarker905" class="pcalibre calibre4 pcalibre1"/>by visualizing the robot and TFs in RViz.</p>
			<p class="calibre3">Save all files, build and source the workspace, and start the <strong class="source-inline1">my_robot.launch.xml</strong> file again.</p>
			<p class="calibre3">In another terminal, list all the topics, and you will see the <strong class="source-inline1">/cmd_vel</strong> topic that we configured previously. The interface for this topic is the same one we used for Turtlesim in <em class="italic">Part 2</em> of the book, so you should be familiar with it. Send a velocity command from the terminal:</p>
			<pre class="console">
$ ros2 topic pub /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.5}}"</pre>			<p class="calibre3">The robot should start moving in Gazebo (to stop, send the same command with <strong class="source-inline1">{x: 0.0}</strong>). If you see the robot moving, it means that the bridge is correctly configured, as the ROS 2 topic can reach the Gazebo system. It also means that the diff drive system works.</p>
			<p class="calibre3">To achieve a better way to control the robot and make more tests, you can run this node instead:</p>
			<pre class="console">
$ ros2 run teleop_twist_keyboard teleop_twist_keyboard</pre>			<p class="calibre3">This will listen to your keyboard and publish to the <strong class="source-inline1">/cmd_vel</strong> topic (if you use a different name for the topic, simply add a remapping with <strong class="source-inline1">–-</strong><strong class="source-inline1">ros-args -r</strong>).</p>
			<p class="calibre3">Now, we have validated that the robot can move in Gazebo when we send a command.</p>
			<p class="calibre3">To check the TFs, you can do the following:</p>
			<ul class="calibre9">
				<li class="calibre10">Subscribe to the <code>/joint_states</code> topic and see the states for both the right and left wheels</li>
				<li class="calibre10">Subscribe to the <code>/tf</code> topic and see all published TFs</li>
				<li class="calibre10">Print the TF tree (<code>ros2 run tf2_tools view_frames</code>), which should contain all the TFs, including the two TFs for the wheels and an additional one between the <code>odom</code> and <code>base_footprint</code></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">If something does not work or if some topic data is missing, then either one of the systems or bridges is not correctly configured. To solve this, first check the topics on the Gazebo side (the <code>gz topic</code> command line). If you see the correct data, then the bridge is wrong; if you don’t, start with the system.</p>
			<p class="calibre3">So, we can <a id="_idIndexMarker906" class="pcalibre calibre4 pcalibre1"/>control the robot and get the correct TFs in our ROS 2 application. Finally, let’s start RViz. You can use the command line, but you can also add RViz directly inside the launch file if you want to. In this case, we will first create a variable to find the RViz config path:</p>
			<pre class="source-code">
&lt;let name="rviz_config_path" value="$(find-pkg-share my_robot_description)/rviz/urdf_config.rviz" /&gt;</pre>			<p class="calibre3">We will use the file we previously created in <strong class="source-inline1">my_robot_description</strong>. You could also create a new RViz configuration file and install it in <strong class="source-inline1">my_robot_bringup</strong>. Then, we start RViz after all the other nodes:</p>
			<pre class="source-code">
&lt;node pkg="rviz2" exec="rviz2" args="-d $(var rviz_config_path)" /&gt;</pre>			<p class="calibre3">With this, when you start the launch file, you will have both Gazebo and RViz. The TF errors that we previously got in RViz (see <em class="italic">Figure 13</em><em class="italic">.6</em>) should not be there anymore.</p>
			<p class="calibre3">One thing you can do is to select <strong class="source-inline1">odom</strong> as the fixed frame, inside <strong class="bold">Global Options</strong>. With this setting, when the robot moves in Gazebo, you will also see it moving from its starting position in RViz.</p>
			<p class="calibre3">Our application is now finished. The Gazebo systems<a id="_idTextAnchor663" class="pcalibre calibre4 pcalibre1"/> correctly work and can communicate with the ROS 2 side. The loop is closed.</p>
			<h1 id="_idParaDest-310" class="calibre6"><a id="_idTextAnchor664" class="pcalibre calibre4 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, you learned how to simulate your robot in Gazebo.</p>
			<p class="calibre3">You first discovered how Gazebo works. Gazebo is a 3D simulation tool that can simulate gravity and the physical properties of your robot in the environment—unlike RViz, which is only a visualization tool, helpful for developing and debugging.</p>
			<p class="calibre3">Then, you followed the process to simulate a robot in Gazebo. Here is a recap of the steps:</p>
			<ol class="calibre11">
				<li class="calibre10">Before you even get started, make sure you have a URDF that properly describes all the links and joints of your robot (this is what we did in the previous chapters).</li>
				<li class="calibre10">Adapt the URDF for Gazebo by adding <code>&lt;inertial&gt;</code> and <code>&lt;collision&gt;</code> tags for each link. You can use RViz to visualize those properties and make sure they are correct.</li>
				<li class="calibre10">Spawn the robot in Gazebo. To do this, you first start the Gazebo simulator and the <code>robot_state_publisher</code> node. Then, you can spawn the robot.</li>
				<li class="calibre10">Control the robot with plugins (i.e., systems). To use a system, you will add a <code>&lt;plugin&gt;</code> tag to your URDF. Then, to be able to connect the Gazebo systems with ROS 2, you can use the <code>ros_gz_bridge</code> package and provide the bridge configuration in a YAML file.</li>
			</ol>
			<p class="calibre3">All along the way, we organized the application into two packages:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>my_robot_description</code>: This contains the URDF, including the links, joints, inertial and collision properties, and Gazebo systems</li>
				<li class="calibre10"><code>my_robot_bringup</code>: This contains the launch file to start the application and the YAML configuration file for the Gazebo bridge</li>
			</ul>
			<p class="calibre3">The project we started in <em class="italic">Part 3</em> is now complete. You have a fully working 3D simulation of a robot, and you can apply the whole process (not only from this chapter but also from all the previous ones) to any other custom robot that you create.</p>
			<p class="calibre3">Now, of course, that’s not the end; there are more things you may want to do with your robot and ROS 2. In the next chapter, we will conclude the book, and we will provide additional resources and tips for you to go further.</p>
		</div>
	</body></html>