- en: Chapter 6. Running Your Tests with Nose
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：使用Nose运行你的测试
- en: In the last chapter, we saw the `unittest` discover tool find our tests without
    being told explicitly where they were. That was pretty handy, compared to the
    way `doctest` had been making us tell it exactly where to find the tests it should
    run, particularly, when we're talking about a large source tree that has tests
    in many locations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了`unittest`发现工具在不明确告知它们位置的情况下找到我们的测试。与`doctest`让我们明确告诉它应该在哪里找到要运行的测试相比，这非常方便，尤其是当我们谈论一个包含许多位置的测试的大型源树时。
- en: Nose is a tool that expands on this idea. It's capable of finding `unittest`
    tests, `doctest` tests, and ad hoc tests throughout a source tree, and running
    them all. It then presents you with a unified report of test successes and failures.
    In other words, Nose lets you pick the right testing tool for any given test,
    integrating them simply and conveniently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Nose是一个基于这个想法的工具。它能够在整个源树中找到`unittest`测试、`doctest`测试和临时测试，并运行它们。然后，它会向你展示一个关于测试成功和失败的统一报告。换句话说，Nose让你可以为任何给定的测试选择正确的测试工具，简单方便地集成它们。
- en: Nose also provides a few new testing features, such as module-level fixtures
    and some new assert functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Nose还提供了一些新的测试功能，例如模块级别的设置和一些新的断言函数。
- en: Installing Nose
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Nose
- en: 'Nose is not a part of the Python standard library, which means that you''ll
    need to install it yourself. You can install Nose with a single command:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 鼻子（Nose）不是Python标准库的一部分，这意味着你需要自己安装它。你可以使用一条命令来安装Nose：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If the command reports that no module named `pip` was found, you need to run
    the following command to install the `pip` module:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令报告找不到名为`pip`的模块，你需要运行以下命令来安装`pip`模块：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ensurepip` module is part of the standard library as of Python 3.4, so
    you can count on it being available. You probably won't need this, though, because,
    even though `pip` isn't part of the standard library, it is bundled with Python
    releases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`ensurepip`模块自Python 3.4起成为标准库的一部分，因此你可以信赖它总是可用的。尽管如此，你可能不需要它，因为尽管`pip`不是标准库的一部分，但它包含在Python发行版中。'
- en: The `--user` command-line switch in the previous command tells the tool to install
    into your personal Python package folder. If you leave that out of the command,
    it will try to install Nose for all users.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 之前命令中的`--user`命令行开关告诉工具将其安装到你的个人Python包文件夹中。如果你省略了这个命令，它将尝试为所有用户安装Nose。
- en: That's it. Nose is ready to go.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。Nose已经准备好使用了。
- en: Organizing tests
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织测试
- en: All right, we've got Nose installed, so what's it good for? Nose looks through
    a directory structure, finds the test files, sorts out the tests that they contain,
    runs the tests, and reports the results back to you. That's a lot of work that
    you don't have to do each time you want to run your tests—which should be often.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经安装了Nose，那么它有什么好处呢？Nose会遍历目录结构，找到测试文件，整理出它们包含的测试，运行测试，并将结果报告给你。这是一项你每次想要运行测试时都不必做的很多工作——你应该经常运行测试。
- en: Nose recognizes the test files based on their names. Any file or directory whose
    name contains `test` or `Test` either at the beginning or following any of the
    characters `_` (underscore), `.` (dot), or `–` (dash) is recognized as a place
    where the tests might be found. So are Python source files and package directories.
    Any file that might contain tests is checked for `unittest` `TestCases` as well
    as any functions whose names indicate that they're tests. Nose can find and execute
    the `doctest` tests, as well, that are either embedded in docstrings or written
    in separate test files. By default, it won't look for the `doctest` tests unless
    we tell it to. We'll see how to change the default settings shortly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Nose根据文件名识别测试文件。任何名称包含`test`或`Test`，无论是位于开头还是位于任何字符`_`（下划线）、`.`（点）或`–`（破折号）之后，都被识别为可能包含测试的地方。Python源文件和包目录也是如此。任何可能包含测试的文件都会被检查是否存在`unittest`
    `TestCases`以及任何名称表明它们是测试的函数。Nose还可以找到并执行嵌入在文档字符串中或单独编写的`doctest`测试。默认情况下，它不会寻找`doctest`测试，除非我们告诉它。我们很快就会看到如何更改默认设置。
- en: 'Since Nose is so willing to go looking for our tests, we have a lot of freedom
    with respect to how we can organize them. It often turns out to be a good idea
    to separate all of the tests into their own directory, or larger projects into
    a whole tree of directories. A big project can end up having many thousands of
    tests, so organizing them for easy navigation is a big benefit. If doctests are
    being used as documentation as well as testing, it''s probably a good idea to
    store them in yet another separate directory with a name that communicates that
    they are documentary. For a moderately-sized project, this recommended structure
    might look like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Nose 非常愿意寻找我们的测试，我们在如何组织它们方面有很大的自由度。通常，将所有测试分离到它们自己的目录中，或者将大型项目组织成整个目录树，都是一个不错的选择。一个大型的项目最终可能会有成千上万的测试，因此为了便于导航而组织它们是一个很大的好处。如果
    doctests 不仅要作为测试还要作为文档，那么将它们存储在另一个单独的目录中，并使用一个表明它们是文档的名称，可能是一个好主意。对于一个中等规模的项目，这个建议的结构可能如下所示：
- en: '![Organizing tests](img/3211OS_06_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![测试组织](img/3211OS_06_01.jpg)'
- en: This structure is only a recommendation... it's for your benefit, not for Nose.
    If you feel that a different structure will make things easier for you, go ahead
    and use it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构只是一个建议...这是为了你的便利，而不是为了 Nose。如果你觉得不同的结构会使事情更容易，那么请随意使用它。
- en: An example of organizing tests
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试组织的一个例子
- en: We're going to take some of our tests from the previous chapters and organize
    them into a tree of directories. Then, we're going to use Nose to run them all.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从前几章中选取一些测试，并将它们组织成一个目录树。然后，我们将使用 Nose 运行它们。
- en: The first step is to create a directory that will hold our code and tests. You
    can call it whatever you like, but I'll refer to is as `project` here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个将存放我们的代码和测试的目录。你可以随意命名，但在这里我将称之为 `project`。
- en: Copy the `pid.py`, `avl_tree.py`, and `employees.py` files from the previous
    chapters into the `project` directory. Also place `test.py` from [Chapter 2](ch02.html
    "Chapter 2. Working with doctest"), *Working with doctest*, here, but rename it
    to `inline_doctest.py`. We want it to be treated as a source file, not as a test
    file, so you can see how Nose handles source files with doctests in their docstrings.
    Modules and packages placed in the `project` directory will be available for tests
    no matter where the test is placed in the tree.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将前几章中的 `pid.py`、`avl_tree.py` 和 `employees.py` 文件复制到 `project` 目录中。同时，将 [第 2
    章](ch02.html "第 2 章. 使用 doctest") 中的 `test.py` 文件也放入这里，并将其重命名为 `inline_doctest.py`。我们希望它被视为源文件，而不是测试文件，这样你就可以看到
    Nose 如何处理带有 doctest 的源文件。放置在 `project` 目录中的模块和包，无论测试在树中的位置如何，都将可用于测试。
- en: Create a subdirectory of `project` called `test_chapter2`, and place the `AVL.txt`
    and `test.txt` files from [Chapter 2](ch02.html "Chapter 2. Working with doctest"),
    *Working with doctest*, into it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `test_chapter2` 的子目录，位于 `project` 目录下，并将 [第 2 章](ch02.html "第 2 章. 使用
    doctest") 中的 `AVL.txt` 和 `test.txt` 文件，*使用 doctest*，放入其中。
- en: Create a subdirectory of `project` called `test_chapter3`, and place `PID.txt`
    into it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `project` 目录下创建一个名为 `test_chapter3` 的子目录，并将 `PID.txt` 放入其中。
- en: Create a subdirectory of `project` called `test_chapter5`, and place all of
    the `test_*` modules from [Chapter 5](ch05.html "Chapter 5. Structured Testing
    with unittest"), *Structured Testing with unittest*, into it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `project` 目录下创建一个名为 `test_chapter5` 的子目录，并将 [第 5 章](ch05.html "第 5 章. 使用 unittest
    进行结构化测试") 中的所有 `test_*` 模块，*使用 unittest 进行结构化测试*，放入其中。
- en: 'Now, we''re ready to run our tests using the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用以下代码运行我们的测试：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can leave off the `-v` if you want. It just tells Nose to provide a more
    detailed report.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用 `-v` 选项，也可以省略。这只是为了告诉 Nose 提供更详细的报告。
- en: 'All of the tests should run. We expect to see a few failures, since some of
    the tests from the previous chapters were intended to fail, for illustrative purposes.
    There''s one failure, as shown in the following screenshot, though, that we need
    to consider:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都应该运行。我们预计会看到一些失败，因为前几章中的一些测试是为了说明目的而故意设计的。然而，以下截图显示了一个我们需要考虑的失败：
- en: '![An example of organizing tests](img/3211OS_06_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![测试组织的一个例子](img/3211OS_06_02.jpg)'
- en: 'The first part of this error report can be safely ignored: it just means that
    the whole `doctest` file is being treated as a failing test by Nose. The useful
    information comes in the second part of the report. It tells us that where we
    were expecting to get a previous time of `1.0`, instead we''re getting a very
    large number (this will be different, and larger, when you run the test for yourself,
    as it represents the time in seconds since a point several decades in the past).
    What''s going on? Didn''t we replace `time.time` for that test with a mock? Let''s
    take a look at the relevant part of `pid.txt`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误报告的第一部分可以安全忽略：它只是意味着整个`doctest`文件被Nose当作一个失败的测试处理。有用的信息在报告的第二部分。它告诉我们，我们期望得到一个`1.0`的先前时间，但得到的是一个非常大的数字（当你自己运行测试时，这个数字会不同，并且更大，因为它代表了几十年前的某个时间点以来的秒数）。发生了什么事？我们没有在那个测试中用模拟替换`time.time`吗？让我们看看`pid.txt`的相关部分：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We mocked `time.time`, sure enough (although it would be better to use the
    `unittest.mock` `patch` function). How is it that `from time import time` in `pid.py`
    is getting the wrong (which is to say, real) time function? What if `pid.py` had
    already been imported before this test ran? Then `from time import time` would
    already have been run before our mock was put in place, and it would never know
    about the mock. So, was `pid.py` imported by some thing else, before `pid.txt`
    imported it? As it happens, it was: Nose itself imported it, when it was scanning
    for tests to be executed. If we''re using Nose, we can''t count on our `import`
    statements actually being the first to import any given module. We can fix the
    problem easily, though, by using patch to replace the `time` function where our
    test code finds it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模拟了`time.time`，确实如此（尽管最好使用`unittest.mock`的`patch`函数）。为什么`pid.py`中的`from time
    import time`获取的是错误的时间函数（也就是说，真实的时间）呢？如果在这个测试运行之前`pid.py`已经被导入，那么`from time import
    time`就已经在模拟被放置之前运行了，它将永远不会知道有模拟的存在。那么，是其他什么在`pid.txt`导入它之前导入了`pid.py`吗？实际上是这样的：Nose在扫描要执行测试时导入了它。如果我们使用Nose，我们不能指望我们的`import`语句实际上是第一个导入任何给定模块的。不过，我们可以通过使用`patch`来替换测试代码中找到的`time`函数来轻松解决这个问题：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that we're only looking at the first test in the file here. There is another
    test that would be better written in the same way, although it does pass. Can
    you spot that test and improve it?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里只查看文件中的第一个测试。还有一个测试，虽然它通过了，但以同样的方式编写会更好。你能找到那个测试并改进它吗？
- en: 'Don''t get confused: we switched to using `unittest.mock` for this test because
    it''s a better tool for mocking objects, not because it solves the problem. The
    real solution is that we switched from replacing `time.time` to replacing `pid.time`.
    Nothing in `pid.py` refers to `time.time`, except for the `import` line. Every
    other place in the code that references `time` looks it up in the module''s own
    global scope. That means it''s `pid.time` that we really need to mock, and it
    always was. The fact that `pid.time` is another name for `time.time` is irrelevant;
    we should mock the object where it''s found, not where it came from.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被弄混：我们切换到使用`unittest.mock`进行这个测试，并不是因为它解决了问题，而是因为它是一个更好的模拟对象的工具。真正的解决方案是我们从替换`time.time`切换到替换`pid.time`。在`pid.py`中，除了`import`行之外，没有其他地方引用`time`。这意味着我们需要模拟的是`pid.time`，而且一直都是。`pid.time`是`time.time`的另一个名称，这是无关紧要的；我们应该模拟找到对象的地方，而不是它来自哪里。
- en: 'Now, when we run the tests again, the only failures are the expected ones.
    Your summary report (that we get because we passed `-v` to Nose on the command
    line) should look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行测试时，唯一的失败是预期的。你的总结报告（因为我们把`-v`传递给命令行上的Nose）应该看起来像这样：
- en: '![An example of organizing tests](img/3211OS_06_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![组织测试的示例](img/3211OS_06_03.jpg)'
- en: We just saw how hidden assumptions can break tests, just as they can break the
    code being tested. Until now, we've been assuming that, when one of our tests
    imports a module, that's the first time the module has been imported. Some of
    our tests relied on this assumption to replace library objects with mocks. Now
    that we're dealing with running many tests aggregated together, with no guaranteed
    order of execution, this assumption isn't reliable. On top of that, the module
    that we had trouble with actually had to be imported to search it for tests, before
    any of our tests were run. A quick switch of the affected tests to use a better
    approach, and we were good to go.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到隐藏的假设如何破坏测试，就像它们可以破坏被测试的代码一样。到目前为止，我们一直假设，当我们的某个测试导入一个模块时，这是该模块第一次被导入。一些测试依赖于这个假设来用模拟对象替换库对象。现在，我们正在处理运行许多聚合在一起的测试，没有保证的执行顺序，这个假设是不可靠的。更不用说，我们遇到麻烦的模块实际上必须被导入以在运行任何测试之前搜索它。通过快速切换受影响的测试以使用更好的方法，我们就可以继续进行。
- en: So, we just ran all of these tests with a single command, and we can spread
    our tests across as many directories, source files, and documents as we need to
    keep everything organized. That's pretty nice. We're getting to the point where
    testing is useful in the real world.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只使用一个命令运行了所有这些测试，我们可以将测试分散到尽可能多的目录、源文件和文档中，以保持一切井然有序。这真是太好了。我们正在接近测试在现实世界中变得有用的地步。
- en: We can store our tests in a separate and well-organized directory structure,
    and run them all with a single, quick, and simple command. We can also easily
    run a subset of our tests by passing the filenames, module names, or directories
    containing the tests we want to run as command-line parameters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的测试存储在单独且井然有序的目录结构中，并使用单个简单快捷的命令运行它们。我们还可以通过传递包含我们想要运行的测试的文件名、模块名或包含测试的目录作为命令行参数，轻松地运行测试的子集。
- en: Simplifying the Nose command line
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化Nose的命令行
- en: 'The `python3 -m nose` command that we used earlier was not hard to understand,
    but it''s longer than we''d like if we''re going to be typing it all the time.
    Instead of the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的`python3 -m nose`命令并不难理解，但如果我们要一直输入它，它就比我们希望的更长。而不是以下命令：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''d really prefer just the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的更希望只使用以下命令：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'or, even more simply:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，甚至更简单：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Fortunately, it''s simple to tell Nose that we want it to use different defaults
    for the values of these command-line switches. To do this, just create a configuration
    file called `nose.cfg` or `.noserc` (either name will work) in your home directory,
    and place the following inside it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，告诉Nose我们想要它为这些命令行开关的值使用不同的默认值非常简单。为此，只需在你的主目录中创建一个名为`nose.cfg`或`.noserc`（任一名称都行）的配置文件，并在其中放置以下内容：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Setting the options in the configuration file takes care of all the extraneous
    command-line arguments. From now on, whenever you run Nose, it will assume these
    options, unless you tell it otherwise. You don't have to type them on the command
    line any more. You can use the same trick for any option that Nose can accept
    on the command line.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中设置选项可以处理所有多余的命令行参数。从现在开始，每次你运行Nose时，它都会假设这些选项，除非你明确告知它否则。你不再需要在命令行上输入它们。你可以为Nose可以接受的任何命令行选项使用同样的技巧。
- en: For the second refinement, Nose installs a script called `nosetests` when it's
    installed. Typing `nosetests` is exactly the same as typing `python3 -m nose`,
    except that you might have to add the directory that contains `nosetests` to your
    `PATH` environment variable before it will work. We'll continue using `python3
    -m nose` in the examples.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二次改进，Nose在安装时会安装一个名为`nosetests`的脚本。输入`nosetests`与输入`python3 -m nose`完全相同，但你可能需要将包含`nosetests`的目录添加到你的`PATH`环境变量中，它才能正常工作。在示例中，我们将继续使用`python3
    -m nose`。
- en: Customizing Nose's test search
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Nose的测试搜索
- en: We've said before that Nose uses names of directories, modules, and functions
    to inform its search for tests. Directories and modules whose names start with
    `test` or `Test`, or contain a `_`, `.`, or `–` followed by `test` or `Test` will
    be included in the search, in addition to any other places that Nose decides it
    should search. This is by default, but it's not actually the whole story.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，Nose使用目录、模块和函数的名称来告知其搜索测试。以`test`或`Test`开头，或包含一个`_`、`.`或`–`后跟`test`或`Test`的目录和模块将被包括在搜索中，除了Nose决定应该搜索的其他任何地方。这是默认设置，但这并不是全部。
- en: If you know about regular expressions, you can customize the pattern that Nose
    uses to look for tests. You can do this by passing the `--include=REGEX` command
    line option, or by putting `include=REGEX` in your `nose.cfg` or `.noserc`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解正则表达式，你可以自定义Nose用来查找测试的模式。你可以通过传递`--include=REGEX`命令行选项，或者在你的`nose.cfg`或`.noserc`文件中放入`include=REGEX`来实现。
- en: 'For example, run the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行以下命令：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now Nose will, in addition to looking for names using the word `test`, also
    look for names that start with `doc` or `Doc`. This means that you can call the
    directory containing your `doctest` files as `docs`, `Documentation`, `doctests`,
    and so on, and Nose will still find and run those tests. If you use this option
    often, you'll almost certainly want to add it to your configuration file, as described
    under the previous heading.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Nose除了使用单词`test`查找名称外，还会查找以`doc`或`Doc`开头的名称。这意味着你可以将包含你的`doctest`文件的目录命名为`docs`、`Documentation`、`doctests`等，Nose仍然会找到并运行这些测试。如果你经常使用此选项，你几乎肯定会想将其添加到你的配置文件中，如前所述。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full syntax and use of regular expressions is a subject itself, and has
    been the topic of many books; but you can find everything that you need to do
    in the Python documentation at [https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的完整语法和使用是一个主题本身，并且已经成为许多书籍的主题；但你可以从Python文档中找到你需要做的所有事情，网址为[https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html)。
- en: Check your understanding
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查你的理解
- en: By running `python3 -m nose --processes=4`, Nose can be made to launch four
    testing processes simultaneously, which can be a big gain, if you're running the
    tests on a quad-core system. How would you make Nose always launch four testing
    processes, without being told on the command line? The answer is just put `processes=4`
    in your Nose configuration file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`python3 -m nose --processes=4`，Nose可以同时启动四个测试进程，如果你在一个四核系统上运行测试，这将是一个很大的优势。你将如何让Nose始终启动四个测试进程，而无需在命令行中指定？答案是只需在你的Nose配置文件中将`processes=4`放入即可。
- en: If some of your tests were stored in a directory called `specs`, how would you
    tell Nose that it should search that directory for tests? You need to add `--include="specs"`
    to the Nose command line.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的某些测试存储在一个名为`specs`的目录中，你将如何告诉Nose它应该在该目录中搜索测试？你需要将`--include="specs"`添加到Nose命令行。
- en: Which of the following will be recognized by Nose as possibly containing the
    `UnitTests`, `unit_tests`, `TestFiles`, `test_files`, and `doctests` tests by
    default? The answer is that `unit_tests`, `TestFiles`, and `test_files` will be
    recognized by Nose's default configuration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个会被Nose默认识别为可能包含`UnitTests`、`unit_tests`、`TestFiles`、`test_files`和`doctests`测试？答案是`unit_tests`、`TestFiles`和`test_files`会被Nose的默认配置识别。
- en: Practicing Nose
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习Nose
- en: 'Write some `doctest` and `unittest` tests for the following specification,
    and create a directory tree to contain them and the code that they describe. Write
    the code using the test-driven methodology, and use Nose to run the tests:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为以下规范编写一些`doctest`和`unittest`测试，并创建一个目录树来包含它们以及它们所描述的代码。使用测试驱动的方法编写代码，并使用Nose运行测试：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Nose and doctest tests
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼻子测试和doctest测试
- en: Nose doesn't just support `doctest`, it actually enhances it. When you're using
    Nose, you can write test fixtures for your `doctest` files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Nose不仅支持`doctest`，实际上还增强了它。当你使用Nose时，你可以为你的`doctest`文件编写测试固定文件。
- en: If you pass `--doctest-fixtures=_fixture` on the command line, Nose will go
    looking for a fixture file whenever it finds a `doctest` file. The name of the
    fixture file is based on the name of the `doctest` file, and is calculated by
    appending the `doctest` fixture suffix (in other words, the value of `doctest-fixtures`)
    to the main part of the `doctest` filename, and then adding `.py` to the end.
    For example, if Nose found a `doctest` file called `PID.txt`, and had been told
    to find `doctest‑fixtures=_fixture`, it would try to find the test fixture in
    a file called `PID_fixture.py`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过命令行传递`--doctest-fixtures=_fixture`，Nose会在找到`doctest`文件时寻找一个固定文件。固定文件的名字基于`doctest`文件的名字，通过在`doctest`文件名的主要部分后添加`doctest`固定后缀（换句话说，就是`doctest-fixtures`的值），然后添加`.py`到末尾来计算。例如，如果Nose找到一个名为`PID.txt`的`doctest`文件，并且被告知要寻找`doctest‑fixtures=_fixture`，它会尝试在一个名为`PID_fixture.py`的文件中找到测试固定文件。
- en: 'The test fixture file for a `doctest` is very simple: it''s just a Python module
    that contains a `setup()` or `setUp()` function, and a `teardown()` or `tearDown()`
    function. The `setup` function is executed before the `doctest` file, and the
    `teardown` function is executed after the `doctest` file.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`的测试固定装置文件非常简单：它只是一个包含`setup()`或`setUp()`函数以及`teardown()`或`tearDown()`函数的Python模块。`setup`函数在`doctest`文件之前执行，`teardown`函数在`doctest`文件之后执行。'
- en: The fixture operates in a different namespace from the `doctest` file, so none
    of the variables that get defined in the fixture module are visible in the actual
    tests. If you want to share the variables between the fixture and the test, you'll
    probably want to do it by making a simple little module to hold the variables,
    which you can import into both the fixture and the test.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 固定装置在`doctest`文件的不同命名空间中运行，因此固定装置模块中定义的所有变量在实际测试中都是不可见的。如果你想在固定装置和测试之间共享变量，你可能需要创建一个简单的模块来保存这些变量，这样你就可以将其导入到固定装置和测试中。
- en: Nose and unittest tests
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nose和unittest测试
- en: Nose enhances `unittest` by providing test fixtures at the package and module
    levels. The package `setup` function is run before any of the tests in any of
    the modules in a package, while the `teardown` function is run after all of the
    tests in all of the modules in the package have completed. Similarly, the module
    `setup` function is run before any of the tests in a given module have been executed,
    and the module `teardown` function is executed after all of the tests in the module
    have been executed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Nose通过在包和模块级别提供测试固定装置来增强`unittest`。包的`setup`函数在包中任何模块的任何测试之前运行，而`teardown`函数在包中所有模块的所有测试完成后运行。同样，模块`setup`函数在给定模块的任何测试执行之前运行，模块`teardown`函数在模块中所有测试执行之后执行。
- en: Module fixture practice
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块固定装置练习
- en: 'We''re going to build a test module with a module-level fixture. In the fixture,
    we''ll replace the `datetime.date.today` function, which normally returns an object
    representing the current date. We want it to return a specific value, so that
    our tests can know what to expect. Perform the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个具有模块级固定装置的测试模块。在固定装置中，我们将替换`datetime.date.today`函数，该函数通常返回表示当前日期的对象。我们希望它返回一个特定的值，这样我们的测试就可以知道期望什么。执行以下步骤：
- en: Create a directory called `tests`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`tests`的目录。
- en: 'Within the `tests` directory, create a file called `module_fixture_tests.py`
    containing the following code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests`目录下，创建一个名为`module_fixture_tests.py`的文件，包含以下代码：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that there are two `TestCase` classes in this module. Using pure `unittest`,
    we'd have to duplicate the fixture code in each of these classes. Nose lets us
    write it once and use it in both the places.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在这个模块中有两个`TestCase`类。使用纯`unittest`，我们不得不在每个这些类中重复固定装置代码。Nose允许我们只写一次，然后在两个地方使用它。
- en: Go ahead and run the tests by moving to the directory that contains the tests
    directory and type `python -m nose`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往包含测试目录的目录，并输入`python -m nose`来运行测试。
- en: Nose will recognize `tests` as a directory that might contain tests (because
    of the directory name), find the `module_fixtures_tests.py` file, run the `setup`
    function, run all of the tests, and then run the `teardown` function. There won't
    be much to see, though, aside from a simple report of how many tests passed.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nose会将`tests`识别为可能包含测试的目录（因为目录名），找到`module_fixtures_tests.py`文件，运行`setup`函数，运行所有测试，然后运行`teardown`函数。不过，除了一个简单的测试通过报告外，没有太多可以看的东西。
- en: You might have noticed yet another way of using `unittest.mock.patch` in the
    previous example. In addition to being usable as a decorator or a context manager,
    you can also use the `patch` function as a constructor, and call `start` and `stop`
    on the object it returns. Of all the ways you can use the `patch` function, this
    is the one to avoid in most cases, because this requires you to be careful to
    remember to call the `stop` function. The preceding code would have been better
    using `patch_date` as a class decorator on each of the `TestCase` classes, except
    that the point here was to demonstrate what module-level fixtures look like.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了在之前的示例中又一种使用`unittest.mock.patch`的方式。除了可以作为装饰器或上下文管理器使用外，你还可以将`patch`函数用作构造函数，并对其返回的对象调用`start`和`stop`方法。在所有可以使用`patch`函数的方式中，在大多数情况下，你应该避免使用这种方法，因为这要求你务必记得调用`stop`函数。前面的代码如果使用`patch_date`作为每个`TestCase`类的类装饰器会更好，除非这里的目的是为了展示模块级固定装置的样子。
- en: Normally, rather than creating mock objects, `setup` and `teardown` will do
    things such as handle, create, and destroy temporary files, or so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，而不是创建模拟对象，`setup`和`teardown`会做一些诸如处理、创建和销毁临时文件等事情。
- en: We can save ourselves some time and effort by using a second layer of test fixtures
    that wrap around the entire test modules instead of single test methods. By doing
    this, we save ourselves from duplicating the fixture code inside every test class
    in the module; but this comes with a cost. The `setup` and `teardown` functions
    aren't run before and after each test, as normal test fixtures are. Instead, all
    of the tests in the module happen between a single module-level setup/teardown
    pair, which means that, if a test does something that affects the environment
    created by the `setup` function, it won't be undone before the next test runs.
    In other words, the isolation of tests is not guaranteed with respect to the environment
    created by a module-level fixture.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用一层环绕整个测试模块的测试夹具，而不是单个测试方法，来节省一些时间和精力。通过这样做，我们避免了在每个测试类内部重复夹具代码；但这也带来了一定的代价。`setup`和`teardown`函数不会在每次测试前后运行，就像正常的测试夹具一样。相反，模块中的所有测试都在单个模块级别的setup/teardown对之间进行，这意味着如果测试执行了影响由`setup`函数创建的环境的操作，那么在下一个测试运行之前，这些操作不会被撤销。换句话说，测试的隔离性在模块级别的夹具创建的环境方面不能得到保证。
- en: Package fixture practice
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包夹具练习
- en: 'Now, we''re going to create a fixture that wraps around all the test modules
    in an entire package. Perform the following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个夹具，它将围绕整个包中的所有测试模块。执行以下步骤：
- en: Add a new file called `__init__.py` to the `tests` directory that we created
    in the last practice section. (That's two underscores, the word `init` and two
    more underscores). The presence of this file tells Python that the directory is
    a package.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们上一个练习部分中创建的`tests`目录中添加一个名为`__init__.py`的新文件。（这是两个下划线，单词`init`和另外两个下划线）。这个文件的存在告诉Python该目录是一个包。
- en: 'In `module_fixture_tests.py`, change:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`module_fixture_tests.py`中，更改：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'with the following:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下内容：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Place the following code inside `__init__.py` in the `tests` directory:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests`目录中的`__init__.py`文件内放置以下代码：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's fairly common that the `__init__.py` files are completely empty, but they're
    the canonical source for the package object; so that's where Nose looks for a
    package-level fixture.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，`__init__.py`文件是完全空的，但它们是包对象的规范来源；因此，这就是Nose寻找包级别夹具的地方。
- en: 'Add a new file called `package_fixtures_tests.py` to the `tests` directory,
    with the following contents:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests`目录中添加一个名为`package_fixtures_tests.py`的新文件，内容如下：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Go ahead and run the tests again. You won't see much output, but that just means
    the tests passed. Notice that the `test_glob` function can't succeed unless `test.tmp`
    exists. Since this file is created in the package setup and destroyed in the package
    teardown (and it no longer exists), we know that the setup was run before the
    test, and teardown was run after the test. If we added a test to `module_fixture_tests.py`
    that depended on `test.tmp`, they too would pass, because the `setup` function
    is called before any test in the package, and `teardown` is called after every
    test in the package has run.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续运行测试。你不会看到很多输出，但这只是意味着测试通过了。注意，`test_glob`函数只有在`test.tmp`存在的情况下才能成功。由于这个文件是在包设置中创建并在包清理时销毁（并且它不再存在），我们知道设置是在测试之前运行的，清理是在测试之后运行的。如果我们向`module_fixture_tests.py`添加一个依赖于`test.tmp`的测试，它们也会通过，因为`setup`函数在包中的任何测试之前调用，`teardown`在包中的每个测试运行之后调用。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `glob` module provides the ability to expand command-line - style wildcards
    into a list of filenames. The `glob.glob` function is one of several globbing
    functions available.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`glob`模块提供了将命令行风格的通配符扩展为文件名列表的能力。`glob.glob`函数是几个globbing函数之一。'
- en: We worked with yet another layer of test fixture, this time wrapping around
    all of the test modules in the `tests` directory. As you can see from looking
    at the code we just wrote, the environment created by the package-level test fixture
    is available in every test in every module in the package.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与另一层测试夹具一起工作，这次是围绕`tests`目录中的所有测试模块。从我们刚刚编写的代码中可以看出，包级别测试夹具创建的环境在包中每个模块的每个测试中都是可用的。
- en: Like module-level test fixtures, package-level test fixtures can be a big labor-saving
    shortcut, but they don't provide you with the protection against communication
    between tests that real test-level fixtures do.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与模块级测试固定装置一样，包级测试固定装置可以是一个节省大量劳动的快捷方式，但它们并不提供像真实测试级固定装置那样的防止测试之间通信的保护。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why did we change `'module_fixture_tests.date'` into `'tests.module_fixture_tests.date'`
    when we added the package-level fixture? Well, when we added `__init__.py` to
    the `tests` directory, in Python's view, we changed that directory into a Python
    package. As a Python package, its name is part of the absolute name of any variable
    inside it, which indirectly includes our imported `date` class. We have to pass
    an absolute variable name to patch, so we have to start with the containing package
    name.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在添加包级固定装置时将 `'module_fixture_tests.date'` 改为 `'tests.module_fixture_tests.date'`
    呢？因为当我们向 `tests` 目录添加 `__init__.py` 时，在Python看来，我们将其目录变成了一个Python包。作为一个Python包，它的名称是其内部任何变量的绝对名称的一部分，这间接包括我们导入的
    `date` 类。我们必须传递一个绝对变量名给 `patch`，因此我们必须从包含的包名称开始。
- en: Nose and ad hoc tests
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nose 和临时测试
- en: 'Nose supports two new kinds of tests: standalone test functions, and non-`TestCase`
    test classes. It finds these tests by using the same pattern matching that it
    uses to find test modules. When looking through a module whose name matches the
    pattern, any functions or classes whose names also match the pattern are assumed
    to be tests.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Nose 支持两种新的测试类型：独立测试函数和非 `TestCase` 测试类。它通过使用与查找测试模块相同的模式匹配来找到这些测试。当遍历一个名称与模式匹配的模块时，任何名称也匹配该模式的函数或类都被假定是测试。
- en: We're going to write a few tests that demonstrate Nose's support for test functions
    and non-`TestCase` test classes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一些测试来展示 Nose 对测试函数和非 `TestCase` 测试类的支持。
- en: 'Let''s create a new test file in the `tests` directory, called `nose_specific_tests.py`.
    Inside the file, put the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `tests` 目录中创建一个新的测试文件，命名为 `nose_specific_tests.py`。在文件内部，放置以下代码：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running Nose now doesn't print out very much, but the fact that the tests were
    run and didn't fail tells us a lot.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 Nose 并不会打印出很多内容，但测试已运行且未失败的事实告诉我们很多。
- en: The `grouped_tests` class contains a test fixture (the `setup` and `teardown`
    methods) and two tests; but it's not a `unittest` `TestCase` class. Nose recognized
    it as a test class because its name follows the same pattern that Nose looks for
    when it checks module names to find test modules. It then looks through the class
    for a test fixture and any test methods, and runs them appropriately.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`grouped_tests` 类包含一个测试固定装置（`setup` 和 `teardown` 方法）和两个测试；但它不是一个 `unittest`
    的 `TestCase` 类。Nose 通过其名称符合 Nose 在检查模块名称以查找测试模块时寻找的相同模式，将其识别为测试类。然后它遍历该类以查找测试固定装置和任何测试方法，并相应地运行它们。'
- en: Since the class isn't a `TestCase` class, the tests don't have access to any
    of the `unittest` `assert` methods; Nose considers such a test to pass unless
    it raises an exception. Python has an `assert` statement that raises an exception
    if its expression is false, which is helpful for just this sort of thing. It's
    not as nice as `assertEqual`, but it does the job in many cases.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该类不是 `TestCase` 类，测试无法访问任何 `unittest` 的 `assert` 方法；Nose 认为这样的测试通过，除非它引发异常。Python
    有一个 `assert` 语句，如果其表达式为假，则会引发异常，这对于这种情况非常有用。它不如 `assertEqual` 那么优雅，但在许多情况下可以完成任务。
- en: We wrote another test in the `standalone_test` function. Like `grouped_tests`,
    `standalone_test` is recognized as a test by Nose because its name matches the
    same pattern that Nose uses to search for test modules. Nose runs `standalone_test`
    as a test, and reports a failure if it raises an exception.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `standalone_test` 函数中又编写了一个测试。像 `grouped_tests` 一样，`standalone_test` 被Nose识别为测试，因为它的名称与Nose用于搜索测试模块的相同模式匹配。Nose
    将 `standalone_test` 作为测试运行，如果它引发异常，则报告失败。
- en: We were able to attach a test fixture to `standalone_test` by setting its `setup`
    and `teardown` attributes to a pair of functions that we defined for that purpose.
    As usual, the `setup` function runs before the test function and the `teardown`
    function runs after the test function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 `setup` 和 `teardown` 属性设置为定义为此目的的一对函数，将测试固定装置附加到 `standalone_test` 上。像往常一样，`setup`
    函数在测试函数之前运行，`teardown` 函数在测试函数之后运行。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about the Nose testing meta-framework. Specifically,
    we covered how Nose finds files that contain tests, and how you can adapt the
    process to fit into your organization scheme; how to run all of your tests with
    Nose, whether they are `doctest`, `unittest`, or ad hoc; how Nose enhances the
    other frameworks with additional support for test fixtures; and how to use Nose's
    support for standalone test functions and non-`TestCase` test classes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关于Nose测试元框架学到了很多。具体来说，我们涵盖了Nose如何查找包含测试的文件，以及如何调整流程以适应您的组织架构；如何使用Nose运行所有的测试，无论它们是`doctest`、`unittest`还是临时的；Nose如何通过额外的测试固定支持增强其他框架；以及如何使用Nose对独立测试函数和非`TestCase`测试类的支持。
- en: Now that we've learned about Nose and running all of our tests easily, we're
    ready to tackle a complete test-driven project, which is the topic of the next
    chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Nose以及如何轻松运行所有测试，我们准备着手处理一个完整的测试驱动型项目，这正是下一章的主题。
