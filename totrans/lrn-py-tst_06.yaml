- en: Chapter 6. Running Your Tests with Nose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we saw the `unittest` discover tool find our tests without
    being told explicitly where they were. That was pretty handy, compared to the
    way `doctest` had been making us tell it exactly where to find the tests it should
    run, particularly, when we're talking about a large source tree that has tests
    in many locations.
  prefs: []
  type: TYPE_NORMAL
- en: Nose is a tool that expands on this idea. It's capable of finding `unittest`
    tests, `doctest` tests, and ad hoc tests throughout a source tree, and running
    them all. It then presents you with a unified report of test successes and failures.
    In other words, Nose lets you pick the right testing tool for any given test,
    integrating them simply and conveniently.
  prefs: []
  type: TYPE_NORMAL
- en: Nose also provides a few new testing features, such as module-level fixtures
    and some new assert functions.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Nose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nose is not a part of the Python standard library, which means that you''ll
    need to install it yourself. You can install Nose with a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the command reports that no module named `pip` was found, you need to run
    the following command to install the `pip` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `ensurepip` module is part of the standard library as of Python 3.4, so
    you can count on it being available. You probably won't need this, though, because,
    even though `pip` isn't part of the standard library, it is bundled with Python
    releases.
  prefs: []
  type: TYPE_NORMAL
- en: The `--user` command-line switch in the previous command tells the tool to install
    into your personal Python package folder. If you leave that out of the command,
    it will try to install Nose for all users.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. Nose is ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All right, we've got Nose installed, so what's it good for? Nose looks through
    a directory structure, finds the test files, sorts out the tests that they contain,
    runs the tests, and reports the results back to you. That's a lot of work that
    you don't have to do each time you want to run your tests—which should be often.
  prefs: []
  type: TYPE_NORMAL
- en: Nose recognizes the test files based on their names. Any file or directory whose
    name contains `test` or `Test` either at the beginning or following any of the
    characters `_` (underscore), `.` (dot), or `–` (dash) is recognized as a place
    where the tests might be found. So are Python source files and package directories.
    Any file that might contain tests is checked for `unittest` `TestCases` as well
    as any functions whose names indicate that they're tests. Nose can find and execute
    the `doctest` tests, as well, that are either embedded in docstrings or written
    in separate test files. By default, it won't look for the `doctest` tests unless
    we tell it to. We'll see how to change the default settings shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Nose is so willing to go looking for our tests, we have a lot of freedom
    with respect to how we can organize them. It often turns out to be a good idea
    to separate all of the tests into their own directory, or larger projects into
    a whole tree of directories. A big project can end up having many thousands of
    tests, so organizing them for easy navigation is a big benefit. If doctests are
    being used as documentation as well as testing, it''s probably a good idea to
    store them in yet another separate directory with a name that communicates that
    they are documentary. For a moderately-sized project, this recommended structure
    might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing tests](img/3211OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This structure is only a recommendation... it's for your benefit, not for Nose.
    If you feel that a different structure will make things easier for you, go ahead
    and use it.
  prefs: []
  type: TYPE_NORMAL
- en: An example of organizing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to take some of our tests from the previous chapters and organize
    them into a tree of directories. Then, we're going to use Nose to run them all.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a directory that will hold our code and tests. You
    can call it whatever you like, but I'll refer to is as `project` here.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `pid.py`, `avl_tree.py`, and `employees.py` files from the previous
    chapters into the `project` directory. Also place `test.py` from [Chapter 2](ch02.html
    "Chapter 2. Working with doctest"), *Working with doctest*, here, but rename it
    to `inline_doctest.py`. We want it to be treated as a source file, not as a test
    file, so you can see how Nose handles source files with doctests in their docstrings.
    Modules and packages placed in the `project` directory will be available for tests
    no matter where the test is placed in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Create a subdirectory of `project` called `test_chapter2`, and place the `AVL.txt`
    and `test.txt` files from [Chapter 2](ch02.html "Chapter 2. Working with doctest"),
    *Working with doctest*, into it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a subdirectory of `project` called `test_chapter3`, and place `PID.txt`
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a subdirectory of `project` called `test_chapter5`, and place all of
    the `test_*` modules from [Chapter 5](ch05.html "Chapter 5. Structured Testing
    with unittest"), *Structured Testing with unittest*, into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''re ready to run our tests using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can leave off the `-v` if you want. It just tells Nose to provide a more
    detailed report.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the tests should run. We expect to see a few failures, since some of
    the tests from the previous chapters were intended to fail, for illustrative purposes.
    There''s one failure, as shown in the following screenshot, though, that we need
    to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of organizing tests](img/3211OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first part of this error report can be safely ignored: it just means that
    the whole `doctest` file is being treated as a failing test by Nose. The useful
    information comes in the second part of the report. It tells us that where we
    were expecting to get a previous time of `1.0`, instead we''re getting a very
    large number (this will be different, and larger, when you run the test for yourself,
    as it represents the time in seconds since a point several decades in the past).
    What''s going on? Didn''t we replace `time.time` for that test with a mock? Let''s
    take a look at the relevant part of `pid.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We mocked `time.time`, sure enough (although it would be better to use the
    `unittest.mock` `patch` function). How is it that `from time import time` in `pid.py`
    is getting the wrong (which is to say, real) time function? What if `pid.py` had
    already been imported before this test ran? Then `from time import time` would
    already have been run before our mock was put in place, and it would never know
    about the mock. So, was `pid.py` imported by some thing else, before `pid.txt`
    imported it? As it happens, it was: Nose itself imported it, when it was scanning
    for tests to be executed. If we''re using Nose, we can''t count on our `import`
    statements actually being the first to import any given module. We can fix the
    problem easily, though, by using patch to replace the `time` function where our
    test code finds it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we're only looking at the first test in the file here. There is another
    test that would be better written in the same way, although it does pass. Can
    you spot that test and improve it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t get confused: we switched to using `unittest.mock` for this test because
    it''s a better tool for mocking objects, not because it solves the problem. The
    real solution is that we switched from replacing `time.time` to replacing `pid.time`.
    Nothing in `pid.py` refers to `time.time`, except for the `import` line. Every
    other place in the code that references `time` looks it up in the module''s own
    global scope. That means it''s `pid.time` that we really need to mock, and it
    always was. The fact that `pid.time` is another name for `time.time` is irrelevant;
    we should mock the object where it''s found, not where it came from.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we run the tests again, the only failures are the expected ones.
    Your summary report (that we get because we passed `-v` to Nose on the command
    line) should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of organizing tests](img/3211OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We just saw how hidden assumptions can break tests, just as they can break the
    code being tested. Until now, we've been assuming that, when one of our tests
    imports a module, that's the first time the module has been imported. Some of
    our tests relied on this assumption to replace library objects with mocks. Now
    that we're dealing with running many tests aggregated together, with no guaranteed
    order of execution, this assumption isn't reliable. On top of that, the module
    that we had trouble with actually had to be imported to search it for tests, before
    any of our tests were run. A quick switch of the affected tests to use a better
    approach, and we were good to go.
  prefs: []
  type: TYPE_NORMAL
- en: So, we just ran all of these tests with a single command, and we can spread
    our tests across as many directories, source files, and documents as we need to
    keep everything organized. That's pretty nice. We're getting to the point where
    testing is useful in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: We can store our tests in a separate and well-organized directory structure,
    and run them all with a single, quick, and simple command. We can also easily
    run a subset of our tests by passing the filenames, module names, or directories
    containing the tests we want to run as command-line parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the Nose command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `python3 -m nose` command that we used earlier was not hard to understand,
    but it''s longer than we''d like if we''re going to be typing it all the time.
    Instead of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d really prefer just the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'or, even more simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, it''s simple to tell Nose that we want it to use different defaults
    for the values of these command-line switches. To do this, just create a configuration
    file called `nose.cfg` or `.noserc` (either name will work) in your home directory,
    and place the following inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Setting the options in the configuration file takes care of all the extraneous
    command-line arguments. From now on, whenever you run Nose, it will assume these
    options, unless you tell it otherwise. You don't have to type them on the command
    line any more. You can use the same trick for any option that Nose can accept
    on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: For the second refinement, Nose installs a script called `nosetests` when it's
    installed. Typing `nosetests` is exactly the same as typing `python3 -m nose`,
    except that you might have to add the directory that contains `nosetests` to your
    `PATH` environment variable before it will work. We'll continue using `python3
    -m nose` in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Nose's test search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've said before that Nose uses names of directories, modules, and functions
    to inform its search for tests. Directories and modules whose names start with
    `test` or `Test`, or contain a `_`, `.`, or `–` followed by `test` or `Test` will
    be included in the search, in addition to any other places that Nose decides it
    should search. This is by default, but it's not actually the whole story.
  prefs: []
  type: TYPE_NORMAL
- en: If you know about regular expressions, you can customize the pattern that Nose
    uses to look for tests. You can do this by passing the `--include=REGEX` command
    line option, or by putting `include=REGEX` in your `nose.cfg` or `.noserc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now Nose will, in addition to looking for names using the word `test`, also
    look for names that start with `doc` or `Doc`. This means that you can call the
    directory containing your `doctest` files as `docs`, `Documentation`, `doctests`,
    and so on, and Nose will still find and run those tests. If you use this option
    often, you'll almost certainly want to add it to your configuration file, as described
    under the previous heading.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full syntax and use of regular expressions is a subject itself, and has
    been the topic of many books; but you can find everything that you need to do
    in the Python documentation at [https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html).
  prefs: []
  type: TYPE_NORMAL
- en: Check your understanding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By running `python3 -m nose --processes=4`, Nose can be made to launch four
    testing processes simultaneously, which can be a big gain, if you're running the
    tests on a quad-core system. How would you make Nose always launch four testing
    processes, without being told on the command line? The answer is just put `processes=4`
    in your Nose configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: If some of your tests were stored in a directory called `specs`, how would you
    tell Nose that it should search that directory for tests? You need to add `--include="specs"`
    to the Nose command line.
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following will be recognized by Nose as possibly containing the
    `UnitTests`, `unit_tests`, `TestFiles`, `test_files`, and `doctests` tests by
    default? The answer is that `unit_tests`, `TestFiles`, and `test_files` will be
    recognized by Nose's default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing Nose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write some `doctest` and `unittest` tests for the following specification,
    and create a directory tree to contain them and the code that they describe. Write
    the code using the test-driven methodology, and use Nose to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Nose and doctest tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nose doesn't just support `doctest`, it actually enhances it. When you're using
    Nose, you can write test fixtures for your `doctest` files.
  prefs: []
  type: TYPE_NORMAL
- en: If you pass `--doctest-fixtures=_fixture` on the command line, Nose will go
    looking for a fixture file whenever it finds a `doctest` file. The name of the
    fixture file is based on the name of the `doctest` file, and is calculated by
    appending the `doctest` fixture suffix (in other words, the value of `doctest-fixtures`)
    to the main part of the `doctest` filename, and then adding `.py` to the end.
    For example, if Nose found a `doctest` file called `PID.txt`, and had been told
    to find `doctest‑fixtures=_fixture`, it would try to find the test fixture in
    a file called `PID_fixture.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test fixture file for a `doctest` is very simple: it''s just a Python module
    that contains a `setup()` or `setUp()` function, and a `teardown()` or `tearDown()`
    function. The `setup` function is executed before the `doctest` file, and the
    `teardown` function is executed after the `doctest` file.'
  prefs: []
  type: TYPE_NORMAL
- en: The fixture operates in a different namespace from the `doctest` file, so none
    of the variables that get defined in the fixture module are visible in the actual
    tests. If you want to share the variables between the fixture and the test, you'll
    probably want to do it by making a simple little module to hold the variables,
    which you can import into both the fixture and the test.
  prefs: []
  type: TYPE_NORMAL
- en: Nose and unittest tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nose enhances `unittest` by providing test fixtures at the package and module
    levels. The package `setup` function is run before any of the tests in any of
    the modules in a package, while the `teardown` function is run after all of the
    tests in all of the modules in the package have completed. Similarly, the module
    `setup` function is run before any of the tests in a given module have been executed,
    and the module `teardown` function is executed after all of the tests in the module
    have been executed.
  prefs: []
  type: TYPE_NORMAL
- en: Module fixture practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to build a test module with a module-level fixture. In the fixture,
    we''ll replace the `datetime.date.today` function, which normally returns an object
    representing the current date. We want it to return a specific value, so that
    our tests can know what to expect. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `tests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the `tests` directory, create a file called `module_fixture_tests.py`
    containing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that there are two `TestCase` classes in this module. Using pure `unittest`,
    we'd have to duplicate the fixture code in each of these classes. Nose lets us
    write it once and use it in both the places.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and run the tests by moving to the directory that contains the tests
    directory and type `python -m nose`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nose will recognize `tests` as a directory that might contain tests (because
    of the directory name), find the `module_fixtures_tests.py` file, run the `setup`
    function, run all of the tests, and then run the `teardown` function. There won't
    be much to see, though, aside from a simple report of how many tests passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might have noticed yet another way of using `unittest.mock.patch` in the
    previous example. In addition to being usable as a decorator or a context manager,
    you can also use the `patch` function as a constructor, and call `start` and `stop`
    on the object it returns. Of all the ways you can use the `patch` function, this
    is the one to avoid in most cases, because this requires you to be careful to
    remember to call the `stop` function. The preceding code would have been better
    using `patch_date` as a class decorator on each of the `TestCase` classes, except
    that the point here was to demonstrate what module-level fixtures look like.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, rather than creating mock objects, `setup` and `teardown` will do
    things such as handle, create, and destroy temporary files, or so on.
  prefs: []
  type: TYPE_NORMAL
- en: We can save ourselves some time and effort by using a second layer of test fixtures
    that wrap around the entire test modules instead of single test methods. By doing
    this, we save ourselves from duplicating the fixture code inside every test class
    in the module; but this comes with a cost. The `setup` and `teardown` functions
    aren't run before and after each test, as normal test fixtures are. Instead, all
    of the tests in the module happen between a single module-level setup/teardown
    pair, which means that, if a test does something that affects the environment
    created by the `setup` function, it won't be undone before the next test runs.
    In other words, the isolation of tests is not guaranteed with respect to the environment
    created by a module-level fixture.
  prefs: []
  type: TYPE_NORMAL
- en: Package fixture practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we''re going to create a fixture that wraps around all the test modules
    in an entire package. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new file called `__init__.py` to the `tests` directory that we created
    in the last practice section. (That's two underscores, the word `init` and two
    more underscores). The presence of this file tells Python that the directory is
    a package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `module_fixture_tests.py`, change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'with the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place the following code inside `__init__.py` in the `tests` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It's fairly common that the `__init__.py` files are completely empty, but they're
    the canonical source for the package object; so that's where Nose looks for a
    package-level fixture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new file called `package_fixtures_tests.py` to the `tests` directory,
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go ahead and run the tests again. You won't see much output, but that just means
    the tests passed. Notice that the `test_glob` function can't succeed unless `test.tmp`
    exists. Since this file is created in the package setup and destroyed in the package
    teardown (and it no longer exists), we know that the setup was run before the
    test, and teardown was run after the test. If we added a test to `module_fixture_tests.py`
    that depended on `test.tmp`, they too would pass, because the `setup` function
    is called before any test in the package, and `teardown` is called after every
    test in the package has run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `glob` module provides the ability to expand command-line - style wildcards
    into a list of filenames. The `glob.glob` function is one of several globbing
    functions available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We worked with yet another layer of test fixture, this time wrapping around
    all of the test modules in the `tests` directory. As you can see from looking
    at the code we just wrote, the environment created by the package-level test fixture
    is available in every test in every module in the package.
  prefs: []
  type: TYPE_NORMAL
- en: Like module-level test fixtures, package-level test fixtures can be a big labor-saving
    shortcut, but they don't provide you with the protection against communication
    between tests that real test-level fixtures do.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why did we change `'module_fixture_tests.date'` into `'tests.module_fixture_tests.date'`
    when we added the package-level fixture? Well, when we added `__init__.py` to
    the `tests` directory, in Python's view, we changed that directory into a Python
    package. As a Python package, its name is part of the absolute name of any variable
    inside it, which indirectly includes our imported `date` class. We have to pass
    an absolute variable name to patch, so we have to start with the containing package
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Nose and ad hoc tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nose supports two new kinds of tests: standalone test functions, and non-`TestCase`
    test classes. It finds these tests by using the same pattern matching that it
    uses to find test modules. When looking through a module whose name matches the
    pattern, any functions or classes whose names also match the pattern are assumed
    to be tests.'
  prefs: []
  type: TYPE_NORMAL
- en: We're going to write a few tests that demonstrate Nose's support for test functions
    and non-`TestCase` test classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new test file in the `tests` directory, called `nose_specific_tests.py`.
    Inside the file, put the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running Nose now doesn't print out very much, but the fact that the tests were
    run and didn't fail tells us a lot.
  prefs: []
  type: TYPE_NORMAL
- en: The `grouped_tests` class contains a test fixture (the `setup` and `teardown`
    methods) and two tests; but it's not a `unittest` `TestCase` class. Nose recognized
    it as a test class because its name follows the same pattern that Nose looks for
    when it checks module names to find test modules. It then looks through the class
    for a test fixture and any test methods, and runs them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Since the class isn't a `TestCase` class, the tests don't have access to any
    of the `unittest` `assert` methods; Nose considers such a test to pass unless
    it raises an exception. Python has an `assert` statement that raises an exception
    if its expression is false, which is helpful for just this sort of thing. It's
    not as nice as `assertEqual`, but it does the job in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote another test in the `standalone_test` function. Like `grouped_tests`,
    `standalone_test` is recognized as a test by Nose because its name matches the
    same pattern that Nose uses to search for test modules. Nose runs `standalone_test`
    as a test, and reports a failure if it raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: We were able to attach a test fixture to `standalone_test` by setting its `setup`
    and `teardown` attributes to a pair of functions that we defined for that purpose.
    As usual, the `setup` function runs before the test function and the `teardown`
    function runs after the test function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about the Nose testing meta-framework. Specifically,
    we covered how Nose finds files that contain tests, and how you can adapt the
    process to fit into your organization scheme; how to run all of your tests with
    Nose, whether they are `doctest`, `unittest`, or ad hoc; how Nose enhances the
    other frameworks with additional support for test fixtures; and how to use Nose's
    support for standalone test functions and non-`TestCase` test classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about Nose and running all of our tests easily, we're
    ready to tackle a complete test-driven project, which is the topic of the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
