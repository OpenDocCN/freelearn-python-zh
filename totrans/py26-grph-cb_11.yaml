- en: 'Chapter 11. GUI Construction: Part 2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The Grid Layout Geometry Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pack Geometry Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radio buttons to select one from many
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check buttons (Tick boxes) to select some of many
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keystroke event handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrollbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom DIY Controller Widgets (a slimmer slider)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provide more recipes for the **Graphical User Interfaces(GUI)**.
    The recipes in the previous chapter were devised as basic ways of interacting
    with your code while it is running. In this chapter we extend these ideas and
    try to tie them together.
  prefs: []
  type: TYPE_NORMAL
- en: We start by exploring the characteristics of the two layout geometry managers.
    Throughout this book, up until this chapter we have used the grid manager as it
    seems to be the one that gives us most control over the appearance of the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'One choice we are forced to make when we write Tkinter code that uses widgets
    is how we are going to arrange the widgets inside the master widget that contains
    them. There are two layout geometry managers to choose from: the pack and the
    grid. The pack manager is the easiest to use until you have your own ideas of
    how you want the furniture arranged in your house, with furniture and house being
    useful metaphors for widget and containing widget. The grid manager gives you
    absolute control of layout.'
  prefs: []
  type: TYPE_NORMAL
- en: The Grid Layout Geometry Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We look at code that lays out 16 labeled buttons in a planned manner. According
    to the label on each button, there is only one place it should be within a North,
    South, East, West reference system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both grid and pack have navigation reference schemes. The easiest way to understand
    in terms of how our GUIs are going to appear is the grid that specifies the positioning
    of our widget using a clear row, column scheme as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/3845_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the program shown in the usual manner. The result is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3845_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Grid Layout Manager is explicit in interpreting layout instructions. There
    is no ambiguity and the results are easy to understand. Fortunately, for us users,
    one of the entrenched philosophies of the Python language is that wherever possible
    the interpreter should be kind and forgiving to mildly careless programming. For
    instance, say for example, we assigned the grid layout of all the buttons to the
    same address. For example, say we assigned all the buttons as `grid(row=5, column=5)`.
    The result would be what appeared to be a single button inside the window. In
    fact, the layout manager would place all the buttons on top of one another, with
    the first one at the bottom and the last one on top. If we destroyed them one
    at a time in reverse order we would see this sequence unfolding.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just remember that we never mix pack and grid layout managers in the same program.
    If you do, your program will freeze as each of the managers attempts to obey conflicting
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The Pack Geometry Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We attempt to achieve the same result as shown in the previous screenshot without
    complete success because pack tries to arrange widgets in a single strip. The
    limited flexibility pack offers is that it allows us to decide where the strip
    should begin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Pack Layout Manager uses a navigator''s compass scheme illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/3845_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the program shown in the usual way. The result is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3845_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pack geometry packs widgets either in rows or in columns. If we try to do
    both, the results are difficult to predict as shown in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: What it does is it starts at one edge, which you may specify, and then just
    lays the widgets one-by-one next to each other in the same order that they appear
    in our code. If you do not specify an edge to start on the default is TOP so the
    widgets will be laid out as a single column.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also parameters that specify whether the widget should be padded
    out to fill available space. We can get this detail from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://effbot.org/tkinterbook/pack.htm](http://effbot.org/tkinterbook/pack.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: Radiobuttons to select one from many
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use radiobuttons to make one choice from a selection of choices. Each button
    in the set is linked to the same variable. As one button is left-clicked with
    the mouse, the value associated with that particular button gets assigned as the
    value of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Radiobuttons to select one from many](img/3845_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have specified a special Tkinter string variable that we name as `var_1`.
    We can assign one of three possible string values depending on which radio button
    is clicked. A normal button is used to display the value `var_1` has at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Checkbuttons (Tickboxes) to select some of many
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tickboxes always have a value. They are the opposite of radiobuttons they allow
    more than one choice to be made from a group. Each Tickbox is associated with
    a different variable name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Checkbuttons (Tickboxes) to select some of many](img/3845_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are four checkboxes (tickboxes) and therefore four variables. Two are
    integer and two are strings. Whenever the button at the bottom is clicked, all
    four values are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Key-stroke event handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In GUI terminology, an **Event Handler** is a term for a function that executes
    when an external event such as a key or a mouse being clicked occurs. An equivalent
    term used in this book, is a `callback` function. We recognize a `callback` function
    because it has the word event as an argument in the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: Here we make an event handler that reacts to key strokes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have made a textbox to show which key was clicked when a keyboard "event"
    occurs. We have chosen to display and verify our key presses inside a textbox,
    which does not react to function key presses. If we used a Label widget instead,
    we would see the `function` key displayed as expected. In other words the function
    `event.keypress` correctly senses all keystrokes even if they are not represented
    by normal characters.
  prefs: []
  type: TYPE_NORMAL
- en: Scrollbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A scrollbar provides a way to move a viewing window across a larger image or
    text area using a mouse-controlled slider. It can be used with Listboxes, Canvasses,
    Entry widgets, or Text widgets. In this example, we use a vertical scrollbar to
    move a GIF image up and down behind a scrollbar's viewing window.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A two-way connection needs to be made between the canvas and the scrollbar:'
  prefs: []
  type: TYPE_NORMAL
- en: The canvas's `yscrollcommand` option has to be connected to the vertical scrollbar's
    `.set` method, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scrollbar's `command` option has to connected to the canvas's `.yview` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the program shown in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two-way connection between canvas and scrollbar is achieved by the option
    `yscrollcommand=yscrollbar.set` in the `canvas_1 = Canvas(… configuration` command
    and in the scrollbar configuration option `yscrollbar.config(command=canvas_1.yview)`.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we cannot refer to any variable before it has been defined, and this
    is why the `yscrollbar.config` statement cannot be used before the `yscrollbar`
    has been declared.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The above example, for simplicity, only has a vertical scrollbar. If we want
    to include a horizontal scrollbar we would insert the statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After the canvas declarations, add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`xscrollbar.config(command=canvas_1.xview)`'
  prefs: []
  type: TYPE_NORMAL
- en: Custom DIY controller widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We construct our own widget from basic graphic elements on a canvas. The existing
    slide control widget available from Tkinter looks a bit large and cumbersome sometimes.
    If we need a more neat and compact slide-type user input device we can manufacture
    our own.
  prefs: []
  type: TYPE_NORMAL
- en: The choice made here is to assemble the essential slider functions as graphic
    and text elements on a Tkinter canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom DIY controller widgets](img/3845_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we see in the following code are three similar groups of code separated
    by double lines and a `callback` function that focuses on one of the three segments
    depending on the value of a variable named `focus_flag`. Execute the program shown
    in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an array of numerical input gadgets that give users feedback using the
    length of a colored bar as well as a numerical readout.
  prefs: []
  type: TYPE_NORMAL
- en: The function `callback_1` reacts to a click of the left mouse while `callback_2`
    responds to the mouse being dragged while the button is held down. Which of the
    three sets of controls is controlled by a mouse left-click is determined by measuring
    the position of the mouse when the left button is clicked. This measurement is
    performed by the function `separation(x_now, y_now, x_dot, y_dot)`. It measures
    the distance between where the mouse is clicked and each of the slide control
    rectangles. If it is close (within 5 pixels) to a control rectangle, then the
    value of `focus_flag` is set to an integer that we associate with that position.
  prefs: []
  type: TYPE_NORMAL
- en: It works on a similar principle to the official Tkinter scale/slider widget.
  prefs: []
  type: TYPE_NORMAL
- en: It is useful when you want to place a slide controller onto a canvas.
  prefs: []
  type: TYPE_NORMAL
- en: They occupy less screen area than the Ttkinter scale widget.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we need only one canvas slider widget and not three it is a simple matter
    to comment-out or delete any lines of code dealing with two of the widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing widgets inside frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use Tkinter frames to group bunches of related widgets together. When we
    have done this, we only have to think about how we want the frames arranged because
    their contents are already taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing widgets inside frames](img/3845_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The position of frames is specified relative to the "root" window.
  prefs: []
  type: TYPE_NORMAL
- en: Inside each frame, the widgets that belong to it are arranged without reference
    to anything outside that frame.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the specification `redbutton_1.grid(row=0, column=1)` places the
    `red_button` in `row=0` and `column=1` in the grid geometry that is the universe
    of the red frame `frame_1`. The red button is completely unaware of the world
    outside her frame.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the first time we have changed the background color of the root Tkinter
    window from the default gray one to black.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix appA. Quick tips for running Python programs in Microsoft Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running Python programs in Microsoft Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a Linux-operating system, Python is usually already installed. It already
    has Tkinter, math, and many other libraries installed. You do not have to modify
    any system search path variables like `Path` to run Python.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Windows may throw up some obstacles but it is not too difficult to
    overcome them. The Python Windows installer will install everything it needs in
    a Windows directory `C:\Python27`, if it is version 2.7\. Python version 2.6 would
    get stored in `C:\Python26`.
  prefs: []
  type: TYPE_NORMAL
- en: Where will we find the windows installer?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will find it at [www.python.org/download/](http://www.python.org/download/).
    When the [www.python.org/download/](http://www.python.org/download/) page opens
    up, select **Python 2.7 Windows installer (Windows binary does not include source)**.
  prefs: []
  type: TYPE_NORMAL
- en: This will download a file named `Python-2.7.msi` into our windows `Downloads`
    folder. We just have to double-click on this file and Python version 2.7 will
    install itself onto our system at `C:\Python27`.
  prefs: []
  type: TYPE_NORMAL
- en: Do we have to use Python version 2.7?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No, the code in this book should work on Python versions 2.4, 2.5, 2.6, and
    2.7\. It has been run by various people on these versions. It will not run on
    Python version 3.0 and higher without changes required by the new Python syntax.
    For instance, print has to be changed to print (stuff-to-be printed).
  prefs: []
  type: TYPE_NORMAL
- en: Why do we get "python is not recognized…"?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This happens because the Windows operating system does not know where to find
    Python when you type `python` into a command window as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why do we get "python is not recognized…"?](img/3845_appendix_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three ways around this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Type in the full pathname for both python and the target program we want to
    run. In this example, we have used the python program named `entry_box_1.py`.
    It has been stored inside a folder named `constr` as described in the first example
    *Running a Shortest Python Program* in the first chapter. The following screenshot
    shows the command-line dialog. `george` is the name of the user logged into Windows.![Why
    do we get "python is not recognized…"?](img/3845_appendix_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Work inside the `Python27` folder. What we do is `cd.`. and `cd.`. again. Then
    `cd` into folder `Python27`. Then we can just type `python \constr\entry_box_1.py`
    into the command-line as shown in the following screenshot:![Why do we get "python
    is not recognized…"?](img/3845_appendix_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the Windows system variable that informs Windows where to search for
    executable files. We do this by typing `set PATH=%PATH%;C:\Python27` into the
    command-line window. From now on, we can just type `python \constr\entry_box_.py`
    from within any folder. The dialog that achieves this is shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
