- en: 'Chapter 11. GUI Construction: Part 2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 GUI构建：第二部分
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The Grid Layout Geometry Manager
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格布局几何管理器
- en: The Pack Geometry Manager
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包几何管理器
- en: Radio buttons to select one from many
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单选按钮从多个选项中选择一个
- en: Check buttons (Tick boxes) to select some of many
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复选框（勾选框）从多个选项中选择一些
- en: Keystroke event handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按键事件处理
- en: Scrollbar
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动条
- en: Frames
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架
- en: Custom DIY Controller Widgets (a slimmer slider)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义DIY控制器小部件（一个更瘦的滑块）
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we provide more recipes for the **Graphical User Interfaces(GUI)**.
    The recipes in the previous chapter were devised as basic ways of interacting
    with your code while it is running. In this chapter we extend these ideas and
    try to tie them together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提供了更多关于**图形用户界面(GUI)**的食谱。上一章中的食谱被设计为运行时与你的代码交互的基本方式。在本章中，我们扩展了这些想法并试图将它们结合起来。
- en: We start by exploring the characteristics of the two layout geometry managers.
    Throughout this book, up until this chapter we have used the grid manager as it
    seems to be the one that gives us most control over the appearance of the GUI.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探索两个布局几何管理器的特性。在整个这本书中，直到本章，我们一直使用网格管理器，因为它似乎给我们提供了对GUI外观的最大控制。
- en: 'One choice we are forced to make when we write Tkinter code that uses widgets
    is how we are going to arrange the widgets inside the master widget that contains
    them. There are two layout geometry managers to choose from: the pack and the
    grid. The pack manager is the easiest to use until you have your own ideas of
    how you want the furniture arranged in your house, with furniture and house being
    useful metaphors for widget and containing widget. The grid manager gives you
    absolute control of layout.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写使用小部件的Tkinter代码时，我们必须做出的一个选择是如何在我们包含它们的主小部件内部安排这些小部件。有两个布局几何管理器可供选择：打包和网格。打包管理器是最容易使用的，直到你有了自己关于如何在家居中安排家具的想法，家具和房屋是对于小部件和包含小部件的有用隐喻。网格管理器给你提供了对布局的绝对控制。
- en: The Grid Layout Geometry Manager
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格布局几何管理器
- en: We look at code that lays out 16 labeled buttons in a planned manner. According
    to the label on each button, there is only one place it should be within a North,
    South, East, West reference system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看以计划的方式布局16个标签按钮的代码。根据每个按钮上的标签，它只应该在北、南、东、西参考系统中的一个位置。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Both grid and pack have navigation reference schemes. The easiest way to understand
    in terms of how our GUIs are going to appear is the grid that specifies the positioning
    of our widget using a clear row, column scheme as illustrated in the following
    screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 网格和打包都有导航参考方案。从我们的GUI将如何显示的角度来理解，最简单的方法是使用网格，它使用清晰的行、列方案来指定我们的小部件位置，如下面的截图所示：
- en: '![Getting ready](img/3845_11_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/3845_11_01.jpg)'
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the program shown in the usual manner. The result is shown in the following
    screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常的方式执行程序。结果如下面的截图所示：
- en: '![How to do it...](img/3845_11_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3845_11_02.jpg)'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Grid Layout Manager is explicit in interpreting layout instructions. There
    is no ambiguity and the results are easy to understand. Fortunately, for us users,
    one of the entrenched philosophies of the Python language is that wherever possible
    the interpreter should be kind and forgiving to mildly careless programming. For
    instance, say for example, we assigned the grid layout of all the buttons to the
    same address. For example, say we assigned all the buttons as `grid(row=5, column=5)`.
    The result would be what appeared to be a single button inside the window. In
    fact, the layout manager would place all the buttons on top of one another, with
    the first one at the bottom and the last one on top. If we destroyed them one
    at a time in reverse order we would see this sequence unfolding.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局管理器在解释布局指令时是明确的。没有歧义，结果容易理解。幸运的是，对于我们用户来说，Python语言的一个根深蒂固的哲学是，在可能的情况下，解释器应该对轻微的编程疏忽表现出友好和宽容。例如，假设我们给所有按钮分配了相同的网格布局地址。例如，假设我们将所有按钮分配为`grid(row=5,
    column=5)`。结果看起来像窗口中只有一个按钮。实际上，布局管理器会将所有按钮堆叠在一起，第一个在底部，最后一个在顶部。如果我们按相反的顺序逐个销毁它们，我们会看到这个序列展开。
- en: There's more...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Just remember that we never mix pack and grid layout managers in the same program.
    If you do, your program will freeze as each of the managers attempts to obey conflicting
    instructions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，我们永远不会在同一个程序中混合使用包和网格布局管理器。如果您这样做，您的程序将冻结，因为每个管理器都试图遵守冲突的指令。
- en: The Pack Geometry Manager
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包布局管理器
- en: We attempt to achieve the same result as shown in the previous screenshot without
    complete success because pack tries to arrange widgets in a single strip. The
    limited flexibility pack offers is that it allows us to decide where the strip
    should begin.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图实现前一个截图所示的结果，但并不完全成功，因为包试图将小部件排列成一条单行。包提供的有限灵活性在于它允许我们决定条带应该从哪里开始。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The Pack Layout Manager uses a navigator''s compass scheme illustrated as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 包布局管理器使用导航者指南针方案，如下所示：
- en: '![Getting ready](img/3845_11_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/3845_11_03.jpg)'
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the program shown in the usual way. The result is shown in the following
    screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规方式执行显示的程序。结果如下截图所示：
- en: '![How to do it...](img/3845_11_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3845_11_04.jpg)'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The pack geometry packs widgets either in rows or in columns. If we try to do
    both, the results are difficult to predict as shown in the previous screenshot.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 包布局管理器将小部件排列成行或列。如果我们尝试同时做这两件事，结果将难以预测，如前一个截图所示。
- en: What it does is it starts at one edge, which you may specify, and then just
    lays the widgets one-by-one next to each other in the same order that they appear
    in our code. If you do not specify an edge to start on the default is TOP so the
    widgets will be laid out as a single column.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的是从一个可能指定的边缘开始，然后按照它们在代码中出现的顺序，一个接一个地排列小部件。如果您没有指定开始边缘，默认为顶部，因此小部件将作为一个单独的列排列。
- en: 'There are also parameters that specify whether the widget should be padded
    out to fill available space. We can get this detail from:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些参数指定小部件是否应该填充到可用空间。我们可以从这个细节中获取：
- en: '[http://effbot.org/tkinterbook/pack.htm](http://effbot.org/tkinterbook/pack.htm)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://effbot.org/tkinterbook/pack.htm](http://effbot.org/tkinterbook/pack.htm)'
- en: Radiobuttons to select one from many
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单选按钮从多个选项中选择一个
- en: We use radiobuttons to make one choice from a selection of choices. Each button
    in the set is linked to the same variable. As one button is left-clicked with
    the mouse, the value associated with that particular button gets assigned as the
    value of the variable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用单选按钮从一组选择中做出一个选择。集合中的每个按钮都与同一个变量相关联。当鼠标左键点击某个按钮时，与该特定按钮关联的值被分配为变量的值。
- en: '![Radiobuttons to select one from many](img/3845_11_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![单选按钮从多个选项中选择一个](img/3845_11_05.jpg)'
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Execute the program shown in the usual way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规方式执行显示的程序。
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have specified a special Tkinter string variable that we name as `var_1`.
    We can assign one of three possible string values depending on which radio button
    is clicked. A normal button is used to display the value `var_1` has at any time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了一个特殊的Tkinter字符串变量，我们将其命名为`var_1`。我们可以根据哪个单选按钮被点击分配三个可能的字符串值。一个普通按钮用于显示`var_1`在任何时刻的值。
- en: Checkbuttons (Tickboxes) to select some of many
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复选框（勾选框）从多个选项中选择一些
- en: Tickboxes always have a value. They are the opposite of radiobuttons they allow
    more than one choice to be made from a group. Each Tickbox is associated with
    a different variable name.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 勾选框始终有一个值。它们与单选按钮相反，允许从一组中选择多个选项。每个勾选框都与一个不同的变量名相关联。
- en: '![Checkbuttons (Tickboxes) to select some of many](img/3845_11_06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![复选框（勾选框）从多个选项中选择一些](img/3845_11_06.jpg)'
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Execute the program shown in the usual way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规方式执行显示的程序。
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are four checkboxes (tickboxes) and therefore four variables. Two are
    integer and two are strings. Whenever the button at the bottom is clicked, all
    four values are displayed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个勾选框（勾选框），因此有四个变量。其中两个是整数，两个是字符串。每当底部按钮被点击时，所有四个值都会显示出来。
- en: Key-stroke event handling
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键击事件处理
- en: In GUI terminology, an **Event Handler** is a term for a function that executes
    when an external event such as a key or a mouse being clicked occurs. An equivalent
    term used in this book, is a `callback` function. We recognize a `callback` function
    because it has the word event as an argument in the function definition.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形用户界面术语中，**事件处理器**是指当外部事件（如按键或鼠标点击）发生时执行的功能的术语。本书中使用的等效术语是`回调`函数。我们通过函数定义中包含的单词`event`来识别`回调`函数。
- en: Here we make an event handler that reacts to key strokes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个对按键做出反应的事件处理器。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Execute the program shown in the usual way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规方式执行程序。
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: We have made a textbox to show which key was clicked when a keyboard "event"
    occurs. We have chosen to display and verify our key presses inside a textbox,
    which does not react to function key presses. If we used a Label widget instead,
    we would see the `function` key displayed as expected. In other words the function
    `event.keypress` correctly senses all keystrokes even if they are not represented
    by normal characters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个文本框来显示当键盘“事件”发生时按下的哪个键。我们选择在文本框内显示和验证我们的按键，该文本框不会对功能键按下做出反应。如果我们使用标签小部件代替，我们会看到预期的`function`键显示。换句话说，函数`event.keypress`正确地感知了所有按键，即使它们不是由正常字符表示。
- en: Scrollbar
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动条
- en: A scrollbar provides a way to move a viewing window across a larger image or
    text area using a mouse-controlled slider. It can be used with Listboxes, Canvasses,
    Entry widgets, or Text widgets. In this example, we use a vertical scrollbar to
    move a GIF image up and down behind a scrollbar's viewing window.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动条提供了一种使用鼠标控制的滑块在更大的图像或文本区域中移动查看窗口的方法。它可以与列表框、画布、输入小部件或文本小部件一起使用。在这个例子中，我们使用垂直滚动条在滚动条的查看窗口后面上下移动GIF图像。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'A two-way connection needs to be made between the canvas and the scrollbar:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在画布和滚动条之间建立双向连接：
- en: The canvas's `yscrollcommand` option has to be connected to the vertical scrollbar's
    `.set` method, and
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画布的`yscrollcommand`选项必须连接到垂直滚动条的`.set`方法，并且
- en: The scrollbar's `command` option has to connected to the canvas's `.yview` method.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动条的`command`选项必须连接到画布的`.yview`方法。
- en: Execute the program shown in the usual way.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规方式执行显示的程序。
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The two-way connection between canvas and scrollbar is achieved by the option
    `yscrollcommand=yscrollbar.set` in the `canvas_1 = Canvas(… configuration` command
    and in the scrollbar configuration option `yscrollbar.config(command=canvas_1.yview)`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 画布和滚动条之间的双向连接是通过`canvas_1 = Canvas(…配置`命令中的`yscrollcommand=yscrollbar.set`选项和在滚动条配置选项`yscrollbar.config(command=canvas_1.yview)`中实现的。
- en: In Python, we cannot refer to any variable before it has been defined, and this
    is why the `yscrollbar.config` statement cannot be used before the `yscrollbar`
    has been declared.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们不能在定义变量之前引用它，这就是为什么在`yscrollbar`声明之前不能使用`yscrollbar.config`语句的原因。
- en: There's more...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The above example, for simplicity, only has a vertical scrollbar. If we want
    to include a horizontal scrollbar we would insert the statements:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例为了简单起见，只有垂直滚动条。如果我们想包括水平滚动条，我们会插入以下语句：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the canvas declarations, add the following line of code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布声明之后，添加以下代码行：
- en: '`xscrollbar.config(command=canvas_1.xview)`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`xscrollbar.config(command=canvas_1.xview)`'
- en: Custom DIY controller widgets
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制DIY控制器小部件
- en: We construct our own widget from basic graphic elements on a canvas. The existing
    slide control widget available from Tkinter looks a bit large and cumbersome sometimes.
    If we need a more neat and compact slide-type user input device we can manufacture
    our own.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从画布上的基本图形元素构建自己的小部件。Tkinter提供的现有滑动控制小部件有时看起来有点大而笨重。如果我们需要一个更整洁、紧凑的滑动式用户输入设备，我们可以自己制造。
- en: The choice made here is to assemble the essential slider functions as graphic
    and text elements on a Tkinter canvas.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所做的选择是将基本滑块功能作为图形和文本元素组装在Tkinter画布上。
- en: '![Custom DIY controller widgets](img/3845_11_07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![定制DIY控制器小部件](img/3845_11_07.jpg)'
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: What we see in the following code are three similar groups of code separated
    by double lines and a `callback` function that focuses on one of the three segments
    depending on the value of a variable named `focus_flag`. Execute the program shown
    in the usual way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们看到三组相似的代码，由双行和`回调`函数分隔，该函数根据名为`focus_flag`的变量的值关注三个段中的其中一个。按照常规方式执行显示的程序。
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: This is an array of numerical input gadgets that give users feedback using the
    length of a colored bar as well as a numerical readout.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个数值输入小部件数组，它使用彩色条的长度以及数值读数来向用户提供反馈。
- en: The function `callback_1` reacts to a click of the left mouse while `callback_2`
    responds to the mouse being dragged while the button is held down. Which of the
    three sets of controls is controlled by a mouse left-click is determined by measuring
    the position of the mouse when the left button is clicked. This measurement is
    performed by the function `separation(x_now, y_now, x_dot, y_dot)`. It measures
    the distance between where the mouse is clicked and each of the slide control
    rectangles. If it is close (within 5 pixels) to a control rectangle, then the
    value of `focus_flag` is set to an integer that we associate with that position.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`callback_1`对鼠标左键的点击做出反应，而`callback_2`在按钮按下时对鼠标拖动做出响应。通过测量鼠标左键点击时的鼠标位置来确定由鼠标左键控制的是哪三组控制。这个测量是通过函数`separation(x_now,
    y_now, x_dot, y_dot)`完成的。它测量鼠标点击位置与每个滑块控制矩形的距离。如果它很近（在5像素以内）接近一个控制矩形，那么`focus_flag`的值将被设置为与该位置关联的整数。
- en: It works on a similar principle to the official Tkinter scale/slider widget.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理与官方Tkinter的刻度/滑块小部件类似。
- en: It is useful when you want to place a slide controller onto a canvas.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想在画布上放置一个幻灯控制器时，这很有用。
- en: They occupy less screen area than the Ttkinter scale widget.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它们占用的屏幕面积比Ttkinter刻度小部件少。
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: If we need only one canvas slider widget and not three it is a simple matter
    to comment-out or delete any lines of code dealing with two of the widgets.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要一个画布滑块小部件而不是三个，那么注释掉或删除处理两个小部件的任何代码行就是一个简单的问题。
- en: Organizing widgets inside frames
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在框架内组织小部件
- en: We use Tkinter frames to group bunches of related widgets together. When we
    have done this, we only have to think about how we want the frames arranged because
    their contents are already taken care of.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Tkinter框架将相关的小部件组合在一起。当我们这样做之后，我们只需要考虑我们希望框架如何排列，因为它们的内容已经被处理好了。
- en: '![Organizing widgets inside frames](img/3845_11_08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![在框架内组织小部件](img/3845_11_08.jpg)'
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Execute the program shown in the usual way.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常的方式执行程序。
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The position of frames is specified relative to the "root" window.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的位置是相对于“根”窗口来指定的。
- en: Inside each frame, the widgets that belong to it are arranged without reference
    to anything outside that frame.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个框架内部，属于该框架的小部件都是按照不参考该框架外部任何内容的方式进行排列的。
- en: For instance, the specification `redbutton_1.grid(row=0, column=1)` places the
    `red_button` in `row=0` and `column=1` in the grid geometry that is the universe
    of the red frame `frame_1`. The red button is completely unaware of the world
    outside her frame.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，指定`redbutton_1.grid(row=0, column=1)`将`red_button`放置在网格几何中的`row=0`和`column=1`，这是红色框架`frame_1`的宇宙。红色按钮对框架外的世界一无所知。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: For the first time we have changed the background color of the root Tkinter
    window from the default gray one to black.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，我们将根Tkinter窗口的背景颜色从默认的灰色改为黑色。
- en: Appendix appA. Quick tips for running Python programs in Microsoft Windows
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 appA. 在Microsoft Windows中运行Python程序的快速提示
- en: Running Python programs in Microsoft Windows
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Microsoft Windows中运行Python程序
- en: In a Linux-operating system, Python is usually already installed. It already
    has Tkinter, math, and many other libraries installed. You do not have to modify
    any system search path variables like `Path` to run Python.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux操作系统上，Python通常已经安装。它已经安装了Tkinter、math和其他许多库。您不需要修改任何系统搜索路径变量，如`Path`，来运行Python。
- en: Microsoft Windows may throw up some obstacles but it is not too difficult to
    overcome them. The Python Windows installer will install everything it needs in
    a Windows directory `C:\Python27`, if it is version 2.7\. Python version 2.6 would
    get stored in `C:\Python26`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Windows可能会抛出一些障碍，但克服它们并不太难。如果Python版本是2.7，Python Windows安装程序将在Windows目录`C:\Python27`中安装它需要的所有东西。Python版本2.6将被存储在`C:\Python26`。
- en: Where will we find the windows installer?
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在哪里可以找到Windows安装程序？
- en: We will find it at [www.python.org/download/](http://www.python.org/download/).
    When the [www.python.org/download/](http://www.python.org/download/) page opens
    up, select **Python 2.7 Windows installer (Windows binary does not include source)**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[www.python.org/download/](http://www.python.org/download/)找到它。当[www.python.org/download/](http://www.python.org/download/)页面打开时，选择**Python
    2.7 Windows安装程序（Windows二进制文件不包含源代码）**。
- en: This will download a file named `Python-2.7.msi` into our windows `Downloads`
    folder. We just have to double-click on this file and Python version 2.7 will
    install itself onto our system at `C:\Python27`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载一个名为`Python-2.7.msi`的文件到我们的Windows `下载`文件夹。我们只需双击此文件，Python 2.7版本就会自动安装到我们的系统中的`C:\Python27`。
- en: Do we have to use Python version 2.7?
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们必须使用Python 2.7版本吗？
- en: No, the code in this book should work on Python versions 2.4, 2.5, 2.6, and
    2.7\. It has been run by various people on these versions. It will not run on
    Python version 3.0 and higher without changes required by the new Python syntax.
    For instance, print has to be changed to print (stuff-to-be printed).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这本书中的代码应该在Python版本2.4、2.5、2.6和2.7上运行。它已经被不同版本的人运行过。如果不修改新Python语法的要求，它将无法在Python
    3.0及以上版本上运行。例如，print必须改为print（要打印的内容）。
- en: Why do we get "python is not recognized…"?
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么会出现"python未识别…"？
- en: 'This happens because the Windows operating system does not know where to find
    Python when you type `python` into a command window as shown in the following
    screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当你在命令窗口中输入`python`时，Windows操作系统不知道在哪里找到Python，如下面的截图所示：
- en: '![Why do we get "python is not recognized…"?](img/3845_appendix_01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![为什么会出现"python未识别…"?](img/3845_appendix_01.jpg)'
- en: 'There are three ways around this problem:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以解决这个问题：
- en: Type in the full pathname for both python and the target program we want to
    run. In this example, we have used the python program named `entry_box_1.py`.
    It has been stored inside a folder named `constr` as described in the first example
    *Running a Shortest Python Program* in the first chapter. The following screenshot
    shows the command-line dialog. `george` is the name of the user logged into Windows.![Why
    do we get "python is not recognized…"?](img/3845_appendix_02.jpg)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入python和我们要运行的程序的全路径名称。在这个例子中，我们使用了名为`entry_box_1.py`的python程序。它被存储在名为`constr`的文件夹中，正如第一章中第一个示例*运行简短的Python程序*中所述。下面的截图显示了命令行对话框。`george`是登录到Windows的用户名。![为什么会出现"python未识别…"?](img/3845_appendix_02.jpg)
- en: Work inside the `Python27` folder. What we do is `cd.`. and `cd.`. again. Then
    `cd` into folder `Python27`. Then we can just type `python \constr\entry_box_1.py`
    into the command-line as shown in the following screenshot:![Why do we get "python
    is not recognized…"?](img/3845_appendix_03.jpg)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Python27`文件夹内工作。我们执行的操作是`cd.`. 和 `cd.`. 再次。然后进入文件夹`Python27`。然后我们可以在命令行中输入`python
    \constr\entry_box_1.py`，如下面的截图所示：![为什么会出现"python未识别…"?](img/3845_appendix_03.jpg)
- en: 'Change the Windows system variable that informs Windows where to search for
    executable files. We do this by typing `set PATH=%PATH%;C:\Python27` into the
    command-line window. From now on, we can just type `python \constr\entry_box_.py`
    from within any folder. The dialog that achieves this is shown in the following
    screenshot:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改Windows系统变量，告知Windows在哪里搜索可执行文件。我们通过在命令行窗口中输入`set PATH=%PATH%;C:\Python27`来完成此操作。从现在起，我们只需在任何文件夹中输入`python
    \constr\entry_box_.py`即可。实现这一点的对话框如下所示：
- en: 'screenshot:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 截图：
