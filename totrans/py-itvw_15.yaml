- en: Chapter 15. Oliver Schoenborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Oliver Schoenborn](img/B08180_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Oliver Schoenborn is a Canadian software developer and independent software
    developer. Past roles have included working as a simulation consultant at CAE
    Inc and as a visualization software developer at the National Research Council
    Canada. Oliver is passionate about connecting with the business and government
    communities. He is the author of Pypubsub (hosted at [https://github.com/schollii/pypubsub](https://github.com/schollii/pypubsub)),
    a Python package that gives users a simple way to decouple parts of their event-based
    application. Oliver regularly updates Pypubsub and contributes to the wxPython
    mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion themes: Pypubsub, Python in AI, Python''s future.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Catch up with Oliver Schoenborn here: @schollii2**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Mike Driscoll**: So let''s start with your background. Why did you decide
    to become a programmer?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn**: Well, a buddy at school was selling his Apple IIe. I
    had never done programming before that, but I decided to buy his used computer.
    I was 14 at the time.'
  prefs: []
  type: TYPE_NORMAL
- en: I remember being quite intrigued by the BASIC and assembly language. There was
    a command prompt and you could somehow drop into the assembly level to write assembly.
    I read the many manuals for the computer, which described how to program it. I
    tried to write some little programs and eventually got into Pascal. I really enjoyed
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In my fifth year of high school, a school teacher asked us to do something with
    a language called Logo. It was basically graphics commands to move a pen right,
    left, draw lines etc. I created a simulation loop in there so that I could simulate
    a little aircraft flying and dropping a bomb. It was very simple but it was fun,
    and the teacher was impressed!
  prefs: []
  type: TYPE_NORMAL
- en: So that's how I got into programming. It was more or less a chance in some ways.
    At that point, programming was still just a hobby, because my goal was to get
    into physics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: So how did you end up getting into Python itself?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: At work we had a project that needed some graphical user interface
    development on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: For the previous 10 years, I had mostly programmed in C++ on UNIX, developing
    command line and 3D graphics applications, but not menu-based applications (except
    for a GUI written in Java AWT). I really dreaded MFC, so I started looking into
    options on Windows for doing that. I came across Python (because it was platform
    independent), and Tk.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''Python was the perfect fit. As soon as I saw the language,
    I really related to its simple and clean syntax.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python was the perfect fit. As soon as I saw the language, I really related
    to its simple and clean syntax. I don't know if it just matched my way of thinking.
    I also found wxPython and saw that its API seemed to be rather solid. I fell in
    love with Python and the ability it provided to quickly create interfaces using
    wxPython.
  prefs: []
  type: TYPE_NORMAL
- en: So how I got into Python was through a work project that had requirements that
    were more easily achievable in Python than in C++.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Was this how you got involved with the wxPython community as
    well?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: That''s right. I developed my first application in wxPython
    as a result of that project. It was an application for analyzing seat heating
    and air-conditioning. Back then, automobile seat comfort was being prototyped
    using this kind of software.'
  prefs: []
  type: TYPE_NORMAL
- en: So I used wxPython and I thought that the publish-subscribe pattern that it
    supported was a really awesome idea. I got involved more heavily with the wxPython
    development by taking over the Pubsub component of that library.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''I got involved more heavily with wxPython development
    by taking over the Pubsub component of the wxPython library.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Driscoll**: So was Pubsub started by someone else?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: Yes, Robb Shecter created the first version of Pubsub. There
    were limitations that I needed to get around (mostly, a memory leak: subscribers
    were not released after they were no longer needed by the application), and I
    proposed some significant patches and unit tests. Robb was looking for someone
    to take over `wx.lib.pubsub`. So I did that.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Is that also when Pubsub got split into its own module away from
    wxPython?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: I think it was a couple of years later. Pubsub was pretty much
    a standalone sub-package, whereas most other wx.lib sub-packages required other
    wxPython components. I wanted to make wx.lib.pubsub available to a broader set
    of developers, and others on the wxPython developers group agreed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''Pubsub was pretty much a standalone component.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Driscoll**: Were you guys aware of the PyDispatcher projects at that time?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: Well, I did become aware of PyDispatcher at some point in those
    years. It was quite a different approach.'
  prefs: []
  type: TYPE_NORMAL
- en: I remember that at the time it was not topic- based. Pubsub was sufficiently
    different from it to be justified as a separate package. It has been a while since
    I have looked at it, but it would be interesting actually to see where PyDispatcher
    is at now.
  prefs: []
  type: TYPE_NORMAL
- en: There are several projects now that use the basic idea of topics, messaging,
    and publish/subscribe (such as MQTT and Google pub/sub), but at the network, that
    is the inter-application level, whereas Pypubsub is at the application inter-component
    level. They have evolved much more than Pubsub has had to evolve; Pypubsub is
    mature and production quality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: So I noticed that when you did that interview with me in the
    PyDev of the Week series, you had switched to PyQt. How did that happen?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: That was some time in 2013\. We basically had this project
    that involved modernizing an old prototype that our client had. The application
    involved user-defined scripts that could be run by the prototype and those were
    all written in Python. So we had to either embed a Python interpreter, or translate
    huge Python scripts into another language, while guaranteeing the same outputs,
    (a task that could not fit within the scope of the project budget).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''We had to either embed a Python interpreter, or translate
    huge Python scripts.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The graphics interface had to be very sophisticated. At the time, the prototype
    had a 3D component, where the user could rotate model components in a 3D environment.
    We needed to integrate the graphical user interface with menus and list views
    as a sophisticated 2D and 3D canvas, where the user could interact with things.
  prefs: []
  type: TYPE_NORMAL
- en: We wanted something that was stable, powerful, and well-documented, with an
    active community behind it. At the time, WPF, wxPython, and PyQt (or Qt, for a
    C++ infrastructure) were the main candidates for us. On the C# side there was
    WPF. We looked at a number of different approaches and in the end it was between
    wxPython and PyQt.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt seemed to have more powerful integration of a 3D environment than wxPython
    did. PyQt also seemed to be quickly growing towards supporting a 3D scene graph,
    whereas in wxPython I would have had to use OpenGL, and this would have been more
    complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3 was required, but I think that's when Robin Dunn decided to create
    wxPython 3, and so the work on supporting Python 3 was still very early. Basically,
    there was only Python 2.7 for wxPython and the availability of Qt Designer was
    also a factor. PyQt had a very sophisticated interface for creating designs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''PyQt definitely seemed to have momentum.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An XML-driven user interface description was supported by both PyQt and WPF.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt definitely seemed to have momentum, and it supported commercial use of
    the package, which was important for that project. I had had some negative experiences
    with WPF, fighting with the black-magic that it used in order to bind properties
    to widgets. Also, there were signs that IronPython was unmaintained. All things
    considered, we picked PyQt. We did not regret the choice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Going back to the Pypubsub part, I forgot to ask you, did you
    have any challenges while running that open source project that you''d like to
    talk about?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: Well, it wasn''t really a technical challenge, but I did have
    an interesting experience from an open source development point of view. It reminded
    me that you don''t really control the space that you can occupy in the open source
    world.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''You don''t really control the space that you can occupy
    in the open source world.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happened was that Pypubsub was on SourceForge, where it was named simply
    "pubsub", because that's how it was named in wxPython. On PyPI I had named it
    pypubsub. A couple of years later, I found out that there was another project
    on SourceForge called Pypubsub, but it hadn't gone anywhere. Basically, it was
    a dead project and sometimes it led to some confusion on Stack Overflow and the
    two pypubsub forums.
  prefs: []
  type: TYPE_NORMAL
- en: That took some effort to straighten out. I had to contact the author and explain
    what was going on. Eventually, he agreed and I was able to take ownership of the
    "pypubsub" name on SourceForge.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, GitHub had become really popular. Some people had copied my
    Pypubsub source code into GitHub, just to have it handy. Nothing wrong with that,
    but since these forks were not to add features, when I actually decided to move
    Pypubsub to GitHub, I had to let some devs know that Pypubsub was finally available
    there. I explained that there probably was no longer a good reason to have separate
    copies. This was an interesting aspect of open source.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: How much of a commitment was the project?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: Well, there have been various periods during the past 15 years
    when I made major changes to the implementation and extended the API: fixing bugs,
    updating documentation, and make sure that all tests work when there was a new
    release of Python. Finding the time to do those things was often a challenge.
    It is, I guess, another interesting aspect of working on a volunteer basis.'
  prefs: []
  type: TYPE_NORMAL
- en: Evolving the API, while maintaining backwards compatibility, was mostly requested
    by Robin, the wxPython author, and this was important to me even if Pypubsub was
    technically separate from wxPython. It was a major technical challenge to make
    that possible. This led to the concept of Pubsub supporting three APIs or messaging
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''It was a major technical challenge.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First, there was backwards compatibility with the very first version of Pubsub.
    That was what I called the version 1 messaging protocol. Then there was the sort
    of "modern" Pubsub, which had significant improvements in the API, and there were
    two APIs for that.
  prefs: []
  type: TYPE_NORMAL
- en: One was called `arg1` because all message data was in one big blob given as
    one argument to the `sendMessage()` function. The other was called `kwargs` because
    message data was sent via keyword arguments in the `sendMessage()` function. That
    was the default when you installed Pypubsub standalone.
  prefs: []
  type: TYPE_NORMAL
- en: A vanilla installation of wxPython would install the `arg1` API, since that
    one was almost 100% compatible with the version 1 API. A setup flag could be set
    in the application code, before importing Pypubsub, to choose the `kwargs` protocol..
  prefs: []
  type: TYPE_NORMAL
- en: So getting all that to work was a major headache. I had to sort of hijack the
    import system a little bit, basically to allow for the user to say, "Well in this
    application I want the `arg1` protocol and in this wxPython application, I want
    the `kwargs` protocol.."
  prefs: []
  type: TYPE_NORMAL
- en: I also added some code to help transition a wxPython application from version
    1 to `arg1`, to `kwargs` protocol. That was tough too.
  prefs: []
  type: TYPE_NORMAL
- en: I really wish that I hadn't had to do all that, but I felt at the time that
    it was a necessary evil.. Other than code complexity, it made the import system
    used by Pypubsub rather complicated, which could interfere with freezing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Why did you focus on making this transition possible?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: Because I had to go through that challenge in one of my own
    applications on a project. It was using the `arg1` protocol and migrating it to
    the new `kwargs` protocol. Although not complex, this was somewhat tedious and
    error prone. It was worth adding these error checkers and going through the transition,
    due to the advantages of the `kwargs` API.'
  prefs: []
  type: TYPE_NORMAL
- en: I had the concept of a parameter that you could set when you imported Pypubsub.
    This would configure Pypubsub to do some "in-between" tasks, that were useful
    during a transition between the two messaging protocols. The bridge would allow
    you to gradually move towards being fully kwargs, with some helpful facilities
    along the way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''The code was certainly more complex than I wanted it
    to be.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting to a stable API took quite a bit of effort. The frustration was that
    the code was certainly more complex than I wanted it to be, so it was a harder
    to maintain and harder to trace calls through Pypubsub. Also, it caused some challenges
    for people who wanted to freeze their application.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as I was able to, I suggested we deprecate all of that old stuff, since
    it was only useful for the wxPython app with the old API. Robin agreed. In 2016,
    I dropped all support for version 1 and arg1 protocols, allowing for a major clean
    up and the simplification of the code base. So now there's just one API. This
    is v4 of Pypubsub.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: So can you tell me about some other Python projects that you''ve
    been involved with lately?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: Sure, one is a really cool closed-source project, which is
    very challenging technically, with a very sophisticated GUI. I actually mentioned
    it indirectly in discussing the reason for working with PyQt in recent years.'
  prefs: []
  type: TYPE_NORMAL
- en: The application shows a canvas on which you can drop boxes and connect them
    together in different ways. The difference from a tool like Visio is that the
    user can program these boxes to change in time, like an animation, to represent
    a process.
  prefs: []
  type: TYPE_NORMAL
- en: The user does this by defining Python scripts. The application adds a live Python
    namespace to each user script, so that the user can dynamically query the underlying
    model (such as code completion on properties dynamically changed in the model).
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''The application adds a live Python namespace to each
    user script, so that the user can dynamically query the underlying model.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So there's a very sophisticated interface for creating model components, adding
    them, and linking them. There is also a very sophisticated undo function that
    covers all the different aspects of model editing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: '' As usual, there was 10% of the feature that occupied
    90% of its dev time.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We coupled the view to the undo/redo so that the user could always see what
    was going to be undone, or redone, as they navigated their document. This was
    an interesting challenge, and as usual, there was 10% of the feature that occupied
    90% of its dev time.
  prefs: []
  type: TYPE_NORMAL
- en: The application is a simulation system, so it's not just creating lines or boxes.
    There are interface components to manage the simulation, that is, the changing
    of the model in time, restoring it to its initial state, seeing the queue of changes,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: So there is a very large set of functionality in the application. But PyQt has
    been awesome to work with in that respect.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Could you explain a little more about using Qt for this project?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: Yes, Qt''s Graphics View has been really impressive in terms
    of what it has allowed us to do.'
  prefs: []
  type: TYPE_NORMAL
- en: I remember in the beginning, it was not always obvious how to do certain things
    in Qt. For example, in a canvas-based application, where you can do so many different
    things, it's super useful to have a state machine to manage what can be done at
    any given moment. There is no documentation that explains this because it is something
    that you learn over the years as a useful technique. Note that Qt has built-in
    support for state machines, but it wasn't sufficiently powerful for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: A state machine allows you to define states in which only certain actions are
    possible. So in the "creating line" state, the only thing you can do is cancel
    creation, drag the mouse, or select the line target. That's where the state machine
    shines. Without it, your code ends up an unmaintainable spaghetti. Troubleshooting
    and extending with new actions is so much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Although the Qt docs are excellent, there are things you figure out as you go.
    Sometimes you say, "Oh yeah, I finally understand how to do this. I'm going to
    backtrack a bit and fix things." You end up with a more robust implementation
    that can really support the next level of features.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''You end up with a more robust implementation that can
    really have the next level of features.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I'm starting to get kind of familiar with all of the widgets that Qt has. There
    was a nasty bug that we found, when we upgraded PyQt, that caused a whole interface
    to show all sorts of lines as you dragged pieces around. Needless to say, that
    was a problem, but we really needed to update PyQt for other features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We traced the problem back to the C++ layer and by some incredible stroke of
    luck, there was a workaround: there was one line of code that we just had to put
    in our application at Python level. We didn''t even need to change the PyQt source
    code. As long as we had that one line of code, then the bug would go away. I submitted:
    [https://bugreports.qt.io/browse/QTBUG-55918](https://bugreports.qt.io/browse/QTBUG-55918).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very interesting aspect of using Qt was unit testing. We needed unit
    tests for the GUI side of the application. We used the excellent pytest, and had
    one test suite for the core business logic, and one for the GUI components. Unit
    testing a GUI can be really challenging: you have to script user actions.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Qt makes this relatively easy, in that you can easily trigger any widget
    event just by calling a method. But being event based, we needed a way to define
    a bunch of user actions, with the expected outcome. So I created a library to
    support doing this. Unfortunately, source is closed, so I could not share the
    code, but I mentioned the idea on the PyQt forum and some people implemented their
    own concept of it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Python is one of the major languages being used in the AI and
    machine learning boom. What do you think is behind this?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: I would say that it''s the "Olympian" nature of Python that
    makes it good for AI and machine learning. Python happens to be very strong in
    many of the necessary elements, instead of just one or two.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''It''s the "Olympian" nature of Python that makes it
    good for AI and machine learning.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example, Python can be used for functional, procedural, or object-oriented
    coding, in any combination, and the code is still understandable and clean. Moreover,
    no compilation needed makes the exploration of algorithms and data so easy: you
    just modify the code and re-run the script.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Python provides powerful abstractions using a simple syntax. Maybe
    I'm biased, but I think that Python is at the top in this respect. I'm big on
    explicit and clean code, and on refactoring and testing. Being strong at all of
    these things makes Python the perfect language for AI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mike Driscoll: What could be done to make Python a better language for AI
    and machine learning?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: A language is most useful, in a given problem domain, when
    the abstractions provided match those of the problem domain.'
  prefs: []
  type: TYPE_NORMAL
- en: So if deep learning uses neural networks, then having a generic concept of a
    neural net could be really useful.. This is currently provided by libraries like
    TensorFlow. But perhaps as machine learning algorithms improve, a generic abstraction
    for a neural net will emerge that can become a basic data structure like lists
    and maps.
  prefs: []
  type: TYPE_NORMAL
- en: Also, I think we need the ability to ask the AI/machine learning functions,
    "How did you get to this result?" That's how humans validate conclusions. They
    are aware of the logic they used, they can verbalise it, another person can follow
    it, and they can verify its correctness.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Many people I have talked to, and even people at PyCon, have
    put a lot of emphasis on Python growing in the data science field. Are you seeing
    that in what you''re doing, or can you give me any kind of opinion one way or
    the other?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: Yeah, Python is really growing in that field. Tools like Jupyter,
    Anaconda, and scikit-learn are major reasons for this, in my opinion.'
  prefs: []
  type: TYPE_NORMAL
- en: Probably in combination with the fact that with large compute power, the speed
    of the language no longer matters so much. Python can be used in embedded systems,
    so in principle some predictive analytics based on trained machine models can
    happen in the devices themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '****Oliver Schoenborn: ''With large compute power, the speed of the** **language
    no longers matters so much.''****'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There was a really interesting presentation at PyCon in 2017\. A presenter was
    surveying the plotting libraries landscape. The survey started with matplotlib
    and everything around that. Then the survey moved on to some of the JavaScript
    libraries, in some cases related to Python libraries. So this was really fascinating,
    because there is a lot of interest, even for my own clients, in using pandas,
    NumPy, and matplotlib. This showed that there are many different extensions or
    layers that you can add.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking from a client perspective, you want a certain amount of capability
    and you don't want to be limited to only matplotlib, because there's so much more
    that's available. You also know that you don't want to be reinventing the wheel,
    so you must make sure that what you build is sufficiently generic. If you want
    to do statistical analysis, then you might want to do it with Jupyter or R. You
    always try to get a sense of the applications that are providing these capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: You don't want to force the user to use matplotlib, because it is so diverse
    and the API is so advanced. There's no way that you can provide a GUI component
    that supports everything that matplotlib can do.
  prefs: []
  type: TYPE_NORMAL
- en: Python is such an expressive language and so easy to learn. I think that's why
    Python is so big now in research and applied research. It's easy to apply, sophisticated
    and solves technical problems.
  prefs: []
  type: TYPE_NORMAL
- en: '****Oliver Schoenborn: ''Python is such an expressive language and so** **easy
    to learn. I think that''s why Python is so big now in research and applied research.''****'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python gives you all of the tools to make and provide something that's robust
    and deterministic. We can measure performance, find bottlenecks or find memory
    leaks. There are so many things that really make Python a great tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Have there been any other particularly memorable PyCon presentations?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: There was another interesting PyCon 2017 presentation about
    the Global Interpreter Lock (GIL). In theory, getting rid of the GIL would be
    so great: we could run Python threads on separate cores.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''In theory, getting rid of the GIL would be so great.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'But the GIL solves a very practical problem: synchronizing access to Python
    data structures. You start digging into the GIL by analyzing what would be necessary,
    and what would be the gain versus the cost. You realize that the GIL really simplifies
    a lot of things and may well be a reason that it''s so easy to do complicated
    things with Python.'
  prefs: []
  type: TYPE_NORMAL
- en: You can basically get concurrent programming, without all the catches of multi-threaded
    programming. Most often in a large class of problems, that's what you want. In
    the other class of problems, you want to tackle trivially parallelizable problems.
    It's basically where you are subdividing the solution into tasks. There's very
    little coupling between the tasks and you can do it very easily.
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo is one example because it's very important in simulation and business
    processes. You basically want to run a large number of things many times, with
    very little variation between them. Python makes that easy too.
  prefs: []
  type: TYPE_NORMAL
- en: For trivially parallelizable problems, you need to run those. You can run them
    on separate cores, just using a multiprocessing module. Yes, there's even that
    capability! So many different things that are complex in principle, are simple
    in Python, which makes it so usable for number crunching tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''So many different things that are complex in principle,
    are simple in Python.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But I do think that there should be an easier way to run Python code on multiple
    cores without having to use the module. There should be language constructs that
    work hand in hand with the GIL. There is no technical infeasibility there; it's
    just that there has to be enough concerted effort to make it happen.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: What are you most excited about in Python today?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: The optional type annotation system, asynchronous calls, and
    the multiprocessing module.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Which language is Python''s biggest competitor would you say?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: JavaScript. It''s just so unfortunate that JavaScript dominates
    the web side of things. There are these two major contenders: JavaScript on the
    web and Python in technical computing. If you really need the raw compute speed,
    then you can do C++.'
  prefs: []
  type: TYPE_NORMAL
- en: You can get major speedups in Python, by writing some C++ code and ingesting
    it in Python via SWIG and SIP. There is also Cython. It's so easy to work at a
    high level of abstraction with Python, with that compute power when you need it
    from C++.
  prefs: []
  type: TYPE_NORMAL
- en: I don't know where that's going to go. I think that a lot of things would have
    to happen on the JavaScript side to make it as powerful and as simple to use as
    Python, but on the other hand, I can't see Python becoming a supported language
    in the web browser, because JavaScript is just too established. Maybe if Google
    decides to make Python code runnable from Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''A lot of things would have to happen on the JavaScript
    side to make it as powerful and simple to use as Python.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Driscoll**: So is Python here to stay?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: I think that Python is here to stay. Python is too good a language
    and its community has developed good quality and solid libraries, and language
    evolution processes via PEPs. There is a very rigorous process for Python and
    a lot of smart people working on it. So it''s here to stay for sure.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: What do you think about the long life of Python 2.7? Should people
    move over to the latest version?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: The long life of Python 2.7 is most irritating! Big influencers,
    like Ubuntu and Google Cloud Platform, must start making Python 3.6 their default.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oliver Schoenborn: ''The long life of Python 2.7 is most irritating!''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Driscoll**: What changes would you like to see in future Python releases?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schoenborn**: I would like to see an optional static typing system with type
    inference (so types do not need declaration), true parallelism, and an optional
    compilation mode.'
  prefs: []
  type: TYPE_NORMAL
- en: The combination of optional static typing, compilation, and type inference would
    allow the language to stay simple when starting, and get more rigorous when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It could also provide massive gains in speed and productivity: it''s always
    a time saver to be able to point to any object and know exactly what operations
    are either available on it, or required of it (within a function signature). Realistically,
    I don''t know if a compilation mode (even JIT) that freezes types is feasible,
    but there are some incredibly smart people out there, so I would not discount
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: With regards to parallelism, I'm referring to the ability to run Python code
    on multiple cores simultaneously, while keeping the GIL. Sure, there is the multiprocessing
    module, but I'm talking about constructs built into the language itself as first-class
    citizens.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Thank you, Oliver Schoenborn.'
  prefs: []
  type: TYPE_NORMAL
