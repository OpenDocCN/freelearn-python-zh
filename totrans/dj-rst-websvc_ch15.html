<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Understanding and Customizing the Browsable API Feature</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding and Customizing the Browsable API Feature</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will work with one of the most interesting and powerful features included in the Django REST framework: the browsable API. This feature makes it easy for us to interact with our RESTful Web Services through any web browser. We will gain an understanding of:</p>
<ul>
<li>Understanding the possibility of rendering text/HTML content</li>
<li>Using a web browser to work with our web service</li>
<li>Making HTTP GET requests with the browsable API</li>
<li>Making HTTP POST requests with the browsable API</li>
<li>Making HTTP PUT requests with the browsable API</li>
<li>Making HTTP DELETE requests with the browsable API</li>
<li>Making HTTP OPTIONS requests with the browsable API</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the possibility of rendering text/HTML content</h1>
                </header>
            
            <article>
                
<p>In <a href="dj-rst-websvc_ch14.html" target="_blank">Chapter 4</a>, <em>Using Generalized Behavior from the APIView Class</em>, we made many changes to make it possible for the simple RESTful Web Service to work with a content negotiation class and provide many content renderers. We used the default configuration for the Django REST framework that includes a renderer that produces <kbd>text/html</kbd> content.</p>
<p>The <kbd>rest_framework.response.BrowsableAPIRenderer</kbd> class is responsible for rendering the <kbd>text/html</kbd> content. This class makes it possible for us to browse the API. The Django REST framework includes a feature that generates an interactive and human-friendly HTML output for the different resources when the request specifies <kbd>text/html</kbd> as the value for the <kbd>Content-Type</kbd> key in the request header. This feature is known as the browsable API because it enables us to use a web browser to navigate through the API and easily make different types of HTTP requests.</p>
<div class="packt_tip">The browsable API feature is extremely useful when we have to test the RESTful Web Services that perform CRUD operations on a database, such as the one we have been developing in <a href="https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=79&amp;action=edit#post_61" target="_blank">Chapter 4</a><span>,&#160;</span><em>Using Generalized Behavior from the APIView Class</em>.</div>
<p>Now, we will compose and send HTTP requests that will make the RESTful Web Service user the <kbd>BrowsableAPIRenderer</kbd> class to provide <kbd>text/html</kbd> content in the response. This way, we will understand how the browsable API works before we jump into the web browser and we start using and customizing this feature. In case you stopped Django's development server, you will have to start it again as we learned in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>,&#160;<em>Creating API Views</em>, in the section <em>Launching Django's development server</em>, to start running the Django development server.</p>
<p>Run the following command to retrieve all the toys with the <kbd>Accept</kbd> request header key set to <kbd>text/html</kbd>. Remember that the virtual environment we created in the previous chapters must be activated in order to run the next <kbd>http</kbd> command:</p>
<pre><strong> http -v :8000/toys/ "Accept:text/html"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre><strong> curl -vH "Accept: text/html" -iX GET localhost:8000/toys/</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/toys/</kbd>. These commands specify the <kbd>text/html</kbd> value for the <kbd>Accept</kbd> key in the request header. This way, the HTTP request indicates that it accepts a response of <kbd>text/html</kbd>.</p>
<p>In both cases, we specified the <kbd>-v</kbd> option that provides a verbose output and prints the details of the request that has been made. For example, the following are the first lines of the output generated by the <kbd>http</kbd> command:</p>
<pre>    <strong>GET /toys/ HTTP/1.1</strong>
    <strong>Accept: text/html</strong>
    <strong>Accept-Encoding: gzip, deflate</strong>
    <strong>Connection: keep-alive</strong>
    <strong>Host: localhost:8000</strong>
    <strong>User-Agent: HTTPie/0.9.3</strong></pre>
<p>The second line prints the value for the <kbd>Accept</kbd> key included in the request header,&#160;<kbd>text/</kbd>html. The header response for the request will include the following line:</p>
<pre>    <strong>Content-Type: text/html; charset=utf-8</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/toys/</kbd>. The request will end up running the <kbd>views.toy_list</kbd> function, that is, the <kbd>toy_list</kbd> function declared within the <kbd>toys/views.py</kbd> file. The content negotiation class selected the <kbd>BrowsableAPIRenderer</kbd> class to provide <kbd>text/html</kbd> content in the response. The following lines show the first lines of the output for the <kbd>http</kbd> command:</p>
<div class="CDPAlignCenter CDPAlign"><img height="306" width="511" src="images/502ddeaf-edd3-4c70-b495-2adcd6b4da36.png"/></div>
<p>We can easily detect from the previous output that the Django REST framework provides an HTML web page as a response to our previous requests. If we enter any URL for a resource collection or resource in any web browser, the browser will perform an HTTP GET request that requires an HTML response, that is, the <kbd>Accept</kbd> request header key will be set to <kbd>text/html</kbd>. The web service built with the Django REST framework will provide an HTML response and the browser will render the web page.</p>
<p>By default, the <kbd>BrowsableAPIRenderer</kbd> class uses the Bootstrap popular frontend component library. You can read more about Bootstrap here: <a href="http://getbootstrap.com"><span class="URLPACKT">http://getbootstrap.com</span></a>. The web page might include the following elements:</p>
<ul>
<li>Diverse buttons to perform other requests to the resource or resource collection</li>
<li>A section that displays the resource or resource collection content in JSON</li>
<li>Forms with fields that allow us to submit data for <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>PATCH</kbd> requests</li>
</ul>
<p>The Django REST framework uses templates and themes to render the pages for the browsable API. It is possible to customize many settings to tailor the output to our specific requirements.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using a web browser to work with our web service</h1>
                </header>
            
            <article>
                
<p>Let's start browsing our RESTful Web Service. Open a web browser and enter <kbd>http://localhost:8000/toys/</kbd>. The browser will compose and send a <kbd>GET</kbd> request to <kbd>http://localhost:8000/toys/</kbd> with <kbd>text/html</kbd> as the desired content type and the returned HTML web page will be rendered.</p>
<p>Under the hood, the web service will compose and send an HTTP GET request to <kbd>http://localhost:8000/toys/</kbd> with <kbd>application/json</kbd> as the content type and the headers, and the JSON returned by this request will be rendered as part of the content of the web page. The following screenshot shows the rendered web page with the resource collection description,&#160;<span class="packt_screen">Toy List</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/5f029d42-262c-425d-8c8a-f2de015d210c.png"/></div>
<p>When we work with the browsable API, Django uses the information about the allowed methods for a resource or resource collection to render the appropriate buttons to allow us to execute the related requests. In the previous screenshot, you will notice that there are two buttons on the right-hand side of the resource description (<span class="packt_screen">Toy List</span>): <span class="packt_screen">OPTIONS</span> and <span class="packt_screen">GET</span>. We will use the different buttons to make additional requests to the RESTful Web Service.</p>
<p>If you decide to browse the web service in a web browser that is being executed on another computer or device connected to the LAN, you will have to use the assigned IP address to the computer that is running Django's development server instead of <kbd>localhost</kbd>. For example, if Django's development server is running on a computer whose assigned IPv4 IP address is <kbd>192.168.2.125</kbd>, instead of <kbd>http://localhost:8000/toys/</kbd>, you should use <kbd>http://192.168.2.125:8000/toys/</kbd>. You can also use the hostname instead of the IPv4 address or an IPv6 address.</p>
<p>One of the nicest features of the browsable API is that it makes it extremely easy to test a RESTful Web Service from a mobile device.</p>
<p>As a disclaimer, I must say that once you learn how to take advantage of the browsable API, you will never want to work with a framework that doesn't provide a feature like this one.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP GET requests with the browsable API</h1>
                </header>
            
            <article>
                
<p>We just made an HTTP GET request to retrieve the toys resource collection with the browsable API. Now, we will compose and send another HTTP GET request for an existing toy resource with the web browser.</p>
<p>Enter the URL for an existing toy resource, such as <kbd>http://localhost:8000/toys/3</kbd>. Make sure you replace <kbd>3</kbd> with the <kbd>id</kbd> or primary key of an existing toy in the previously rendered <span class="packt_screen">Toy List</span>. Django will compose and send a <kbd>GET</kbd> request to <kbd>http://localhost:8000/toys/3</kbd> and the rendered web page will display the results of its execution, that is, the headers and the JSON data for the toy resource. The following screenshot shows the rendered web page after entering the URL in a web browser with the resource description,<span class="packt_screen">&#160;Toy Detail</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="330" width="516" src="images/a5c611fe-6153-4eb3-9cc5-e66c5e19f076.png"/></div>
<p>At the right-hand side of the resource description, the browsable API shows a <span class="packt_screen">GET</span> drop-down button. This button allows us to make a <kbd>GET</kbd> request to <kbd>/toys/3</kbd> again. If we click or tap the down arrow, we can select the <span class="packt_screen">json</span> option and the browsable API will display the raw JSON results of a <kbd>GET</kbd> request to <kbd>/toys/3</kbd> without the headers. In fact, the browser will go to <kbd>http://localhost:8000/toys/3?format=json</kbd> and the Django REST framework will display the raw JSON results because the value for the <kbd>format</kbd> query parameter is set to <kbd>json</kbd>. The following screenshot shows the results of making that request:</p>
<div class="CDPAlignCenter CDPAlign"><img height="125" width="397" src="images/42bd263a-d5c8-4854-8863-9f4a8067cdfd.png"/></div>
<p>Enter the URL for a non-existing toy resource, such as <kbd>http://localhost:8000/toys/250</kbd>. Make sure you replace <kbd>250</kbd> with the <kbd>id</kbd> or primary key of the toy that doesn't exist in the previously rendered <span class="packt_screen">Toy List</span>. Django will compose and send a <kbd>GET</kbd> request to <kbd>http://localhost:8000/toys/250</kbd> and the rendered web page will display the results of its execution, that is, the header with the <kbd>HTTP 404 Not found</kbd> status code.</p>
<p>The following screenshot shows the rendered web page after entering the URL in a web browser:</p>
<div class="CDPAlignCenter CDPAlign"><img height="433" width="467" src="images/c85e7e03-cc44-4b83-a46c-212199d0343e.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP POST requests with the browsable API</h1>
                </header>
            
            <article>
                
<p>Now, we want to use the browsable API to compose and send an HTTP POST request to our RESTful Web Service to create a new toy. Go to the following URL in your web browser,&#160;<kbd>http://localhost:8000/toys/</kbd>. At the bottom of the rendered web page, the browsable API displays the following controls to allow us to compose and send a <kbd>POST</kbd> request to <kbd>/toys/</kbd>:</p>
<ul>
<li><span class="packt_screen">Media type</span>: This dropdown allows us to select the desired parser. The list will be generated based on the configured supported parsers in the Django REST framework for our web service.</li>
<li><span class="packt_screen">Content</span>: This text area allows us to enter the text for the body that will be sent with the POST request. The content must be compatible with the selected value for the media type dropdown.</li>
<li><span class="packt_screen">POST</span>: This button will use the selected media type and the entered content to compose and send an HTTP POST request with the appropriate header key/value pairs and content.</li>
</ul>
<p>The following screenshot shows the previously explained controls at the bottom of the rendered web page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/52ab2175-6cf4-429a-80b7-5fcaf13e2a98.png"/></div>
<p>We enabled all the default parsers provided by the Django REST framework for our RESTful Web Service, and therefore, the <span class="packt_screen">Media type</span> drop-down will provide us with the following options:</p>
<ul>
<li><span class="packt_screen">application/json</span></li>
<li><span class="packt_screen">application/x-www-form-urlencoded</span></li>
<li><span class="packt_screen">multipart/form-data</span></li>
</ul>
<p>Select <span class="packt_screen">application/json</span> in the <span class="packt_screen">Media type</span> dropdown and enter the following JSON content in the <span class="packt_screen">Content</span> text area:</p>
<pre>{ 
    "name": "Surfer girl", 
    "description": "Surfer girl doll", 
    "toy_category":"Dolls", 
    "was_included_in_home": "false", 
    "release_date": "2017-10-29T12:11:25.090335Z" 
} </pre>
<p>Click or tap <span class="packt_screen">POST</span>. The browsable API will compose and send an HTTP <kbd>POST</kbd> request to <kbd>/toys/</kbd> with the previously specified data as a JSON body, and we will see the results of the call in the web browser.</p>
<p>The following screenshot shows a web browser displaying the HTTP status code <kbd>201 Created</kbd> in the response and the previously explained dropdown and text area with the <span class="packt_screen">POST</span> button to allow us to continue composing and sending <kbd>POST</kbd> requests to <kbd>/toys/</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="467" width="559" src="images/bcd09a3c-0c7e-4a85-81f9-d217c2e06758.png"/></div>
<div class="packt_tip">In this case, we entered the JSON key/value pairs as we did when we composed and sent HTTP POST requests with command-line and GUI tools. However, we will learn to configure the browsable API to provide us with a form with fields to make it even easier to perform operations on our RESTful Web Service.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP PUT requests with the browsable API</h1>
                </header>
            
            <article>
                
<p>Now, we want to use the browsable API to compose and send an HTTP PUT request to our RESTful Web Service to replace an existing toy with a new one. First, go to the URL for an existing toy resource, such as <kbd>http://localhost:8000/toys/7</kbd>. Make sure you replace <kbd>7</kbd> with the <kbd>id</kbd> or primary key of an existing toy in the previously rendered <span class="packt_screen">Toy List</span>. The HTML web page that displays the results of an HTTP GET request to <kbd>/toys/7</kbd> plus additional details and controls will be rendered.</p>
<p>At the bottom of the rendered web page, the browsable API displays the controls to compose and send a <kbd>POST</kbd> request to <kbd>/toys/</kbd> followed by the controls to compose and send a <kbd>PUT</kbd> request to <kbd>/toys/7</kbd>. The controls for the <kbd>PUT</kbd> request are the same that we already analyzed for the POST request. The <span class="packt_screen">PUT</span> button will use the selected media type and the entered content to compose and send an HTTP PUT request with the appropriate header key/value pairs and content.</p>
<p>The following screenshot shows the controls to compose and send an HTTP PUT request at the bottom of the rendered web page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/5fad0786-566f-4b85-a486-2b922e6a893c.png"/></div>
<div class="packt_tip">In this example, we took advantage of the features included in the Django REST framework to build the OPTIONS response that indicates which HTTP verbs are allowed for each resource and resource collection. Thus, the browsable API only offers us the possibility to compose and send a POST and PUT methods. The POST method is applied to the resource collection while the PUT method is applied to a single resource. The browsable API doesn't provide the controls to compose and send an HTTP PATCH method on a resource because the code hasn't specified that this verb is accepted as a resource.</div>
<p>Select <span class="packt_screen">application/json</span> in the <span class="packt_screen">Media type</span> dropdown and enter the following JSON content in the <span class="packt_screen">Content</span> text area. Remember that the HTTP PUT method replaces an existing resource with a new one, and therefore, we must specify the values for all the fields and not just for the fields that we want to update:</p>
<pre>{ 
    "name": "Surfer girl", 
    "description": "Surfer girl doll (includes pink surfboard)", 
    "toy_category":"Dolls", 
    "was_included_in_home": "false", 
    "release_date": "2017-10-29T12:11:25.090335Z" 
} </pre>
<p>Click or tap <span class="packt_screen">PUT</span>. The browsable API will compose and send an HTTP <kbd>PUT</kbd> request to <kbd>/toys/7</kbd> with the previously specified data as a JSON body and we will see the results of the call in the web browser. The following screenshot shows a web browser displaying the HTTP status code <kbd>200 OK</kbd> in the response, and the controls to allow us to send a new PUT request, if necessary:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/d674d1c8-957a-45e6-80a5-c4baa2c035f4.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP OPTIONS requests with the browsable API</h1>
                </header>
            
            <article>
                
<p>Now, we want to use the browsable API to compose and send an HTTP OPTIONS request to our RESTful Web Service to check the allowed HTTP verbs, the available renderers, and parsers for a toy resource. First, go to the URL for an existing toy resource, such as <kbd>http://localhost:8000/toys/7</kbd>. Make sure you replace <kbd>7</kbd> with the <kbd>id</kbd> or primary key of an existing toy in the previously rendered <span class="packt_screen">Toy List</span>. The HTML web page that displays the results of an HTTP GET request to <kbd>/toys/7</kbd> plus additional details and controls will be rendered.</p>
<p>At the right-hand side of the <span class="packt_screen">Toy Detail</span> title, you will see an <span class="packt_screen">OPTIONS</span> button. Click or tap this button. The browsable API will compose and send an HTTP <kbd>OPTIONS</kbd> request to <kbd>/toys/7</kbd> and we will see the results of the call in the web browser. The following screenshot shows a web browser displaying the HTTP status code <kbd>200 OK</kbd> in the response, the allowed HTTP verbs, the content types that the toy resource is capable of rendering as values for the <kbd>renders</kbd> key, and the content types that the toy resource is capable of parsing as values for the <kbd>parses</kbd> key:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/94f81573-570a-485d-bf83-c01ecdf243de.png"/></div>
<p>We can also compose and send an HTTP OPTIONS request to our RESTful Web Service to check the allowed HTTP verbs, the available renderers, and parsers for the toys resource collection. First, go to the URL for the toys resource collection: <kbd>http://localhost:8000/toys/</kbd>. The HTML web page that displays the results of an HTTP GET request to <kbd>/toys/</kbd>, plus additional details and controls, will be rendered.</p>
<p>At the right-hand side of the <span class="packt_screen">Toy Detail</span> title, you will see an <span class="packt_screen">OPTIONS</span> button. Click or tap this button. The browsable API will compose and send an HTTP <kbd>OPTIONS</kbd> request to <kbd>/toys/</kbd> with the previously specified data as a JSON body and we will see the results of the call in the web browser. The following screenshot shows a web browser displaying the HTTP status code <kbd>200 OK</kbd> in the response, the allowed HTTP verbs, the content types that the toys resource collection is capable of rendering as values for the <kbd>renders</kbd> key, and the content types that the toys resource collection is capable of parsing as values for the <kbd>parses</kbd> key:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/756ae095-a7cc-494b-a75d-db60b90b2a01.png"/></div>
<p>It is always a good idea to check that all the allowed verbs returned by an HTTP OPTIONS request to a specific resource or resource collection are coded. The browsable API makes it easy for us to test whether the requests for all the supported verbs are working OK. Then, we can automate testing, which is a topic we will learn in the forthcoming chapters.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP DELETE requests with the browsable API</h1>
                </header>
            
            <article>
                
<p>Now, we want to use the browsable API to compose and send an HTTP DELETE request to our RESTful Web Service to delete an existing toy resource. First, go to the URL for an existing toy resource, such as <kbd>http://localhost:8000/toys/7</kbd>. Make sure you replace <kbd>7</kbd> with the <kbd>id</kbd> or primary key of an existing toy in the previously rendered <span class="packt_screen">Toy List</span>. The HTML web page that displays the results of an HTTP GET request to <kbd>/toys/7</kbd>, plus additional details and controls, will be rendered.</p>
<p>At the right-hand side of the <span class="packt_screen">Toy Detail</span> title, you will see a <span class="packt_screen">DELETE</span> button. Click or tap this button. The web page will display a modal requesting confirmation to delete the toy resource. Click or tap the <span class="packt_screen">DELETE</span> button in this modal.</p>
<p>The browsable API will compose and send an HTTP <kbd>DELETE</kbd> request to <kbd>/toys/7</kbd> and we will see the results of the call in the web browser. The following screenshot shows a web browser displaying the HTTP status code <kbd>204 No Content</kbd> in the response:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/24a2b13a-0a09-439c-ab6b-0165b3d4f0fe.png"/></div>
<p>Now, go to the URL for the toys resource collection: <kbd>http://localhost:8000/toys/</kbd>. The HTML web page that displays the results of an HTTP GET request to <kbd>/toys/</kbd> plus additional details and controls will be rendered. The recently deleted toy has been removed from the database. Thus, the list will not include the deleted toy.­ The following screenshot shows a web browser displaying the HTTP status code <kbd>200 OK</kbd> in the response and the list of toys without the recently deleted toy:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/9d654d8e-ebee-4965-a9be-44f18e4b5953.png"/></div>
<p>The browsable API allowed us to compose and send many HTTP requests to our web service by clicking or tapping buttons on a web browser. We could check that all the operations are working as expected in our RESTful Web Service. However, we had to enter JSON content and we couldn't click on hyperlinks to navigate through entities. For example, we couldn't click on a toy's <kbd>id</kbd> to perform an HTTP GET request to retrieve this specific toy.</p>
<p>We will definitely improve this situation and we will take full advantage of many additional features included in the browsable API as we create additional RESTful Web Services. We will do this in the forthcoming chapters. We have just started working with the browsable API.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>Which of the following classes is responsible for rendering the <kbd>text/html</kbd> content:
<ol>
<li>The <kbd>rest_framework.response.HtmlRenderer</kbd> class</li>
<li>The <kbd>rest_framework.response.TextHtmlAPIRenderer</kbd> class</li>
<li>The <kbd>rest_framework.response.BrowsableAPIRenderer</kbd> class</li>
</ol>
</li>
<li>By default, the browsable API uses the following web component library:
<ol>
<li><kbd>Bootstrap</kbd></li>
<li><kbd>ReactJS</kbd></li>
<li><kbd>AngularJS</kbd></li>
</ol>
</li>
<li>When we enter the URL of an existing resource in a web browser, the browsable API:
<ol>
<li>Returns a web page with just the JSON response for an HTTP GET request to the resource</li>
<li>Returns a web page with a section that displays the JSON response for an HTTP GET request to the resource and diverse buttons to perform other requests to the resource</li>
<li>Returns a web page with a section that displays the JSON response for an HTTP OPTIONS request to the resource and diverse buttons to perform other requests to the resource</li>
</ol>
</li>
<li>When we enter the URL of a non-existing resource in a web browser, the browsable API:
<ol>
<li>Renders a web page that displays an <kbd>HTTP 404 not found</kbd> header</li>
<li>Displays a plain text message with an <kbd>HTTP 404 not found</kbd> error</li>
<li>Renders a web page with the last toy resource that was available</li>
</ol>
</li>
</ol>
<ol start="5">
<li>If we enter the following URL, <kbd>http://localhost:8000/toys/10?format=json</kbd>, and there is a toy resource whose <kbd>id</kbd> is equal to <kbd>10</kbd>, the browsable API will display:
<ol>
<li>The raw JSON results of an HTTP GET request to <kbd>http://localhost:8000/toys/</kbd></li>
<li>The raw JSON results of an HTTP GET request to <kbd>http://localhost:8000/toys/10</kbd></li>
<li>The same web page that would be rendered if we entered <kbd>http://localhost:8000/toys/10</kbd></li>
</ol>
</li>
</ol>
<p>&#160;</p>
<p><span>The rights answers are included in the <a href="https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&amp;action=edit#post_454" target="_blank">Appendix</a>,&#160;<em>Solutions</em>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we understood some of the additional features that the Django REST framework adds to our RESTful Web Service, the browsable API. We used a web browser to work with our first web service built with Django.</p>
<p>We learned to make HTTP GET, POST, PUT, OPTIONS, and DELETE requests with the browsable API. We were able to easily test CRUD operations with a web browser. The browsable API allowed us to easily interact with our RESTful Web Service. We will take advantage of additional features in the forthcoming chapters.</p>
<p>Now that we understand how easy it is to take advantage of the browsable API with the Django REST framework, we will move on to more advanced scenarios and we will start a new RESTful Web Service. We will work with advanced relationships and serialization. We will cover these topics in <a href="dj-rst-websvc_ch16.html" target="_blank">Chapter 6</a>, <em>Working with Advanced Relationships and Serialization</em>.</p>


            </article>

            
        </section>
    </div>
</body>
</html>