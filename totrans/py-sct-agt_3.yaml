- en: Chapter 3. Encoding Secret Messages with Steganography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to acquire intelligence data from a variety of sources. In the previous
    chapter, we searched the WWW. We might use our own cameras or recording devices.
    We'll look at image processing and encoding in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To work with images in Python, we'll need to install Pillow. This library gives
    us software tools to process image files. Pillow is a fork of the older PIL project;
    Pillow is a bit nicer to use than PIL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the way, we''ll visit some additional Python programming techniques,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll review how Python works with OS files and also look at some common physical
    formats, including ZIP files, JSON, and CSV.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll introduce JPEG files and learn to process them with Pillow. We'll have
    to install Pillow before we can make this work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at several image transformations, such as getting the EXIF data,
    creating thumbnails, cropping, enhancing, and filtering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at how we can fiddle with the individual bits that make up an integer
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also see how we work with Unicode characters and how characters are encoded
    into bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to work with Unicode characters will allow us to encode data in the
    pixels of an image file. We'll look at the two common steganography algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also take a quick side trip to look at secure hashes. This will show us
    how to make messages that can't be altered in transmission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is a very powerful programming language. In this chapter, we'll see a
    lot of sophistication available. We'll also lay a foundation to look at web services
    and geocoding in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Background briefing – handling file formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've observed so far, our data comes in a wide variety of physical formats.
    In [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"), *Our Espionage Toolkit*,
    we looked at ZIP files, which are archives that contain other files. In [Chapter
    2](ch02.html "Chapter 2. Acquiring Intelligence Data"), *Acquiring Intelligence
    Data*, we looked at JSON files, which serialize many kinds of Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to review some previous technology and then look
    at working specifically with CSV files. The important part is to look at the various
    kinds of image files that we might need to work with.
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, Python encourages looking at a file as a kind of context. This
    means that we should strive to open files using the `with` statement so that we
    can be sure the file is properly closed when we're done with the processing. This
    doesn't always work out perfectly, so there are some exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the OS filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many modules for working with files. We''ll focus on two: `glob`
    and `os`.'
  prefs: []
  type: TYPE_NORMAL
- en: glob
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `glob` module implements filesystem *globbing* rules. When we use `*.jpg`
    in a command at the terminal prompt, a standard OS shell tool will *glob* or expand
    the wildcard name into a matching list of actual file names, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The POSIX standard is for `*.jpg` to be expanded by the shell, prior to the
    `ls` program being run. In Windows, this is not always the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `glob` module contains the `glob()` function that does this job
    from within a Python program. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we evaluated `glob.glob("*.jpg")`, the return value was a list of strings
    with the names of matching files.
  prefs: []
  type: TYPE_NORMAL
- en: os
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many files have a `path/name.extension` format. For Windows, a device prefix
    and the backslash is used (`c:path\name.ext`). The Python `os` package provides
    a `path` module with a number of functions for working with file names and paths
    irrespective of any vagaries of punctuation. As the `path` module is in the `os`
    package, the components will have two levels of namespace containers: `os.path`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We must always use functions from the `os.path` module for working with filenames.
    There are numerous functions to split paths, join paths, and create absolute paths
    from relative paths. For example, we should use `os.path.splitext()` to separate
    a filename from the extension. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've separated the filename from the extension without writing any of our own
    code. There's no reason to write our own parsers when the standard library already
    has them written.
  prefs: []
  type: TYPE_NORMAL
- en: Processing simple text files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, our files contain ordinary text. In this case, we can open the
    file and process the lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the most common way to work with text files. Each line processed by
    the `for` loop will include a trailing `\n` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a simple generator expression to strip the trailing spaces from
    each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve inserted a generator expression into the `for` statement. The generator
    expression has three parts: a subexpression (`raw.rstrip()`), a target variable
    (`raw`), and a source iterable collection (`data`). Each line in the source iterable,
    `data`, is assigned to the target, `raw`, and the subexpression is evaluated.
    Each result from the generator expression is made available to the outer `for`
    loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visually separate the generator expression into a separate line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We wrote the generator expression outside the `for` statement. We assigned
    the generator—not the resulting collection—to the `clean_lines` variable to clarify
    its purpose. A generator doesn''t generate any output until the individual lines
    are required by another iterator, in this case, the `for` loop. There''s no real
    overhead: the processing is simply separated visually.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique allows us to separate different design considerations. We can
    separate the text cleanup from the important processing inside the `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can expand on the cleanup by writing additional generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've broken down two preprocessing steps into two separate generator expressions.
    The first expression removes the `\n` character from the end of each line. The
    second generator expression uses the optional `if` clause—it will get lines from
    the first generator expression and only pass lines if the length is not 0\. This
    is a filter that rejects blank lines. The final `for` statement only gets nonblank
    lines that have had the `\n` character removed.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ZIP files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A ZIP archive contains one or more files. To use `with` with ZIP archives,
    we need to import the `zipfile` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, we can open an archive using something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This creates a context so that we can work with the file and be sure that it's
    properly closed at the end of the indented context.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to create an archive, we can provide an additional parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a ZIP file that uses a simple compression algorithm to save
    space. If we''re reading members of a ZIP archive, we can use a nested context
    to open this member file, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we showed in [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"),
    *Our Espionage Toolkit*, once we''ve opened a member for reading, it''s similar
    to an ordinary OS file. The nested context allows us to use ordinary file processing
    operations on the member. We used the following example earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We used a context to open the archive. We used a nested context to open a member
    of the archive. Not all files can be read this way. Members that are images, for
    example, can''t be read directly by Pillow; they must be extracted to a temporary
    file. We''d do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will extract a member named `warship.png` from the archive and create a
    local file. Pillow can then work with the extracted file.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JSON file contains a Python object that''s been serialized in JSON notation.
    To work with JSON files, we need to import the `json` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The file processing context doesn''t really apply well to JSON files. We don''t
    generally have the file open for any extended time when processing it. Often,
    the `with` statement context is just one line of code. We might create a file
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all that''s required to create a JSON-encoded file. Often, we''ll contrive
    to make the object we''re serializing a list or a dict so that we can save multiple
    objects in a single file. To retrieve the object, we generally do something that''s
    similarly simple, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will decode the object and save it in the given variable. If the file contains
    a list, we can iterate through the object to process each item in the list. If
    the file contains a dictionary, we might work with specific key values of this
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The processing applied to the resulting object, `an_object`, is outside the
    context of the `with` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Python object has been created, we no longer need the file context.
    The resources associated with the file can be released, and we can focus our processing
    steps on the resulting object.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CSV files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CSV** stands for **comma-separated values**. While one of the most common
    CSV formats uses the quote character and commas, the CSV idea is readily applicable
    to any file that has a column-separator character. We might have a file with each
    data item separated by tab characters, written as `\t` in Python. This is also
    a kind of CSV file that uses the tab character to fill the role of a comma.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the `csv` module to process these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When we open a CSV file, we must create a *reader* or *writer* that parses the
    various rows of data in the file. Let's say we downloaded the historical record
    of bitcoin prices. You can download this data from [https://coinbase.com/api/doc/1.0/prices/historical.html](https://coinbase.com/api/doc/1.0/prices/historical.html).
    See [Chapter 2](ch02.html "Chapter 2. Acquiring Intelligence Data"), *Acquiring
    Intelligence Data*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data is in the CSV notation. Once we''ve read the string, we need to create
    a CSV reader around the data. As the data was just read into a big string variable,
    we don''t need to use the filesystem. We can use in-memory processing to create
    a file-like object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `urllib.request.urlopen()` function to make a `GET` request to
    the given URL. The response will be in bytes. We decoded the characters from these
    bytes and saved them in a variable named `history_data`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make this amenable to the `csv.Reader` class, we used the `io.StringIO`
    class to wrap the data. This creates a file-like object without actually wasting
    time to create a file on the disk somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now read individual rows from the `reader` object, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This `for` loop will step through each row of the CSV file. The various columns
    of data will be separated; each row will be a tuple of individual column values.
  prefs: []
  type: TYPE_NORMAL
- en: If we have *tab-separated* data, we'd modify the reader by providing additional
    details about the file format. We might, for example, use `rdr= csv.reader(some_file,
    delimiter='\t')` to specify that there are tab-separated values instead of comma-separated
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: JPEG and PNG graphics – pixels and metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An image is composed of picture elements called pixels. Each pixel is a dot.
    For computer displays, the individual dots are encoded using **red-green-blue**
    (**RGB**) colors. Each displayed pixel is a sum of the levels of red, green, and
    blue light. For printing, the colors might be switched to **cyan-magenta-yellow-key**
    (**CMYK**) colors.
  prefs: []
  type: TYPE_NORMAL
- en: An image file contains an encoding of the various pixels of the image. The image
    file may also contain metadata about the image. The metadata information is sometimes
    called **tags** and even **Exif tags**.
  prefs: []
  type: TYPE_NORMAL
- en: An image file can use a variety of encodings for each pixel. A pure black and
    white image only needs 1 bit for each pixel. High-quality photographs may use
    one byte for each color, leading to 24 bits per pixel. In some cases, we might
    add a transparency mask or look for even higher-resolution color. This leads to
    four bytes per pixel.
  prefs: []
  type: TYPE_NORMAL
- en: The issue rapidly turns into a question of the amount of storage required. A
    picture that fills an iPhone display has 326 pixels per inch. The display has
    1136 by 640 pixels. If each pixel uses 4 bytes of color information, then the
    image involves 3 MB of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scanned image that''s of 8 1/2" by 11" at 326 pixels per inch The
    image is 2762 x 3586 pixels, a total of 39 MB. Some scanners are capable of producing
    images at 1200 pixels per inch: that file would be of 673 MB.'
  prefs: []
  type: TYPE_NORMAL
- en: Different image files reflect different strategies to compress this immense
    amount of data without losing the quality of the image.
  prefs: []
  type: TYPE_NORMAL
- en: A naive compression algorithm can make the files somewhat smaller. TIFF files,
    for example, use a fairly simple compression. The algorithms used by JPEG, however,
    are quite sophisticated and lead to relatively small file sizes while retaining
    much—but not all—of the original image. While JPEG is very good at compressing,
    the compressed image is not perfect—details are lost to achieve good compression.
    This makes JPEG weak for steganography where we'll be tweaking the bits to conceal
    a message in an image.
  prefs: []
  type: TYPE_NORMAL
- en: We can call JPEG compression lossy because some bits can be lost. We can call
    TIFF compression lossless because all the original bits can be recovered. Once
    bits are lost, they can't be recovered. As our message will only be tweaking a
    few bits, JPEG compression can corrupt our hidden message.
  prefs: []
  type: TYPE_NORMAL
- en: When we work with images in Pillow, it will be similar to working with a JSON
    file. We'll open and load the image. We can then process the object in our program.
    When we're done, we'll save the modified image.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Pillow library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to add some cool Python software to process images. The Pillow package
    is a sophisticated image-processing library. This library provides extensive file
    format support, an efficient internal representation, and fairly powerful image
    processing capabilities. For more information, visit [https://pypi.python.org/pypi/Pillow/2.1.0](https://pypi.python.org/pypi/Pillow/2.1.0).
    The Pillow documentation will provide important background in what needs to be
    done. The installation guide on the PyPi web page is essential reading, you will
    get some additional details here. The core Pillow documentation is at [http://pillow.readthedocs.org/en/latest/](http://pillow.readthedocs.org/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Note that Pillow will install a package named `PIL`. This assures that Pillow
    (the project) creates a module that's compatible with the **Python Imaging Library**
    (**PIL**). We'll be importing modules from the `PIL` package, even though we'll
    be installing software created by the Pillow project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the required supporting libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're a Windows agent, then you can skip this section. The folks who build
    Pillow have you firmly in mind. For everyone else, your OS may not be Pillow ready.
  prefs: []
  type: TYPE_NORMAL
- en: Before installing Pillow, some supporting software infrastructure must be in
    place. Once all the supporting software is ready, then Pillow can be installed.
  prefs: []
  type: TYPE_NORMAL
- en: GNU/Linux secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to have the following libraries in our GNU/Linux configuration. Odds
    are good that these files are already present in a given distribution. If these
    files aren''t present, it''s time to perform some upgrades or installations. Install
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**libjpeg**: This library provides access to JPEG images; versions 6b, 8, and
    9 have been tested'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**zlib**: This library provides access to compressed PNG images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**libtiff**: This library provides access to TIFF images; versions 3.x and
    4.0 have been tested'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**libfreetype**: This library provides type-related services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**littlecms**: This library provides color management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**libwebp**: This library provides access to the WebP format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each Linux distribution has a unique approach to installing and configuring
    the libraries. We can't cover them all.
  prefs: []
  type: TYPE_NORMAL
- en: Once the supporting libraries are in place, we can use the `easy_install-3.3
    pillow` command. We'll review this in the *Installing and confirming Pillow* section.
  prefs: []
  type: TYPE_NORMAL
- en: Mac OS X secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install Pillow on a Mac, we require three preliminary steps to be performed.
    We'll need Xcode and homebrew, then we'll use homebrew.
  prefs: []
  type: TYPE_NORMAL
- en: To get Xcode for Mac OS X, visit [https://developer.apple.com/xcode/downloads/](https://developer.apple.com/xcode/downloads/).
    Every Mac OS X agent should have Xcode, even if they're not going to write native
    Mac OS X or iOS apps.
  prefs: []
  type: TYPE_NORMAL
- en: When installing Xcode, we must be sure that we also install the command-line
    developer tools. This is another big download above and beyond the basic XCode
    download.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have Xcode command-line tools, the second preliminary step is to install
    Homebrew from [http://brew.sh](http://brew.sh). This application builds and installs
    GNU/Linux binaries for Mac OS X. Homebrew is not directly related to Python; this
    is a popular Mac OS X developer tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Homebrew installation is a single line entered in the terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will use the curl program to download the Homebrew installation kit from
    GitHub. It will use Ruby to run this installation program, building the various
    Homebrew tools and scripts. The Homebrew installation suggests using `brew doctor`
    to check the development environment. There may be some cleanup to do before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third step is to use the `brew` program to install the required additional
    libraries for Pillow. This command line will handle that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Periodically, we may need to upgrade the libraries Homebrew knows about. The
    command is simply `brew update`. We may also need to upgrade the various packages
    we installed. This is done using `brew upgrade libtiff libjpeg webp littlecms`.
  prefs: []
  type: TYPE_NORMAL
- en: When we've finished the three preliminary steps, we can use the `easy_install-3.3
    pillow` command. We'll review this in the *Installing and confirming pillow* section.
  prefs: []
  type: TYPE_NORMAL
- en: Windows secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Pillow distribution for Windows contains all the various libraries prebuilt.
    The kit will have the following already installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**libjpeg**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**zlib**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**libtiff**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**libfreetype**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**littlecms**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**libwebp**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the installation is complete, these modules will all be present and used
    by Pillow.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and confirming Pillow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once all the required supporting tools are in place (or you're a Windows agent),
    the next step is to install Pillow.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should amount to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Windows agents must omit the `sudo` command that prefixes the `easy_install`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part of the output will look something like this (details will vary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that some libraries were not available, and we can't do every
    kind of processing. If we don't intend to work with JPEG2000 files or do complex
    color management, this is acceptable. On the other hand, if we think we're going
    to do more complex processing, we may need to track down additional modules and
    redo our Pillow installation.
  prefs: []
  type: TYPE_NORMAL
- en: The Pillow installation creates PIL. The top-level package will be named `PIL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test Pillow using it''s own internal test script, `PIL.selftest`. Otherwise,
    we can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If this works, then the PIL package is installed. We can then open an image
    file to see whether things are working properly. The following code shows us that
    PIL happily opened an image file for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows us that PIL was able to save the file in a different format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This simple-looking step requires Pillow do a tremendous amount of computation
    to convert from one format to another.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding and encoding image data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Image files are encoded in a form that makes them handy for reading and writing,
    but not so useful for detailed processing. We''ll need to decode an image from
    the file format to a useful internal representation. Pillow greatly simplifies
    the processes of decoding and encoding image files. Our general strategy for working
    with an image file is to start with the following recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Pillow extracts a number of interesting attributes from the image metadata.
    There's a complex hierarchy of additional information that comes along with the
    image. We'll review some of this metadata in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top level, there are some pieces of information that describe some details
    of the encoding. These are available in a dictionary that is the `info` attribute
    of the `pix` object we created. We can use the `keys()` method of a dictionary
    to see what''s present in the metadata, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Of these keys, the value mapped to the `exif` key is often the most interesting.
    This is the exchangeable image file format data that provides additional details
    about the image. The other items are technical details about the image encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Exif data isn''t automatically decoded by Pillow. We need to use the `_getexif()`
    method to see what''s in the `exif` key for the image. Note the leading `_` sign
    to this name. This is atypical. This method will give us a dictionary of tags
    and values. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn''t look too useful. The good news is that the numeric codes are
    defined in a separate module. We can use a dictionary lookup to translate numeric
    codes to words. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will iterate through the Exif tags and values, translating the tag values
    to words. Now we can find the useful identifying information about the image.
    The output shows us details like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Of these Exif tags, the number `34853`, the `GPSInfo` tag form a subdictionary
    with yet more cryptic numeric keys. This secondary set of numeric codes are defined
    by the `PIL.ExifTags.GPSTAGS` mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to something like the following to dump the information for an
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will iterate through the top-level `.info` dictionary associated with the
    image. Within this top-level `.info` dictionary, if the key is `exif`, we'll iterate
    through the `Exif` dictionary items. Within the `Exif` dictionary, we'll translate
    the numeric keys to meaningful strings. If we find the key, `34853` (`GPSInfo`),
    we know that we have another dictionary that is more deeply nested. We'll use
    another nested `for` loop to iterate through the items of the `GPSInfo` dictionary,
    translating those keys to useful strings.
  prefs: []
  type: TYPE_NORMAL
- en: We might see this kind of output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this output, the Exif data isn't too interesting. The other details don't
    seem useful either.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at a picture that''s richly detailed with metadata, there might
    be over 30 individual pieces of Exif data. For example, here''s a section of some
    Exif data found in one image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This can tell someone a lot about how the picture was taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have pictures taken with modern cameras (such as phone cameras) with
    GPS data, some additional information is packed into the Exif. For some cameras,
    we''ll find this kind of information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The GPS coordinates from the camera are a little odd looking. We can turn each
    of these tuple-of-tuples structures into numbers such as 36°50′40.12″N and 76°17′35.21″W.
    Once we have the location, we can figure out where the picture was taken.
  prefs: []
  type: TYPE_NORMAL
- en: A quick check on the nautical chart 12253 shows that the picture was taken from
    a dock in Norfolk, Virginia. *Every secret agent has a set of nautical charts,
    right? If not, visit* [http://www.nauticalcharts.noaa.gov/mcd/Raster/](http://www.nauticalcharts.noaa.gov/mcd/Raster/).
  prefs: []
  type: TYPE_NORMAL
- en: The ICC profile shows the details of color and rendering for the image. For
    details on the data encoded here, see the applicable specifications from [http://www.color.org/specification/ICC1v43_2010-12.pdf](http://www.color.org/specification/ICC1v43_2010-12.pdf).
    It's not clear that this information is very helpful for what we're doing.
  prefs: []
  type: TYPE_NORMAL
- en: What's more helpful is looking at the picture. LHD 3 painted on the hull seems
    to be important.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating images – resizing and thumbnails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pillow software allows us to perform a number of manipulations on the image.
    We can, without too much additional work, resize, crop, rotate, or apply any number
    of filters to an image.
  prefs: []
  type: TYPE_NORMAL
- en: The most important reason for using PIL is that we have a reproducible, automated
    process. We can find many kinds of manual image manipulation software. The problem
    with these desktop tools is that a manual sequence of steps is irreproducible.
    The benefit of using Pillow for this manipulation is we know precisely what we
    did.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common resizing is to create a thumbnail image from a larger image. Here''s
    how we can create useful thumbnail versions of a collection of images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve imported the modules we need: `PIL.Image`, `glob` and `os`. We used
    `glob.glob("*.jpg")` to locate all of the JPEG files in the current working directory.
    We used `os.path.splitext()` to tease apart the base filename and extension. If
    the filename already ends in `_thumb`, we''ll continue the `for` loop. No more
    processing will happen for this filename; the `for` statement will advance to
    the next item in the glob sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: We opened the image file and immediately created a copy. This allows us to work
    with the original image, if we need to, as well as work with the copy.
  prefs: []
  type: TYPE_NORMAL
- en: We've extracted the size of the original image and assigned each item of the
    tuples to two separate variables, `w` and `h`. We picked the largest of the two
    dimensions using the `max()` function. If the picture was in the landscape mode,
    the width will be largest; if the picture was in the portrait mode, the height
    will be largest.
  prefs: []
  type: TYPE_NORMAL
- en: We've computed the size of the thumbnail image, `w_t` and `h_t`. The pair of
    calculations will assure that the largest dimension is limited to 128 pixels and
    the smaller dimension will be scaled proportionally.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `thumbnail()` method of the `thumb` object, which is a copy of the
    original image. We provided a two-tuple with the new dimensions. It's essential
    that we include `()` around `(w_n, h_n)` to create a tuple for the first argument
    value to the `thumbnail()` method. We also provided the resample function to use;
    in this case, we used the `PIL.Image.ANTIALIAS` function, as this produces good
    (but slow) results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the thumbnail of our LHD warship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating images – resizing and thumbnails](img/0420OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The image is pretty small. This makes it good for attaching it to an e-mail.
    However, for more serious intelligence work, we'll need to blow it up, crop it,
    and enhance it.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating images – cropping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we look at our LHD warship image, we notice that the ship number is almost
    visible on the bow. We'd like to crop that portion of the image and perhaps, blow
    it up. Cropping without a visual editor involves a certain amount of hit-or-miss
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even from the command line, we can crop an image interactively by using the
    `show()` method of an image, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try different bounding boxes until we locate the logo. One way to start
    is to break the image into thirds in each direction; this leads to nine sections,
    computed via relatively simple rules as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The bounding box for a crop operation requires a four-tuple with the left, top,
    right, and bottom sides, in that order. The values must be integers and the `()`
    brackets are required to create four-tuple, instead of four separate argument
    values. The horizontal dividing lines are at `0`, `w//3`, `2*w//3`, and `w`. The
    vertical dividing lines are at `0`, `h//3`, `2*h//3`, and `h`. We can use various
    combinations to locate the various sections of the image and show each section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering formulae like this is error prone. It''s much nicer to work with a
    bounding box defined by a top-left coordinate pair. We can fiddle in a width and
    compute the height to maintain the picture''s proportions. If we use something
    like the following, we only have to tweak the *x* and *y* coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can fiddle with the `x` and `y` values. Then we can use the up arrow key
    to fetch the `ship.crop().show()` line back again. This allows us to step through
    the image manually, just changing `x` and `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do a little better at generalizing the bounding boxes of image sections.
    Consider this list of fractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined the number of slices we want to make. In this case, we''ll
    divide the image into 1/6, giving us 36 individual boxes. We then computed the
    `slice+1` lines at positions between ![Manipulating images – cropping](img/0420OS_03_13.jpg)
    and ![Manipulating images – cropping](img/0420OS_03_14.jpg). Here is an illustration
    that shows the slicing of the image into a 6 x 6 grid. Each cell has a boundary
    defined by the `box` sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating images – cropping](img/0420OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This uses the following pair of nested `for` loops with the `box` fractions
    to generate the individual boundaries for various pieces of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Each boundary box has the left, top, right, and bottom side as a four-tuple.
    We've picked values of two variables to enumerate all 36 combinations from (0,0)
    to (5,5). We've picked two adjacent values from our list of fractions, `lines`.
    This will give us all 36 bounding boxes from top-left to bottom-right.
  prefs: []
  type: TYPE_NORMAL
- en: We can then crop our original image using each of these definitions of box and
    show all 36 slices, looking for the one that's closest to the subject matter we're
    looking for. Also, we might want to resize each image and make it twice as big.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following to show each box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This will display the original image cropped to each of the slices. The `bounds`
    object is a four-tuple with the boundary information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can slightly optimize the expression that computes the bounds using the
    `map()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map()` function will apply a function to each element of the associated
    collection. In this example, we apply the `int()` function to each value of the
    bounding box. It turns out that this is the image we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We've cropped the image using two adjacent boxes. The boxes at (3,6) and (4,6)
    incorporate the ship's identification number nicely. We created a single four-tuple
    with the combined bounding box and cropped the original image to pick up just
    the logo. We used the `show()` method of the `logo` object, which will pop up
    an image viewer. We also saved it so that we'd have a file we could work with
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might want to resize the cropped image. We can use code like this to blow
    up the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will use the original size as a basis so that the expanded image retains
    the original proportions. As with other operations, the size is given as a tuple
    and the inner `()` brackets are required to define a tuple. Without the inner
    `()` brackets, these would be two separate argument values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the cropped image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating images – cropping](img/0420OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's kind of murky and hard to work with. We'll need to enhance it.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating images – enhancing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original picture is pretty grainy. We'd like to enhance the details of the
    slice we found. Pillow has a number of filters than can help modify an image.
    Unlike popular TV shows and movies, there's no enhance feature that magically
    makes a poor image spectacular.
  prefs: []
  type: TYPE_NORMAL
- en: We can modify an image, and sometimes, it's more usable. We can also modify
    an image and leave it no better than we found it. The third choice—not often available
    to secret agents—is that we might make the results more artistic than the original
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three modules in the Pillow package that contain filter-like processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ImageEnhance`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageFilter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageOps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ImageEnhance` module contains `enhance` class definitions. We create an
    enhancer object by binding an enhancer and an image. We then use that bound object
    to create enhanced versions of a given image. An enhancer allows us to make many
    incremental changes to an image. We can think of these as simple knobs, which
    might be turned to tweak the image.
  prefs: []
  type: TYPE_NORMAL
- en: The `ImageFilter` module contains filters functions that will revise the image,
    creating a new image object that we might save. These various kinds of filter
    objects are plugged into the image's `filter()` method. A filter can be imagined
    as a way to reduce the volume of information in the image; the image is usually
    simpler after being filtered.
  prefs: []
  type: TYPE_NORMAL
- en: The `ImageOps` module contains functions that transform one image to create
    a new image. These are different from filtering and enhancing. They're not necessarily
    reducing the data nor are they simple knobs to tweak an image. The `ImageOps`
    module tends to perform more complex transformations.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start out with some simple enhancers in the `PIL.ImageEnhance` module,
    specifically, the `Contrast` class. We won't present each individual class; the
    more systematic exploration is for field agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with one of the four enhancers: the `Contrast` class. Here''s
    how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This builds an enhancer, based on the specific algorithm and the image we're
    working with. We've assigned this enhancer to the `e` variable. We then performed
    an `enhance` operation with a specific parameter value and showed the resulting
    image.
  prefs: []
  type: TYPE_NORMAL
- en: The last image is pretty nice. We can save a copy of this image with `e.enhance(8.0).save(
    "LHD_Number_1.jpg" )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the logo looks with the `Contrast` enhancement set to `8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating images – enhancing](img/0420OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Someone might be able to work with this image. As a field agent, you''ll need
    to experiment with the other three enhancement filters: color, brightness, and
    sharpness. You might be able to extract even more detail from the image.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the first step in defining a reproducible, automated process. Using
    Python from the command line means that we have a record of precisely what we
    did. We can reduce the process to an automated script.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating images – filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at the `ImageEnhance` module to improve an image. We can also filter
    via the image's `filter()` method. The `ImageFilter` module defines 18 different
    filters. When we use a filter, we'll provide the filter object to the `Image.filter()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We'll pick just one of these filters. The `ImageFilter.EDGE_ENHANCE` module
    seems to be helpful for distinguishing between the light-colored letter and the
    dark-colored background. Emphasizing on the transition in color might make the
    letters more visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using the `ImageFilter.EDGE_ENHANCE` filter in the `filter()`
    method of an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `filter` method to create and show a new image.
  prefs: []
  type: TYPE_NORMAL
- en: While this is good, it seems like our enhancement attempts might work better
    with the `ImageEnhance.Contrast` class we used earlier. Here's how we can apply
    a sequence of transformations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code applies the specific filter to the image and creates a new
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We've created an enhanced image and then applied a filter to it. This creates
    something even more crisp and possibly more usable than the original image.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our filtered and enhanced image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating images – filtering](img/0420OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The filter has made some minor changes to the previously saved image. The edge
    on the lower loop of `3` might be a bit more crisp. We'll need to change some
    more things.
  prefs: []
  type: TYPE_NORMAL
- en: Some filters (such as the `EDGE_ENHANCE` object) have no parameters or options.
    Other filters have parameters that can be applied to change the way they work.
    For example, the `ModeFilter()` will reduce a given section of the image to the
    most common color value within that section; we provide a parameter for the number
    of pixels to consider when computing the mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of combining several operations to create a new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This seems to be tending towards art and away from proper intelligence gathering.
    However, a good field agent will work with some additional filters and filter
    parameters to look for better enhancement techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating images – ImageOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at the `ImageEnhance` module to improve an image. We've also looked
    at a few other filters in the `ImageFilter` module. The `ImageOps` module provides
    13 additional transformations that we can use to improve our image.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the `ImageOps.autocontrast()` function, as shown in the following
    snippet. This will adjust the various pixels so that the brightness levels fill
    the entire 8-bit space from 0 to 255\. An image that's dark or washed out lacks
    contrast, and the pixels are all piled up at the dark end or the bright end of
    the spectrum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This shows an image with `autocontrast` applied and the original image. This
    shows the striking difference between the original clipping and an image that
    uses the full range from dark to light. That seems to be just what HQ would want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s tweak the contrast a little further to really make the numbers stand
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems to be the most startling enhancement we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating images – ImageOps](img/0420OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This might be good enough. A competent field agent should play with the rest
    of the `ImageOps` transformations to see whether more improvement is possible.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have the outline for a reproducible, automated process. We
    know precisely what we did to enhance the image. We can use our series of experiments
    to create an automated script for image enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Some approaches to steganography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many more things we can do with image files. One thing we can do is
    use steganography to conceal messages inside image files. As image files are large,
    complex, and relatively noisy, adding a few extra bits of data won't make much
    of a visible change to the image or the file.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes this is summarized as adding a **digital watermark** to an image.
    We're going to subtly alter the image in a way that we can recognize and recover
    it later.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a message can be seen as a lossy modification to the image. Some of the
    original pixels will be unrecoverable. As the JPEG compression, in general, already
    involves minor losses, tweaking the image as part of steganography will be a similar
    level of image corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of losses, the JPEG format can, and will, tweak some of the bits in
    our image. Consequently, it's difficult to perform steganography with JPEG. Rather
    than wrestle with JPEG details, we'll use the TIFF format for our concealed messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common approaches to concealing a message in an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a color channel**: If we overwrite some bytes in just one color channel,
    we''ll be shifting a part of the color of a few pixels in the area we overwrote.
    It will only be a few of millions of pixels, and it will only be one of the three
    (or four) colors. If we confine the tweaking to the edge, it''s not too noticeable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the least significant bits (LSBs) of each byte**: If we overwrite the
    least significant bit in a series of bytes, we''ll make an extremely minor shift
    in the image. We have to limit the size of our message because we can only encode
    one byte per pixel. A small picture that''s *432 * 161 = 69,552* pixels can encode
    8,694 bytes of data. If we use the UTF-8 encoding for our characters, we should
    be able to cram an 8 K message into that image. If we use UTF-16, we''d only get
    a 4 K message. This technique works even for grayscale images where there''s only
    one channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the JPEG compression problem, there are some color encoding schemes
    that don't work out well with either of these steganography approaches. The modes,
    known as **P**, **I**, and **F**, present a bit of a problem. These color modes
    involve mapping a color code to a palette. In these cases, the byte is not the
    level of gray or the level of a color; when using a palette, the bytes are a reference
    to a color. Making a 1-bit change might lead to a profound change in the color
    selected from the underlying palette. The color `5` might be a pleasant sea-foam
    green, the color `4` might be an awful magenta. A 1-bit change between `5` and
    `4` may be a noticeable out-of-place dot.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we can switch the source image to RGB (or CMYK) before applying
    our steganography encoding. The basic change to the color mode might be visible
    to someone who had access to the original image. However, the hidden message will
    remain obscured unless they also know our steganography algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our strategy works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the bytes from the pixels of the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform our secret message from a Unicode string into a sequence of bits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each bit of our secret message, adulterate 1 byte of the original image.
    As we're tweaking the least significant bit, one of two things will happen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll make an image pixel value into an even number to encode a 0 bit from our
    secret message
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll make an image pixel value into an odd number to encode a 1 bit from our
    secret message
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll work with two parallel sequences of values:'
  prefs: []
  type: TYPE_NORMAL
- en: The bytes from the image (ideally enough to encode our entire message)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bits from our secret message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea is to step through each byte of the image and incorporate 1 bit of
    the secret message into that image byte. The cool feature of this is that some
    pixel values might not need to actually change. If we're encoding a byte in a
    pixel that's already odd, we won't change the image at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we need to perform the following important steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the bytes in the red channel of the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the bytes from a Unicode message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the bits from the message bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tweak the image pixel byte using a message bit, and update the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll tackle these one at a time, then we'll weld it all together at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the red-channel data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at encoding our message in an image using the red channel LSB encoding.
    Why red? Why not? Men may have some degree of red-green color blindness; if they're
    less likely to see a shift in this channel, then we've further concealed our image
    from a few prying eyes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first question is this: how do we tinker with the bytes of the original
    image?'
  prefs: []
  type: TYPE_NORMAL
- en: The PIL `Image` object has the `getpixel()` and `putpixel()` methods that allow
    us to get the various color band values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can peel out individual pixels from the image like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve provided an `(x,y)` two-tuple to the `getpixel()` method. This shows
    us that each pixel in the image is a three-tuple. It''s not obvious what the three
    numbers are. We can use `ship.getbands()` to get this information, as shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: There was little doubt in our minds that the three pixel values were red level,
    green level, and blue level. We've used the `getband()` method to get confirmation
    from Pillow that our assumption about the image encoding band was correct.
  prefs: []
  type: TYPE_NORMAL
- en: We now have access to the individual bytes of the image. The next steps are
    to get the bits from our secret message and then adulterate the image bytes with
    our secret message bits.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting bytes from Unicode characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to encode our secret message into the bytes of an image, we'll need
    to transform our Unicode message into bytes. Once we have some bytes, we can then
    make one more transformation to get a sequence of bits.
  prefs: []
  type: TYPE_NORMAL
- en: The second question, is how do we get the individual bits of the message text?
    Another form of this question is, how do we turn a string of Unicode characters
    into a string of individual bits?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a Unicode string we can work with: [http://www.kearsarge.navy.mil](http://www.kearsarge.navy.mil).
    We''ll break the transformation into two steps: first to bytes and then to bits.
    There are a number of ways to encode strings as bytes. We''ll use the UTF-8 encoding
    as that''s very popular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't look like too much happened there. This is because the UTF-8 encoding
    happens to match the ASCII encoding that Python byte literals use. This means
    that the bytes version of a string, which happens to use only US-ASCII characters,
    will look very much like the original Python string. The presence of special `b'
    '` quotes is the hint that the string is only bytes, not full Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: If we had some non-ASCII Unicode characters in our string, then the UTF-8 encoding
    would become quite a bit more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for reference, here''s the UTF-16 encoding of our message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The previous encoded message looks to be a proper mess. As expected, it's close
    to twice as big as UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another view of the individual bytes in the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We've used a generator expression to apply the `hex()` function to each byte.
    This gives us a hint as to how we're going to proceed. Our message was transformed
    into 29 bytes, which is 232 bits; we want to put these bits into the first 232
    pixels of our image.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating bits and bytes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we'll be fiddling with individual bits, we need to know how to transform
    a Python byte into a tuple of 8 bits. The inverse is a technique to transform
    an 8-bit tuple back into a single byte. If we expand each byte into an eight-tuple,
    we can easily adjust the bits and confirm that we're doing the right thing.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need some functions to expand a list of byte into bits and contract the
    bits back to the original list of bytes. Then, we can apply these functions to
    our sequence of bytes to create the sequence of individual bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential computer science is explained next:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A number, ![Manipulating bits and bytes](img/0420OS_03_07.jpg), is a polynomial
    in some particular base. Here''s the polynomial for the value of 234 with base
    10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating bits and bytes](img/0420OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In base 16, we have ![Manipulating bits and bytes](img/0420OS_03_09.jpg). When
    writing hex, we use letters for the 14 and 10 digits: `0xea`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of polynomial representation is true in base 2\. A number, ![Manipulating
    bits and bytes](img/0420OS_03_07.jpg), is a polynomial in base 2\. Here''s the
    polynomial for the value of 234:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating bits and bytes](img/0420OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a way to extract the lower 8 bits from a numeric value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `v&1` expression applies a bitwise operation to extract the rightmost bit
    of a number. We'll append the calculated bit value to the `b` variable. The `v
    >>= 1` statement is the same as `v = v>>1`; the `v>>1` expression will shift the
    value, `v`, one bit to the right. After doing this eight times, we've extracted
    the lowest bits of the `v` value. We've assembled this sequence of bits in a list
    object, `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are accumulated in the *wrong* order, so we reverse them and create
    a tidy little eight-tuple object. We can compare this with the built-in `bin()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: For a value over 127, both the `bin()` and `to_bits()` functions produce 8-bit
    results. For smaller values, we'll see that the `bin()` function doesn't produce
    8 bits; it produces just enough bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite transformation evaluates the polynomial. We can do a little algebra
    to optimize the number of multiplications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating bits and bytes](img/0420OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Because of the grouping, the leftmost 1 winds up multiplied by ![Manipulating
    bits and bytes](img/0420OS_03_12.jpg). As shifting bits to the left is the same
    as multiplying by 2, we can reconstruct the a byte value from a tuple of bits
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `(v<<1)|bit` expression will shift `v` to the left 1 bit, effectively performing
    a `*2` operation. An `OR` operation will fold the next bit into the value being
    accumulated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test these two functions with a loop like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If all 256 byte values are converted to bits and back to bytes, we are absolutely
    sure that we can convert bytes to bits. We can use this to see the expansion of
    our message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show us a big list of 8-tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Each byte of the secret message has become an eight-tuple of individual bits.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the bits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we''ve got two parallel sequences of values:'
  prefs: []
  type: TYPE_NORMAL
- en: The bytes from the image (ideally enough to encode our entire message)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bits from our secret message (in the example, we've got just 29 bytes, which
    is 232 bits)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea is to step through each byte of the image and incorporate one bit of
    the secret message into that byte.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can fully tweak the various image bytes with our message bits, we
    need to assemble a long sequence of individual bits. We have two choices to do
    this. We can create a `list` object with all of the bit values. This wastes a
    bit of memory, and we can do better.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create a generator function that will appear to be a `sequence`
    object with all of the bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a generator function that we can use to emit the entire sequence of
    bits from the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We've stepped through each individual eight-tuple in the list-of-tuples values
    that can be created by our `to_bits()` function. For each bit in the 8-tuple,
    we've used the `yield` statement to provide the individual bit values. Any expression
    or statement that expects an iterable sequence will be able to use this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can use this to accumulate a sequence of all 232 bits from a
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This will apply the `to_bits()` function to each byte of the message, creating
    a sequence of 8-tuples. Then it will apply the `bit_sequence()` generator to that
    sequence of eight-tuples. The output is a sequence of individual bits, which we
    collected into a `list` object. The resulting list looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We can see the list of 232 individual bits built from our original message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the inverse to the `bit_sequence()` function. This will group a sequence
    of bits into eight-tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We've used the built-in `enumerate()` generator function to provide a number
    for each individual bit in the original sequence. The output from the `enumerate(bits)`
    expression is a sequence of two-tuples; each two-tuple has the enumerated bit
    number (from `0` to `231`) and the bit value itself (`0` or `1`).
  prefs: []
  type: TYPE_NORMAL
- en: When the bit number is a multiple of `8` (`n%8 == 0`), we've seen a complete
    batch of eight bits. We can convert these eight bits to a byte with `to_byte()`,
    yield the byte value, and reset our temporary accumulator, `byte`, to be empty.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've made a special exception for the very first byte.
  prefs: []
  type: TYPE_NORMAL
- en: The `enumerate()` function will assign the very first byte number `0`; since
    `0%8 == 0`, it looks like we've just accumulated eight bits to make a byte. We've
    avoided this complication by assuring that `n` is not 0; it's not the first bit
    value. We could also have used the `len(byte) != 0` expression to avoid the first-time
    complication.
  prefs: []
  type: TYPE_NORMAL
- en: The final `yield` statement is critical for success. The final batch of bits
    will have `n%8` values of `0` to `7`. The `n%8` test won't be used when the collection
    of bits is exhausted, but we'll still have eight bits accumulated in the `byte`
    variable. We yield this final batch of eight bits as an extra step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We've taken the sequence of individual bits and collected each batch of eight
    bits into bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding the message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we can transform any Unicode string into bits, we can encode a message
    into an image. The final nuance is how to delimit the message. We don't want to
    accidentally decode each byte in the entire image. If we did this, our message
    will be padded with random characters. We need to know when to stop decoding.
  prefs: []
  type: TYPE_NORMAL
- en: One common technique is to include a terminator character. Another common technique
    is to provide a length in front of the string. We're going to include a length
    in front of the string so that we aren't constrained by the contents of the string
    or the encoded bytes that are produced from that string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use a 2-byte length in front of the string; we can encode it into bytes
    and bits like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We've used the Python `divmod()` function to compute the quotient and remainder
    after division. The results of the `divmod( len(message), 256 )` expression will
    be `len(message)//256` and `len(message)%256`. We can recover the original value
    from the `len_H*256+len_L` expression.
  prefs: []
  type: TYPE_NORMAL
- en: The `size` variable is set to a short sequence composed of two eight-tuples
    built from the `len_H` and `len_L` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete sequence of bytes, including the length, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: First, we encoded the message into bytes. Depending on the Unicode characters
    involved and the encoding used, this may be longer than the original message.
    The `bits_list` variable is a sequence of eight-tuples built from the various
    bytes of the encoded message.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we created two more bytes with the length information and converted them
    to bits. The `size_list` variable is a sequence of eight-tuples built from the
    bytes of the encoded size.
  prefs: []
  type: TYPE_NORMAL
- en: The `size_list+bits_list` expression shows how to concatenate the two sequences
    to create a long sequence of individual bits that we can embed into our image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we use the `putpixel()` and `getpixel()` methods to update the
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We've extracted the size of the original image; this tells us how long the *x*
    axis is so that we can use multiple rows of the image if necessary. If our image
    only has 128 pixels on a row, we'll need more than one row for a 292-bit message.
  prefs: []
  type: TYPE_NORMAL
- en: We've applied the `enumerate()` function to the `bit_sequence(size_list+bits_list)`
    value. This will provide both a sequence number and an individual bit from the
    original message. The sequence number can be converted to a row and column using
    the `divmod()` function. We'll set `y` to `sequence // width`; we'll set `x` to
    `sequence % width`.
  prefs: []
  type: TYPE_NORMAL
- en: If we use the thumbnail image, which is 128-pixels wide, the first 128 bits
    go to row `0`. The next 128 bits go to row `1`. The balance of the 292 bits will
    wind up on row `3`.
  prefs: []
  type: TYPE_NORMAL
- en: We got the RGB values from the pixel using `ship.getpixel( (x,y) )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve highlighted the bit-fiddling part: `r_new = (r & 0xfe) | m`. This uses
    a **mask** value of `0xfe`, which is `0b11111110`. This works because the `&`
    operator has a handy feature. When we use `b&1`, the value of `b` is preserved.
    When we use `b&0`, the result is `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The value of `b` (either `1` or `0`) was preserved. Similarly, `1 & 0` and `0
    & 0` are both `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a mask value in `(r & 0xfe)` means that the leftmost seven bits of `r`
    will be preserved; the rightmost bit will be set to `0`. When we use `(r & 0xfe)
    | m`, we''ll be folding the value of `m` into the rightmost position. We''ve printed
    out the old and new pixel values to provide some details on how this works. Here
    are two rows from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the old value of the red channel was `245`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The value `244` shows how the rightmost bit was removed from `245`. When we
    fold in a new bit value `0`, the result remains `244`. An even value encodes a
    0 bit from our secret message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the old value of the red channel was `246`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The value remains `246` when we remove the rightmost bit. When we fold in a
    new bit value of `1`, the result becomes `247`. An odd value encodes a one bit
    from our secret message.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `ship.show()` before and after the image reveals no perceivable change
    to the image.
  prefs: []
  type: TYPE_NORMAL
- en: After all, we've only tweaked the level of the red in the image by plus or minus
    `1` on a scale of `256`, less than half percent change.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will decode a message concealed with steganography in two steps. The first
    step will decode just the first two bytes of length information, so we can recover
    our embedded message. Once we know how many bytes we're looking for, we can decode
    the right number of bits, recovering just our embedded characters, and nothing
    more.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ll be dipping into the message twice, it will help to write a bit extractor.
    Here''s the function that will strip bits from the red channel of an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve defined a function with three parameters: an image, an offset into the
    image, and a number of bits to extract. The length information is an offset zero
    and has a length of 16 bits. We set those as default values.'
  prefs: []
  type: TYPE_NORMAL
- en: We used the a common `divmod()` calculation to transform a position into *y*
    and *x* coordinates based on the overall width of the image. The `y` value is
    `position//width`; the `x` value is `position%width`. This matches the calculation
    carried out when embedding bits into the message.
  prefs: []
  type: TYPE_NORMAL
- en: We used the image's `getpixel()` method to extract the three channels of color
    information. We used `r & 0x01` to calculate just the rightmost bit of the red
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the value was returned with a `yield` statement, this is a generator function:
    it provides a sequence of values. As our `byte_sequence()` function expects a
    sequence of values, we can combine the two to extract the size, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We grabbed 16 bits from the image using the `get_bits()` function. This sequence
    of bits was provided to the `byte_sequence()` function. The bits were grouped
    into eight-tuples and the eight-tuples transformed into single values. We can
    then multiply and add these values to recover the original message size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how many bytes to get, we also know how many bits to extract.
    The extraction looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `get_bits()` function to extract bits starting from position
    16 and extending until we've found a total of `size*8` individual bits. We grouped
    the bits into eight-tuples and converted the eight-tuples to individual values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a sequence of bytes, we can create a `bytes` object and use Python''s
    decoder to recover the original string. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This will properly decode bytes into characters using the UTF-8 encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and preventing tampering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use steganography to assure that our message isn't tampered with. If
    we can't find our digital watermark properly encoded, we know that our picture
    was touched. This is one way to detect tampering. A more robust technique to detect
    tampering is to use hash totals. There are a number of hash algorithms used to
    produce a summary or signature of a sequence of bytes. We send both the message
    and the hash code separately. If the received message doesn't match the hash code,
    we know something went wrong. One common use case for hashes is to confirm a proper
    download of a file. After downloading a file, we should compare the hash of the
    file we got with a separately published hash value; if the hash values don't match,
    something's wrong with the file. We can delete it before opening it.
  prefs: []
  type: TYPE_NORMAL
- en: While it seems like encryption would prevent tampering, it requires careful
    management of the encryption keys. Encryption is no panacea. It's possible to
    employ a good encryption algorithm but lose control of the keys, rendering the
    encryption useless. Someone with unauthorized access to the key can rewrite the
    file and no one would know.
  prefs: []
  type: TYPE_NORMAL
- en: Using hash totals to validate a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has a number of hash algorithms available in the `hashlib` module. Software
    downloads are often provided with MD5 hashes of the software package. We can compute
    an MD5 digest of a file using `hashlib`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We've created an MD5 digest object using the `hashlib.new()` function; we named
    the algorithm to be used. We opened the file in *bytes* mode. We provided the
    entire file to the digest object's `update()` method. For really large files,
    we might want to read the file in blocks rather than read the entire file into
    memory in one swoop. Finally, we printed the hex version of the digest.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will provide a hexadecimal string version of the MD5 digest, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Having this secure hash allows us to confirm that the file has not been tampered
    with in its journey through the Internet from sender to receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Using a key with a digest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can provide considerably more security by adding a key to a message digest.
    This doesn't encrypt the message; it encrypts the digest to be sure that the digest
    is not touched during transmission.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hmac` module in the Python standard library handles this for us, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've created an HMAC digest object and also passed the message
    content to that digest object. The `hmac.new()` function can accept both the key
    (as a string of bytes) and the body of a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hex digest from this HMAC digest object includes both the original message
    and a key we provided. Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: As HQ knows our key, they can confirm that a message comes from us.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, HQ must use our key when sending us a message. We can then use our
    key when we read the message to confirm that it was sent to us by HQ.
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems – encrypting a message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For proper encryption, the PyCrypto package can be used, which can be downloaded
    from [https://www.dlitz.net/software/pycrypto/](https://www.dlitz.net/software/pycrypto/).
    As with Pillow, this is a hefty download.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"), *Our
    Espionage Toolkit*, a poor choice of key will render any encryption scheme essentially
    worthless. If we encrypt a file using a single-word key that's available in a
    readily available corpus of words, we haven't really made our data very secure
    at all. A brute-force attack will break the encryption.
  prefs: []
  type: TYPE_NORMAL
- en: We can combine steganography with the creation of a `ZipFile` archive to embed
    a message in an image in a ZIP file. As a ZIP file can have a comment string,
    we can include an HMAC signature as the comment for the ZIP archive.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we'd use the ZIP encryption. However, the Python `ZipFile` library
    doesn't create encrypted ZIP files. It only reads encrypted files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to define a function that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We'll provide the text of our message, the image source, the key we'll use to
    create our HMAC signature, and an output filename. The output from this will be
    a ZIP file that contains the image and the signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outline of our `package()` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We've opened the source image and used an `steg_embed()` function to put our
    secret message into the image. We've saved the updated image to a temporary file.
  prefs: []
  type: TYPE_NORMAL
- en: We computed the HMAC digest of our image file before doing anything else with
    it. We saved the digest in the `digest` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything is prepared, we can create a new archive file. We can write
    the image into one member of the archive. When we are setting the `comment` attribute
    of the archive, this will make sure that the comment text is written when the
    archive is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we had to convert the key to ASCII bytes to create a digest. The HMAC
    algorithm is defined for bytes, not Unicode characters. Similarly, the resulting
    `hexdigest()` string had to be converted to ASCII bytes before it could be placed
    in the archive. ZIP archives only work in bytes and can't directly support Unicode
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we removed the temporary file that had the tweaked image in it. There's
    no reason to leave potentially incriminating files laying around.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, we need to complete the function, `steg_embed()`, that implements
    our steganographic encoding. See the *Some approaches to steganography* section
    for details on how this needs to work.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking a message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll also need the inverse function that can decode a message in a ZIP archive.
    This function would have a definition like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'It requires a ZIP filename and a key to validate the signature. This can return
    two things: the embedded message and the image into which the message was encoded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The outline of our `unpackage()` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We're going to remove any temporary file that might exist. If the file doesn't
    exist already, that's a good thing, but it will raise a `FileNotFoundError` exception.
    We need to trap and silence that exception.
  prefs: []
  type: TYPE_NORMAL
- en: Our first step is to open the ZIP file and then open the `image.tiff` member
    within the ZIP file. We compute the HMAC digest of this member. Then, we assert
    that the archive comment matches the hex digest of the selected member. If the
    condition in the `assert` statement is false and the HMAC keys don't match, then
    this will raise an exception and the script will stop running. This will also
    mean that our message was compromised. If the condition in the `assert` statement
    is true, it executes silently.
  prefs: []
  type: TYPE_NORMAL
- en: If the assertion is true, we can extract the image file to a spot in the `/tmp`
    directory. From here, we can open the file and use the `steg_extract()` function
    to recover the message hidden in the image. Windows agents can use the `os` module
    to locate a temporary directory. The value of `os.environ['TEMP']` will name a
    suitable temporary directory.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've got the message, we can remove the temporary file.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, we need to complete the function, `steg_extract()`, that implements
    our steganographic decoding. See the *Some approaches to steganography* section
    for details on how this needs to work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to work on a computer's filesystem and common
    file formats. We looked in depth at image files. We also saw how Pillow allows
    us to apply operations such as cropping, filtering, and enhancing to an image.
  prefs: []
  type: TYPE_NORMAL
- en: We covered Python bit-fiddling operators such as `&`, `|`, `<<`, and `>>`. These
    operators work on the individual bits of an integer value. Something like `bin(0b0100
    & 0b1100)` will show how the answer is based on doing an `AND` operation on each
    individual bit of the number.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how we can apply steganographic techniques to conceal a message
    in an image file. This involved both byte and bit manipulation in Python.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at incorporating geolocation information with
    our other information gathering. We know that pictures can be tied to locations,
    so geocoding and reverse geocoding are essential. We'll also look at ways to read
    more complex online datasets and combine multiple web services into a composite
    application.
  prefs: []
  type: TYPE_NORMAL
