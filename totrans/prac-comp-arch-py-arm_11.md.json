["```py\n\ncd ..         # This means change directory to parent (the node above)\ncd home\ncd pi\ncd Desktop\n```", "```py\n\nsudo apt-get update        # Downloads the packages you have in your configuration source files\nsudo apt-get upgrade       # Updates the packages\n```", "```py\n\nsudo shutdown -r now\n```", "```py\nsudo reboot\n```", "```py\n\n.section .text       @ .text indicates a region of code (not data)\n.global _start       @ .global indicates that this label is visible to external objects\n_start:              @ _start is the entry point to this program\n   mov r0,#1         @ Load r0 with 1\\. mov copies an 8-bit value into a register\n   mov r1,#2         @ Load r1 with 2\n   add r3,r0,r1      @ Add r0 and r1 and put result in r3\n.end                 @ .end indicates the end of the program. It is optional\n```", "```py\n\nas –o myProg.o myProg.s\nld –o myProg myProg.o\n```", "```py\n\nas -g –o myProg.o myProg.s       # Assemble myProg.s Note the -g parameter\nld –o myProg myProg.o            # Link myProg.o to create source code myProg\n```", "```py\ngdb myProg                       # Run the debugger\n```", "```py\n\n       mov   r0,#0           @ Clear the total in r0\n       mov   r1,#4           @ FOR i = 1 to 4 (count down)\nNext:  mul   r2,r1,r1        /* Square a number */\n       mla   r0,r2,r1,r0     @ Cube the number and add to total\n       subs  r1,r1,#1        @ Decrement counter (and set condition flags)\n       bne   Next            @ END FOR (branch back on count not zero)\n```", "```py\n\n        .global _start        @ Provide entry point\n_start: mov   r0,#0           @ Clear the total in r0\n        mov   r1,#10          @ FOR i = 1 to 10 (count down)\nNext:   mul   r2,r1,r1        /* Square a number. Note the C style comment */\n        mla   r0,r2,r1,r0     @ Cube the number and add to total\n        subs  r1,r1,#1        @ Decrement counter (set condition flags)\n        bne   Next            @ END FOR (branch back on count not zero)\n        mov   r7,#1           @ r7 contains 1 to indicate a leave request\n        svc   #0              @ Call operating system to exit this code\n```", "```py\n\npi@raspberrypi:~ $ cd Desktop                     # Change to Desktop directory\npi@raspberrypi:~/Desktop $ as -g -o a4.o a4.s     # Assemble the program a4.s\npi@raspberrypi:~/Desktop $ ld -o a4 a4.o          # Now link it to create executable\npi@raspberrypi:~/Desktop $ ./a4 ; echo $?         # Run the executable program a4\n```", "```py\n\npi@raspberrypi:~/Desktop $ gdb a4\nReading symbols from a4...done.\n(gdb) b _start\nBreakpoint 1 at 0x10074: file a4.s, line 14.\n```", "```py\n\n(gdb) run\nStarting program: /home/pi/Desktop/a4\nBreakpoint 1, _start () at a4.s:14\n14    _start: mov r0,#4             @ Enter here (first instruction)\n```", "```py\n\n(gdb) i r\nr0             0x0                 0\nr1             0x0                 0\nr2             0x0                 0\nr3             0x0                 0\nr4             0x0                 0\nr5             0x0                 0\nr6             0x0                 0\nr7             0x0                 0\nr8             0x0                 0\nr9             0x0                 0\nr10            0x0                 0\nr11            0x0                 0\nr12            0x0                 0\nsp             0xbefff390          0xbefff390\nlr             0x0                 0\npc             0x10074             0x10074 <_start>\ncpsr           0x10                16\n```", "```py\nfpscr          0x0                 0\n```", "```py\n\n(gdb) si 1\n15            mov r1,#9\n(gdb)\n16            add r2,r0,r1\n(gdb)\n17            sub r3,r2,#3\n(gdb)\n18            ldr r4,=Alan3         @ Load an address into r4\n(gdb)\n19            ldr r5,[r4]           @ And pick up a word from memory\n```", "```py\n\n(gdb) i r\nr0             0x4                 4\nr1             0x9                 9\nr2             0xd                 13 Note: r2 is expressed in hex and decimal\nr3             0xa                 10\nr4             0x200a0             131232\nr5             0x0                 0\npc             0x10088             0x10088 <_start+20> Note: 20 bytes from start\n```", "```py\n\n(gdb) si 1\n21            mov r7,#1             @ Prepare to exit\n(gdb)\n22            svc 0                 @ Go\n(gdb)\n```", "```py\n[Inferior 1 (process 1163) exited with code 04]\n```", "```py\n\n                                @ Test function calls and memory access\n         .text                  @ Program (code) area\n         .global  _start        @ Provide entry point and make it known to linker\n         .equ     v1,0xAB       @ Test equate directive\n_start:   mov     r0,#23        @ Just three dummy operations for debugging\n          mov     r1,#v1        @ ARM assembler uses # to indicate a literal\n          add     r2,r0,r1\n```", "```py\n\n          ldr     r1, =banner   @ Test display function (this is a pseudo-instruction)\n          mov     r2,#15        @ Number of characters to print 13 plus two newlines)\n          mov     r0,#1         @ Tell the OS we want to print on console display\n          mov     r7,#4         @ Tell the OS we want to perform a print operation\n```", "```py\n          svc     0             @ Call the operating system to do the printing\n```", "```py\n\n          adr     r3,v3              @ Load address of v3 into register r3 (a pseudo-instruction)\n          ldr     r4,[r3]            @ Read contents of v3 in memory\n                                     @ Read from memory, increment and store in next location\n          ldr     r0,adr_dat1        @ r0 is a pointer to dat1 in memory\n          ldr     r1,[r0]            @ Load r1 with the contents of dat1\n          add     r2,r1,#1           @ Add 1 to dat1 and put in r2\n          add     r3,r0,#4           @ Use r3 to point to next memory location after dat1\n          str     r2,[r3]            @ Store new data in location after dat1\n```", "```py\n\n          mov     r0,#0              @ Exit status code (0 indicates OK)\n          mov     r7,#1              @ Tell the OS we want to return from this program\n          svc     0                  @ Call the operating system to return\n```", "```py\n\nadr_dat1: .word   dat1               @ Generate an address for dat1 in the memory area\nv2:       .word   0xFACE             @ Dummy data\nbanner:   .ascii \"\\nTest printing\\n\" @ String to print. Note newlines \"\\n\"\n                                     @ This string has 15 characters (13 ASCII two newlines)\n          .balign 4                  @ Align data (0 inserted because the string is 15 chars)\nv3:       .word   0x1111             @ Dummy test data\n          .space  4,0xAB             @ Reserve 8 bytes of storage and fill with 0xAB\n          .word   0x2222\n          .data                      @ Data segment\ntest:     .word 0xbbbb\ndat1:     .word 0x1234\n          .end                       @ End of this program\n```", "```py\n\ndat1:     .word 0x1234   @ The value 0x1234 is stored in memory at address dat1\n```", "```py\n\nadr_dat1: .word   dat1\n```", "```py\n\npi@raspberrypi:~ $ cd Desktop\npi@raspberrypi:~/Desktop $ as -g -o t1a.o t1a.s\npi@raspberrypi:~/Desktop $ ld -o t1a t1a.o\npi@raspberrypi:~/Desktop $ gdb\nGNU gdb (Raspbian 8.2.1-2) 8.2.1\n(gdb) file t1a\nReading symbols from t1a...done.\n(gdb) b _start\nBreakpoint 1 at 0x10074: file t1a.s, line 7.\n(gdb) r 1\nStarting program: /home/pi/Desktop/t1a 1\nBreakpoint 1, _start () at t1a.s:7\n7    _start: mov     r0,#23        @ Just three dummy operations for debugging\n(gdb) si 1\n8            mov     r1,#v1\n9            add     r2,r0,r1\n11           ldr     r1,=banner   @ Test display function (r1 has address of a string)\n12           mov     r2,#15        @ Number of characters to print 13 plus two newlines)\n13           mov     r0,#1         @ Tell the OS we want to print on console display\n14           mov     r7,#4         @ Tell the OS we want to perform a print operation\n15           svc     0             @ Call the operating system to do the printing\nTest printing\n17           adr     r3,v3         @ Load address of v3\n18           ldr     r4,[r3]       @ Read its contents in memory\n21           ldr     r0,adr_dat1   @ r0 is a pointer to dat1 in memory\n22           ldr     r1,[r0]       @ Load r1 with the contents of data1\n23           add     r2,r1,#1      @ Add 1 to dat1 and put in r2\n24           add     r3,r0,#4      @ Use r3 to point to next memory location after dat1\n25           str     r2,[r3]       @ Store new data in location after dat1\n(gdb) i r r0 r1 r2 r3\nr0           0x200e8             131304\nr1           0x1234              4660\nr2           0x1235              4661\nr3           0x200ec             131308\n(gdb) si 1\n28          mov    r0,#0           @ Exit status code (indicates OK)\n29          mov    r7,#1           @ Tell the OS we want to return from this program\n30          svc    0               @ Call the operating system to return\n(gdb) x/2xw 0x200e8\n0x200e8:    0x00001234    0x00001235\n(gdb) si 1\n[Inferior 1 (process 7601) exited normally]\n```", "```py\n\nx/2xw 0x2208    Read the contents of two memory locations\n```", "```py\n\n      cmp   r0,#'A'            @ Was it a letter 'A'?\n```", "```py\n\n      .equ  Tuesday, 2\n```", "```py\n\n      .equ    Value1,12        @ Associate name Value1 with 12\n      .equ    Value2,45        @ Associate name Value2 with 45\n      .word   Table,Value1     @ Store the 32-bit word 12 in memory at address Table\n      .word   Value2           @ Store the word 45 in memory\n      .word   Value2 + 14      @ Store  45 + 14 = 59 in memory (you can use expressions)\n```", "```py\n\nQ1:    .byte        25                  @ Store the byte 25 in memory\nQ2:    .byte        42                  @ Store the byte 42 in memory\nTx2:   .hword       12342               @ Store the 16-bit halfword 12,342 in memory\n```", "```py\n\nMess1: .ascii    \"This is message 1\"    @ Store string memory\nMess2: .asciz    \"This is message 2\"    @ Store string followed by 0\n       .balign  4                       @ Align code on word boundary\n```", "```py\n\n        .global  _start                 @ Tell the linker where we start from\n        .text                           @ This is a text (code) segment\n_start: mov     r0,#XX                  @ Load r0 with 5 (i.e., XX)\n        mov     r1,#P1                  @ Load r1 with P1 which is equated to 0x12 or 18 decimal\n        add     r2,r0,r1                @ Just a dummy instruction\n        add     r3,r2,#YY               @ Test equate to ASCII byte (should be 0x42 for 'B')\n        adr     r4,test                 @ Let's load an address (i.e., location of variable test)\n        ldr     r5,[r4]                 @ Now, access that variable which should be 0xBB)\nAgain:  b       Again                   @ Eternal endless loop (terminate here)\n       .equ     XX,5                    @ Equate XX to 5\n       .equ     P1,0x12                 @ Equate P1 to 0x12\n       .equ     YY,'B'                  @ Equate YY to the ASCII value for 'B'\n       .ascii   \"Hello\"                 @ Store the ASCII byte string \"Hello\"\n       .balign  4                       @ Ensure code is on a 32-bit word boundary\n       .ascii   \"Hello\"                 @ Store the ASCII byte string \"Hello\"\n       .byte    0xAA                    @ Store the byte 0xAA in memory\ntest:  .byte    0xBB                    @ Store the byte 0xBB in memory\n       .balign  2                       @ Ensure code is on a 16-bit halfword boundary\n       .hword   0xABCD                  @ Store the 16-bit halfword 0xABCD in memory\nlast:  .word    0x12345678              @ Store a 32-bit hex value in memory\n       .end\n```", "```py\n\npi@raspberrypi:~ $ cd Desktop\npi@raspberrypi:~/Desktop $ as -g -o labels.o labels.s\npi@raspberrypi:~/Desktop $ ld -o labels labels.o\npi@raspberrypi:~/Desktop $ gdb labels\nGNU gdb (Raspbian 8.2.1-2) 8.2.1\nReading symbols from labels...done.\n(gdb) b _start\nBreakpoint 1 at 0x10054: file labels.s, line 3.\n(gdb) run 1\nStarting program: /home/pi/Desktop/labels 1\nBreakpoint 1, _start () at labels.s:3\n3    _start: mov     r0,#XX             @ Load r0 with 5 (i.e., XX)\n(gdb) si 1\n4            mov     r1,#P1             @ Load r1 with 0x12 (i.e., P1)\n5            add     r2,r0,r1           @ Dummy instruction (r2 is 5+0x12=0x17)\n6            add     r3,r2,#YY          @ Dummy instruction (r3 is 0x17+0x42=0x59)\n7            adr     r4,test\n8            ldr     r5,[r4]\nAgain () at labels.s:9\n9    Again:  b       Again              @ Eternal endless loop (enter control-C to exit)\n```", "```py\n\n(gdb) i r\nr0             0x5                 5\nr1             0x12                18\nr2             0x17                23\nr3             0x59                89 Note 0x59 = 0x17 + 0x42\nr4             0x1007e             65662\nr5             0xabcd00bb          2882339003\npc             0x1006c Current pc     0x1006c <Again>\n```", "```py\n\n(gdb) x/7xw 0x1006c\n0x1006c <Again>:    0xeafffffe 0x6c6c6548 0x0000006f 0x6c6c6548\n0x1007c <Again+16>: 0x00bbaa6f 0x5678abcd 0x00001234\n```", "```py\n\n(gdb) x/28xb 0x1006c\n0x1006c <Again>:      0xfe   0xff   0xff   0xea   0x48   0x65   0x6c   0x6c\n0x10074 <Again+8>:    0x6f   0x00   0x00   0x00   0x48   0x65   0x6c   0x6c\n0x1007c <Again+16>:   0x6f   0xaa   0xbb   0x00   0xcd   0xab   0x78   0x56\n0x10084 <last+2>:     0x34   0x12   0x00   0x00\n```", "```py\n\n000000010070     48             ASCII H start of the sequence Hello\n000000000071     65             ASCII e\n000000000072     6C             ASCII l\n000000000073     6C             ASCII l\n000000000074     6F             ASCII o\n000000000075     00             Padded zero due to align\n000000000076     00             Padded zero due to align\n000000000077     0              Padded zero due to align\n000000010078     48             ASCII H\n000000000079     65             ASCII e\n00000000007A     6C             ASCII l\n00000000007B     6C             ASCII l\n00000000007C     6C             ASCII o\n00000000007D     0xAA           Byte 0xAA\n00000000007E     0xBB           Byte 0xBB\n00000000007F     00             Padded zero due to align\n000000000080     0xAB           First byte of 0xABCD\n000000000081     0xCD           Second byte of 0xABCD\n```", "```py\n\n          adr    r0,someData    @ Setup r1 to point to someData in memory\n          ldr    r1,[r0]        @ Read someData using the pointer in r0\n          .        .\nsomeData: .word  0x12345678     @ Here's the data\n```", "```py\n\n      ldr r2, =0x12345678       @ Load a 32-bit literal into r2\n```", "```py\n\n        .text\n        .global _start\n_start: ldr    r0,=0x12345678   @ Load r0 with a 32-bit constant\n        adr    r1,Table1        @ Load r1 with the address of Table1\n        adr    r2,Table2        @ Load r2 with the address of Table2\n        ldr    r3,[r1]          @ Load r3 with data in Table1\n        ldr    r4,[r2]          @ Load r4 with data in Table2\n        ldr    r5, =0xAAAAAAAA  @ Load r5 with a 32-bit constant\nwait:   mov    r0,#0            @ Goodbye message\n        mov    r7,#1            @ Goodbye command in r7\n        svc    0                @ Call operating system to return\nTable1: .word  0xABCDDCBA       @ Dummy data\nTable2: .word  0xFFFFFFFF\n```", "```py\n\nr0             0x0                 0\nr1             0x10078             65656\nr2             0x1007c             65660\nr3             0xabcddcba          2882395322\nr4             0xffffffff          4294967295\nr5             0xaaaaaaaa          2863311530\npc             0x10074             0x10074 <wait+8>\n```", "```py\n\nDump of assembler code from 0x10054 to 0x10086:\n   0x00010054 <_start+0>:    ldr    r0, [pc, #36]    ; 0x10080 <Table2+4>\n   0x00010058 <_start+4>:    add    r1, pc, #24\n   0x0001005c <_start+8>:    add    r2, pc, #24\n   0x00010060 <_start+12>:   ldr    r3, [r1]\n   0x00010064 <_start+16>:   ldr    r4, [r2]\n```", "```py\n   0x00010068 <_start+20>:   ldr    r5, [pc, #20]    ; 0x10084 <Table2+8>\n```", "```py\n\n(gdb) x/6xw 0x10080\n0x10080 <Table2+4>:    0x12345678    0xaaaaaaaa    0x00001141    0x61656100\n0x10090:               0x01006962    0x00000007\n```", "```py\n\n        .global _start\n_start: adr     r0,mike        @ r0 points to ASCII string \"Mike\"\n        ldr     r1,[r0]        @ Read the string into r1\n        ldrb    r2,[r0,#3]     @ Read byte 3 of \"Mike\"\n        adr     r3,test        @ Point to data value 0x2468FACE in memory\n        ldrb    r4,[r3]        @ Read single byte of test. Pointer in r0\n        ldrb    r5,[r3,#1]     @ Read single byte 1 offset\n        ldrh    r6,[r3]        @ Read halfword of test\n        ldr     r7,a_adr       @ r7 points at address of testRW\n        ldr     r8,=0x12345678 @ r8 loaded with 32-bit literal 0x12345678\n        str     r8,[r7]        @ Store r8 in read/write memory at testRW\n        ldrh    r9,[r7]        @ Read halfword of testRW\n        mvn     r10,r9         @ Logically negate r9\n        strh    r10,[r7,#4]    @ Store halfword in next word after testRW\n        nop                    @ Just a place to stop\n        mov     r0,#1          @ Raspberry Pi exit sequence\n        mov     r7,#7\n        svc     0\nmike:   .ascii  \"Mike\"         @ Store string as 4 ASCII characters\ntest:   .word   0x2468FACE     @ Save a word in memory\na_adr:  .word   testRW         @ Pointer to data in read/write memory\n        .data                  @ Data section in read/write memory\nnines:  .word   0x99999999     @ 0x99999999 Just dummy data\ntestRW: .word   0xFFFFFFFF     @\n        .word   0x77777777     @ More dummy data\n        .word   0xBBBBBBBB     @ More dummy data\n```", "```py\n        .end\n```", "```py\n\nalan@raspberrypi:~/Desktop $ as g o endian.o endian.s\nalan@raspberrypi:~/Desktop $ ld o endian endian.o\nalan@raspberrypi:~/Desktop $ gdb endian\nGNU gdb (Raspbian 10.11.7) 10.1.90.20210103git\n```", "```py\n\n(gdb) b _start\nBreakpoint 1 at 0x10074: file endian.s, line 2.\n(gdb) r\nStarting program: /home/alan/Desktop/endian\nBreakpoint 1, _start () at endian.s:2\n2    _start: adr     r0,mike   @ r0 points to ASCII string \"Mike\"\n```", "```py\n\n(gdb) disassemble\nDump of assembler code for function _start:\n=> 0x00010074 <+0>:     add    r0, pc, #60    ; 0x3c\n   0x00010078 <+4>:     ldr    r1, [r0]\n   0x0001007c <+8>:     ldrb   r2, [r0, #3]\n   0x00010080 <+12>:    add    r3, pc, #52    ; 0x34\n   0x00010084 <+16>:    ldrb   r4, [r3]\n   0x00010088 <+20>:    ldrb   r5, [r3, #1]\n   0x0001008c <+24>:    ldrh   r6, [r3]\n   0x00010090 <+28>:    ldr    r7, [pc, #40]   ; 0x100c0 <a_adr>\n   0x00010094 <+32>:    ldr    r8, [pc, #40]   ; 0x100c4 <a_adr+4>\n   0x00010098 <+36>:    str    r8, [r7]\n   0x0001009c <+40>:    ldrh   r9, [r7]\n   0x000100a0 <+44>:    mvn    r10, r9\n   0x000100a4 <+48>:    strh   r10, [r7, #4]\n   0x000100a8 <+52>:    nop                    ; (mov r0, r0)\n   0x000100ac <+56>:    mov    r0, #1\n   0x000100b0 <+60>:    mov    r7, #7\n   0x000100b4 <+64>:    svc    0x00000000\n```", "```py\nEnd of assembler dump.\n```", "```py\n\n(gdb) x/8wx 0x100b4\n0x100b4 <_start+64>:    0xef000000    0x656b694d    0x2468face    0x000200cc\n0x100c4 <a_adr+4>:      0x12345678    0x99999999    0xffffffff    0x77777777\n```", "```py\n\n(gdb) si 1\n3          ldr   r1,[r0]       @ Read the string into r1\n4          ldrb  r2,[r0,#3]    @ Read byte 3 of \"Mike\"\n6          adr   r3,test       @ Point to data value 0x2468FACE in memory\n```", "```py\n\n(gdb) i r\nr0             0x100b8             65720\nr1             0x656b694d          1701538125\nr2             0x65                101\nr3             0x0                 0\nr4             0x0                 0\nsp             0x7efff360          0x7efff360\nlr             0x0                 0\n```", "```py\npc             0x10080             0x10080 <_start+12>\n```", "```py\n\n(gdb) si 1\n7          ldrb    r4,[r3]          @ Read byte of test Pointer in r0\n8          ldrb    r5,[r3,#1]       @ Read single byte 1 offset\n9          ldrh    r6,[r3]          @ Read halfword of test\n11         ldr     r7,a_adr         @ r7 points at address of testRW\n12         ldr     r8,=0x12345678   @ r8 loaded with 32-bit 0x12345678\n(gdb) i r\nr0             0x100b8             65720\nr1             0x656b694d          1701538125\nr2             0x65                101\nr3             0x100bc             65724\nr4             0xce                206\nr5             0xfa                250\nr6             0xface              64206\nr7             0x200cc             131276\nsp             0x7efff360          0x7efff360\nlr             0x0                 0\npc             0x10094             0x10094 <_start+32>\n```", "```py\n\n(gdb) x/4xw 0x200c8\n0x200c8:    0x99999999    0xffffffff    0x77777777    0xbbbbbbbb\n```", "```py\n\n(gdb) si 1\n13          str    r8,[r7]       @ Store r8 in read/write memory at testRW\n14          ldrh   r9,[r7]       @ Read halfword of testRW\n15          mvn    r10,r9        @ Logically negate r9\n16          strh   r10,[r7,#4]   @ Store halfword in next word after testRW\n```", "```py\n17          nop                  @ Just a place to stop\n```", "```py\n\n(gdb) i r\nr0             0x100b8             65720\nr1             0x656b694d          1701538125\nr2             0x65                101\nr3             0x100bc             65724\nr4             0xce                206\nr5             0xfa                250\nr6             0xface              64206\nr7             0x200cc             131276\nr8             0x12345678          305419896\nr9             0x5678              22136\nr10            0xffffa987          4294945159\nsp             0x7efff360          0x7efff360\nlr             0x0                 0\npc             0x100a8             0x100a8 <_start+52>\n```", "```py\n\n(gdb) x/4xw 0x200c8\n0x200c8:    0x99999999    0x12345678    0x7777a987    0xbbbbbbbb\n```", "```py\n\n         .text           @ Code section\n         .global _start\n_start:  ldr r1,=xxx     @ Point to data xxx\n         ldr r2,[r1]     @ Read the data\n         adr r3,adr_xxx  @ Point to the address of the address of xxx\n         ldr r4,[r3]     @ Point to the data xxx\n         ldr r5,[r4]     @ Read the value of xxx\n         add r5,r5,#1    @ Increment the data\n         str r5,[r4]     @ Change xxx in memory\n         mov r0,#0       @ Exit procedure\n         mov r7,#1\n         svc 0\nadr_xxx: .word           @ Pointer to data xxx\n         .data           @ Data section\nxxx:     .word  0xABCD   @ Initialize variable xxx\n         .end\n```"]