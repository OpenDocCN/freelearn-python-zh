<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Unit Testing with Doctest"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Unit Testing with Doctest</h1></div></div></div><p>
<span class="emphasis"><em>Okay, so we've talked about what doctest does, and how to make it behave the way we want. We've talked about testing things with doctest too. What's left to talk about in this chapter, then? In this chapter, we'll be talking about the programming discipline called Unit testing. We'll still be using doctest, but this time the focus is on what you're doing and why, rather than on the details of how to do it.</em></span>
</p><p>In this chapter we shall:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discuss in detail what Unit testing is</li><li class="listitem" style="list-style-type: disc">Talk about the ways in which Unit testing helps various stages of development</li><li class="listitem" style="list-style-type: disc">Work with examples that illustrate Unit testing and its advantages</li></ul></div><p>So, let's get on with it!</p><div class="section" title="What is Unit testing and what it is not?"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>What is Unit testing and what it is not?</h1></div></div></div><a class="indexterm" id="id78"/><p>The title of this section, begs another question: "Why do I care?" One answer is that Unit testing is a best practice that has been evolving toward its current form over most of the time that programming has existed. Another answer is that the core principles of Unit testing are just good sense; it might actually be a little embarrassing to our community as a whole that it took us so long to recognize them.</p><p>Alright, so what is Unit testing? In its most fundamental form, Unit testing can be defined as testing the smallest meaningful pieces of code (such pieces are called units), in such a way that each piece's success or failure depends only on itself. For the most part, we've been following this principle already.</p><p>There's a reason for each part of this definition: we test the smallest meaningful pieces of code because, when a test fails, we want that failure to tell where the problem is us as specifically as possible. We make each test independent because we don't want a test to make any other test succeed, when it should have failed; or fail when it should have succeeded. When tests aren't independent, you can't trust them to tell you what you need to know.</p><p>Traditionally, automated testing is associated with Unit testing. Automated testing makes it fast and easy to run unit tests, which tend to be amenable to automation. We'll certainly make heavy use of automated testing with doctest and later with tools such as unittest and Nose as well.</p><p>Any test that involves more than one unit is automatically not a unit test. That matters <a class="indexterm" id="id79"/>because the results of such tests tend to be confusing. The effects of the different units get tangled together, with the end result that not only do you not know where the problem is (is the mistake in this piece of code, or is it just responding correctly to bad input from some other piece of code?), you're also often unsure exactly what the problem is this output is wrong, but how does each unit contribute to the error? Empirical scientists must perform experiments that check only one hypothesis at a time, whether the subject at hand is chemistry, physics, or the behavior of a body of program code.</p></div></div>
<div class="section" title="Time for action &#x2013; identifying units"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Time for action – identifying units</h1></div></div></div><a class="indexterm" id="id80"/><p>Imagine that you're responsible for testing the following code:</p><div class="informalexample"><pre class="programlisting">class testable:
    def method1(self, number):
        number += 4
        number **= 0.5
        number *= 7
        return number

    def method2(self, number):
        return ((number * 2) ** 1.27) * 0.3

    def method3(self, number):
        return self.method1(number) + self.method2(number)

    def method4(self):
        return 1.713 * self.method3(id(self))</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In this example, what are the units? Is the whole class a single unit, or is each method a separate unit. How about each statement, or each expression? Keep in mind that the definition of a unit is somewhat subjective (although never bigger than a single class), and make your own decision.</li><li class="listitem">Think about what you chose. What would the consequences have been if you chose otherwise? For example, if you chose to think of each method as a unit, what would be different if you chose to treat the whole class as a unit?</li><li class="listitem">Consider <code class="literal">method4</code>. Its result depends on all of the other methods working correctly. On top of that, it depends on something that changes from one test run to another, the unique ID of the <code class="literal">self</code> object. Is it even possible to treat <code class="literal">method4</code> as a unit in a self-contained test? If we could change anything except <code class="literal">method4</code>, what would we have to change to enable <code class="literal">method4</code> to run in a <a class="indexterm" id="id81"/>self-contained test and produce a predictable result?</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>By answering those three questions, you thought about some of the deeper aspects of unit testing.</p><p>The question of what constitutes a unit, is fundamental to how you organize your tests. The capabilities of the language affects this choice. C++ and Java make it difficult or impossible to treat methods as units, for example, so in those languages each class is usually treated as a single unit. C, on the other hand, doesn't support classes as language features at all, so the obvious choice of unit is the function. Python is flexible enough that either classes or methods could be considered units, and of course it has stand-alone functions as well, which are also natural to think of as units. Python can't easily handle individual statements within a function or method as units, because they don't exist as separate objects when the test runs. They're all lumped together into a single code object that's part of the function.</p><p>The consequences of your choice of unit are far-reaching. The smaller the units are, the more useful the tests tend to be, because they narrow down the location and nature of bugs more quickly. For example, one of the consequences of choosing to treat the testable class as a single unit is that tests of the class will fail if there is a mistake in any of the methods. That tells you that there's a mistake in testable, but not (for example) that it's in <code class="literal">method2</code>. On the other hand, there is a certain amount of rigmarole involved in treating <code class="literal">method4</code> and its like as units, to such an extent that the next chapter of the book is dedicated to dealing with such situations. Even so, I recommend using methods and functions as units most of the time, because it pays off in the long run.</p><p>In answering the third question, you probably discovered that the functions <code class="literal">id</code> and <code class="literal">self.method3</code> would need to have different definitions, definitions that produced a predictable result, and did so without invoking code in any of the other units. In Python, replacing the real function with such stand-ins is fairly easy to do in an ad hoc manner, but we'll be discussing a more structured approach in the next chapter.</p></div><div class="section" title="Pop quiz – understanding units"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Pop quiz – understanding units</h2></div></div></div><p>Consider this code and then try to answer the questions:</p><div class="informalexample"><pre class="programlisting">class class_one:
    def __init__(self, arg1, arg2):
        self.arg1 = int(arg1)
        self.arg2 = arg2

    def method1(self, x):
        return x * self.arg1

    def method2(self, x):
        return self.method1(self.arg2) * x</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Assuming that methods are units, how many units exist in the above code?</li><li class="listitem">Which units make assumptions about the correct operation of other units? In other words, which units are not independent?</li><li class="listitem">What would you need to do to create a test for <code class="literal">method2</code> that was independent of other units?</li></ol></div></div></div>
<div class="section" title="Unit testing throughout the development process"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Unit testing throughout the development process</h1></div></div></div><a class="indexterm" id="id82"/><p>We'll walk through the development of a single class, treating it with all the dignity of a real project. We'll be strictly careful to integrate unit testing into every phase of the project. This may seem silly at times, but just play along. There's a lot to learn from the experience.</p><p>The example we'll be working with is a PID controller. The basic idea is that a PID controller is a feedback loop for controlling some piece of real-world hardware. It takes input from a sensor that can measure some property of the hardware, and generates a control signal that adjusts that property toward some desired state. The position of a robot arm in a factory might be controlled by a PID controller.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>If you want to know more about <code class="literal">PID</code> controllers, the Internet is rife with information. The Wikipedia entry is a good place to start: <a class="ulink" href="http://en.wikipedia.org/wiki/PID_controller">http://en.wikipedia.org/wiki/PID_controller</a>.</p></div></div><div class="section" title="Design phase"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Design phase</h2></div></div></div><a class="indexterm" id="id83"/><a class="indexterm" id="id84"/><p>Our notional client comes to us with the following (rather sparse) specification:</p><div class="informalexample"><pre class="programlisting">We want a class that implements a PID controller for a single variable. The measurement, setpoint, and output should all be real numbers.

We need to be able to adjust the setpoint at runtime, but we want it to have a memory, so that we can easily return to the previous setpoint.<a class="indexterm" id="id85"/>
<a class="indexterm" id="id86"/>
</pre></div></div></div>
<div class="section" title="Time for action &#x2013; unit testing during design"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Time for action – unit testing during design</h1></div></div></div><a class="indexterm" id="id87"/><p>Time to make that specification a bit more formal—and complete—by writing unit tests that describe the desired behavior.<a class="indexterm" id="id88"/>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to write a test that describes the PID constructor. After checking our references, we determine that a PID controller is defined by three <code class="literal">gains</code>, and a <code class="literal">setpoint</code>. The controller has three components: proportional, integral and derivative (hence the name PID). Each <code class="literal">gain</code> is a number that determines how much one of the three parts of the controller has on the final result. The <code class="literal">setpoint</code> determines what the goal of the controller is; in other words, to where it's trying to move the controlled variable. Looking at all that, we decide that the constructor should just store the <code class="literal">gains</code> and the <code class="literal">setpoint</code>, along with initializing some internal state that we know we'll need due to reading up on the workings of a PID controller:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import pid

&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0)

&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[0.0]
&gt;&gt;&gt; controller.previous_time is None
True
&gt;&gt;&gt; controller.previous_error
0.0
&gt;&gt;&gt; controller.integrated_error
0.0</pre></div></li><li class="listitem">We need to write tests that describe measurement processing. This is the controller in action, taking a measured value as its input and producing a control signal that should smoothly move the measured variable to the <code class="literal">setpoint</code>. For this to work correctly, we need to be able to control what the controller sees as the current time. After that, we plug our test input values into the math that defines a PID controller, along with the <code class="literal">gains</code>, to figure out what the correct outputs would be:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import time
&gt;&gt;&gt; real_time = time.time
&gt;&gt;&gt; time.time = (float(x) for x in xrange(1, 1000)).next
&gt;&gt;&gt; pid = reload(pid)
&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0)
&gt;&gt;&gt; controller.measure(12)
-6.0
&gt;&gt;&gt; controller.measure(6)
-3.0
&gt;&gt;&gt; controller.measure(3)
-4.5
&gt;&gt;&gt; controller.measure(-1.5)
-0.75
&gt;&gt;&gt; controller.measure(-2.25)
-1.125
&gt;&gt;&gt; time.time = real_time</pre></div></li><li class="listitem"><a class="indexterm" id="id89"/><a class="indexterm" id="id90"/>We need to write tests that describe <code class="literal">setpoint</code> handling. Our client asked for a <code class="literal">setpoint</code> stack, so we write tests that check such stack behavior. Writing code that uses this stack behavior brings to our attention that fact that a PID controller with no <code class="literal">setpoint</code> is not a meaningful entity, so we add a test that checks that the PID class rejects that situation by raising an exception.<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; pid = reload(pid)
&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0)
	
&gt;&gt;&gt; controller.push_setpoint(7)
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0]

&gt;&gt;&gt; controller.push_setpoint(8.5)
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0, 8.5]

&gt;&gt;&gt; controller.pop_setpoint()
8.5
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0]

&gt;&gt;&gt; controller.pop_setpoint()
7.0
&gt;&gt;&gt; controller.setpoint
[0.0]

&gt;&gt;&gt; controller.pop_setpoint()
Traceback (most recent call last):
ValueError: PID controller must have a setpoint<a class="indexterm" id="id91"/>
<a class="indexterm" id="id92"/>
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>Our clients gave us a pretty good initial specification, but it left a lot of details to assumption. By writing these tests, we've codified exactly what our goal is. Writing the tests forced us to make our assumptions explicit. Additionally, we've gotten a chance to use the object, which gives us an understanding of it that would otherwise be hard to get at this stage.</p><p>Normally we'd place the doctests in the same file as the specification, and in fact that's what you'll find in the book's code archive. In the book format, we used the specification text as the description for each step of the example.</p><p>You could ask how many tests we should write for each piece of the specification. After all, each test is for certain specific input values, so when code passes it, all it proves is that the code produces the right results for that specific input. The code could conceivably do something entirely wrong, and still pass the test. The fact is that it's usually a safe assumption that the code you'll be testing was supposed to do the right thing, and so a single test for each specified property fairly well distinguishes between working and non-working code. Add to that tests for any boundaries specified—for "The X input may be between the values 1 and 7, inclusive" you might add tests for X values of 0.9 and 7.1 to make sure they weren't accepted—and you're doing fine.</p><p>There were a couple of tricks we pulled to make the tests repeatable and independent. In every test after the first, we called the <code class="literal">reload</code> function on the <code class="literal">pid</code> module, to reload it from the disk. That has the effect of resetting anything that might have changed in the module, and causes it to re-import any modules that it depends on. That latter effect is particularly important, since in the tests of measure, we replaced <code class="literal">time.time</code> with a dummy function. We want to be sure that the <code class="literal">pid</code> module uses the dummy time function, so we reload the <code class="literal">pid</code> module. If the real time function is used instead of the dummy, the test won't be useful, because there will be only one time in all of history at which it would succeed. Tests need to be repeatable.</p><p>The dummy time function is created by making an iterator that counts through the integers from 1 to 999 (as floating point values), and binding <code class="literal">time.time</code> to that iterator's <code class="literal">next</code> method. Once we were done with the time-dependent tests, we replaced the original <code class="literal">time.time</code>.</p><p>Right now, we have tests for a module that doesn't exist. That's good! Writing the tests was easier than writing the module will be, and it gives us a stepping stone toward getting the module right, quickly and easily. As a general rule, you always want to have tests ready before the code that they test is written.</p></div><div class="section" title="Pop quiz – unit testing during design"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Pop quiz – unit testing during design</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><a class="indexterm" id="id93"/><a class="indexterm" id="id94"/>Why should we care whether tests are independent of each other, when the code they're testing is imaginary and the tests can't even be run?</li><li class="listitem">Why are you, as a programmer, writing tests during this phase? Should this be part of the job of the people writing the specification instead?</li><li class="listitem">Tests at this phase try to make use of code that hasn't been written yet, and so they end up—in a sense—defining that code. What advantages and disadvantages does this have?</li></ol></div></div><div class="section" title="Have a go hero"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Have a go hero</h2></div></div></div><p>Try this a few times on your own: Describe some program or module that you'd enjoy having access to in real life, using normal language. Then go back through it and try writing tests, describing the program or module. Keep an eye out for places where writing the test makes you aware of ambiguities in your prior description, or makes you realize that there's a better way to do something.</p></div><div class="section" title="Development phase"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Development phase</h2></div></div></div><a class="indexterm" id="id95"/><a class="indexterm" id="id96"/><p>With tests in hand, we're ready to write some code. The tests will act as a guide to us, a specification that actively tells us when we get something wrong.<a class="indexterm" id="id97"/>
</p></div></div>
<div class="section" title="Time for action &#x2013; unit testing during development"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Time for action – unit testing during development</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><a class="indexterm" id="id98"/>The first step is to run the tests. Of course, we have a pretty good idea of what's going to happen; they're all going to fail. Still, it's useful to know exactly what the failures are, because those are the things that we need to address by writing code.<div class="mediaobject"><img alt="Time for action – unit testing during development" src="graphics/8846_03_01.jpg"/></div><p>There are many more failing tests after that, but you get the idea.</p></li><li class="listitem">Taking our cue from the tests, and our references on PID controllers, we write the <code class="literal">pid.py</code> module:<div class="informalexample"><pre class="programlisting">from time import time

class PID:
    def __init__(self, P, I, D, setpoint):
        self.gains = (float(P), float(I), float(D))
        self.setpoint = [float(setpoint)]
        self.previous_time = None
        self.previous_error = 0.0
        self.integrated_error = 0.0

    def push_setpoint(self, target):
        self.setpoint.append(float(target))

<a class="indexterm" id="id99"/>
<a class="indexterm" id="id100"/>    def pop_setpoint(self):
        if len(self.setpoint) &gt; 1:
            return self.setpoint.pop()
        raise ValueError('PID controller must have a setpoint')

    def measure(self, value):
        now = time()
        P, I, D = self.gains

        err = value - self.setpoint[-1]

        result = P * err
        if self.previous_time is not None:
            delta = now - self.previous_time
            self.integrated_error +q= err * delta
            result += I * self.integrated_error
            result += D * (err - self.previous_error) / delta

        self.previous_error = err
        self.previous_time = now

        return result</pre></div></li><li class="listitem">Next we run the tests again. We're hoping that they will all pass, but unfortunately the measure method seems to have some sort of bug.<a class="indexterm" id="id101"/><a class="indexterm" id="id102"/><div class="mediaobject"><img alt="Time for action – unit testing during development" src="graphics/8846_03_02.jpg"/></div><p>There are several more reports showing similar things (five tests in total should fail). The measure function is working backwards, returning positive numbers when it should be returning negative, and vice-versa.</p></li><li class="listitem">We know we need to look for a sign error in the measure method, so we don't have too much trouble finding and fixing the bug. The measured value should be subtracted from the setpoint, not the other way around, on the fourth line of the <code class="literal">measure</code> method:<div class="informalexample"><pre class="programlisting">        err = self.setpoint[-1] – value</pre></div><p>After fixing that, we find that all the tests pass.</p></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We used our tests to tell us what needed to be done and when our code was finished. Our first run of the tests gave us a list of things that needed to be written; a to-do list, of sorts. After we wrote some code, we ran the tests again to see if it was doing what we expected, which gave us a new to-do list. We keep on alternating between running the tests and writing code until the tests all passed. When all the tests pass, either we're done, or we need to write more tests.</p><p>Whenever we find a bug that isn't already caught by a test, the right thing to do is to add a test that catches it, and then to fix it. That way, you not only have a fixed bug, you have a test that covers some aspect of the program that wasn't tested before. That test may well catch other bugs in the future, or tell you if you accidentally re-introduced the original bug.</p><p>This "test a little, code a little" style of programming is called <span class="emphasis"><em>Test-Driven Development</em></span>, and you'll find that it's very productive.</p><p>Notice that the pattern in the way the tests failed was immediately apparent. There's no guarantee that this will always be the case, of course, but it's quite common. Combined with the ability to narrow your attention to the specific units that are having problems, debugging is usually a snap.</p><p><a class="indexterm" id="id103"/>Another thing to think about is test isolation. The methods of the <code class="literal">PID</code> class make use of variables stored in <code class="literal">self</code>, which means that in order for the tests to be isolated, we have to make sure that none of the changes to <code class="literal">self</code> variables made by any method propagate to any other method. We did that by just reloading the <code class="literal">pid</code> module and making a new instance of the <code class="literal">PID</code> class for each test. As long as the test (and the code being tested) doesn't invoke any other methods on <code class="literal">self</code>, that's all that we need.</p></div><div class="section" title="Feedback phase"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Feedback phase</h2></div></div></div><a class="indexterm" id="id104"/><a class="indexterm" id="id105"/><p>So, we have a PID controller, and it passes all the tests. We're feeling pretty good. Time to brave the lions, and show it to the client!</p><p>Luckily for us, for the most part they like it. They do have a few requests, though: They want us to let them optionally specify the current time as a parameter to <code class="literal">measure</code>, instead of just using <code class="literal">time.time</code> to figure it out. They also want us to change the signature of the constructor so that it takes an initial measurement and optional time as parameters. Finally, they want us to rename the <code class="literal">measure</code> function to <code class="literal">calculate_response</code>, because they think that more clearly describes what it does.</p></div></div>
<div class="section" title="Time for action &#x2013; unit testing during feedback"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Time for action – unit testing during feedback</h1></div></div></div><p>So, how are we going to deal with this? The program passes all the tests, but the tests no longer reflect the requirements.<a class="indexterm" id="id106"/>
<a class="indexterm" id="id107"/>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the initial parameter to the constructor test, and update the expected results.</li><li class="listitem">Add a second constructor test, which tests the optional time parameter that is now expected to be part of the constructor.</li><li class="listitem">Change the <code class="literal">measure</code> method's name to <code class="literal">calculate_response</code> in all tests.</li><li class="listitem">Add the initial constructor parameter in the <code class="literal">calculate_response</code> test – while we're doing that, we notice that this is going to change the way the <code class="literal">calculate_response</code> function behaves. We contact the client for clarification, and they decide it's okay, so we update the expectations to match what we calculate should happen after the change.</li><li class="listitem">Add a second <code class="literal">calculate_response</code> test, which checks its behavior when the optional time parameter is supplied.</li><li class="listitem">After making all those changes, our specification/test file looks like the following. Lines that have been changed or added are formatted differently, to help you spot them more easily.<div class="informalexample"><pre class="programlisting">We want a class that implements a PID controller for a single variable. The measurement, setpoint, and output should all be real numbers. The constructor should accept an initial measurement value in addition to the gains and setpoint.

&gt;&gt;&gt; import time
&gt;&gt;&gt; real_time = time.time
&gt;&gt;&gt; time.time = (float(x) for x in xrange(1, 1000)).next
&gt;&gt;&gt; import pid
&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0,
...                      initial=12)
&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[0.0]
&gt;&gt;&gt; controller.previous_time
1.0
&gt;&gt;&gt; controller.previous_error
-12.0
&gt;&gt;&gt; controller.integrated_error
0.0
&gt;&gt;&gt; time.time = real_time

The constructor should also optionally accept a parameter specifying when the initial measurement was taken.

&gt;&gt;&gt; pid = reload(pid)
&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=1,
...                      initial=12, when=43)
&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[1.0]
&gt;&gt;&gt; controller.previous_time
43.0
&gt;&gt;&gt; controller.previous_error
-11.0
&gt;&gt;&gt; controller.integrated_error
0.0

&gt;&gt;&gt; real_time = time.time
&gt;&gt;&gt; time.time = (float(x) for x in xrange(1, 1000)).next
&gt;&gt;&gt; pid = reload(pid)
&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0,
...                      initial=12)
&gt;&gt;&gt; controller.calculate_response(6)
-3.0
&gt;&gt;&gt; controller.calculate_response(3)
-4.5
&gt;&gt;&gt; controller.calculate_response(-1.5)
-0.75
&gt;&gt;&gt; controller.calculate_response(-2.25)
-1.125
&gt;&gt;&gt; time.time = real_time
<a class="indexterm" id="id108"/>
<a class="indexterm" id="id109"/>
The calculate_response method should be willing to accept a parameter specifying at what time the call is happening.

&gt;&gt;&gt; pid = reload(pid)
&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0,
...                      initial=12, when=1)
&gt;&gt;&gt; controller.calculate_response(6, 2)
-3.0
&gt;&gt;&gt; controller.calculate_response(3, 3)
-4.5
&gt;&gt;&gt; controller.calculate_response(-1.5, 4)
-0.75
&gt;&gt;&gt; controller.calculate_response(-2.25, 5)
-1.125

We need to be able to adjust the setpoint at runtime, but we want it to have a memory, so that we can easily return to the previous setpoint.

&gt;&gt;&gt; pid = reload(pid)
&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0,
...                      initial=12)
&gt;&gt;&gt; controller.push_setpoint(7)
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0]
&gt;&gt;&gt; controller.push_setpoint(8.5)
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0, 8.5]
&gt;&gt;&gt; controller.pop_setpoint()
8.5
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0]
&gt;&gt;&gt; controller.pop_setpoint()
7.0
&gt;&gt;&gt; controller.setpoint
[0.0]
&gt;&gt;&gt; controller.pop_setpoint()
Traceback (most recent call last):
ValueError: PID controller must have a setpoint<a class="indexterm" id="id110"/>
<a class="indexterm" id="id111"/>
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>Our tests didn't match the requirements any more, so they had to change.</p><p>Well and good, but we don't want them to change too much, because our collection of tests helps us avoid regressions in our code. Regressions are changes that cause something that used to work, to stop working. One of the best ways to avoid them is to avoid deleting tests. If you still have tests in place that check for every desired behavior and every bug fixed, then if you introduce a regression you find out about it immediately.</p><p>That's one reason why we added new tests to check the behavior when the optional time parameters are supplied. The other reason is that if we added those parameters to the existing tests, we wouldn't have any tests of what happens when you don't use those parameters. We always want to check every code path through each unit.</p><p>Sometimes, a test just isn't right any more. For example, tests that make use of the <code class="literal">measure</code> method are just plain wrong, and need to	 be updated to call <code class="literal">calculate_response</code> instead. When we change these tests, though, we still change them as little as possible. After all, we don't want the test to stop checking for old behavior that's still correct, and we don't want to introduce a bug in the test itself.</p><p>The addition of the <code class="literal">initial</code> parameter to the constructor is a big deal. It not only changes the way the constructor should behave, it also changes the way the <code class="literal">calculate_response</code> (née <code class="literal">measure</code>) method should behave in a rather dramatic way. Since this is a change in the correct behavior (a fact which we didn't realize until the tests pointed it out to us, which in turn allowed us to get confirmation of what the correct behavior should be from our clients <span class="emphasis"><em>before</em></span> we started writing the code), we have no choice but to go through and change the tests, recalculating the expected outputs. However, doing all that work has a benefit over and above the future ability to check that the function is working correctly; it makes it much easier to comprehend how the function should work when we actually write it.</p></div><div class="section" title="Back to the development phase"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Back to the development phase</h2></div></div></div><a class="indexterm" id="id112"/><p>Well, it's time to go back into development. In real life, there's no telling how often we'd have to cycle back and forth between development and feedback, but we would want to keep the cycle short. The more often we switch back and forth, the more in contact we are with what our clients really want, and that makes for a more productive, more rewarding job.</p></div></div>
<div class="section" title="Time for action &#x2013; unit testing during development... again"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Time for action – unit testing during development... again</h1></div></div></div><a class="indexterm" id="id113"/><a class="indexterm" id="id114"/><p>We've got our updated tests, so now it's time to get back into a state where all of our tests pass.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First off, let's run the tests, and so get a new list of things that need to be done.<div class="mediaobject"><img alt="Time for action – unit testing during development... again" src="graphics/8846_03_03.jpg"/></div><p>There are several more error reports after this, of course. Doctest reports a total of 32 failing examples, although that's not particularly meaningful since none of the tests are able to even construct a PID object right now. Fixing that constructor would be a reasonable place to start.</p></li><li class="listitem">Using the doctest report as a guide, we set about adjusting the PID class. This is going to work best as an iterative process, where we make a few changes, then run the tests, then make a few changes, and so on. In the end, though, we'll end up with something like the following (the <code class="literal">push_setpoint</code> and <code class="literal">pop_setpoint</code> methods are unchanged, so they've been omitted here to save <a class="indexterm" id="id115"/>space):<div class="informalexample"><pre class="programlisting">
<a class="indexterm" id="id116"/>from time import time

class PID:
    def __init__(self, P, I, D, setpoint, initial, when=None):
        self.gains = (float(P), float(I), float(D))
        self.setpoint = [float(setpoint)]

        if when is None:
            self.previous_time = time()
        else:
            self.previous_time = float(when)

        self.previous_error = self.setpoint[-1] - float(initial)
        self.integrated_error = 0.0

    def calculate_response(self, value, now=None):
        if now is None:
            now = time()
        else:
            now = float(now)

        P, I, D = self.gains
        err = self.setpoint[-1] - value
        result = P * err
        delta = now - self.previous_time
        self.integrated_error += err * delta
        result += I * self.integrated_error
        result += D * (err - self.previous_error) / delta

        self.previous_error = err
        self.previous_time = now

        return result</pre></div><p>We check the tests again, and they all pass.</p></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>
<span class="emphasis"><em>
<a class="indexterm" id="id117"/>
<a class="indexterm" id="id118"/>What just happened?
</em></span>
</h2></div></div></div><p>This wasn't very different from our first time through the development phase. Just as before, we had a set of tests, and the error report from those tests gives us a checklist of things we need to fix. As we work, we keep an eye out for things that need to be tested, but aren't yet, and add those tests. When all the tests pass, we check with our client again (which means we go back to the feedback phase). Eventually the client will be satisfied. Then we can move on to releasing the code, and then into the maintenance phase.</p><p>As we're working, the tests give us a nice, fast way to get a sense of whether what we're doing works, and how far along we are. It makes it easy for us to see that the code we're writing does something, which in turn makes the coding process flow better, and even makes it more fun. Writing code that just sits there is boring and bug-prone, but because we have the tests, our code doesn't just sit there. It's active, and we can see the results at any time.</p></div><div class="section" title="Maintenance phase"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Maintenance phase</h2></div></div></div><p><a class="indexterm" id="id119"/>
<a class="indexterm" id="id120"/>Now that we've passed on our work to our client, we have to make sure that they stay happy with it. That means fixing any bugs that may have slipped past our tests (hopefully not many) and making small improvements on request.</p></div></div>
<div class="section" title="Time for action &#x2013; unit testing during maintenance"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Time for action – unit testing during maintenance</h1></div></div></div><p><a class="indexterm" id="id121"/>Our client has come to us with a change request: they don't want the <code class="literal">PID</code> class to accept negative gain values in its constructor, because negative gains make its output push things further away from the <code class="literal">setpoint</code>, instead of <a class="indexterm" id="id122"/>pulling them toward it.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We add new tests that describe what should happen when negative gains are passed to the constructor. We're testing something that the old tests don't describe, so we get to leave the old tests alone and just add new tests. That's a good thing, because it means that the old tests will be certain to catch any regressions that we might introduce while we're working on this.<div class="informalexample"><pre class="programlisting">It's important that the P, I and D gains not be negative.

&gt;&gt;&gt; pid = reload(pid)
&gt;&gt;&gt; controller = pid.PID(P=-0.5, I=0.5, D=0.5, setpoint=0,
...                      initial=12)
Traceback (most recent call last):
ValueError: PID controller gains must be non-negative

&gt;&gt;&gt; pid = reload(pid)
&gt;&gt;&gt; controller = pid.PID(P=0.5, I=-0.5, D=0.5, setpoint=0,
...                      initial=12)
Traceback (most recent call last):
ValueError: PID controller gains must be non-negative

<a class="indexterm" id="id123"/>&gt;&gt;&gt; pid = reload(pid)
&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=-0.5, setpoint=0,
...                      initial=12)
Traceback (most recent call last):
ValueError: PID controller gains must be non-negative</pre></div></li><li class="listitem">Run the tests to see what needs doing. As we might expect in this case, doctest reports three failures, one for each of the tests we just added – The <code class="literal">PID</code> class didn't raise the expected <code class="literal">ValueError</code>s.<div class="mediaobject"><img alt="Time for action – unit testing during maintenance" src="graphics/8846_03_05.jpg"/></div></li><li class="listitem">Now we write the code that will make the <code class="literal">PID</code> class pass the tests. That's <a class="indexterm" id="id124"/><a class="indexterm" id="id125"/>easily done by adding the following to the constructor:<div class="informalexample"><pre class="programlisting">if P &lt; 0 or I &lt; 0 or D &lt; 0:
  raise ValueError('PID controller gains must be non-negative')</pre></div></li><li class="listitem">We run the tests again, and when they all pass, we can report to our client that the change has been implemented.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Remember, if doctest doesn't print anything, then all the tests passed. It only tells you about errors, unless you pass <code class="literal">-v</code> on its command line.</p></div></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>That looked pretty straightforward, but the fact is that our body of tests was a big help to us here. When we're mucking around in a codebase, trying to update its behavior, or to fix a bug that we've never even considered might exist, it's easy to break other parts of the program. This is doubly so when the codebase is one that we haven't worked with for a while, as is often the case with maintenance requests. Thanks to the expertise stored inthe tests that we wrote, we don't have to worry about forgetting details of what constitutes correct behavior, or what might go wrong in various parts of the code. We don't have to waste time or effort re-learning those details when we come back to the code. Instead, we can just execute the tests.</p><p>Our clients don't necessarily know about our testing process, but they appreciate the fast turnaround time we can give them because of it.</p></div><div class="section" title="Reuse phase"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Reuse phase</h2></div></div></div><p><a class="indexterm" id="id126"/>
<a class="indexterm" id="id127"/>Eventually, there comes a time when—if the code we wrote is useful—we'll want to use it again in a different project. That means we're going to be putting it in a context where the assumptions made in the code may no longer be valid.</p></div></div>
<div class="section" title="Time for action &#x2013; unit testing during reuse"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Time for action – unit testing during reuse</h1></div></div></div><p><a class="indexterm" id="id128"/>
<a class="indexterm" id="id129"/>Our client wants to use a PID controller in a new project, but there's a twist: The value that's going to be measured and controlled is represented as a complex number. When we wrote the PID controller, there was an implicit assumption that the values would always be representable as floating point numbers. What do we have to do to re-use this code? Let's find out.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>By the way, if you don't know what complex numbers are, don't worry. They're not actually complicated; a complex number is just a pair of coordinates, much like latitude and longitude.</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write some tests that use complex numbers for <code class="literal">setpoint</code>, <code class="literal">initial</code> and the measurements. Since we want to make sure we don't break code that still uses floating point numbers, we don't replace the older tests, we just add more.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>You'll notice that we're using some very random-looking numbers here. They're not random at all. Complex numbers can be thought of as representing coordinates; they represent the same values that we used in our earlier tests, except rotated <code class="literal">45</code> degrees and translated by <code class="literal">1+1j</code>. For example, where before we used the value <code class="literal">12</code>, we now use the value of <code class="literal">12 * complex(cos(0.25 * pi), sin(0.25 * pi))+ (1+1j)</code>, which is <code class="literal">9.4852813742385695+9.4852813742385695j</code>. If you don't understand, or don't care, it's enough to know that the same expression can be used to calculate the value of every complex number in this example: just substitute the appropriate number in place of the <code class="literal">12</code>. You can find <code class="literal">sin</code>, <code class="literal">cos</code> and <code class="literal">pi</code> in the <code class="literal">math</code> module.</p></div></div><p><a class="indexterm" id="id130"/>(Some of the input lines here are very long, and have to be wrapped to fit onto the page. They shouldn't be wrapped in the doctest file.)</p><div class="informalexample"><pre class="programlisting">We want to be able to use complex numbers as the measurement and setpoint for the PID controller.

&gt;&gt;&gt; pid = reload(pid)
&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=0.5,
...      setpoint = 1 + 1j,
...      initial = 9.4852813742385695+9.4852813742385695j,
...      when = 1)
&gt;&gt;&gt; controller.calculate_response(5.2426406871192848+5.2426406871192848j, 2)
(-2.1213203435596424-2.1213203435596424j)

&gt;&gt;&gt; controller.calculate_response(3.1213203435596424+3.1213203435596424j, 3)
(-3.1819805153394638-3.1819805153394638j)

&gt;&gt;&gt; controller.calculate_response(-0.060660171779821193-0.060660171779821193j, 4)
(-0.53033008588991093-0.53033008588991093j)

&gt;&gt;&gt; controller.calculate_response(-0.5909902576697319-0.5909902576697319j, 5)
(-0.79549512883486606-0.79549512883486606j)</pre></div></li><li class="listitem"><a class="indexterm" id="id131"/>Okay, the correct behavior has been calculated and the tests have been written. Let's run them and see what doesn't work. We run the doctests, and the first thing that comes out of it is an exception raised in the constructor. It looks like our floating point assumption is already causing trouble. There are several more error reports after this, but since the constructor didn't work, we can't expect them to make much sense.<div class="mediaobject"><img alt="Time for action – unit testing during reuse" src="graphics/8846_03_04.jpg"/></div></li><li class="listitem">The problems in the constructor arise from passing complex numbers into the constructor for the <code class="literal">float</code> class, which is not allowed. Do we really need to call <code class="literal">float</code> there? Sometimes we do, because we don't want to use integers for <code class="literal">setpoint</code> and <code class="literal">initial</code>. Integer division doesn't work the same way as floating point division in versions of Python less than 3.0, so integers could severely mess up the behavior of the system.<p>So,<a class="indexterm" id="id132"/>
<a class="indexterm" id="id133"/> we want to call the <code class="literal">float</code> constructor on <code class="literal">initial</code> and <code class="literal">setpoint</code>, <span class="emphasis"><em>unless</em></span> they are complex numbers. That makes the constructor look like this (again, watch out for the wrapping of long lines):</p><div class="informalexample"><pre class="programlisting">def __init__(self, P, I, D, setpoint, initial, when=None):
    self.gains = (float(P), float(I), float(D))

    if P &lt; 0 or I &lt; 0 or D &lt; 0:
        raise ValueError('PID controller gains must be non-negative')

    if not isinstance(setpoint, complex):
        setpoint = float(setpoint)

    if not isinstance(initial, complex):
        initial = float(initial)

    self.setpoint = [setpoint]

    if when is None:
        self.previous_time = time()
    else:
        self.previous_time = float(when)

    self.previous_error = self.setpoint[-1] - initial
    self.integrated_error = 0.0</pre></div></li><li class="listitem">Okay, we've fixed the constructor. We run the tests again, and all the tests pass! Somewhat surprisingly, perhaps, the <code class="literal">calculate_response</code> function is already compatible with complex numbers.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/>
<span class="emphasis"><em><a class="indexterm" id="id134"/>
<a class="indexterm" id="id135"/>What just happened?
</em></span>
</h2></div></div></div><p>Writing our tests originally helped us to determine what assumptions we were making, and the tests check those assumptions explicitly. Furthermore, even the assumptions that we didn't know we were making have a tendency to be checked by our tests, because they are implicit in our expectations. An example of this is the floating point results that the tests expected. If we had just removed the calls to float in the constructor entirely, all of those tests that were expecting a float would have failed, telling us that we'd violated an implicit assumption about the behavior of the code.</p><p>Our tests give us confidence that our code is correct (even when its operating on complex numbers), and that we haven't broken anything else by changing the code. No muss, no fuss; it works. If one of the tests had failed, that would have told us where the problems lay. Either way, we know where we are in the project and what needs to be done next, which lets us keep the process rolling along.</p></div><div class="section" title="Pop quiz – unit testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec50"/>Pop quiz – unit testing</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><a class="indexterm" id="id136"/><a class="indexterm" id="id137"/>When you write a test, should you do it while referring to the code being tested, or should you do it based on your expectations of what correct behavior should be, before the code is even written?</li><li class="listitem">True or false: You should avoid changing or deleting tests whenever possible, and prefer changing them to deleting them when you aren't able to keep them untouched.</li><li class="listitem">How often do you think your tests should be run? Can you think of any particularly good times to execute the tests?</li><li class="listitem">If your development process is test driven, you as a programmer will spend most of your time doing what?</li></ol></div></div><div class="section" title="Have a go hero – test-driven development"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Have a go hero – test-driven development</h2></div></div></div><a class="indexterm" id="id138"/><p>Try using the methods that we've talked about in this chapter to implement this plain language specification:</p><div class="informalexample"><pre class="programlisting">The library consists of three classes, one representing bank accounts, one representing people, and one representing monetary transactions. Person objects should be able to draw on zero or more accounts, and account objects should be accessible to one or more people. Transactions should represent the transfer of a certain amount of money between one person and another, by transferring the money from an account accessible by the first person to an account accessible by the second.
Attempts to create invalid transactions should fail.
After having been created, it should be possible to execute a transaction to perform the actual transfer between accounts.
All monies should be represented as fixed point numbers, not floating point.</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about Unit testing and Test-Driven Development, which are best-practice disciplines for quickly building reliable programs.</p><p>Specifically, we covered the definition of Unit testing, how unit testing can help during each stage of the development process, what it feels like to use unit testing to drive development, and how it can make the process quicker and more pleasant.</p><p>Now that we've learned about Unit testing, we're ready to talk about making it easier to isolate tests with the help of mock objects—which is the topic of the next chapter.</p></div></body></html>