<html><head></head><body>
        

                            
                    <h1 class="header-title">Frameworks, Standard Languages, and Toolkits</h1>
                
            
            
                
<p>Software frameworks are the lifeline of software applications. They provide extended capabilities and offer many out-of-the-box implementations so that application developers don't need to handle every coding aspect of software and can focus on building faster and smarter business capabilities by using out-of-the-box capabilities, libraries, APIs, and models provided by the frameworks.</p>
<p>We'll provide a short introduction to few popular frameworks along with a little bit of information about their supported programming languages, capabilities, standards, and characteristics, such as footprints, adaptability, cloud deployment friendliness, and ease of development.</p>
<p>The aim of this chapter is to introduce readers to a few prominent frameworks that can come in handy when choosing the right framework for their API-development needs. Please note that the list of discussed frameworks isn't exhaustive, and there's no intention to provide a comparison between them.</p>
<p>The following are the chapter objectives:</p>
<ul>
<li>This chapter is all about introducing a few prominent frameworks to app developers who want to jump-start their RESTful APIs and microservices with their acquainted programming languages</li>
<li>It's an attempt to provide readers with an introduction, guidelines, and advantages and disadvantages for few programming language-friendly frameworks so that they can pick and play with a more suitable framework for their RESTful API development needs</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>As we'll discuss a few prominent frameworks based on the Java, Python, and Go (programming) languages, having a basic understanding in one or more programming languages would enable readers of this chapter to jumpstart their RESTful API development with one or more of their favorite frameworks. This chapter serves as reference material as well as a technical guide for those who have a minimum understanding of any of these three programming languages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Core features of a framework</h1>
                
            
            
                
<p>As we are aware, frameworks are software libraries, APIs, scaffoldings, AJAX, caching, security, compilers and much more. It's imperative that we refresh our memory with the following core qualities of any framework, as our selection of framework relies on these qualities:</p>
<ul>
<li>Simple, consistent, easy to adapt, and faster to implement</li>
<li>Layered architecture, well-designed and -documented</li>
<li>Built with genuine trade-offs</li>
<li>Built with reusable libraries and reused libraries (borrowed from the past) </li>
<li>Integrated and designed to evolve</li>
</ul>
<p>Let's look at a few Java-based frameworks to understand their capabilities regarding their design, footprint, documentation, and adaptability, along with their advantages and disadvantages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Spring Boot</h1>
                
            
            
                
<p>One of the most popular open source, Java-based frameworks is <strong>Spring Boot</strong>. It offers an excellent platform for many Java developers to build and deploy REST-based applications with a rapid turnaround time.</p>
<p>The fundamental design principles of Spring Boot is as follows:</p>
<ul>
<li>Provide radically faster and widely-accessible code, reusable libraries, and boilerplates for all Spring development</li>
</ul>
<ul>
<li>Be opinionated (certain, strong, and expressive), think outside the box, and provide a way for developers to customize as per their requirements, and challenge the defaults</li>
</ul>
<ul>
<li>Provide non-functional requirement features variations that are common to classes of the project that can be used for instrumentation (such as security, embedded servers, health checks, metrics and externalized configuration))</li>
</ul>
<ul>
<li>No code-generation mechanism and no need for XML configurations</li>
</ul>
<p>Boilerplate code or boilerplate represents a code or code library incorporated in a software application, and we can reuse those libraries with little or no alteration. </p>
<p>Let's see what makes Spring Framework a popular choice for app developers for their RESTful API development.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Core features of Spring</h1>
                
            
            
                
<p>Spring's application, external configuration, profiles, and logging are the constituents of Spring's core features. Let's look at each constituent and its values:</p>
<ul>
<li>The Spring application provides a convenient way to bootstrap our applications</li>
<li>External configuration helps us to work with same application code in different environments by using YAML, environment variables, or even with command-line arguments</li>
<li>Profiles segregate parts of an application's configuration and make it available only to certain environments</li>
<li>It provides out-of-the-box Apache Commons Logging capabilities, however, it doesn't stop us from use different logging frameworks</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Database integration with Spring data</h1>
                
            
            
                
<p>Database integration is an important part of any production software applications, and we'll observe how Spring makes the lives of developers better by providing exciting capabilities to integration for traditional SQL databases and NoSQL technologies:</p>
<ul>
<li><strong>SQL</strong>: Spring provides far-reaching support to work with SQL databases. JdbcTemplate for ORM, with Spring data, provides an additional level of functionality called <strong>repository creations</strong>.</li>
<li><strong>NO-SQL</strong>: A Spring-based programming model for data access, called <strong>Spring data</strong>, powers the Spring Framework and provides a quick-and-easy access mechanism to connect to a variety of NoSQL technologies.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Messaging integration</h1>
                
            
            
                
<p>Integration with messaging systems is super simplified with the Spring message framework. Be it simple messaging with JmsTemplate for JMS or ActiveMQ support or be it an AMQP for advanced messaging or for Apache Kafka integration the Spring-framework, it provides simple methods for messaging integration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending Spring with auto-configuration</h1>
                
            
            
                
<p>In many practical scenarios, we need to develop shared libraries (within an organization or as a contribution to open source) and in such cases create specific configuration classes—as modules (JAR). Making it available in the application's classpath makes the development faster and easier by eliminating the need to define specific beans that are included in the auto-configuration classes. The configuration examples could be LDAP, different DB sources configurations, or security configurations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing unit tests and integration test cases</h1>
                
            
            
                
<p>Writing unit test cases and integration tests are essential practices for any developers. Spring provides better capabilities to write unit tests, tests in isolation scripts, and integration tests. Spring Framework comes up with a few utilities and annotations for testing our applications. Spring-boot-starter-test is the favorite test utility for most of developers as its starter tool imports Junit, AssertJ, Hamcrest, and Mockito. Spring-test and Spring-boot-test for integration tests are common libraries and come in handy when writing integration tests. What's exciting about the spring test framework is that we can add some additional test dependencies of our own as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of Spring Boot</h1>
                
            
            
                
<p>Before we move to another popular framework, let's look at some advantages of Spring Boot:</p>
<ul>
<li>Quick setup, rapid development, and push to production (enterprise ready)</li>
<li>Effortless and quick integration with security, ORM, and JDBC</li>
<li>Embedded lightweight HTTP servers</li>
<li>Along with Java, it also supports Groovy</li>
<li>Supports Maven and Gradle build tools</li>
<li>Modular and plays well with other libraries</li>
<li>Quick learning, broad, and in-depth documentation</li>
<li>Very active community (of development and documentation) online and offline</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawbacks of Spring Boot</h1>
                
            
            
                
<p>While Spring has many advantages, we should also be aware of its drawbacks:</p>
<ul>
<li>Frequent breaking changes (by introducing new capabilities and defect fixes) between versions</li>
<li>May create an obligation to use latest versions</li>
<li>Too much information and documentation may be overkill</li>
<li>Vast framework finding specifics may be hard for few (may affect rapid prototyping)</li>
</ul>
<p>The author's choice for all of the code in this book is also Spring Boot, and from examples in <a href="edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml" target="_blank">Chapter 2</a>, <em>Design Strategy, Guidelines, and Best Practices</em>, and <a href="bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml"/><a href="bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml">Chapter 3</a>, <em>Essential RESTful API</em> <em>patterns</em>, we've seen how easy it was to bring up RESTful APIs with Spring Boot. Numerous capabilities are built-in with Spring Boot, and it's one of the matured frameworks of the software industry.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Beginning about Light 4j</h1>
                
            
            
                
<p>Light is a cloud-native micro-services platform developed with Jave SE, with design goals of high throughput, low latency, and a small footprint. Light 4j is a general-purpose web/API framework with different frameworks, such as OAUTH2, Portal, Logging, Messaging, and Metrics, built in.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Core features of Light 4j</h1>
                
            
            
                
<p>The light-4j platform aims at containerized microservices and supports a design-driven approach from the OpenAPI specification for the RESTful API and the GraphQL IDL for GraphQL services and has code-generation and runtime models (for validation and security).</p>
<p>As a platform or a framework, it's good that it addresses a few technical cross-cutting concerns, such as auditing, load-balancing, authentication, and health checks, so that service or API developers can focus on business logic without worrying too much about those technical concerns, also called <strong>non-functional requirements</strong>. Light 4j provides various handler logic and separates those non-functional requirements from the business context, to help the API developers to focus on developing business logic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning about Light Rest 4j</h1>
                
            
            
                
<p>Light Rest 4j is a framework that is built on top of Light 4j, and designed to speed up RESTful API development and deployment. It has many middleware handlers designed around Swagger 2.0 and open API 3.0 specifications. Light-rest-4j comes with open API metadata, open API security, an open API validator, Swagger meta, Swagger security, and Swagger validator.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Light-code-gen</h1>
                
            
            
                
<p>We can build RESTful APIs or services with the OpenAPI 3.0 specification-ready light-rest-4j provided frameworks and scaffold a project with a command-line tool called <strong>light-code-gen</strong> tool. It enables JWT scope-verification and schema-validation for any service requests.</p>
<p>The light-code-gen tool helps us to scaffold a project with a specification file and a config JSON file. The command-line tool can be as simple as a Java command-line tool, docker command line, or even a script that can be part of the DevOps pipeline. light-code-gen works with our favorite Maven build tool as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Choosing Light 4j over the rest</h1>
                
            
            
                
<p>Let's conclude this section with the following facts about Light 4j, as it may help you determine whether to choose Light 4j for RESTful API development:</p>
<ul>
<li>Java-SE-based framework</li>
</ul>
<ul>
<li>Scalable design</li>
</ul>
<ul>
<li>Low latency</li>
</ul>
<ul>
<li>Small memory footprint</li>
</ul>
<ul>
<li>Several handlers as plugins</li>
</ul>
<ul>
<li>Out-of-the-box OAuth2 integration (security-first design)</li>
</ul>
<ul>
<li>Easy integration with other frameworks</li>
</ul>
<ul>
<li>A built-in dependency-injection framework</li>
</ul>
<ul>
<li>Benchmarks indicate as this the fastest RESTful framework</li>
</ul>
<ul>
<li>May involve a steep learning curve due to poor documentation</li>
</ul>
<ul>
<li>New to market/industry, so not much feedback yet on production systems</li>
</ul>
<p>Light-rest-4j, built on top of the light4j framework, is very promising and gaining popularity due to various features—lightweight, very low latency, designed for scalability, not J2EE-based but J2SE-based, and its security-first design.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Spark Framework</h1>
                
            
            
                
<p>Spark is a micro-framework founded by Per Wendel for creating web applications in Java with minimal effort, and it's a free and open source Java Web Framework, released under the Apache 2 license.</p>
<p>The Spark Framework is a rapid-development web framework built with Java 8 Lambda Expression (based on the lambda philosophy), so it can help to build a web application with fewer verbose, in fact you can build a REST API with a JSON response in less than 10 lines of code and provide Node.js-like experience when developing a web API. Cool, isn't it?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Core features of Spark Framework</h1>
                
            
            
                
<p>Let's get a glimpse of some of the core characteristics of Spark:</p>
<ul>
<li>Designed to create APIs faster and more easily</li>
</ul>
<ul>
<li>It's a lightweight library</li>
</ul>
<ul>
<li>Provides simple interfaces through which we can define routes and dispatch them to functions for the paths we requested</li>
</ul>
<ul>
<li>Follows the Java 8 lambda philosophy (create web APIs with fewer lines)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an API with fewer lines</h1>
                
            
            
                
<p>Typically, we would write the following few lines to bring up a hello world API with Spark:</p>
<pre>1 import static spark.Spark.*;<br/>2<br/>3 public class MyHelloWorld {<br/>4 public static void main(String[] args) {<br/>5 get("/sayhello", (request, response) -&gt; "Hello Reader");<br/>6 }<br/>7 }</pre>
<p>That's it! Line one, <kbd>spark.Spark.*</kbd>, as indicated in the preceding code snippet, does the magic. By using CURL (curl <kbd>http://localhost:4567/sayhello</kbd>), we would visualize the following request and response as output for the previous code:</p>
<pre>Request: 
 
GET http://localhost:4567/sayhello 
 
Response: 
 
Hello Reader 
 </pre>
<p>As we can see in the preceding snippet, curl hits the application, so the lambda function of <kbd>Spark.*</kbd> fires and the client (curl in this case) gets the output of the static lambda function. It's not just a simple hello world API; we can write complex RESTful APIs with Spark as it supports a variety of functions, such as query maps, cookies and sessions, filters, redirects, exception and error handlings, and views and templates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of Spark</h1>
                
            
            
                
<p>Now it's time to review the advantages of Spark (and then we'll review another exciting framework called <strong>Dropwizard</strong>):</p>
<ul>
<li>Java-8-EE-based and based on the lambda philosophy (less verbose)</li>
<li>Facilitates rapid development</li>
<li>Enables App developers to create scalable REST APIs</li>
<li>Fast and lightweight</li>
<li>Best suited and excellent fit for rapid prototyping purposes</li>
<li>Scores high on the speed factor as Spark is a thin wrapper around Java EE's servlet API</li>
<li>Simplified and effective routing</li>
<li>Brings better productivity by providing a simple <strong>domain-specific language</strong> (<strong>DSL</strong>) for routing API endpoints to handlers</li>
<li>Maven and Gradle support</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawbacks of Spark</h1>
                
            
            
                
<p>Any popular framework may have drawbacks, and Spark is no exception:</p>
<ul>
<li>Not as popular as other frameworks (small community)</li>
<li>May not be suitable for huge projects (SQL and NoSQL plug-and-play aspects)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Dropwizard</h1>
                
            
            
                
<p>In this section, we'll review another popular Java-based framework licensed under Apache, called Dropwizard. This framework is named for a character from a K.C. Green webcomic (<a href="http://gunshowcomic.com/316">http://gunshowcomic.com/316</a>) series.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overview</h1>
                
            
            
                
<p><strong>Dropwizard</strong> is a stable, mature framework, assembled with several Java libraries, yet lightweight and intended to help API developers by providing features that one can quickly develop and deploy web applications to production servers. Dropwizard's principal design goal is to provide reliable, reusable, and high-performance implementations of everything that a web application needs and provide out-of-the-box capabilities that the application is deployable in production servers. Framework's reusable libraries make the core application lean and focused, hence reducing both time-to-market and maintenance burdens:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3e9cc853-cb48-4ff6-9c2b-dc4556f5e04c.png" style="width:20.17em;height:20.33em;"/></p>
<p>As we can see in the previous diagram, <strong>Dropwizard</strong> supports several powerful libraries, and we'll see some details about each in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Core features of Dropwizard</h1>
                
            
            
                
<p>Dropwizard tailors several high-performance Java-library implementations, such as Jetty, Jersy, Jackson, and Metrics. Let's take a quick glimpse at a few of these libraries.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Jetty for HTTP</h1>
                
            
            
                
<p>Dropwizard uses the Jetty HTTP library and spins up an HTTP web server with its <kbd>main</kbd> method, and so facilitates running your web application as a simple Unix process and piggybacking on existing Unix process management tool. By having this <kbd>main</kbd> method as a way of spinning up, the process leads to the following:</p>
<ul>
<li>No need to manage the traditionally-burdensome Java production process</li>
<li>Gets rid of PermGen issues</li>
<li>No need to customize the application server's configuration</li>
<li>No need for separate deployment tools</li>
<li>No classloader issues</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Jersey for REST</h1>
                
            
            
                
<p>As we know, the JAX-RS reference implementation Jersey is open source; it comes with its native API toolkit to simplify the development of RESTful web services and their clients in Java. Jersey also exposes numerous extension SPIs (software platform infrastructure as a services model). Dropwizard bundles Jersey as its RESTful web app framework and helps developers to write clean code, providing testable classes that gracefully map HTTP requests to simple Java objects that streaming output, matrix URI parameters, conditional <kbd>GET</kbd> requests, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Jackson</h1>
                
            
            
                
<p>A critical need for app developers is having the object mapper from JSON and allowing the domain model to export directly to those Java objects. Dropwizard gratifies those app-developer needs by having Jackson as its primary core feature along with many others.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Metrics</h1>
                
            
            
                
<p>This Java library acts as a powerful toolkit and offers ways to measure the behavior of components that are deployed in production. Combined with other prominent libraries, such as Ehcache and Graphite, Metrics stands as it provides full-stack visibility to our RESTful API and web applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Liquibase</h1>
                
            
            
                
<p>Dropwizard includes the open source solution for managing revisions of database-schema scripts. Liquibase supports various types of database, and various file formats for defining the DB structure. The highlight of Liquibase is its ability to roll back changes (forward and backward) from a specific point.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other noteworthy features</h1>
                
            
            
                
<p>Before we get into its advantages and disadvantages, let's take a glimpse at other noteworthy libraries in Dropwizard:</p>
<ul>
<li><strong>Logging</strong>: Logback and slf4j for performant and flexible logging</li>
</ul>
<ul>
<li><strong>Hibernate validator</strong>: Offers easy ways for user input validation, along with capabilities of generating i18n-friendly error messages</li>
</ul>
<ul>
<li><strong>Http interactions</strong>: Bundled with Apache HttpClient and Jersey client libraries, it helps low-level and high-level HTTP interactions with other web services</li>
</ul>
<ul>
<li><strong>JDBI</strong>: Provides a simple, comfortable, and straightforward way to establish Relational database connectivity with Java backends</li>
</ul>
<ul>
<li><strong>Templates</strong>: Dropwizard supports Freemarker and Mustache, the simplest templating systems for consumer or user-facing applications</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of Dropwizard</h1>
                
            
            
                
<p>As we are covering the advantages and disadvantages of each framework, let's touch upon them for Dropwizard as well, so that you can decide why or why not to use Dropwizard. The following are its merits:</p>
<ul>
<li>A Java framework</li>
<li>Out-of-the-box support for configuration, application metrics, logging, operational tools, templating, and much more</li>
<li>You can do rapid prototyping</li>
<li>Ops-friendly</li>
<li>Very modular</li>
<li>Develops high-performance RESTful web services</li>
<li>Supports many open source and independent libraries</li>
<li>Implementation of monitoring at its best with Metrics</li>
<li>Supports integration and the use of several third-party frameworks</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawbacks of Dropwizard</h1>
                
            
            
                
<p>A few factors that you may consider drawbacks of Dropwizard are as follows:</p>
<ul>
<li>Maintaining applications with third-party frameworks and libraries may bring debugging nightmares</li>
<li>Though there are several powerful libraries, there may be situations where you need a specific library, but it isn't supported by Dropwizard (restriction of using only what Dropwizard provides)</li>
<li>It may incur a steep learning curve</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding Go framework for the RESTful API</h1>
                
            
            
                
<p>Go is one of the friendlier programming languages for microservices and RESTful APIs. Go is a general-purpose, procedural programming language with advanced features and clean syntax. It influences the efficient management of dependencies using package-assembly and supports environment adopting patterns alike to dynamic languages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview</h1>
                
            
            
                
<p>There are many powerful frameworks that Gophers (Go lang programmers) can employ to reuse proven, extensible, production-grade external packages out of the box for their app's development. This section intends to cover some details and functions for two Go-language-based frameworks—Gin-gonic and Revel – that you can use to jump-start your RESTful API development.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gin-gonic</h1>
                
            
            
                
<p>Gin is an HTTP web framework written in Go. Gin design is much out of Martini, another Go framework, however, with better performance than Martini. The Gin framework claims: <em>If you need smashing performance, get yourself some gin</em>. Gin-gonic helps developers to write less boilerplate code and build a request-handling pipeline.</p>
<div><strong>Martini</strong> (<a href="https://github.com/go-martini/martini">https://github.com/go-martini/martini</a>) is a framework developed with the Go language. Its modular and non-intrusive design makes the framework simple to use. However, please be aware that it's no longer maintained or supported.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Core features</h1>
                
            
            
                
<p><strong>Gin</strong> is a very lean framework and supports essential and much-needed features and functionalities for you to design and develop a RESTful web service. The trimmed-down version has essential libraries as well, and you can create your own reusable and extensible pieces of code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HttpRouter</h1>
                
            
            
                
<p><strong>HttpRouter</strong> is a lightweight and a high-performance HTTP request router for Go; it's also called <strong>multiplexer</strong> (or mux, for short). Unlike the default mux of Go's net/HTTP package, this customized mux helps to bind the routing variables in the routing pattern and matches against the request method. The best part of this router is its small memory footprint, optimized for high performance. As this custom router employs a compressing radix tree structure for efficient matching of the long paths, a large number of routes is possible with the custom router.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Http2 server push</h1>
                
            
            
                
<p>Gin supports Http2 server push capabilities out of the box. Server push helps the server to utilize its network resources fully and so improves the page-load time. HTTP/2 introduced a concept called <strong>server push</strong>, which allows the server to push the additional required resources to the browser even before they are explicitly requested.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multi-template</h1>
                
            
            
                
<p>Gin allows by default the use of only one HTML template. However, there's a custom HTML rendering to support multiple templates, that is, more than one <kbd>*template.</kbd> template.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Upload files</h1>
                
            
            
                
<p>By using <kbd>multipart.write</kbd>, we can write files into the cache and send them to the server through the <kbd>POST</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other noteworthy features</h1>
                
            
            
                
<p>Though <em>Gin-Gonic</em> has many libraries and supports several features, here are some of its best features:</p>
<ul>
<li>Groups routes</li>
<li>Writes into log files</li>
<li>Custom validator</li>
<li>Custom middleware</li>
<li>Builds with <em>jsoniter</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of Gin-Gonic</h1>
                
            
            
                
<p>Let's see a few pros of <em>Gin-</em>Gonic:</p>
<ul>
<li>Lean and lightweight</li>
<li>Zero-allocation router</li>
<li>Complete set of unit tests</li>
<li>Backward-compatible, new releases will not break the old code</li>
<li>High performance and highly scalable</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawbacks of Gin-Gonic</h1>
                
            
            
                
<p>Let's be aware of a few disadvantages of this framework:</p>
<ul>
<li>May not be suitable for large, enterprise-based implementations</li>
<li>Low server processing capabilities, which forces clients to handle the workloads</li>
<li>May incur a steep learning curve</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Revel</h1>
                
            
            
                
<p class="mce-root">In our list of frameworks, one of the most promising is Revel. It's fully-featured, designed to provide out-of-the-box asynchronous, stateless, and modular capabilities to our web APIs. Let's learn a bit about Revel and its abilities in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Core features</h1>
                
            
            
                
<p>Revel is a self-contained, almost full-stack web framework, with customizable middleware and an externally-configurable framework that Gophers would develop and stand up their RESTful APIs really quickly. Let's get to know some of the fundamental features of Revel in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Router</h1>
                
            
            
                
<p>URLs and routes definitions are configurable in the file, as shown:</p>
<pre>[METHOD] [URL Pattern] [Controller.Method]<br/>GET / MyGoSite.Hello</pre>
<p>We can route the URLs with Revel in different ways. The following are a few routing methods with examples:</p>
<ul>
<li><strong>Fixed-path routing</strong>: Fixed-path or exact-match routing of the HTTP method and the path to invoke specific methods and controllers</li>
<li><kbd>GET/About App.About</kbd></li>
<li>Use exact match/About as path and <kbd>App.About</kbd> as method on the <kbd>App</kbd> controller</li>
<li><strong>URL</strong><em>: Parameters</em> routing - segments of the path extracted <em>with—</em>prefix</li>
<li><kbd>GET /user/:id User.Details</kbd></li>
</ul>
<p>A few other methods that Revel supports for routing (that we aren't covering in this section) are auto-routing, reverse-routing, static serving, and purge.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Server engine</h1>
                
            
            
                
<p>The best part of Revel's server engine is that app developers are free to implement their favorite HTTP engines. Revel uses the Go HTTP engine by default, but it allows us to configure any other server engine, such as fastHttp, New Relic HTTP, or our custom developed HTTP engine. How cool is that?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Controllers</h1>
                
            
            
                
<p>Controllers in the Revel framework are the logic containers responsible for executing the API logic. The controller holds the incoming HTTP requests information, such as query parameters, path parameters, JSON body, and form data, to the handlers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handlers</h1>
                
            
            
                
<p>HTTP request routers are responsible for comparing the incoming requests against a list of predefined URL paths and calling the respective handlers. Handlers are responsible for writing response headers and bodies. Any Go object that satisfies the <kbd>http.Handler</kbd> interface can be a handler. Interestingly, Go's HTTP package is distributed with functions that can generate handlers, such as <kbd>FileServer</kbd>, <kbd>RedirectHandler</kbd>, and <kbd>NotFoundHandler</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interceptors</h1>
                
            
            
                
<p>There are cases, such as request logging, error handling, or authentication handling, where we need an action invoked by the framework BEFORE or AFTER a specific event, and those sorts of invocations will happen through a Revel function called <strong>interceptors</strong>. In other words, interceptors are a function that gets invoked by the framework. Revel supports three forms of interceptors—function interceptor, method interceptor, and controller interceptor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Filters</h1>
                
            
            
                
<p>Revel has independent functions called <strong>filters</strong>. Filters help to implement horizontal concerns, such as request-logging, cookie policies, and authorization. Filters are middleware, and most of Revel's built-in functionalities and request-processing functionalities are filters. They are interfaces that allow them to be nested.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cache</h1>
                
            
            
                
<p>Revel comes with a library that facilitates server-side, low-latency, and temporary storage to act as a cache. If you need to take advantage of, and minimize access to, the database, cache is a good choice. Another example is implementing cache for user sessions where cookie-based sessions aren't preferred or are insufficient.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other noteworthy features</h1>
                
            
            
                
<p>Here are some other noteworthy features of Revel:</p>
<ul>
<li><strong>Websockets</strong>: Revel supports full-duplex communication over a single TCP connection with WS methods or with the server <kbd>WebSocket</kbd> parameter as an action.</li>
</ul>
<ul>
<li><strong>Database</strong>: DB support through app conf (application configuration) database section configuration. Note that DB isn't preconfigured and it's up to the developers to use modules, such as GORM.</li>
<li><strong>Testing</strong>: Revel comes with pre-built modules that make it easy to write and run functional test cases.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of Revel</h1>
                
            
            
                
<p>Now we are ready to look at the pros of the Revel framework:</p>
<ul>
<li>Hot-code reload</li>
<li>Comprehensive libraries</li>
<li>High performance</li>
<li>Modular, it's built around composable middleware, called filters, which implement most of the request-processing functionality</li>
<li>Built-in test modules facilitate functional test-case execution</li>
<li>Well-documented</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawbacks of Revel</h1>
                
            
            
                
<p>The factors that may make Revel less appealing are as follows:</p>
<ul>
<li>Comprehensive libraries are Revel's advantage in most cases; there are situations that it makes the code base hefty and generates a large footprint (in contradiction to Go's lean principle)</li>
<li>May incur a steep learning curve</li>
<li>No community standard for managing package versions and it's up to the developers to manage and release with the necessary latest dependencies (no backward-compatibility)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Python RESTful API frameworks</h1>
                
            
            
                
<p>Python is one of the top-rated programming languages. It's also known for its less-complex syntax, and its high-level, object-oriented, robust, and general-purpose programming. Python is the top choice for any first-time programmer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overview of Python</h1>
                
            
            
                
<p>Since its release in 1991, Python has evolved and powered by several frameworks for web application development, scientific and mathematical computing, and graphical user interfaces to the latest REST API frameworks. In this section, we'll explore two comprehensive frameworks, Django and Flask, so that you can choose the best one for developing your RESTful API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Django</h1>
                
            
            
                
<p><strong>Django</strong> is a web framework also available as open source with the BSD license, designed to help developers create their web app very quickly as it takes care of additional web-development needs. It includes several packages (also known as <strong>applications</strong>) to handle typical web-development tasks, such as authentication, content administration, scaffolding, templates, caching, and syndication. Let's review the <strong>Django REST Framework</strong> (<strong>DRF</strong>) built with Python, and use the Django core framework for REST API development and deployment in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Django Rest Framework</h1>
                
            
            
                
<p>DRF is an open source, well-matured Python and Django library intended to help APP developers build sophisticated web APIs. DRF's modular, flexible, and customizable architecture makes the development of both simple, turnkey API endpoints and complicated REST constructs possible. The goal of DRF is to divide a model, generalize the wire representation, such as JSON or XML, and customize a set of class-based views to satisfy the specific API endpoint using a serializer that describes the mapping between views and API endpoints.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Core features</h1>
                
            
            
                
<p>Let's have a quick introduction on some of the core features of Django in the following paragraphs and then move on to its noteworthy features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Web-browsable API</h1>
                
            
            
                
<p>This feature enhances the REST API developed with DRF. It has a rich interface, and the web-browsable API supports multiple media types too. The browsable API does mean that the APIs we build will be self-describing and the API endpoints that we create as part of the REST services and return JSON or HTML representations. The interesting fact about the web-browsable API is that we can interact with it fully through the browser, and any endpoint that we interact with using a programmatic client will also be capable of responding with a browser-friendly view onto the web-browsable API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authentication</h1>
                
            
            
                
<p>One of the DRF out-of-the-box capabilities is authentication; it supports broad categories of authentication schemes, from basic authentication, token authentication, session authentication, remote user authentication, to OAuth Authentication. It also supports custom authentication schemes if we wish to implement one. DRF runs the authentication scheme at the start of the view, that is, before any other code is allowed to proceed. DRF determines the incoming requests privileges from the permission and throttling policies, and then decides whether the incoming request can be allowed or disallowed with the matched credentials.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Serialization and deserialization</h1>
                
            
            
                
<p>Serialization is the process of converting complex data, such as querysets and model instances, into native Python datatypes. Converting facilitates the rendering of native data types, such as JSON or XML. DRF supports serialization through serializers classes. The serializers of DRF are similar to Django's <kbd>Form</kbd> and <kbd>ModelForm</kbd> classes. It provides a serializer class, which helps to control the output of responses. The DRF <kbd>ModelSerializer</kbd> classes provide a simple mechanism with which we can create serializers that deal with model instances and querysets. Serializers also do deserialization, that is, serializers allow parsed data that needs to be converted back into complex types. Please note that the deserialization happens only after validating the incoming data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other noteworthy features</h1>
                
            
            
                
<p>Here are some other noteworthy features of the DRF:</p>
<ul>
<li><strong>Routers</strong>: The DRF supports automatic URL routing to Django and provides a consistent and straightforward way to wire the view logic to a set of URLs</li>
<li><strong>Class-based views</strong>: A dominant pattern that enables the reusability of common functionalities</li>
<li><strong>Hyperlinking APIs</strong>: The DRF supports various styles (using primary keys, hyperlinking between entities, and so on) to represent the relationship between entities</li>
<li><strong>Generic views</strong>: Allows us to build API views that map to the database models</li>
</ul>
<p>There are many more features, such as caching, throttling, and testing, that the DRF supports which we won't cover.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of the DRF</h1>
                
            
            
                
<p>Here are some of the benefits of the DRF:</p>
<ul>
<li>Web-browsable API</li>
<li>Authentication policies</li>
<li>Powerful serialization</li>
<li>Extensive documentation and excellent community support</li>
<li>Simple yet powerful</li>
<li>Test coverage of source code</li>
<li>Secure and scalable</li>
<li>Customizable</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawbacks of the DRF</h1>
                
            
            
                
<p>Here are some facts that may disappoint some Python app developers who intend to use the DRF:</p>
<ul>
<li>Monolithic and components get deployed together</li>
<li>Based on Django ORM</li>
<li>Steep learning curve</li>
<li>Slow response time</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Flask</h1>
                
            
            
                
<p>Flask is a microframework for Python developers based on Werkzeug (WSGI toolkit) and Jinja 2 (template engine). It comes under BSD licensing. <strong>Flask</strong> is very easy to set up and simple to use. Like other frameworks, Flask comes with several out-of-the-box capabilities, such as a built-in development server, debugger, unit test support, templating, secure cookies, and RESTful request dispatching. Let's have a look at one more powerful RESTful API framework, called <strong>Flask-RESTful</strong>, in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Flask-RESTful</h1>
                
            
            
                
<p>Flask-RESTful is an extension for Flask that provides additional support for building REST APIs. You will never be disappointed with the time it takes to develop an API. Flask-Restful is a lightweight abstraction that works with the existing ORM/libraries. Flask-RESTful encourages best practices with minimal setup. Now let's get a glimpse of the core features that Flask-RESTful offers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Core features of Flask-RESTful</h1>
                
            
            
                
<p>Flask-RESTful comes with several built-in features; this section covers a few unique RESTful features since we've covered the most common RESTful framework features with Django, and there isn't much difference between their supporting core features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Resourceful routing</h1>
                
            
            
                
<p>The design goal of Flask-RESTful is to provide resources built on top of Flask pluggable views. The pluggable views provide a simple way (defining a resource method) to access the HTTP methods. Consider the following example code:</p>
<pre>   class Todo(Resource): 
    def get(self, user_id): 
        .... 
    def delete(self, user_id): 
        .... 
    def put(self, user_id): 
        args = parser.parse_args() 
        .... 
  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Restful request parsing</h1>
                
            
            
                
<p>Request parsing refers to an interface, modeled after the Python parser <em>interface</em> for command-line arguments, called <kbd>argparser</kbd>. The RESTful request parser is designed to provide uniform and straightforward access to any variable that comes within the <kbd>(flask.request)</kbd> request object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Output fields</h1>
                
            
            
                
<p>In most cases, app developers prefer to control rendering response data, and Flask-RESTful provides a mechanism where you can use ORM models or even custom classes as an object to render. Another interesting fact about this framework is that app developers don't need to worry about exposing any internal data structures as its let one format and filter the response objects. So, when we look at the code, it'll be evident which data would go for rendering and how it'll be formatted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other noteworthy features</h1>
                
            
            
                
<p>As we've covered a few unique features in the previous section, here are some other noteworthy features of Flask-RESTful:</p>
<ul>
<li><strong>API</strong>: This is the main entry point for the restful API, which we'll initialize with the Flask application.</li>
<li><strong>ReqParse</strong>: This enables us to add and parse multiple arguments in the context of the single request.</li>
<li><strong>Input</strong>: A useful functionality, it parses the input string and returns true or false depending on the Input. If the input is from the JSON body,  the type is already native Boolean and passed through without further parsing.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of the Flask framework</h1>
                
            
            
                
<p>Let's look at some of the advantages of Flask and the Flask-Restful framework:</p>
<ul>
<li>Built-in development server and debugger</li>
<li>Out-of-the-box RESTful request dispatching</li>
<li>Support for secure cookies</li>
<li>Integrated unit-test support</li>
<li>Lightweight</li>
<li>Very minimal setup</li>
<li>Faster (performance)</li>
<li>Easy NoSQL integration</li>
<li>Extensive documentation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawbacks of Flask</h1>
                
            
            
                
<p>Here are some of Flask and Flask-RESTful's disadvantages:</p>
<ul>
<li>Version management (managed by developers)</li>
<li>No brownie points as it doesn't have browsable APIs</li>
<li>May incur a steep learning curve</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Frameworks – a table of reference </h1>
                
            
            
                
<p>The following table provides a quick reference of a few other prominent micro-frameworks, their features, and supported programming languages:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Language</strong></p>
</td>
<td>
<p><strong>Framework</strong></p>
</td>
<td>
<p><strong>Short description</strong></p>
</td>
<td>
<p><strong>Prominent features</strong></p>
</td>
</tr>
<tr>
<td>
<p>Java</p>
</td>
<td>
<p>Blade</p>
</td>
<td>
<p>Fast and elegant MVC framework for Java8</p>
</td>
<td>
<p>Lightweight</p>
<p>High performance</p>
<p>Based on the MVC pattern</p>
<p>RESTful-style router interface</p>
<p>Built-in security</p>
</td>
</tr>
<tr>
<td>
<p>Java/Scala</p>
</td>
<td>
<p>Play Framework</p>
</td>
<td>
<p>High-velocity Reactive web</p>
<p>framework for Java and Scala</p>
</td>
<td>
<p>Lightweight, stateless, and web-friendly architecture</p>
<p>Built on Akka</p>
<p>Supports predictable and minimal resource-consumption for highly-scalable applications</p>
<p>Developer-friendly</p>
</td>
</tr>
<tr>
<td>
<p>Java</p>
</td>
<td>
<p>Ninja Web Framework</p>
</td>
<td>
<p>Full-stack web framework</p>
</td>
<td>
<p>Fast</p>
<p>Developer-friendly</p>
<p>Rapid prototyping</p>
<p>Plain vanilla Java, dependency injection, first-class IDE integration</p>
<p>Simple and fast to test (mocked tests/integration tests)</p>
<p>Excellent build and CI support</p>
<p>Clean codebase – easy to extend</p>
</td>
</tr>
<tr>
<td>
<p>Java</p>
</td>
<td>
<p>RESTEASY</p>
</td>
<td>
<p>JBoss-based implementation that integrates several frameworks to help to build RESTful Web and Java applications</p>
</td>
<td>
<p>Fast and reliable</p>
<p>Large community</p>
<p>Enterprise-ready</p>
<p>Security support</p>
</td>
</tr>
<tr>
<td>
<p>Java</p>
</td>
<td>
<p>RESTLET</p>
</td>
<td>
<p>A lightweight and comprehensive framework based on Java, suitable for both server and client applications.</p>
</td>
<td>
<p>Lightweight</p>
<p>Large community</p>
<p>Native REST support</p>
<p>Connectors set</p>
</td>
</tr>
<tr>
<td>
<p>JavaScript</p>
</td>
<td>
<p>Express.js</p>
</td>
<td>
<p>Minimal and flexible Node.js-based JavaScript framework for mobile and web applications</p>
</td>
<td>
<p>HTTP utility methods</p>
<p>Security updates</p>
<p>Templating engine</p>
</td>
</tr>
<tr>
<td>
<p>PHP</p>
</td>
<td>
<p>Laravel</p>
</td>
<td>
<p>An open source web-app builder based on PHP and the MVC architecture pattern</p>
</td>
<td>
<p>Intuitive interface</p>
<p>Blade template engine</p>
<p>Eloquent ORM as default</p>
</td>
</tr>
<tr>
<td>
<p>Elixir</p>
</td>
<td>
<p>Phoenix (Elixir)</p>
</td>
<td>
<p>Powered with the Elixir functional language, a reliable and faster micro-framework</p>
</td>
<td>
<p>MVC-based</p>
<p>High application performance</p>
<p>Erlong virtual machine enables better use of resources</p>
</td>
</tr>
<tr>
<td>
<p>Python</p>
</td>
<td>
<p>Pyramid</p>
</td>
<td>
<p>Python-based micro-framework</p>
</td>
<td>
<p>Lightweight</p>
<p>Function decorators</p>
<p>Events and subscribers support</p>
<p>Easy implementations and high productivity</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We are about to conclude another exciting chapter that dealt with unique, high-productive, lightweight, developer friendly, quick-time-to-market, highly-scalable frameworks from three major programming languages—Java, Go (Golang), and Python. You might have observed that this chapter covered the most popular frameworks and their core functionality and touched on a few noteworthy features along the way. This chapter gave readers a few ideas about the frameworks' advantages and disadvantages. We discussed <em>Spring-Boot</em>, <em>Light 4j</em>, <em>Spark Framework</em>, <em>Dropwizard</em>, <em>Gin-</em>gonic, <em>Revel</em>, <em>Django</em>, and <em>Flask</em>. It's evident that there are several excellent frameworks you can use to jump-start your RESTful API development using your programming language of choice. But one chapter, and only a few pages of information, doesn't begin to cover the greatness of these frameworks and what they bring to the table. We hope this chapter gave you a fair idea of the popular frameworks so that you can kick-start not only your prototyping but also production-grade RESTful applications. In the next chapter, we'll explore best practices for migrating legacy applications to capable microservices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><em>Building RESTful Python Web Services</em> by Gastón C. Hillar, <a href="https://www.packtpub.com/application-development/building-restful-python-web-services">https://www.packtpub.com/application-development/building-restful-python-web-services</a>  <a href="https://www.packtpub.com/application-development/building-restful-python-web-services">October 2016</a></li>
<li><em>Building RESTful Web services with Go</em> by Naren Yellavula, <a href="https://www.packtpub.com/application-development/building-restful-web-services-go">https://www.packtpub.com/application-development/building-restful-web-services-go</a></li>
</ul>


            

            
        
    </body></html>