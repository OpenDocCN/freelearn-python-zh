<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Advanced Forms</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem"><p>Adding a cancel button to forms</p></li><li class="listitem"><p>Adding confirmation on form submit</p></li><li class="listitem"><p>Searching data dynamically</p></li><li class="listitem"><p>Embedding multiple forms in one page</p></li><li class="listitem"><p>Detecting and blocking concurrent updates</p></li><li class="listitem"><p>Creating a form wizard</p></li><li class="listitem"><p>De-normalizing data temporarily</p></li><li class="listitem"><p>Removing form labels</p></li><li class="listitem"><p>Using<code class="literal"> fileuploader.js</code>
</p></li><li class="listitem"><p>Uploading files using a<code class="literal"> LOADed</code> component</p></li><li class="listitem"><p>Making image thumbnails from uploaded images</p></li><li class="listitem"><p>Monitoring upload progress</p></li><li class="listitem"><p>Auto tooltip in forms</p></li><li class="listitem"><p>Color picker widget</p></li><li class="listitem"><p>Shortening text fields</p></li><li class="listitem"><p>Creating multi-table forms</p></li><li class="listitem"><p>Creating a multi-table form with references</p></li><li class="listitem"><p>Creating a multi-table update form</p></li><li class="listitem"><p>Star rating widget</p></li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Introduction</h1></div></div></div><p>Web2py comes with powerful functions for form generation. In this chapter, we provide examples of customization of forms from adding buttons to creating custom form widgets. We also provide examples of complex forms, such as wizards and multi-table forms.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec01"/>Adding a cancel button to forms</h2></div></div></div><p>This recipe explains a method to add cancel buttons to forms, that is, a button that does not submit the forms, ignores any changes, and goes back to the previous page (or moves on to the next, depending on settings). The cancel button is really just a special case of a more general mechanism described herein to add buttons to your form.<a id="id135" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec02"/>Getting ready</h2></div></div></div><p>Our recipe assumes a generic model.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec03"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>The controller builds the form and button with the following statements:</p><div><pre class="programlisting">
form=SQLFORM(db.mytable,
	record=mytable_index,
	deletable=True,
	submit_button=T('Update'))
</pre></div></li><li class="listitem"><p>You can add a button using the following statement:</p><div><pre class="programlisting">
form[0][-1][1].append(TAG.BUTTON('Cancel',
	_onclick="document.location='%s';"%URL('index')))
</pre></div><p>The last line shows how adding a <code class="literal">Cancel</code> button to a form is as simple as appending to the form. The index of the <code class="literal">SQLFORM</code>, where you choose append (or insert) your cancel button, determines where your button will appear on your page.
</p><p>Here form<code class="literal">[0]</code> is the TABLE inside the form. <code class="literal">form[0]</code>[-1] is the last TR. form<code class="literal">[0][-1][1]</code> is column number one (the second TD in the last TR). The <code class="literal">_onclick</code> argument takes the user to the URL specified in the right-hand-side of the <code class="literal">window.location= statement.
</code>
</p></li><li class="listitem"><p>An equivalent notation to put the<code class="literal"> Cancel</code> button after the<code class="literal"> Submit</code> button would be:</p><div><pre class="programlisting">form.element('input[type=submit]').parent.append(TAG.BUTTON(...))
</pre></div><p>Here, the element method partially accepts CSS3 syntax.
</p></li><li class="listitem"><p>In general, buttons of any type can be added into a form using this same mechanism.</p><p>If you prefer more control and transparency over the creation of your <code class="literal">Cancel</code> button, or other buttons, then a custom view might be in order. However, you may not mix this method with a form that has been appended to. This example shows a custom form, where the form was created by the following:
</p><div><pre class="programlisting">form=SQLFORM.factory(db.mytable)
</pre></div></li></ol></div><p>The example assumes a generic table with fields numbered<code class="literal"> 1</code> to<code class="literal"> N</code>.</p><div><pre class="programlisting">{{=form.custom.begin}}
{{=form.custom.widget.field1}}
{{=form.custom.widget.field2}}
{{=form.custom.widget.field3}}
{{=form.custom.submit}}
{{=TAG.BUTTON(T('Cancel'), _onclick='...')}}
{{=form.custom.end}}
</pre></div><p>Here, cannot<code class="literal"> field1...field3</code> must be actual field names. Once more, the<code class="literal"> _onclick</code> action can be of any kind and flavor you like.<a id="id136" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Adding confirmation on form submit</h1></div></div></div><p>Often, you want to double-check that the user is not accidentally submitting an incorrect form. You can do this by prompting the user for confirmation when he/she presses the submit button. This can be done in two ways.<a id="id137" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec04"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>One way is by using<code class="literal"> jQuery</code> to only edit the view that renders the form. In the view add the following code:</p><div><pre class="programlisting">
&lt;script&gt;
	jQuery(function(){
		jQuery('input[type=submit]').click(
			function(){return confirm('Are you sure?');
		});
	});
&lt;/script&gt;
</pre></div><p>Here, <code class="literal">confirm</code> is a JavaScript function that instructs the browser to create a confirmation dialog-box. If you press [<strong>yes</strong>] the <code class="literal">onclick</code> function returns true, and the form is submitted. If you press [<strong>no</strong>], the <code class="literal">onclick</code> function returns false, and the form is not submitted.
</p></li><li class="listitem"><p>The same can be achieved by adding the string to the<code class="literal"> onclick</code> attribute of the button when the form is created.</p><div><pre class="programlisting">return confirm('Are you sure?')
</pre></div></li><li class="listitem"><p>In web2py, there is an easy way to do it:</p><div><pre class="programlisting">
def my_action():
	form = SQLFORM.factory(...)
	form.element('input[type=submit]')['_onclick'] = "return
		confirm('Are you sure?');"
	return dict(form=form)
</pre></div></li></ol></div><p>Notice how we grab the<code class="literal"> form.element(...)</code> using the<code class="literal"> jQuery</code> syntax on the server-side (before the form is actually rendered in HTML), and we modify its<code class="literal"> onclick</code> attribute (using the web2py notation with the preceding underscore).<a id="id138" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Searching data dynamically</h1></div></div></div><p>Web2py comes with a<code class="literal"> crud.search</code> mechanism that allows you to do the following:<a id="id139" class="indexterm"/>
</p><div><pre class="programlisting">
def index():
	form, results = crud.search(db.things)
	return dict(form=form, results=results)
</pre></div><p>Here,<code class="literal"> form</code> is a search form and<code class="literal"> records</code> are the result of the search. To understand how this works, we present in this recipe a simplified implementation of this function that you can further customize depending on your needs. Here,<code class="literal"> db.things</code> is a table containing our things. The actual name of the table or its structure are not relevant here.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec05"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>First of all crate a new model, for example<code class="literal"> dynamic_search.py</code>, and add the following code to it:</p><div><pre class="programlisting">
def build_query(field, op, value):
	if op == 'equals':
		return field == value
	elif op == 'not equal':
		return field != value
	elif op == 'greater than':
		return field &gt; value
	elif op == 'less than':
		return field &lt; value
	elif op == 'starts with':
		return field.startswith(value)
	elif op == 'ends with':
		return field.endswith(value)
	elif op == 'contains':
		return field.contains(value)
def dynamic_search(table):
	tbl = TABLE()
	selected = []
	ops = ['equals','not equal','greater than','less than',
		  'starts with','ends with','contains']
	query = table.id &gt; 0
	for field in table.fields:
		chkval = request.vars.get('chk'+field,None)
		txtval = request.vars.get('txt'+field,None)
		opval = request.vars.get('op'+field,None)
		row = TR(TD(INPUT(_type="checkbox",_name="chk"+field,
							value=chkval=='on')),
				TD(field),TD(SELECT(ops,_name="op"+field,
							value=opval)),
				TD(INPUT(_type="text",_name="txt"+field,
							_value=txtval)))
		tbl.append(row)
		if chkval:
			if txtval:
				query &amp;= build_query(table[field], opval,txtval)
				selected.append(table[field])
	form = FORM(tbl,INPUT(_type="submit"))
	results = db(query).select(*selected)
	return form, results
</pre></div></li><li class="listitem"><p>Now, you can use<code class="literal"> dynamic_search</code> as a replacement for<code class="literal"> crud.search</code>.</p><div><pre class="programlisting">
def index():
	form,results = dynamic_search(db.things)
	return dict(form=form,results=results)
</pre></div><p>We can render this with the following view:
</p><div><pre class="programlisting">{{extend 'layout.html'}}
{{=form}}
{{=results}}
</pre></div><p>Here is how it looks like:
</p></li></ol></div><div><img src="img/5467OS_04_27.jpg" alt="How to do it..."/></div></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec04"/>Embedding multiple forms in one page</h1></div></div></div><p>This recipe explains how to embed more than one form in a page. Doing so can increase user productivity by reducing HTTP calls, but carries a risk of cluttering the page layout.<a id="id140" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec06"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>To illustrate a page with multiple forms, we create a stripped-down system for storing a person's educational<strong> Curriculum Vitae (CV)</strong> . We begin by defining tables for schools, students, and the degrees they received.</p><div><pre class="programlisting">
YEARS = range(1910, 2011)
DEGREES = ('BA', 'BS', 'MA', 'MS', 'MBA', 'JD', 'PhD')

db.define_table('school',
	Field('name', 'string', unique=True),
	Field('address', 'string'),
	Field('established', 'integer', requires=IS_IN_SET(YEARS)),
	format='%(name)s')

db.define_table('student',
	Field('name', 'string', unique=True),
	Field('birthday', 'date'),
	format='%(name)s')
	
db.define_table('education',
	Field('student', db.student),
	Field('school', db.school),
	Field('degree', 'string', requires=IS_IN_SET(DEGREES)),
	Field('graduated', 'integer', requires=IS_IN_SET(YEARS)))
</pre></div></li><li class="listitem"><p>The<code class="literal"> index()</code> controller creates a form for each of the tables:</p><div><pre class="programlisting">
def index():

	student_form = SQLFORM(db.student)
	if student_form.accepts(request, session):
		response.flash = 'Student Form Accepted'
	elif student_form.errors:
		response.flash = 'Form has errors'
		
	school_form=SQLFORM(db.school)
	if school_form.accepts(request, session):
		redirect(URL('index'))
		response.flash = 'School Form Accepted'
	elif school_form.errors:
		response.flash = 'Form has errors'
		
	education_form=SQLFORM(db.education)
	if education_form.accepts(request, session):
		response.flash = 'Education Form Accepted'
	elif education_form.errors:
		response.flash = 'Form has errors'
		
return locals()
</pre></div></li><li class="listitem"><p>In a typical web2py controller, you would see only one<code class="literal"> form=SQLFORM(...)</code> statement, and one<code class="literal"> if form.accepts(...)</code> clause. Since we have three forms to render and process, we need three<code class="literal"> SQLFORM(...)</code> statements, and three<code class="literal"> if specific_form.accepts(...)</code> statements. Each form must be given a unique name, so that when one of the forms is POSTed, its respective<code class="literal"> form.accepts</code> clause will be triggered.</p><p>Note that forms about tables that contain references to other tables must be defined and processed in the order of the dependences. So if a new <code class="literal">school</code> or a new <code class="literal">student</code> is added, it shows the <code class="literal">education</code> form drop-down menu.
<a id="id141" class="indexterm"/>
</p><p>The simplest view to display all three forms on a single page is something like this:
</p><div><pre class="programlisting">{{extend 'layout.html'}}
&lt;h2&gt;Education CV&lt;/h2&gt;
&lt;div id='form1'&gt;{{=education_form}}&lt;/div&gt;

&lt;h2&gt;Student&lt;/h2&gt;
&lt;div id='form1'&gt;{{=student_form}}&lt;/div&gt;

&lt;h2&gt;School&lt;/h2&gt;
&lt;div id='form1'&gt;{{=school_form}}&lt;/div&gt;
</pre></div></li></ol></div><p>If two or more forms are relative to the same table, the accepts must be passed a<code class="literal"> formname</code> argument, and it must be different for the two forms.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec07"/>There's more...</h2></div></div></div><p>Another option consists of implementing the different forms and components loaded in the main (index) page using the<code class="literal"> LOAD</code> command. Also notice that a submission of the<code class="literal"> education</code> form does not affect the other two, while the other two affect the drop-down in the<code class="literal"> education</code> form. This allows us to create different actions for each of the forms:<a id="id142" class="indexterm"/>
</p><div><pre class="programlisting">
def index():
	return dict()
	
def create_student():
	return crud.create(db.student, message='Student Form Accepted')
	
def create_school():
	return crud.create(db.school, message='School Form Accepted')
	
def create_education():
	return crud.create(db.education, message='Education Form Accepted')
</pre></div><p>A view<code class="literal"> views/default/index.html</code> embeds the three forms and traps the<code class="literal"> education</code> form, so that when this form is submitted, the other two are not processed and reloaded:</p><div><pre class="programlisting">
{{extend 'layout.html'}}
&lt;h2&gt;Education CV&lt;/h2&gt;
&lt;div id='form1'&gt;
	{{=LOAD('default','create_eduction',ajax_trap=True)}}
&lt;/div&gt;

&lt;h2&gt;Student&lt;/h2&gt;
&lt;div id='form1'&gt;{{=LOAD('default', 'create_student')}}&lt;/div&gt;

&lt;h2&gt;School&lt;/h2&gt;
&lt;div id='form1'&gt;{{=LOAD('default', 'create_school')}}&lt;/div&gt;
</pre></div><p>Multiple-form pages can also be created using the<code class="literal"> FORM, SQLFORM.factory</code>, and<code class="literal"> crud</code> statements, or a combination of all form-generating statements. Customized forms can be mixed with automatically-generated forms. There is no limit to the flexibility available to generating beautiful form-entry pages with web2py.<a id="id143" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Detecting and blocking concurrent updates</h1></div></div></div><p>Consider for example a wiki page. You open the page, edit it, and save it. It is possible that while you edit your page, somebody accesses the same page, and saves a new version of the page before you do. Your save action will result in the previous edits being lost.<a id="id144" class="indexterm"/>
</p><p>Of course, you can prevent concurrent edits by implementing a locking mechanism, but it is difficult to properly implement such a mechanism. What if a user opens a page for editing, leaves the browser open, and forgets about it? Everybody else would be prevented to edit the same page. Implementing a timeout re-introduces the original problem.</p><p>There is a simple solution. Every time you save a page (or any record for that matters) ask web2py to check whether the original record has been modified on the server since the moment when the record was originally retrieved.</p><p>This is easy in web2py, as we will explain in the this recipe.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec08"/>Getting ready</h2></div></div></div><p>We will consider, as an example, an application with following model:</p><div><pre class="programlisting">db.define_table('page', Field('title', notnull=True), Field('body'))
</pre></div><p>And the following edit form:</p><div><pre class="programlisting">
def edit():
	page = db.page(request.args(0))
	form = SQLFORM(db.page,page)
	if form.accepts(request,session):
		response.flash = "page saved"
	return dict(form=form)
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec09"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>All you have to do is pass an extra attribute to<code class="literal"> form.accepts, detect_record_change</code>, and check whether the record has changed:</p><div><pre class="programlisting">
def edit():
	page = db.page(request.args(0))
	form = SQLFORM(db.page,page)
	if form.accepts(request,session, detect_record_change=True):
		response.flash = "page saved"
	elif form.record_changed:
		response.flash = "page not saved because changed on server"
	return dict(form=form)
</pre></div></li><li class="listitem"><p>On<code class="literal"> record-changed</code>, you can the write your own logic to deal with the conflict. The data on the server is always in the page (<code class="literal">page.title</code> and<code class="literal"> page.body)</code>; the submitted values are in<code class="literal"> request.vars.title</code> and<code class="literal"> request.vars.body</code>.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec10"/>There's more...</h2></div></div></div><p>What about<code class="literal"> crud</code> forms? It turns out that<code class="literal"> crud.create</code> and<code class="literal"> crud.update</code> forms have<code class="literal"> detect_record_change=True</code>, by default (while it is<code class="literal"> False</code> by default for normal SQLFORMs). Therefore, if a record is modified on the server, the newly submitted values are not saved. Yet crud forms do not provide any logic to deal with this situation, and leave it to the developer. For example, you can rewrite the previous example using<code class="literal"> crud</code> as follows:<a id="id145" class="indexterm"/>
</p><div><pre class="programlisting">
def edit():
	page = db.page(request.args(0))
	form = crud.update(db.page,page)
	if form.record_changed:
		response.flash = "page not saved; try resubmit"
	return dict(form=form)
</pre></div><p>Notice that when a submission is rejected because the record changed on the server, a second submission will succeed.</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec06"/>Creating a form wizard</h1></div></div></div><p>We often need to gather information from a user (for example, to populate a database or perform some other operation), yet we do not want to overwhelm the user with a very large form. A better approach consists of breaking the form into multiple pages that the user can navigate with a<code class="literal"> [next]</code> button. Such an approach is a called a<strong> wizard</strong>.<a id="id146" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec11"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>Here we assume we want to use a wizard to populate multiple fields in a table called<code class="literal"> mytable:</code>
</p><div><pre class="programlisting">
db.define_table('mytable',
	Field('field1'),
	Field('field2'),
	...
	Field('fieldN'))
</pre></div><p>It does not matter how many fields you have.
</p></li><li class="listitem"><p>We can handle the wizard with a single action. The action needs to know how many steps, which fields to query at each step, and where to go after the last step. Here is a possible implementation:</p><div><pre class="programlisting">
def wizard():
	STEPS = {0: ('field1','field2'), # fields for 1st page
		1: ('field3','field4'), # fields for 2nd page
		2: ('field5,''field6'), # fields for 3rd page
		3: URL('done')} # url when wizard completed
		
	step = int(request.args(0) or 0)
	if not step in STEPS: redirect(URL(args=0))
	fields = STEPS[step]
	if step==0:
		session.wizard = {}
	if isinstance(fields,tuple):
		form = SQLFORM.factory(*[f for f in db.mytable if f.name in
			fields])
	if form.accepts(request,session):
		session.wizard.update(form.vars)
		redirect(URL(args=step+1))
	else:
		db.mytable.insert(**session.wizard)
		session.flash = T('wizard completed')
		redirect(fields)
	return dict(form=form,step=step)
</pre></div></li><li class="listitem"><p>You can render the wizard with the following:</p><div><pre class="programlisting">{{extend 'layout.html'}}
&lt;h1&gt;Wizard Step {{=step}}&lt;/h1&gt;
{{=form}}
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec12"/>How it works...</h3></div></div></div><p>It is pretty simple, actually. The wizard action gets its page number from<code class="literal"> request.args(0)</code>, and looks up in<code class="literal"> STEPS</code> which fields to display. It uses<code class="literal"> SQLFORM.factory</code> to build the partial form. Completed data from<code class="literal"> form.vars</code> are stored in<code class="literal"> session.wizard</code>. The last page instead of a tuple for the list of fields, contains a<code class="literal"> URL('done')</code>, which is a string. When the wizard encounters this condition, it knows that it is time to insert the<code class="literal"> session.wizard</code> variables in a new table and redirect them to the said URL. Notice that validation is done at each step for the fields that are displayed.<a id="id147" class="indexterm"/>
</p></div></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec07"/>De-normalizing data temporarily</h1></div></div></div><p>In this recipe, we consider the model described in the recipe<em> Efficient search by tag</em>, and we want to create insert, update forms, or a table<code class="literal"> data</code> that allows the user to type in tags in a single input type text-box within the same form. In other words, we want to create a form that is automatically populated from the<code class="literal"> data</code>, and all<code class="literal"> tag</code> records referring to this<code class="literal"> data</code> record. On submission, the form should update both the<code class="literal"> data</code> and the<code class="literal"> tag</code> tables.<a id="id148" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec13"/>Getting ready</h2></div></div></div><p>We assume our usual application, and the following model:</p><div><pre class="programlisting">db.define_table('data',Field('value'))
db.define_table('tag',Field('record_id',db.data),Field('name'))
</pre></div><p>We will also assume the following function in<code class="literal"> controllers/default.py:</code>
</p><div><pre class="programlisting">
def edit():
	record = db.data(request.args(0))
	form = crud.update(db.data,record)
	return dict(form=form)
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec14"/>How to do it...</h2></div></div></div><p>We need to do this in two steps, each represented by a function. One function will assume we have new tags, delete old tags, and store the new tags. Another function will modify the crud form and add an input field containing the current tags. These two functions can then be used to modify our original form.</p><div><pre class="programlisting">
def update_tags(form):
	db(db.tag.record_id==form.record.id).delete()
	new_tags = [tag.strip() for tag in request.vars.tags.split(',')]
	for tag in new_tags:
		if tag:
			db.tag.insert(record_id=form.record.id,name=tag)
			
def make_taggable(form):
	tags = [tag.name for tag in db(db.tag.record_id==form.record.id).
select()]
	value = ', '.join(tags)
		form.element('table').insert(-2, TR(LABEL('Tags:'),
			INPUT(_name='tags', value=value)))
	return form
	
def edit():
record = db.data(request.args(1))
form = make_taggable(crud.update(db.data, record,
	onaccept=update_tags))
return dict(form=form)
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec15"/>How it works...</h2></div></div></div><p>The<code class="literal"> make_taggable</code> function takes a form object (forms are always derivatives of the<code class="literal"> FORM</code> class), and injects into the form table a new row containing a label (<code class="literal">Tags:</code>), and an<code class="literal"> INPUT</code> element. The<code class="literal"> INPUT</code> value defaults to a string containing the current tags for the record.</p><p>When the form is submitted and accepted,<code class="literal"> crud.update</code> ignores the<code class="literal"> request.vars.tags</code> because it is not a field of the<code class="literal"> db.data</code> table. If the form is accepted, the<code class="literal"> onaccept</code> function is called, which points to<code class="literal"> update_tags</code>. This function deletes the current tags and updates them.<a id="id149" class="indexterm"/>
</p><p>Notice that this mechanism is very general, and there is nothing specific to the table<code class="literal"> db.data</code>. In fact, the two functions<code class="literal"> update_tags</code> and<code class="literal"> make_taggable</code> can be used with any table, as long as it is referenced by a<code class="literal"> db.tags</code> table, and both by<code class="literal"> crud.update</code> and<code class="literal"> crud.create</code> forms.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec16"/>There's more...</h2></div></div></div><p>We will need a minor tweak if the tags field needs validation. We will assume that each tag name needs validation and the validator is given by:</p><div><pre class="programlisting">db.tag.name.requires=IS_MATCH('\w[\w\-\./]+')
</pre></div><p>That is, each tag must contain at least two characters. The first one must be alphanumeric (<code class="literal">\w</code>), while the subsequent ones can be alphanumeric (<code class="literal">\w</code>), or dash (<code class="literal">\-</code>), or dot (<code class="literal">\.</code>), or forward slash (<code class="literal">/</code>).</p><p>In order to perform the validation, we need a smart validation function:</p><div><pre class="programlisting">
def validate_tags(form):
	new_tags = [tag.strip() for tag in request.vars.tags.split(',')]
	if tag in new_tags:
		(value, error) = db.tag.name.validate(tag)
	if error:
		form.errors['tags'] = error + '(%s)' % value
</pre></div><p>Then we need to force its call on validation:</p><div><pre class="programlisting">
def edit():
	record = db.data(request.args(0))
	form = make_taggable(crud.update(db.data,record,
	onvalidation=validate_tags,
	onaccept=update_tags))
return dict(form=form)
</pre></div><p>If all the other fields are validated, the<code class="literal"> onvalidation</code> function is called. This function loops over all the tags, and validates them using the<code class="literal"> db.tag.name</code> validator. If one of them does not pass, the error is stored in<code class="literal"> form.errors</code>, which is a<code class="literal"> Storage</code> object. The presence of form errors prevents the form from being accepted. When the form is rendered, the<code class="literal"> INPUT(...,_name='tags')</code> object will pick up the error from the form, and display it appropriately.<a id="id150" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec08"/>Removing form labels</h1></div></div></div><p>When you use<code class="literal"> SQLFORM</code> or crud, the generated form has labels. You can use the<code class="literal"> formstyle</code> attribute of the form to decide how the labels should display:<a id="id151" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">table3cols</code> (on the left of the input widgets)</p></li><li class="listitem"><p>
<code class="literal">table2cols</code> (on the top of the input widgets)</p></li><li class="listitem"><p>
<code class="literal">divs</code> (on separate<code class="literal"> divs</code> without a table, so you can position them by coordinates)</p></li><li class="listitem"><p>
<code class="literal">ul</code> (on the left of the input widgets but using unordered lists instead of a table)</p></li></ul></div><p>Yet sometimes you just want to hide labels.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec17"/>How to do it...</h2></div></div></div><p>There are two ways to do this:</p><div><ol class="orderedlist"><li class="listitem"><p>One way consists of generating the form and removing them from the form:</p><div><pre class="programlisting">
db.define_table('mytable',Field('myfield'))
def index():
	form = SQLFORM(db.mytable)
	for row in form.element('table'): del row[0]
	return dict(form=form)
</pre></div></li><li class="listitem"><p>Another method consists of using a custom form in the view:</p><div><pre class="programlisting">
{{=form.custom.begin}}
&lt;table&gt;
	&lt;tr&gt;
		&lt;td&gt;{{=form.custom.widget.myfield}}&lt;/td&gt;
		&lt;td&gt;{{=db.mytable.myfield.comment}}&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;{{=form.custom.submit}}&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
{{=form.custom.end}}
</pre></div></li></ol></div><p>The net effect is the same.</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec09"/>Using fileuploader.js</h1></div></div></div><p>In this recipe, we will assume you have a database table to store uploaded files and you want to create an interface that allows users to upload multiple files using Ajax.<code class="literal"> fileuploader.js</code> is a jQuery plugin that uses XHR for uploading multiple files, and displays a progress-bar. It works in Firefox 3.6+, Safari 4+, and Chrome, and falls back to the hidden iframe-based upload in other browsers.<a id="id152" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec18"/>Getting ready</h2></div></div></div><p>First you need to download the plugin from<a class="ulink" href="http://https://github.com/valums/file-uploader"> https://github.com/valums/file-uploader</a>, and place the file<code class="literal"> fileuploader.js</code> into the application<code class="literal"> static/js/</code>. Also, place the<code class="literal"> fileuploader.css</code> into the application<code class="literal"> static/css</code>.</p><p>Second, we will assume you have a model, such as the following where you would store uploaded files:</p><div><pre class="programlisting">
db.define_table('document',
	Field('filename', 'upload'),
	Field('uploaded_by', db.auth_user))
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>How to do it...</h2></div></div></div><p>We need to create the following upload action in<code class="literal"> controllers/default.py:</code>
</p><div><pre class="programlisting">
@auth.requires_login()
def upload_callback():
	if 'qqfile' in request.vars:
		filename = request.vars.qqfile
		newfilename = db.document.filename.store(request.body, filename)
		db.document.insert(filename=newfilename,
			uploaded_by=auth.user.id)
	return response.json({'success': 'true'})
	
@auth.requires_login()
def upload():
	return dict()
</pre></div><p>The<code class="literal"> upload_callback</code> action will receive a file in the<code class="literal"> request.body</code> with a name in<code class="literal"> request.vars.qqfile</code>. It will rename it, store it, insert the new name in the database, and return success. The<code class="literal"> upload</code> action, instead, does nothing but its view will display the jQuery plugin:</p><div><pre class="programlisting">
{{response.files.append(URL(request.application,'static','js/
fileuploader.js'))}}
{{response.files.append(URL(request.application,'static','css/
fileuploader.css'))}}
{{extend 'layout.html'}}

&lt;script&gt;
jQuery(document).ready(function() {
	var uploader = new qq.FileUploader({
		// pass the dom node (ex. jQuery(selector)[0] for jQuery users)
		element: document.getElementById('file-uploader'),
		// path to server-side upload script
		action: '{{=URL("upload_callback")}}',
		sizeLimit: 15000000,
		minSizeLimit: 0,
		allowedExtensions: ['xls','jpg', 'jpeg', 'pdf',
			'txt','doc','htm','html','xml','xmls', 'txt','ppt','png',
			'gif'],
		// set to true to output server response to console
		debug: true,
		
		// events
		// you can return false to abort submit
		onSubmit: function(id, fileName){},
		onProgress: function(id, fileName, loaded, total){},
		onComplete: function(id, fileName, responseJSON){},
		onCancel: function(id, fileName){},
		
		messages: {
			// error messages, see qq.FileUploaderBasic for content
			typeError: "{file} {{=T('has invalid extension.')}}
				{{=T('Only')}} {extensions} {{=T('are allowed.')}}",
				sizeError: "{file} {{=T('is too large, maximum file size
				is')}} {sizeLimit}.",
			minSizeError: "{file} {{=T('is too small, minimum file size
				is')}} {minSizeLimit}.",
			emptyError: "{file} {{=T('is empty, please select files again
				without it.')}}",
			onLeave: "{{=T('The files are being uploaded, if you leave now
				the upload will be cancelled.')}}"
			},
			showMessage: function(message){ alert(message); }
		});
	});
&lt;/script&gt;

&lt;div id="file-uploader"&gt;
	&lt;noscript&gt;
		&lt;p&gt;Please enable JavaScript to use file uploader.&lt;/p&gt;
		&lt;!-- or put a simple form for upload here --&gt;
	&lt;/noscript&gt;
&lt;/div&gt;
</pre></div><p>This plugin is very powerful, and it has many configuration options. To learn more about it we refer to its website:<a class="ulink" href="http://valums.com/ajax-upload/"> http://valums.com/ajax-upload/</a>.</p><p>A screenshot of the result can be seen here:<a id="id153" class="indexterm"/>
</p><div><img src="img/5467OS_04_28.jpg" alt="How to do it..."/></div></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec10"/>Uploading files using a LOADed component</h1></div></div></div><p>web2py allows you to design pages in a modular way and LOAD components in the page using Ajax. A component is a subset of the page served by its own action. The component may, for example, render a form. The component traps form submission, and only refreshes itself upon submission. This magic is possible, thanks to the<code class="literal"> static/js/web2py_ajax.js</code> utilities, and the LOAD helper. The problem is that this mechanism breaks for multi-part forms, and it does not work when the form in a LOADed component includes a file<code class="literal"> upload</code> field.<a id="id154" class="indexterm"/>
</p><p>To fix the problem, we need a jQuery plugin called<code class="literal"> jquery.form.js</code>.<a id="id155" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Getting ready</h2></div></div></div><p>To start, you need to download the required jQuery plugin from<a class="ulink" href="http://github.com/malsup/form/raw/master/jquery.form.js?v2.43"> http://github.com/malsup/form/raw/master/jquery.form.js?v2.43</a>, and place it into the<code class="literal"> static/js</code> folder as<code class="literal"> jquery.form.js</code>.</p><p>We will also assume the following models (same as previous recipe), but we will ignore authentication:</p><div><pre class="programlisting">
db.define_table('document',
	Field('filename','upload',requires=IS_NOT_EMPTY()),
	Field('uploaded_by',db.auth_user))
</pre></div><p>The following controller:</p><div><pre class="programlisting">
def index():
	return dict()
	
@auth.requires_signature()
def component_list():
	db.document.filename.represent = lambda f,r: f and A('file',_href\
		=URL('download',args=f))
	return db(db.document).select()
	
@auth.requires_signature()
def component_form():
	db.document.uploaded_by.default = auth.user_id
	db.document.uploaded_by.writable = False
	form = SQLFORM(db.document)
	if form.accepts(request):
		response.flash = 'Thanks for filling the form'
		response.js = "web2py_component('%s','doc_list');" % \
		URL('component_list.load',user_signature=True)
	elif form.errors:
		response.flash = 'Fill the form correctly'
	else:
		response.flash = 'Please fill the form'
	return dict(form=form)
</pre></div><p>And<code class="literal"> views/default/index.html:</code>
</p><div><pre class="programlisting">
{{extend 'layout.html'}}

&lt;h1&gt;{{=T("Change the user's image!")}}&lt;/h1&gt;

{{=LOAD('default', 'component_list.load', ajax=True,
	target='doc_list', user_signature=True)}}
	
{{=LOAD('default', 'component_form.load', ajax=True,
	user_signature=True)}}
</pre></div><p>For any form but the one we created, this would work fine. It would not work with our form, because it contains an<code class="literal"> upload</code> field. Notice that, in this recipe, we have used<code class="literal"> user_signature=True</code> and<code class="literal"> auth.requires_signature()</code> decorator. This will make sure that all URLs are signed, and any authentication/authorization that we apply to the parent page<code class="literal"> index</code> will propagate to the components.<a id="id156" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>To fix the problem, we need two steps. First we need to include the plugins by adding this line in<code class="literal"> views/web2py_ajax.html:</code>
</p><div><pre class="programlisting">response.files.insert(2,URL('static','js/jquery.form.js'))
</pre></div></li><li class="listitem"><p>Then we need to modify<code class="literal"> static/js/web2py_ajax.js</code>, by adding the logic to capture the form and handle the uploads using the<code class="literal"> ajaxForm</code> function, defined in<code class="literal"> jqeury.form.js</code>. To achieve this, edit<code class="literal"> web2py_ajax.js</code> and replace the function<code class="literal"> web2py_trap_form</code> with the following:</p><div><pre class="programlisting">
function web2py_trap_form(action,target) {
	jQuery('#'+target+' form').each(function(i){
		var form=jQuery(this);
		if(!form.hasClass('no_trap'))
			if(form.find('.upload').length&gt;0) {
				form.ajaxForm({
					url: action,
					success: function(data, statusText, xhr) {
						jQuery('#'+target).html(xhr.responseText);
						web2py_trap_form(action,target);
						web2py_ajax_init();
						}
					});
				} else {
					form.submit(function(e){
						jQuery('.flash').hide().html('');
						web2py_ajax_page('post',action,form.serialize(),target);
						e.preventDefault();
					});
				}
		});
}
</pre></div><p>It will handle the form upload using ajaxForm, only if the form contains an input element of the upload class.
</p></li><li class="listitem"><p>Then we need to create a view for the action<code class="literal"> component_form</code> called<code class="literal"> views/default/component_form.load</code> that contains the following:</p><div><pre class="programlisting">
{{=form}}

&lt;script&gt;
/* hack because jquery.form.js does not properly passes headers */
	jQuery('.flash').hide().html("{{=response.flash}}").slideDown();
	eval("{{=XML(response.js or '')}}");
&lt;/script&gt;
</pre></div></li></ol></div><p>The script should not be necessary, but the<code class="literal"> ajaxForm</code> function does not properly pass the headers back-and-forth to the server. Therefore, we need to explicitly include in the view, the logic to show<code class="literal"> response.flash</code>, and execute<code class="literal"> response.js</code>.<a id="id157" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec11"/>Making image thumbnails from uploaded images</h1></div></div></div><p>The title says it all. We want to upload images, and dynamically make thumbnails images from them. We will store the thumbnail references in the same records as the uploaded images.<a id="id158" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Getting ready</h2></div></div></div><p>To use the recipe, you must install the<strong> Python Imaging Library</strong> (PIL). You can find it at the following link:</p><p>
<a class="ulink" href="http://www.pythonware.com/products/pil/">http://www.pythonware.com/products/pil/</a>
</p><p>That requires running web2py from source. As usual with Python, you can use<code class="literal"> easy_install:</code>
</p><div><pre class="programlisting"><strong>easy_install PIL</strong>
</pre></div><p>Or from a Debian compatible distribution with the following:</p><div><pre class="programlisting"><strong>sudo apt-get install python-imaging</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec23"/>How to do it...</h2></div></div></div><p>For this purpose, we will modify the model used in the two previous recipes by adding a field called<code class="literal"> thumbnail</code>, and we will ignore authentication, since it is an orthogonal issue.</p><div><pre class="programlisting">
db.define_table('document',
	Field('filename','upload'),
	Field('thumbnail','upload', readable=False, writable=False))
</pre></div><p>Here is the controller:</p><div><pre class="programlisting">
def make_thumbnail(table, image_id, size=(150, 150)):
	import os
	from PIL import Image
	this_image = table(image_id)
	im = Image.open(os.path.join(request.folder, 'uploads',
		this_image.filename))
	im.thumbnail(size, Image.ANTIALIAS)
	thumbnail = 'document.thumbnail.%s.jpg' %
		this_image.filename.split('.')[2]
	im.save(os.path.join(request.folder, 'uploads', thumbnail), 'jpeg')
	this_image.update_record(thumbnail=thumbnail)
	
def uploadimage():
	form = SQLFORM(db.document)
	if form.accepts(request, session):
		response.flash = 'form accepted'
		make_thumbnail(db.document,form.vars.id,(175,175))
	elif form.errors:
		response.flash = 'form has errors'
	docs = db(db.document).select()
	return dict(form=form,docs=docs)
</pre></div></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec12"/>Monitoring upload progress</h1></div></div></div><p>In this recipe, we will show how to create a JavaScript widget that displays a progress bar, and displays the upload progress. Our solution is server-based and more reliable than pure JavaScript solutions. Be aware that no browser can handle a file over 2GB.<a id="id159" class="indexterm"/>
</p><p>This recipe is based on the following recipes adapted to web2py:</p><p>
<a class="ulink" href="http://www.motobit.com/help/scptutl/pa98.htm">http://www.motobit.com/help/scptutl/pa98.htm</a>
</p><p>
<a class="ulink" href="http://www.djangosnippets.org/snippets/679/">http://www.djangosnippets.org/snippets/679/</a>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec24"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>The main idea consists of using<code class="literal"> cache.ram</code> to store the progress server-side, and expose an action to query for the value of this variable.</p><p>This is accomplished in two steps. In the first step, we choose an X-Progress-ID key, so that we can later retrieve the cache value:
</p><div><pre class="programlisting">
&lt;form action="http://127.0.0.1:8000/example/upload/post?X-
Progress-ID=myuuid"&gt;
</pre></div></li><li class="listitem"><p>Then we retrieve the upload total length from<code class="literal"> cache.ram:</code>
</p><div><pre class="programlisting">cache.ram("X-Progress-ID:myuuid:length",lambda:0,None)
</pre></div><p>And the current uploaded length:
</p><div><pre class="programlisting">
cache.ram('X-Progress-ID:myuuid:uploaded',
	lambda: 0, None)
</pre></div><p>Here <code class="literal">myuuid</code> has to be replaced everywhere with a server generated UUID.
</p></li><li class="listitem"><p>Let's do it now in more detail with a concrete example. Consider this controller action in<code class="literal"> controllers/default.py:</code>
</p><div><pre class="programlisting">
def post():
	if request.extension=='json' and 'X-Progress-ID' in
		request.get_vars:
		cache_key = 'X-Progress-ID:'+request.get_vars['X-Progress-ID']
		length=cache.ram(cache_key+':length', lambda: 0, None)
		uploaded=cache.ram(cache_key+':uploaded', lambda: 0, None)
		from gluon.serializers import json
		return json(dict(length=length, uploaded=uploaded))
	form = FORM(INPUT(_type='file',
		_name='file',requires=IS_NOT_EMPTY()),
		INPUT(_type='submit', _value='SUBMIT'))
	return dict(form=form, myuuid = "[server generated uuid]")
</pre></div><p>Note that this action servers two purposes:
</p><div><ul class="itemizedlist"><li class="listitem"><p>It creates and processes the form</p></li><li class="listitem"><p>If called with<code class="literal"> .json</code>, and passed an<code class="literal"> X-Progress-ID</code>, it returns the length and uploaded variables in json</p></li></ul></div></li><li class="listitem"><p>Now we need to customize the form in<code class="literal"> views/default/post.html:</code>
<a id="id160" class="indexterm"/>
</p><div><pre class="programlisting">
{{extend 'layout.html'}}
&lt;script type="text/javascript"&gt;
	// Add upload progress for multipart forms.
	jQuery(function() { jQuery('form[enctype="multipart/form-
		data"]').submit(function(){
	// Prevent multiple submits
	if (jQuery.data(this, 'submitted')) return false;
	// freqency of update in ms
	var freq = 1000;
	// id for this upload so we can fetch progress info.
	var uuid = ''+Math.floor(Math.random() * 1000000);
	// ajax view serving progress info
	var progress_url = '{{ =URL( extension= "json" )}}';
	// Append X-Progress-ID uuid form action
	this.action += ((this.action.indexOf('?') == -1)?'?':'&amp;') +
		'X-Progress-ID=' + uuid;
	var progress = jQuery('&lt;div id="upload-progress"
		class="upload-progress"&gt;&lt;/div&gt;').insertAfter(
		jQuery('input[type="submit"]')).append('&lt;div
		class="progress-container"&gt;
		&lt;span class="progress-info"&gt;uploading 0%&lt;/span&gt;
		&lt;div class="progress-bar"&gt;&lt;/div&gt;&lt;/div&gt;');
	jQuery('input[type="submit"]').remove();
	// style the progress bar
	progress.find('.progress-bar').height('1em').width(0);
	progress.css("background-color", "red");
	
	// Update progress bar
	function update_progress_info() {
		progress.show();
		jQuery.getJSON(progress_url,
		{'X-Progress-ID': uuid, 'random': Math.random()},
		function(data, status){ if (data) {
			var progress_coefficient=
				parseInt(data.uploaded)/parseInt(data.length);
			var width=progress.find('.progress-container').width();
			var progress_width = width * progress_coefficient;
			progress.find('.progress-bar').width(progress_width);
			progress.find('.progress-info').text('uploading '
				+ progress_coefficient*100 + '%');
		}
		window.setTimeout(update_progress_info, freq);
		});
	};
	window.setTimeout(update_progress_info, freq);
	// mark form as submitted.
	jQuery.data(this, 'submitted', true);
	});
});
&lt;/script&gt;

{{=form}}
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec25"/>How it works...</h3></div></div></div><p>The important part in this is the following:<a id="id161" class="indexterm"/>
</p><div><pre class="programlisting">
this.action += (this.action.indexOf('?') == -1 ? '?' : '&amp;')
	+ 'X-Progress-ID=' + uuid;
</pre></div><p>It passes the<code class="literal"> uuid</code> variable as a<code class="literal"> GET</code> variable. The rest of the magic is done automatically by web2py, which reads this variables, computes the upload programs, and stores it in<code class="literal"> cache.ram</code>.</p><p>These lines is also important:</p><div><pre class="programlisting">
var progress_url = '{{=URL(extension='json')}}';
jQuery.getJSON(progress_url,
	{'X-Progress-ID': uuid, 'random': Math.random()},
	...)
</pre></div><p>They tell web2py to use the same URL, but with the<code class="literal"> .json</code> extension to get the length and uploaded values necessary to update the progress bar.<a id="id162" class="indexterm"/>
</p></div></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec13"/>Auto tooltips in forms</h1></div></div></div><p>This recipe shows you how to display tooltips in forms created through Crud or SQLFORM, using the field's<code class="literal"> comment</code> attribute.<a id="id163" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Getting ready</h2></div></div></div><p>First of all, you have to fill the<code class="literal"> comment</code> attribute in the<code class="literal"> field</code> definition where you want the tooltip to appear. For example:</p><div><pre class="programlisting">
db.define_table('board',
	Field('message', comment='Let your message here.'))
</pre></div><p>If you do only this, the tip will appear on the right side of the field when the form is generated through Crud or SQLFORM.</p><p>Remember that you can put HTML code in a comment using helpers:</p><div><pre class="programlisting">
db.define_table('recados',
	Field('message', comment=SPAN('Let here your ',B('message'))))
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>How to do it...</h2></div></div></div><p>You will need a jQuery plugin to show the tip, so you may Google it and pick one. Or you can use this link:<a class="ulink" href="http://jquery.bassistance.de/tooltip/jquery.tooltip.zip"> http://jquery.bassistance.de/tooltip/jquery.tooltip.zip</a>. See what it looks like here:<a class="ulink" href="http://jquery.bassistance.de/tooltip/demo/"> http://jquery.bassistance.de/tooltip/demo/</a>.</p><div><ol class="orderedlist"><li class="listitem"><p>Extract<code class="literal"> jquery.tooltip.min.js</code> in<code class="literal"> static/js</code>, and<code class="literal"> jquery.tooltip.css</code> to<code class="literal"> static/css</code> respectively.</p></li><li class="listitem"><p>Edit your layout file, and in the head, before<code class="literal"> {{include 'web2py_ajax.html'}}</code> add the following:</p><div><pre class="programlisting">
{{
	response.files.append(URL('static','js/jquery.tooltip.min.js'))
	response.files.append(URL('static','css/jquery.tooltip.css'))
}}
</pre></div></li><li class="listitem"><p>Now you have this script on every page you want tooltips:</p><div><pre class="programlisting">
&lt;script type="text/javascript"&gt;
	jQuery(function() {
	// iterates over all form widgets
	jQuery(".w2p_fw").each(function (){
		// set title for the widget taken from the comment column
		jQuery(this).attr('title',jQuery(this).next().html());
		// clear the comment (optional)
		jQuery(this).next().html('');
		// create the tooltip with title attribute set
		jQuery(this).tooltip();
	});
});
&lt;/script&gt;
</pre></div><p>Your comment column will be converted into nice tooltips.
</p></li></ol></div><p>You can also include this script in<code class="literal"> web2py_ajax.html</code> or<code class="literal"> layout.html</code>, to reuse the code. Or you may put this code in another file, and include it when needed; maybe this is a better way.<a id="id164" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec14"/>Color picker widget</h1></div></div></div><p>If you have a table field that is supposed to contain a color (red, green, #ff24dc, and so on.) you may want to a widget to represent the feild that allows you to change/select the color by picking it from a color canvas. Here we show you how to build a widget to do just that.<a id="id165" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Getting ready</h2></div></div></div><p>You need to download<code class="literal"> mColorPicker</code> from<a class="ulink" href="http://www.bertera.it/software/web2py/mColorPicker-w2p.tgz"> http://www.bertera.it/software/web2py/mColorPicker-w2p.tgz</a>, and uncompress it in the<code class="literal"> static/</code> folder of your application.<a id="id166" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>Define the widget in the file<code class="literal"> models/plugin_colorpicker.py:</code>
</p><div><pre class="programlisting">
class ColorPickerWidget(object):
	"""
	Colorpicker widget based on
	http://code.google.com/p/mcolorpicker/
	"""
	def __init__ (self, js = colorpicker_js, button=True, style="",
			transparency=False):
		import uuid
		uid = str(uuid.uuid4())[:8]
		self._class = "_%s" % uid
		self.style = style
		if transparency == False:
			self.transparency = 'false'
		else:
			self.transparency = 'true'
		if button == True:
			self.data = 'hidden'
		if self.style == "":
			self.style = "height:20px;width:20px;"
		else:
			self.data = 'display'
		if not js in response.files:
			response.files.append(js)
		def widget(self, f, v):
			wrapper = DIV()
			inp = SQLFORM.widgets.string.widget(f,v, _value=v,\
			_type='color',\
			_data_text='hidden', _style=self.style, _hex='true',\
			_class=self._class)
			scr = SCRIPT("jQuery.fn.mColorPicker.init.replace = false; \
			jQuery.fn.mColorPicker.init.allowTransparency=%s; \
			jQuery('input.%s').mColorPicker(\
				{'imageFolder': '/%s/static/mColorPicker/'});"\
			% (self.transparency, self._class, request.application))
			wrapper.components.append(inp)
			wrapper.components.append(scr)
			return wrapper
color_widget = ColorPickerWidget()
</pre></div></li><li class="listitem"><p>To test it, create a table, and set the widget to our new<code class="literal"> colorpicker</code> widget:</p><div><pre class="programlisting">
db.define_table('house',
	Field('color', widget = color_widget.widget))
</pre></div></li><li class="listitem"><p>Finally, create the form in your controller:</p><div><pre class="programlisting">
def index():
	form = SQLFORM(db.house)
	if form.accepts(request, session):
		response.flash = T('New house inserted')
	return dict(form=form)
<a id="id167" class="indexterm"/>
</pre></div></li></ol></div></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec15"/>Shortening text fields</h1></div></div></div><p>In this recipe, we assume we have a table like the following, and we want to display a list of selected post bodies, but shortened.<a id="id168" class="indexterm"/>
</p><div><pre class="programlisting">db.define_table('post', Field('body', 'text'))
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>How to do it...</h2></div></div></div><p>How to do this depends on whether the post contains HTML or wiki syntax.</p><div><ol class="orderedlist"><li class="listitem"><p>We'll consider HTML first.</p><p>This is done in three steps. In the controller we select the rows:
</p><div><pre class="programlisting">
def index():
	posts = db(db.post).select()
	return dict(posts=posts)
</pre></div></li><li class="listitem"><p>Then we shorten by serializing and truncating the HTML:</p><div><pre class="programlisting">
def index():
	posts = db(db.post).select()
	for post in posts:
		post.short = TAG(post.body).flatten()[:100]+'...'
	return dict(posts=posts)
</pre></div></li><li class="listitem"><p>Then we display in the associated view:</p><div><pre class="programlisting">
{{for post in posts:}}&lt;div
	class="post"&gt;{{=post.short}}&lt;/div&gt;{{pass}}
</pre></div><p>Notice that TAG(<code class="literal">post.body</code>) parses the HTML, and then <code class="literal">flatten()</code> serializes the parsed HTML into text, omitting tags. We then extract the first 100 characters and add '...'.
</p></li><li class="listitem"><p>If the body contained wiki syntax instead of HTML, then things are simpler, because we do not need to parse, and we could render the shortened text. Here we assume<code class="literal"> MARKMIN</code> wiki syntax:</p><div><pre class="programlisting">
def index():
	posts = db(db.post).select()
	for post in posts:
		post.short = post.body[:100]+'...'
	return dict(posts=posts)
</pre></div></li><li class="listitem"><p>And in the view:<a id="id169" class="indexterm"/>
</p><div><pre class="programlisting">
{{for post in posts:}}&lt;div
	class="post"&gt;{{=MARKMIN(post.short)}}&lt;/div&gt;{{pass}}
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec31"/>There's more...</h3></div></div></div><p>In the latter case, if you are using a relational database, the truncation can be done in the database server, thus reducing the amount of data transferred from<code class="literal"> db</code> server to<code class="literal"> db</code> client.</p><div><pre class="programlisting">
def index():
	posts = db(db.post).select(db.post.body[:100]+'...')
	for post in posts:
		post.short = post(db.post.body[:100]+'...')
	return dict(posts=posts)
</pre></div><p>An even better approach is to store the shortened text in a different database field instead of shortening every time it is needed. This will result in a faster application.</p></div></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec16"/>Creating multi-table forms</h1></div></div></div><p>Let us consider the example case of a database table called bottles with fields representing guests bringing a bottle of wine to a tasting party. Each bottle can have one or two tasters. Rest assured, there is also a one-to-many relation for the tasting, but here we assume only two testers. Our goal is to create a custom form that allows inserting a description of the bottle, and fill in the names of the two tasters, even if the one-to-may relation is implemented through a separate table.<a id="id170" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Getting ready</h2></div></div></div><p>We will assume the following minimalist model, where the latter table implements the one-to-many relation:</p><div><pre class="programlisting">db.define_table('bottle', Field('name'), Field('year', 'integer'))
db.define_table('taster', Field('name'), Field('bottle', db.bottle))
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>First, we ask the<code class="literal"> factory</code> to make us a form that contains a description of the bottle and a list field for the tasters:</p><div><pre class="programlisting">
form=SQLFORM.factory(
	db.bottle,
	Field('tasters', type='list:string', label=T('Tasters')))
</pre></div></li><li class="listitem"><p>Now, we can handle the<code class="literal"> accept</code> in the following two steps:</p><div><ul class="itemizedlist"><li class="listitem"><p>We insert the<code class="literal"> bottle</code> into the<code class="literal"> db.bottle</code> table</p></li><li class="listitem"><p>We insert each of the<code class="literal"> tasters</code> into the<code class="literal"> db.taster</code> table</p></li></ul></div><div><pre class="programlisting">
def register_bottle():
	form=SQLFORM.factory(
		db.bottle, Field('tasters', type='list:string',
		label=T('Tasters')))
	if form.accepts(request,session):
		bottle_id =
			db.bottle.insert(**db.bottle._filter_fields(form.vars))
	if isinstance(form.vars.tasters, basestring):
		db.taster.insert(name=form.vars.tasters, bottle=bottle_id)
	else:
		for taster in form.vars.tasters:
			db.taster.insert(name=taster, bottle=bottle_id)
		response.flash = 'Wine and guest data are now registered'
		return dict(form=form, bottles = db(db.bottle).select(), \
		tasters = db(db.taster).select())
</pre></div></li></ol></div><p>Notice that we have to filter fields from<code class="literal"> form.vars</code>, before we can perform a<code class="literal"> db.bottle.insert</code>, because the form contains fields that do not belong to the table.<a id="id171" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec17"/>Creating a multi-table form with references</h1></div></div></div><p>Now we want to modify the previous example, so that tasters must be registered users in the system, and we want to select them using drop-boxes. One easy way to do this is by setting a maximum number of tasters (here we choose<code class="literal"> 10)</code>.<a id="id172" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>First we need to modify the model, so that tasters is now a many-to-many link table (a bottle can have many tasters, and a taster can taste multiple bottles):</p><div><pre class="programlisting">
db.define_table('bottle', Field('name'), Field('year', 'integer'))
db.define_table('taster', Field('auth_user', db.auth_user),
	Field('bottle', db.bottle))
</pre></div></li><li class="listitem"><p>Now we change the action accordingly:</p><div><pre class="programlisting">
def register_bottle():
	tasters = range(10)
	form=SQLFORM.factory(
		db.bottle,
			*[Field('taster%i'%i, db.auth_user,label=T('Taster #%i'%i))
			for i in tasters])
	if form.accepts(request,session):
		bottle_id = \
			db.bottle.insert(**db.bottle._filter_fields(form.vars))
	for i in tasters:
		if 'taster%i'%i in form.vars:
			db.taster.insert(auth_user=
				form.vars['taster%i'%i],bottle=bottle_id)
		response.flash='Wine and guest data are now registered'
return dict(form=form)
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec35"/>There's more...</h3></div></div></div><p>A naive way to render this form is the following:</p><div><pre class="programlisting">{{extend 'layout.html'}}
{{=form}}
</pre></div><p>But, it is possible to make it smarter using JavaScript. The idea consists of hiding all rows of the form related to tasters, but showing only the first one and then letting the following rows appear as needed. jQuery is a fantastic tool for this kind of manipulation:</p><div><pre class="programlisting">
{{extend 'layout.html'}}
{{=form}}
&lt;script&gt;
	var taster_rows = new Array();
	for(var i=0; i&lt;10; i++){
	taster_rows[i] = new Array();
	taster_rows[i][0] = '#no_table_taster'+i;
	taster_rows[i][1] = '#no_table_taster'+(i+1)+'__row';
}
	jQuery(function(){
		for(var i=1; i&lt;10; i++){
			jQuery('#no_table_taster'+i+'__row').hide();
	}
	for(var i=0; i&lt;9; i++){
		jQuery('#no_table_taster'+i).change(
			function(){
				for(var i=0; i&lt;10; i++){
					if(taster_rows[i][0] == ("#" + $(this).attr("id"))){
						jQuery(taster_rows[i][1]).slideDown();
					}
				}
			});
		}
	}
	);
&lt;/script&gt;
<a id="id173" class="indexterm"/>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec36"/>How it works...</h3></div></div></div><p>First of all, we hide all rows, but<code class="literal"> taster0</code>. Then we register<code class="literal"> js</code> actions to events. When a field value changes, for example,<code class="literal"> taster2</code>, we make the next one,<code class="literal"> taster3</code>, appear<code class="literal"> (i+1)</code>. Notice that if<code class="literal"> taster3</code> is a field name, then<code class="literal"> #no_table_taster3</code> is the ID of the<code class="literal"> input/select</code> tag, and<code class="literal"> #no_table_taster3__row</code> is the ID of the row in the table. This is a web2py convention.<code class="literal"> no_table</code> comes from the fact that the form is generated by a<code class="literal"> SQLFORM.factory</code>, and is not uniquely associated to a database table.</p></div></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec18"/>Creating a multi-table update form</h1></div></div></div><p>What we now want is to update a record of the<code class="literal"> db.bottle</code> table and its associated<code class="literal"> db.tasters</code> in one single form. This can be done using a mechanism similar to the one explained in the previous recipe. We need to do a little more work.<a id="id174" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec37"/>How to do it...</h2></div></div></div><p>First, we will retain the same model structure as in the previous example, but we change the controller action:</p><div><pre class="programlisting">
def edit_bottle():
	bottle_id = request.args(0)
	bottle = db.bottle(bottle_id) or redirect(URL('error'))
	bottle_tasters = db(db.taster.bottle==bottle_id).select()
	tasters, actual_testers = range(10), len(bottle_tasters)
	form=SQLFORM.factory(
		Field('name', default=bottle.name),
		Field('year', 'integer', default=bottle.year),
		*[Field('taster%i'%i,db.auth_user, default=bottle_tasters[i].auth_user \ if i&lt;actual_testers else '', label=T('Taster #%i'%i)) for
i in tasters])
	if form.accepts(request,session):
		bottle.update_record(**db.bottle._filter_fields(form.vars))
		db(db.taster.bottle==bottle_id).delete()
	for i in tasters:
		if 'taster%i'%i in form.vars:
			db.taster.insert(auth_user=
				form.vars['taster%i'%i],bottle=bottle_id)
	response.flash = 'Wine and guest data are now updated'
	return dict(form=form)
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec38"/>How it works...</h2></div></div></div><p>Very much like the previous form, but the bottle fields are passed explicitly to the<code class="literal"> SQLFORM.factory</code>, so that they can be pre-populated. The<code class="literal"> tasters%i</code> fields are also pre-populated with existing tasters. When the form is submitted, the corresponding bottle record is updated, the past tasters are deleted, and new relations between the bottle and new tasters are inserted.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>There's more...</h2></div></div></div><p>There is always more. The problem is that the JS code that hides empty rows, is now more complex. This is because, when editing the custom form, we do not want to hide rows that have a selected value. Here is a possible solution:</p><div><pre class="programlisting">
{{extend 'layout.html'}}
{{=form}}
&lt;script&gt;
	var taster_rows = new Array();
	for(var i=0; i&lt;10; i++){
		taster_rows[i] = new Array();
		taster_rows[i][0] = '#no_table_taster'+i;
		taster_rows[i][1] = '#no_table_taster'+(i+1)+'__row';
	}
	jQuery(function(){
		for(var i=1; i&lt;10; i++){
			if(!jQuery('#no_table_taster'+i).val()){
				jQuery('#no_table_taster'+i+'__row').hide();
		}
	}
	for(var i=0; i&lt;9; i++){
		jQuery('#no_table_taster'+i).change(
			function(){
				for(var i=0; i&lt;10; i++){
					if(taster_rows[i][0] == ("#" + $(this).attr("id"))){
						jQuery(taster_rows[i][1]).slideDown();
					}
				}
			});
		}
	}
);
&lt;/script&gt;
</pre></div><p>Can you figure out what it does?<a id="id175" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec19"/>Star rating widget</h1></div></div></div><p>In this recipe, we show you how to use the<code class="literal"> jquery</code> star rating plugin, and integrate it with web2py.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Getting ready</h2></div></div></div><p>You need to download the jQuery star rating widget from the following link:<a id="id176" class="indexterm"/>
</p><p>
<a class="ulink" href="http://orkans-tmp.22web.net/star_rating/index.html">http://orkans-tmp.22web.net/star_rating/index.html</a>
</p><p>Extract the files under a new<code class="literal"> static/stars</code> folder, so that<code class="literal"> stars/ui.stars.js, stars/ui.stars.css</code>, and the necessary images provided by the plugin are in it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>Create a model file called<code class="literal"> models/plugin_rating.py</code>, and in the file write the following:</p><div><pre class="programlisting">
DEPENDENCIES = [
	'http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.9/jquery-
		ui.js',
	'http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.9/themes/ui-
		darkness/jquery-ui.css',
	URL(c='static/stars',f='jquery.ui.stars.js'),
	URL(c='static/stars',f='jquery.ui.stars.css')]
	
def rating_widget(f,v):
	from gluon.sqlhtml import OptionsWidget
	import uuid
	id = str(uuid.uuid4())
	for path in DEPENDENCIES:
		response.files.append(path)
	return DIV(SPAN(_id="stars-cap"),
		DIV(OptionsWidget.widget(f,v),_id=id),
		SCRIPT("jQuery(function(){jQuery('#%s').stars({inputType:
			'select'});});" % id))
</pre></div></li><li class="listitem"><p>Then, create a model. For example:</p><div><pre class="programlisting">
db.define_table('song',
	Field('title'),
	Field('rating', 'integer'))
</pre></div></li><li class="listitem"><p>Set the widget to the<code class="literal"> rating_widget</code>, as follows:</p><div><pre class="programlisting">db.song.rating.requires = IS_IN_SET(range(0, 6))
db.song.rating.widget = rating_widget
</pre></div></li><li class="listitem"><p>The plugin model must be executed before the above two lines or the<code class="literal"> rating_widget</code> function will be undefined.</p></li><li class="listitem"><p>It is important here that the field represented by the star rating be an integer with<code class="literal"> IS_IN_SET(range(0,6))</code>.</p></li></ol></div><p>Notice how the<code class="literal"> rating_plugin</code> uses a<code class="literal"> UUID</code> to define the<code class="literal"> id</code> attribute of the<code class="literal"> DIV</code> that renders the widget. In this way, you can have more than one field using the<code class="literal"> rating</code> plugin</p></div></div></div></div>
</body></html>