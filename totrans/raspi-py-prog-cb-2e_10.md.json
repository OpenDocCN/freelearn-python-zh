["```py\n#!/usr/bin/python3\n# socketControl.py\nimport time\nimport RPi.GPIO as GPIO\n#HARDWARE SETUP\n# P1\n# 2[V=G====XI====]26[=======]40\n# 1[=====321=====]25[=======]39\n#V=5V  G=Gnd\nsw_num=[15,13,11]#Pins for Switch 1,2,3\nsw_state=[16,18]#Pins for State X=Off,I=On\nMSGOFF=0; MSGON=1\nSW_ACTIVE=0; SW_INACTIVE=1\n\nclass Switch():\n  def __init__(self):\n    self.setup()\n  def __enter__(self):\n    return self\n  def setup(self):\n    print(\"Do init\")\n    #Setup the wiring\n    GPIO.setmode(GPIO.BOARD)\n    for pin in sw_num:\n      GPIO.setup(pin,GPIO.OUT)\n    for pin in sw_state:\n      GPIO.setup(pin,GPIO.OUT)\n    self.clear()\n  def message(self,number,state):\n    print (\"SEND SW_CMD: %s %d\" % (number,state))\n    if state==MSGON:\n      self.on(number)\n    else:\n      self.off(number)\n  def on(self,number):\n    print (\"ON: %d\"% number)\n    GPIO.output(sw_num[number-1],SW_ACTIVE)\n    GPIO.output(sw_state[MSGON],SW_ACTIVE)\n    GPIO.output(sw_state[MSGOFF],SW_INACTIVE)\n    time.sleep(0.5)\n    self.clear()\n  def off(self,number):\n    print (\"OFF: %d\"% number)\n    GPIO.output(sw_num[number-1],SW_ACTIVE)\n    GPIO.output(sw_state[MSGON],SW_INACTIVE)\n    GPIO.output(sw_state[MSGOFF],SW_ACTIVE)\n    time.sleep(0.5)\n    self.clear()\n  def clear(self):\n    for pin in sw_num:\n      GPIO.output(pin,SW_INACTIVE)\n    for pin in sw_state:\n      GPIO.output(pin,SW_INACTIVE)\n  def __exit__(self, type, value, traceback):\n    self.clear()\n    GPIO.cleanup()\ndef main():\n  with Switch() as mySwitches:\n    mySwitches.on(1)\n    time.sleep(5)\n    mySwitches.off(1)  \n\nif __name__ == \"__main__\":\n    main()\n#End\n```", "```py\n#!/usr/bin/python3\n#socketMenu.py\nimport tkinter as TK\nimport socketControl as SC\n\n#Define Switches [\"Switch name\",\"Switch number\"]\nswitch1 = [\"Living Room Lamp\",1]\nswitch2 = [\"Coffee Machine\",2]\nswitch3 = [\"Bedroom Fan\",3]\nsw_list = [switch1,switch2,switch3]\nSW_NAME = 0; SW_CMD  = 1\nSW_COLOR=[\"gray\",\"green\"]\n\nclass swButtons:\n  def __init__(self,gui,sw_index,switchCtrl):\n    #Add the buttons to window\n    self.msgType=TK.IntVar()\n    self.msgType.set(SC.MSGOFF)\n    self.btn = TK.Button(gui,\n                  text=sw_list[sw_index][SW_NAME],\n                  width=30, command=self.sendMsg,\n                  bg=SW_COLOR[self.msgType.get()])\n    self.btn.pack()\n    msgOn = TK.Radiobutton(gui,text=\"On\",\n              variable=self.msgType, value=SC.MSGON)\n    msgOn.pack()\n    msgOff = TK.Radiobutton(gui,text=\"Off\",\n              variable=self.msgType,value=SC.MSGOFF)\n    msgOff.pack()\n    self.sw_num=sw_list[sw_index][SW_CMD]\n    self.sw_ctrl=switchCtrl\n  def sendMsg(self):\n    print (\"SW_CMD: %s %d\" % (self.sw_num,\n                              self.msgType.get()))\n    self.btn.configure(bg=SW_COLOR[self.msgType.get()])\n    self.sw_ctrl.message(self.sw_num,\n                         self.msgType.get())\n\nroot = TK.Tk()\nroot.title(\"Remote Switches\")\nprompt = \"Control a switch\"\nlabel1 = TK.Label(root, text=prompt, width=len(prompt),\n                  justify=TK.CENTER, bg='lightblue')\nlabel1.pack()\n#Create the switch\nwith SC.Switch() as mySwitches:\n  #Create menu buttons from sw_list\n  for index, app in enumerate(sw_list):\n    swButtons(root,index,mySwitches)\n  root.mainloop()\n#End\n```", "```py\ncd ~\nwget https://github.com/ninjablocks/433Utils/archive/master.zip\nunzip master.zip\n\n```", "```py\ncd ~/433Utils-master/RPi_utils\nnano codesend.cpp -c\n\n```", "```py\nif (wiringPiSetup () == -1) return 1;\n```", "```py\nif (wiringPiSetupPhys () == -1) return 1;\n```", "```py\nnano RFSniffer.cpp -c\n\n```", "```py\n     int PIN = 2;\n```", "```py\n     int PIN = 13; //RPi physical pin number\n```", "```py\n     if(wiringPiSetup() == -1) {\n```", "```py\n     if(wiringPiSetupPhys() == -1) {\n```", "```py\nmake all\n\n```", "```py\ng++    -c -o codesend.o codesend.cpp\ng++   RCSwitch.o codesend.o -o codesend -lwiringPi\ng++    -c -o RFSniffer.o RFSniffer.cpp\ng++   RCSwitch.o RFSniffer.o -o RFSniffer -lwiringPi\n\n```", "```py\nsudo ./RFSniffer\n\n```", "```py\nReceived 1381716\nReceived 1381716\nReceived 1381716\nReceived 1381717\nReceived 1398103\n\n```", "```py\nsendcode 1381716\nsendcode 1381719\n\n```", "```py\nsudo nano /boot/config.txt\n\n```", "```py\ndtparam=spi=on\n\n```", "```py\nlsmod\n\n```", "```py\n#!/usr/bin/python3\n# spiTest.py\nimport wiringpi\n\nprint(\"Add SPI Loopback - connect GPIO Pin19 and Pin21\")\nprint(\"[Press Enter to continue]\")\ninput()\nwiringpi.wiringPiSPISetup(1,500000)\nbuffer=str.encode(\"HELLO\")\nprint(\"Buffer sent %s\" % buffer)\nwiringpi.wiringPiSPIDataRW(1,buffer)\nprint(\"Buffer received %s\" % buffer)\nprint(\"Remove the SPI Loopback\")\nprint(\"[Press Enter to continue]\")\ninput()\nbuffer=str.encode(\"HELLO\")\nprint(\"Buffer sent %s\" % buffer)\nwiringpi.wiringPiSPIDataRW(1,buffer)\nprint(\"Buffer received %s\" % buffer)\n#End\n```", "```py\nBuffer sent b'HELLO'\nBuffer received b'HELLO'\nRemove the SPI Loopback\n[Press Enter to continue]\nBuffer sent b'HELLO'\nBuffer received b'\\x00\\x00\\x00\\x00\\x00'\n\n```", "```py\n#!/usr/bin/python3\n# matrixControl.py\nimport wiringpi\nimport time\n\nMAX7219_NOOP        = 0x00\nDIG0=0x01; DIG1=0x02; DIG2=0x03; DIG3=0x04\nDIG4=0x05; DIG5=0x06; DIG6=0x07; DIG7=0x08\nMAX7219_DIGIT=[DIG0,DIG1,DIG2,DIG3,DIG4,DIG5,DIG6,DIG7]\nMAX7219_DECODEMODE  = 0x09\nMAX7219_INTENSITY   = 0x0A\nMAX7219_SCANLIMIT   = 0x0B\nMAX7219_SHUTDOWN    = 0x0C\nMAX7219_DISPLAYTEST = 0x0F\nSPI_CS=1\nSPI_SPEED=100000\n\nclass matrix():\n  def __init__(self,DEBUG=False):\n    self.DEBUG=DEBUG\n    wiringpi.wiringPiSPISetup(SPI_CS,SPI_SPEED)\n    self.sendCmd(MAX7219_SCANLIMIT, 8)   # enable outputs\n    self.sendCmd(MAX7219_DECODEMODE, 0)  # no digit decode\n    self.sendCmd(MAX7219_DISPLAYTEST, 0) # display test off\n    self.clear()\n    self.brightness(7)                   # brightness 0-15\n    self.sendCmd(MAX7219_SHUTDOWN, 1)    # start display\n  def sendCmd(self, register, data):\n    buffer=(register<<8)+data\n    buffer=buffer.to_bytes(2, byteorder='big')\n    if self.DEBUG:print(\"Send byte: 0x%04x\"%\n                        int.from_bytes(buffer,'big'))\n    wiringpi.wiringPiSPIDataRW(SPI_CS,buffer)\n    if self.DEBUG:print(\"Response:  0x%04x\"%\n                        int.from_bytes(buffer,'big'))\n    return buffer\n  def clear(self):\n    if self.DEBUG:print(\"Clear\")\n    for row in MAX7219_DIGIT:\n      self.sendCmd(row + 1, 0)\n  def brightness(self,intensity):\n    self.sendCmd(MAX7219_INTENSITY, intensity % 16)\n\ndef letterK(matrix):\n    print(\"K\")\n    K=(0x0066763e1e366646).to_bytes(8, byteorder='big')\n    for idx,value in enumerate(K):\n        matrix.sendCmd(idx+1,value)\n\ndef main():\n    myMatrix=matrix(DEBUG=True)\n    letterK(myMatrix)\n    while(1):\n      time.sleep(5)\n      myMatrix.clear()\n      time.sleep(5)\n      letterK(myMatrix)\n\nif __name__ == '__main__':\n    main()\n#End\n```", "```py\n#!/usr/bin/python3\n#matrixMenu.py\nimport tkinter as TK\nimport time\nimport matrixControl as MC\n\n#Enable/Disable DEBUG\nDEBUG = True\n#Set display sizes\nBUTTON_SIZE = 10\nNUM_BUTTON = 8\nNUM_LIGHTS=NUM_BUTTON*NUM_BUTTON\nMAX_VALUE=0xFFFFFFFFFFFFFFFF\nMARGIN = 2\nWINDOW_H = MARGIN+((BUTTON_SIZE+MARGIN)*NUM_BUTTON)\nWINDOW_W = WINDOW_H\nTEXT_WIDTH=int(2+((NUM_BUTTON*NUM_BUTTON)/4))\nLIGHTOFFON=[\"red4\",\"red\"]\nOFF = 0; ON = 1\ncolBg = \"black\"\n\ndef isBitSet(value,bit):\n  return (value>>bit & 1)\n\ndef setBit(value,bit,state=1):\n  mask=1<<bit\n  if state==1:\n    value|=mask\n  else:\n    value&=~mask\n  return value\n\ndef toggleBit(value,bit):\n  state=isBitSet(value,bit)\n  value=setBit(value,bit,not state)\n  return value\n\nclass matrixGUI(TK.Frame):\n  def __init__(self,parent,matrix):\n    self.parent = parent\n    self.matrix=matrix\n    #Light Status\n    self.lightStatus=0\n    #Add a canvas area ready for drawing on\n    self.canvas = TK.Canvas(parent, width=WINDOW_W,\n                        height=WINDOW_H, background=colBg)\n    self.canvas.pack()\n    #Add some \"lights\" to the canvas\n    self.light = []\n    for iy in range(NUM_BUTTON):\n      for ix in range(NUM_BUTTON):\n        x = MARGIN+MARGIN+((MARGIN+BUTTON_SIZE)*ix)\n        y = MARGIN+MARGIN+((MARGIN+BUTTON_SIZE)*iy)\n        self.light.append(self.canvas.create_rectangle(x,y,\n                              x+BUTTON_SIZE,y+BUTTON_SIZE,\n                              fill=LIGHTOFFON[OFF]))\n    #Add other items\n    self.codeText=TK.StringVar()\n    self.codeText.trace(\"w\", self.changedCode)\n    self.generateCode()\n    code=TK.Entry(parent,textvariable=self.codeText,\n                  justify=TK.CENTER,width=TEXT_WIDTH)\n    code.pack()\n    #Bind to canvas not tk (only respond to lights)\n    self.canvas.bind('<Button-1>', self.mouseClick)\n\n  def mouseClick(self,event):\n    itemsClicked=self.canvas.find_overlapping(event.x,\n                             event.y,event.x+1,event.y+1)\n    for item in itemsClicked:\n      self.toggleLight(item)\n\n  def setLight(self,num):\n    state=isBitSet(self.lightStatus,num)\n    self.canvas.itemconfig(self.light[num],\n                           fill=LIGHTOFFON[state])\n\n  def toggleLight(self,num):\n    if num != 0:\n      self.lightStatus=toggleBit(self.lightStatus,num-1)\n      self.setLight(num-1)\n      self.generateCode()\n\n  def generateCode(self):\n    self.codeText.set(\"0x%016x\"%self.lightStatus)\n\n  def changedCode(self,*args):\n    updated=False\n    try:\n      codeValue=int(self.codeText.get(),16)\n      if(codeValue>MAX_VALUE):\n        codeValue=codeValue>>4\n      self.updateLight(codeValue)\n      updated=True\n    except:\n      self.generateCode()\n      updated=False\n    return updated\n\n  def updateLight(self,lightsetting):\n    self.lightStatus=lightsetting\n    for num in range(NUM_LIGHTS):\n      self.setLight(num)\n    self.generateCode()\n    self.updateHardware()\n\n  def updateHardware(self):\n    sendBytes=self.lightStatus.to_bytes(NUM_BUTTON,\n                                        byteorder='big')\n    print(sendBytes)\n    for idx,row in enumerate(MC.MAX7219_DIGIT):\n      response = self.matrix.sendCmd(row,sendBytes[idx])\n      print(response)\n\ndef main():\n  global root\n  root=TK.Tk()\n  root.title(\"Matrix GUI\")\n  myMatrixHW=MC.matrix(DEBUG)\n  myMatrixGUI=matrixGUI(root,myMatrixHW)\n  TK.mainloop()\n\nif __name__ == '__main__':\n    main()\n#End\n```", "```py\n    sudo pip-3.2 install pyserial\n    ```", "```py\n#!/usr/bin/python3\n#serialControl.py\nimport serial\nimport time\n\n#Serial Port settings\nSERNAME=\"/dev/ttyUSB0\"\n#default setting is 9600,8,N,1\nIDLE=0; SEND=1; RECEIVE=1\n\ndef b2s(message):\n  '''Byte to String'''\n  return bytes.decode(message)\ndef s2b(message):\n  '''String to Byte'''\n  return bytearray(message,\"ascii\")\n\nclass serPort():\n  def __init__(self,serName=\"/dev/ttyAMA0\"):\n    self.ser = serial.Serial(serName)\n    print (self.ser.name)\n    print (self.ser)\n    self.state=IDLE\n  def __enter__(self):\n    return self\n  def send(self,message):\n    if self.state==IDLE and self.ser.isOpen():\n      self.state=SEND\n      self.ser.write(s2b(message))\n      self.state=IDLE\n\n  def receive(self, chars=1, timeout=5, echo=True,\n              terminate=\"\\r\"):\n    message=\"\"\n    if self.state==IDLE and self.ser.isOpen():\n      self.state=RECEIVE\n      self.ser.timeout=timeout\n      while self.state==RECEIVE:\n        echovalue=\"\"\n        while self.ser.inWaiting() > 0:\n          echovalue += b2s(self.ser.read(chars))\n        if echo==True:\n          self.ser.write(s2b(echovalue))\n        message+=echovalue\n        if terminate in message:\n          self.state=IDLE\n    return message\n  def __exit__(self,type,value,traceback):\n    self.ser.close()      \n\ndef main():\n  try:\n    with serPort(serName=SERNAME) as mySerialPort:\n      mySerialPort.send(\"Send some data to me!\\r\\n\")\n      while True:\n        print (\"Waiting for input:\")\n        print (mySerialPort.receive())\n  except OSError:\n    print (\"Check selected port is valid: %s\" %serName)\n  except KeyboardInterrupt:\n    print (\"Finished\")\n\nif __name__==\"__main__\":\n  main()\n#End    \n```", "```py\n#!/usr/bin/python3\n#serialMenu.py\nimport time\nimport RPi.GPIO as GPIO\nimport serialControl as SC\nSERNAME = \"/dev/ttyUSB0\"\nrunning=True\n\nCMD=0;PIN=1;STATE=2;OFF=0;ON=1\nGPIO_PINS=[7,11,12,13,15,16,18,22]\nGPIO_STATE=[\"OFF\",\"ON\"]\nEXIT=\"EXIT\"\n\ndef gpioSetup():\n  GPIO.setmode(GPIO.BOARD)\n  for pin in GPIO_PINS:\n    GPIO.setup(pin,GPIO.OUT)\n\ndef handleCmd(cmd):\n  global running\n  commands=cmd.upper()\n  commands=commands.split()\n  valid=False\n  print (\"Received: \"+ str(commands))\n  if len(commands)==3:\n    if commands[CMD]==\"GPIO\":\n      for pin in GPIO_PINS:\n        if str(pin)==commands[PIN]:\n          print (\"GPIO pin is valid\")\n          if GPIO_STATE[OFF]==commands[STATE]:\n            print (\"Switch GPIO %s %s\"% (commands[PIN],\n                                         commands[STATE]))\n            GPIO.output(pin,OFF)\n            valid=True\n          elif GPIO_STATE[ON]==commands[STATE]:\n            print (\"Switch GPIO %s %s\"% (commands[PIN],\n                                         commands[STATE]))\n            GPIO.output(pin,ON)\n            valid=True\n  elif commands[CMD]==EXIT:\n    print(\"Exit\")\n    valid=True\n    running=False\n  if valid==False:\n    print (\"Received command is invalid\")\n    response=\"  Invalid:GPIO Pin#(%s) %s\\r\\n\"% (\n                      str(GPIO_PINS), str(GPIO_STATE))\n  else:\n    response=\"  OK\\r\\n\"\n  return (response)\n\ndef main():\n  try:\n    gpioSetup()\n    with SC.serPort(serName=SERNAME) as mySerialPort:\n      mySerialPort.send(\"\\r\\n\")\n      mySerialPort.send(\"  GPIO Serial Control\\r\\n\")\n      mySerialPort.send(\"  -------------------\\r\\n\")\n      mySerialPort.send(\"  CMD PIN STATE \"+\n                        \"[GPIO Pin# ON]\\r\\n\")\n      while running==True:\n        print (\"Waiting for command...\")\n        mySerialPort.send(\">>\")\n        cmd = mySerialPort.receive(terminate=\"\\r\\n\")\n        response=handleCmd(cmd)\n        mySerialPort.send(response)\n      mySerialPort.send(\"  Finished!\\r\\n\")\n  except OSError:\n    print (\"Check selected port is valid: %s\" %serName)\n  except KeyboardInterrupt:\n    print (\"Finished\")\n  finally:\n    GPIO.cleanup()\n\nmain()\n#End\n```", "```py\ndmesg | grep tty\n\n```", "```py\n[ 2409.195407] usb 1-1.2: pl2303 converter now attached to ttyUSB0\n\n```", "```py\nsudo nano /boot/cmdline.txt\ndwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait\n\n```", "```py\ndwc_otg.lpm_enable=0 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait\n\n```", "```py\nsudo nano /etc/inittab\nT0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100\n\n```", "```py\n#T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100\n\n```", "```py\n#!/usr/bin/python3\n#serialTest.py\nimport serial\nimport time\n\nWAITTIME=1\nserName=\"/dev/ttyAMA0\"\nser = serial.Serial(serName)\nprint (ser.name)\nprint (ser)\nif ser.isOpen():\n  try:\n    print(\"For Serial Loopback - connect GPIO Pin8 and Pin10\")\n    print(\"[Type Message and Press Enter to continue]\")\n    print(\"#:\")\n    command=input()\n    ser.write(bytearray(command+\"\\r\\n\",\"ascii\"))\n    time.sleep(WAITTIME)\n    out=\"\"\n    while ser.inWaiting() > 0:\n      out += bytes.decode(ser.read(1))\n    if out != \"\":\n      print (\">>\" + out)\n    else:\n      print (\"No data Received\")\n  except KeyboardInterrupt:\n    ser.close()\n#End\n```", "```py\nser = serial.Serial(port=serName, baudrate= 115200, \n    timeout=1, parity=serial.PARITY_ODD,\n    stopbits=serial.STOPBITS_TWO,\n    bytesize=serial.SEVENBITS)\n```", "```py\n    serName=\"/dev/ttyAMA0\"\n\n    ```", "```py\n    sudo python3 menuSerial.py\n\n    ```", "```py\npython3 -m serial.tools.miniterm\n\n```", "```py\nEnter port name: /dev/ttyAMA0\n\n```", "```py\nsudo pip-3.2 install pyusb\n\n```", "```py\npython3\n> import usb\n> help (usb)\n> exit()\n\n```", "```py\n    #!/usr/bin/python3\n    # missileControl.py\n    import time\n    import usb.core\n    ```", "```py\n    class SamMissile():\n      idVendor=0x1130\n      idProduct=0x0202\n      idName=\"Tenx Technology SAM Missile\"\n      # Protocol control bytes\n      bmRequestType=0x21\n      bmRequest=0x09\n      wValue=0x02\n      wIndex=0x01\n      # Protocol command bytes\n      INITA     = [ord('U'), ord('S'), ord('B'), ord('C'),\n                   0,  0,  4,  0]\n      INITB     = [ord('U'), ord('S'), ord('B'), ord('C'),\n                   0, 64,  2,  0]\n      CMDFILL   = [ 8,  8,\n                    0,  0,  0,  0,  0,  0,  0,  0,\n                    0,  0,  0,  0,  0,  0,  0,  0,\n                    0,  0,  0,  0,  0,  0,  0,  0,\n                    0,  0,  0,  0,  0,  0,  0,  0,\n                    0,  0,  0,  0,  0,  0,  0,  0,\n                    0,  0,  0,  0,  0,  0,  0,  0,\n                    0,  0,  0,  0,  0,  0,  0,  0]#48 zeros\n      STOP      = [ 0,  0,  0,  0,  0,  0]\n      LEFT      = [ 0,  1,  0,  0,  0,  0]\n      RIGHT     = [ 0,  0,  1,  0,  0,  0]\n      UP        = [ 0,  0,  0,  1,  0,  0]\n      DOWN      = [ 0,  0,  0,  0,  1,  0]\n      LEFTUP    = [ 0,  1,  0,  1,  0,  0]\n      RIGHTUP   = [ 0,  0,  1,  1,  0,  0]\n      LEFTDOWN  = [ 0,  1,  0,  0,  1,  0]\n      RIGHTDOWN = [ 0,  0,  1,  0,  1,  0]\n      FIRE      = [ 0,  0,  0,  0,  0,  1]\n      def __init__(self):\n        self.dev = usb.core.find(idVendor=self.idVendor,\n                                    idProduct=self.idProduct)\n      def move(self,cmd,duration):\n        print(\"Move:%s %d sec\"% (cmd,duration))\n        self.dev.ctrl_transfer(self.bmRequestType,\n                               self.bmRequest,self.wValue,\n                               self.wIndex, self.INITA)\n        self.dev.ctrl_transfer(self.bmRequestType,\n                               self.bmRequest,self.wValue,\n                               self.wIndex, self.INITB)\n        self.dev.ctrl_transfer(self.bmRequestType,\n                               self.bmRequest, self.wValue,\n                               self.wIndex, cmd+self.CMDFILL)\n        time.sleep(duration)\n        self.dev.ctrl_transfer(self.bmRequestType,\n                               self.bmRequest, self.wValue,\n                               self.wIndex, self.INITA)\n        self.dev.ctrl_transfer(self.bmRequestType,\n                               self.bmRequest, self.wValue,\n                               self.wIndex, self.INITB)\n        self.dev.ctrl_transfer(self.bmRequestType,\n                          self.bmRequest, self.wValue,\n                          self.wIndex, self.STOP+self.CMDFILL)\n    ```", "```py\n    class Missile():\n      def __init__(self):\n        print(\"Initialize Missiles\")\n        self.usbDevice=SamMissile()\n\n        if self.usbDevice.dev is not None:\n          print(\"Device Initialized:\" +\n                \" %s\" % self.usbDevice.idName)\n          #Detach the kernel driver if active\n          if self.usbDevice.dev.is_kernel_driver_active(0):\n            print(\"Detaching kernel driver 0\")\n            self.usbDevice.dev.detach_kernel_driver(0)\n          if self.usbDevice.dev.is_kernel_driver_active(1):\n            print(\"Detaching kernel driver 1\")\n            self.usbDevice.dev.detach_kernel_driver(1)\n          self.usbDevice.dev.set_configuration()\n        else:\n          raise Exception(\"Missile device not found\")\n      def __enter__(self):\n        return self\n      def left(self,duration=1):\n        self.usbDevice.move(self.usbDevice.LEFT,duration)\n      def right(self,duration=1):\n        self.usbDevice.move(self.usbDevice.RIGHT,duration)\n      def up(self,duration=1):\n        self.usbDevice.move(self.usbDevice.UP,duration)\n      def down(self,duration=1):\n        self.usbDevice.move(self.usbDevice.DOWN,duration)\n      def fire(self,duration=1):\n        self.usbDevice.move(self.usbDevice.FIRE,duration)\n      def stop(self,duration=1):\n        self.usbDevice.move(self.usbDevice.STOP,duration)\n      def __exit__(self, type, value, traceback):\n        print(\"Exit\")\n    ```", "```py\n    def main():\n      try:\n        with Missile() as myMissile:\n          myMissile.down()\n          myMissile.up()\n      except Exception as detail:\n\n          time.sleep(2)\n        print(\"Error: %s\" % detail)\n\n    if __name__ == '__main__':\n        main()\n    #End\n    ```", "```py\nsudo python3 missileControl.py\n\n```", "```py\n#!/usr/bin/python3\n#missileMenu.py\nimport tkinter as TK\nimport missileControl as MC\n\nBTN_SIZE=10\n\ndef menuInit():\n  btnLeft = TK.Button(root, text=\"Left\",\n                      command=sendLeft, width=BTN_SIZE)   \n  btnRight = TK.Button(root, text=\"Right\",\n                       command=sendRight, width=BTN_SIZE)   \n  btnUp = TK.Button(root, text=\"Up\",\n                    command=sendUp, width=BTN_SIZE)   \n  btnDown = TK.Button(root, text=\"Down\",\n                      command=sendDown, width=BTN_SIZE)\n  btnFire = TK.Button(root, text=\"Fire\",command=sendFire,\n                      width=BTN_SIZE, bg=\"red\")\n  btnLeft.grid(row=2,column=0)\n  btnRight.grid(row=2,column=2)\n  btnUp.grid(row=1,column=1)\n  btnDown.grid(row=3,column=1)\n  btnFire.grid(row=2,column=1)\n\ndef sendLeft():\n  print(\"Left\")\n  myMissile.left()\n\ndef sendRight():\n  print(\"Right\")    \n  myMissile.right()\n\ndef sendUp():\n  print(\"Up\")\n  myMissile.up()\n\ndef sendDown():\n  print(\"Down\")\n  myMissile.down()\n\ndef sendFire():\n  print(\"Fire\")\n  myMissile.fire()\n\nroot = TK.Tk()\nroot.title(\"Missile Command\")\nprompt = \"Select action\"\nlabel1 = TK.Label(root, text=prompt, width=len(prompt),\n                  justify=TK.CENTER, bg='lightblue')\nlabel1.grid(row=0,column=0,columnspan=3)\nmenuInit()\nwith MC.Missile() as myMissile:\n  root.mainloop()\n#End\n```", "```py\nclass ChesenMissile():\n  idVendor=0x0a81\n  idProduct=0x0701\n  idName=\"Chesen Electronics/Dream Link\"\n  # Protocol control bytes\n  bmRequestType=0x21\n  bmRequest=0x09\n  wValue=0x0200\n  wIndex=0x00\n  # Protocol command bytes\n  DOWN    = [0x01]\n  UP      = [0x02]\n  LEFT    = [0x04]\n  RIGHT   = [0x08]\n  FIRE    = [0x10]\n  STOP    = [0x20]\n  def __init__(self):\n    self.dev = usb.core.find(idVendor=self.idVendor,\n                             idProduct=self.idProduct)\n  def move(self,cmd,duration):\n    print(\"Move:%s\"%cmd)\n    self.dev.ctrl_transfer(self.bmRequestType,\n                           self.bmRequest,\n                           self.wValue, self.wIndex, cmd)\n    time.sleep(duration)\n    self.dev.ctrl_transfer(self.bmRequestType,\n                           self.bmRequest, self.wValue,\n                           self.wIndex, self.STOP)\n```", "```py\nclass ThunderMissile():\n  idVendor=0x2123\n  idProduct=0x1010\n  idName=\"Dream Cheeky Thunder\"\n  # Protocol control bytes\n  bmRequestType=0x21\n  bmRequest=0x09\n  wValue=0x00\n  wIndex=0x00\n  # Protocol command bytes\n  CMDFILL = [0,0,0,0,0,0]\n  DOWN    = [0x02,0x01]\n  UP      = [0x02,0x02]\n  LEFT    = [0x02,0x04]\n  RIGHT   = [0x02,0x08]\n  FIRE    = [0x02,0x10]\n  STOP    = [0x02,0x20]\n  def __init__(self):\n    self.dev = usb.core.find(idVendor=self.idVendor,\n                             idProduct=self.idProduct)\n  def move(self,cmd,duration):\n    print(\"Move:%s\"%cmd)\n    self.dev.ctrl_transfer(self.bmRequestType,\n                           self.bmRequest, self.wValue,\n                           self.wIndex, cmd+self.CMDFILL)\n    time.sleep(duration)\n    self.dev.ctrl_transfer(self.bmRequestType,\n                      self.bmRequest, self.wValue,\n                      self.wIndex, self.STOP+self.CMDFILL)\n```", "```py\nclass Missile():\n  def __init__(self):\n    print(\"Initialize Missiles\")\n    self.usbDevice = ThunderMissile()\n```", "```py\nclass OwiArm():\n  idVendor=0x1267\n  idProduct=0x0000\n  idName=\"Owi Robot Arm\"\n  # Protocol control bytes\n  bmRequestType=0x40\n  bmRequest=0x06\n  wValue=0x0100\n  wIndex=0x00\n  # Protocol command bytes\n  BASE_CCW    = [0x00,0x01,0x00]\n  BASE_CW     = [0x00,0x02,0x00]\n  SHOLDER_UP  = [0x40,0x00,0x00]\n  SHOLDER_DWN = [0x80,0x00,0x00]\n  ELBOW_UP    = [0x10,0x00,0x00]\n  ELBOW_DWN   = [0x20,0x00,0x00]\n  WRIST_UP    = [0x04,0x00,0x00]\n  WRIST_DOWN  = [0x08,0x00,0x00]\n  GRIP_OPEN   = [0x02,0x00,0x00]\n  GRIP_CLOSE  = [0x01,0x00,0x00]\n  LIGHT_ON    = [0x00,0x00,0x01]\n  LIGHT_OFF   = [0x00,0x00,0x00]\n  STOP        = [0x00,0x00,0x00]\n```"]