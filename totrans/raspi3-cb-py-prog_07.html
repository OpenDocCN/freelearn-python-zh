<html><head></head><body><div><h1 class="header-title">Creating 3D Graphics</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Getting started with 3D coordinates and vertices</li>
<li>Creating and importing 3D models</li>
<li>Creating a 3D world to explore</li>
<li>Building 3D maps and mazes</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>The chip at the heart of the original Raspberry Pi (a <strong>Broadcom BCM2835</strong> processor) was originally designed to be a <strong>Graphical Processing Unit</strong> (<strong>GPU</strong>) for mobile and embedded applications. The ARM core that drives most of Raspberry Pi's functionality was added because some extra space was available on the chip; this enabled this powerful GPU to be used as a <strong>System-on-Chip</strong> (<strong>SoC</strong>) solution.</p>
<p>An SoC is an integrated service microchip with all the necessary electronic circuits and parts of a computer or electronic system, it is used in smartphones or wearable computers, on a single <strong>integrated circuit</strong> (<strong>IC</strong>).</p>
<p>As you can imagine, if that original ARM core (<strong>ARM1176JZF-S</strong>, which is the <strong>ARMv6</strong> architecture) consisted of only a small part of the chip on Raspberry Pi, you would be right in thinking that the GPU must perform rather well.</p>
<p>The processor at the heart of Raspberry Pi 3 has been upgraded (to a <strong>Broadcom BCM2837</strong> processor); it now contains four ARM cores (<strong>Cortex A53 ARMv8A</strong>), each of which are more powerful than the original <strong>ARMv6</strong>. Coupled with the same GPU from the previous generation, Raspberry Pi 3 is far better equipped to perform the calculations required to build 3D environments. However, although Raspberry Pi 3 will load the examples faster, once the 3D models are generated, both versions of the chip perform just as well.</p>
<p>The <strong>VideoCore IV GPU</strong> consists of 48 purpose-built processors, with some providing support for 1080p high-definition encoding and decoding of video, while others support <strong>OpenGL ES 2.0</strong>, which provides fast calculations for 3D graphics. It has been said that its graphics processing power is equivalent to that of an Apple iPhone 4S and the original Microsoft Xbox. This is even more apparent if you run <strong>Quake 3</strong> or <strong>OpenArena</strong> on Raspberry Pi (go to <a href="http://www.raspberrypi.org/openarena-for-raspberry-pi">http://www.raspberrypi.org/openarena-for-raspberry-pi</a> for details).</p>
<p>In this chapter, I hope to show you that while you can achieve a lot by performing operations using the ARM side of Raspberry Pi, if you venture to the side where the GPU is hidden, you may see that there is even more to this little computer than what first appears.</p>
<p>The <kbd>pi3d</kbd> library created by the <kbd>pi3d</kbd> team (Patrick Gaunt, Tom Swirly, Tim Skillman, and others) provides a way to put the GPU to work by creating 3D graphics.</p>
<p>The <kbd>pi3d</kbd> Wiki and documentation pages can be found at the following link: <a href="http://pi3d.github.io/html/index.html">http://pi3d.github.io/html/index.html.<br/></a></p>
<p>The support/development group can be found at the following link: <a href="https://groups.google.com/forum/#!forum/pi3d">https://groups.google.com/forum/#!forum/pi3d.<br/></a></p>
<p>The library contains many features, so it will not be possible to cover everything that is available in the following examples. It is recommended that you also take some time to try out the <kbd>pi3d</kbd> demos. To discover more options for the creation and handling of the 3D graphics, you can have a look through some of the Python modules which make up the library itself (described in the documentation or the code on GitHub at <a href="https://github.com/pi3d/pi3d.github.com">https://github.com/pi3d/pi3d.github.com</a>). It is hoped that this chapter will introduce you to enough concepts to illustrate some of the raw potential available to you.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting started with 3D coordinates and vertices</h1>
                
            
            
                
<p>The world around us is three-dimensional, so in order to simulate parts of the world, we can create a 3D representation and display it on our 2D screen.</p>
<p>Raspberry Pi enables us to simulate a 3D space, place 3D objects within it, and observe them from a selected viewpoint. We will use the GPU to produce a representation of the 3D view as a 2D image to display it on the screen.</p>
<p>The following example will show you how we can use <kbd>pi3d</kbd> (an OpenGL ES library for Raspberry Pi) to place a single 3D object and display it within the 3D space. We will then allow the mouse to rotate the view around the object:</p>
<div><img src="img/3088707e-2c3a-49c2-b58a-3081dccd415c.png" style="width:20.67em;height:15.92em;" width="620" height="476"/></div>
<p>Single 3D object</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Raspberry Pi must be directly connected to a display, either via the HDMI or an analog video output. The 3D graphics rendered by the GPU will only be displayed on a local display, even if you are connecting to Raspberry Pi remotely over a network. You will also need to use a locally connected mouse for control (however, keyboard control does work via a SSH connection).</p>
<p>The first time we use <kbd>pi3d</kbd>, we will need to download and install it via the following steps:</p>
<ol>
<li>The <kbd>pi3d</kbd> library uses Pillow, a version of the Python Imaging Library that is compatible with Python 3, to import graphics used in models (such as textures<br/>
and backgrounds).</li>
</ol>
<p style="padding-left: 60px">The installation of Pillow has been covered in the <em>Getting ready</em> section of <a href="eb11b6c6-b334-42e0-941c-5d32db18cc9d.xhtml" target="_blank">Chapter 3</a>, <em>Using Python for Automation and Productivity</em>.</p>
<p style="padding-left: 60px">The commands for the installation are shown in the following code (if you've installed them before, it will skip them and continue):</p>
<pre style="padding-left: 60px"><strong>sudo apt-get update</strong>
<strong>sudo apt-get install python3-pip</strong>
<strong>sudo apt-get install libjpeg-dev</strong>
<strong>sudo pip-3.2 install pillow</strong>  </pre>
<ol start="2">
<li>We can now use <kbd>pip</kbd> to install <kbd>pi3d</kbd> using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo pip-3.2 install pi3d</strong>    </pre>
<p>The <kbd>pi3d</kbd> team is continuously developing and improving the library; if you are experiencing problems, it may mean that a new release is not compatible with the previous ones.<br/>
<br/>
You can also check in the Appendix, <em>Hardware and Software List</em>, to confirm which version of <kbd>pi3d</kbd> you have and, if required, install the same version listed. Alternatively, contact the <kbd>pi3d</kbd> team via the Google group; they will be happy to help!<br/>
<br/>
Obtain <kbd>pi3d</kbd> demos from the GitHub site, as shown in the following command lines. You will need around 90 MB of free space to download and extract the files:<br/>
<br/>
<kbd>  cd ~</kbd><br/>
<br/>
<kbd>  wget <br/>
  https://github.com/pi3d/pi3d_demos/archive/master.zip</kbd><br/>
<br/>
<kbd>  unzip master.zip</kbd><br/>
<br/>
<kbd>  rm master.zip</kbd></p>
<p style="padding-left: 60px">You will find that the demos have been unpacked to <kbd>pi3d_demos-master</kbd>.</p>
<p style="padding-left: 60px">By default, the demos are expected to be located at <kbd>home/pi/pi3d</kbd>; therefore, we will rename this directory <kbd>pi3d</kbd>, as shown in the following command:</p>
<pre style="padding-left: 60px"><strong>mv pi3d_demos-master pi3d</strong>  </pre>
<ol start="3">
<li>Finally, check the Raspberry Pi memory split. Run <kbd>raspi-config</kbd> (<kbd>sudo raspi-config</kbd>) and ensure that your memory split is set to 128. (You should only need to do this if you have changed it in the past, as 128 MB is the default.) This ensures that you have plenty of RAM allocated for the GPU, so it will be able to handle lots of 3D objects if required.</li>
<li>Test if everything is working properly. You should now be able to run any of the scripts in the <kbd>pi3d_demos-master</kbd> directory. See the <kbd>pi3d</kbd> Wiki pages for details on how they function (<a href="http://pi3d.github.io/html/ReadMe.html">http://pi3d.github.io/html/ReadMe.html</a>). To get the best performance, it is recommended that the scripts are run from the command prompt (without loading the desktop):</li>
</ol>
<pre style="padding-left: 60px"><strong>cd pi3d</strong>
<strong>python3 Raspberry_Rain.py</strong>     </pre>
<p>The <kbd>pi3d.Keyboard</kbd> object also supports keyboard control via SSH (see the <em>Connecting remotely to Raspberry Pi over the network using SSH (and X11 forwarding)</em> section of <a href="b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml" target="_blank">Chapter 1</a>, <em>Getting Started with a Raspberry Pi 3 Computer</em>).<br/>
<br/>
Configure the setup for your own scripts. Since we will use some of the textures and models from the demos, it is recommended that you create your scripts within the <kbd>pi3d</kbd> directory. If you have a username that's different from the default Pi account, you will need to adjust <kbd>/pi3d/demo.py</kbd>. Replace the <kbd>USERNAME</kbd> part with your own username by editing the file:<br/>
<br/>
<kbd>  nano ~/pi3d/demo.py</kbd><br/>
<br/>
<kbd>  import sys</kbd><br/>
<br/>
<kbd>  sys.path.insert(1, '/home/USERNAME/pi3d')</kbd></p>
<p style="padding-left: 60px">If you want to relocate your files somewhere else, ensure that you add a copy of <kbd>demo.py</kbd> in the folder with the correct path to any resource files you require.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create the following <kbd>3dObject.py</kbd> script:</p>
<pre>#!/usr/bin/python3 
""" Create a 3D space with a Tetrahedron inside and rotate the 
    view around using the mouse. 
""" 
from math import sin, cos, radians 
 
import demo 
import pi3d 
 
KEY = {'ESC':27,'NONE':-1} 
 
DISPLAY = pi3d.Display.create(x=50, y=50) 
#capture mouse and key presses 
mykeys = pi3d.Keyboard() 
mymouse = pi3d.Mouse(restrict = False) 
mymouse.start() 
 
def main(): 
  CAMERA = pi3d.Camera.instance() 
  tex = pi3d.Texture("textures/stripwood.jpg") 
  flatsh = pi3d.Shader("uv_flat") 
 
  #Define the coordinates for our shape (x,y,z)  
  A = (-1.0,-1.0,-1.0) 
  B = (1.0,-1.0,1.0) 
  C = (-1.0,-1.0,1.0) 
  D = (-1.0,1.0,1.0) 
  ids = ["A","B","C","D"] 
  coords = [A,B,C,D] 
  myTetra = pi3d.Tetrahedron(x=0.0, y=0.0, z=0.0, 
                             corners=(A,B,C,D)) 
  myTetra.set_draw_details(flatsh,[tex]) 
  # Load ttf font and set the font to black 
  arialFont = pi3d.Font("fonts/FreeMonoBoldOblique.ttf", 
                        "#000000") 
  mystring = [] 
  #Create string objects to show the coordinates 
  for i,pos in enumerate(coords): 
    mystring.append(pi3d.String(font=arialFont, 
                            string=ids[i]+str(pos), 
                            x=pos[0], y=pos[1],z=pos[2])) 
    mystring.append(pi3d.String(font=arialFont, 
                            string=ids[i]+str(pos), 
                            x=pos[0], y=pos[1],z=pos[2], ry=180)) 
  for string in mystring: 
    string.set_shader(flatsh) 
 
  camRad = 4.0 # radius of camera position 
  rot = 0.0 # rotation of camera 
  tilt = 0.0 # tilt of camera 
  k = KEY['NONE'] 
  omx, omy = mymouse.position() 
   
  # main display loop 
  while DISPLAY.loop_running() and not k == KEY['ESC']: 
    k = mykeys.read() 
    mx, my = mymouse.position() 
    rot -= (mx-omx)*0.8 
    tilt += (my-omy)*0.8 
    omx = mx 
    omy = my 
 
    CAMERA.reset() 
    CAMERA.rotate(-tilt, rot, 0) 
    CAMERA.position((camRad * sin(radians(rot)) * 
                     cos(radians(tilt)),  
                     camRad * sin(radians(tilt)),  
                     -camRad * cos(radians(rot)) * 
                     cos(radians(tilt)))) 
    #Draw the Tetrahedron 
    myTetra.draw() 
    for string in mystring: 
      string.draw() 
 
try: 
  main() 
finally: 
  mykeys.close() 
  mymouse.stop() 
  DISPLAY.destroy() 
  print("Closed Everything. END") 
#End </pre>
<p>To run the script, use <kbd>python3 3dObject.py</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We import the <kbd>math</kbd> modules (for angle calculations used to control the view based on mouse movements). We also import the demo module, which just provides the path to the <strong>shaders</strong> and <strong>textures</strong> in this example.</p>
<p>We start by defining some key elements that will be used by <kbd>pi3d</kbd> to generate and display our object. The space in which we shall place our object is the <kbd>pi3d.Display</kbd> object; this defines the size of the space and initializes the screen to generate and display OpenGL ES graphics.</p>
<p>Next, we define a <kbd>pi3d.Camera</kbd> object, which will allow us to define how we view the<br/>
object within our space. To render our object, we define a texture to be applied to the surface and a shader that will apply the texture to the object. The shader is used to apply all the effects and lighting to the object, and it is coded to use the GPU's OpenGL ES core instead of the ARM processor.</p>
<p>We define the <kbd>keyboard</kbd> and <kbd>mouse</kbd> object using <kbd>pi3d.keyboard()</kbd> and <kbd>pi3d.mouse()</kbd> so that we can respond to the keyboard and mouse input. The <kbd>restrict</kbd> flag of the <kbd>mouse</kbd> object allows the absolute mouse position to continue past the screen limits (so we can continuously rotate our 3D object). The main loop, when running, will check if the <em>Esc</em> key is pressed and will then close everything down (including calling <kbd>DISPLAY.destroy()</kbd> to release the screen). We use the <kbd>try: finally:</kbd> method to ensure that the display is closed correctly, even if there is an exception within <kbd>main()</kbd>.</p>
<p>The mouse movement is collected in the main display loop using <kbd>mymouse.position()</kbd>, which returns the <em>x</em> and <em>y</em> coordinates. The difference in the <em>x</em> and <em>y</em> movement is used to rotate around the object.</p>
<p>The mouse movements determine the position and angle of the camera. Any adjustment to the forward/backward position of the mouse is used to move it over or under the object and change the angle of the camera (using <kbd>tilt</kbd>) so it remains pointing at the object. Similarly, any sideways movement will move the camera around the object using the <kbd>CAMERA.reset()</kbd> function. This ensures that the display updates the camera view with the new position, <kbd>CAMERA.rotate()</kbd>, to change the angle, and uses <kbd>CAMERA.position()</kbd> to move the camera to a position around the object, <kbd>camRad</kbd> units away from its center.</p>
<p>We will draw a three-dimensional object called a <strong>tetrahedron</strong>, a shape made up of four triangles to form a pyramid with a triangular base. The four corners of the shape (three around the base and one at the top) will be defined by the three-dimensional coordinates <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, and <strong>D</strong>, as shown in the following diagram:</p>
<div><img src="img/5d899fc4-3493-449d-af5a-d1f8bd962c48.png" style="width:19.75em;height:14.42em;" width="1089" height="792"/></div>
<p>The tetrahedron placed within the 3D coordinates</p>
<p>The <kbd>pi3d.Tetrahedron</kbd> object is defined by specifying <em>x</em>, <em>y,</em> and <em>z</em> coordinates of four points to position it in the space and then specify the corners that will be joined to form the four triangles that make up the shape.</p>
<p>Using <kbd>set_draw_details(flatsh,[text])</kbd>, we apply the shader(s) we wish to use and the texture(s) for the object. In our example, we are just using a single texture, but some shaders can use several textures for complex effects.</p>
<p>To help highlight where the coordinates are, we will add some <kbd>pi3d.String</kbd> objects by setting the string text to specify the ID and coordinates next to them and placing it at the required location. We will create two string objects for each location, one facing forward and another facing backward (<kbd>ry=180</kbd> rotates the object by 180 degrees on the <em>y</em> axis). The <kbd>pi3d.String</kbd> objects are single-sided, so if we only had one side facing forward, it wouldn't be visible from behind when the view was rotated and would just disappear (plus, if it was visible, the text would be backwards anyway). Again, we use the <kbd>flatsh</kbd> shader to render it using the <kbd>set_shader()</kbd> string object.</p>
<p>All that is left to do now is to draw our tetrahedron and the string objects while checking for any keyboard events. Each time the <kbd>while</kbd> loop completes, <kbd>DISPLAY.loop_running()</kbd> is called, which will update the display with any adjustments to the camera as required.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>In addition to introducing how to draw a basic object within the 3D space, the preceding example makes use of the following four key elements used in 3D graphics programming.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Camera</h1>
                
            
            
                
<p>The camera represents our view in the 3D space; one way to explore and see more of the space is by moving the camera. The <kbd>Camera</kbd> class is defined as follows:</p>
<pre>pi3d.Camera.Camera(at=(0, 0, 0), eye=(0, 0, -0.1), 
                   lens=None, is_3d=True, scale=1.0) </pre>
<p>The camera is defined by providing two locations, one to look at (usually the object we wish to see, defined by <kbd>at</kbd>) and another to look from (the object's position, defined by <kbd>eye</kbd>). Other features of the camera, such as its field of view (<kbd>lens</kbd>) and so on, can be adjusted or used with the default settings.</p>
<p>If we didn't define a camera in our display, a default one will be created that points at the origin (the center of the display, that is, <kbd>0,0,0</kbd>), positioned slightly in front of it (<kbd>0,0,-0.1</kbd>).<br/>
<br/>
See the <kbd>pi3d</kbd> documentation regarding the camera module for more details.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Shaders</h1>
                
            
            
                
<p>Shaders are very useful as they allow a lot of the complex work required to apply textures and lighting to an object by offloading the task to the more powerful GPU in Raspberry Pi. The <kbd>Shader</kbd> class is defined as follows:</p>
<pre>class pi3d.Shader.Shader(shfile=None, vshader_source=None, 
                                      fshader_source=None) </pre>
<p>This allows you to specify a shader file (<kbd>shfile</kbd>) and specific vertex and fragment shaders (if required) within the file.</p>
<p>There are several shaders included in the <kbd>pi3d</kbd> library, some of which allow multiple textures to be used for reflections, close-up details, and transparency effects. The implementation of the shader will determine how the lights and textures are applied to the object (and in some cases, such as <kbd>uv_flat</kbd>, the shader will ignore any lighting effects).</p>
<p>The shader files are listed in the <kbd>pi3dshaders</kbd> directory. Try experimenting with different shaders, such as <kbd>mat_reflect</kbd>, which will ignore the textures/fonts but still apply the lighting effects, or <kbd>uv_toon</kbd>, which will apply a cartoon effect to the texture.</p>
<p>Each shader consists of two files, <kbd>vs</kbd> (vertex shader) and <kbd>fs</kbd> (fragment shader), written in C-like code. They work together to apply the effects to the object as desired. The vertex shader is responsible for mapping the 3D location of the vertices to the 2D display. The fragment shader (sometimes called the pixel shader) is responsible for applying lighting and texture effects to the pixels themselves. The construction and operation of these shaders is well beyond the scope of this chapter, but there are several example shaders that you can compare, change, and experiment with within the <kbd>pi3dshaders</kbd> directory.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Lights</h1>
                
            
            
                
<p>Lighting is very important in a 3D world; it could range from simple general lighting (as used in our example) to multiple lights angled from different directions providing different strengths and colors. How lights interact with objects and the effects they produce will be determined by the textures and shaders used to render them.</p>
<p>Lights are defined by their direction, their color and brightness, and also by an ambient light to define the background (non-directional) light. The <kbd>Light</kbd> class is defined as follows:</p>
<pre>class pi3d.Light (lightpos=(10, -10, 20), 
                       lightcol=(1.0, 1.0, 1.0), 
                       lightamb=(0.1, 0.1, 0.2)) </pre>
<p>By default, the display will define a light that has the following properties:<br/>
<ul>
<li><kbd>lightpos=(10, -10, 20)</kbd>: This is a light that shines from the front of the space (near the top-left side) down towards the back of the space (towards the right)</li>
</ul>
<ul>
<li><kbd>lightcol=(1.0, 1.0, 1.0)</kbd>: This is a bright, white, directional light (the direction is defined in the preceding dimension, and it is the color defined by the RGB values <kbd>1.0, 1.0, 1.0</kbd>)</li>
</ul>
<ul>
<li><kbd>ightamb=(0.1, 0.1, 0.2)</kbd>: This is overall a dull, slightly bluish light</li>
</ul>
</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Textures</h1>
                
            
            
                
<p>Textures are able to add realism to an object by allowing fine detail to be applied to the object's surface; this could be an image of bricks for a wall or a person's face displayed on the character. When a texture is used by the shader, it can often be rescaled and reflection can be added to it; some shaders even allow you to apply surface detail.</p>
<p>We can apply multiple textures to an object to combine them and produce different effects; it will be up to the shader to determine how they are applied.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating and importing 3D models</h1>
                
            
            
                
<p>Creating complex shapes directly from code can often be cumbersome and time-consuming. Fortunately, it is possible to import prebuilt models into your 3D space.</p>
<p>It is even possible to use graphical 3D modeling programs to generate models and then export them as a suitable format for you to use. This example produces a Newell Teapot<br/>
in the Raspberry Pi theme, as shown in the following screenshot:</p>
<div><img src="img/10aa71ca-a743-4972-a7f3-0a32fdbd9dcd.png" style="width:25.75em;height:19.00em;" width="433" height="318"/></div>
<p>Newell Raspberry Pi teapot</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We shall use 3D models of a teapot (both <kbd>teapot.obj</kbd> and <kbd>teapot.mdl</kbd>) located in<br/>
<kbd>pi3dmodels</kbd>.</p>
<p>Modeling a teapot is the traditional 3D equivalent of displaying <em>Hello World</em>. Computer graphics researcher Martin Newell first created the Newell Teapot in 1975 as a basic test model for his work. The Newell Teapot soon became the standard model to quickly check if a 3D rendering system was working correctly (it even appeared in <em>Toy Story</em> and a 3D episode of <em>The Simpsons</em>).<br/>
<br/>
Other models are available in the <kbd>pi3dmodels</kbd> directory (<kbd>monkey.obj/mdl</kbd>, which has been used later on, is available in the book's resource files).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create and run the following <kbd>3dModel.py</kbd> script:</p>
<pre>#!/usr/bin/python3 
""" Wavefront obj model loading. Material properties set in 
    mtl file. Uses the import pi3d method to load *everything* 
""" 
import demo 
import pi3d 
from math import sin, cos, radians 
 
KEY = {'ESC':27,'NONE':-1} 
 
# Setup display and initialise pi3d 
DISPLAY = pi3d.Display.create() 
#capture mouse and key presses 
mykeys = pi3d.Keyboard() 
mymouse = pi3d.Mouse(restrict = False) 
mymouse.start() 
   
def main(): 
  #Model textures and shaders 
  shader = pi3d.Shader("uv_reflect") 
  bumptex = pi3d.Texture("textures/floor_nm.jpg") 
  shinetex = pi3d.Texture("textures/stars.jpg") 
  # load model 
  #mymodel = pi3d.Model(file_string='models/teapot.obj', z=10) 
  mymodel = pi3d.Model(file_string='models/monkey.obj', z=10) 
  mymodel.set_shader(shader) 
  mymodel.set_normal_shine(bumptex, 4.0, shinetex, 0.5) 
 
  #Create environment box 
  flatsh = pi3d.Shader("uv_flat") 
  ectex = pi3d.loadECfiles("textures/ecubes","sbox") 
  myecube = pi3d.EnvironmentCube(size=900.0, maptype="FACES", 
                                 name="cube") 
  myecube.set_draw_details(flatsh, ectex) 
     
  CAMERA = pi3d.Camera.instance() 
  rot = 0.0 # rotation of camera 
  tilt = 0.0 # tilt of camera 
  k = KEY['NONE'] 
  omx, omy = mymouse.position() 
     
  while DISPLAY.loop_running() and not k == KEY['ESC']: 
    k = mykeys.read() 
    #Rotate camera - camera steered by mouse 
    mx, my = mymouse.position() 
    rot -= (mx-omx)*0.8 
    tilt += (my-omy)*0.8 
    omx = mx 
    omy = my 
    CAMERA.reset() 
    CAMERA.rotate(tilt, rot, 0) 
    #Rotate object 
    mymodel.rotateIncY(2.0) 
    mymodel.rotateIncZ(0.1) 
    mymodel.rotateIncX(0.3) 
    #Draw objects 
    mymodel.draw() 
    myecube.draw() 
 
try: 
  main() 
finally: 
  mykeys.close() 
  mymouse.stop() 
  DISPLAY.destroy() 
  print("Closed Everything. END") 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Like the <kbd>3dObject.py</kbd> example, we define the <kbd>DISPLAY</kbd> shader (this time using <kbd>uv_reflect</kbd>) and some additional textures—<kbd>bumptex</kbd> (<kbd>floor_nm.jpg</kbd>) and <kbd>shinetex</kbd> (<kbd>stars.jpg</kbd>)—to use later. We define a model that we want to import, placing it at <kbd>z=10</kbd> (if no coordinates are given, it will be placed at <kbd>(0,0,0)</kbd>). Since we do not specify a camera position, the default will place it within the view (see the section regarding the camera for more details).</p>
<p>We apply the shader using the <kbd>set_shader()</kbd> function. Next, we add some textures and effects using <kbd>bumptex</kbd> as a surface texture (scaled by <kbd>4</kbd>). We apply an extra shiny effect using <kbd>shinetex</kbd> and apply a reflection strength of <kbd>0.5</kbd> (the strength ranges from 0.0, the weakest, to 1.0, the strongest) using the <kbd>set_normal_shine()</kbd> function. If you look closely at the surface of the model, the <kbd>bumptex</kbd> texture provides additional surface detail and the <kbd>shinetex</kbd> texture can be seen as the reflection on the surface.</p>
<p>To display our model within something more interesting than a default blue space, we will create an <kbd>EnvironmentCube</kbd> object. This defines a large space that has a special texture applied to the inside space (in this instance, it will load the <kbd>sbox_front/back/bottom/left</kbd> and <kbd>sbox_right</kbd> images from the <kbd>texturesecubes</kbd> directory), so it effectively encloses the objects within. The result is that you get a pleasant backdrop for your object.</p>
<p>Again, we define a default <kbd>CAMERA</kbd> object with <kbd>rot</kbd> and <kbd>tilt</kbd> variables to control the view. Within the <kbd>DISPLAY.loop_running()</kbd> section, we can control the view of the<br/>
<kbd>CAMERA</kbd> object using the mouse and rotate the model on its axis at different rates to let it<br/>
spin and show all its sides (using the <kbd>RotateIncX/Y/Z()</kbd> function to specify the rate of rotation). Finally, we ensure that the <kbd>DISPLAY</kbd> is updated by drawing the model and the environment cube.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We can create a wide range of objects to place within our simulated environment. <kbd>pi3d</kbd> provides methods to import our own models and apply multiple textures to them.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating or loading your own objects</h1>
                
            
            
                
<p>If you wish to use your own models in this example, you shall need to create one in the correct format; <kbd>pi3d</kbd> supports <strong>obj</strong> (wavefront object files) and <strong>egg</strong> (Panda3D).</p>
<p>An excellent, free, 3D modeling program is called <strong>Blender</strong> (available at <a href="http://www.blender.org">http://www.blender.org</a>). There are lots of examples and tutorials on their website to get you started with basic modeling (<a href="http://www.blender.org/education-help/tutorials">http://www.blender.org/education-help/tutorials</a>).</p>
<p>The <kbd>pi3d</kbd> model support is limited and will not support all the features that Blender can embed in an exported model, for example, deformable meshes. Therefore, only basic multipart models are supported. There are a few steps required to simplify the model so it can be loaded by <kbd>pi3d</kbd>.</p>
<p>To convert an <kbd>.obj</kbd> model to use it with <kbd>pi3d</kbd>, proceed with the following steps:</p>
<ol>
<li>Create or load a model in Blender—try starting with a simple object before attempting more complex models.</li>
<li>Select each Object and switch to Edit mode (press <em>Tab</em>).</li>
<li>Select all vertices (press <em>A</em>) and uv-map them (press <em>U</em> and then select Unwrap).</li>
<li>Return to Object mode (press <em>Tab</em>).</li>
<li>Export it as obj – from the File menu at the top, select Export, and then select Wavefront (.obj). Ensure that Include Normals is also checked in the list of options in the bottom-left list.</li>
<li>Click on Save and place the <kbd>.obj</kbd> and <kbd>.mtl</kbd> files in the <kbd>pi3dmodels</kbd> directory, and ensure that you update the script with the model's filename, as follows:</li>
</ol>
<pre style="padding-left: 60px">mymodel = pi3d.Model(file_string='models/monkey.obj', <br/>   name='monkey', z=4) </pre>
<p>When you run your updated script, you will see your model displayed in the 3D space. For example, the <kbd>monkey.obj</kbd> model is shown in the following screenshot:</p>
<div><img src="img/a9ce19a7-cf62-4b7d-b35d-b23f73fc4d13.png" style="width:33.67em;height:26.92em;" width="720" height="576"/></div>
<p>A monkey head model created in Blender and displayed by pi3d</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Changing the object's textures and .mtl files</h1>
                
            
            
                
<p>The texture that is applied to the surface of the model is contained within the <kbd>.mtl</kbd> file of the model. This file defines the textures and how they are applied as set by the modeling software. Complex models may contain multiple textures for various parts of the object.</p>
<p>If no material is defined, the first texture in the shader is used (in our example, this is the <kbd>bumptex</kbd> texture). To add a new texture to the object, add (or edit) the following line in the <kbd>.mtl</kbd> file (that is, to use <kbd>water.jpg</kbd>):</p>
<pre>map_Kd ../textures/water.jpg </pre>
<p>More information about <kbd>.mtl</kbd> files and <kbd>.obj</kbd> files can be found at the following<br/>
Wikipedia link: <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">https://en.wikipedia.org/wiki/Wavefront_.obj_file.</a><a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file"> </a></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Taking screenshots</h1>
                
            
            
                
<p>The <kbd>pi3d</kbd> library includes a useful screenshot function to capture the screen in a <kbd>.jpg</kbd> or <kbd>.png</kbd> file. We can add a new key event to trigger it and call <kbd>pi3d.screenshot("filename.jpg")</kbd> to save an image (or use a counter to take multiple screenshots), as shown in the following code:</p>
<pre>shotnum = 0 #Set counter to 0 
while DISPLAY.loop_running() 
... 
  if inputs.key_state("KEY_P"): 
    while inputs.key_state("KEY_P"): 
      inputs.do_input_events()         # wait for key to go up 
      pi3d.screenshot("screenshot%04d.jpg"%( shotnum)) 
      shotnum += 1 
... </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating a 3D world to explore</h1>
                
            
            
                
<p>Now that we are able to create models and objects within our 3D space, as well as<br/>
generate backgrounds, we may want to create a more interesting environment within<br/>
which to place them.</p>
<p>3D terrain maps provide an elegant way to define very complex landscapes. The terrain is defined using a grayscale image to set the elevation of the land. The following example shows how we can define our own landscape and simulate flying over it, or even walk on its surface:</p>
<div><img src="img/e134ca0e-20c3-47c1-a71e-b9002102403f.png" style="width:21.33em;height:16.33em;" width="620" height="476"/></div>
<p>A 3D landscape generated from a terrain map</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need to place the <kbd>Map.png</kbd> file (available in the book resource files) in the <kbd>pi3d/textures</kbd> directory of the <kbd>pi3d</kbd> library. Alternatively, you can use one of the elevation maps already present—replace the reference to <kbd>Map.png</kbd> with another one of the elevation maps, such as <kbd>testislands.jpg</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create the following <kbd>3dWorld.py</kbd> script:</p>
<pre>#!/usr/bin/python3 
from __future__ import absolute_import, division 
from __future__ import print_function, unicode_literals 
""" An example of generating a 3D environment using a elevation map 
""" 
from math import sin, cos, radians 
import demo 
import pi3d 
 
KEY = {'R':114,'S':115,'T':116,'W':119,'ESC':27,'NONE':-1} 
 
DISPLAY = pi3d.Display.create(x=50, y=50) 
#capture mouse and key presses 
mykeys = pi3d.Keyboard() 
mymouse = pi3d.Mouse(restrict = False) 
mymouse.start() 
 
def limit(value,min,max): 
  if (value &lt; min): 
    value = min 
  elif (value &gt; max): 
    value = max 
  return value 
 
def main(): 
  CAMERA = pi3d.Camera.instance() 
  tex = pi3d.Texture("textures/grass.jpg") 
  flatsh = pi3d.Shader("uv_flat") 
  # Create elevation map 
  mapwidth,mapdepth,mapheight = 200.0,200.0,50.0 
  mymap = pi3d.ElevationMap("textures/Map.png", 
                width=mapwidth, depth=mapdepth, height=mapheight, 
                divx=128, divy=128, ntiles=20) 
  mymap.set_draw_details(flatsh, [tex], 1.0, 1.0) 
 
  rot = 0.0 # rotation of camera 
  tilt = 0.0 # tilt of camera 
  height = 20 
  viewhight = 4 
  sky = 200 
  xm,ym,zm = 0.0,height,0.0 
  k = KEY['NONE'] 
  omx, omy = mymouse.position() 
  onGround = False 
  # main display loop 
  while DISPLAY.loop_running() and not k == KEY['ESC']: 
    CAMERA.reset() 
    CAMERA.rotate(-tilt, rot, 0) 
    CAMERA.position((xm,ym,zm)) 
    mymap.draw() 
    
    mx, my = mymouse.position() 
    rot -= (mx-omx)*0.8 
    tilt += (my-omy)*0.8 
    omx = mx 
    omy = my 
 
    #Read keyboard keys 
    k = mykeys.read() 
    if k == KEY['W']: 
      xm -= sin(radians(rot)) 
      zm += cos(radians(rot)) 
    elif k == KEY['S']: 
      xm += sin(radians(rot)) 
      zm -= cos(radians(rot)) 
    elif k == KEY['R']: 
      ym += 2 
      onGround = False 
    elif k == KEY['T']: 
      ym -= 2 
    ym -= 0.1 #Float down! 
    #Limit the movement 
    xm = limit(xm,-(mapwidth/2),mapwidth/2) 
    zm = limit(zm,-(mapdepth/2),mapdepth/2) 
    if ym &gt;= sky: 
      ym = sky 
    #Check onGround 
    ground = mymap.calcHeight(xm, zm) + viewhight 
    if (onGround == True) or (ym &lt;= ground): 
      ym = mymap.calcHeight(xm, zm) + viewhight 
      onGround = True 
 
try: 
  main() 
finally: 
  mykeys.close() 
  mymouse.stop() 
  DISPLAY.destroy() 
  print("Closed Everything. END") 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Once we have defined the display, camera, textures, and shaders that we are going to use, we can define the <kbd>ElevationMap</kbd> object.</p>
<p>It works by assigning a height to the terrain image based on the pixel value of the selected points of the image. For example, a single line of an image will provide a slice of the <kbd>ElevationMap</kbd> object and a row of elevation points on the 3D surface:</p>
<div><img src="img/6621618c-a3c5-4eb0-ba4e-af33aaf25ad1.png" style="width:22.00em;height:18.58em;" width="832" height="701"/></div>
<p>Mapping the map.png pixel shade to the terrain height</p>
<p>We create an <kbd>ElevationMap</kbd> object by providing the filename of the image we will use for the gradient information (<kbd>textures/Map.png</kbd>), and we also create the dimensions of the map (<kbd>width</kbd>, <kbd>depth</kbd>, and <kbd>height</kbd>—which is how high the white spaces will be compared to the black spaces):</p>
<div><img src="img/acf91238-7e92-4cb2-943a-aca1ef10a20e.png" style="width:20.00em;height:20.08em;" width="256" height="256"/></div>
<p>ElevationMap object</p>
<p>The <kbd>Map.png</kbd> texture provides an example terrain map, which is converted into a<br/>
three-dimensional surface.</p>
<p>We also specify <kbd>divx</kbd> and <kbd>divy</kbd>, which determine how much detail of the terrain map is used (how many points from the terrain map are used to create the elevation surface). Finally, <kbd>ntiles</kbd> specifies that the texture used will be scaled to fit <kbd>20 times</kbd> across the surface.</p>
<p>Within the main <kbd>DISPLAY.loop_running()</kbd> section, we will control the camera, draw <kbd>ElevationMap</kbd>, respond to inputs, and limit movements in our space.</p>
<p>As before, we use a <kbd>Keyboard</kbd> object to capture mouse movements and translate them to control the camera. We will also use <kbd>mykeys.read()</kbd> to determine if <em>W</em>, <em>S</em>, <em>R</em>, and <em>T</em> have been pressed, which allow us to move forward and backwards, as well as rise up and down.</p>
<p>To allow easy conversion between the values returned from the   and their equivalent meaning, we will use a Python dictionary:<br/>
<br/>
<kbd>  KEY = {'R':114,'S':115,'T':116,'W':119,'ESC':27,'NONE':-1}</kbd><br/>
<br/>
The dictionary provides an easy way to translate between a given value and the resulting string. To access a key's value, we use <kbd>KEY['W']</kbd>. We also used a dictionary in <a href="eb11b6c6-b334-42e0-941c-5d32db18cc9d.xhtml" target="_blank">Chapter 3</a>, <em>Using Python for Automation and Productivity</em>, to translate between the image EXIF tag names and IDs.</p>
<p>To ensure that we do not fall through the surface of the <kbd>ElevationMap</kbd> object when<br/>
we move over it, we can use <kbd>mymap.calcHeight()</kbd> to provide us with the height of<br/>
the terrain at a specific location (<kbd>x,y,z</kbd>). We can either follow the ground by ensuring the camera is set to equal this, or fly through the air by just ensuring that we never go below it. When we detect that we are on the ground, we ensure that we remain on the ground until<br/>
we press <em>R</em> to rise again.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Building 3D maps and mazes</h1>
                
            
            
                
<p>We've seen that the <kbd>pi3d</kbd> library can be used to create lots of interesting objects and environments. Using some of the more complex classes (or by constructing our own), whole custom spaces can be designed for the user to explore.</p>
<p>In the following example, we use a special module called <strong>Building</strong>, which has been designed to allow you to construct a whole building using a single image file to provide the layout:</p>
<div><img src="img/3928fd78-57bb-4112-a73b-c18c94c9d64b.png" style="width:35.33em;height:28.25em;" width="720" height="576"/></div>
<p>Exploring the maze and finding the sphere that marks the exit</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need to ensure that you have the following files in the <kbd>pi3d/textures</kbd> directory:</p>
<ul>
<li><kbd>squareblocksred.png</kbd></li>
<li><kbd>floor.png</kbd></li>
<li><kbd>inside_map0.png</kbd>, <kbd>inside_map1.png</kbd>, <kbd>inside_map2.png</kbd></li>
</ul>
<p>These files are available as part of the book's resources placed in <kbd>Chapter07resourcesource_filestextures</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's run the following <kbd>3dMaze.py</kbd> script by performing the following steps:</p>
<ol>
<li>First, we set up the keyboard, mouse, display, and settings for the model using the following code:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
"""Small maze game, try to find the exit 
""" 
from math import sin, cos, radians 
import demo 
import pi3d 
from pi3d.shape.Building import Building, SolidObject 
from pi3d.shape.Building import Size, Position 
 
KEY = {'A':97,'D':100,'H':104,'R':114,'S':115,'T':116, 
       'W':119,'ESC':27,'APOST':39,'SLASH':47,'NONE':-1} 
 
# Setup display and initialise pi3d 
DISPLAY = pi3d.Display.create() 
#capture mouse and key presses 
mykeys = pi3d.Keyboard() 
mymouse = pi3d.Mouse(restrict = False) 
 
#Load shader 
shader = pi3d.Shader("uv_reflect") 
flatsh = pi3d.Shader("uv_flat") 
# Load textures 
ceilingimg = pi3d.Texture("textures/squareblocks4.png") 
wallimg = pi3d.Texture("textures/squareblocksred.png") 
floorimg = pi3d.Texture("textures/dunes3_512.jpg") 
bumpimg = pi3d.Texture("textures/mudnormal.jpg") 
startimg = pi3d.Texture("textures/rock1.jpg")     
endimg = pi3d.Texture("textures/water.jpg") 
# Create elevation map 
mapwidth = 1000.0 
mapdepth = 1000.0 
#We shall assume we are using a flat floor in this example 
mapheight = 0.0 
mymap = pi3d.ElevationMap(mapfile="textures/floor.png", 
                width=mapwidth, depth=mapdepth, height=mapheight, 
                divx=64, divy=64) 
mymap.set_draw_details(shader,[floorimg, bumpimg],128.0, 0.0) 
levelList = ["textures/inside_map0.png","textures/inside_map1.png", 
             "textures/inside_map2.png"] 
avhgt = 5.0 
aveyelevel = 4.0 
MAP_BLOCK = 15.0 
aveyeleveladjust = aveyelevel - avhgt/2 
PLAYERHEIGHT = (mymap.calcHeight(5, 5) + avhgt/2) 
#Start the player in the top-left corner 
startpos = [(8*MAP_BLOCK),PLAYERHEIGHT,(8*MAP_BLOCK)] 
endpos = [0,PLAYERHEIGHT,0] #Set the end pos in the centre 
person = SolidObject("person", Size(1, avhgt, 1), 
                Position(startpos[0],startpos[1],startpos[2]), 1) 
#Add spheres for start and end, end must also have a solid object 
#so we can detect when we hit it 
startobject = pi3d.Sphere(name="start",x=startpos[0], 
                          y=startpos[1]+avhgt,z=startpos[2]) 
startobject.set_draw_details(shader, [startimg, bumpimg], 
                             32.0, 0.3) 
endobject = pi3d.Sphere(name="end",x=endpos[0], 
                        y=endpos[1],z=endpos[2]) 
endobject.set_draw_details(shader, [endimg, bumpimg], 32.0, 0.3) 
endSolid = SolidObject("end", Size(1, avhgt, 1), 
                Position(endpos[0],endpos[1],endpos[2]), 1) 
 
mazeScheme = {"#models": 3, 
      (1,None): [["C",2]],      #white cell : Ceiling 
      (0,1,"edge"): [["W",1]],  #white cell on edge next 
                                #   black cell : Wall 
      (1,0,"edge"): [["W",1]],  #black cell on edge next 
                                #   to white cell : Wall 
      (0,1):[["W",0]]}          #white cell next 
                                #   to black cell : Wall 
 
details = [[shader, [wallimg], 1.0, 0.0, 4.0, 16.0], 
            [shader, [wallimg], 1.0, 0.0, 4.0, 8.0], 
            [shader, [ceilingimg], 1.0, 0.0, 4.0, 4.0]] 
 
arialFont = pi3d.Font("fonts/FreeMonoBoldOblique.ttf", 
                      "#ffffff", font_size=10) </pre>
<ol start="2">
<li>We then create functions to allow us to reload the levels and display messages to the player using the following code:</li>
</ol>
<pre style="padding-left: 60px">def loadLevel(next_level): 
  print("&gt;&gt;&gt; Please wait while maze is constructed...") 
  next_level=next_level%len(levelList) 
  building = pi3d.Building(levelList[next_level], 0, 0, mymap, 
      width=MAP_BLOCK, depth=MAP_BLOCK, height=30.0, 
      name="", draw_details=details, yoff=-15, scheme=mazeScheme) 
  return building 
 
def showMessage(text,rot=0): 
  message = pi3d.String(font=arialFont, string=text, 
                        x=endpos[0],y=endpos[1]+(avhgt/4), 
                        z=endpos[2], sx=0.05, sy=0.05,ry=-rot) 
  message.set_shader(flatsh) 
  message.draw() </pre>
<ol start="3">
<li>Within the main function, we set up the 3D environment and draw all of the objects using the following code:</li>
</ol>
<pre style="padding-left: 60px">def main(): 
  #Load a level 
  level=0 
  building = loadLevel(level) 
  lights = pi3d.Light(lightpos=(10, -10, 20), 
                      lightcol =(0.7, 0.7, 0.7), 
                      lightamb=(0.7, 0.7, 0.7)) 
  rot=0.0 
  tilt=0.0 
  #capture mouse movements 
  mymouse.start() 
  omx, omy = mymouse.position() 
 
  CAMERA = pi3d.Camera.instance() 
  while DISPLAY.loop_running() and not  
                               inputs.key_state("KEY_ESC"): 
    CAMERA.reset() 
    CAMERA.rotate(tilt, rot, 0) 
    CAMERA.position((person.x(), person.y(), 
                     person.z() - aveyeleveladjust)) 
    #draw objects 
    person.drawall() 
    building.drawAll() 
    mymap.draw() 
    startobject.draw() 
    endobject.draw() 
    #Apply the light to all the objects in the building 
    for b in building.model: 
      b.set_light(lights, 0) 
    mymap.set_light(lights, 0) 
 
   #Get mouse position 
    mx, my = mymouse.position() 
    rot -= (mx-omx)*0.8 
    tilt += (my-omy)*0.8 
    omx = mx 
    omy = my 
    xm = person.x() 
    ym = person.y() 
    zm = person.z() </pre>
<ol start="4">
<li>Finally, we monitor for key presses, handle any collisions with objects, and move within the maze as follows:</li>
</ol>
<pre style="padding-left: 60px">#Read keyboard keys 
k = mykeys.read() 
if k == KEY['APOST']: #' Key 
  tilt -= 2.0 
elif k == KEY['SLASH']: #/ Key 
  tilt += 2.0 
elif k == KEY['A']: 
  rot += 2.0 
elif k == KEY['D']: 
  rot -= 2.0 
elif k == KEY['H']: 
  #Use point_at as help - will turn the player to face 
  #  the direction of the end point 
  tilt, rot = CAMERA.point_at([endobject.x(), endobject.y(), 
                                   endobject.z()]) 
elif k == KEY['W']: 
  xm -= sin(radians(rot)) 
  zm += cos(radians(rot)) 
elif k == KEY['S']: 
  xm += sin(radians(rot)) 
  zm -= cos(radians(rot)) 
 
NewPos = Position(xm, ym, zm) 
collisions = person.CollisionList(NewPos) 
if collisions: 
  #If we reach the end, reset to start position! 
  for obj in collisions: 
    if obj.name == "end": 
      #Required to remove the building walls from the 
      #  solidobject list 
      building.remove_walls() 
      showMessage("Loading Level",rot) 
      DISPLAY.loop_running() 
      level+=1 
      building = loadLevel(level) 
      showMessage("") 
      person.move(Position(startpos[0],startpos[1], 
                               startpos[2])) 
else: 
  person.move(NewPos) 
     
try: 
  main() 
finally: 
  mykeys.close() 
  mymouse.stop() 
  DISPLAY.destroy() 
  print("Closed Everything. END") 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We define many of the elements we used in the preceding examples, such as the display, textures, shaders, font, and lighting. We also define the objects, such as the building itself, the <kbd>ElevationMap</kbd> object, as well as the start and end points of the maze. We also use SolidObjects to help detect movement within the space. See the <em>Using</em> <em>SolidObjects</em> <em>to detect collisions</em> subsection in the <em>There's more...</em> section of this recipe for more information.</p>
<p>Finally, we create the actual <kbd>Building</kbd> object based on the selected map image (using the <kbd>loadLevel()</kbd> function) and locate the camera (which represents our first person viewpoint) at the start. See the <em>The Building module</em> subsection in the <em>There's more...</em> section of this recipe for more information.</p>
<p>Within the <kbd>main</kbd> loop, we draw all the objects in our space and apply the lighting effects. We will also monitor for movement in the mouse (to control the tilt and rotation of the camera) or the keyboard to move the player (or exit/provide help).</p>
<p>The controls are as follows:</p>
<ul>
<li><strong>Mouse movement</strong>: This changes the camera tilt and rotation.</li>
<li><strong>' or / key</strong>: This changes the camera to tilt either downwards or upwards.</li>
<li><strong>A or D</strong>: This changes the camera to rotate from left to right or vice versa.</li>
<li><strong>W or S</strong>: This moves the player forwards or backwards.</li>
<li><strong>H</strong>: This helps the player by rotating them to face the end of the maze. The useful <kbd>CAMERA.point_at()</kbd> function is used to quickly rotate and tilt the camera's viewpoint towards the provided coordinates (the end position).</li>
</ul>
<p>Whenever the player moves, we check if the new position (<kbd>NewPos</kbd>) collides with another <kbd>SolidObject</kbd> using <kbd>CollisionList(NewPos)</kbd>. The function will return a list of any other SolidObjects that overlap the coordinates provided.</p>
<p>If there are no SolidObjects in the way, we make the player move; otherwise, we check to see if one of the SolidObject's names is the <kbd>end</kbd> object, in which case we have reached the end of the maze.</p>
<p>When the player reaches the end, we remove the walls from the old <kbd>Building</kbd> object and display a loading message. If we don't remove the walls, all of the SolidObjects belonging to the previous <kbd>Building</kbd> will still remain, creating invisible obstacles in the next level.</p>
<p>We will use the <kbd>showMessage()</kbd> function to inform the user that the next level will be loaded soon (since it can take a while for the building object to be constructed). We need to ensure that we call <kbd>DISPLAY.loop_running()</kbd> after we draw the message. This ensures it is displayed on the screen before we start loading the level (after which the person will be unable to move while loading takes place). We need to ensure that the message is always facing the player, regardless of which of their sides collides with the <kbd>end</kbd> object, by using the camera rotation (<kbd>rot</kbd>) for its angle:</p>
<div><img src="img/cc05fc13-625c-465b-9569-34302419fd8e.png" style="width:24.25em;height:19.33em;" width="768" height="614"/></div>
<p>When the exit ball is found, the next level is loaded</p>
<p>When the next level in the list has been loaded (or the first level has been loaded again when all the levels have been completed), we replace the message with a blank one to remove it and reset the person's position back to the start.</p>
<p>You can design and add your own levels by creating additional map files (20 x 20 PNG files with walls marked out with black pixels and walkways in white) and listing them in <kbd>levelList</kbd>. The player will start at the top-left corner of the map, and the exit is placed at the center.</p>
<p>You will notice that loading the levels can take quite a long time; this is the relatively slow ARM processor in Raspberry Pi performing all the calculations required to construct the maze and locate all the components. As soon as the maze has been built, the more powerful GPU takes over, which results in fast and smooth graphics as the player explores the space.</p>
<p>This recipe demonstrates the difference between the original Raspberry Pi processor and Raspberry Pi 2. Raspberry Pi 2 takes around 1 minute 20 seconds to load the first level, while the original Raspberry Pi can take up to 4 minutes 20 seconds. Raspberry Pi 3 takes a stunning 4 seconds to load the same level.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The preceding example creates a building for the player to explore and interact with. In order to achieve this, we use the <kbd>Building</kbd> module of <kbd>pi3d</kbd> to create a building and use <kbd>SolidObject</kbd> to detect collisions.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The Building module</h1>
                
            
            
                
<p>The <kbd>pi3d.Building</kbd> module allows you to define a whole level or floor of a building using map files. Like the terrain maps used in the preceding example, the color of the pixels will be converted into different parts of the level. In our case, black is for the walls and white is used for the passages and halls, complete with ceilings:</p>
<div><img src="img/abc8e87e-59f5-4fc2-8a5b-abc3efd02e5e.png" style="width:9.75em;height:10.00em;" width="402" height="402"/></div>
<p>The building layout is defined by the pixels in the image</p>
<p>The sections built by the <kbd>Building</kbd> object are defined by the <kbd>Scheme</kbd> used. The <kbd>Scheme</kbd> is defined by two sections, by the number of models, and then by the definitions for various aspects of the model, as seen in the following code:</p>
<pre>mazeScheme = {"#models": 3, 
  (1,None): [["C",2]],     #white cell : Ceiling 
  (0,1,"edge"): [["W",1]], #white cell on edge by black cell : Wall 
  (1,0,"edge"): [["W",1]], #black cell on edge by white cell : Wall 
  (0,1):[["W",0]]}         #white cell next to black cell : Wall  </pre>
<p>The first <strong>tuple</strong> defines the type of cell/square that the selected model should be applied to. Since there are two pixel colors in the map, the squares will either be black (<kbd>0</kbd>) or white (<kbd>1</kbd>). By determining the position and type of a particular cell/square, we can define which models (wall, ceiling, or roof) we want to apply.</p>
<p>We can define three main types of cell/square location:</p>
<ul>
<li><strong>A whole square (1,None)</strong>: This is a white cell representing open space in<br/>
the building.</li>
<li><strong>One cell bordering another, on the edge (0,1,"edge")</strong>: This is a black cell next to a white one on the map edge. This also includes <kbd>(1,0,"edge")</kbd>. This will represent the outer wall of the building.</li>
<li><strong>Any black cell that is next to a white cell (0,1)</strong>: This will represent all of the internal walls of the building.</li>
</ul>
<p>Next, we allocate a type of object(s) to be applied for that type (<kbd>W</kbd> or <kbd>C</kbd>):</p>
<ul>
<li><strong>Wall (W)</strong>: This is a vertical wall that is placed between the specified cells (such as between black and white cells).</li>
<li><strong>Ceiling (C)</strong>: This is a horizontal section of the ceiling to cover the current cell.</li>
<li><strong>Roof (R)</strong>: This is an additional horizontal section that is placed slightly above the ceiling to provide a roofing effect. It is typically used for buildings that may need to be viewed from the outside (this is not used in our example).</li>
<li><strong>Ceiling Edge (CE)</strong>: This is used to join the ceiling sections to the roof around the edges of the building (it is not used in our example since ours is an indoor model).</li>
</ul>
<p>Finally, we specify the model that will be used for each object. We are using three models in this example (normal walls, walls on an edge, and the ceiling), so we can define the model used by specifying <kbd>0</kbd>, <kbd>1</kbd>, or <kbd>2</kbd>.</p>
<p>Each of the models are defined in the <kbd>details</kbd> array, which allows us to set the required textures and shaders for each one (this contains the same information that would normally be set by the <kbd>.set_draw_details()</kbd> function), as shown in the following code:</p>
<pre>details = [[shader, [wallimg], 1.0, 0.0, 4.0, 16.0], 
           [shader, [wallimg], 1.0, 0.0, 4.0, 8.0], 
           [shader, [ceilingimg], 1.0, 0.0, 4.0, 4.0]] </pre>
<p>In our example, the inside walls are allocated to the <kbd>wallimg</kbd> texture (<kbd>textures/squareblocksred.png</kbd>) and the ceilings are allocated to the <kbd>ceilingimg</kbd> texture (<kbd>textures/squareblocks4.png</kbd>). You may be able to note from the following screenshot that we can apply different texture models (in our case, a slightly different scaling) to the different types of blocks. The walls that border the outside of the maze (with the edge identifier) will use the <kbd>wallimg</kbd> model texture scaled by 4 x 8 (<kbd>details[1]</kbd>) while the same model texture will be scaled 4 x 16 for the internal walls (<kbd>details[0]</kbd>):</p>
<div><img src="img/94c15c80-75a1-47ff-96e0-12967c6792b4.png" style="width:29.75em;height:23.83em;" width="768" height="613"/></div>
<p>Walls with different scaling</p>
<p>Both <kbd>scheme</kbd> and <kbd>draw_details</kbd> are set when the <kbd>pi3d.Building</kbd> object is created, as shown in the following code:</p>
<pre>building = pi3d.Building(levelList[next_level], 0, 0, mymap,<br/>    width=MAP_BLOCK, depth=MAP_BLOCK, height=30.0, name="",<br/>      draw_details=details, yoff=-15, scheme=mazeScheme) </pre>
<p>Using the map file (<kbd>levelList[next_level</kbd>]), the scheme (<kbd>mazeScheme</kbd>), and draw details (<kbd>details</kbd>), the entire building is created within the environment:</p>
<div><img src="img/9f60cce2-156c-41f4-8e51-ebd2ec4fe8f6.png" style="width:28.00em;height:22.42em;" width="1280" height="1024"/></div>
<p>An overhead view of the 3D maze we created</p>
<p>Although we use just black and white in this example, other colored pixels can also be used to define additional block types (and therefore different textures, if required). If another color (such as gray) is added, the indexing of the color mapping is shifted so that black blocks are referenced as <kbd>0</kbd>, the new colored blocks as <kbd>1</kbd>, and the white blocks as <kbd>2</kbd>. See the <strong>Silo</strong> example in the <kbd>pi3d</kbd> demos for details.<br/>
<br/>
We also need to define an <kbd>ElevationMap</kbd> object: <kbd>mymap</kbd>. The <kbd>pi3d.Building</kbd> module makes use of the <kbd>ElevationMap</kbd> object's <kbd>calcHeight()</kbd> function to correctly place the walls on top of the <kbd>ElevationMap</kbd> object's surface. In this example, we will apply a basic <kbd>ElevationMap</kbd> object using <kbd>textures/floor.png</kbd>, which will generate a flat surface that the <kbd>Building</kbd> object will be placed on.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using SolidObjects to detect collisions</h1>
                
            
            
                
<p>In addition to the <kbd>Building</kbd> object, we will define an object for the player and also define two objects to mark the start and end points of the maze. Although the player's view is the first person viewpoint (that is, we don't actually see them since the view is effectively through their eyes), we need to define a <strong>SolidObject</strong> to represent them.</p>
<p>A SolidObject is a special type of invisible object that can be checked to determine if the space that would be occupied by one SolidObject has overlapped another. This will allow us to use <kbd>person.CollisionList(NewPos)</kbd> to get a list of any other SolidObjects that the <kbd>person</kbd> object will be in contact with at the <kbd>NewPos</kbd> position. Since the <kbd>Building</kbd> class defines SolidObjects for all of the parts of the <kbd>Building</kbd> object, we will be able to detect when the player tries to move through a wall (or, for some reason, the roof/ceiling) and stop them from moving through it.</p>
<p>We also use SolidObjects for the start and end locations in the maze. The place where the player starts is set as the top-left corner of the map (the white-space pixel from the top left of the map) and is marked by the <kbd>startpos</kbd> object (a small <kbd>pi3d.Sphere</kbd> with the <kbd>rock1.jpg</kbd> texture) placed above the person's head. The end of the maze is marked with another <kbd>pi3d.Sphere</kbd> object (with the <kbd>water.jpg</kbd> texture) located at the center of the map. We also define another SolidObject at the end so that we can detect when the player reaches it and collides with it (and load the next level).</p>


            

            
        
    </div>



  </body></html>