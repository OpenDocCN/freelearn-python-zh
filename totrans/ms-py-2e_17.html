<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer305" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">17</h1>&#13;
    <h1 id="_idParaDest-503" class="chapterTitle">Extensions in C/C++, System Calls, and C/C++ Libraries</h1>&#13;
    <p class="normal">The last few chapters have shown us many machine learning and scientific computing libraries. Many of these libraries are not written in pure Python because of code reuse from existing libraries, or for performance reasons. In this chapter, we will learn how we can do some of this ourselves by creating C/C++ extensions.</p>&#13;
    <p class="normal">In <em class="chapterRef">Chapter 12</em>, <em class="italic">Performance – Tracking and Reducing Your Memory and CPU Usage</em>, we saw that the <code class="inlineCode">cProfile</code> module is about 10 times faster than the <code class="inlineCode">profile</code> module, which indicates that at least some C extensions are faster than their pure Python equivalents. This chapter will not focus on performance that much, however. The goal here is interaction with non-Python libraries. To paraphrase Linus Torvalds, any performance improvement will just be a completely unintentional side effect.</p>&#13;
    <p class="normal">If performance is your main goal, you really should not be looking at writing a C/C++ extension manually. For the Python core modules, that was done, of course, but in most practical applications you are far better off using <code class="inlineCode">numba</code> or <code class="inlineCode">cython</code>. Or, if the use case allows, use pre-existing libraries such as <code class="inlineCode">numpy</code> or <code class="inlineCode">jax</code>. The main reason for using the tools in this chapter should be to reuse existing libraries so you don’t have to reinvent the wheel.</p>&#13;
    <p class="normal">We will discuss the following topics in this chapter:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">ctypes</code> for handling foreign (C/C++) functions and data from Python</li>&#13;
      <li class="bulletList"><strong class="keyWord">C Foreign Function Interface</strong> (<strong class="keyWord">CFFI</strong>), similar to <code class="inlineCode">ctypes</code>, but with a slightly different approach</li>&#13;
      <li class="bulletList">Writing native C/C++ to extend Python</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-504" class="heading-1">Setting up tooling</h1>&#13;
    <p class="normal">Before we begin, it is important to note that this chapter will require a working compiler that plays nicely with your Python interpreter. Unfortunately, these vary from platform to platform. For <a id="_idIndexMarker1494"/>Linux distributions, this can usually be achieved with one or two commands without much hassle. </p>&#13;
    <p class="normal">For OS X, the experience is often very similar, mostly because the heavy lifting can be offloaded to package management systems such as Homebrew. For Windows, it can be slightly trickier, but that process has been streamlined over the last few years as well.</p>&#13;
    <p class="normal">A good<a id="_idIndexMarker1495"/> and up-to-date starting point to get the required tooling is the Python Developer’s Guide: <a href="https://devguide.python.org/setup/"><span class="url">https://devguide.python.org/setup/</span></a>.</p>&#13;
    <p class="normal">For building the actual extensions, the Python manual can be useful: <a href="https://docs.python.org/3/extending/building.html"><span class="url">https://docs.python.org/3/extending/building.html</span></a>. </p>&#13;
    <h2 id="_idParaDest-505" class="heading-2">Do you need C/C++ modules?</h2>&#13;
    <p class="normal">In almost all cases, I’m inclined to say that you<a id="_idIndexMarker1496"/> don’t need C/C++ modules. If you are really strapped for best performance, then there are almost always highly optimized Python libraries available that use C/C++/Fortran/etc. internally and fit your purpose. There are some cases where native C/C++ (or just “not Python”) is a<a id="_idIndexMarker1497"/> requirement. If you need to communicate directly with hardware that has specific timings, then Python might not do the trick. Generally, however, that kind of communication should be left to an operating system kernel-level driver that takes care of the specific timings. Regardless, even if you will never write one of these modules yourself, you might still need to know how they work when you are debugging a project.</p>&#13;
    <h2 id="_idParaDest-506" class="heading-2">Windows</h2>&#13;
    <p class="normal">For Windows, the general <a id="_idIndexMarker1498"/>recommendation is Visual Studio. The specific<a id="_idIndexMarker1499"/> version depends on your Python version:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="keyWord">Python 3.4</strong>: Microsoft Visual Studio 2010</li>&#13;
      <li class="bulletList"><strong class="keyWord">Python 3.5 and 3.6</strong>: Microsoft Visual Studio 2015 or Visual Studio 2017</li>&#13;
      <li class="bulletList"><strong class="keyWord">Python 3.7–3.10</strong>: Microsoft Visual <a id="_idIndexMarker1500"/>Studio 2017</li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="normal">Visual Studio 2019 is also supported, but the official builds of Python 3.7 to Python 3.10 still use Visual Studio 2017, making that the recommended solution.</p>&#13;
    </div>&#13;
    <p class="normal">The specifics <a id="_idIndexMarker1501"/>of installing Visual Studio and compiling Python modules fall somewhat outside the scope of this book. Luckily, the Python documentation has some documentation available to<a id="_idIndexMarker1502"/> get you started: <a href="https://devguide.python.org/setup/#windows"><span class="url">https://devguide.python.org/setup/#windows</span></a>.</p>&#13;
    <p class="normal">If you are looking for a more Linux/Unix-like solution, you can also choose to use the GCC compiler through MinGW.</p>&#13;
    <h2 id="_idParaDest-507" class="heading-2">OS X</h2>&#13;
    <p class="normal">For a Mac, the process is <a id="_idIndexMarker1503"/>mostly straightforward, but there are a few tips specific to<a id="_idIndexMarker1504"/> OS X. First, install Xcode through the Mac App Store. </p>&#13;
    <p class="normal">Once you have done that, you should be able to run the following command:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> xcode-select --install&#13;
</code></pre>&#13;
    <p class="normal">Next up is the fun part. Because OS X comes with a bundled Python version (which is generally out of date), I would recommend installing a new Python version through Homebrew instead. The most up-to-date instructions for installing Homebrew can be found on the<a id="_idIndexMarker1505"/> Homebrew home page (<a href="http://brew.sh/"><span class="url">http://brew.sh/</span></a>), but the gist of installing Homebrew is this command:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> /bin/bash -c <span class="hljs-con-string">"</span><span class="hljs-con-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span><span class="hljs-con-string">"</span>&#13;
</code></pre>&#13;
    <p class="normal">After that, make sure you check whether everything is set up correctly using the <code class="inlineCode">doctor</code> command:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> brew doctor&#13;
</code></pre>&#13;
    <p class="normal">When all of this is done, simply install Python through Homebrew and make sure you use that Python release when executing your scripts:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> brew install python3&#13;
<span class="hljs-con-meta">$</span> python3 --version&#13;
Python 3.9.7&#13;
which python3&#13;
/usr/local/bin/python3&#13;
</code></pre>&#13;
    <p class="normal">Also ensure that the Python <a id="_idIndexMarker1506"/>process is in <code class="inlineCode">/usr/local/bin</code>, that is, the <a id="_idIndexMarker1507"/>Homebrewed version. The regular OS X version would be in <code class="inlineCode">/usr/bin/</code> instead.</p>&#13;
    <h2 id="_idParaDest-508" class="heading-2">Linux/Unix</h2>&#13;
    <p class="normal">The installation for Linux/Unix systems<a id="_idIndexMarker1508"/> greatly depends on the <a id="_idIndexMarker1509"/>distribution, but it is generally simple to do.</p>&#13;
    <p class="normal">For Fedora, Red Hat, CentOS, and other systems that use <code class="inlineCode">yum</code> as the package manager, use these lines:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> sudo yum install yum-utils&#13;
<span class="hljs-con-meta">$</span> sudo yum-builddep python3&#13;
</code></pre>&#13;
    <p class="normal">For Debian, Ubuntu, and other systems that use <code class="inlineCode">apt</code> as the package manager, use the following line:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> sudo apt-get build-dep python3.10&#13;
</code></pre>&#13;
    <p class="normal">Note that Python 3.10 is not available everywhere yet, so you might need Python 3.9 or even Python 3.8 instead.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">For most systems, to get help with the installation, a web search along the lines of <code class="inlineCode">&lt;operating system&gt; python.h</code> should do the trick.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-509" class="heading-1">Calling C/C++ with ctypes</h1>&#13;
    <p class="normal">The <code class="inlineCode">ctypes</code> library makes <a id="_idIndexMarker1510"/>it easily possible to call functions <a id="_idIndexMarker1511"/>from C libraries, but you do need to be careful with memory access and data types. Python is generally very lenient in memory allocation and type-casting; C is, most definitely, not that forgiving.</p>&#13;
    <h2 id="_idParaDest-510" class="heading-2">Platform-specific libraries</h2>&#13;
    <p class="normal">Even though all platforms will have a<a id="_idIndexMarker1512"/> standard C library available somewhere, the location and the method of calling it differs per platform. For the purpose of having a simple environment that is easily accessible to most people, I will assume the use of an Ubuntu (virtual) machine. If you don’t have a native Ubuntu machine available, you can easily run it through VirtualBox on Windows, Linux, and OS X.</p>&#13;
    <p class="normal">Since you will often want to run examples on your native system instead, we will first show the basics of loading <code class="inlineCode">printf</code> from the standard C library.</p>&#13;
    <h3 id="_idParaDest-511" class="heading-3">Windows</h3>&#13;
    <p class="normal">One<a id="_idIndexMarker1513"/> problem of calling C functions from Python is that the <a id="_idIndexMarker1514"/>default libraries are platform-specific. While the following example will work just fine on Windows systems, it won’t run on other platforms:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> ctypes&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ctypes.cdll&#13;
&lt;ctypes.LibraryLoader object at 0x...&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc = ctypes.cdll.msvcrt&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc&#13;
&lt;CDLL 'msvcrt', handle ... at ...&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf&#13;
&lt;_FuncPtr object at 0x...&gt;&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">c</code><code class="inlineCode">types</code> library exposes the functions and attributes of the C/C++ library (<code class="inlineCode">MSVCRT.DLL</code> in this case) to your Python installation. Since the <code class="inlineCode">ms</code> part of <code class="inlineCode">msvcrt</code> stands for Microsoft, this is one library you generally won’t find on non-Windows systems.</p>&#13;
    <p class="normal">There is a difference between Linux/Unix and Windows in loading as well; on Windows, the modules will generally be auto-loaded, while on Linux/Unix systems, you will need to load them manually, because these systems will often have multiple versions of the same library available.</p>&#13;
    <h3 id="_idParaDest-512" class="heading-3">Linux/Unix</h3>&#13;
    <p class="normal">Calling standard system libraries from<a id="_idIndexMarker1515"/> Linux/Unix does require <a id="_idIndexMarker1516"/>manual loading, but it’s luckily nothing too involved. Fetching the <code class="inlineCode">printf</code> function from the standard C library is quite simple:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> ctypes&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ctypes.cdll&#13;
&lt;ctypes.LibraryLoader object at 0x...&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc = ctypes.cdll.LoadLibrary(<span class="hljs-con-string">'libc.so.6'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc&#13;
&lt;CDLL 'libc.so.6', handle ... at ...&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf&#13;
&lt;_FuncPtr object at 0x...&gt;&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-513" class="heading-3">OS X</h3>&#13;
    <p class="normal">For OS X, explicit loading is also<a id="_idIndexMarker1517"/> required, but <a id="_idIndexMarker1518"/>beyond that, it is quite similar to how everything works on regular Linux/Unix systems:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> ctypes&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc = ctypes.cdll.LoadLibrary(<span class="hljs-con-string">'libc.dylib'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc&#13;
&lt;CDLL 'libc.dylib', handle ... at 0x...&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf&#13;
&lt;_FuncPtr object at 0x...&gt;&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-514" class="heading-3">Making it easy</h3>&#13;
    <p class="normal">Besides the way libraries are loaded, there are more differences, unfortunately, but the earlier examples<a id="_idIndexMarker1519"/> at least give you the standard C library, which allows you to call functions such as <code class="inlineCode">printf</code> straight from your C implementation. If, for some reason, you have trouble loading the right library, there is always the <code class="inlineCode">ctypes.util.find_library</code> function. </p>&#13;
    <p class="normal">As always, I would recommend explicit over implicit declarations, but things can be made easier in some cases using this function. To illustrate a run on an OS X system:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># OS X</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> ctypes <span class="hljs-con-keyword">import</span> util&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> ctypes <span class="hljs-con-keyword">import</span> cdll&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> library = util.find_library(<span class="hljs-con-string">'libc'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> library&#13;
'/usr/lib/libc.dylib'&#13;
&#13;
<span class="hljs-con-comment"># Load the library</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc = cdll.LoadLibrary(library)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc&#13;
&lt;CDLL '/usr/lib/libc.dylib', handle ... at 0x...&gt;&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-515" class="heading-2">Calling functions and native types</h2>&#13;
    <p class="normal">Calling a function through <code class="inlineCode">ctypes</code> is nearly <a id="_idIndexMarker1520"/>as simple as calling native Python functions. The notable <a id="_idIndexMarker1521"/>difference is the arguments and <code class="inlineCode">return</code> statements. These should be converted to native C variables.</p>&#13;
    <div class="note">&#13;
      <p class="normal">These examples assume that you have <code class="inlineCode">libc</code> in your scope from one of the examples in the previous paragraphs.</p>&#13;
    </div>&#13;
    <p class="normal">We will now create a C string that is effectively a memory block, with the characters as ASCII characters and terminated with a null character. After creating the C string, we will run <code class="inlineCode">printf</code> on the string:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> c_string = ctypes.create_string_buffer(<span class="hljs-con-string">b'some bytes'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ctypes.sizeof(c_string)&#13;
11&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c_string.raw&#13;
b'some bytes\x00'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c_string.value&#13;
b'some bytes'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf(c_string)&#13;
10&#13;
some bytes&gt;&gt;&gt;&#13;
</code></pre>&#13;
    <p class="normal">This output might look a bit confusing initially, so let’s analyze it. When we call <code class="inlineCode">libc.printf</code> on <code class="inlineCode">c_string</code>, it will write the string to <code class="inlineCode">stdout</code> directly. Because of this, you can see that the output is interleaved (<code class="inlineCode">some bytes&gt;&gt;&gt;</code>) with the Python output, as this circumvents the Python output buffering and Python does not know this is happening. Additionally, you can see that <code class="inlineCode">libc.printf</code> returned <code class="inlineCode">10</code>, which is the number of bytes written to <code class="inlineCode">stdout</code>.</p>&#13;
    <p class="normal">To call the <code class="inlineCode">printf</code> function, you <em class="italic">must</em>—and I cannot stress this enough—convert your values from Python to C explicitly. While it might appear to work without this initially, it really doesn’t:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf(<span class="hljs-con-number">123</span>)&#13;
segmentation fault (core dumped)  python3&#13;
</code></pre>&#13;
    <div class="note">&#13;
      <p class="normal">Remember to use the <code class="inlineCode">faulthandler</code> module from <em class="chapterRef">Chapter 11</em>, <em class="italic">Debugging – Solving the Bugs</em>, to debug <code class="inlineCode">segfaults</code>.</p>&#13;
    </div>&#13;
    <p class="normal">Another thing to note<a id="_idIndexMarker1522"/> from the example is that <code class="inlineCode">ctypes.sizeof(c_string)</code> returns <code class="inlineCode">11</code> instead of <code class="inlineCode">10</code>. This is caused by the trailing null character that C strings require, which is visible in the raw property of the C string.</p>&#13;
    <p class="normal">Without it, the string functions in <a id="_idIndexMarker1523"/>C such as <code class="inlineCode">printf</code> won’t know where the string will end, since a C string is just a block of bytes in memory and C only knows at what memory address the string starts; the end is indicated by the null character. This is why memory management in C requires paying a lot of attention. </p>&#13;
    <p class="normal">If you allocate a string of size 5 and write 10 bytes to it, you will be writing into the memory outside of your variable, which could be another function, another variable, or outside of your program’s memory. This would result in a segmentation fault.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Python will generally protect you from silly mistakes; C and C++ most certainly won’t. To quote Bjarne Stroustrup (the creator of C++):</p>&#13;
      <p class="normal"><em class="italic">“C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do, it blows away your whole leg.”</em></p>&#13;
      <p class="normal">As opposed to C, C++ does have a string type to protect you in these cases. However, it is still a language where you have easy access to memory addresses and mistakes are easily made.</p>&#13;
    </div>&#13;
    <p class="normal">To pass along other types (such as integers) toward <code class="inlineCode">libc</code> functions, we have to use some conversion as well. In some cases, it is optional:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> format_string = <span class="hljs-con-string">b'Number: %d\n'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf(format_string, <span class="hljs-con-number">123</span>)&#13;
Number: 123&#13;
12&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x = ctypes.c_int(<span class="hljs-con-number">123</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf(format_string, x)&#13;
Number: 123&#13;
12&#13;
</code></pre>&#13;
    <p class="normal">But not in all cases, so caution is advised, and explicitly converting is the safer option:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> format_string = <span class="hljs-con-string">b'Number: %.3f\n'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf(format_string, <span class="hljs-con-number">123.45</span>)&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
ctypes.ArgumentError: argument 2: &lt;class 'TypeError'&gt;: Don't know how to convert parameter 2&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x = ctypes.c_double(<span class="hljs-con-number">123.45</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf(format_string, x)&#13;
Number: 123.450&#13;
16&#13;
</code></pre>&#13;
    <p class="normal">It’s important to note<a id="_idIndexMarker1524"/> that even though these values are usable as native C types, they are still mutable<a id="_idIndexMarker1525"/> through the <code class="inlineCode">value</code> attribute:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> x = ctypes.c_double(<span class="hljs-con-number">123.45</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x.value&#13;
123.45&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x.value = <span class="hljs-con-number">456</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x&#13;
c_double(456.0)&#13;
</code></pre>&#13;
    <p class="normal">This is the case unless the original object was immutable, which is a very important distinction to make. The <code class="inlineCode">create_string_buffer</code> object creates a mutable string object, whereas <code class="inlineCode">c_wchar_p</code>, <code class="inlineCode">c_char_p</code>, and <code class="inlineCode">c_void_p</code> create references to the actual Python string. Since strings are immutable in Python, these values are also immutable. You can still change the <code class="inlineCode">value</code> property, but it will only assign a new string. Passing one of these immutable variables to a C function that mutates the internal value will result in unpredictable behavior and/or crashes.</p>&#13;
    <p class="normal">The only values that should convert to C without any issues are integers, strings, and bytes, but I personally recommend that you always convert all of your values so that you are certain of which type you will get and how to treat it.</p>&#13;
    <h2 id="_idParaDest-516" class="heading-2">Complex data structures</h2>&#13;
    <p class="normal">We have already seen that <a id="_idIndexMarker1526"/>we can’t just pass along Python <a id="_idIndexMarker1527"/>values to C, but what if we need more complex objects such as classes or tuples? Luckily, we can easily create (and access) C structures using <code class="inlineCode">ctypes</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> _libc <span class="hljs-con-keyword">import</span> libc&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> ctypes&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">ComplexStructure</span><span class="hljs-con-class">(</span><span class="hljs-con-params">ctypes.Structure</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     _fields_ = [&#13;
<span class="hljs-con-meta">...</span>         (<span class="hljs-con-string">'some_int'</span>, ctypes.c_int),&#13;
<span class="hljs-con-meta">...</span>         (<span class="hljs-con-string">'some_double'</span>, ctypes.c_double),&#13;
<span class="hljs-con-meta">...</span>         (<span class="hljs-con-string">'some_char'</span>, ctypes.c_char),&#13;
<span class="hljs-con-meta">...</span>         (<span class="hljs-con-string">'some_string'</span>, ctypes.c_char_p),&#13;
<span class="hljs-con-meta">...</span>     ]&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> structure = ComplexStructure(<span class="hljs-con-number">123</span>, <span class="hljs-con-number">456.789</span>, <span class="hljs-con-string">b'x'</span>, <span class="hljs-con-string">b'abc'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> structure.some_int&#13;
123&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> structure.some_double&#13;
456.789&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> structure.some_char&#13;
b'x'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> structure.some_string&#13;
b'abc'&#13;
</code></pre>&#13;
    <p class="normal">This supports any of the fundamental data types such as integers, floating-point numbers, and strings. Nesting is also supported; for instance, other structures could use <code class="inlineCode">ComplexStructure</code> instead of <code class="inlineCode">ctypes.c_int</code> in this example.</p>&#13;
    <h2 id="_idParaDest-517" class="heading-2">Arrays</h2>&#13;
    <p class="normal">Within Python, we <a id="_idIndexMarker1528"/>generally use a <code class="inlineCode">list</code> to represent a collection of objects. These are very<a id="_idIndexMarker1529"/> convenient in that you can easily add and remove values. Within C, the default collection object is the <strong class="keyWord">array</strong>, which is just a block of memory with a fixed size.</p>&#13;
    <p class="normal">The size of the block in bytes is decided by multiplying the number of items by the size of the type. In the case of a <code class="inlineCode">char</code>, this is <code class="inlineCode">8</code> bits, so if you wish to store <code class="inlineCode">100</code> chars, you would have <code class="inlineCode">100 * 8 bits = 800 bits = 100 bytes</code>.</p>&#13;
    <p class="normal">This is literally all it is—a block of memory—and the only reference you receive from C is a pointer to the memory address where the block of memory begins. Since the pointer does have a type, <code class="inlineCode">char*</code> in this case, C will know how many bytes to jump ahead when trying to access a different item. Effectively, when trying to access item 25 in a <code class="inlineCode">char</code> array, you simply need to do <code class="inlineCode">array_pointer + 24 * sizeof(char)</code>. This has a convenient shortcut: <code class="inlineCode">array_pointer[24]</code>. Note that we need to access index 24 because we start counting at 0, just like with Python collections such as lists and strings.</p>&#13;
    <p class="normal">Note that C does not <a id="_idIndexMarker1530"/>store the number of items in the array, so even though our array has only 100 items, it won’t block us from doing <code class="inlineCode">array_pointer[1000]</code> and<a id="_idIndexMarker1531"/> reading other (random) memory. At some point, however, you will go outside of the reserved memory of your application and your operating system will punish you with a segmentation fault.</p>&#13;
    <p class="normal">If you take all of these limitations into account, C arrays are definitely usable but mistakes are quickly made and C is unforgiving. No warnings; just crashes and strangely behaving code. Beyond that, let’s see how easily we can declare an array with <code class="inlineCode">ctypes</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> TenNumbers = <span class="hljs-con-number">10</span> * ctypes.c_double&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> numbers = TenNumbers()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> numbers[<span class="hljs-con-number">0</span>]&#13;
0.0&#13;
</code></pre>&#13;
    <p class="normal">As you can see, because of the fixed sizes and the requirement of declaring the type before using it, its usage is slightly awkward. However, it does function as you would expect. Additionally, as opposed to regular C, the values are initialized to zero by default and it will protect you from out-of-bound errors when accessing from Python. Naturally, this can be combined with our previously created custom structures as well:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> GrossComplexStructures = <span class="hljs-con-number">144</span> * ComplexStructure &#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> complex_structures = GrossComplexStructures()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> complex_structures[<span class="hljs-con-number">10</span>].some_double = <span class="hljs-con-number">123</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> complex_structures[<span class="hljs-con-number">10</span>]&#13;
&lt;__main__.ComplexStructure object at ...&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> complex_structures&#13;
&lt;__main__.ComplexStructure_Array_144 object at ...&gt;&#13;
</code></pre>&#13;
    <p class="normal">Even though you cannot simply append to these arrays to resize them, they are actually resizable with a few constraints. Firstly, the new array needs to be larger than the original array. Secondly, the size needs to be specified in bytes, not items. To illustrate, we have this example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> TenNumbers = <span class="hljs-con-number">10</span> * ctypes.c_double&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> numbers = TenNumbers()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ctypes.resize(numbers, <span class="hljs-con-number">11</span> * ctypes.sizeof(ctypes.c_double))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ctypes.resize(numbers, <span class="hljs-con-number">10</span> * ctypes.sizeof(ctypes.c_double))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ctypes.resize(numbers, <span class="hljs-con-number">9</span> * ctypes.sizeof(ctypes.c_double))&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
ValueError: minimum size is 80&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> numbers[:<span class="hljs-con-number">5</span>] = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> numbers[:]&#13;
[0.0, 1.0, 2.0, 3.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0]&#13;
</code></pre>&#13;
    <p class="normal">As a starting point, the <code class="inlineCode">TenNumbers</code> array has 10 items. Next up, we try to resize the array to 11, which works<a id="_idIndexMarker1532"/> because it’s more than the original 10. Resizing back to 10<a id="_idIndexMarker1533"/> is also allowed, but resizing to 9 items is not allowed because that is fewer than the 10 items we had originally.</p>&#13;
    <p class="normal">Lastly, we mutate a slice of items simultaneously, which works as you would expect.</p>&#13;
    <h2 id="_idParaDest-518" class="heading-2">Gotchas with memory management</h2>&#13;
    <p class="normal">Besides the obvious memory <a id="_idIndexMarker1534"/>allocation issues and mixing mutable and immutable objects, there is one more non-obvious memory mutability issue.</p>&#13;
    <p class="normal">In regular Python, we can do something like <code class="inlineCode">a, b = b, a</code> and it will work as you would expect because Python uses internal temporary variables. With regular C, you do not have that luxury, unfortunately; with <code class="inlineCode">ctypes</code>, you do have the benefit of Python taking care of the temporary variable for you, but sometimes that can still go wrong:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> ctypes&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Point</span><span class="hljs-con-class">(</span><span class="hljs-con-params">ctypes.Structure</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     _fields_ = (<span class="hljs-con-string">'x'</span>, ctypes.c_int), (<span class="hljs-con-string">'y'</span>, ctypes.c_int)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Vertex</span><span class="hljs-con-class">(</span><span class="hljs-con-params">ctypes.Structure</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     _fields_ = (<span class="hljs-con-string">'</span><span class="hljs-con-string">c'</span>, Point), (<span class="hljs-con-string">'d'</span>, Point)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a = Point(<span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = Point(<span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a.x, a.y, b.x, b.y&#13;
(0, 1, 2, 3)&#13;
&#13;
<span class="hljs-con-comment"># Swap points a and b</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a, b = b, a&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a.x, a.y, b.x, b.y&#13;
(2, 3, 0, 1)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v = Vertex()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v.c = Point(<span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v.d = Point(<span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v.c.x, v.c.y, v.d.x, v.d.y&#13;
(0, 1, 2, 3)&#13;
&#13;
<span class="hljs-con-comment"># Swap points c and d</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v.c, v.d = v.d, v.c&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v.c.x, v.c.y, v.d.x, v.d.y&#13;
(2, 3, 2, 3)&#13;
</code></pre>&#13;
    <p class="normal">With the first example, we get <code class="inlineCode">2, 3, 0, 1</code> when swapping <code class="inlineCode">a</code> and <code class="inlineCode">b</code>, as expected. With the second<a id="_idIndexMarker1535"/> example, we get <code class="inlineCode">2, 3, 2, 3</code> instead. The problem is that these objects are copied to a temporary buffer variable, but the objects themselves are being changed in the meantime.</p>&#13;
    <p class="normal">Let’s elaborate for a bit more clarity. With Python, when you do <code class="inlineCode">a, b = b, a</code>, it will effectively run <code class="inlineCode">temp = a; a = b; b = temp</code>. That way, the replacement works as expected and you will receive the correct values in <code class="inlineCode">a</code> and <code class="inlineCode">b</code>.</p>&#13;
    <p class="normal">When you execute <code class="inlineCode">a, b = b, a</code> in C, you effectively get <code class="inlineCode">a = b; b = a</code>. By the time the <code class="inlineCode">b = a</code> statement is executed, the value for <code class="inlineCode">a</code> has already been changed by the <code class="inlineCode">a = b</code> statement, so both <code class="inlineCode">a</code> and <code class="inlineCode">b</code> will have the original value of <code class="inlineCode">b</code> at that point.</p>&#13;
    <h1 id="_idParaDest-519" class="heading-1">CFFI</h1>&#13;
    <p class="normal">The <code class="inlineCode">CFFI</code> (C Foreign Function Interface) library offers <a id="_idIndexMarker1536"/>options very similar to <code class="inlineCode">ctypes</code>, but it’s a bit more direct. Unlike the <code class="inlineCode">ctypes</code> library, a C compiler is really a necessity for CFFI. With it comes the opportunity to directly call your C compiler from Python in an easy way. We illustrate by calling <code class="inlineCode">printf</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> cffi&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ffi = cffi.FFI()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ffi.cdef(<span class="hljs-con-string">'int printf(const char* format, ...);'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc = ffi.dlopen(<span class="hljs-con-literal">None</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> arg = ffi.new(<span class="hljs-con-string">'char[]'</span>, <span class="hljs-con-string">b'Printing using CFFI\n'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf(arg)&#13;
20&#13;
Printing using CFFI&#13;
</code></pre>&#13;
    <p class="normal">Okay… so that looks a bit weird, right? We had to define how the <code class="inlineCode">printf</code> function looks and specify the arguments to <code class="inlineCode">printf</code> with a valid C function header. Additionally, we had to specify the C-string as a <code class="inlineCode">char[]</code> array manually. With <code class="inlineCode">ctypes</code>, that would not be required, but there are several advantages to <code class="inlineCode">CFFI</code> as opposed to <code class="inlineCode">ctypes</code>.</p>&#13;
    <p class="normal">With CFFI, we can directly control what is sent to the C compiler, which gives us much more control over what is happening internally compared to <code class="inlineCode">ctypes</code>. This means you can exactly control what types you feed the functions and what types you are returning, and you can use C macros.</p>&#13;
    <p class="normal">Additionally, CFFI allows for easy reuse of existing C code. If the C code you are using has several <code class="inlineCode">struct</code> definitions, you<a id="_idIndexMarker1537"/> don’t have to manually map them to a <code class="inlineCode">ctypes.Structure</code> class; you can use the <code class="inlineCode">struct</code> definition straightaway. You can even write C code directly in your Python code and CFFI will take care of calling the compiler and building the library for you.</p>&#13;
    <p class="normal">Getting back to the declarations, you may notice that we called <code class="inlineCode">ffi.dlopen</code> with a <code class="inlineCode">None</code> parameter. When you pass <code class="inlineCode">None</code> to this function, it will automatically load the entire C namespace; on non-Windows systems, at least. On Windows systems, you will need to explicitly tell CFFI which library to load.</p>&#13;
    <p class="normal">If you remember the <code class="inlineCode">ctypes.util.find_library</code> function, you can use that again in this case, depending on your operating system:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> ctypes <span class="hljs-con-keyword">import</span> util&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> cffi&#13;
&#13;
<span class="hljs-con-comment"># Initialize the FFI builder</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ffi = cffi.FFI()&#13;
&#13;
<span class="hljs-con-comment"># Find the libc library on OS X. Look back at the ctypes examples</span>&#13;
<span class="hljs-con-comment"># for other platforms.</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> library = util.find_library(<span class="hljs-con-string">'libc.dylib'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> library&#13;
'/usr/lib/libc.dylib'&#13;
&#13;
<span class="hljs-con-comment"># Load the library</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc = ffi.dlopen(library)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc&#13;
&lt;cffi.api._make_ffi_library.&lt;locals&gt;.FFILibrary object at ...&gt;&#13;
&#13;
<span class="hljs-con-comment"># We do have printf available, but CFFI requires a signature</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf&#13;
Traceback (most recent call last):&#13;
  ...&#13;
AttributeError: printf&#13;
&#13;
<span class="hljs-con-comment"># Define the printf signature and call printf</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ffi.cdef(<span class="hljs-con-string">'int printf(const char* format, ...);'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> libc.printf&#13;
&lt;cdata 'int(*)(char*, ...)' ...&gt;&#13;
</code></pre>&#13;
    <p class="normal">we can see here, the workings are initially quite comparable to <code class="inlineCode">ctypes</code> and loading the library is just as easy. The big difference is when actually calling functions and using library attributes; those<a id="_idIndexMarker1538"/> need to be explicitly defined.</p>&#13;
    <p class="normal">Luckily, the function signatures are almost always available in a C header file for your convenience so you <a id="_idIndexMarker1539"/>don’t need to write those yourself. And that is one of the advantages of CFFI: it allows you to reuse existing C code.</p>&#13;
    <h2 id="_idParaDest-520" class="heading-2">Complex data structures</h2>&#13;
    <p class="normal">The <code class="inlineCode">CFFI</code> definitions are <a id="_idIndexMarker1540"/>somewhat <a id="_idIndexMarker1541"/>similar to the <code class="inlineCode">ctypes</code> definitions, but instead of having Python emulating C, it’s just plain C that is accessible from Python. In reality, it’s only a small syntactical difference. While <code class="inlineCode">ctypes</code> is a library for accessing C from Python while remaining as close to the Python syntax as possible, CFFI uses plain C syntax to access C systems, which actually removes some confusion for people experienced with C. I personally find CFFI easier to use because I have experience with C and know what is actually happening, whereas I am not always 100% certain with <code class="inlineCode">ctypes</code>. </p>&#13;
    <p class="normal">Let’s repeat the <code class="inlineCode">Vertex</code> and <code class="inlineCode">Point</code> example with CFFI:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> cffi&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ffi = cffi.FFI()&#13;
&#13;
<span class="hljs-con-comment"># Create the structures as C structs</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ffi.cdef(<span class="hljs-con-string">'''</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">typedef struct {</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">    int x;</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">    int y;</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">} point;</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">typedef struct {</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">    point a;</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">    point b;</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">} vertex;</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">'''</span>)&#13;
&#13;
<span class="hljs-con-comment"># Create a vertex and return the pointer</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v = ffi.new(<span class="hljs-con-string">'vertex*'</span>)&#13;
&#13;
<span class="hljs-con-comment"># Set the data</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v.a.x, v.a.y, v.b.x, v.b.y = (<span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>)&#13;
&#13;
<span class="hljs-con-comment"># Print before change</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v.a.x, v.a.y, v.b.x, v.b.y&#13;
(0, 1, 2, 3)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v.a, v.b = v.b, v.a&#13;
&#13;
<span class="hljs-con-comment"># Print after change</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> v.a.x, v.a.y, v.b.x, v.b.y&#13;
(2, 3, 2, 3)&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the mutable variable<a id="_idIndexMarker1542"/> issues remain, but the code is just as usable. Since the struct can be copied from your C <a id="_idIndexMarker1543"/>headers, the only thing that remains for you is to allocate the memory for the vertex.</p>&#13;
    <div class="note">&#13;
      <p class="normal">In C, a regular <code class="inlineCode">int</code> type variable <code class="inlineCode">x</code> looks like <code class="inlineCode">int x;</code>. A pointer to a memory address with size <code class="inlineCode">int</code> looks like this: <code class="inlineCode">int *x;</code>. The <code class="inlineCode">int</code> part of the pointer tells the compiler how much memory to fetch when using the variable. To illustrate:</p>&#13;
      <pre class="programlisting code"><code class="hljs-code">int a = 123; // Variable a contains integer 123&#13;
int* b = &amp;a; // Variable b contains the memory address of a&#13;
int c = *b;  // Variable c contains 123, the value at memory address c&#13;
</code></pre>&#13;
      <p class="normal">The <code class="inlineCode">&amp;</code> operator returns the memory address for a variable and the <code class="inlineCode">*</code> operator returns the value at the pointer’s address.</p>&#13;
    </div>&#13;
    <p class="normal">The special workings of CFFI allow<a id="_idIndexMarker1544"/> you to shortcut these operations. Normally in C, using <code class="inlineCode">vertex*</code> would only allocate the memory for<a id="_idIndexMarker1545"/> the pointer, not the <code class="inlineCode">vertex</code> itself. In the case of CFFI, that is taken care of automatically.</p>&#13;
    <h2 id="_idParaDest-521" class="heading-2">Arrays</h2>&#13;
    <p class="normal">Allocation memory for new <a id="_idIndexMarker1546"/>variables is almost<a id="_idIndexMarker1547"/> trivial with CFFI. The previous section showed you an example of a single <code class="inlineCode">struct</code> allocation. Let’s now see how we can allocate an array of structs:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> cffi&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ffi = cffi.FFI()&#13;
&#13;
<span class="hljs-con-comment"># Create arrays of size 10:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x = ffi.new(<span class="hljs-con-string">'int[10]'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> y = ffi.new(<span class="hljs-con-string">'int[]'</span>, <span class="hljs-con-number">10</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x&#13;
&lt;cdata 'int[10]' owning 40 bytes&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> y&#13;
&lt;cdata 'int[]' owning 40 bytes&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x[<span class="hljs-con-number">0</span>:<span class="hljs-con-number">10</span>] = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(x)&#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x[:] = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>)&#13;
Traceback (most recent call last):&#13;
    ...&#13;
IndexError: slice start must be specified&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x[<span class="hljs-con-number">0</span>:<span class="hljs-con-number">100</span>] = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">100</span>)&#13;
Traceback (most recent call last):&#13;
    ...&#13;
IndexError: index too large (expected 100 &lt;= 10)&#13;
</code></pre>&#13;
    <p class="normal">In this case, you might wonder why the slice includes both the start and the stop. This is a requirement for CFFI. Not<a id="_idIndexMarker1548"/> problematic, but a tad annoying<a id="_idIndexMarker1549"/> nonetheless. Luckily, as you can see in the example above, CFFI does protect us from allocating outside of the bounds of the array.</p>&#13;
    <h2 id="_idParaDest-522" class="heading-2">ABI or API?</h2>&#13;
    <p class="normal">As always, there are some caveats. The<a id="_idIndexMarker1550"/> examples so far have partially used the <strong class="keyWord">ABI</strong> (<strong class="keyWord">application binary interface</strong>), which loads the<a id="_idIndexMarker1551"/> binary structures from the libraries. With the standard C library, this is generally safe; with other libraries, it generally isn’t. The difference <a id="_idIndexMarker1552"/>between the <strong class="keyWord">API</strong> (<strong class="keyWord">application programming interface</strong>) and the ABI is that the latter <a id="_idIndexMarker1553"/>calls the functions at a binary level, directly addressing memory, calling memory locations directly, and expecting them to be functions.</p>&#13;
    <p class="normal">To be able to do this, all sizes need to be consistent as well. When compiled as a 32-bit binary, a pointer will be 32 bits; when compiled as a 64-bit binary, a pointer will be 64 bits. That means that the offsets are not guaranteed to be consistent and you could be calling a random block of memory as a function.</p>&#13;
    <p class="normal">Within CFFI, it’s the difference between <code class="inlineCode">ffi.dlopen</code> and <code class="inlineCode">ffi.set_source</code>. Here, <code class="inlineCode">dlopen</code> is not always safe, but <code class="inlineCode">set_source</code> is, because it passes a compiler instead of just guessing how to call a method. The downside of using <code class="inlineCode">set_source</code> is that you need the actual source for the library you are planning to use. Let’s look at a quick example of using <code class="inlineCode">ffi.set_source</code> to call a function we defined ourselves:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> cffi&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ffi = cffi.FFI()&#13;
&#13;
<span class="hljs-con-comment"># In API mode, we can in-line the actual C code</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ffi.set_source(<span class="hljs-con-string">'_sum'</span>, <span class="hljs-con-string">'''</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">int sum(int* input, int n){</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">    int result = 0;</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">    while(n--)result += input[n];</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">    return result;</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">}</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">'''</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ffi.cdef(<span class="hljs-con-string">'int sum(int*, int);'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> library = ffi.<span class="hljs-con-built_in">compile</span>()&#13;
</code></pre>&#13;
    <p class="normal">The initialization of CFFI is as normal, but instead of using <code class="inlineCode">ffi.dlopen()</code> we are now using <code class="inlineCode">ffi.set_source()</code> to <a id="_idIndexMarker1554"/>directly pass the C code to CFFI. By doing this, CFFI can compile the library specifically for our system so we know that we will not run into ABI issues because we are creating the <a id="_idIndexMarker1555"/>ABI ourselves with the call to <code class="inlineCode">ffi.compile()</code>.</p>&#13;
    <p class="normal">After the <code class="inlineCode">ffi.compile()</code> step has <a id="_idIndexMarker1556"/>completed, CFFI has <a id="_idIndexMarker1557"/>created a <code class="inlineCode">_sum.dll</code>, <code class="inlineCode">sum.so</code>, or <code class="inlineCode">_sum.cpython-...-os.so</code> file, which can be imported as a regular Python library. Now we will use the generated library:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Now we can import the library</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> _sum&#13;
&#13;
<span class="hljs-con-comment"># Or use 'ffi.dlopen()' with the results from the compile step</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> _sum_lib = ffi.dlopen(library)&#13;
&#13;
<span class="hljs-con-comment"># Create an array with 5 items</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> N = <span class="hljs-con-number">5</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> array = ffi.new(<span class="hljs-con-string">'int[]'</span>, N)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> array[<span class="hljs-con-number">0</span>:N] = <span class="hljs-con-built_in">range</span>(N)&#13;
&#13;
<span class="hljs-con-comment"># Call our C function from either the import or the dlopen</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> _sum.lib.<span class="hljs-con-built_in">sum</span>(array, N)&#13;
10&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> _sum_lib.<span class="hljs-con-built_in">sum</span>(array, N)&#13;
10&#13;
</code></pre>&#13;
    <p class="normal">As you can see, both <code class="inlineCode">import _sum</code> and <code class="inlineCode">ffi.dlopen(library)</code> work in this case. For use in production applications, I would recommend the <code class="inlineCode">import _sum</code> method, but the <code class="inlineCode">ffi.dlopen()</code> method can be very convenient to use from long-running applications such as Jupyter Notebooks. If you were to use <code class="inlineCode">import _sum</code> and make a change in the library, it would not show your changes without you first calling <code class="inlineCode">reload(_sum)</code>.</p>&#13;
    <p class="normal">Since this is a C function, we need to pass a C array for complex types, which is why we are using <code class="inlineCode">ffi.new()</code> here. After that, the function call is straightforward, but since a C array does not have a notion of size, we need to pass the array size for this to work.</p>&#13;
    <p class="normal">You can easily go out of bounds here and put in some arbitrary number instead of <code class="inlineCode">N</code>, and the function will most likely <a id="_idIndexMarker1558"/>work without crashes, but it <a id="_idIndexMarker1559"/>will return very strange results because it will be summing random data in your memory.</p>&#13;
    <h2 id="_idParaDest-523" class="heading-2">CFFI or ctypes?</h2>&#13;
    <p class="normal">This really depends on <a id="_idIndexMarker1560"/>what you are looking for. If you have a C library that <a id="_idIndexMarker1561"/>you simply need to call and you don’t need anything special, then <code class="inlineCode">ctypes</code> is most likely the easier choice. If you’re actually writing your own C library and trying to link to the library from Python, CFFI is probably a more convenient option.</p>&#13;
    <div class="note">&#13;
      <p class="normal">In C/C++, linking a library means using an external pre-compiled library without requiring the source. You do need to have the header files, which contain details such as the function arguments and return types. This is exactly what we are doing when we use CFFI in ABI mode.</p>&#13;
    </div>&#13;
    <p class="normal">If you’re not familiar with the C programming language, then I would definitely recommend <code class="inlineCode">ctypes</code> or perhaps <code class="inlineCode">cython</code>.</p>&#13;
    <h1 id="_idParaDest-524" class="heading-1">Native C/C++ extensions</h1>&#13;
    <p class="normal">The libraries that we have <a id="_idIndexMarker1562"/>used so far only showed us how to access a C/C++ library within our Python code. Now we are going to look at the other side of the story: how C/C++ functions/modules within Python are actually written and how modules such as <code class="inlineCode">cPickle</code> and <code class="inlineCode">cProfile</code> are created.</p>&#13;
    <h2 id="_idParaDest-525" class="heading-2">A basic example</h2>&#13;
    <p class="normal">Before we can actually start with <a id="_idIndexMarker1563"/>writing and using native C/C++ extensions, we have a few prerequisites. First of all, we need the compiler and Python headers; the instructions at the beginning of this chapter should have taken care of this for us. After that, we need to tell Python what to compile. The <code class="inlineCode">setuptools</code> package mostly takes care of this, but we do need to create a <code class="inlineCode">setup.py</code> file:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pathlib&#13;
<span class="hljs-keyword">import</span> setuptools&#13;
&#13;
<span class="hljs-comment"># Get the current directory</span>&#13;
PROJECT_PATH = pathlib.Path(__file__).parent&#13;
&#13;
sum_of_squares = setuptools.Extension(<span class="hljs-string">'sum_of_squares'</span>, sources=[&#13;
    <span class="hljs-comment"># Get the relative path to sum_of_squares.c</span>&#13;
    <span class="hljs-built_in">str</span>(PROJECT_PATH / <span class="hljs-string">'sum_of_squares.c'</span>),&#13;
])&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    setuptools.setup(&#13;
        name=<span class="hljs-string">'SumOfSquares'</span>,&#13;
        version=<span class="hljs-string">'1.0'</span>,&#13;
        ext_modules=[sum_of_squares],&#13;
    )&#13;
</code></pre>&#13;
    <p class="normal">This tells Python that we have an <code class="inlineCode">Extension</code> object named <code class="inlineCode">sum_of_squares</code> that will be based on <code class="inlineCode">sum_of_squares.c</code>.</p>&#13;
    <p class="normal">Now, let’s write a function<a id="_idIndexMarker1564"/> in C that sums all perfect squares (<code class="inlineCode">2*2</code>, <code class="inlineCode">3*3</code>, and so on) up to a given number. The Python code will be stored in <code class="inlineCode">sum_of_squares_python.py</code> and looks like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">sum_of_squares</span><span class="hljs-function">(</span><span class="hljs-params">n</span><span class="hljs-function">):</span>&#13;
    total = <span class="hljs-number">0</span>&#13;
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):&#13;
        <span class="hljs-keyword">if</span> i * i &lt; n:&#13;
            total += i * i&#13;
        <span class="hljs-keyword">else</span>:&#13;
            <span class="hljs-keyword">break</span>&#13;
&#13;
    <span class="hljs-keyword">return</span> total&#13;
</code></pre>&#13;
    <p class="normal">The raw C version of this code would look something like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">long</span><span class="hljs-function"> </span><span class="hljs-title">sum_of_squares</span><span class="hljs-params">(</span><span class="hljs-keyword">long</span><span class="hljs-params"> n)</span>{&#13;
    <span class="hljs-keyword">long</span> total = <span class="hljs-number">0</span>;&#13;
    <span class="hljs-comment">/* The actual summing code */</span>&#13;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++){&#13;
        <span class="hljs-keyword">if</span>((i * i) &lt; n){&#13;
            total += i * i;&#13;
        }<span class="hljs-keyword">else</span>{&#13;
            <span class="hljs-keyword">break</span>;&#13;
        }&#13;
    }&#13;
&#13;
    <span class="hljs-keyword">return</span> total;&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Now that we know how the C code looks, we will create the actual C Python version that we will be using.</p>&#13;
    <p class="normal">As we have seen with <code class="inlineCode">ctypes</code> and <code class="inlineCode">CFFI</code>, Python and C have different data types and some conversion needs to be done. Since the CPython interpreter is written in C, it has definitions specifically to take care of this translation step.</p>&#13;
    <p class="normal">To load these definitions, we need to include <code class="inlineCode">Python.h</code>, which are the CPython header files that should have everything you need.</p>&#13;
    <p class="normal">If you look carefully, you<a id="_idIndexMarker1565"/> will see that the actual summing code is identical to the C version, but we need quite a few conversion steps to make Python understand what we are doing: </p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#</span><span class="hljs-meta-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-meta-string">&lt;Python.h&gt;</span>&#13;
&#13;
<span class="hljs-keyword">static</span><span class="hljs-function"> PyObject* </span><span class="hljs-title">sum_of_squares</span><span class="hljs-params">(PyObject *self, PyObject</span>&#13;
<span class="hljs-params">        *args)</span>{&#13;
    <span class="hljs-comment">/* Declare the variables */</span>&#13;
    <span class="hljs-keyword">int</span> n;&#13;
    <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;&#13;
&#13;
    <span class="hljs-comment">/* Parse the arguments */</span>&#13;
    <span class="hljs-keyword">if</span>(!PyArg_ParseTuple(args, <span class="hljs-string">"i"</span>, &amp;n)){&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
    }&#13;
&#13;
    <span class="hljs-comment">/* The actual summing code */</span>&#13;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++){&#13;
        <span class="hljs-keyword">if</span>((i * i) &lt; n){&#13;
            total += i * i;&#13;
        }<span class="hljs-keyword">else</span>{&#13;
            <span class="hljs-keyword">break</span>;&#13;
        }&#13;
    }&#13;
&#13;
    <span class="hljs-comment">/* Return the number but convert it to a Python object first */</span>&#13;
    <span class="hljs-keyword">return</span> PyLong_FromLong(total);&#13;
}&#13;
&#13;
<span class="hljs-keyword">static</span> PyMethodDef methods[] = {&#13;
    <span class="hljs-comment">/* Register the function */</span>&#13;
    {<span class="hljs-string">"sum_of_squares"</span>, sum_of_squares, METH_VARARGS,&#13;
     <span class="hljs-string">"Sum the perfect squares below n"</span>},&#13;
    <span class="hljs-comment">/* Indicate the end of the list */</span>&#13;
    {<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>},&#13;
};&#13;
&#13;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">PyModuleDef</span><span class="hljs-class"> </span><span class="hljs-title">module</span><span class="hljs-class"> =</span> {&#13;
    PyModuleDef_HEAD_INIT,&#13;
    <span class="hljs-string">"sum_of_squares"</span>, <span class="hljs-comment">/* Module name */</span>&#13;
    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">/* Module documentation */</span>&#13;
    <span class="hljs-number">-1</span>, <span class="hljs-comment">/* Module state, -1 means global. This parameter is</span>&#13;
<span class="hljs-comment">           for sub-interpreters */</span>&#13;
    methods,&#13;
};&#13;
&#13;
<span class="hljs-comment">/* Initialize the module */</span>&#13;
<span class="hljs-function">PyMODINIT_FUNC </span><span class="hljs-title">PyInit_sum_of_squares</span><span class="hljs-params">(</span><span class="hljs-keyword">void</span><span class="hljs-params">)</span>{&#13;
    <span class="hljs-keyword">return</span> PyModule_Create(&amp;<span class="hljs-keyword">module</span>);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">It looks quite complicated, but it’s really<a id="_idIndexMarker1566"/> not that hard. There is just a lot of overhead in this case because we only have a single function. Generally, you would have several functions, in which case you only need to expand the <code class="inlineCode">methods</code> array and create the functions. We will explain the code in more detail shortly, but first, let’s look at how to run our first example. We need to build and install the module:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_09_native/setup.py build install&#13;
running build&#13;
running build_ext&#13;
building 'sum_of_squares' extension ...&#13;
...&#13;
Processing dependencies for SumOfSquares==1.0&#13;
Finished processing dependencies for SumOfSquares==1.0&#13;
</code></pre>&#13;
    <p class="normal">Now, let’s create a little test script to time the difference between the Python version and the C version. First, some imports and setup:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> sys&#13;
<span class="hljs-keyword">import</span> timeit&#13;
<span class="hljs-keyword">import</span> argparse&#13;
<span class="hljs-keyword">import</span> functools&#13;
&#13;
<span class="hljs-keyword">from</span> sum_of_squares_py <span class="hljs-keyword">import</span> sum_of_squares <span class="hljs-keyword">as</span> sum_py&#13;
&#13;
<span class="hljs-keyword">try</span>:&#13;
    <span class="hljs-keyword">from</span> sum_of_squares <span class="hljs-keyword">import</span> sum_of_squares <span class="hljs-keyword">as</span> sum_c&#13;
<span class="hljs-keyword">except</span> ImportError:&#13;
    print(<span class="hljs-string">'Please run "python setup.py build install" first'</span>)&#13;
    sys.exit(<span class="hljs-number">1</span>)&#13;
</code></pre>&#13;
    <p class="normal">Now that we have the <a id="_idIndexMarker1567"/>modules imported (or got an error if you hadn’t run the build step yet), we can start benchmarking:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    parser = argparse.ArgumentParser()&#13;
    parser.add_argument(<span class="hljs-string">'repetitions'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)&#13;
    parser.add_argument(<span class="hljs-string">'maximum'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)&#13;
    args = parser.parse_args()&#13;
&#13;
    timer = functools.partial(&#13;
        timeit.timeit, number=args.repetitions, <span class="hljs-built_in">globals</span>=<span class="hljs-built_in">globals</span>())&#13;
&#13;
    print(<span class="hljs-string">f'Testing </span><span class="hljs-subst">{args.repetitions}</span><span class="hljs-string"> repetitions with maximum: '</span>&#13;
          <span class="hljs-string">f'</span><span class="hljs-subst">{args.maximum}</span><span class="hljs-string">'</span>)&#13;
&#13;
    result = sum_c(args.maximum)&#13;
    duration_c = timer(<span class="hljs-string">'sum_c(args.maximum)'</span>)&#13;
    print(<span class="hljs-string">f'C: </span><span class="hljs-subst">{result}</span><span class="hljs-string"> took </span><span class="hljs-subst">{duration_c:</span><span class="hljs-number">.3</span><span class="hljs-subst">f}</span><span class="hljs-string"> seconds'</span>)&#13;
&#13;
    result = sum_py(args.maximum)&#13;
    duration_py = timer(<span class="hljs-string">'sum_py(args.maximum)'</span>)&#13;
    print(<span class="hljs-string">f'Py: </span><span class="hljs-subst">{result}</span><span class="hljs-string"> took </span><span class="hljs-subst">{duration_py:</span><span class="hljs-number">.3</span><span class="hljs-subst">f}</span><span class="hljs-string"> seconds'</span>)&#13;
&#13;
    print(<span class="hljs-string">f'C was </span><span class="hljs-subst">{duration_py / duration_c:</span><span class="hljs-number">.1</span><span class="hljs-subst">f}</span><span class="hljs-string"> times faster'</span>)&#13;
</code></pre>&#13;
    <p class="normal">In essence, we have a basic benchmarking script where we compare the C version to the Python version here, with a configurable number of repetitions and a maximum number to test for. Now, let’s execute it:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_09_native/test.py 10000 1000000&#13;
Testing 10000 repetitions with maximum: 1000000&#13;
C: 332833500 took 0.009 seconds&#13;
Py: 332833500 took 1.264 seconds&#13;
C was 148.2 times faster&#13;
</code></pre>&#13;
    <p class="normal">Perfect! Exactly the same results but much faster.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">If your goal is speed alone, you should give <code class="inlineCode">numba</code> a try instead. Adding the <code class="inlineCode">@numba.njit</code> decorator to <code class="inlineCode">sum_of_squares_python</code> is much easier and probably even faster.</p>&#13;
    </div>&#13;
    <p class="normal">The main advantage of<a id="_idIndexMarker1568"/> writing C modules is the reuse of existing C code, however. For speedups, you are often better off with <code class="inlineCode">cython</code>, <code class="inlineCode">numba</code>, or converting your code to use libraries such as <code class="inlineCode">numpy</code> or <code class="inlineCode">jax</code>.</p>&#13;
    <h2 id="_idParaDest-526" class="heading-2">C is not Python – Size matters</h2>&#13;
    <p class="normal">The Python language makes <a id="_idIndexMarker1569"/>programming so easy that you might forget about the underlying data structures at times; with C and C++, you can’t afford to do that. Just take our example from the previous section but with different parameters:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_09_native/test.py 1000 10000000&#13;
Testing 1000 repetitions with maximum: 10000000&#13;
C sum of squares: 1953214233 took 0.003 seconds&#13;
Python sum of squares: 10543148825 took 0.407 seconds&#13;
C was 145.6 times faster&#13;
</code></pre>&#13;
    <p class="normal">It’s still very fast, but what happened to the numbers? The Python and C versions give different results, <code class="inlineCode">1953214233</code> versus <code class="inlineCode">10543148825</code>. This is caused by integer overflows in C. While Python numbers can essentially have any size, with C, a regular number has a fixed size. How much you get depends on the type you use (<code class="inlineCode">int</code>, <code class="inlineCode">long</code>, and so on) and your architecture (32-bit, 64-bit, and so on), but it’s definitely something to be careful with. It might be hundreds of times faster in some cases, but that is meaningless if the results are incorrect.</p>&#13;
    <p class="normal">We can increase the size a bit, of course. This makes it better:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> bigint;&#13;
&#13;
<span class="hljs-keyword">static</span><span class="hljs-function"> PyObject* </span><span class="hljs-title">sum_of_large_squares</span><span class="hljs-params">(PyObject *self, PyObject *args)</span>{&#13;
    <span class="hljs-comment">/* Declare the variables */</span>&#13;
    bigint n;&#13;
    bigint total = <span class="hljs-number">0</span>;&#13;
&#13;
    <span class="hljs-comment">/* Parse the arguments */</span>&#13;
    <span class="hljs-keyword">if</span>(!PyArg_ParseTuple(args, <span class="hljs-string">"K"</span>, &amp;n)){&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
    }&#13;
&#13;
    <span class="hljs-comment">/* The actual summing code */</span>&#13;
    <span class="hljs-keyword">for</span>(bigint i=<span class="hljs-number">0</span>; i&lt;n; i++){&#13;
        <span class="hljs-keyword">if</span>((i * i) &lt; n){&#13;
            total += i * i;&#13;
        }<span class="hljs-keyword">else</span>{&#13;
            <span class="hljs-keyword">break</span>;&#13;
        }&#13;
    }&#13;
&#13;
    <span class="hljs-comment">/* Return the number but convert it to a Python object first */</span>&#13;
    <span class="hljs-keyword">return</span> PyLong_FromUnsignedLongLong(total);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">We used <code class="inlineCode">typedef</code> to create a <code class="inlineCode">bigint</code> alias for <code class="inlineCode">unsigned long long int</code>.</p>&#13;
    <p class="normal">If we test it now, we<a id="_idIndexMarker1570"/> realize that it works great:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_10_size_matters/test.py 1000 10000000&#13;
Testing 1000 repetitions with maximum: 10000000&#13;
C: 10543148825 took 0.001 seconds&#13;
Py: 10543148825 took 0.405 seconds&#13;
C was 270.3 times faster&#13;
</code></pre>&#13;
    <p class="normal">And with the increased size, the difference in performance increases as well.</p>&#13;
    <p class="normal">Making the number even larger breaks things again since even an <code class="inlineCode">unsigned long long int</code> still has its limits:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_10_size_matters/test.py 1 100000000000000&#13;
Testing 1 repetitions with maximum: 100000000000000&#13;
C: 1291890006563070912 took 0.004 seconds&#13;
Py: 333333283333335000000 took 1.270 seconds&#13;
C was 293.7 times faster&#13;
</code></pre>&#13;
    <p class="normal">So, how can you fix this? The simple answer is that you can’t, and Python hasn’t really fixed it either. The complex answer is that you can if you use a different data type to store your data. The C language by itself doesn’t have the “big number support” that Python has.</p>&#13;
    <p class="normal">Python supports infinitely large numbers by combining several regular numbers in the actual memory and automatically switches to those types of numbers when needed. With Python 2, that was much more obvious with the distinction between the <code class="inlineCode">int</code> and <code class="inlineCode">long</code> types. With Python 3, the <code class="inlineCode">long</code> and <code class="inlineCode">int</code> types have been merged into the <code class="inlineCode">int</code> type. You will not notice the switchover to the <code class="inlineCode">long</code> type; it will automatically happen in the background.</p>&#13;
    <p class="normal">Within C, there are no commonly available provisions for this, so there is simply no easy way to get this working. But we can check for errors instead:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span><span class="hljs-function"> </span><span class="hljs-keyword">unsigned</span><span class="hljs-function"> </span><span class="hljs-keyword">long</span><span class="hljs-function"> </span><span class="hljs-keyword">long</span><span class="hljs-function"> </span><span class="hljs-keyword">int</span><span class="hljs-function"> </span><span class="hljs-title">get_number_from_object</span><span class="hljs-params">(</span><span class="hljs-keyword">int</span><span class="hljs-params">* overflow, </span>&#13;
<span class="hljs-params">        PyObject* some_very_large_number)</span>{&#13;
    <span class="hljs-keyword">return</span> PyLong_AsLongLongAndOverflow(sum, overflow);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Note that this only <a id="_idIndexMarker1571"/>works for <code class="inlineCode">PyObject*</code>, which means it doesn’t work for internal C overflows. However, you can, of course, just keep the original Python long around and perform operations on that instead. So, you do have big number support in C without too much effort.</p>&#13;
    <h2 id="_idParaDest-527" class="heading-2">The example explained</h2>&#13;
    <p class="normal">We have seen the results from our example, but if you’re not familiar with the Python C API, you might be confused as to why the function <a id="_idIndexMarker1572"/>parameters look the way they do. </p>&#13;
    <p class="normal">The basic calculations within <code class="inlineCode">sum_of_squares</code> are identical to the regular C <code class="inlineCode">sum_of_squares</code> function, but there are a few small differences. Firstly, the type definition for a function using the Python C API should look something like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span><span class="hljs-function"> PyObject* </span><span class="hljs-title">sum_of_squares</span><span class="hljs-params">(PyObject *self, PyObject *args);</span>&#13;
</code></pre>&#13;
    <p class="normal">Let’s break this down.</p>&#13;
    <h3 id="_idParaDest-528" class="heading-3">static</h3>&#13;
    <p class="normal">This means that the function is <strong class="keyWord">static</strong>. A function<a id="_idIndexMarker1573"/> that’s static can be called only from the same translation unit within the compiler. This effectively results in a function that cannot be linked (imported/used) from other modules, which allows the compiler to optimize a bit further. Since functions in C are global by default, this can be very useful in preventing naming collisions. Just to be sure, however, you could prefix your function names with the name of the module if you use a name that is less likely to be unique.</p>&#13;
    <p class="normal">Be careful not to<a id="_idIndexMarker1574"/> confuse the word <code class="inlineCode">static</code> here with the <code class="inlineCode">static</code> before a variable. They are completely different beasts. A <code class="inlineCode">static</code> variable means that the variable will exist for the entire runtime of the program instead of the runtime of just the function.</p>&#13;
    <h3 id="_idParaDest-529" class="heading-3">PyObject*</h3>&#13;
    <p class="normal">The <code class="inlineCode">PyObject</code> type is the basic type for Python data types, which means that all Python objects can be cast to <code class="inlineCode">PyObject*</code> (the <code class="inlineCode">PyObject</code> pointer). Effectively, it only tells the compiler what kind of <a id="_idIndexMarker1575"/>properties to expect, which can be used later for type identification and memory management. Instead of direct access to <code class="inlineCode">PyObject*</code>, it is generally a better idea to use the available macros, such as <code class="inlineCode">Py_TYPE(some_object)</code>. Internally, this expands to <code class="inlineCode">(((PyObject*)(o))-&gt;ob_type)</code>, which is why the macro is generally a better idea. Besides being unreadable, a typo can easily happen.</p>&#13;
    <p class="normal">The list of properties is long and depends greatly on the type of object. For those, you can refer to the Python documentation: <a href="https://docs.python.org/3/c-api/typeobj.html"><span class="url">https://docs.python.org/3/c-api/typeobj.html</span></a>.</p>&#13;
    <p class="normal">The entire Python C API could fill a book of its own, but it is luckily well documented within the Python manual. Its usage, on the other hand, might be less obvious.</p>&#13;
    <h3 id="_idParaDest-530" class="heading-3">Parsing arguments</h3>&#13;
    <p class="normal">With regular C and Python, you<a id="_idIndexMarker1576"/> specify the arguments explicitly, since variable-sized arguments are a bit tricky with C. This is because they need to be parsed separately. <code class="inlineCode">PyObject* args</code> is the reference to objects containing the actual values. To parse these, you need to know how many and which type of variables to expect. In the example, we used the <code class="inlineCode">PyArg_ParseTuple</code> function, which parses the arguments as positional arguments only, but it is quite easily possible to parse named arguments as well using <code class="inlineCode">PyArg_ParseTupleAndKeywords</code> or <code class="inlineCode">PyArg_VaParseTupleAndKeywords</code>. The difference between these is that the first one uses a variable number of arguments to specify the destination and the latter uses a <code class="inlineCode">va_list</code> to set the values to. </p>&#13;
    <p class="normal">Let’s analyze the code from the actual example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span>(!PyArg_ParseTuple(args, <span class="hljs-string">"i"</span>, &amp;n)){&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">We know that <code class="inlineCode">args</code> is the object containing the reference to the actual arguments. The <code class="inlineCode">"i"</code> is a format string, which in this case will try to parse a single integer. <code class="inlineCode">&amp;n</code> tells the function to store the value at the memory address of the <code class="inlineCode">n</code> variable.</p>&#13;
    <p class="normal">The format string is the<a id="_idIndexMarker1577"/> important part here. Depending on the character, you get a different data type, but there are many; <code class="inlineCode">i</code> specifies a regular integer, and <code class="inlineCode">s</code> converts your variable to a C-string (actually a <code class="inlineCode">char*</code>, which is a null-terminated character array). It should be noted that this function is, luckily, smart enough to take overflows into consideration as well.</p>&#13;
    <p class="normal">Parsing multiple arguments is quite similar; you need to add multiple characters to the format string and multiple destination variables:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">PyObject* callback;&#13;
<span class="hljs-keyword">int</span> n;&#13;
&#13;
<span class="hljs-comment">/* Parse the arguments */</span>&#13;
<span class="hljs-keyword">if</span>(!PyArg_ParseTuple(args, <span class="hljs-string">"Oi"</span>, &amp;callback, &amp;n)){&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">The version with keyword arguments is similar, but requires a few more code changes as the list of methods needs to be informed that the function takes keyword arguments. Otherwise, the <code class="inlineCode">kwargs</code> parameter would never arrive:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span><span class="hljs-function"> PyObject* </span><span class="hljs-title">function</span><span class="hljs-params">(</span>&#13;
<span class="hljs-params">        PyObject *self,</span>&#13;
<span class="hljs-params">        PyObject *args,</span>&#13;
<span class="hljs-params">        PyObject *kwargs)</span>{&#13;
    <span class="hljs-comment">/* Declare the variables */</span>&#13;
    PyObject* callback;&#13;
    <span class="hljs-keyword">int</span> n;&#13;
&#13;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>* keywords[] = {<span class="hljs-string">"</span><span class="hljs-string">callback"</span>, <span class="hljs-string">"n"</span>, <span class="hljs-literal">NULL</span>};&#13;
&#13;
    <span class="hljs-comment">/* Parse the arguments */</span>&#13;
    <span class="hljs-keyword">if</span>(!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="hljs-string">"Oi"</span>, keywords,&#13;
                &amp;callback, &amp;n)){&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
    }&#13;
&#13;
    Py_RETURN_NONE;&#13;
}&#13;
&#13;
<span class="hljs-keyword">static</span> PyMethodDef methods[] = {&#13;
    <span class="hljs-comment">/* Register the function with kwargs */</span>&#13;
    {<span class="hljs-string">"</span><span class="hljs-string">function"</span>, function, METH_VARARGS | METH_KEYWORDS,&#13;
     <span class="hljs-string">"Some kwargs function"</span>},&#13;
    <span class="hljs-comment">/* Indicate the end of the list */</span>&#13;
    {<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>},&#13;
};&#13;
</code></pre>&#13;
    <p class="normal">Let’s look at the differences from the <a id="_idIndexMarker1578"/>version that only supported <code class="inlineCode">*args</code>:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">Similar to pure Python, our function header now includes <code class="inlineCode">PyObject *kwargs</code>.</li>&#13;
      <li class="numberedList">Because we need to pre-allocate strings in C, we have an array of words called <code class="inlineCode">keywords</code> with all of the <code class="inlineCode">kwargs</code> we plan to parse.</li>&#13;
      <li class="numberedList">Instead of <code class="inlineCode">PyArg_ParseTuple</code> we now have to use <code class="inlineCode">PyArg_ParseTupleAndKeywords</code>. This function overlaps the <code class="inlineCode">PyArg_ParseTuple</code> function and adds keyword parsing by walking through the previously defined <code class="inlineCode">keywords</code> array.</li>&#13;
      <li class="numberedList">At the function registry, we need to specify that the function supports keyword arguments by adding the <code class="inlineCode">METH_KEYWORDS</code> flag in addition to the <code class="inlineCode">METH_VARARGS</code> flag.</li>&#13;
    </ol>&#13;
    <p class="normal">Note that this still supports normal arguments, but keyword arguments are also supported now.</p>&#13;
    <h2 id="_idParaDest-531" class="heading-2">C is not Python – Errors are silent or lethal</h2>&#13;
    <p class="normal">As we saw in a previous<a id="_idIndexMarker1579"/> example, integer overflows are not something you will generally notice, and unfortunately, there’s no good cross-platform way to catch them. However, those are actually the easier errors to handle; the worst one is generally memory management. With Python, if you get an error, you will get an exception that you can catch. With C, you can’t really handle it gracefully. Take a division by zero, for example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 -c <span class="hljs-con-string">'1/0'</span>&#13;
Traceback (most recent call last):&#13;
  File "&lt;string&gt;", line 1, in &lt;module&gt;&#13;
ZeroDivisionError: division by zero&#13;
</code></pre>&#13;
    <p class="normal">This is simple enough to catch with <code class="inlineCode">try: ... except ZeroDivisionError: ...</code>. With C, on the other hand, if you get a<a id="_idIndexMarker1580"/> bad error, it will kill your entire process. But debugging C code is what C compilers have debuggers for, and to find the cause of the error, you can use the <code class="inlineCode">faulthandler</code> module discussed in <em class="chapterRef">Chapter 11</em>, <em class="italic">Debugging – Solving the Bugs</em>. Right now, let’s see how we can properly throw errors from C:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span><span class="hljs-function"> PyObject* </span><span class="hljs-title">count_eggs</span><span class="hljs-params">(PyObject *self, PyObject *args)</span>{&#13;
    PyErr_SetString(PyExc_RuntimeError, <span class="hljs-string">"Too many eggs!"</span>);&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">When executing this, it will effectively run <code class="inlineCode">raise RuntimeError('Too many eggs!')</code>. The syntax is slightly different—<code class="inlineCode">PyErr_SetString</code> instead of <code class="inlineCode">raise</code>—but it’s the same basic principle.</p>&#13;
    <h2 id="_idParaDest-532" class="heading-2">Calling Python from C – Handling complex types</h2>&#13;
    <p class="normal">We have seen how to<a id="_idIndexMarker1581"/> call C functions from Python, but now let’s try Python from C and back. Instead of using the readily available <code class="inlineCode">sum</code> function, we will build one of our own with<a id="_idIndexMarker1582"/> a callback and handling of any type of iterable. While this sounds simple enough, it does actually require a bit of type meddling, as you can only expect <code class="inlineCode">PyObject*</code> as arguments. This is contrary to the simple types, such as integers, chars, and strings, which are immediately converted to the native Python version. </p>&#13;
    <div class="note">&#13;
      <p class="normal">For clarity, this is just a single function that is broken up into multiple parts.</p>&#13;
    </div>&#13;
    <p class="normal">First, we start with the <code class="inlineCode">include</code> function signature, and the declaration of the variables we need. Note that the values for <code class="inlineCode">total</code> and <code class="inlineCode">callback</code> are defaults in the event that these arguments are not specified:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#</span><span class="hljs-meta-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-meta-string">&lt;Python.h&gt;</span>&#13;
&#13;
<span class="hljs-keyword">static</span><span class="hljs-function"> PyObject* </span><span class="hljs-title">custom_sum</span><span class="hljs-params">(PyObject* self, PyObject* args)</span>{&#13;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;&#13;
    <span class="hljs-keyword">int</span> overflow = <span class="hljs-number">0</span>;&#13;
    PyObject* iterator;&#13;
    PyObject* iterable;&#13;
    PyObject* callback = <span class="hljs-literal">NULL</span>;&#13;
    PyObject* value;&#13;
    PyObject* item;&#13;
</code></pre>&#13;
    <p class="normal">Now we parse a <code class="inlineCode">PyObject*</code> followed by, optionally (the | character), a <code class="inlineCode">PyObject*</code> and a <code class="inlineCode">long long int</code>. This is specified by the <code class="inlineCode">O|OL</code> argument. The results will be stored in the memory addresses (the <code class="inlineCode">&amp;</code> sends the <a id="_idIndexMarker1583"/>memory address of a variable) of <code class="inlineCode">iterable</code>, <code class="inlineCode">callback</code>, and <code class="inlineCode">total</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span>(!PyArg_ParseTuple(args, <span class="hljs-string">"O|OL"</span>, &amp;iterable, &amp;callback, &amp;total)){&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
    }&#13;
</code></pre>&#13;
    <p class="normal">We see if we can create an iterator from the iterable. This is effectively the same as doing <code class="inlineCode">iter(iterable)</code> in Python:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    iterator = PyObject_GetIter(iterable);&#13;
    <span class="hljs-keyword">if</span>(iterator == <span class="hljs-literal">NULL</span>){&#13;
        PyErr_SetString(PyExc_TypeError,&#13;
                <span class="hljs-string">"Argument is not iterable"</span>);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
    }&#13;
</code></pre>&#13;
    <p class="normal">Next, we check whether the<a id="_idIndexMarker1584"/> callback exists or wasn’t specified. If it was specified, check whether it’s callable or not:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span>(callback != <span class="hljs-literal">NULL</span> &amp;&amp; !PyCallable_Check(callback)){&#13;
        PyErr_SetString(PyExc_TypeError, <span class="hljs-string">"Callback is not callable"</span>);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
    }&#13;
</code></pre>&#13;
    <p class="normal">Looping through the iterable, if we have a callback available, we call it. Otherwise, we just use the <code class="inlineCode">item</code> as the <code class="inlineCode">value</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">while</span>((item = PyIter_Next(iterator))){&#13;
        <span class="hljs-keyword">if</span>(callback == <span class="hljs-literal">NULL</span>){&#13;
            value = item;&#13;
        }<span class="hljs-keyword">else</span>{&#13;
            value = PyObject_CallFunction(callback, <span class="hljs-string">"O"</span>, item);&#13;
        }&#13;
</code></pre>&#13;
    <p class="normal">We add the value to <code class="inlineCode">total</code> and check for overflows:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">        total += PyLong_AsLongLongAndOverflow(value, &amp;overflow);&#13;
        <span class="hljs-keyword">if</span>(overflow &gt; <span class="hljs-number">0</span>){&#13;
            PyErr_SetString(PyExc_RuntimeError, <span class="hljs-string">"Integer overflow"</span>);&#13;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(overflow &lt; <span class="hljs-number">0</span>){&#13;
            PyErr_SetString(PyExc_RuntimeError, <span class="hljs-string">"Integer underflow"</span>);&#13;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#13;
        }&#13;
</code></pre>&#13;
    <p class="normal">If we were indeed using the callback, we decrease the reference count to the value because it is a separate object now. </p>&#13;
    <p class="normal">We also need to dereference <code class="inlineCode">item</code> and the iterator. Forgetting to do this<a id="_idIndexMarker1585"/> results in memory leaks because it decreases the reference count for the Python garbage collector. </p>&#13;
    <p class="normal">So, always make sure you call the <code class="inlineCode">PyDECREF</code> function after using <code class="inlineCode">PyObject*</code> types:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-keyword">if</span>(callback != <span class="hljs-literal">NULL</span>){&#13;
            Py_DECREF(value);&#13;
        }&#13;
        Py_DECREF(item);&#13;
    }&#13;
    Py_DECREF(iterator);&#13;
</code></pre>&#13;
    <p class="normal">Lastly, we need to convert <code class="inlineCode">total</code> to the correct return type and return it:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    return PyLong_FromLongLong(total);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">This function is callable in three <a id="_idIndexMarker1586"/>different ways. When given only an iterable, it will sum the iterable and return the value. Optionally, we can pass a callback function, which will be applied to each value in the iterable before summing. As a second optional parameter, we can specify the initial value to start with:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> x = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> custom_sum(x)&#13;
45&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> custom_sum(x, <span class="hljs-con-keyword">lambda</span> y: y + <span class="hljs-con-number">5</span>)&#13;
95&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> custom_sum(x, <span class="hljs-con-keyword">lambda</span> y: y + <span class="hljs-con-number">5</span>, <span class="hljs-con-number">5</span>)&#13;
100&#13;
</code></pre>&#13;
    <p class="normal">Another important issue is that even though we catch overflow errors when converting to <code class="inlineCode">long long int</code>, this code is still not safe. If we sum even two very large numbers (close to the <code class="inlineCode">long long int</code> limit), we will still have an overflow:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> spam&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> n = (<span class="hljs-con-number">2</span> ** <span class="hljs-con-number">63</span>) - <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x = n,&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam.<span class="hljs-con-built_in">sum</span>(x)&#13;
9223372036854775807&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x = n, n&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam.<span class="hljs-con-built_in">sum</span>(x)&#13;
-2&#13;
</code></pre>&#13;
    <p class="normal">In this case, you could<a id="_idIndexMarker1587"/> test for this by doing something like <code class="inlineCode">if(value &gt; INT_MAX - total)</code>, but that <a id="_idIndexMarker1588"/>solution does not always apply, so it is most important to be conscious of overflows and underflows when using C.</p>&#13;
    <h1 id="_idParaDest-533" class="heading-1">Exercises</h1>&#13;
    <p class="normal">The possibilities with external libraries are endless, so perhaps you already have some ideas about what to implement. If not, here’s some inspiration:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Try to sort a list of numbers using <code class="inlineCode">ctypes</code>, <code class="inlineCode">CFFI</code>, and with a native extension. You can use the <code class="inlineCode">qsort</code> function in <code class="inlineCode">stdlib</code>.</li>&#13;
      <li class="bulletList">Try to make the <code class="inlineCode">custom_sum</code> function we created safer by adding proper errors for overflow/underflow issues. Additionally, catch the errors when summing multiple numbers that only overflow or underflow in summation.</li>&#13;
    </ul>&#13;
    <p class="normal">These exercises should be a nice starting point for doing something useful with your newly acquired knowledge. If you are looking for more of the native C/C++ examples, I would recommend looking through the CPython source. There are many examples available: <a href="https://github.com/python/cpython/tree/main/Modules"><span class="url">https://github.com/python/cpython/tree/main/Modules</span></a>. I would suggest starting with a relatively simple one such as the <code class="inlineCode">bisect</code> module.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_17.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-534" class="heading-1">Summary</h1>&#13;
    <p class="normal">In this chapter, you learned about writing and using extensions in C/C++. As a quick recap, we covered:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Loading external (system) libraries such as <code class="inlineCode">stdlib</code> using <code class="inlineCode">ctypes</code></li>&#13;
      <li class="bulletList">Creating and handling complex data structures using <code class="inlineCode">ctypes</code> and <code class="inlineCode">CFFI</code></li>&#13;
      <li class="bulletList">Handling arrays using <code class="inlineCode">ctypes</code> and <code class="inlineCode">CFFI</code></li>&#13;
      <li class="bulletList">Combining C and Python functions</li>&#13;
      <li class="bulletList">Important caveats regarding numeric types, arrays, overflows, and other error handling</li>&#13;
    </ul>&#13;
    <p class="normal">Even though you can now create C/C++ extensions, I still recommend that you avoid them, if possible, because it is so easy to end up with bugs. Even the code examples in this chapter don’t handle many of the possible error scenarios and, as opposed to errors in Python, if these errors happen in C, they can kill your interpreter or application entirely.</p>&#13;
    <p class="normal">If your goal is better performance, then I would recommend trying <code class="inlineCode">numba</code> or <code class="inlineCode">cython</code> instead. If you really need interoperability with non-Python libraries, however, these libraries are good options. A few examples of universal libraries such as these are TensorFlow and OpenCV, which are available in many languages and have Python wrappers for convenience.</p>&#13;
    <p class="normal">While building the examples in this chapter, you may have noticed that we used a <code class="inlineCode">setup.py</code> file and imported from the <code class="inlineCode">setuptools</code> library. This is what the next chapter will cover: packaging your code into an installable Python library and distributing it on the Python Package Index.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>