- en: Chapter 9. Building Robots
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章.构建机器人
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building a Rover-Pi robot with forward driving motors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正向驱动电机构建Rover-Pi机器人
- en: Using advanced motor control
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级电机控制
- en: Building a six-legged Pi-Bug robot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个六足Pi-Bug机器人
- en: Controlling servos directly with ServoBlaster
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ServoBlaster直接控制伺服机构
- en: Avoiding objects and obstacles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免物体和障碍物
- en: Getting a sense of direction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得方向感
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A little computer with a "brain the size of a planet" (to quote Douglas Adams,
    the author of *Hitchhikers Guide to the Galaxy*) is perfect to be the brain of
    your own robotic creation. In reality, the Raspberry Pi probably provides far
    more processing power than a little robot or rover would need; however, its small
    size, excellent connectivity, and fairly low-power requirements mean that it is
    ideally suited.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一台“大脑大小如行星”的小型计算机（引用道格拉斯·亚当斯，《银河系漫游指南》的作者）是您自己机器人创造物的理想大脑。实际上，树莓派可能提供的处理能力远远超过一个小型机器人或越野车所需的；然而，其小巧的尺寸、优秀的连接性和相对较低的能量需求意味着它非常适合。
- en: This chapter will focus on exploring the various ways in which we can combine
    motors or servos to produce robotic movement and use sensors to gather information
    and allow our creation to act upon it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点探讨我们可以将电机或伺服机构以何种方式组合起来产生机器人运动，并使用传感器收集信息，使我们的创造物能够对其做出反应的各种方法。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to check out the [Appendix](apa.html "Appendix A. Hardware and Software
    List"), *Hardware and Software List*; it lists all the items used in this chapter
    and the places you can obtain them from.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必查看[附录](apa.html "附录A.硬件和软件列表")，*硬件和软件列表*；它列出了本章中使用的所有物品及其获取地点。
- en: Building a Rover-Pi robot with forward driving motors
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正向驱动电机构建Rover-Pi机器人
- en: Creating robots does not need to be an expensive hobby. A small, rover-type
    robot can be constructed using household items for the chassis (the base everything
    is attached to), and a couple of small driving motors can be used to move it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 构建机器人不必是一项昂贵的爱好。可以使用家用物品构建一个小型、越野车型的机器人作为底盘（即所有部件都连接到的基座），并且可以使用几个小型驱动电机来移动它。
- en: 'The Rover-Pi robot is a small, buggy-type robot that has just two wheels and
    a skid or caster at the front to allow it to turn. One such robot is shown in
    the following image:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rover-Pi机器人是一种小型、越野车型的机器人，它只有两个轮子和前部的滑轮或万向轮，以便它能够转向。以下图片展示了一个这样的机器人：
- en: '![Building a Rover-Pi robot with forward driving motors](img/6623OT_09_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![使用正向驱动电机构建Rover-Pi机器人](img/6623OT_09_001.jpg)'
- en: A home-built Rover-Pi robot
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 自制Rover-Pi机器人
- en: While it may not be in the same league as a Mars Exploration Rover, as you will
    see, there is plenty for you to experiment with.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它可能无法与火星探测车相提并论，但正如您将看到的，您有很多可以实验的东西。
- en: You can also purchase many inexpensive robot kits that contain most of what
    you need in a single package (see the *There's more…* section at the end of this
    example).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以购买许多价格低廉的机器人套件，这些套件包含您在一个包装中所需的大部分东西（请参阅本例末尾的*更多内容*部分）。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The Rover we are building will need to contain the elements shown in the following
    diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的Rover将需要包含以下图中所示的元素：
- en: '![Getting ready](img/6623OT_09_002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_09_002.jpg)'
- en: The separate parts of the Rover-Pi robot
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Rover-Pi机器人的各个部分
- en: 'The elements are discussed in detail as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将详细讨论这些元素：
- en: '**Chassis**: This example uses a modified, battery-operated push nightlight
    (although any suitable platform can be used). Remember that the larger and heavier
    your robot is, the more powerful the driving motors will need to be to move it.
    Alternatively, you can use one of the chassis kits listed in the *There''s more…*
    section. A suitable push nightlight is shown in the following image:![Getting
    ready](img/6623OT_09_003.jpg)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底盘**：本例使用了一个修改过的、电池供电的推杆夜灯（尽管任何合适的平台都可以使用）。请记住，您的机器人越大、越重，驱动电机就需要越强大才能移动它。或者，您也可以使用*更多内容*部分中列出的底盘套件之一。以下图片展示了一个合适的推杆夜灯：![准备中](img/6623OT_09_003.jpg)'
- en: This push nightlight forms the basic chassis of a Rover-Pi robot
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这款推杆夜灯构成了Rover-Pi机器人的基本底盘
- en: '**Front skid or caster**: This can be as simple as a large paper clip (76 mm/3
    inches) bent into shape, or a small caster wheel. A skid works best when it is
    on a smooth surface, but it may get stuck on the carpet. A caster wheel works
    well on all surfaces, but sometimes, it can have problems turning.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前滑或转向轮**: 这可以简单到用一个大曲别针（76 mm/3 英寸）弯曲成形状，或者一个小转向轮。滑轮在光滑表面上工作时效果最佳，但它可能会卡在地毯上。转向轮在所有表面上都能很好地工作，但有时可能会在转向时出现问题。'
- en: '**Wheels**, **motors**, and **gears**: The wheel movement of the Rover-Pi robot
    is a combination of the motor, gears, and wheels. The gears are helpful as they
    allow a fast-spinning motor to turn the wheels at a slower speed and more force
    (torque); this will allow better control of our robot. A unit that combines the
    wheels, motors, and gears in a single unit is shown in the following image:![Getting
    ready](img/6623OT_09_004.jpg)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮子**、**电机**和**齿轮**: Rover-Pi 机器人的轮子移动是电机、齿轮和轮子的组合。齿轮很有用，因为它们允许高速旋转的电机以较慢的速度和更大的力量（扭矩）转动轮子；这将允许更好地控制我们的机器人。以下图片显示了一个将轮子、电机和齿轮组合在一起的单元：![准备中](img/6623OT_09_004.jpg)'
- en: These wheels with built-in geared motors are ideal for small rovers
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些内置齿轮电机的轮子非常适合小型巡游车
- en: '**Battery/power source**: The Rover-Pi robot will be powered using 4 x AA batteries
    fitted into the bay of the chassis. Alternatively, a standard battery holder can
    be used, or even a long wire connected to suitable power supply. It is recommended
    that you power the motors from a supply independent from the Raspberry Pi. This
    will help avoid a situation in which the Raspberry Pi suddenly loses power when
    driving the motors, which requires a big jump in current to move. Alternatively,
    you can power the Raspberry Pi with the batteries using a 5V regulator. The following
    image shows a chassis with 4 x AA batteries:![Getting ready](img/6623OT_09_005.jpg)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电池/电源**: Rover-Pi 机器人将使用安装在底盘托架中的 4 节 AA 电池供电。或者，可以使用标准电池盒，甚至可以使用一根长线连接到合适的电源。建议您从独立于
    Raspberry Pi 的电源为电机供电。这将有助于避免在驱动电机时，当需要大幅增加电流以移动时，Raspberry Pi 突然断电的情况。或者，您可以使用
    5V 稳压器用电池为 Raspberry Pi 供电。以下图片显示了一个带有 4 节 AA 电池的底盘：![准备中](img/6623OT_09_005.jpg)'
- en: 4x AA batteries provide a power source to drive the wheels
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4 节 AA 电池为驱动轮提供电源
- en: '**Motor driver/controller**: Motors will require a voltage and current greater
    than the GPIO can handle. Therefore, we will use a **Darlington array module**
    (which uses a **ULN2003** chip). See the *There''s more…* section at the end of
    this example for more details on how this particular module works. The following
    image shows a Darlington array module:![Getting ready](img/6623OT_09_006.jpg)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电机驱动器/控制器**: 电机需要比 GPIO 可以处理的电压和电流更大的电压和电流。因此，我们将使用 **Darlington 阵列模块**（它使用
    **ULN2003** 芯片）。请参阅本例末尾的 *更多内容...* 部分，以了解更多有关该特定模块如何工作的详细信息。以下图片显示了一个 Darlington
    阵列模块：![准备中](img/6623OT_09_006.jpg)'
- en: This Darlington array module, available at dx.com, can be used to drive small
    motors
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 dx.com 上可用的 Darlington 阵列模块可以用来驱动小型电机
- en: '**Small cable ties or wire ties**: This will allow us to attach items such
    as the motors or a controller to the chassis. The following image shows the use
    of cable ties:![Getting ready](img/6623OT_09_007.jpg)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型电缆扎带或线扎带**: 这将使我们能够将电机或控制器等物品固定在底盘上。以下图片显示了电缆扎带的使用：![准备中](img/6623OT_09_007.jpg)'
- en: We use cable ties to secure the motors and wheels to the chassis
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用电缆扎带来固定电机和轮子到底盘上
- en: '**The Raspberry Pi connection**: The easiest setup is to attach the control
    wires to the Raspberry Pi using long cables, so you can easily control your robot
    directly using an attached screen and keyboard. Later, you can consider mounting
    the Raspberry Pi on the robot and controlling it remotely (or even autonomously
    if you include sensors and intelligence to make sense of them).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Raspberry Pi 连接**: 最简单的设置是将控制线通过长线连接到 Raspberry Pi，这样您就可以通过连接的屏幕和键盘直接轻松控制您的机器人。稍后，您可以考虑将
    Raspberry Pi 安装在机器人上，并远程（或者如果您包括传感器和智能来理解它们，甚至可以自主）控制它。'
- en: In this chapter, we will use the **WiringPi2** Python library to control the
    GPIO; see [Chapter 7](ch07.html "Chapter 7. Sense and Display Real-World Data"),
    *Sense and Display Real-World Data*, for details on how to install it using PIP
    (a Python package manager).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 **WiringPi2** Python 库来控制 GPIO；有关如何使用 PIP（Python 包管理器）安装它的详细信息，请参阅[第
    7 章](ch07.html "第 7 章. 感知和显示现实世界数据")，*感知和显示现实世界数据*。
- en: How to do it…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to create a small Rover-Pi robot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建一个小型Rover-Pi机器人：
- en: At the front of the chassis, you will need to mount the skid by bending the
    paperclip/wire into a V shape. Attach the paperclip/wire to the front of the chassis
    by drilling small holes on either side, and thread cable ties through the holes
    around the wire and pull tight to secure. The fitted wire skid should look similar
    to the one shown in the following image:![How to do it…](img/6623OT_09_008.jpg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在底盘的前方，你需要通过将纸夹/电线弯曲成V形来安装滑轨。通过在两侧钻小孔将纸夹/电线固定在底盘前方，并通过电线周围的孔穿过电缆扎带并拉紧以固定。安装好的电线滑轨应类似于以下图片所示：![如何操作…](img/6623OT_09_008.jpg)
- en: Wire skid fitted to the front of the Rover-Pi robot
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将滑轨安装在Rover-Pi机器人的前方
- en: Before you mount the wheels, you need to work out the approximate center of
    gravity of the chassis (do this with the batteries fitted in the chassis as they
    will affect the balance). Get a feel of where the center is by trying to balance
    the unit on two fingers on either side, and find out how far forward or backward
    the chassis tilts. For my unit, this was about 1 cm (approximately one-third of
    an inch) back from the center. You should aim to place the wheel axles slightly
    behind this so that the Rover will rest slightly forward on the skid. Mark the
    location of the wheels on the chassis.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装轮子之前，你需要计算出底盘的大致重心（在底盘中安装电池时进行此操作，因为它们会影响平衡）。通过尝试用两侧的两根手指平衡单元来感受重心的位置，并找出底盘向前或向后倾斜的程度。对于我的单元，这大约是在中心后1厘米（大约三分之一英寸）的位置。你应该将轮轴稍微放在这个位置之后，以便Rover在滑轨上稍微向前倾斜。在底盘上标记轮子的位置。
- en: Drill three holes on each side to mount the wheels using the cable ties. If
    the cable ties aren't long enough, you can join two together by pulling the end
    of one through the end of the other (only pull through far enough for the tie
    to grip so that it extends the tie). The following diagram shows how you can use
    the cable ties:![How to do it…](img/6623OT_09_009.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每侧钻三个孔，使用电缆扎带安装轮子。如果电缆扎带不够长，可以将两个扎带连接在一起，通过将一个扎带的末端穿过另一个扎带的末端（只拉到扎带能够抓住的程度，以便延长扎带）。以下图示显示了如何使用电缆扎带：![如何操作…](img/6623OT_09_009.jpg)
- en: Securely fix the motors to the chassis
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将电机牢固地固定在底盘上
- en: Next, test the motors by inserting the batteries into the unit; then, disconnect
    the wires that originally connected to the bulb and touch them to the motor contacts.
    Determine which connection on the motor should be positive and which should be
    negative for the motor to move the robot forward (the top of the wheel should
    move forward when the robot is facing forwards). Connect red and black wires to
    the motor (on mine, black equals negative at the top and red equals positive at
    the bottom of the motor), ensuring that the wires are long enough to reach anywhere
    on the chassis (around 14 cm, that is, approximately 5 and a half inches is enough
    for the nightlight).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过将电池插入单元来测试电机；然后，断开原本连接到灯泡的电线，并将它们接触到电机触点上。确定电机上哪个连接应该是正极，哪个应该是负极，以便机器人向前移动（当机器人面向前方时，轮子的顶部应该向前移动）。将红黑电线连接到电机（在我的机器上，黑色在电机顶部是负极，红色在电机底部是正极），确保电线足够长，可以到达底盘上的任何位置（大约14厘米，即大约五又二分之一英寸就足够用于夜灯）。
- en: 'The Rover-Pi robot components should be wired up as shown in the following
    diagram:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rover-Pi机器人的组件应按照以下图示进行接线：
- en: '![How to do it…](img/6623OT_09_010.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/6623OT_09_010.jpg)'
- en: The wiring layout of the Rover-Pi robot
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rover-Pi机器人的接线布局
- en: 'To make the connections, perform the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立连接，请执行以下步骤：
- en: Connect the black wires of the motors to the **OUT 1** (left) and **OUT 2**
    (right) output of the Darlington module, and connect the red wires to the last
    pin (the COM connection).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电机的黑色电线连接到达林顿模块的**OUT 1**（左侧）和**OUT 2**（右侧）输出，将红色电线连接到最后一个引脚（COM连接）。
- en: Next, connect the battery wires to the **GND**/**V-** and **V+** connections
    at the bottom of the module.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将电池电线连接到模块底部的**GND**/**V-**和**V+**连接。
- en: Finally, connect the **GND** from the GPIO connector (**Pin 6**) to the same
    **GND** connection.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将GPIO连接器的**GND**（**引脚6**）连接到相同的**GND**连接。
- en: Test the motor control by connecting 3.3V (GPIO **Pin 1**) to **IN1** or **IN2**
    to simulate a GPIO output. When happy, connect GPIO **Pin 16** to **IN1** (for
    left) and GPIO **Pin 18** to **IN2** (for right).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将3.3V（GPIO **引脚1**）连接到**IN1**或**IN2**来测试电机控制，以模拟GPIO输出。当你满意时，将GPIO **引脚16**连接到**IN1**（用于左侧）和GPIO
    **引脚18**连接到**IN2**（用于右侧）。
- en: 'The wiring should now match the details given in the following table:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 线路现在应与以下表格中给出的细节相匹配：
- en: '| Raspberry Pi GPIO | Darlington module |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| Raspberry Pi GPIO | 达林顿模块 |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Pin 16: Left | IN1 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 引脚16：左侧 | IN1 |'
- en: '| Pin 18: Right | IN2 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 引脚18：右侧 | IN2 |'
- en: '| Pin 6: GND | GND/V- (marked with "–") |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 引脚6：GND | GND/V-（标记为“–”）|'
- en: '| **Motor 4 x AA battery Darlington module** |   |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **电机4 x AA电池达林顿模块** |   |'
- en: '| Positive side of battery | V+ (marked with "+") |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 电池正极 | V+（标记为“+”）|'
- en: '| Negative side of battery | GND/V- (marked with "–") |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 电池负极 | GND/V-（标记为“–”）|'
- en: '| **Motors** |   |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **电机** |   |'
- en: '| Left motor: black wire | OUT 1 (top pin in white socket) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 左电机：黑色导线 | OUT 1（白色插座中的顶部引脚）|'
- en: '| Right motor: black wire | OUT 2 (second pin in white socket) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 右电机：黑色导线 | OUT 2（白色插座中的第二个引脚）|'
- en: '| Both motors: red wires | COM (last pin in white socket) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 两个电机：红色导线 | COM（白色插座中的最后一个引脚）|'
- en: 'Use the following `rover_drivefwd.py` script to test the control:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下`rover_drivefwd.py`脚本来测试控制：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that WiringPi2 should be installed before running the scripts in this
    chapter (see [Chapter 7](ch07.html "Chapter 7. Sense and Display Real-World Data"),
    *Sense and Display Real-world Data*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在运行本章中的脚本之前应该安装WiringPi2（见[第7章](ch07.html "第7章. 感知和显示现实世界数据")，*感知和显示现实世界数据*）。
- en: 'Run the previous code using the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行之前的代码：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The script will prompt you with following message:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将提示以下信息：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can enter a series of commands to follow, for example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以输入一系列要执行的命令，例如：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous command will instruct the Rover-Pi robot to perform a series of
    movements—forward (`f`), right (`r`), pause (`#`), and left (`l`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将指示Rover-Pi机器人执行一系列移动——向前（`f`）、向右（`r`）、暂停（`#`）和向左（`l`）。
- en: How it works…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once you have built the robot and wired up the wheels to the motor controller,
    you can discover how to control it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建了机器人并将轮子连接到电机控制器，你就可以发现如何控制它。
- en: Start by importing `time` (which will allow you to put pauses in the motor control)
    and `wiringpi2` to allow control of the GPIO pins. Use `wiringpi2` here since
    it makes it much easier to make use of IO expanders and other I²C devices if you
    want to later on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入`time`（这将允许你在电机控制中设置暂停）和`wiringpi2`以允许控制GPIO引脚。在这里使用`wiringpi2`，因为它使得在以后使用IO扩展器和其他I²C设备时更容易利用IO扩展器。
- en: Define values to use for setting the pins `ON`/`OFF`, for the direction `IN`/`OUT`,
    as well as the duration of each motor `STEP`. Also, define which `PINS` are wired
    to the motor controls and our movements `FWD`, `RIGHT`, and `LEFT`. The movement
    is defined in such a way that by switching both motors `ON`, you will move forward
    or, by switching just one motor `ON`, you will turn. By setting these values at
    the start of the file using variables, our code is easier to maintain and understand.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 定义用于设置引脚`ON`/`OFF`、方向`IN`/`OUT`以及每个电机`STEP`持续时间的值。还要定义哪些`PINS`连接到电机控制和我们的移动`FWD`、`RIGHT`和`LEFT`。移动的定义方式是，通过同时打开两个电机，你可以向前移动，或者通过只打开一个电机，你可以转向。通过在文件开头使用变量设置这些值，我们的代码更容易维护和理解。
- en: We define a `motor` class that will allow us to reuse it in other code or easily
    swap it with alternative `motor` classes so we can use other hardware if we want
    to. We set the default pins we are using and our `steptime` value (the `steptime`
    object defines how long we drive the motor(s) for each step). However, both can
    still be specified when initializing the object if desired.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个`motor`类，这将允许我们在其他代码中重用它或轻松地将其与替代`motor`类交换，这样我们就可以在需要时使用其他硬件。我们设置我们使用的默认引脚和我们的`steptime`值（`steptime`对象定义了每次步进时我们驱动电机的时间）。然而，如果需要，这两个值在初始化对象时也可以指定。
- en: Next, we call `GPIOsetup()`; it selects the physical pin numbering mode (so
    we can refer to the pins as they are located on the board). We also set all of
    the pins we are using to output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`GPIOsetup()`；它选择物理引脚编号模式（因此我们可以根据它们在板上的位置来引用引脚）。我们还设置我们使用的所有引脚为输出模式。
- en: 'Finally, for the `motor` class, we define the following three functions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`motor`类，我们定义以下三个函数：
- en: The first function we define (called `off()`) will allow us to switch off the
    motors, so we cycle through the pins list and set each GPIO pin to low (and therefore
    switch the motors off).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义的第一个函数（称为 `off()`）将允许我们关闭电机，因此我们遍历引脚列表，将每个 GPIO 引脚设置为低电平（因此关闭电机）。
- en: The `drive()` function allows us to provide a list of drive actions (a combination
    of `ON` and `OFF` for each of the GPOI pins). Again, we cycle through each of
    the pins and set them to the corresponding drive action, wait for the step time,
    and then switch off the motors using the `off()` function.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drive()` 函数允许我们提供一个驱动操作列表（每个 GPOI 引脚的 `ON` 和 `OFF` 组合）。同样，我们遍历每个引脚，将其设置为相应的驱动操作，等待步进时间，然后使用
    `off()` 函数关闭电机。'
- en: The last function we define (called `cmd()`) simply allows us to send `char`
    (a single character) and use it to select the set of drive actions we want to
    use (`FWD`, `RIGHT`, or `LEFT`, or wait (`#`)).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义的最后一个函数（称为 `cmd()`）简单地允许我们发送 `char`（单个字符）并使用它来选择我们想要使用的驱动操作集合（`FWD`、`RIGHT`、`LEFT`
    或等待 `#`）。
- en: 'For testing, `main()` allows us to specify a list of actions that need to be
    performed from the command line using the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试，`main()` 允许我们通过以下命令从命令行指定需要执行的一系列操作：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using `os.environ` (by importing the `os` module so we can use it), we can check
    for `CMD` in the command and use it as our list of drive actions. If no `CMD`
    command has been provided, we can use the `input()` function to prompt for a list
    of drive actions directly. To use the `motor` class, we set `roverPi=motor()`;
    this allows us to call the `cmd()` function (of the motor class) with each character
    from the list of drive actions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入 `os` 模块以使用 `os.environ`，我们可以检查命令中的 `CMD` 并将其用作我们的驱动操作列表。如果没有提供 `CMD` 命令，我们可以使用
    `input()` 函数直接提示输入驱动操作列表。要使用 `motor` 类，我们设置 `roverPi=motor()`；这允许我们使用驱动操作列表中的每个字符调用电机类的
    `cmd()` 函数。
- en: There's more…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Your robot should only be limited by your own creativity. There are lots of
    suitable chassis you can use, other motors, wheels, and ways to control and drive
    the wheels. You should experiment and test things to determine which combinations
    work best together. That is all part of the fun!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人应该只受限于你自己的创造力。你可以使用很多合适的底盘，其他电机、轮子以及控制驱动轮子的方式。你应该进行实验和测试，以确定哪些组合效果最佳。这些都是乐趣的一部分！
- en: Darlington array circuits
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 达林顿阵列电路
- en: 'Darlington transistors are a low-cost way to drive higher powered devices,
    such as motors or even relays. They consist of two transistors arranged in a series,
    where one feeds the other (allowing the gain in the current to be multiplied).
    That is, if the first transistor has a gain of 20, and the second also has a gain
    of 20, together they will provide an overall gain of 400\. This means that 1 mA
    on the base pin (1) will allow you to drive up to 400 mA through the Darlington
    transistor. The Darlington transistor''s electrical symbol is shown in the following
    diagram:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 达林顿晶体管是驱动更高功率设备（如电机甚至继电器）的低成本方式。它们由两个串联排列的晶体管组成，其中一个晶体管向另一个晶体管供电（允许电流增益相乘）。也就是说，如果第一个晶体管的增益为
    20，第二个晶体管的增益也为 20，那么它们将提供总增益为 400。这意味着基极引脚（1）上的 1 mA 电流可以使你通过达林顿晶体管驱动高达 400 mA
    的电流。达林顿晶体管的电气符号在以下图示中显示：
- en: '![Darlington array circuits](img/6623OT_09_011.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![达林顿阵列电路](img/6623OT_09_011.jpg)'
- en: The electrical symbol for a Darlington transistor shows how two transistors
    are packaged together
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 达林顿晶体管的电气符号显示了两个晶体管是如何封装在一起的
- en: 'The ULN2003 chip is used in the previous module and provides 7 NPN Darlington
    transistors (an 8-way version ULN2803 is also available if more output is required
    or to use with two stepper motors). The following diagram shows how a Darlington
    array can be used to drive motors:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模块中使用了 ULN2003 芯片，它提供了 7 个 NPN 达林顿晶体管（如果需要更多输出或与两个步进电机一起使用，还有 8 通道版本的 ULN2803）。以下图示显示了如何使用达林顿阵列来驱动电机：
- en: '![Darlington array circuits](img/6623OT_09_012.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![达林顿阵列电路](img/6623OT_09_012.jpg)'
- en: A Darlington array being used to drive two small motors
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用达林顿阵列驱动两个小型电机
- en: Each output from the chip can supply a maximum of 500 mA at up to 50V (enough
    to power most small motors). However, with extended use, the chip may overheat,
    so a heat sink is recommended when driving larger motors. An internal diode connected
    across each Darlington for protection is built into the chip. This is needed because
    when the motor moves without being driven (this can occur due to the natural momentum
    of the motor), it will act like a generator. A reverse voltage called **back EMF**
    is created, which would destroy the transistor if it wasn't dissipated back through
    the diode.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片每个输出端最多可提供500 mA的电流，电压高达50V（足以驱动大多数小型电机）。然而，随着使用时间的延长，芯片可能会过热，因此在驱动大型电机时建议使用散热片。芯片内部已集成在每个达林顿晶体管上跨接的保护二极管。这是必要的，因为当电机在没有驱动的情况下移动时（这可能是由于电机的自然惯性引起的），它将像发电机一样工作。会产生一个称为**反电动势**的反向电压，如果不通过二极管耗散，将会损坏晶体管。
- en: One disadvantage of the chip is that the positive supply voltage must always
    be connected to the common pin (COM), so each output is only able to sink current.
    That is, it will only drive the motor in one direction, with the positive voltage
    on COM and the negative voltage on the OUT pins. Therefore, we will need a different
    solution if we wish to drive our Rover-Pi robot in different directions (see the
    next example in the *Using advanced motor control* recipe).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片的一个缺点是，正电源电压必须始终连接到公共端（COM），因此每个输出端只能吸收电流。也就是说，它只能驱动电机单向转动，COM端为正电压，OUT端为负电压。因此，如果我们希望驱动Rover-Pi机器人以不同方向行驶，我们需要一个不同的解决方案（参见下一例“使用高级电机控制”配方）。
- en: These chips can also be used to drive certain types of stepper motors. One of
    the modules from [dx.com](http://dx.com) includes a stepper motor as a part of
    the kit. Although the gearing is for very slow movement at around 12 seconds per
    rotation (too slow for a rover), it is still interesting to use (for a clock perhaps).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些芯片也可以用来驱动某些类型的步进电机。dx.com网站上的一个模块将步进电机作为套件的一部分。尽管齿轮是为了非常缓慢的运动设计的，大约每转12秒（对于漫游车来说太慢了），但仍然很有趣（比如用于时钟）。
- en: Transistor and relay circuits
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 晶体管和继电器电路
- en: Relays are able to handle much more highly powered motors since they are mechanical
    switches controlled by an electromagnetic coil that physically moves the contacts
    together. However, they require a reasonable amount of current to be turned on
    and usually more than 3.3V. To switch even small relays, we need around 60 mA
    at 5V (more than is available from the GPIO), so we will still need to use some
    additional components to switch it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于继电器是由电磁线圈控制的机械开关，可以处理更多高功率的电机，因此它们能够处理更多高功率的电机。然而，它们需要相当大的电流来开启，通常超过3.3V。为了切换小型继电器，我们需要大约60
    mA的5V电流（比GPIO提供的要多），因此我们仍然需要使用一些额外的组件来切换它。
- en: 'We can use the Darlington array (as used previously) or a small transistor
    (any small transistor, such as the 2N2222, will be fine) to provide the current
    and voltage required to switch it. The following circuit will allow us to do this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用达林顿阵列（如之前所述）或一个小型晶体管（任何小型晶体管，如2N2222，都行）来提供切换所需的电流和电压。以下电路将允许我们做到这一点：
- en: '![Transistor and relay circuits](img/6623OT_09_013.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![晶体管和继电器电路](img/6623OT_09_013.jpg)'
- en: The transistor and relay circuit used to drive external circuits
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用于驱动外部电路的晶体管和继电器电路
- en: Much like a motor, a relay can also generate EMF spikes, so a protection diode
    is also needed to avoid any reverse voltage on the transistor.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像电机一样，继电器也可以产生电磁脉冲，因此也需要一个保护二极管来避免晶体管上出现任何反向电压。
- en: This is a very useful circuit, not just for driving motors but for any external
    circuit as well; the physical switch allows it to be independent and electrically
    isolated from the Raspberry Pi controlling it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的电路，不仅适用于驱动电机，也适用于任何外部电路；物理开关允许它与控制它的Raspberry Pi独立且电气隔离。
- en: As long as the relay is rated correctly, you can drive DC or AC devices through
    it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 只要继电器正确标定，你就可以通过它驱动直流或交流设备。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can use some relays to control items powered by the mains. However, this
    should be done only with extreme caution and proper electrical training. Electricity
    from the mains can kill or cause serious harm.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一些继电器来控制由市电供电的设备。但是，这应该仅以极端谨慎和适当的电气培训进行。市电的电力可以致命或造成严重伤害。
- en: PiBorg has a ready-made module named the **PicoBorg** that will allow the switching
    of up to four relays. It uses devices called **MOSFETs** that are essentially
    high-power versions of transistors that function with the same principle as discussed
    previously.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: PiBorg有一个现成的模块，名为**PicoBorg**，它允许切换多达四个继电器。它使用称为**MOSFETs**的设备，它们实际上是具有相同原理的高功率晶体管版本。
- en: Tethered or untethered robots
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接或非连接机器人
- en: An important choice when designing your own Rover-Pi robot is to decide if you
    want to make it fully self-contained or if you are happy to have a tether (a long
    control/power cable connected to the Rover-Pi). Using a tether, you can keep the
    weight of the Rover-Pi robot down, which means the small motors will be able to
    move the unit with ease. This will allow you to keep the Raspberry Pi separate
    from the main unit so it can remain connected to a screen and keyboard for easy
    programming and debugging. The main disadvantage is that you will need a long,
    umbilical-like connection to your Rover-Pi robot (with a wire for each control
    signal) that may impede its movement. However, as we will see later, you may only
    need three or four wires to provide all the control you need (see the *Using I/O
    expanders* section in the next recipe).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计自己的Rover-Pi机器人时，一个重要的选择是决定你是否想使其完全自包含，或者你是否愿意有一个连接线（一个连接到Rover-Pi的长控制/电源电缆）。使用连接线，你可以降低Rover-Pi机器人的重量，这意味着小型电机可以轻松地移动单元。这将允许你将Raspberry
    Pi与主单元分开，以便它可以连接到屏幕和键盘，便于编程和调试。主要的缺点是，你将需要一个长长的脐带状连接到你的Rover-Pi机器人（每个控制信号都有一个电线），这可能会阻碍其移动。然而，正如我们稍后将要看到的，你可能只需要三根或四根电线就能提供所有需要的控制（参见下一道菜谱中的*使用I/O扩展器*部分）。
- en: If you intend to mount the Raspberry Pi directly on the Rover-Pi robot, you
    will need a suitable power supply, such as a phone charger battery pack. If the
    battery pack has two USB ports, then you may be able to use it as a power source
    to drive both the Raspberry Pi and the motors. The unit must be able to maintain
    the supplies independently as any power spike caused by driving the motors could
    reset the Raspberry Pi.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算直接将Raspberry Pi安装在Rover-Pi机器人上，你需要一个合适的电源，例如手机充电电池组。如果电池组有两个USB端口，那么你可能能够将其用作电源来驱动Raspberry
    Pi和电机。该单元必须能够独立维持供应，因为任何由驱动电机引起的电源尖峰都可能导致Raspberry Pi重置。
- en: Remember that if the Raspberry Pi is now attached to the robot, you will need
    a means to control it. This can be a USB Wi-Fi dongle that will allow a remote
    connection via SSH and so on, or a wireless keyboard (that uses RF/Bluetooth),
    or even the GPIO D-Pad from [Chapter 6](ch06.html "Chapter 6. Using Python to
    Drive Hardware"), *Using Python to Drive Hardware*, can be used for direct control.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果现在Raspberry Pi已经连接到机器人上，你需要一种控制它的方法。这可以是一个USB Wi-Fi适配器，它允许通过SSH进行远程连接，或者一个无线键盘（使用RF/蓝牙），甚至[第6章](ch06.html
    "第6章。使用Python驱动硬件")中的GPIO D-Pad，*使用Python驱动硬件*，可以用于直接控制。
- en: 'However, the more you mount on the chassis, the harder the motors will need
    to work to move. You may find that stronger motors are required, rather than the
    little ones used here. A Rover-Pi robot powered by a USB battery pack is shown
    in the following image:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你安装到底盘上的东西越多，电机就越需要努力工作来移动。你可能会发现需要更强的电机，而不是这里使用的小电机。以下图像显示了由USB电池组供电的Rover-Pi机器人：
- en: '![Tethered or untethered robots](img/6623OT_09_014.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![连接或非连接机器人](img/6623OT_09_014.jpg)'
- en: A battery-powered Raspberry Rover-Pi robot being controlled via Wi-Fi (cable
    management is optional)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由电池供电的Raspberry Rover-Pi机器人，通过Wi-Fi控制（可选的电缆管理）
- en: Rover kits
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探路者套件
- en: 'If you don''t fancy making your own chassis, there are also a number of pre-made
    rover chassis available that can be used. They are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想自己制作底盘，也有许多现成的探路者底盘可供使用。它们如下：
- en: 2WD Magician Robot Chassis from SparkFun
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自SparkFun的2WD魔术师机器人底盘
- en: 4 Motor Smart Car Chassis from DX.com
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自DX.com的4电机智能小车底盘
- en: 2 Wheel Smart Car Model DX.com![Rover kits](img/6623OT_09_015.jpg)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2轮智能小车模型DX.com![探路者套件](img/6623OT_09_015.jpg)
- en: The Tiddlybot show how multiple components can be integrated together within
    a single platform, as shown in my modified version
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Tiddlybot展示了多个组件如何在单个平台上集成在一起，如我在修改版本中所示
- en: A particularly nice robot setup is the Tiddlybot (from [PiBot.org](http://PiBot.org)),
    which combines multiple sensors, continuous servos, an onboard battery pack, and
    the Raspberry Pi camera. The SD card is set up so the TiddlyBot acts as a Wi-Fi
    hotspot hosting a simple drag and drop programming platform with a remote control
    interface. This shows how simple components such as the ones described in this
    chapter can be combined into a complete system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别好的机器人设置是Tiddlybot（来自[PiBot.org](http://PiBot.org)），它结合了多个传感器、连续伺服、机载电池组和Raspberry
    Pi摄像头。SD卡已设置，使TiddlyBot充当Wi-Fi热点，提供简单的拖放编程平台和遥控接口。这展示了如何将本章中描述的简单组件组合成一个完整的系统。
- en: '![Rover kits](img/6623OT_09_016.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Rover套件](img/6623OT_09_016.jpg)'
- en: The Tiddlybot GUI provides a cross-platform drag and drop interface as well
    as Python support
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Tiddlybot图形用户界面提供了一个跨平台的拖放界面以及Python支持
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to check out the [Appendix](apa.html "Appendix A. Hardware and Software
    List"), *Hardware and Software List*; it lists all the items used in this chapter
    and the places you can obtain them from.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看[附录](apa.html "附录A. 硬件和软件列表")，*硬件和软件列表*；它列出了本章中使用的所有物品及其获取地点。
- en: Using advanced motor control
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级电机控制
- en: 'The previous driving circuits are not suitable for driving motors in more than
    one direction (as they only switch the motor on or off). However, using a circuit
    named an H-bridge, you can switch and control the motor''s direction too. The
    switch combinations are shown in the following diagram:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的驱动电路不适用于驱动多方向运行的电机（因为它们只能切换电机的开或关）。然而，使用名为H桥的电路，你还可以切换和控制电机的方向。开关组合如下所示：
- en: '![Using advanced motor control](img/6623OT_09_017.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![使用高级电机控制](img/6623OT_09_017.jpg)'
- en: The direction of the motor can be controlled by different switch combinations
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 电机方向可以通过不同的开关组合来控制
- en: Using a different combination of switching, we can change the direction of the
    motor by switching the positive and negative supply to the motor (**SW1** and
    **SW4** activate the motor, and **SW2** and **SW3** reverse the motor). However,
    not only do we need four switching devices for each motor, but since the ULN2X03
    devices and PiBorg's PicoBorg module can only sink current, equivalent devices
    would be required to source current (to make up the top section of switches).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的开关组合，我们可以通过切换电机的正负电源来改变电机的方向（**SW1**和**SW4**激活电机，**SW2**和**SW3**反转电机）。然而，我们不仅需要每个电机四个开关设备，而且由于ULN2X03设备以及PiBorg的PicoBorg模块只能吸收电流，因此还需要等效的设备来提供电流（以构成开关的上部部分）。
- en: Fortunately, there are purpose-built H-bridge chips, such as L298N, that contain
    the previous circuit inside them to provide a powerful and convenient solution
    to control motors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有专门设计的H桥芯片，如L298N，它们内部包含先前的电路，以提供强大且方便的电机控制解决方案。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We shall replace the previous Darlington array module with the H-bridge motor
    controller shown in the following image:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用以下图像中所示的H桥电机控制器替换先前的达林顿阵列模块：
- en: '![Getting ready](img/6623OT_09_018.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_09_018.jpg)'
- en: The H-bridge motor controller allows directional control of motors
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: H桥电机控制器允许控制电机的方向
- en: There is some detailed information about this unit available at [http://www.geekonfire.com/wiki/index.php?title=Dual_H-Bridge_Motor_Driver](http://www.geekonfire.com/wiki/index.php?title=Dual_H-Bridge_Motor_Driver).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个单元的详细信息可在[http://www.geekonfire.com/wiki/index.php?title=Dual_H-Bridge_Motor_Driver](http://www.geekonfire.com/wiki/index.php?title=Dual_H-Bridge_Motor_Driver)找到。
- en: The datasheet of L298N is available at [http://www.st.com/resource/en/datasheet/l298.pdf](http://www.st.com/resource/en/datasheet/l298.pdf).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: L298N的数据表可在[http://www.st.com/resource/en/datasheet/l298.pdf](http://www.st.com/resource/en/datasheet/l298.pdf)找到。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The unit will need to be wired as follows (this will be similar for other H-bridge
    type controllers, but check with the relevant datasheet if unsure).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 单元需要按照以下方式布线（这与其他H桥类型控制器类似，但如果有疑问，请查阅相关数据表）。
- en: 'The following table shows how the motors and motor power supply connect to
    the H-bridge controller module:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了电机和电机电源如何连接到H桥控制器模块：
- en: '| The motor side of the module – connecting to the battery and motors |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 模块的电机侧 – 连接到电池和电机 |'
- en: '| --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Motor A | VMS | GND | 5V OUT | Motor B |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 电机A | VMS | GND | 5V OUT | 电机B |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Left motor Red wire | Left motor Black wire | Battery positive | Battery
    GND | None | Right motor Red wire | Right motor Black wire |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: 'The following table shows how the H-bridge controller module connects to the
    Raspberry Pi:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '| Control side of the module – connecting to the Raspberry Pi GPIO header |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| ENA | IN1 | IN2 | IN3 | IN4 | ENB | GND | 5V |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| None | Pin 15 | Pin 16 | Pin 18 | Pin 22 | None | Pin 6 | None |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: It is recommended that you keep the pull-up resistor jumpers on (UR1-UR4) and
    allow the motor supply to power the onboard voltage regulator, which in turn will
    power the L298N controller (jumper 5V_EN). The on-board regulator (the 78M05 device)
    can supply up to 500 mA, enough for the L298N controller plus any additional circuits,
    such as an IO expander (see the *There's more…* section for more information).
    Both the ENA and ENB pins should be disconnected (the motor output will stay enabled
    by default).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: You will need to make the following changes to the previous `rover_drivefwd.py`
    script (you can save it as `rover_drive.py`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file, redefine `PINS` as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And update the control patterns as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to add the backwards command to `cmd()` as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can update the prompt that we have within the `main()` function
    to include `b` (backwards) as an option, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The H-bridge motor controller recreates the previous switching circuit with
    additional circuitry to ensure that the electronic switches cannot create a short
    circuit (by not allowing **SW1** and **SW3** or **SW2** and **SW4** to be enabled
    at the same time). The H-bridge motor controller''s switching circuit is as shown
    in the following diagram:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_09_019.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: An approximation of the H-bridge switching circuit (in Motor off state)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The input (**IN1** and **IN2**) will produce the following action on the motors:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '| IN1IN2 | 0 | 1 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| 0 | Motor off | Motor backwards |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| 1 | Motor forwards | Motor off |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: As we did in the previous recipe, we can move forward by driving both motors
    forward; however, now we can drive them both backwards (to move backwards) as
    well as in opposite directions (allowing us to turn the Rover-Pi robot on the
    spot).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can achieve finer control of the motors using a **pulse width modulated**
    (**PWM**) signal and expand the available input/output using an IO expander.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Motor speed control using PWM control
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, the Rover-Pi robot motors are controlled by being switched on and
    off; however, if the robot is moving too fast (for example, if you have fitted
    bigger motors or used higher gearing), we could make use of the **ENA** and **ENB**
    input on the controller. If these are set low, the motor output is disabled, and
    if set high, it is enabled again. Therefore, by driving them with a PWM signal,
    we can control the speed of the motors. We could even set slightly different PWM
    rates (if required) to compensate for any differences in the motors/wheels or
    surface to drive them at slightly different speeds, as shown in the following
    diagram:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Motor speed control using PWM control](img/6623OT_09_020.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: A PWM signal controls the ratio of the ON and OFF times
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: A PWM signal is a digital on/off signal that has different amounts of **ON**
    time compared to **OFF** time. A motor driven with a 50:50, `ON:OFF` signal would
    drive a motor with half the power of an ON signal at 100 percent and would therefore
    run more slowly. Using different ratios, we can drive the motors at different
    speeds.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: We can use the hardware PWM of the Raspberry Pi (GPIO Pin 12 can use the PWM
    driver).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PWM driver normally provides one of the audio channels of the analog audio
    output. Sometimes, this generates interference; therefore, it is suggested that
    you disconnect any devices connected to the analog audio socket.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'The hardware PWM function is enabled in `wiringpi2` by setting the pin mode
    to `2` (which is the value of `PWM`) and specifying the on time (represented as
    `ON_TIME`) as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, this is only suitable for joint PWM motor control (as it is connected
    to both ENA and ENB) since there is only the one available hardware PWM output.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative is to use the software PWM function of `wiringpi2`. This
    creates a crude PWM signal using software; depending on your requirements, this
    may acceptable. The code for generating a software PWM signal on GPIO Pin 7 and
    GPIO Pin 11 is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous code sets both pins to 100 Hz, with GPIO Pin 7 set to an on time
    of 2 ms (and an off time of 8 ms) and GPIO Pin 11 set to 7.5 ms/2.5 ms.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: To adjust the PWM timings, use `wiringpi2.softPwmWrite(PWM_PIN_ENA,ON_TIME2)`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The accuracy of the PWM signal may be interrupted by other system processes,
    but it can control a small micro servo, even if it's slightly jittery.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Using I/O expanders
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen previously (in [Chapter 7](ch07.html "Chapter 7. Sense and Display
    Real-World Data"), *Sense and Display Real-World Data*), `wiringpi2` allows us
    to easily adjust our code to make use of I/O expanders using I²C. In this case,
    it can be useful to add additional circuits, such as sensors and LED status indicators,
    perhaps even displays and control buttons to assist with debugging and controlling
    the Rover-Pi robot as you develop it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: It can be particularly helpful if you intend to use it as a tethered device,
    since you will only require three wires to connect back to the Raspberry Pi (I²C
    Data GPIO Pin 3, I²C Clock GPIO Pin 5, and Ground GPIO Pin 6), with I²C VCC being
    provided by the motor controller 5V output.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'As done earlier, add defines for the I²C address and pin base as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, in `gpiosetup()`, set up the MCP23017 device using the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ensure that any pin references you make are numbered 100-115 (to refer to the
    I/O expander pins A0-7 and B0-7) with `AF_BASE` added (which is the pin offset
    for the I/O expander).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Building a six-legged Pi-Bug robot
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Controlling motors is very useful for creating vehicle-like robots, but creating
    more naturally behaving robot components such as servos can provide excellent
    results. There are many creative designs of insect-like robots, or even biped
    designs (with humanoid-like legs), that use servos to provide natural joint movements.
    The design in this example uses three servos, but these principles and concepts
    can easily be applied to far more complex designs, to control legs/arms that use
    multiple servos. The Pi-Bug robot is shown in the following image:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a six-legged Pi-Bug robot](img/6623OT_09_021.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: The six-legged Pi-Bug robot uses a servo driver to control three servos to scuttle
    around
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**A PWM driver module**: A driver module such as the Adafruit 16-Channel 12-bit
    PWM/Servo Driver will be needed. This uses a PCA9685 device; see the datasheet
    at [http://www.adafruit.com/datasheets/PCA9685.pdf](http://www.adafruit.com/datasheets/PCA9685.pdf)
    for details.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3 x micro servos**: The MG90S 9g Metal Gear Servos provide a reasonable amount
    of torque at a low cost.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A heavy gauge wire**: This will form the legs; three giant paper clips (76
    mm/3 inches) are ideal for this.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A light gauge wire / cable ties**: These will be used to connect the legs
    to the servos and to mount the servos to the main board.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A small section of plywood or fiberboard**: Holes can be drilled into this,
    and the servos can be mounted on it.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need to have wiringPi2 installed to control the PWM module, and it
    will be useful to install the I²C tools for debugging. See [Chapter 7](ch07.html
    "Chapter 7. Sense and Display Real-World Data"), *Sense and Display Real-world
    Data*, for details on how to install WiringPi2 and the I²C tools. The I²C connections
    are as shown in the following diagram:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_09_022.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: I²C connections on the Raspberry Pi GPIO header
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pi-Bug robot uses three servos, one on either side and one in the middle.
    Mount each servo by drilling a hole on either side of the servo body, loop a wire
    or cable ties through it, and pull to hold the servo tightly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Bend the paper clip wire into a suitable shape to form the Pi-Bug robot's legs,
    and add a small kink that will allow you to wire the legs securely to the servo
    arms. It is recommended that you run the program first, with the Pi-Bug robot
    set to the home position `h` before you screw the servo arms in place. This will
    ensure that the legs are located in the middle.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the components on the Pi-Bug robot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6623OT_09_023.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: The layout of components on the Pi-Bug robot
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `servoAdafruit.py` script to control the servos:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the following `bug_drive.py` script to control the Pi-Bug robot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We explain how the previous script functions by exploring how the servos are
    controlled using a PWM. Next, we see how the servo class provides the methods
    to control the PCA9685 device. Finally, we look at how the movements of the three
    servos combine to produce forward and turning motions for the Pi-Bug robot itself.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the servos
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To control the servos used for the Pi-Bug robot, we require a special control
    signal that will determine the angle that the servo is required to move to. We
    will send the servo a PWM signal where the duration of the on time will allow
    us to control the angle of the servo arm (and thereby allow us to control the
    Pi-Bug robot''s legs). The following diagram shows how a PWM signal can be used
    to control the angle of the servo:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the servos](img/6623OT_09_024.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: The angle of the servo is controlled by the duration of the Up Time of the PWM
    signal
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Most servos will have an angular range of approximately 180 degrees and the
    mid-position of 90 degrees. A PWM frequency of 50 Hz will have a period of 20
    ms, and the mid-position of 90 degrees typically corresponds to an **Up Time**
    of 1.5 ms, with a range of +/- 0.5 ms to 0.4 ms for near 0 degrees and near 180
    degrees. Each type of servo will be slightly different, but you should be able
    to adjust the code to suit if required. The following diagram shows how you can
    control the servo angle using different PWM Up Times:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the servos](img/6623OT_09_025.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: The servo angle is controlled by sending a PWM Up-Time between 1 ms and 2 ms
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another type of servo is called a **continuous servo** (not used here). It allows
    you to control the rotation speed instead of the angle, and will rotate at a constant
    speed, depending on the PWM signal that has been applied. Both servo types have
    internal feedback loops that will continuously drive the servo until the required
    angle or speed is reached.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Although it is theoretically possible to generate these signals using software,
    you will find that any tiny interruption by other processes on the system will
    interfere with the signal timing; this, in turn, will produce an erratic response
    from the servo. This is why we use a hardware PWM controller, which only needs
    to be set with a specific up and down time, to then generate the required signal
    automatically for us.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The servo class
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The servo code is based on the PWM driver that Adafruit uses for their module;
    however, it is not Python 3 friendly, so we need to create our own version. We
    will use Wiringpi2's I²C driver to initialize and control the I²C PWM controller.
    We define the registers that we will need to use (see the datasheet for the PCA9685
    device) as well as its default bus address `0x40` (PWMADR) and the PWM frequency
    of 50 Hz (PWMHZ).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our servo class, we initialize the I²C driver in `wiringpi2` and set
    up our `devPWM` device on the bus. Next, we initialize the PWM device itself (using
    `pwmInit()`). We have to calculate the **prescaler** required for the device to
    convert the onboard 25 MHz clock to a 50 Hz signal to generate the PWM frequency
    we need; we will use the following formula:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![The servo class](img/6623OT_09_026.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: The prescale register value sets the PWM frequency using a 12-bit value to scale
    the 25 MHz clock
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The prescale value is loaded into the device, and a device reset is triggered
    to enable it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a function to allow the PWM ON and OFF times to be controlled.
    The `ON` and `OFF` times are 12-bit values (0-4096), so each value is split into
    upper and lower bytes (8 bits each) that need to be loaded into two registers.
    For the `L` (low) registers, we mask off the upper 8 bits using `&0xFF`, and for
    the `H` (high) registers, we shift down by 8 bits to provide the higher 8 bits.
    Each PWM channel will have two registers for the on time and two for the off time,
    so we can multiply the addresses of the first PWM channel registers by 4 and the
    channel number to get the addresses of any of the others.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our `servo` class, we define the minimum and maximum ranges of the
    servos, which we calculate as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The PWM frequency of 50 Hz has a 20 ms period (*T=1/f*)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ON/OFF times range from 0-4,096 (so 0 ms to 20 ms)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can calculate the control values for 0 degrees (1 ms) and 180 degrees
    (2 ms) as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 1 ms (servo min) is equal to 4,096/20 ms, which is 204.8
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 ms (servo max) is equal to 4,096/10 ms, which is 409.6
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We round the values to the nearest whole number.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Learning to walk
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Pi-Bug robot uses a common design that allows three servos to be used to
    create a small, six-legged robot. The servos at the two ends provide forward and
    backward movement, while the servo in the middle provides the control. The following
    image shows the mounted servos:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning to walk](img/6623OT_09_027.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: The servos are mounted upside down on the underside of the board
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The following table assumes that the left and right servos are mounted upside
    down on the underside of the board, with the middle servo fitted vertically. You
    shall have to adjust the code if mounted differently.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the servo movements used to walk forward:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '| Direction | Middle (`servoM`) | Left (`servoL`) | Right (`servoR`) |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| **home** | `MID`/Middle | `MID`/Middle | `MID`/Middle |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| **fwdStep1** | `TR`/Right side up | `ACW`/Legs forward | `ACW`/Legs backward
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| **fwdStep2** | `TL`/Left side up | `CW`/Legs backward | `CW`/Legs forward
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: 'The following diagram shows how the movement makes the Pi-Bug robot step forward:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning to walk](img/6623OT_09_028.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: The Pi-Bug robot moving forward
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem a little confusing at first, when you see the robot moving,
    it should make more sense.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: For the first forward step, we move the middle servo (`servoM`) clockwise so
    that the left side of the Pi-Bug robot is lifted off the ground by the movement
    of the remaining middle leg. We can then move the left servo (`servoL`) to move
    the legs on the left side forward (ready for movement later, they are not touching
    the ground at this point). Now by moving the right servo (`servoR`), we can move
    the legs on the right backwards (allowing the Pi-Bug robot to be pushed forward
    on that side).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The second forward step is the same, except that we use the middle servo (`servoM`)
    to lift the right side off the ground. Again, we move the legs that are off the
    ground forward (ready for next time) and then move the legs on the other side
    backward (allowing that side of the Pi-Bug robot to move forward). By repeating
    the forward steps, the Pi-Bug robot will move forward, or by swapping the sides
    that are being lifted up by the middle servo (`servoM`), it will move backward.
    The result is a rather bug-like scuttle!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the Pi-Bug robot turn, we perform a similar action, except that just
    like the advanced motor control for the Rover-Pi robot, we move one side of the
    robot forward and the other side backward. The following table shows the servo
    movements used to turn right:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '| Direction | Middle (`servoM`) | Left (`servoL`) | Right (`servoR`) |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| **home** | `MID`/Middle | `MID`/Middle | `MID`/Middle |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| **rightStep1** | `TL`/Left side up | `CW`/Legs backward | `ACW`/Legs backward
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| **rightStep2** | `TR`/Right side up | `ACW`/Legs forward | `CW`/Legs forward
    |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: 'The steps to turn the Pi-Bug robot to the right are shown in the following
    diagram:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning to walk](img/6623OT_09_029.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: The Pi-Bug robot making a right turn
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: To turn right, we lift the left side of the Pi-Bug robot off the ground, but
    this time, we move the legs on both sides backward. This allows the right side
    of the Pi-Bug robot to move forward. The second half of the step lifts the right
    side off the ground, and we move the legs forward (which will push the left side
    of the Pi-Bug robot backward). In this manner, the bug will turn as it steps;
    again, just by swapping the sides that are being lifted, we can change the direction
    that the Pi-Bug robot will turn in.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The Pi-Bug code for walking
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code for the Pi-Bug robot has been designed to provide the same interface
    as the Rover-Pi robot so that they can be interchanged easily. You should notice
    that each class consists of the same four functions (`__init__()`, `off()`, `drive()`,
    and `cmd()`). The `__init__()` function defines the set of pins we will control,
    the `steptime` value of the walking action (this time, the gap between movements),
    and the previously defined servo module.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we have an `off()` function that provides a function that can be
    called to set the servos in their middle positions (which is very useful for when
    you need to fit the legs in position, as described previously in the home position).
    The `off()` function uses the `drive()` function to set each servo to the `MID`
    position. The `MID` value is halfway between `servoMin` and `servoMax` (1.5 ms
    to give a position of 90 degrees).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The `drive()` function is just like the previous motor control version; it cycles
    through each of the actions required for each servo as defined in the various
    movement patterns (`FWD`, `BWD`, `LEFT`, and `RIGHT`) we discussed previously.
    However, to reproduce the required pattern of movement, we cycle through each
    servo twice, while inserting a small delay whenever we move the middle servo (`servoM`).
    This allows time for the servo to move and provide the necessary tilt to lift
    the other legs off the ground before allowing them to move.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: We define each of the servo commands as a clockwise (CW) or anticlockwise/counterclockwise
    (ACW) movement of the servo arm. Since the servos are mounted upside down, an
    anticlockwise (clockwise if viewed from above) movement of the left servo (`servoL`)
    will bring the legs forwards, while the same direction of movement on the right
    servo (`servoR`) will move the legs backward (which is **fwdStep1** in the previous
    diagram). In this way, each of the patterns can be defined.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we provide a test function using the following command that allows
    a list of instructions to either be defined from the command line or directly
    entered at the prompt:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This includes the addition of `h` to return to the `home` position, if desired.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Controlling servos directly with Servoblaster
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe demonstrated using a dedicated servo controller to handle
    the control of the servos used by the PiBug. This has the advantage that any disturbances
    in the processing taking place on the Raspberry Pi does not cause interference
    with the delicate servo control (since the controller will continue to send the
    correct signals).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: However, the Raspberry Pi is also capable of direct servo control. To achieve
    this we will make use of Richard Hurst's Servoblaster, which is a multiple servo
    driver.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will control four servos attached to the MeArm, a simple
    laser-cut robot arm; however, you can choose to fit servos to whatever device
    you like.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling servos directly with Servoblaster](img/6623OT_09_030.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: The MeArm is a simple robot arm powered by four miniature servos
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most common servos will have three wires and a three pin connector as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '| Black/Brown | Red | Orange/White/Yellow/Blue |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| Ground | Positive Supply (Typically 5V for small servos) | Signal |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: While it is usually possible to power the servos directly from the Raspberry
    Pi 5V pins on the GPIO header, they can draw a significant amount of current when
    moving. Unless you have a very good power supply, this can cause the Raspberry
    Pi to reset unexpectedly, risking corrupting the SD card. Therefore it is recommended
    that you power them separately, for example, with an additional USB power supply
    and cable connected to the ground and positive supply.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'By default the servos can be wired as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '| **Servo** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | All GND | All Power |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| **Raspberry Pi****GPIO Pin** |   |   |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| 7 | 11 | 12 | 13 | 15 | 16 | 19 | 22 | 6 | No Connect |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| **5V Power Supply** |   | GND | +5V |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: We will assume we are controlling four servos (0, 1, 2 and 3) that will be fitted
    later to the MeArm or similar device.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/Image11157.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: 'To install Servoblaster, start by downloading the source files from the Git
    repository:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Unzip and open the `matplotlib-master` folder, as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will use the user space daemon (which is located in the user directory)
    that is called `servod`. Before we can use it, we should compile it with this
    command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There should be no errors, showing the following text:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For usage information use the following command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can test a servo, first start the **servod** daemon (with a timeout
    of 2,000ms to switch off the servo off after it has moved):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can move the servo''s position to 0% of the servo''s range:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now update the servo to 50%, causing the servo to rotate to 90 degrees (servo
    mid-point):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As recommended by the MeArm build instructions, the servos should be connected
    and calibrated before building the arm, to ensure that each servo is able to move
    the arm in its correct range. This is done by ensuring each servo is powered up
    and commanded to its mid-point position (50%/90 degrees) and the servo-arm fitted
    at the expected orientation:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_09_031.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: Each of the servos should be calibrated in the correct position before you fit
    them on the MeArm
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: You can now set each of the MeArm servos (0, 1, 2 and 3) to their mid-points
    (by commanding each in turn to 50%) before building and fitting them to completed
    arm.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The servos could be used to control a wide range of alternative devices other
    than the MeArm, but your servos will probably need to be calibrated in a similar
    manor.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_09_032.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: The precision control of servos means they can be used for a variety of applications.
    For example, controlling simulated hands
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the following `servo_control.py` script:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the script:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can control the servos fitted to the MeArm (or whatever you are using)
    as prompted:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script starts by importing the `curses` and `os` modules. A standard python
    `input()` command would require the *Enter* key to be pressed after each key press
    before we could act upon it. However, as we will see shortly, the `curses` module
    simply allows us to scan for keyboard presses and respond to them immediately.
    We use the `os` module to call the servoblaster commands, as we would via the
    terminal.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: First, we define our setup, such as the servo mappings, calibration positions,
    min/max ranges, our control keys and the STEP size in degrees for each control
    command. We also define our parameters for our requested angle (in degrees) to
    target PWM signal up-time (in milliseconds) calculation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: For these particular servos an up-time of 1 ms is equal to 0 degrees
    and 2.5 ms is 180 degrees, so we have an offset (`OFFSET`) of 1 ms and a scale
    (`DEG2MS`) of 180 degrees/1.5 ms.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, our required up-time (in milliseconds) can be calculated as *OFFSET
    + (degrees*DEG2MS)*. Finally, we define the SERVOD command line and servo `IDLE`
    timeout to initialize the servoblaster user daemon. Within `initialize ()` we
    use `os.system()` to start the servod daemon as we did before.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: In order to detect keypresses, we call the `main()` function of the script from
    `curses.wrapper()`, allowing term to control the terminal input and output. We
    use `term.nodelay(1)` so when we do check for any keypresses (using `term.getch()`)
    execution will continue normally. We use `term.addstr(text)` to show the user
    the control keys and then update the display via `term.refresh()`. The remaining
    script checks the terminal for keypresses and the result assigned to `c`. If no
    key was pressed, then `term.getch()` returns `-1`, otherwise the ASCII equivalent
    value is returned and we can check for it in each of the dictionaries we defined
    for control keys. We will use `KEY_MORE` and `KEY_LESS` to change the servo positions
    and `KEY_CMD` (`c` or `x`) to allow us to set all the servos to their calibrated
    position or to exit cleanly. Finally, we display any useful debugging information
    (if `DEBUG` is set to `True`) using `term.addstr()` and ensure it is displayed
    at (1,0) in the terminal (one line down from the top).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: For normal control, the position of the servos will be controlled using the
    `updateServo()` function, which adjusts the current position (stored in the POS
    array) by the required change (either `+STEP` or `–STEP`). We ensure the new position
    is within the MAX/MIN limits defined and report if we've hit them. The servo is
    then instructed to move to the required position using `setServo()` specifying
    the needed PWM up-time in micro seconds.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: The last function, `calibrate()`, called when c is pressed, simply sets each
    of the servos to the angle defined in the `CAL` array (using `setServo()`) and
    ensures the current position is kept up to date.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Using an Infra-Red Remote Control with your Raspberry Pi
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often useful to control robots remotely. An easy way to add additional
    input is to make use of an IR (infra-red) receiver and a standard remote control.
    Fortunately, the receiver is well supported.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: We will use a module called LIRC to capture and decode IR signals from a standard
    remote control.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LIRC supports many types of IR detectors, such as Energenie's PiMote IR board;
    however, since we only need to receive IR signals, we can use a simple (TSOP38238)
    IR detector.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting Ready](img/6623OT_09_033.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: The three pins of the TSOP38238 IR Receiver can fit directly onto the Raspberry
    Pi header
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the following packages using `apt-get`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following to `/boot/config.txt`. This will enable the driver and define
    the pin the receiver is fitted on (BCM GPIO24):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Perform a restart of the Raspberry Pi so that the configuration takes effect:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We should now find that the IR device is located at `/dev/lirc0`. We can observe
    the output of the receiver if we point a remote control at it and press some buttons
    after using the following command (use *Ctrl* + *Z* to exit):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: If the `lirc0` resource is reported as busy:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will need to stop the `lirc` service:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Which will give the following response:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you are ready, you can start the service again:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will give the following response:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You will see output similar to the following (if not ensure you have connected
    the receiver connected to the correct pins on the Raspberry Pi GPIO):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that we know our device is working, we can configure it.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The global LIRC configurations are stored in `/etc/lirc`. We are interested
    in the following files:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '| `hardware.conf` | Defines where our IR sensor is installed and overall setting
    for our sensor. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| `lircd.conf` | The remote control configuration file; this contains the recorded
    outputs for your remote control''s keys and maps them to specific key symbols.
    You can often obtain pre-recorded files from [lirc.sourceforge.net/remotes](http://lirc.sourceforge.net/remotes)
    or we can record a custom one as shown next. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| `lircrc` | This file provides mapping of each of the key symbols to specific
    commands or keyboard mappings. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: All the LIRC configurations stored in `/etc/lirc` are available for
    all users; however, if required, different configurations can be defined for each
    user by placing them in specific home folders, for example `/home/pi/.config/`,
    allowing the defaults to be overridden.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three parts steps setting up the sensor, one for each of the LIRC
    configuration files:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'First, ensure `hardware.conf` is set up. For our sensor, we must ensure the
    following is set:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, obtain a `lircd.conf` file, or if you do not have one for your remote,
    we can generate it. The following process will now take you through detecting
    each of the individual keys on the remote. For the purpose of this recipe, we
    only need to map eight keys (to control the four servos from the previous recipe).
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want map additional keys, use the following command to find out the
    full list of valid key symbols:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| `KEY_UP` | `KEY_RIGHT` | `KEY_VOLUMEUP` | `KEY_CHANNELUP` |'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `KEY_DOWN` | `KEY_LEFT` | `KEY_VOLUMEDOWN` | `KEY_CHANNELDOWN` |'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '![How to do it…](img/6623OT_09_034.jpg)'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We can use the volume, channel, and direction buttons on this Goodmans remote
    as our MeArm controller
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we will need to stop the `lirc` service, which, if it was running would
    be using the `/dev/lirc0` device:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, start the capture process using the following commands:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![How to do it…](img/6623OT_09_035.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
- en: Record each button on the remote using the irrecord tool
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have captured the required keys, we ensure the name of the remote
    is set (by default it will be set to name of the `lirc.conf` file when the buttons
    are captured):'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Set the name of the remote in the file, for example, Goodmans:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we can replace the configuration in the `/etc/lirc` folder:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: We can confirm the key symbols which are mapped to the remote using
    the `irw` program as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will report the details of the key pressed and the remote control as defined:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we can map the keys to specific commands; in this case we will map them
    to the keys we used for controlling the MeArm servos. Create a new `/etc/lirc/lircrc`
    file:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Replace with the following content:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To apply the configuration, you may need to restart the service (or if that
    doesn''t work, try restarting the Raspberry Pi):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When we run the `servo_control.py` script in the previous recipe, the remote
    should control the arm directly.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LIRC supports several helper programs, of which `irxevent` is just one:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '| remote | By default, LIRC supports some simple controls, for example:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will provide simple cursor control from a remote (UP, DOWN, LEFT, RIGHT
    and also ENTER) that are perfect for simple menu control. |
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '| [http://www.lirc.org/html/configure.html#lircrc_format](http://www.lirc.org/html/configure.html#lircrc_format)
    |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: '| `irxevent` | Emulates button clicks and key presses within X applications.
    You can specify that the key event occurs in the `CurrentWindow` or in a specific
    window by name, that is, `leafpad`. This only works if you are running from the
    graphical desktop environment (or using X-forwarding). |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| [http://www.lirc.org/html/irxevent.html](http://www.lirc.org/html/irxevent.html)
    |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| irpty | Converts infrared remote commands into key strokes for controlling
    a particular program:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Start it by specifying the `lircrc` configuration and program you want to control:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '| [http://www.lirc.org/html/irpty.html](http://www.lirc.org/html/irpty.html)
    |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
- en: '| irexec | Allows commands to be run directly from the remote control:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '| [http://www.lirc.org/html/irexec.html](http://www.lirc.org/html/irexec.html)
    |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
- en: 'You can test any part of the `lircrc` file by using `ircat` with the required
    `prog`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding command will report the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, if you have suitable IR Transmitter LED attached (including protective
    resistor/switching transistor) you can also use LIRC to send infra-red signals
    from the Raspberry Pi. For this you can use the `irsend` command, for example:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The IR output channel is enabled within the `/boot/config.txt` file (assuming
    connected to GPIO Pin 19):'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Avoiding objects and obstacles
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid obstacles, you can place sensors around the robot's perimeter to activate
    whenever an object is encountered. Depending on how you want your robot to behave,
    one avoidance strategy is to just reverse any action (with an additional turn
    for forward/backward actions) that was last taken that caused one of the sensors
    to be activated.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need some micro switches to be triggered when there is an impact with objects.
    Depending on the type you have, you need to place enough switches to detect any
    object around the outside (if required, you can use an additional length of wire
    to extend the reach of the switch). Shown in the following image are two possible
    sensors that will cause the switch to activate when the spring or the metal arm
    hits an object. You need to determine which contacts of the switch open or close
    the circuit (this will depend on the device).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_09_036.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
- en: Small micro switches can be used as collision sensors
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Connect the switches to the GPIO using a method similar to the one we used
    previously in [Chapter 6](ch06.html "Chapter 6. Using Python to Drive Hardware"),
    *Using Python to Drive Hardware*, for the D-Pad controller. A circuit diagram
    of the switches is as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6623OT_09_037.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
- en: The switches should include current limiting resistors (1K ohm is ideal)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'How you connect to the Raspberry Pi''s GPIO will depend on how your motor/servo
    drive is wired up. For example, a Rover-Pi robot with the H-bridge motor controller
    can be wired up as follows:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '| Control side of the module – connecting to the Raspberry Pi GPIO header |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
- en: '| ENA | IN1 | IN2 | IN3 | IN4 | ENB | GND | 5V |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
- en: '| None | Pin 15 | Pin 16 | Pin 18 | Pin 22 | None | Pin 6 | None |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
- en: 'Four additional proximity/collision sensors can be connected to the Raspberry
    Pi GPIO as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '| Proximity/collision sensors – connecting to the Raspberry Pi GPIO header
    |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
- en: '| R_FWD | L_FWD | R_BWD | L_BWD | GND |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
- en: '| Pin 7 | Pin 11 | Pin 12 | Pin 13 | Pin 6 |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
- en: If you wired it differently, you can adjust the pin numbers within the code
    as required. If you require additional pins, then any of the multipurpose pins,
    such as RS232 RX/TX (pins 8 and 10) or the SPI/I²C, can be used as normal GPIO
    pins too; just set them as input or output as normal. Normally, we just avoid
    using them as they are often more useful for expansion and other things, so it
    is sometimes useful to keep them available.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: You can even use a single GPIO pin for all your sensors if you are just using
    the following example code, since the action is the same, regardless of which
    sensor is triggered. However, by wiring each one separately, you can adjust your
    strategy based on where the obstacle is around the robot or provide additional
    debug information about which sensor has been triggered.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `avoidance.py` script:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We import `rover_drive` to control the robot (if we are using a Pi-Bug robot,
    `bug_drive` can be used) and `wiringpi2` so that we can use the GPIO to read the
    sensors (defined as `PINS`). We define `opCmds`, which uses a Python dictionary
    to allocate new commands in response to the original command (using `opCmds[char]`,
    where `char` is the original command).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `sensor` and set up each of the switches as GPIO
    input (each with an internal pull-ups set). Now, whenever we make a movement (as
    earlier, from the list of requested commands in the `main()` function), we check
    to see if any of the switches have been triggered (by calling `mySensor.checkSensor()`).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: If a switch was tripped, we stop the current movement and then move in the opposite
    direction. However, if we are moving forward when one of the sensors is triggered,
    we move backward and then turn. This allows the robot to gradually turn away from
    the object that is blocking its path and continue its movement in another direction.
    Similarly, if we are moving backwards and a sensor is triggered, we move forward
    and then turn. By combining simple object avoidance with directional information,
    the robot can be commanded to navigate around as desired.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also ways to detect objects that are near the robot without actually
    making physical contact with it. One such way is to use ultrasonic sensors, commonly
    used for vehicle reversing/parking sensors.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Ultrasonic reversing sensors
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ultrasonic sensors provide an excellent way to measure the distance of the
    robot from obstacles (providing a measurement of between 2 cm and 20 cm) and are
    available at most electrical hobby stores (see the [Appendix](apa.html "Appendix A. Hardware
    and Software List"), *Hardware and Software List*). The ultrasonic module functions
    by sending a short burst of ultrasonic pulses and then measures the time it takes
    for the receiver to detect the echo. The module then produces a pulse on the echo
    output that is equal to the time measured. This time is equal to the distance
    travelled divided by the speed of sound (340.29 m/sec or 34,029 cm/s), which is
    the distance from the sensor to the object and back again. An ultrasonic module
    is shown in the following image:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '![Ultrasonic reversing sensors](img/6623OT_09_38.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
- en: The HC-SR04 ultrasonic sensor module
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: The sensor requires 5V to power it; it has an input that will receive the trigger
    pulse and an output that the echo pulse will be sent on. While the module works
    with a 3.3V trigger pulse, it responds with a 5V signal on the echo line; so,
    it requires some extra resistors to protect the Raspberry Pi's GPIO.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'The following circuit diagram shows the connection of the sensor output:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '![Ultrasonic reversing sensors](img/6623OT_09_39.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
- en: The sensor echo output must be connected to the Raspberry Pi via a potential
    divider
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'The resistors **Rt** and **Rb** create a potential divider; the aim is to drop
    the echo voltage from 5V to around 3V (but not less than 2.5V). Use the following
    equation from [Chapter 7](ch07.html "Chapter 7. Sense and Display Real-World Data"),
    *Sense and Display Real-world Data*, to obtain the output voltage:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '![Ultrasonic reversing sensors](img/6623OT_09_40.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
- en: The output voltage (Vout) of the potential divider is calculated using this
    equation
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: This means that we should aim for an **Rt** to **Rb** ratio of 2:3 to give 3V
    (and not lower than 1:1, which would give 2.5V); that is, **Rt** equals 2K ohm
    and **Rb** equals 3K ohm, or 330 ohm and 470 ohm will be fine.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: If you have a voltage meter, you can check it (with everything else disconnected).
    Connect the top of the potential divider to GPIO Pin 2 (5V), the bottom to GPIO
    Pin 6 (GND), and measure the voltage from the middle (it should be around 3V).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `sonic.py` script:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: First, we define the pins `TRIGGER` and `ECHO`, the length of the trigger pulse,
    and also the speed of sound (340.29 m/s). The `TRIGGER` pin is set as an output
    and the `ECHO` as an input (we will not need a pull-up or pull-down resistor since
    the module already has one).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: The `pulse()` function will send a short trigger pulse (10 microseconds); then
    it will time the duration of the echo pulse. We then calculate the total distance
    travelled by dividing the duration by the speed of sound (the distance to the
    object is just half of this value).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the sensor can get confused with certain types of objects; it
    will either detect echoes that bounce off a nearby object before being reflected
    back or not pick up narrow items such as chair legs. However, combined with localized
    collision sensors, the ultrasonic sensor can aid with the general navigation and
    avoidance of the larger objects.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: An improvement to this setup would be to mount the sonic sensor on top of a
    servo, thereby allowing you to make a sensor sweep of the robot's surroundings.
    By making multiple sweeps, taking distance measurements, and tracking the angle
    of the servo, you could build an internal map of the robot's surroundings.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Getting a sense of direction
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to navigate your robot around the environment, you will need to keep
    track of which way your robot is facing. You can estimate the angle that your
    robot turns at by measuring the angle that it turned at in a fixed time period.
    For wheeled robots, you can also measure the rotation of each wheel using a rotary
    encoder (a device that provides a count of the wheel's rotations). However, as
    you make the robot take multiple turns, the direction the robot is facing becomes
    more and more uncertain as differences in the surfaces and the grip of the wheels
    or legs cause differences in the angles that the robot is turning at.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can use an electronic version of a compass; it allows us to
    determine the direction that the robot is facing by providing an angle from magnetic
    North. If we know which direction the robot is facing, we can receive commands
    requesting a particular angle and ensure that the robot moves towards it. This
    allows the robot to perform controlled movements and navigate as required.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: When given a target angle, we can determine which direction we need to turn
    towards, until we reach it.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need a magnetometer device such as the PiBorg''s **XLoBorg** module (which
    is a combined I²C magnetometer and accelerometer). In this example, we focus on
    the magnetometer (the smaller chip on the left) output only. The XLoBorg module
    looks as shown in the following image:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_09_41.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
- en: The PiBorg XLoBorg module contains a 3-axis magnetometer and accelerometer
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: This device can be used with both types of robot, and the angle information
    received from the module can be used to determine which direction the robot needs
    to move in.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'The module is designed to connect directly to the GPIO header, which will block
    all the remaining pins. So in order to use other GPIO devices, a GPIO splitter
    (such as the PiBorg **TriBorg**) can be used. Alternatively, you can use Dupont
    female to male patch wires to connect just the I²C pins. The connections to be
    made are shown in the following diagram:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_09_42.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
- en: Connections to manually wire the XLoBorg module to the Raspberry Pi (using standard
    I²C connections)
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: When viewed from the underside, the PiBorg XLoBorg pins are mirrored compared
    to the Raspberry Pi GPIO header.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a Python 3-friendly version of the XLoBorg library (`XLoBorg3.py`) using
    `wiringpi2` as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works…
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script is based on the XLoBorg library available for the XLoBorg module,
    except that we use WiringPi2, which is Python 3-friendly, to perform the I²C actions.
    Just like our motor/servo drivers, we also define it as a class so that we can
    drop it into our code and easily replace it with alternative devices if required.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: We import `wiringpi2`, `time`, and also a library called `struct` (which allows
    us to quickly unpack a block of data read from the device into separate items).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: We create the `compass` class, which will include the `__init__()`, `initCompass()`,
    and `readCompassRaw()` functions. The `readCompassRaw()` function is the equivalent
    of the standard XLoBorg `ReadCompassRaw()` function provided by their library.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__()` function sets up the I²C bus with `wiringpi2` and registers
    the `degMAG` device on the bus address `0x0E`. The `initCompass()` function sets
    the `CTRL_REG1` and `CTRL_REG2` registers of the device with the settings required
    to quickly get raw readings from the device.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: More details on the MAG3110 registers are available at [http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf](http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: The `readCompassRaw()` function reads the data registers of the device in a
    single block (using the custom function `readBlockData()`). It reads all the 18
    registers of the device (`0x00` through to `0x11`). The sensor readings we need
    are contained within the registers `0x01` to `0x06`, which contain the *x*, *y*,
    and *z* readings split into upper and lower bytes (8-bit values). The `struct.pack()`
    and `struct.unpack()` functions provide an easy way to package them together and
    resplit them as separate words (16-bit values).
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: We can test our script by creating a `myCompass` object from the `compass` class
    and reading the sensor values using `myCompass.readCompassRaw()`. You will see
    the raw x, y, and z values from the device, just as you would from the standard
    XLoBorg library.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: As you will find, these values aren't much use on their own since they are uncalibrated
    and only give you RAW readings from the magnetometer. What we need is a far more
    useful angle relative to magnetic North (see the following *There's more…* section
    for details on how to do this).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, the basic library allows us to see the strength of the magnetic field
    on each of the three axes around the sensor (up/down, left/right, and forward/backward).
    While we can see that these values will change as we move the sensor around, this
    is not enough to steer our robot. First, we need to calibrate the sensor and then
    determine the direction of the robot from the readings of the *x* and *y* axes.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Calibrating the compass
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The compass needs to be calibrated in order to report values that are centered
    and equalized. This is needed because there are magnetic fields all around, so
    by calibrating the sensor, we can cancel out the effect of any localized fields.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: By measuring the readings of the compass on all axes, we can determine the minimum
    and maximum values for each axis. This will allow us to calculate both the midpoint
    of the readings and also the scaling so that each axis will read the same value
    whenever it is facing the same way.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code at the top of the file (after the `import` statements):'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add the following code to `__init__(self)` of the `compass` class:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add a new function named `calibrateCompass()` within the `compass` class as
    follows:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add another new function named `readCompass()` in the `compass` class as follows:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you look closely at the readings (if you use `readCompass()`), you will now
    find that all the readings have the same range and are centered around the same
    values.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the compass bearing
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The XLoBorg library only provides access to the RAW values of the MAG3110 device,
    which provides a measure of how strong the magnetic field is on each of the axes.
    To determine the direction of the sensor, we can use the readings from the *x*
    and *y* axes (assuming we have mounted and calibrated the sensor horizontally).
    The readings of the *x* and *y* axes are proportional to the magnetic field in
    each direction around the sensor, as shown in the following diagram:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating the compass bearing](img/6623OT_09_43.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
- en: The magnetometer measures the strength of the magnetic field on each axis
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 'The angle at which we turned away from the north can be calculated with the
    formula shown in the following diagram:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating the compass bearing](img/6623OT_09_44.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
- en: The angle we are pointing towards that is relative to magnetic North can be
    calculated using the measurements Rx and Ry
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now obtain the `compass` angle by adding the following `readCompassAngle()`
    function to our `compass` class, as follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We also need to add the following import with the other `import` statements:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We use the math function, `math.atan2()`, to calculate our angle (`atan2` will
    return with the angle relative to the *x* axis of the coordinates `read[1]` and
    `read[2]`—the angle we want). The angle is in radians, which means one full turn
    is defined as 2Pi rather than 360 degrees. We convert it back to degrees by multiplying
    it by 360 and dividing by 2Pi. Since we wish to have our angle between the range
    of 0 to 360 degrees (rather than -180 to 180 degrees), we must ensure that it
    is positive by adding the equivalent of a full circle (2Pi) to any negative values.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: With the sensor calibrated and the angle calculated, we should now have proper
    compass bearing to use on our robot. To compare, you can see the result of using
    the uncalibrated value in our calculation by calling the function with `readCompassAngle
    (cal=False)`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Saving the calibration
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having calibrated the sensor once in its current position, it would be inconvenient
    to have to calibrate it each and every time that you run the robot. Therefore,
    you can add the following code to your library to automatically save your calibration
    and read it from a file the next time you run your robot. To create a new calibration,
    either delete or rename `mag.cal` (which is created in the same folder as your
    script) or create your `compass` object with `compass(newCal=True)`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code near the top of the file (after the `imports` statements):'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Change `__init__(self)` to `__init__(self,newCal=False)`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, consider the following line:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Change the previous line to the following line:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Add `readCal()` to the `compass` class as follows:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add `writeCal()` to the `compass` class as follows:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Driving the robot using the compass
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All that remains for us to do now is to use the compass bearing to steer our
    robot to the desired angle.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `compassDrive.py` script:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We import the modules that we previously created: `XLoBorg3`, `rover_drive`
    (for the Rover-Pi robot or the alternative `bug_drive`, as required), and `time`.
    Next, we create a function that will return `LEFT`, `RIGHT`, or `DONE` based on
    the given target angle (requested by the user) and the current angle (read from
    the `compass` class). If the compass angle is within 180 degrees less than the
    target angle, then we turn `LEFT`. Similarly, if it is within 180 degrees, we
    turn `RIGHT`. Finally, if the compass angle is within the margin (+10 degrees/-10
    degrees), then we are `DONE`. By using `angle%360` (which gives us the remainder
    from dividing the angle by 360), we ensure the angles are all 0-360 (that is,
    -90 becomes 270).'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: For the `main()` function, we create `myCompass` (an `XLoBorg.compass` object)
    and `myBot` (a `drive.motor()` object); these allow us to determine the direction
    we are facing in and provide us with a way to drive in the desired direction.
    Within the main loop, we prompt for a target angle, find the current angle that
    our robot is facing at, and then continue to turn towards the required angle until
    we reach it (or reach somewhere near enough).
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
