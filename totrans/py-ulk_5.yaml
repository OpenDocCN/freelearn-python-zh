- en: Chapter 5. Elegance with Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn some design patterns that will help us
    in writing better software, which is reusable and tidy. But, the biggest help
    is that they let developers think on an architectural level. They are solutions
    to recurring problems. While learning them is very helpful for compiled languages
    such as C and C++ because they are actually solutions to problems, in Python,
    developers often "just write code" without needing any design pattern due to the
    dynamism in the language and conciseness of code. This is largely true for developers
    whose first language is Python. My advice is to learn design patterns to be able
    to process information and design at an architectural level rather than function
    and classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adaptor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registry pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 1: Spreading information to all listeners.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the basic pattern in which an object tells other objects about something
    interesting. It is very useful in GUI applications, pub/sub applications, and
    those applications where we need to notify a lot of loosely-coupled application
    components about a change occurring at one source node. In the following code,
    `Subject` is the object to which other objects register themselves for events
    via `register_observer`. The `observer` objects are the listening objects. The
    `observers` start observing the function that registers the `observers` object
    to `Subject` object. Whenever there is an event to `Subject` it cascades the event
    to all `observers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 2: Changing the behavior of an algorithm.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the same piece of code must have different behavior for different
    invocation by different clients. For example, time-conversion for all countries
    must handle daylight-savings time in some countries and change their strategy
    in these cases. The main use is to switch the implementation. In this pattern,
    algorithm''s behavior is selected on runtime. As Python is a dynamic language,
    it is trivial to assign functions to variables and change them on runtime. Similar
    to the following code segment, there are two implementations to calculate tax,
    namely, `tax_simple`, and `tax_actual`. For the following code snippet, `tax_cal`
    references clients that are used. The implementation can be changed by changing
    reference to the implementing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But the issue with the preceding implementation is that at one time all clients
    will see the same strategy for tax calculation. We can improve this using a class
    that selects the implementation based on request parameters. In the following
    example, in the `TaxCalculator` class''s instance, the strategy is determined
    for each call to it on runtime. If the request is for India `IN`, Tax is calculated
    as per the Indian standard, and if request is for `US`, it is calculated as per
    the US standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 3: Providing the same view to all.**'
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern maintains the same state for all instances of a class.
    When we change an attribute at one place in a program, it is reflected in all
    references to this instance. As modules are globally shared, we can use them as
    singleton methods, and the variables defined in them are the same everywhere.
    But, there are similar issues in that as the module is reloaded, there may be
    more singleton classes that are needed. We can also create a singleton pattern
    using metaclasses in the following manner. The `six` is a third-party library
    to help in writing the same code that is runnable on Python 2 and Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, `Singleton` metaclass has a registry dictionary where
    the instance corresponding to each new class is stored. When any class asks for
    a new instance, this class is searched for in the registry, and if found, the
    old instance is passed. Otherwise, a new instance is created, stored in registry,
    and returned. This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Template pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 4: Refining algorithm to use case.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this pattern, we define the skeleton of an algorithm in a method called
    the `template` method, which defers some of its steps to subclasses. How we do
    this is as follows, we analyze the procedure, and break it down to logical steps,
    which are different for different use cases. Now, we may or may not implement
    the default implementation of these steps in the main class. The subclasses of
    the main class will implement the steps that are not implemented in the main class,
    and they may skip some generic steps implementation. In the following example,
    `AlooDish` is base class with the `cook` template method. It applies to normal
    Aloo fried dishes, which have a common cooking procedure. Each recipe is a bit
    different in ingredients, time to cook, and so on. Two variants, `AlooMatar`,
    and `AlooPyaz`, define some set of steps differently than others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adaptor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 5: Bridging class interfaces.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is used to adapt a given class to a new interface. It solves the
    problem for an interface mismatch. To demonstrate this, let''s assume that we
    have an API function that creates a competition to run different animals. Animals
    should have a `running_speed` function, which tells their speed to compare them.
    `Cat` is one such class. Now, if we have a `Fish` class in a different library,
    which also wants to participate in the function, it must be able to know its `running_speed`
    function. As changing the implementation of `Fish` is not good option, we can
    create an `adaptor` class that can adapt the `Fish` class to run by providing
    the necessary bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Facade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 6: Hiding system complexity for a simpler interface.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this pattern, a main class called facade exports a simpler interface to
    client classes and encapsulates the complexity of interaction with many other
    classes of the system. It is like a gateway to a complex set of functionality,
    such as in the following example, the `WalkingDrone` class hides the complexity
    of synchronization of the `Leg` classes and provides a simpler interface to client
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Flyweight pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 7: Consuming less memory with shared objects.**'
  prefs: []
  type: TYPE_NORMAL
- en: A flyweight design pattern is useful to save memory. When we have lots of object
    count, we store references to previous similar objects and provide them instead
    of creating new objects. In the following example, we have a `Link` class used
    by the browser, which stores the link data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser uses this data, and there may be a lot of data that is associated
    with pictures referenced by the link, such as image content, size, and so on,
    and images can be reused over the page. Hence, the nodes using it only store a
    flyweight `BrowserImage` object to decrease the memory footprint. When the link
    class tries to create a new `BrowserImage` instance, the `BrowserImage` class
    checks whether it has an instance in its `_resources` mapping for the resource
    path. If it does, it will just pass the old instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 8: Easy-execution management for commands.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this pattern, we encapsulate information that is needed to execute a command
    in an object so that command itself can have further capabilities, such as undo,
    cancel, and metadata that are needed at a later point of time. For example, let''s
    create a simple `Chef` in a restaurant, users can issue orders (commands), commands
    here have metadata that are needed to cancel them. This is similar to a notepad
    app where each user action is recorded with an undo method. This makes coupling
    loose between caller and the invoker, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Abstract factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This design pattern creates an interface to create a family of interrelated
    objects without specifying their concrete class. It is similar to a superfactory.
    Its advantage is that we can add further variants, and clients will not have to
    worry further about the interface or actual classes for the new variants. It is
    helpful in supporting various platforms, windowing systems, data types, and so
    on. In the following example, the `Animal` class is the interface that the client
    will know about for any animal instance. `AnimalFactory` is the abstract factory
    that `DogFactory` and `CatFactory` implement. Now, on the runtime by user input,
    or configuration file, or runtime environment check, we can decide whether we
    will have all `Dog` or `Cat` instances. It is very convenient to add a new class
    implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Registry pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 9: Adding functionality from anywhere in code to class.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of my favorite patterns and comes to help a lot. In this pattern,
    we register classes to a registry, which tracks the naming to functionality. Hence,
    we can add functionality to the main class from anywhere in the code. In the following
    code, `Convertor` tracks all convertors from dictionary to Python objects. We
    can easily add further functionalities to the system using the `convertor.register`
    decorator from anywhere in the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: State pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 10: Changing execution based on state.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'State machines are very useful for an algorithm whose vector-flow of control
    depends on the state of the application. Similar to when parsing a log output
    with sections, you may want to change the parser logic on every next section.
    It is also very useful to write code for network servers/clients who enable certain
    commands in a certain scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw various design patterns that can help us better organize
    the code, and in some cases, increase performance. The good thing about patterns
    is they let you think beyond classes, and they provide strategy for architecture
    of your application. As closing advice for this chapter, do not code to use design
    pattern; when you code and see a good fit, only then use design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will go onto testing, which is a must for any serious development effort.
  prefs: []
  type: TYPE_NORMAL
