<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Class Definitions</h1></div></div></div><p>A <a class="indexterm" id="id580"/>Python object is an instance of a class. A <a class="indexterm" id="id581"/>
<strong>class</strong> defines the behavior of an object via the method functions. In this chapter, we'll look at creating our own classes and our own objects. We'll start by looking at the basics of creating classes and objects. Once we've seen the essential tools, we can summarize some of the ways that we can class definitions to create objects, and how objects should interact to create the behavior we intend.</p><p>We'll look at some elements of more sophisticated class definition. Advanced topics will include the concepts of class methods and static methods. An entire book can be written on advanced object-oriented programming in Python, so we'll take a broad, but shallow, approach to looking at class definitions.</p><p>We'll also look at the built-in abstract base classes. We can use these to simplify our own class definitions. In many cases, we have container-like classes that can leverage a base class, saving us some programming and assuring a seamless fit with other Python features.</p><div><div><div><div><h1 class="title"><a id="ch11lvl1sec95"/>Creating a class</h1></div></div></div><p>The core of the<a class="indexterm" id="id582"/> object-oriented program is the class definition. The class statement creates an object that is used to create instances of the class. When we create a new class, <code class="literal">SomeClass</code>, we can then use that <code class="literal">SomeClass()</code> function to create objects that share the common definitions of the class. This is the way the built-in classes all work; for example, the <code class="literal">int()</code> function creates an instance of the <code class="literal">int</code> class.</p><p>In Python, a <code class="literal">class</code> statement includes the method functions that describe the behavior of each instance. In addition to ordinary methods, there are several varieties of "special" methods which are intimately bound to the way Python operates.</p><p>We aren't obligated—in any formal way—to provide specific attributes (also called instance variables) for a class. The instance variables of an object are flexible, and are not defined in advance.</p><p>The initial clause of a <code class="literal">class</code> statement provides the class name. It can also name any superclasses, from which features are inherited. The bulk of the class body contains method definitions, created with the indented <code class="literal">def</code> statements.</p><p>In some cases, we <a class="indexterm" id="id583"/>don't need to provide a suite of statements. We often create customized exception classes like this</p><div><pre class="programlisting">class MyAppError(Exception):
    pass</pre></div><p>In this example, we've provided a new class name, <code class="literal">MyAppError</code>, and specified that it inherits the features of the <code class="literal">Exception</code> class. We don't need to make any changes to that base definition; since we must provide an indented suite of statements, we use the pass statement to complete the syntax of the <code class="literal">class</code> statement.</p><p>Since this class works like any other exception, we can use statements like <code class="literal">raise MyAppError("Some Message")</code> to raise an instance of this new class of exceptions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec96"/>Writing the suite of statements in a class</h1></div></div></div><p>The suite of statements<a class="indexterm" id="id584"/> inside a <code class="literal">class</code> statement is generally a collection of method definitions. Each method is a function that's bound to the class. The suite of statements can also include assignment statements; these will create variables that are part of the class definition as a whole.</p><p>Here's a simple class for an (<em>x</em>, <em>y</em>) coordinate pair:</p><div><pre class="programlisting">class Point:
    """
    Point on a plane.
    """
    def __init__(self, x, y):
        self.x= x
        self.y= y
    def __repr__(self):
        return "{cls}({x:.0f}, {y:.0f})".format(
            cls=self.__class__.__name__, x=self.x, y=self.y)</pre></div><p>We've provided a class name, <code class="literal">Point</code>. We haven't explicitly provided a superclass; by default our new class will be a subclass of <code class="literal">object</code>. By convention, the names of most built-in classes, like <code class="literal">object</code>, begin with lowercase letters. All of the other classes that we will define should begin with uppercase letters; hence, our name of <code class="literal">Point</code>. We've also provided a minimal docstring for this class. In <a class="link" href="ch14.html" title="Chapter 14. Fit and Finish – Unit Testing, Packaging, and Documentation">Chapter 14</a>, <em>Fit and Finish – Unit Testing, Packaging, and Documentation</em>, we'll look at expanding this docstring.</p><p>We've defined two methods in the class. The first has a special name of <code class="literal">__init__()</code>. The first parameter to any method defined within a class must include the instance variable. This variable, usually <code class="literal">self</code>, will be the reference to the relevant object. When we assign a value to the variable <code class="literal">self.x</code>, this will set the <code class="literal">x</code> attribute of a specific instance of the <code class="literal">Point</code> class. The instance variable is provided implicitly when the method is called.</p><p>Instead of any <a class="indexterm" id="id585"/>formal definition of the allowed instance variables, Python relies on the <code class="literal">__init__()</code> special method to initialize appropriate instance variables. By default, an object can have additional attributes added at any time.</p><p>The second method has a special name of <code class="literal">__repr__()</code>. To be a proper method, the first parameter must be the instance variable, <code class="literal">self</code>. This method must return a string that represents our coordinate pair. If we don't override this special method, we'll get a default string representation that looks like this: <code class="literal">&lt;__main__.Point object at 0x100623e10&gt;</code>. Our implementation uses <code class="literal">self.__class__.__name__</code> to leverage the class of an object so that any subclass will have the proper class name inserted into the resulting output.</p><p>Special method names are ubiquitous in Python. Using them allows a seamless integration between our classes and built-in Python features. There are a large number of special method names—too many to review in this book. All such names begin and end with <code class="literal">__</code> (two underscores). It's easy to avoid conflicts with this naming convention. There is no good reason to use <code class="literal">__</code> names that are part of our application programming; any name in this form that we choose may turn out to be a hidden feature of Python.</p><p>Note that we did not include placeholder docstrings on the two method functions. We've omitted them to keep the example short, and focused on class definitions. In general, every method of a class will have a docstring to provide a pithy, helpful summary of that method.</p><p>In <a class="link" href="ch04.html" title="Chapter 4. Variables, Assignment and Scoping Rules">Chapter 4</a>, <em>Variables, Assignment and Scoping Rules</em>, we introduced the concept of a namespace as a container for variables. The <code class="literal">self</code> variable is the object, which is a namespace into which we can insert attribute variables.</p><p>We can create an instance of a class like this:</p><div><pre class="programlisting">&gt;&gt;&gt; p_1 = Point(22, 7)
&gt;&gt;&gt; p_1.x
22
&gt;&gt;&gt; p_1.y
7</pre></div><p>We've used the class name, <code class="literal">Point</code>, like a function. An empty object is created first. Then the argument values are provided to the <code class="literal">__init__()</code> special method to initialize that empty object. Note that we did not explicitly provide a value for the instance variable, <code class="literal">self</code>.</p><p>To execute the <code class="literal">__repr__()</code> special method, we can do this:</p><div><pre class="programlisting">&gt;&gt;&gt; p_1
Point(22, 7)</pre></div><p>When an object is <a class="indexterm" id="id586"/>printed, the built-in <code class="literal">repr()</code> function is applied to get a string representation of the object. This built-in function relies on the <code class="literal">__repr__()</code> special method of an object to provide a string representation for the object. The object, <code class="literal">p_1</code>, was implicitly assigned to the instance variable, <code class="literal">self</code>, when evaluating the <code class="literal">__repr__()</code> method.</p><p>Our implementation of the <code class="literal">__repr__()</code> special method produced a string with the <em>x</em> and <em>y</em> coordinate values. We used <code class="literal">.0f</code> as the format specification, providing zero places to the right of the decimal point for the <code class="literal">x</code> and <code class="literal">y</code> attributes of the self instance variable.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec97"/>Using instance variables and methods</h1></div></div></div><p>The<a class="indexterm" id="id587"/> <code class="literal">Point</code> class definition in the previous section included only two special methods. We'll now add a third method that's not special. Here's the third method for this class:</p><div><pre class="programlisting">    def dist(self, point):
        return math.hypot(self.x-point.x, self.y-point.y)</pre></div><p>This <a class="indexterm" id="id588"/>method function accepts a single parameter, named <code class="literal">point</code>. The body of this method function uses <code class="literal">math.hypot()</code> to compute the direct distance between two points on the same plane.</p><p>Here's how we can use this function:</p><div><pre class="programlisting">&gt;&gt;&gt; p_1 = Point(22, 7)
&gt;&gt;&gt; p_2 = Point(20, 5)
&gt;&gt;&gt; round(p_1.dist(p_2),4)
2.8284</pre></div><p>We've created two <code class="literal">Point</code> objects. When the <code class="literal">p_1.dist(p_2)</code> expression is evaluated, the object that was assigned to the <code class="literal">p_1</code> variable will be assigned to the <code class="literal">self</code> variable. This is the instance of <code class="literal">Point</code> that's doing the relevant processing. The argument to the <code class="literal">dist()</code> method, assigned to the <code class="literal">p_2</code> variable, will be assigned to the <code class="literal">point</code> parameter variable.</p><div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>When we evaluate <code class="literal">obj.method()</code>, the <code class="literal">obj</code> object will be the <code class="literal">self</code> instance variable.</p></div></div><p>By default, the objects we create are mutable. Here's another method of the <code class="literal">Point</code> object—this changes the internal state:</p><div><pre class="programlisting">    def offset(self, d_x, d_y):
        self.x += d_x
        self.y += d_y</pre></div><p>This method requires two values which are used to offset the coordinates of the <code class="literal">Point</code> object. The method assigns new<a class="indexterm" id="id589"/> values to the <code class="literal">x</code> and <code class="literal">y</code> attributes of the object.</p><p>Here's<a class="indexterm" id="id590"/> what happens when we use this method:</p><div><pre class="programlisting">&gt;&gt;&gt; p_1.offset(-3, 3)
&gt;&gt;&gt; p_1.x
19
&gt;&gt;&gt; p_1.y
10</pre></div><p>We've evaluated the offset method associated with object <code class="literal">p_1</code>. As noted earlier, the <code class="literal">self</code> instance variable will be the same object referred to by <code class="literal">p_1</code>. When we assign a value to <code class="literal">self.x</code>, that will mutate the object referred to by <code class="literal">p_1</code>, setting <code class="literal">p_1.x</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec98"/>Pythonic object-oriented programming</h1></div></div></div><p>We've seen a <a class="indexterm" id="id591"/>few important features of Python's approach to object-orientation. Perhaps the most important is that Python lacks a static binding between variable name and type; any type of object can be assigned to any variable. Names are not resolved statically by a compiler. Python's dynamic name resolution means that we can think of our programs as being entirely generic with respect to class.</p><p>When we evaluate <code class="literal">obj.attribute</code> or <code class="literal">obj.method()</code>, there are two steps. First the name, <code class="literal">attribute</code> or <code class="literal">method</code>, must be resolved. Second the referenced attribute or method is evaluated.</p><p>For the name resolution step, there are several namespaces that are searched to determine what the name means.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The local namespace of the <code class="literal">obj</code> instance is searched to resolve the name. The object's namespace is available as <code class="literal">obj.__dict__</code>. Attribute names (and values) are generally found in the object's own namespace. Methods, on the other hand, are not generally part of an object instance.</li><li class="listitem" style="list-style-type: disc">If the name isn't local to the object, the local namespace of the object's class is searched. The class namespace is available as <code class="literal">obj.__class__.__dict__</code>. Method names are generally found in the class's namespace. An attribute of the class may also be found here.</li><li class="listitem" style="list-style-type: disc">If the name isn't in the class, the superclasses are searched for the name. The entire lattice of superclasses is assembled into the <code class="literal">obj.__class__.__mro__</code> value. This defines the <a class="indexterm" id="id592"/><strong>Method Resolution Order</strong> (<strong>MRO</strong>); each of the classes in this sequence is searched for the name.</li></ul></div><p>Once the name has been found, Python must determine the value. For names that do not refer to callable methods, that is, attributes—the object referred to by the name is the value of the attribute. A name that refers to a callable method will have argument values bound and it will be evaluated as a function. The result of that function is the value.</p><p>The "search" described <a class="indexterm" id="id593"/>previously relies on the built-in <code class="literal">dict</code> class. This uses hashing to make an extremely fast determination of the presence or absence of a name. There's remarkably little performance cost from the sophisticated and flexible class behavior available in Python.</p><p>If an object of an inappropriate type is provided at run-time, a method name or attribute name won't be found in the object, and an <code class="literal">AttributeError</code> exception is raised. In our preceding example, we can try to evaluate <code class="literal">p_1.copy()</code>. The <code class="literal">copy</code> name is not defined in our class nor any of the superclasses, so an <code class="literal">AttributeError</code> exception is raised.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec90"/>Trying to do type casting</h2></div></div></div><p>While <a class="indexterm" id="id594"/>Python variables are merely names attached to objects, the underlying objects are very strongly typed. There's no way to assign a new value to the <code class="literal">__class__</code> name that defines the class of an object.</p><p>
<strong>Type casts</strong> are <a class="indexterm" id="id595"/>required by some statically-compiled languages to make it possible to create generic data structures. In those languages, we can cast a reference from one type to another type. Because of the dynamic nature of method resolution, there's no need for this kind of type casting in Python.</p><p>All Python collections can contain objects of mixed types. We can easily evaluate this:</p><div><pre class="programlisting">&gt;&gt;&gt; map(lambda x:x+1, [1, 2.3, (4+5j)])</pre></div><p>The lambda expression, <code class="literal">x+1</code>, can be applied to an <code class="literal">int</code>, a <code class="literal">float</code>, or a <code class="literal">complex</code> type without resorting to any kind of type cast operation. This works because each class provides appropriate special method functions to implement the addition of an integer.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec91"/>Designing for encapsulation and privacy</h2></div></div></div><p>A common question <a class="indexterm" id="id596"/>about Python class <a class="indexterm" id="id597"/>definitions is how we can achieve <a class="indexterm" id="id598"/>
<strong>encapsulation</strong> if all attribute and member names are public. Some programmers worry about this:</p><div><pre class="programlisting">&gt;&gt;&gt; p_2 = Point(20, 5)
&gt;&gt;&gt; p_2.y = 6
&gt;&gt;&gt; p_2
(20, 6)</pre></div><p>We've created an object, <code class="literal">p_2</code>. Then we modified an attribute value of the object without using any of the object's method functions. This is not a failure to use the encapsulation design <a class="indexterm" id="id599"/>principle: the class has a properly encapsulated design. The class doesn't have an implementation that can be checked statically by a compiler.</p><p>The Pythonic principle is summarized with the following observation:</p><div><blockquote class="blockquote"><p><em>We're all adults here.</em></p></blockquote></div><p>There's no compelling<a class="indexterm" id="id600"/> reason to create the complexity of private, public, and protected methods and attributes of an object, because Python code is distributed as source and anyone can inspect the source to see what the consequences of bending or breaking encapsulation might be. The preferred approach is to write clear docstrings for classes and methods, and to provide unit tests to demonstrate that attributes and methods are being used properly.</p><p>We can prefix a name with a single <code class="literal">_</code> to indicate that the method or attribute is not part of the public interface to a class. Python documentation tools will politely ignore these names so that these implementation details can be changed freely. Names that begin with <code class="literal">_</code> are considered to be subject to change without notice; depending on these names may lead to a program breaking in unexpected ways.</p><p>In some languages, "getter and setter" methods are required to expose the attributes of a class. In Python, we can use the object's <code class="literal">__dict__</code> directly, simplifying introspection. We can also use the built-in functions <code class="literal">getattr()</code>, <code class="literal">setattr()</code>, and <code class="literal">delattr()</code>to work with attribute names as strings. For example:</p><div><pre class="programlisting">&gt;&gt;&gt; p_2.__dict__.keys()
dict_keys(['y', 'x'])
&gt;&gt;&gt; getattr(p_2, "x")
20</pre></div><p>This shows how we can get an attribute's names and values dynamically. In the first example, we looked at the object's internal namespace, <code class="literal">__dict__</code>, to get the attributes. In the second example, we used the built-in <code class="literal">getattr()</code> function to get the value of an attribute.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec99"/>Using properties</h1></div></div></div><p>Python allows <a class="indexterm" id="id601"/>us to<a class="indexterm" id="id602"/> create methods that can be used as if they were attributes. This gives us very pleasant syntax for getting a derived value from an object. A method that appears to be an attribute is called a <strong>property</strong>. We'll extend our <code class="literal">Point</code> class with two more methods:</p><div><pre class="programlisting">    @property
    def r(self):
        return math.sqrt(self.x**2 + self.y**2)
    @property
    def θ(self):
        return math.atan2(self.y, self.x)</pre></div><p>We've defined<a class="indexterm" id="id603"/> two functions using the <code class="literal">@property</code> decorator. This decorator can be used with a function that has only the instance variable, <code class="literal">self</code>, as a parameter.</p><p>Here's how we can use these properties:</p><div><pre class="programlisting">&gt;&gt;&gt; p = Point(12, 5)
&gt;&gt;&gt; round(p.r, 1)
13.0
&gt;&gt;&gt; round(math.degrees(p.θ), 1)
22.6</pre></div><p>We've accessed these methods as if they were simple attributes of the object, <code class="literal">p</code>. Using <code class="literal">p.r</code> and <code class="literal">p.</code>θ can be more pleasant than having to write <code class="literal">p.r()</code> and <code class="literal">p.</code>θ<code class="literal">()</code> in a complex formula. The preceding properties are explicitly <em>read-only</em>. We get an exception if we try to assign a value to <code class="literal">p.r</code> or <code class="literal">p.</code>θ.</p><p>We'll return to the topic of the <code class="literal">@property</code> decorator in <a class="link" href="ch13.html" title="Chapter 13. Metaprogramming and Decorators">Chapter 13</a>, <em>Metaprogramming and Decorators</em>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec100"/>Using inheritance to simplify class definitions</h1></div></div></div><p>We can use<a class="indexterm" id="id604"/> <strong>inheritance</strong>—reuse of code from a superclass in subclasses—which can simplify a subclass definition. In <a class="indexterm" id="id605"/>an earlier example, we created the <code class="literal">MyAppError</code> class as a subclass of <code class="literal">Exception</code>. This means that all of the features of <code class="literal">Exception</code> will be available to <code class="literal">MyAppError</code>. This works because of the three-step search for a name: if a method name is not found in an object's class, then the superclasses are all searched for the name.</p><p>Here's an example of a subclass which overrides just one method of the parent class:</p><div><pre class="programlisting">class Manhattan_Point(Point):
    def dist(self, point):
        return abs(self.x-point.x)+abs(self.y-point.y)</pre></div><p>We've defined a subclass of <code class="literal">Point</code> named <code class="literal">Manhattan_Point</code>. This class has all of the features of a <code class="literal">Point</code>. It makes a single change to the parent class. It provides a definition for the <code class="literal">dist()</code> method that will override the definition in the <code class="literal">Point</code> superclass.</p><p>Here's an example that shows how method resolution works:</p><div><pre class="programlisting">&gt;&gt;&gt; p_1 = Point(22, 7)
&gt;&gt;&gt; p_2 = Manhattan_Point(20, 5)
&gt;&gt;&gt; round(p_1.dist(p_2),4)
2.8284
&gt;&gt;&gt; round(p_2.dist(p_1),4)
4</pre></div><p>We've <a class="indexterm" id="id606"/>created two objects: <code class="literal">p_1</code> is an instance of <code class="literal">Point</code>, and <code class="literal">p_2</code> is an instance of <code class="literal">Manhattan_Point</code>. We didn't write the <code class="literal">__init__()</code> method of <code class="literal">Manhattan_Point</code>; it was inherited from <code class="literal">Point</code>. When we evaluate <code class="literal">p_1.dist()</code>, we're using the <code class="literal">dist()</code> method that's part of <code class="literal">p_1</code>'s class, <code class="literal">Point</code>. When we evaluate <code class="literal">p_2.dist()</code>, on the other hand, we're using the <code class="literal">dist()</code> method that's part of <code class="literal">p_2</code>, which is the method of <code class="literal">Manhattan_Point</code>.</p><p>Reuse through<a class="indexterm" id="id607"/> inheritance is a way to guarantee that several classes have identical behavior. This is an import object-oriented design principle, sometimes called the <a class="indexterm" id="id608"/>
<strong>Liskov Substitution Principle</strong> (<strong>LSP</strong>). An instance of <code class="literal">Manhattan_Point</code> can be used anywhere an instance of <code class="literal">Point</code> is used.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec92"/>Using multiple inheritance and the mixin design pattern</h2></div></div></div><p>Inheritance<a class="indexterm" id="id609"/> is sometimes visualized as a simple hierarchy of related classes. If each subclass has at most one parent class, there's a chain of relationships between any given subclass and the <code class="literal">object</code> superclass. This single inheritance model isn't always appropriate. In some cases, a class will include a number of disparate features that don't fit the linear ancestry idea.</p><p>The <code class="literal">collections</code> abstract base class module, <code class="literal">collections.abc</code>, contains a number of examples of multiple inheritance. The overall design pattern here is to have a central class hierarchy that defines the <a class="indexterm" id="id610"/>essential features of the <code class="literal">List</code>, <code class="literal">Set</code>, or <code class="literal">Mapping</code> collections. Other features are included via reusable <a class="indexterm" id="id611"/>
<strong>mixin</strong> classes.</p><p>For example, the <code class="literal">Set</code> class is a subclass of <code class="literal">Container</code>. Mixed into this definition are features from the <code class="literal">Sized</code> and <code class="literal">Iterable</code> class definitions. The <code class="literal">Sized</code> mixin incorporates the <code class="literal">__len__()</code> special method. The <code class="literal">Iterable</code> mixin incorporates the <code class="literal">__iter__()</code> special method.</p><p>This leads to the final class being an assembly of reusable superclasses. We can leverage this to create our own classes which contain different mixtures of features.</p><p>Python manages multiple inheritance by relying on the order in which classes are named in the <code class="literal">class</code> statement. This builds the <code class="literal">__mro__</code> value used to search for names in the inheritance lattice. Here's an example:</p><div><pre class="programlisting">&gt;&gt;&gt; from collections.abc import Mapping
&gt;&gt;&gt; Mapping.__mro__
(&lt;class 'collections.abc.Mapping'&gt;, &lt;class 'collections.abc.Sized'&gt;,
&lt;class 'collections.abc.Iterable'&gt;, &lt;class 'collections.abc.Container'&gt;,
&lt;class 'object'&gt;)</pre></div><p>We've imported one <a class="indexterm" id="id612"/>of the abstract base classes. When we look at the MRO, we see that Python will search for a name in <code class="literal">Mapping</code>, <code class="literal">Sized</code>, <code class="literal">Iterable</code>, <code class="literal">Container</code>, and <code class="literal">object</code>, in that order.</p><p>When designing with<a class="indexterm" id="id613"/> mixin classes like this, we generally divide responsibility among the various classes so that we avoid any name collisions between the various superclasses that are used to assemble the final class definition.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec101"/>Using class methods and attributes</h1></div></div></div><p>Generally, we <a class="indexterm" id="id614"/>expect objects to be stateful and classes to be stateless. While typical, a stateless class is not a requirement. We can create class objects which have attributes as well as methods. A class can also have mutable attributes, in the rare cases that this is necessary.</p><p>One use for class variables<a class="indexterm" id="id615"/> is to create parameters that apply to all instances of the class. When a name is not resolved by the object instance, the class is searched next. Here is a small hierarchy of classes that rely on a class-level attribute:</p><div><pre class="programlisting">class Units(float):
    units= None
    def __repr__(self):
        text = super().__repr__()
        return "{0} {1}".format(text, self.units)

class Height(Units):
    units= "inches"</pre></div><p>The <code class="literal">Units</code> class definition extends the <code class="literal">float</code> class. It introduces a class-level attribute named <code class="literal">units</code>. It overrides the <code class="literal">__repr__()</code> special method of <code class="literal">float</code>. This method uses the superclass <code class="literal">__repr__()</code> method to get the essential text representation of a value. It then includes the value of the <code class="literal">units</code> attribute.</p><p>When we evaluate <code class="literal">self.units</code>, there will be a three-step search for this name. An instance of <code class="literal">Height</code> will not provide the <code class="literal">units</code> attribute. The <code class="literal">Height</code> class, however, will provide the <code class="literal">units</code> attribute; the value will be <code class="literal">inches</code>.</p><p>When we create an instance of a <code class="literal">Height</code> object, we'll see the units:</p><div><pre class="programlisting">&gt;&gt;&gt; Height(61.5)
61.5 inches</pre></div><p>When we print an instance of <code class="literal">Height</code>, the <code class="literal">print()</code> function will use the built-in <code class="literal">repr()</code> function to <a class="indexterm" id="id616"/>get a string representation. The <code class="literal">repr()</code> function uses the <code class="literal">__repr__()</code> special method of an object. We've overridden the <code class="literal">__repr__()</code> special method to include the text from the <code class="literal">units</code> attribute.</p><p>Since all attributes <a class="indexterm" id="id617"/>are publicly available, we can write something like <code class="literal">Height.units= "furlongs"</code>, which will cause all further uses of objects of the <code class="literal">Height</code> class to display different units. Changing the class level attributes is generally a bad idea, but it is not prohibited in any formal way.</p><p>Recall the policy: <em>We're all adults here.</em>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec93"/>Using mutable class variables</h2></div></div></div><p>Some applications<a class="indexterm" id="id618"/> may call for a properly mutable variable that's part of an overall class. A class-level attribute name is found during the three-step search for a name: first the object, then the class, then the superclasses. This means that we can successfully evaluate <code class="literal">self.class_level_name</code>, even if the name is not in the object instance, but is defined in the class or one of the parent superclasses.</p><p>If we try to assign a class-level variable, however, using a name like <code class="literal">self.class_level_name</code>, we'll be creating a new attribute in the instance. The class-level name will no longer be visible because the instance name will now be found first.</p><p>If we want to update a class-level variable, we must explicitly use the class name, avoiding the self instance variable. Here's a class which assigns a sequence number to each instance that is created:</p><div><pre class="programlisting">class Sample:
    counter= 0
    def __init__(self, measure):
        Sample.counter += 1
        self.sequence = Sample.counter
        self.measure = measure</pre></div><p>We have created a class-level variable, <code class="literal">counter</code>, which is initialized to zero when the class is created. The <code class="literal">__init__()</code> method will increment the class-level <code class="literal">counter</code> attribute. In order to avoid creating a variable in the instance, the class name, <code class="literal">Sample</code>, is used instead of <code class="literal">self</code>. In addition to updating <code class="literal">Sample.counter</code>, this method also sets two attributes of the instance: the current value of <code class="literal">Sample.counter</code> is assigned to the sequence attribute, and the given value for the measure is also saved.</p><p>It's essential to note that, inside a method function, we can use <code class="literal">self.counter</code> and <code class="literal">Sample.counter</code> to access the same object. This will be true when there's no instance variable named <code class="literal">counter</code>. In order to assign a variable in the class, however, we can only use <code class="literal">Sample.counter</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec94"/>Writing static methods</h2></div></div></div><p>In some<a class="indexterm" id="id619"/> cases, we'll include a method in a class that does not actually depend on any instance variables. In many languages, this kind of method is called <a class="indexterm" id="id620"/>
<strong>static</strong>. Using the word <em>static</em> to refer to class-level features comes from C++ and Java; it has also been adopted for Python.</p><p>We don't have any syntax complications for class-level attributes. As we've seen in previous examples, any attribute that's not part of the instance will be searched for in the class; the distinction between instance variables and class variables doesn't require any additional syntax.</p><p>A class-level method, however, cannot have an instance variable as the first defined parameter. This is an important syntactic change. We use the <code class="literal">@staticmethod</code> decorator to annotate methods that do not have an instance variable.</p><p>We'll expand the <code class="literal">Sample</code> class shown earlier to include a validity check. Checking for validity isn't a proper instance method: we should not create an instance with invalid values. We'll add this method to the class:</p><div><pre class="programlisting">    @staticmethod
    def validate(measure):
        m= float(measure)
        if 0 &lt;= m &lt; 12:
            pass
        else:
            raise ValueError("Out of range")</pre></div><p>We've marked this method with the <code class="literal">@staticmethod</code> decorator. The method does not have a <code class="literal">self</code> variable, since it doesn't apply to an instance of the class. This method can only be invoked via <code class="literal">Sample.validate(some_value)</code>. The method will confirm that the value of the <code class="literal">measure</code> parameter is valid, or it will raise an exception which details the reason why the value is invalid.</p><p>We might use this method to create and use an instance of the <code class="literal">Sample</code> object:</p><div><pre class="programlisting">try:
    Sample.validate(some_data)
    s= Sample(some_data)
    <em>… etc. …</em>
except Exception as ex:
    print(ex)</pre></div><p>We'll start the <code class="literal">try</code> statement by simply evaluating the <code class="literal">Sample.validate()</code> method. If this method does not raise an exception, the given value is valid. If this method does raise an exception, we'll write an error message and continue processing. Often, we'll have this kind of processing in a file input loop: we'll process good data and write messages about bad data to the log.</p><p>Python also offers a <code class="literal">@classmethod</code> decorator. This is a more specialized tool. It provides the class as an <a class="indexterm" id="id621"/>argument instead of the instance. It allows us to write a method that can work with a variety of classes. This might be used in a metaclass.</p><p>We'll return to the topic of decorators in <a class="link" href="ch13.html" title="Chapter 13. Metaprogramming and Decorators">Chapter 13</a>, <em>Metaprogramming and Decorators</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec102"/>Using __slots__ to save storage</h1></div></div></div><p>The default <a class="indexterm" id="id622"/>behavior of the <code class="literal">object</code> superclass is to create a <code class="literal">dict</code> for an object's attributes. This provides fast resolution of names. It means that an object can have attributes added and changed very freely. Because a hash is used to locate the attribute by name, the internal <code class="literal">dict</code> object can consume quite a bit of memory.</p><p>We can modify the behavior of the <code class="literal">object</code> superclass by providing a list of specific attribute names when we create a class. When we assign these names to the specially named <code class="literal">__slots__</code> variable, these will be the only available attributes. A <code class="literal">dict</code> is not created, and memory use is reduced considerably.</p><p>If we're working with very large datasets, we might need to use a class that looks like this:</p><div><pre class="programlisting">class SmallSample:
    counter= 0
    __slots__ = ["sequence", "measure"]
    def __init__(self, measure):
        SmallSample.counter += 1
        self.sequence = SmallSample.counter
        self.measure = measure</pre></div><p>This class uses the <code class="literal">__slots__</code> attribute to define the only two attributes that can be used for an instance. This avoids using a <code class="literal">dict</code> to represent the attributes of instances of this class.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec103"/>The ABCs of abstract base classes</h1></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <em>More Complex Data Types</em>, we <a class="indexterm" id="id623"/>looked at the <code class="literal">collections</code> module, which offers a number of variations on the mapping theme. These different kinds of collections are built on a foundation of abstract base classes, defined in the <code class="literal">collections.abc</code> module. Looking at this module exposes the common features, and the differences, among the collections.</p><p>We can see how <code class="literal">Sequence</code> is the basis for the built-in tuple <code class="literal">class</code>, and <code class="literal">MutableSequence</code> is the basis for the built-in <code class="literal">list</code>. The <code class="literal">Set</code> abstract base class is the basis for the <code class="literal">frozenset</code> built-in class, and <code class="literal">MutableSet</code> is the basis for the <code class="literal">set</code> class. There's no concrete implementation of the <code class="literal">Mapping</code> class, but the <code class="literal">dict</code> class is the built-in implementation of the <code class="literal">MutableMapping</code> class.</p><p>If we need to <a class="indexterm" id="id624"/>implement a unique kind of collection, one not already provided by the <code class="literal">collection</code> module, we're encouraged to use the <code class="literal">collections.abc</code> module as a starting point. If we leverage these common base classes, we're assured that our new collection will fit seamlessly with other Python features.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec95"/>Writing a callable class</h2></div></div></div><p>The <a class="indexterm" id="id625"/>abstract base class <code class="literal">Callable</code> is defined in the <code class="literal">collections.abc</code> module. This class doesn't seem to have much to do with collections. It's a useful abstraction, nonetheless.</p><p>A class that <a class="indexterm" id="id626"/>derives from <code class="literal">Callable</code> must define the <code class="literal">__call__()</code> special method. The objects created from this class are callable, and can be used as if they were functions. This allows us to create fairly complex functions based on a class definition.</p><p>Here's a function to compute the <em>n</em>th Fibonacci number. There are three relevant rules for computing this value:</p><div><img alt="Writing a callable class" src="img/B03671_11_01.jpg"/></div><p>The first two Fibonacci numbers are defined as zero and one. Other Fibonacci numbers are the sum of the two preceding numbers. If we use a naïve algorithm, it's quite expensive to compute a large Fibonacci number. We can, however, define a <code class="literal">Callable</code> that uses an internal cache to reduce the workload to a manageable level. This technique is called <a class="indexterm" id="id627"/>
<strong>memoization</strong>.</p><p>The class definition for a <code class="literal">Callable</code> looks like this:</p><div><pre class="programlisting">from collections.abc import Callable
class Fibonacci(Callable):
    def __init__(self):
        self.cache= {0: 0, 1: 1}
    def __call__(self, n):
        if n not in self.cache:
            self.cache[n]= self.__call__(n-1) + self.__call__(n-2)
        return self.cache[n]</pre></div><p>We've defined a class, <code class="literal">Fibonacci</code>, which extends the <code class="literal">Callable</code> abstract base class. The <code class="literal">__init__()</code> method<a class="indexterm" id="id628"/> initializes a cache with two defined values for Fibonacci numbers. The <a class="indexterm" id="id629"/>
<code class="literal">__call__()</code> method only <a class="indexterm" id="id630"/>computes a Fibonacci number, <code class="literal">n</code>, if the number is not already in the cache. It does this by recursive calls to compute Fibonacci numbers <code class="literal">n-1</code> and <code class="literal">n-2</code>. Once the result is in the cache, it can be returned.</p><p>When we create<a class="indexterm" id="id631"/> an instance of this class, we have created a callable function. Given that function, we can compute Fibonacci numbers. Here's an example:</p><div><pre class="programlisting">&gt;&gt;&gt; fib= Fibonacci()
&gt;&gt;&gt; fib(7)
13</pre></div><p>We've created an instance of the <code class="literal">Fibonacci</code> class, and assigned this to the variable <code class="literal">fib</code>. The <code class="literal">fib</code> object is callable; when we evaluate it with an argument value of six, we get the seventh Fibonacci number.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec104"/>Summary</h1></div></div></div><p>In this chapter, we've seen the basics of defining a class and using objects of that class. We've looked at how we create the methods that define the behavior of a class. The internal state of the class is the result of the various methods: in Python we don't formally declare instance variables. We generally rely in the <code class="literal">__init__()</code> method to provide the initial or default values for the object's state.</p><p>We've looked at the way Python resolves attribute and method names by searching the object, the class, and then the superclasses. The method resolution order is based on the order the classes are presented in the initial <code class="literal">class</code> statement.</p><p>The <code class="literal">@properties</code> decorator can be used to create methods that have the same syntax as an attribute. This can help clarify otherwise complex algorithms. We've also looked at the <code class="literal">@staticmethod</code> decorator, which is used to create methods that belong to the class as a whole and are independent of any specific instance of the class.</p><p>In order to save some memory, we can use the <code class="literal">__slots__</code> variable. This will construct an object that isn't based on a <code class="literal">dict</code> for storing attributes. The object is quite a bit smaller, but also suffers from some limitations.</p><p>We also looked at how we can create a callable object. This is an object that can be used like a function, but has all of the powerful features of an object.</p><p>In <a class="link" href="ch12.html" title="Chapter 12. Scripts, Modules, Packages, Libraries, and Applications">Chapter 12</a>, <em>Scripts, Modules, Packages, Libraries, and Applications</em>, we'll look at how we can package our functions and classes into modules. We'll see how modules are grouped into packages. The <em>Python Standard Library</em> is a collection of packages that we install with Python. We'll look at the tiny distinctions between modules and script files, and how we can create more complete Python applications.</p></div></body></html>