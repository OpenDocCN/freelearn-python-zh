- en: Chapter 5. A Spymaster's More Sensitive Analyses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of our previous espionage missions focused on bulk data collection and
    processing. HQ doesn't always want details. Sometimes it needs summaries and assessments.
    This means calculating central tendencies, summaries, trends, and correlations,
    which means we need to write more sophisticated algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We will skirt the borders of some very heavy-duty statistical algorithms. Once
    we cross the frontier, we will need more powerful tools. For additional tools
    to support sophisticated numeric processing, check [http://www.numpy.org](http://www.numpy.org).
    For some analyses, we may be more successful using the SciPy package ([http://www.scipy.org](http://www.scipy.org)).
    A good book to refer is *Learning SciPy for Numerical and Scientific Computing*,
    *Francisco J. Blanco-Silva*, *Packt Publishing* ([http://www.packtpub.com/learning-scipy-for-numerical-and-scientific-computing/book](http://www.packtpub.com/learning-scipy-for-numerical-and-scientific-computing/book)).
  prefs: []
  type: TYPE_NORMAL
- en: Another direction we could be pulled in includes the analysis of natural language
    documents. Reports, speeches, books, and articles are sometimes as important as
    basic facts and figures. If we want to work with words and language, we need to
    use the **Natural Language Toolkit** (**NLTK**). More information on this can
    be found at [http://www.nltk.org](http://www.nltk.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at several more advanced topics that secret agents
    need to master, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Computing *central tendency*—mean, median, and mode—of the data we've gathered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrogating CSV files to extract information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More tips and techniques to use Python generator functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing higher-level constructs such as Python modules, libraries, and applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick introduction to class definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computations of standard deviation, standardized scores, and the coefficient
    of correlation. This kind of analysis adds value to intelligence assets. Any secret
    agent can ferret out the raw data. It takes real skill to provide useful summaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use doctest to assure that these more sophisticated algorithms really
    work. Presence of a software bug raises serious questions about the overall quality
    of the data being reported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being a secret agent isn't all car chases and confusing cocktail recipes in
    posh restaurants. *Shaken? Stirred? Who can remember?*
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to tackle some rather complex analysis questions that HQ
    has assigned us. How can we work with per capita cheese consumption, accidental
    suffocation and strangulation in bed, and the number of doctorates in civil engineering?
    What Python components should we apply to this problem?
  prefs: []
  type: TYPE_NORMAL
- en: Creating statistical summaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One essential kind of statistical summary is the *measure of central tendency*.
    There are several variations on this theme; mean, mode, and median, which are
    explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The mean, also known as the average, combines all of the values into a single
    value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The median is the middlemost value—the data must be sorted to locate the one
    in the middle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mode is the most common value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these is perfect to describe a set of data. Data that is truly random
    can often be summarized by the mean. Data that isn't random, however, can be better
    summarized by the median. With continuous data, each value might differ slightly
    from another. Every measurement in a small set of samples may be unique, making
    a mode meaningless.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, we'll need algorithms to compute all three of these essential
    summaries. First, we need some data to work with.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Acquiring Intelligence Data"), *Acquiring
    Intelligence Data*, HQ asked us to gather cheese consumption data. We used the
    URL [http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls](http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, the data was in a format that we can''t easily automate, forcing us
    to copy and paste the annual cheese consumption data. This is what we got. Hopefully,
    there aren''t many errors introduced by copying and pasting. The following is
    the data that we gathered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will serve as a handy dataset that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can type this on multiple lines at the `>>>` prompt. Python needs
    to see a matching pair of `[` and `]` to consider the statement complete. The
    matching `[]` rule allows the users to enter long statements comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the raw data file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've been given the cause of death using ICD code W75 as *accidental suffocation
    and strangulation in bed*. It's not perfectly clear what HQ thinks this data means.
    However, it has somehow become important. We went to the [http://wonder.cdc.gov](http://wonder.cdc.gov)
    website to get the summary of cause of death by year.
  prefs: []
  type: TYPE_NORMAL
- en: 'We wound up with a file that starts out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit painful to process. It's almost—but not quite—in CSV notation.
    It's true that there aren't many commas, but there are tab characters encoded
    as `\t` in Python. These characters are sufficient to make a CSV file, where the
    tab takes the role of a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read this file using Python''s `csv` module with a `\t` delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This snippet will create a `csv.DictReader` object using the `\t` delimiter
    instead of the default value of `,`. Once we have a reader that uses `\t` characters,
    we can iterate through the rows in the document. Each row will appear as a dictionary.
    The column title, found in the first row, will be the key for the items in the
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: We used the expression `row['Notes']` to get the value from the `Notes` column
    of each row. If the notes are equal to `---`, this is the beginning of the footnotes
    for the data. What follows is a great deal of metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting dataset can be summarized easily. First, we''ll create a generator
    function to parse our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We replaced the `print()` function with the `yield` statement. We also replaced
    `---` with `Total` to prune the totals off the data. We can compute our own totals.
    Finally, we converted the year and deaths to integer values so that we can calculate
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: This function will iterate through the various rows of data producing two-tuples
    of the year and the number of deaths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have this generator function, we can collect the summary like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This seems to be the data they're looking for. It gives us more data to work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an average value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mean is defined using a daunting formula which looks like ![Finding an average
    value](img/0420OS_05_01.jpg). While the formula looks complex, the various parts
    are first-class built-in functions of Python.
  prefs: []
  type: TYPE_NORMAL
- en: The big sigma ![Finding an average value](img/0420OS_05_03.jpg) is math-speak
    for the Python `sum()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a list of values, the mean is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our two sets of data are provided as two-tuples with year and amount. We need
    to reel in the years, stowing away the time for later use. We can use a simple
    generator function for this. We can use the expression `cheese for year, cheese
    in year_cheese` to separate the cheese portion of each two-tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what happens when we use a generator with our `mean()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Wait. What?
  prefs: []
  type: TYPE_NORMAL
- en: How can the simple generator not work?
  prefs: []
  type: TYPE_NORMAL
- en: Actually, it does work. It just doesn't do what we assume.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding generator expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three important rules that apply to Python generators:'
  prefs: []
  type: TYPE_NORMAL
- en: Many—but not all—functions will work with generator objects. Some functions,
    however, will not work well with generators; they require a sequence object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The objects yielded by a generator aren't created until absolutely necessary.
    We can describe a generator as being lazy. A list, for example, actually contains
    objects. A generator expression can operate similarly to a list, but the objects
    aren't really created until needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator functions can only be used once. A list can be reused indefinitely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first restriction applies in particular to the `len()` function. This function
    works for lists, tuples, and sets. However, it doesn't work for generators. There's
    no way to know how many items will eventually be created by a generator, so `len()`
    can't return the size.
  prefs: []
  type: TYPE_NORMAL
- en: The second restriction is mostly relevant when we try to print the results of
    a generator. We'll see something such as `<generator object <genexpr> at 0x1007b4460>`,
    until we actually evaluate the generator and create the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third restriction is less obvious. We will to need an example. Let''s try
    to work around the `len()` problem by defining a `count()` function that counts
    items yielded by a generator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will add up a sequence of 1s instead of the sequence of actual values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems to work, right? Based on this one experiment, we can try to rewrite
    the `mean()` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We used `count()`, which works with a generator expression, instead of `len()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use it, we get a `ZeroDivisionError: float division by zero` error.
    Why didn''t `count()` work in the context of `mean()`?'
  prefs: []
  type: TYPE_NORMAL
- en: This reveals the one-use-only rule. The `sum()` function consumed the generator
    expression. When the time to evaluate the `count()` function came, there was no
    data left. The generator was empty, `sum( 1 for x in [] )` was zero.
  prefs: []
  type: TYPE_NORMAL
- en: What can we do?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three choices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can write our own more sophisticated `sum()` that produces both sum and count
    from one pass through the generator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, we can use the `itertools` library to put a *tee* fitting into
    the generator pipeline so that we have two copies of the iterable. This is actually
    a very efficient solution, but it's also a bit advanced for field agents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More simply, we can create an actual list object from the generator. We can
    use the `list()` function or wrap the generator expression in `[]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first two choices are too complex for our purposes. The third is really
    simple. We can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By including `[]`, we created a list object from the generator. We can get both
    `sum()` and `len()` from the list object. This approach works very nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'It points out the importance of writing docstrings in our functions. We really
    need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We put a reminder here that the function works with an object that is a sequence,
    but it doesn't work with a generator expression or other objects that are merely
    iterable. When we use `help(mean)`, we'll see the reminder we left in the docstring.
  prefs: []
  type: TYPE_NORMAL
- en: There's a hierarchy of concepts here. Being iterable is a very general feature
    of many kinds of Python objects. A sequence is one of many kinds of iterable Python
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the value in the middle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The median value is in the middle of a sorted collection of values. In order
    to find the median, we need to sort the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an easy function to compute the median of a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This includes the common technique of averaging the two middlemost values when
    there's an even number of samples.
  prefs: []
  type: TYPE_NORMAL
- en: We used `len(s)%2` to determine if the sequence length is odd. In two separate
    places, we compute `len(s)//2`; seems like we might be able to simplify things
    using the `divmod()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This change removes a little bit of the duplicated code that computes `len(s)//2`,
    but is it really more clear?
  prefs: []
  type: TYPE_NORMAL
- en: 'Two potential issues here are the overheads associated with sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: First, sorting means a lot of comparisons between items. As the size of the
    list grows, the number of items compared grows more quickly. Also, the `sorted()`
    function produces a copy of the sequence, potentially wasting memory when processing
    a very large list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The alternative is a clever variation on the quickselect algorithm. For field
    agents, this level of sophistication isn't necessary. More information is available
    at [http://en.wikipedia.org/wiki/Quickselect](http://en.wikipedia.org/wiki/Quickselect).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the most popular value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The modal value is the single most popular value in the collection. We can compute
    this using the `Counter` class in the `collections` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a `mode` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `most_common()` method of a `Counter` class returns a sequence of two-tuples.
    Each tuple has the value and the number of times it occurred. For our purposes,
    we only wanted the value, so we had to take the first element from the sequence
    of two-tuples. Then, we had to break the pair down into the value and the counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with a demonstration is that our datasets are really small and
    don''t have a proper mode. Here''s a contrived example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that the `mode` function works, even though it doesn't make
    sense for our cheese consumption and death rate data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Python modules and applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We relied heavily on modules in the Python library. Additionally, we added several
    packages, including Pillow and BeautifulSoup. The question should arise, *can
    we create our own module?*
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is, of course, *yes*. A Python module is simply a file. It turns
    out that each example script has been a module. We can look a little more deeply
    at how we can make our own modules of reusable programming. When we look at Python
    programs, we observe three kinds of files:'
  prefs: []
  type: TYPE_NORMAL
- en: Library modules that are purely definitional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application modules that do the real work of our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid modules that are both applications and can be used as libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essential ingredient of creating a Python module is separating the *real
    work* of the top-level script from the various definitions that support this real
    work. All our examples of definitions have been functions created with the `def`
    statement. The other import examples of definitions are `class` definitions, which
    we'll discuss in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a module of only definitions, we simply put all the function and class
    definitions into a file. We have to give the file a name that is an acceptable
    Python variable name. This means that filenames should look like Python variables;
    letters, digits, and `_` are perfectly legal. Characters that Python uses as an
    operator (`+`, `-`, `/`, and so on) may be allowed by our OS for a filename, but
    these characters cannot be used to name a module file.
  prefs: []
  type: TYPE_NORMAL
- en: The file name must end in `.py`. This is not part of the module name; it's for
    the benefit of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: We might collect our statistics functions into a file named `stats.py`. This
    file defines a module named `stats`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import the entire suite of functions or individual functions, or we
    can import the module as a whole. Use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By using this, we import all the functions (and classes) defined in the stats
    module. We can simply use names such as `mean( some_list )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider we use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We imported two specific functions from the stats module. We ignored any other
    definition that might be available in that module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will import the module, but it won't put any of the names into the global
    namespace that we usually work with. All the names in the `stats` module must
    be accessed with a qualified name, such as `stats.mean( some_list )`. In very
    complex scripts, the use of qualified names helps clarify where a particular function
    or class was defined.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to create an application with a **command-line interface**
    (**CLI**) is to write a file and run it from the command line. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When we enter this in the terminal window or command window, we use the OS `python3`
    command and provide a filename. In Windows, the name `python.exe` is sometimes
    used for Python 3, so the command may be `python basic_stats.py`. In most other
    OSes, there will often be both the `python3` and `python3.3` commands. On Mac
    OS X, the `python` command may refer to the old `Python2.7` that is part of Mac
    OS X.
  prefs: []
  type: TYPE_NORMAL
- en: We can determine the difference by using the `python -V` command to see what
    version is bound to the name `python`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted previously, we want to separate our definitions into one file, and
    then put the real work in another file. When we look inside `basic_stats.py`,
    we might find this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The file starts with a triple-quoted string that—like the docstring for a function—is
    the docstring for a module. We imported some functions from another module.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we completed some processing using the functions that we imported. This
    is a common structure for a simple command-line module.
  prefs: []
  type: TYPE_NORMAL
- en: We can also run this via the command `python3 -m basic_stats`. This will use
    Python's internal search path to locate the module, and then run that module.
    Running a module is subtly different from running a file, but the net effect is
    the same; the file produces the output we designed via the `print()` statements.
    For details on how the `-m` option works, consult the documentation for the `runpy`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hybrid module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two significant improvements we can make to the `basic_stats.py`
    module shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we put all the processing into a function definition. We call it `analyze_cheese_deaths`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the addition of an `if` statement to determine the context in
    which the module is being used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the more sophisticated version of `basic_stats.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating a function definition to encapsulate the real work gives us a way to
    extend or reuse this script. We can reuse a function definition (via `import`)
    more easily than we can reuse a top-level script.
  prefs: []
  type: TYPE_NORMAL
- en: The `__name__` variable is a global that Python sets to show the processing
    context. The top-level module—the one named on the command line—has the `__name__`
    variable set to `__main__`. All other module imports have the `__name__` variable
    set to the module name.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, the global variable, `__name__`, has double-underscores before and after.
    This marks it as part of the machinery of Python. Similarly, the string value
    for the main module name, `__main__`, involves double underscores.
  prefs: []
  type: TYPE_NORMAL
- en: This technique allows us to create a module that can be run as a command and
    also be imported to provide definitions. The idea is to promote reusable programming.
    Each time we set out to solve a problem, we don't need to reinvent the wheel and
    other related technology. We should import prior work and build on that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own classes of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two lists of data values that HQ asked us to get—cheese consumption and
    W75 deaths—form two objects that are very similar. They seem to be two instances
    of the same class of things.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the class of things seems to have *annual statistics*. They're
    collections with a consistent structure of a year and a measurement. Both these
    annual statistics objects have a common set of operations. Indeed, the operations
    are pretty tightly bound to the measurement, and they are not at all bound to
    the year number.
  prefs: []
  type: TYPE_NORMAL
- en: Our collection of statistical functions is not very tightly bound to our data
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: We can improve the binding between data structure and processing through a class
    definition. If we define the general features of a class of objects that we can
    call *annual statistics*, we can create two instances of this class and use the
    defined methods on the unique data of each instance. We can easily reuse our method
    functions by having multiple objects of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: A class definition in Python is a collection of method functions. Each method
    function definition has an additional parameter variable, usually named `self`,
    which must be the first parameter to each function. The self variable is how we
    can access the attribute values that are unique to each instance of the class
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we might define a class for the simple statistics HQ is asking
    us to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `class` statement provides a name for our definition. Within the indented
    body of the class statement, we provide `def` statements for each method function
    within this class. Each `def` statement contains the instance variable, `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve defined two methods with special names, as shown in the following list.
    These names have double underscores, they''re fixed by Python, and we must use
    exactly these names in order to have objects initialized or printed properly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__init__()` method is used implicitly to initialize the instance when
    it''s created. We''ll show an example of instance creation in the following section.
    When we create an `AnnualStats` object, three internal attributes are created,
    as shown in the following list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.year_measure` instance variable contains the data provided as an argument
    value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.data` instance variable contains just the data values extracted from
    the year-data two-tuples
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.counter` instance variable contains a `Counter` object built from
    the data values
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__repr__()` method is used implicitly when we attempt to print the object.
    We returned the representation of the internal `self.year_measure` instance variable
    as the representation for the instance as a whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other method functions look similar to the standalone function definitions
    shown previously. Each of these method functions depend on having the instance
    variables properly initialized by the `__init__()` method. These names are entirely
    part of our software design; we can call them anything that's syntactically legal
    and meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: Using a class definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how we can use our `AnnualStats` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We built two instances of the `AnnualStats` class. The `deaths` object is an
    `AnnualStats` object built from the year-death set of data. Similarly, the cheese
    object is an `AnnualStats` object built from the cheese consumption set of data.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the `AnnualStats.__init__()` method is evaluated with the given
    argument value. When we evaluate `AnnualStats( get_deaths() )`, the result of
    `get_deaths()` is provided to `AnnualStats.__init__()` as the value of the `year_measure`
    parameter. The statements of the `__init__()` method will then set the values
    of the three instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: When we evaluate `deaths.min_year()`, this will evaluate the `AnnualStats.min_year()`
    method function. The `self` variable will be `deaths`. This means that `self.year_measure`
    denotes the object originally created by `get_deaths()`.
  prefs: []
  type: TYPE_NORMAL
- en: When we evaluate `deaths.mean()`, this will evaluate the `AnnualStats.min_year()`
    method function with the `self` variable referring to deaths. This means `deaths.data`
    is the sorted sequence we derived from the object originally created by `get_deaths()`.
  prefs: []
  type: TYPE_NORMAL
- en: Each instance (`deaths`, `cheese`) refers to the instance variables created
    by the `__init__()` method. A class encapsulates the processing of the method
    functions with the various instance variables. The encapsulation idea can help
    us design software that is more tightly focused and less likely to have confusing
    bugs or inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons and correlations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important statistical question centers around correlation between variables.
    We often wonder if two sequences of values correlate with each other. If we have
    variables that correlate, perhaps we've found an interesting causal relationship.
    We might be able to use one variable to predict the values of another variable.
    We might also be able to prove that they're independent and have nothing to do
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential statistical tool for this is the *coefficient of correlation*.
    We have several ways to compute this. One solution is to download NumPy or SciPy
    from the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html](http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The correlation algorithms, however, aren't too complex. Implementing these
    two calculations will build up our basic data gathering espionage skills. We'll
    build some more basic statistical functions. Then, we'll build the correlation
    calculation, which will depend on other statistical functions.
  prefs: []
  type: TYPE_NORMAL
- en: The essential numerical depends on computing means and standard deviations.
    We looked at the mean calculation previously. We'll add the standard deviation
    to our bag of tricks. Given the standard deviation, we can standardize each value.
    We'll compute the distance from the mean using the standard deviation as the measurement
    of distance. We can then compare standardized scores to see if two sets of data
    correlate.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the standard deviation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compute the correlation coefficient, we need another descriptive statistic
    for a set of data: the standard deviation. This is a measure of how widely dispersed
    the data is. When we compute the mean, we find a center for the data. The next
    question is, *how tightly do the values huddle around the center?*'
  prefs: []
  type: TYPE_NORMAL
- en: If the standard deviation is small, the data is tightly clustered. If the standard
    deviation is large, the data is spread all over the place. The standard deviation
    calculation gives us a numeric range that brackets about two-third of the data
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Having the standard deviation lets us spot unusual data. For example, the mean
    cheese consumption is 31.8 pounds per person. The standard deviation is 1.27 pounds.
    We expect to see much of the data huddled within the range of 31.8 ± 1.27, that
    is, between 30.53 and 33.07\. If our informant tries to tell as the per capita
    cheese consumption is 36 pounds in 2012, we have a good reason to be suspicious
    of the report.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few variations to the theme of computing a standard deviation. There
    are some statistical subtleties, also, that relate to whether or not we have the
    entire population or just a sample. Here's one of the standard formulae ![Computing
    the standard deviation](img/0420OS_05_04.jpg). The symbol ![Computing the standard
    deviation](img/0420OS_05_05.jpg) represents the standard deviation of some variable,
    ![Computing the standard deviation](img/0420OS_05_06.jpg). The symbol ![Computing
    the standard deviation](img/0420OS_05_07.jpg) represents the mean of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: We have a method function, `mean()`, which computes the ![Computing the standard
    deviation](img/0420OS_05_07.jpg) value. We need to implement the standard deviation
    formula.
  prefs: []
  type: TYPE_NORMAL
- en: The standard deviation formula uses the `math.sqrt()` and `sum()` functions.
    We'll rely on using `import math` in our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can directly translate the equation into Python. Here''s a method function
    we can add to our `AnnualStat` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We evaluated the `mean()` method function to get the mean, shown as ![Computing
    the standard deviation](img/0420OS_05_07.jpg), and assigned this to `μ_x` (yes,
    Greek letters are legal for Python variable names; if your OS doesn't offer ready
    access to extended Unicode characters, you might want to use `mu` instead). We
    also evaluated `len(data)` to get the value of `n`, the number of elements in
    the collection.
  prefs: []
  type: TYPE_NORMAL
- en: We can then do a very literal translation from math-speak to Python. For example,
    the ![Computing the standard deviation](img/0420OS_05_08.jpg) becomes `sum((x-μ_x)**2
    for x in self.data)`. This kind of literal match between mathematical notation
    and Python makes it easy to vet Python programming to be sure it matches the mathematical
    abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another version of standard deviation, based on a slightly different
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This has an elegant symmetry to it. The formula looks like ![Computing the standard
    deviation](img/0420OS_05_09.jpg). It's not efficient or accurate any more. It's
    just sort of cool because of the symmetry between ![Computing the standard deviation](img/0420OS_05_10.jpg),
    ![Computing the standard deviation](img/0420OS_05_11.jpg), and ![Computing the
    standard deviation](img/0420OS_05_12.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Computing a standardized score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have the standard deviation, we can standardize each measurement in
    the sequence. This standardized score is sometimes called a Z score. It's the
    number of standard deviations a particular value lies from the mean.
  prefs: []
  type: TYPE_NORMAL
- en: In ![Computing a standardized score](img/0420OS_05_13.jpg), the standardized
    score, ![Computing a standardized score](img/0420OS_05_14.jpg), is the difference
    between the score, ![Computing a standardized score](img/0420OS_05_15.jpg), and
    the mean, ![Computing a standardized score](img/0420OS_05_07.jpg), divided by
    the standard deviation, ![Computing a standardized score](img/0420OS_05_05.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: If we have a mean, ![Computing a standardized score](img/0420OS_05_16.jpg),
    of 31.8 and a standard deviation, ![Computing a standardized score](img/0420OS_05_17.jpg),
    of 1.27, then a measured value of 29.87 will have a Z score of -1.519\. About
    30 percent of the data will be outside 1 standard deviation from the mean. When
    our informant tries to tell us that consumption jumped to 36 pounds of cheese
    per capita, we can compute the Z score for this, 3.307, and suggest that it's
    unlikely to be valid data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standardizing our values to produce scores is a great use of a generator expression.
    We''ll add this to our class definition too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We computed the mean of our data and assigned it to `μ_x`. We computed the standard
    deviation and assigned it to `σ_x`. We used a generator expression to evaluate
    `(x-μ_x)/σ_x` for each value, `x`, in our data. Since the generator was in `[]`,
    we will create a new list object with the standardized scores.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can show how this works with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get a sequence like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Comparing a sequence and an iterable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we look at the result of the `stdscore()` method, we have a choice of what
    to return. In the previous example, we returned a new list object. We don't really
    need to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this in the function to return a generator instead of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the function is the same. It's good to give this version a different
    name. Call the old one `stdscore2()` so that you can compare list and generator
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: The generator `stdscore()` function now returns an expression that can be used
    to generate the values. For most of our calculations, there's no practical difference
    between an actual list object and an iterable sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three differences that we''ll notice:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we can't use `len()` on the generator results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, a generator doesn't generate any data until we use it in a `for` loop
    or to create a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thirdly, an iterable can only be used once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try to see how this works with something simple like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll see the generator expression, not the values that are generated. Here''s
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to do this to collect the generated values into an object. The `list()`
    function does this nicely. Here''s what we can do to evaluate the generator and
    actually generate the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will evaluate the generator, producing a list object that we can print.
  prefs: []
  type: TYPE_NORMAL
- en: Computing a coefficient of correlation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One important question that arises when comparing two sequences of data is
    how well they correlate with each other. When one sequence trends up, does the
    other? Do they trend at the same rate? We can measure this correlation by computing
    a coefficient based on the products of the standardized scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Computing a coefficient of correlation](img/0420OS_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, ![Computing a coefficient of correlation](img/0420OS_05_19.jpg)
    is the standardized score for each individual value, ![Computing a coefficient
    of correlation](img/0420OS_05_20.jpg). We do the same calculation for the other
    sequences and compute the product of each pair. The average of the product of
    the various standardized scores will be a value between +1 and -1\. A value near
    +1 means the two sequences correlate nicely. A value near -1 means the sequences
    oppose each other. One trends up when the other trends down. A value near 0 means
    the sequences don't correlate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a function that computes the correlation between two instances of `AnnualStat`
    data collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We used the `stdscore()` method of each `AnnualStat` object to create a sequence
    of standardized score values.
  prefs: []
  type: TYPE_NORMAL
- en: We created a generator using the `zip()` function that will yield two-tuples
    from two separate sequences of scores. The mean of this sequence of products is
    the coefficient correlation between the two sequences. We computed the mean by
    summing and dividing by the length, `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing high-quality software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do we know these various statistical functions work? This is potentially
    very tricky programming, with lots of opportunities to have things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best tool to make sure that software works is unit testing. The idea behind
    unit testing is to break a module down into separate units—usually functions or
    classes—and test each unit in isolation. Python gives us two ways to perform unit
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Putting examples into docstrings for modules, functions, and classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing separate `unittest.TestCase` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most secret agents will be very happy with docstring test cases. They're easy
    to write. We put them in the docstring right in front of the rest of the code.
    They're visible when we use the `help()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We create these docstring test cases by copying and pasting known correct results
    from interactive Python. The copy and paste will include the `>>>` prompt to make
    it easy to find the examples. Of course, we also include the output that's expected.
    Once we include this in the docstring, the `doctest` module will find and use
    the example.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we need to fake the expected results. It's actually common to
    have worked out what the answer is supposed to be before having written any working
    Python code. If we're sure the docstring example has the expected right answer,
    we can leverage this and use it to help debug the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple function we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We added the example interaction to the function's docstring. We included what
    looks like a copy and paste of the sequence of interactions that will exercise
    this function. In some cases, we make the sequence up based on what we plan to
    write, not what we've written.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can exercise the several different ways. The easiest is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We run the `doctest` module as a top-level main application. The single argument
    to this application is the name of a Python application that has doctest examples
    pasted into docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no output if everything works. If we''re curious, we can ask for more
    verbose output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will produce voluminous output that shows each test that was found in the
    docstrings in the module.
  prefs: []
  type: TYPE_NORMAL
- en: The other techniques include building a self-testing module and writing a separate
    script that just runs tests.
  prefs: []
  type: TYPE_NORMAL
- en: Building a self-testing module and a test module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the techniques that works out nicely is using the `__name__ == "__main__"`
    technique to add a test script to a library module. We'll evaluate the `doctest.testmod()`
    function to test the functions and classes defined in a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If this module is being run from the command line, it's the main module, and
    global `__name__` will be set to `"__main__"`. When this is true, we can import
    the doctest module and evaluate `doctest.testmod()` to confirm that everything
    else in the module works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also write a separate test script. We might call it "`test.py`"; it
    might be as short as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This short script imported the doctest module. It also imported the module we're
    going to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `doctest.testmod()` function to locate doctest examples in the
    given module. The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is a confirmation that there were two lines of `>>>` examples, and everything
    worked perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating more sophisticated tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when we have to be a little cautious of the doctest example
    output. These are situations where Python's behavior is not specified to the level
    of detail where we can copy and paste interactive results without thinking about
    what we're doing.
  prefs: []
  type: TYPE_NORMAL
- en: When working with dict and set collections, the order of the items is not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: For a dict, a doctest string needs to include `sorted()` to force a specific
    order. It's essential to use `sorted(some_dict.items())` instead of simply using
    `some_dict`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same consideration applies to sets. We must use something like `sorted(some_set)`
    instead of `some_set`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some internal functions such as `id()` and `repr()` can display a physical
    memory address that''s unlikely to be the same each time we run the tests. There''s
    a special comment we can include that will alert doctest to skip the details.
    We''ll include `#doctest: +ELLIPSIS` and replace the ID or address with `...`
    (three dots).'
  prefs: []
  type: TYPE_NORMAL
- en: Another place we might use ellipsis is to shorten up a very long bit of output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might have a module docstring like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: A module docstring must be (almost) the first lines in a module file. The only
    line that might come before the module docstring is a one-line `#!` comment. A
    `#!` comment line, if present, is aimed at the OS shell and identifies the rest
    of the file as being a Python script, not a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `# doctest: +ELLIPSIS` directive on one of our tests. The result
    wasn''t complete, it had "`...`" in the expected results to show the parts doctest
    should ignore.'
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point values may not be identical for different processors and OSes.
    We have to be careful to show floating-point numbers with formatting or rounding.
    We might use `"{:.4f}".format(value)` or `round(value,4)` to assure that the insignificant
    digits are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Adding doctest cases to a class definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at doctests in modules and functions. We can put doctests in several
    places in a class definition. This is because we have several places to put docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: The class as a whole can have a docstring right at the top. It's the first line
    after the `class` statement. Also, each individual method within a class can have
    its own private docstring.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might, for example, include a comprehensive docstring at the beginning of
    our class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This provides a complete rundown of all of the features of this class in one
    tidy summary.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our sample data leads to a standard deviation of exactly 2.0\. This trick shows
    that with clever test data, we can circumvent some of the doctest float-point
    output limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems – analyzing some interesting datasets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the correlation coefficient between per-capita cheese consumption and
    death code W75 (accidental suffocation and strangulation in bed) for the years
    2000 to 2009?
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the cheese data came from [http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls](http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls).
  prefs: []
  type: TYPE_NORMAL
- en: This is a pesky bit of data because it's in a proprietary spreadsheet format.
    As much as we dislike copying and pasting, there's no other easy way to get this
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The strangulation in bed data comes from cause of death W75 grouped by year.
    The data request process starts at [http://wonder.cdc.gov/controller/datarequest/D76](http://wonder.cdc.gov/controller/datarequest/D76).
    There will be some further espionage work required to enter a request for data.
    For some additional help, check [http://wonder.cdc.gov/wonder/help/ucd.html](http://wonder.cdc.gov/wonder/help/ucd.html).
  prefs: []
  type: TYPE_NORMAL
- en: How the correlation possibly be so high?
  prefs: []
  type: TYPE_NORMAL
- en: What is it about cheese consumption and death by strangulation in bed that leads
    to this amazing correlation?
  prefs: []
  type: TYPE_NORMAL
- en: Getting some more data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HQ appears to be working on a theory about dairy products. The cheese spreadsheet
    also has mozzarella cheese consumption over the same period of time—2000 to 2009.
  prefs: []
  type: TYPE_NORMAL
- en: We've been ordered to get details on civil engineering doctorates awarded during
    this period.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some initial espionage turned up this set of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.nsf.gov/statistics/infbrief/nsf12303/](http://www.nsf.gov/statistics/infbrief/nsf12303/)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a tricky table to parse. It's a bit more complex because the years are
    in columns and the data we're looking for is in a particular row, a row with `th.text
    == "Civil engineering"`. The heading for the table as a whole is in a row with
    `th.text == "Field"`. This means that the navigation will be rather complex to
    locate the `Field` row and the `Civil engineering` rows of the proper table on
    this page.
  prefs: []
  type: TYPE_NORMAL
- en: How does annual per-capita mozzarella cheese consumption correlate with civil
    engineering doctorates?
  prefs: []
  type: TYPE_NORMAL
- en: How can the correlation possibly be so high?
  prefs: []
  type: TYPE_NORMAL
- en: What is it about cheese, death, and doctorates?
  prefs: []
  type: TYPE_NORMAL
- en: Further research
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Is this just a spurious correlation?
  prefs: []
  type: TYPE_NORMAL
- en: Are there other correlations like this?
  prefs: []
  type: TYPE_NORMAL
- en: What else can we learn from [http://www.tylervigen.com/](http://www.tylervigen.com/)?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how we can easily implement sophisticated statistical analyses as short
    pieces of Python programming. We applied basic statistical insights to all our
    intelligence gathering.
  prefs: []
  type: TYPE_NORMAL
- en: We learned to design Python modules. This allows us to extend the Python standard
    library with our own more specialized modules. We can now easily package reusable
    software in modules for our own purposes as well as for distribution to our network
    of agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to designing modules, we also saw how to write tests to confirm
    that our software really works. Software can''t be trusted unless there are formal
    unit tests to confirm that things are behaving correctly. We saw the essential
    ingredients of the Python language, the standard library, and the ecosystem of
    related projects and tools. The Python language is quite simple: it only has about
    22 statements, and we saw examples of almost all of them.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, each secret agent's areas of interest and expertise will start
    to diverge. There are numerous packages, libraries, and application areas that
    are open for exploration.
  prefs: []
  type: TYPE_NORMAL
- en: Since our focus is on getting field agents to be productive, we were studiously
    avoiding more serious software development issues. In particular, we avoided the
    subject of object-oriented design. An agent that needs to do more sophisticated
    processing will need to write more sophisticated software. A book like *Python
    3 Object Oriented Programming*, *Dusty Phillips*, *Packt Publishing*, is essential
    to learn this important technique. Check [http://www.packtpub.com/python-3-object-oriented-programming/book](http://www.packtpub.com/python-3-object-oriented-programming/book).
  prefs: []
  type: TYPE_NORMAL
- en: An agent's interests and abilities will often lead in different directions.
    Some agents will want to build websites. A book like *Python 3 Web Development
    Beginner's Guide*, *Michel Anders*, *Packt Publishing*, can help. Some agents
    will want to build interactive applications; a book like *Instant Pygame for Python
    Game Development How-to*, *Ivan Idris*, *Packt Publishing*, can help master the
    Pygame framework. This framework is for more than just games.
  prefs: []
  type: TYPE_NORMAL
- en: Some agents will pursue natural language processing. A book like *Python 3 Text
    Processing with NLTK 3 Cookbook*, *Jacob Perkins*, *Packt Publishing*, can help.
    Other agents will pursue more complex media using *Python Multimedia*, *Ninad
    Sathaye*, *Packt Publishing* or perhaps *Practical Maya Programming with Python*,
    *Robert Galanakis*, *Packt Publishing*. Agents interested in geospatial analysis
    might pursue *Programming ArcGIS 10.1 with Python Cookbook*, *Eric Pimpler*, *Packt
    Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: Skilled agents will find that Python can be used for a wide variety of missions.
  prefs: []
  type: TYPE_NORMAL
